<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构</title>
      <link href="/2025/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2025/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-数组-Array"><a href="#1-数组-Array" class="headerlink" title="1. 数组 (Array)"></a>1. 数组 (Array)</h1><p><strong>特点</strong>：连续内存，随机访问 O(1)，插入&#x2F;删除 O(n)。</p><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找（线性查找）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == target) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（指定位置）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insert(<span class="type">int</span>[] arr, <span class="type">int</span> pos, <span class="type">int</span> val) &#123;</span><br><span class="line">    <span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; newArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == pos) newArr[i] = val;</span><br><span class="line">        <span class="keyword">else</span> newArr[i] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（指定位置）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] delete(<span class="type">int</span>[] arr, <span class="type">int</span> pos) &#123;</span><br><span class="line">    <span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == pos) <span class="keyword">continue</span>;</span><br><span class="line">        newArr[j++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i]; arr[i] = arr[j]; arr[j] = tmp;</span><br><span class="line">        i++; j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-链表-Linked-List"><a href="#2-链表-Linked-List" class="headerlink" title="2. 链表 (Linked List)"></a>2. 链表 (Linked List)</h1><p><strong>特点</strong>：动态存储，插入&#x2F;删除 O(1)，随机访问 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next)</span><br><span class="line">        System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（头插）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">insertHead</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    node.next = head;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（指定节点后）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertAfter</span><span class="params">(ListNode node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    newNode.next = node.next;</span><br><span class="line">    node.next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（按值）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">delete</span><span class="params">(ListNode head, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.val == target) <span class="keyword">return</span> head.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.next.val == target) &#123;</span><br><span class="line">            p.next = p.next.next; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-栈-Stack"><a href="#3-栈-Stack" class="headerlink" title="3. 栈 (Stack)"></a>3. 栈 (Stack)</h1><p><strong>特点</strong>：LIFO，常用数组或链表实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123; list.addLast(val); &#125; <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.removeLast(); &#125;   <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.getLast(); &#125;     <span class="comment">// 查看栈顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.isEmpty(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-队列-Queue"><a href="#4-队列-Queue" class="headerlink" title="4. 队列 (Queue)"></a>4. 队列 (Queue)</h1><p><strong>特点</strong>：FIFO，可以用链表或循环数组实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">int</span> val)</span> &#123; list.addLast(val); &#125; <span class="comment">// 入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.removeFirst(); &#125; <span class="comment">// 出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.getFirst(); &#125;       <span class="comment">// 查看队首</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.isEmpty(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双端队列 Deque</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">deque.addFirst(<span class="number">1</span>); <span class="comment">// 头插</span></span><br><span class="line">deque.addLast(<span class="number">2</span>);  <span class="comment">// 尾插</span></span><br><span class="line">deque.removeFirst();</span><br><span class="line">deque.removeLast();</span><br></pre></td></tr></table></figure><hr><h1 id="5-树-Tree"><a href="#5-树-Tree" class="headerlink" title="5. 树 (Tree)"></a>5. 树 (Tree)</h1><p>以 <strong>二叉树</strong> 为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历 (根-左-右)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preorder(root.left);</span><br><span class="line">    preorder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历 (左-根-右)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root.left);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inorder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历 (左-右-根)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postorder(root.left);</span><br><span class="line">    postorder(root.right);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历 (BFS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) q.add(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) q.add(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="6-堆-Heap"><a href="#6-堆-Heap" class="headerlink" title="6. 堆 (Heap)"></a>6. 堆 (Heap)</h1><p>常用 <strong>最小堆 &#x2F; 最大堆</strong>，一般用数组实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">minHeap.add(<span class="number">3</span>);</span><br><span class="line">minHeap.add(<span class="number">1</span>);</span><br><span class="line">minHeap.add(<span class="number">5</span>);</span><br><span class="line">System.out.println(minHeap.poll()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">maxHeap.add(<span class="number">3</span>);</span><br><span class="line">maxHeap.add(<span class="number">1</span>);</span><br><span class="line">maxHeap.add(<span class="number">5</span>);</span><br><span class="line">System.out.println(maxHeap.poll()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><hr><h1 id="7-图-Graph"><a href="#7-图-Graph" class="headerlink" title="7. 图 (Graph)"></a>7. 图 (Graph)</h1><p>常见表示：<strong>邻接表</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        adj.computeIfAbsent(u, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(v);</span><br><span class="line">        adj.computeIfAbsent(v, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(u); <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS 遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(start);</span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> nei : adj.getOrDefault(node, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(nei)) &#123;</span><br><span class="line">                    visited.add(nei);</span><br><span class="line">                    q.add(nei);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DFS 遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        dfsHelper(start, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfsHelper</span><span class="params">(<span class="type">int</span> node, Set&lt;Integer&gt; visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(node)) <span class="keyword">return</span>;</span><br><span class="line">        visited.add(node);</span><br><span class="line">        System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nei : adj.getOrDefault(node, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">            dfsHelper(nei, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令大全</title>
      <link href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="📌-一、Linux-常见命令大全"><a href="#📌-一、Linux-常见命令大全" class="headerlink" title="📌 一、Linux 常见命令大全"></a>📌 一、Linux 常见命令大全</h1><h3 id="🔹-文件与目录操作"><a href="#🔹-文件与目录操作" class="headerlink" title="🔹 文件与目录操作"></a>🔹 文件与目录操作</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>ls</code></td><td>列出目录内容</td><td><code>ls -al</code> 显示隐藏文件和详细信息</td></tr><tr><td><code>pwd</code></td><td>显示当前目录</td><td><code>pwd</code></td></tr><tr><td><code>cd</code></td><td>切换目录</td><td><code>cd /usr/local</code></td></tr><tr><td><code>mkdir</code></td><td>创建目录</td><td><code>mkdir -p /data/logs</code></td></tr><tr><td><code>rmdir</code></td><td>删除空目录</td><td><code>rmdir old</code></td></tr><tr><td><code>rm</code></td><td>删除文件&#x2F;目录</td><td><code>rm -rf /tmp/test</code></td></tr><tr><td><code>cp</code></td><td>复制文件&#x2F;目录</td><td><code>cp a.txt /tmp/</code>，<code>cp -r dir1 dir2</code></td></tr><tr><td><code>mv</code></td><td>移动&#x2F;重命名</td><td><code>mv old.txt new.txt</code></td></tr><tr><td><code>find</code></td><td>查找文件</td><td><code>find / -name &quot;*.log&quot;</code></td></tr><tr><td><code>locate</code></td><td>快速查找文件（需 <code>updatedb</code>）</td><td><code>locate nginx.conf</code></td></tr></tbody></table><hr><h3 id="🔹-文件查看与编辑"><a href="#🔹-文件查看与编辑" class="headerlink" title="🔹 文件查看与编辑"></a>🔹 文件查看与编辑</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>cat</code></td><td>查看文件内容</td><td><code>cat file.txt</code></td></tr><tr><td><code>tac</code></td><td>反向输出</td><td><code>tac file.txt</code></td></tr><tr><td><code>less</code></td><td>分页查看</td><td><code>less /var/log/syslog</code></td></tr><tr><td><code>head</code></td><td>查看前 N 行</td><td><code>head -n 20 file.log</code></td></tr><tr><td><code>tail</code></td><td>查看末尾 N 行</td><td><code>tail -f app.log</code> 实时跟踪</td></tr><tr><td><code>wc</code></td><td>统计行、字数、字符数</td><td><code>wc -l file.txt</code></td></tr><tr><td><code>nano/vim</code></td><td>编辑文件</td><td><code>vim nginx.conf</code></td></tr></tbody></table><hr><h3 id="🔹-用户与权限"><a href="#🔹-用户与权限" class="headerlink" title="🔹 用户与权限"></a>🔹 用户与权限</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>whoami</code></td><td>当前用户</td><td><code>whoami</code></td></tr><tr><td><code>id</code></td><td>用户 ID 和组 ID</td><td><code>id root</code></td></tr><tr><td><code>useradd</code></td><td>新建用户</td><td><code>useradd -m testuser</code></td></tr><tr><td><code>passwd</code></td><td>修改密码</td><td><code>passwd testuser</code></td></tr><tr><td><code>su</code></td><td>切换用户</td><td><code>su - testuser</code></td></tr><tr><td><code>sudo</code></td><td>以 root 权限执行</td><td><code>sudo apt update</code></td></tr><tr><td><code>chmod</code></td><td>修改权限</td><td><code>chmod 755 file.sh</code></td></tr><tr><td><code>chown</code></td><td>修改属主</td><td><code>chown user:group file.txt</code></td></tr></tbody></table><hr><h3 id="🔹-系统管理"><a href="#🔹-系统管理" class="headerlink" title="🔹 系统管理"></a>🔹 系统管理</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>ps</code></td><td>查看进程</td><td>&#96;ps -ef</td></tr><tr><td><code>top</code></td><td>实时查看进程</td><td><code>top</code></td></tr><tr><td><code>htop</code></td><td>高级 top（需安装）</td><td><code>htop</code></td></tr><tr><td><code>kill</code></td><td>杀进程</td><td><code>kill -9 1234</code></td></tr><tr><td><code>df -h</code></td><td>查看磁盘使用</td><td><code>df -h</code></td></tr><tr><td><code>du -sh</code></td><td>查看目录大小</td><td><code>du -sh /var/log</code></td></tr><tr><td><code>free -h</code></td><td>查看内存使用</td><td><code>free -h</code></td></tr><tr><td><code>uptime</code></td><td>系统运行时长</td><td><code>uptime</code></td></tr><tr><td><code>uname -a</code></td><td>系统信息</td><td><code>uname -a</code></td></tr><tr><td><code>shutdown -h now</code></td><td>立刻关机</td><td><code>shutdown -r now</code> 重启</td></tr></tbody></table><hr><h3 id="🔹-网络相关"><a href="#🔹-网络相关" class="headerlink" title="🔹 网络相关"></a>🔹 网络相关</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>ping</code></td><td>测试网络连通</td><td><code>ping www.baidu.com</code></td></tr><tr><td><code>curl</code></td><td>请求 URL</td><td><code>curl -I https://www.baidu.com</code></td></tr><tr><td><code>wget</code></td><td>下载文件</td><td><code>wget http://example.com/file.zip</code></td></tr><tr><td><code>netstat -tulnp</code></td><td>查看端口占用</td><td>&#96;netstat -tulnp</td></tr><tr><td><code>ss -lntp</code></td><td>更快的端口查询</td><td><code>ss -lntp</code></td></tr><tr><td><code>scp</code></td><td>远程拷贝文件</td><td><code>scp file.txt user@host:/path/</code></td></tr><tr><td><code>ssh</code></td><td>登录远程主机</td><td><code>ssh user@192.168.1.1</code></td></tr></tbody></table><hr><h1 id="📌-二、MySQL-常见命令大全"><a href="#📌-二、MySQL-常见命令大全" class="headerlink" title="📌 二、MySQL 常见命令大全"></a>📌 二、MySQL 常见命令大全</h1><h3 id="🔹-登录与基本操作"><a href="#🔹-登录与基本操作" class="headerlink" title="🔹 登录与基本操作"></a>🔹 登录与基本操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p               <span class="comment"># 登录 MySQL</span></span><br><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p   <span class="comment"># 指定地址端口</span></span><br><span class="line"><span class="built_in">exit</span>;                          <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><h3 id="🔹-数据库操作"><a href="#🔹-数据库操作" class="headerlink" title="🔹 数据库操作"></a>🔹 数据库操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;                <span class="comment">-- 查看所有数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE testdb;        <span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE testdb;          <span class="comment">-- 删除数据库</span></span><br><span class="line">USE testdb;                    <span class="comment">-- 切换数据库</span></span><br></pre></td></tr></table></figure><h3 id="🔹-表操作"><a href="#🔹-表操作" class="headerlink" title="🔹 表操作"></a>🔹 表操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;                               <span class="comment">-- 查看表</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> users;                            <span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span></span><br><span class="line">);                                         <span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;                          <span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">ADD</span> email <span class="type">VARCHAR</span>(<span class="number">100</span>);  <span class="comment">-- 增加列</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> email;       <span class="comment">-- 删除列</span></span><br></pre></td></tr></table></figure><h3 id="🔹-数据操作-CRUD"><a href="#🔹-数据操作-CRUD" class="headerlink" title="🔹 数据操作 (CRUD)"></a>🔹 数据操作 (CRUD)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users(name, age) <span class="keyword">VALUES</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>);  <span class="comment">-- 插入</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;                             <span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">18</span>;      <span class="comment">-- 条件查询</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">25</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>;    <span class="comment">-- 更新</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>;            <span class="comment">-- 删除</span></span><br></pre></td></tr></table></figure><h3 id="🔹-用户与权限-1"><a href="#🔹-用户与权限-1" class="headerlink" title="🔹 用户与权限"></a>🔹 用户与权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;       <span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> testdb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;      <span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> testdb.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;   <span class="comment">-- 回收权限</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;                                <span class="comment">-- 删除用户</span></span><br><span class="line">FLUSH PRIVILEGES;                                    <span class="comment">-- 刷新权限</span></span><br></pre></td></tr></table></figure><h3 id="🔹-备份与恢复"><a href="#🔹-备份与恢复" class="headerlink" title="🔹 备份与恢复"></a>🔹 备份与恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p testdb &gt; testdb.sql     <span class="comment"># 导出数据库</span></span><br><span class="line">mysqldump -u root -p --all-databases &gt; all.sql</span><br><span class="line">mysql -u root -p testdb &lt; testdb.sql         <span class="comment"># 导入数据库</span></span><br></pre></td></tr></table></figure><hr><h1 id="📌-三、Git-常见命令大全"><a href="#📌-三、Git-常见命令大全" class="headerlink" title="📌 三、Git 常见命令大全"></a>📌 三、Git 常见命令大全</h1><h3 id="🔹-基础配置"><a href="#🔹-基础配置" class="headerlink" title="🔹 基础配置"></a>🔹 基础配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;YourName&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --list       <span class="comment"># 查看配置</span></span><br></pre></td></tr></table></figure><h3 id="🔹-仓库操作"><a href="#🔹-仓库操作" class="headerlink" title="🔹 仓库操作"></a>🔹 仓库操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init                          <span class="comment"># 初始化仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/xxx.git  <span class="comment"># 克隆仓库</span></span><br><span class="line">git remote -v                     <span class="comment"># 查看远程仓库</span></span><br><span class="line">git remote add origin git@github.com:xxx.git  <span class="comment"># 添加远程仓库</span></span><br></pre></td></tr></table></figure><h3 id="🔹-文件操作"><a href="#🔹-文件操作" class="headerlink" title="🔹 文件操作"></a>🔹 文件操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status        <span class="comment"># 查看状态</span></span><br><span class="line">git add file.txt  <span class="comment"># 添加文件</span></span><br><span class="line">git add .         <span class="comment"># 添加所有文件</span></span><br><span class="line">git commit -m <span class="string">&quot;描述&quot;</span>   <span class="comment"># 提交</span></span><br><span class="line">git diff          <span class="comment"># 查看修改</span></span><br><span class="line">git <span class="built_in">log</span>           <span class="comment"># 查看提交历史</span></span><br><span class="line">git reset --hard HEAD^   <span class="comment"># 回退上一个版本</span></span><br></pre></td></tr></table></figure><h3 id="🔹-分支操作"><a href="#🔹-分支操作" class="headerlink" title="🔹 分支操作"></a>🔹 分支操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch                  <span class="comment"># 查看分支</span></span><br><span class="line">git branch new-feature      <span class="comment"># 新建分支</span></span><br><span class="line">git checkout new-feature    <span class="comment"># 切换分支</span></span><br><span class="line">git checkout -b dev         <span class="comment"># 新建并切换</span></span><br><span class="line">git merge dev               <span class="comment"># 合并分支</span></span><br><span class="line">git branch -d dev           <span class="comment"># 删除分支</span></span><br></pre></td></tr></table></figure><h3 id="🔹-远程仓库"><a href="#🔹-远程仓库" class="headerlink" title="🔹 远程仓库"></a>🔹 远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main        <span class="comment"># 拉取代码</span></span><br><span class="line">git push origin main        <span class="comment"># 推送代码</span></span><br><span class="line">git push -u origin main     <span class="comment"># 关联远程分支并推送</span></span><br><span class="line">git fetch origin            <span class="comment"># 获取最新分支信息</span></span><br></pre></td></tr></table></figure><h3 id="🔹-标签管理"><a href="#🔹-标签管理" class="headerlink" title="🔹 标签管理"></a>🔹 标签管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0                        <span class="comment"># 打标签</span></span><br><span class="line">git tag                             <span class="comment"># 查看标签</span></span><br><span class="line">git push origin v1.0                <span class="comment"># 推送标签</span></span><br><span class="line">git push origin --tags              <span class="comment"># 推送所有标签</span></span><br><span class="line">git tag -d v1.0                     <span class="comment"># 删除本地标签</span></span><br><span class="line">git push origin :refs/tags/v1.0     <span class="comment"># 删除远程标签</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题单</title>
      <link href="/2025/09/11/%E9%A2%98%E5%8D%95/"/>
      <url>/2025/09/11/%E9%A2%98%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="🔹-数组（Array）"><a href="#🔹-数组（Array）" class="headerlink" title="🔹 数组（Array）"></a>🔹 数组（Array）</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(diff)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(diff), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-最大子数组和（Kadane-算法）"><a href="#2-最大子数组和（Kadane-算法）" class="headerlink" title="2. 最大子数组和（Kadane 算法）"></a>2. 最大子数组和（Kadane 算法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>], cur = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        cur = Math.max(nums[i], cur + nums[i]);</span><br><span class="line">        max = Math.max(max, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-链表（Linked-List）"><a href="#🔹-链表（Linked-List）" class="headerlink" title="🔹 链表（Linked List）"></a>🔹 链表（Linked List）</h2><h3 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1. 反转链表"></a>1. 反转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-判断链表是否有环（快慢指针）"><a href="#2-判断链表是否有环（快慢指针）" class="headerlink" title="2. 判断链表是否有环（快慢指针）"></a>2. 判断链表是否有环（快慢指针）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-栈-队列"><a href="#🔹-栈-队列" class="headerlink" title="🔹 栈 &#x2F; 队列"></a>🔹 栈 &#x2F; 队列</h2><h3 id="1-有效括号"><a href="#1-有效括号" class="headerlink" title="1. 有效括号"></a>1. 有效括号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-用栈实现队列"><a href="#2-用栈实现队列" class="headerlink" title="2. 用栈实现队列"></a>2. 用栈实现队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; in = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; out = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123; in.push(x); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123; peek(); <span class="keyword">return</span> out.pop(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (out.isEmpty()) <span class="keyword">while</span> (!in.isEmpty()) out.push(in.pop());</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123; <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-二叉树"><a href="#🔹-二叉树" class="headerlink" title="🔹 二叉树"></a>🔹 二叉树</h2><h3 id="1-二叉树的遍历（递归-迭代）"><a href="#1-二叉树的遍历（递归-迭代）" class="headerlink" title="1. 二叉树的遍历（递归 &amp; 迭代）"></a>1. 二叉树的遍历（递归 &amp; 迭代）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preorder(root.left);</span><br><span class="line">    preorder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) q.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) q.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-验证二叉搜索树"><a href="#2-验证二叉搜索树" class="headerlink" title="2. 验证二叉搜索树"></a>2. 验证二叉搜索树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(TreeNode node, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(node.left, min, node.val) &amp;&amp; helper(node.right, node.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-堆-优先队列"><a href="#🔹-堆-优先队列" class="headerlink" title="🔹 堆 &#x2F; 优先队列"></a>🔹 堆 &#x2F; 优先队列</h2><h3 id="1-数组中的第-K-大元素"><a href="#1-数组中的第-K-大元素" class="headerlink" title="1. 数组中的第 K 大元素"></a>1. 数组中的第 K 大元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">        pq.offer(n);</span><br><span class="line">        <span class="keyword">if</span> (pq.size() &gt; k) pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-图"><a href="#🔹-图" class="headerlink" title="🔹 图"></a>🔹 图</h2><h3 id="1-图的-BFS"><a href="#1-图的-BFS" class="headerlink" title="1. 图的 BFS"></a>1. 图的 BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start, List&lt;List&lt;Integer&gt;&gt; graph)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.size()];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(start);</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nei : graph.get(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[nei]) &#123;</span><br><span class="line">                visited[nei] = <span class="literal">true</span>;</span><br><span class="line">                queue.offer(nei);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-岛屿数量（DFS）"><a href="#2-岛屿数量（DFS）" class="headerlink" title="2. 岛屿数量（DFS）"></a>2. 岛屿数量（DFS）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-排序算法"><a href="#🔹-排序算法" class="headerlink" title="🔹 排序算法"></a>🔹 排序算法</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left], i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    quickSort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-动态规划（DP）"><a href="#🔹-动态规划（DP）" class="headerlink" title="🔹 动态规划（DP）"></a>🔹 动态规划（DP）</h2><h3 id="1-爬楼梯（斐波那契）"><a href="#1-爬楼梯（斐波那契）" class="headerlink" title="1. 爬楼梯（斐波那契）"></a>1. 爬楼梯（斐波那契）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-最长公共子序列（LCS）"><a href="#2-最长公共子序列（LCS）" class="headerlink" title="2. 最长公共子序列（LCS）"></a>2. 最长公共子序列（LCS）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length(), n = text2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><blockquote><p>先给两个通用辅助类（很多题会用到）：<code>ListNode</code>（链表节点）和 <code>TreeNode</code>（二叉树节点）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用辅助类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> v) &#123; val = v; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">    TreeNode(<span class="type">int</span> v) &#123; val = v; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="目录（快速跳转）"><a href="#目录（快速跳转）" class="headerlink" title="目录（快速跳转）"></a>目录（快速跳转）</h1><ol><li>数组 &#x2F; 双指针 &#x2F; 滑动窗口 &#x2F; 前缀和</li><li>排序 &#x2F; 选择（Quickselect）</li><li>链表进阶</li><li>栈进阶 &#x2F; 单调栈</li><li>队列 &#x2F; 双端队列（滑动窗口最大值）</li><li>堆（合并 K 表、数据流中位数）</li><li>树（序列化&#x2F;反序列化、LCA、最大路径和）</li><li>图（拓扑、Dijkstra、Bellman-Ford、并查集）</li><li>动态规划（LIS、背包、DP 状态压缩等）</li><li>回溯（N 皇后、组合&#x2F;子集变体）</li><li>字符串（KMP、Rabin-Karp、最小覆盖子串）</li><li>字典树 Trie</li><li>线段树 &#x2F; 树状数组（Fenwick）</li><li>位运算 &#x2F; 数学小技巧</li><li>设计题（LRU Cache）</li></ol><hr><h1 id="1-数组-双指针-滑动窗口-前缀和"><a href="#1-数组-双指针-滑动窗口-前缀和" class="headerlink" title="1. 数组 &#x2F; 双指针 &#x2F; 滑动窗口 &#x2F; 前缀和"></a>1. 数组 &#x2F; 双指针 &#x2F; 滑动窗口 &#x2F; 前缀和</h1><h3 id="1-1-最长不含重复字符的子串（LeetCode-3）"><a href="#1-1-最长不含重复字符的子串（LeetCode-3）" class="headerlink" title="1.1 最长不含重复字符的子串（LeetCode 3）"></a>1.1 最长不含重复字符的子串（LeetCode 3）</h3><p>思路：滑动窗口 + 哈希表记录字符上次出现位置。<br> 复杂度：O(n) 时间，O(min(n, charset)) 空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>]; <span class="comment">// ASCII</span></span><br><span class="line">    Arrays.fill(last, -<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        start = Math.max(start, last[c] + <span class="number">1</span>);</span><br><span class="line">        maxLen = Math.max(maxLen, i - start + <span class="number">1</span>);</span><br><span class="line">        last[c] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-最小覆盖子串（LeetCode-76）"><a href="#1-2-最小覆盖子串（LeetCode-76）" class="headerlink" title="1.2 最小覆盖子串（LeetCode 76）"></a>1.2 最小覆盖子串（LeetCode 76）</h3><p>思路：滑动窗口 + 计数表；需要满足条件时收缩左边界。<br> 复杂度：O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; t.length()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) need[c]++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, required = t.length(), minLen = Integer.MAX_VALUE, start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right++);</span><br><span class="line">        <span class="keyword">if</span> (need[c]-- &gt; <span class="number">0</span>) required--;</span><br><span class="line">        <span class="keyword">while</span> (required == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; minLen) &#123; minLen = right - left; start = left; &#125;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left++);</span><br><span class="line">            <span class="keyword">if</span> (need[d]++ &gt;= <span class="number">0</span>) required++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-子数组和等于-k（LeetCode-560）"><a href="#1-3-子数组和等于-k（LeetCode-560）" class="headerlink" title="1.3 子数组和等于 k（LeetCode 560）"></a>1.3 子数组和等于 k（LeetCode 560）</h3><p>思路：前缀和 + 哈希表记录之前出现的前缀和频次。<br> 复杂度：O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    cnt.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">        sum += x;</span><br><span class="line">        res += cnt.getOrDefault(sum - k, <span class="number">0</span>);</span><br><span class="line">        cnt.put(sum, cnt.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-三数之和最接近（LeetCode-16）"><a href="#1-4-三数之和最接近（LeetCode-16）" class="headerlink" title="1.4 三数之和最接近（LeetCode 16）"></a>1.4 三数之和最接近（LeetCode 16）</h3><p>思路：排序 + 双指针。复杂度 O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">closest</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i + <span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(closest - target)) closest = sum;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) l++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> closest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-排序-选择-Quickselect"><a href="#2-排序-选择-Quickselect" class="headerlink" title="2. 排序 &#x2F; 选择 (Quickselect)"></a>2. 排序 &#x2F; 选择 (Quickselect)</h1><h3 id="2-1-Quickselect：第-k-小-第-k-大"><a href="#2-1-Quickselect：第-k-小-第-k-大" class="headerlink" title="2.1 Quickselect：第 k 小 &#x2F; 第 k 大"></a>2.1 Quickselect：第 k 小 &#x2F; 第 k 大</h3><p>思路：类似快速排序 partition，期望线性时间。<br> 复杂度：平均 O(n)，最坏 O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123; <span class="comment">// 1-based k-th smallest</span></span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(a, l, r);</span><br><span class="line">    <span class="keyword">if</span> (k == pivot) <span class="keyword">return</span> a[k];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; pivot) <span class="keyword">return</span> quickSelect(a, l, pivot - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(a, pivot + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivotVal</span> <span class="operator">=</span> a[r], i = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt;= pivotVal) swap(a, i++, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, i, r);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; a[i] = a[j]; a[j] = t; &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-链表进阶"><a href="#3-链表进阶" class="headerlink" title="3. 链表进阶"></a>3. 链表进阶</h1><h3 id="3-1-反转-k-个一组（LeetCode-25）"><a href="#3-1-反转-k-个一组（LeetCode-25）" class="headerlink" title="3.1 反转 k 个一组（LeetCode 25）"></a>3.1 反转 k 个一组（LeetCode 25）</h3><p>思路：分段反转。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), prev = dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; node != <span class="literal">null</span>; i++) node = node.next;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> prev.next, curr = tail.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            tail.next = curr.next;</span><br><span class="line">            curr.next = prev.next;</span><br><span class="line">            prev.next = curr;</span><br><span class="line">            curr = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-链表排序（归并排序，LeetCode-148）"><a href="#3-2-链表排序（归并排序，LeetCode-148）" class="headerlink" title="3.2 链表排序（归并排序，LeetCode 148）"></a>3.2 链表排序（归并排序，LeetCode 148）</h3><p>思路：递归分治，O(n log n) 时间，O(log n) 递归栈空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow.next; slow.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> merge(sortList(head), sortList(mid));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="literal">null</span> &amp;&amp; b != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.val &lt; b.val) &#123; p.next = a; a = a.next; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; p.next = b; b = b.next; &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = (a != <span class="literal">null</span>) ? a : b;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-环的入口（LeetCode-142）"><a href="#3-3-环的入口（LeetCode-142）" class="headerlink" title="3.3 环的入口（LeetCode 142）"></a>3.3 环的入口（LeetCode 142）</h3><p>思路：Floyd 快慢指针，找到相遇点后从头与相遇点同步移动。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next; fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span> (p != slow) &#123; p = p.next; slow = slow.next; &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-栈进阶-单调栈"><a href="#4-栈进阶-单调栈" class="headerlink" title="4. 栈进阶 &#x2F; 单调栈"></a>4. 栈进阶 &#x2F; 单调栈</h1><h3 id="4-1-单调栈模板（解决最近更大-更小元素、直方图最大矩形等）"><a href="#4-1-单调栈模板（解决最近更大-更小元素、直方图最大矩形等）" class="headerlink" title="4.1 单调栈模板（解决最近更大&#x2F;更小元素、直方图最大矩形等）"></a>4.1 单调栈模板（解决最近更大&#x2F;更小元素、直方图最大矩形等）</h3><p>思路：维护单调递增或递减栈（存下标）。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以寻找每个元素右侧第一个大于它的下标为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterIndices(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">    Deque&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; arr[i] &gt; arr[st.peek()]) res[st.pop()] = i;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-逆波兰表达式求值（LeetCode-150）"><a href="#4-2-逆波兰表达式求值（LeetCode-150）" class="headerlink" title="4.2 逆波兰表达式求值（LeetCode 150）"></a>4.2 逆波兰表达式求值（LeetCode 150）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String t : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+-*/&quot;</span>.contains(t)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> st.pop(), a = st.pop();</span><br><span class="line">            <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span> : st.push(a + b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span> : st.push(a - b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span> : st.push(a * b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span> : st.push(a / b); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> st.push(Integer.parseInt(t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="5-队列-双端队列（滑动窗口最大值）"><a href="#5-队列-双端队列（滑动窗口最大值）" class="headerlink" title="5. 队列 &#x2F; 双端队列（滑动窗口最大值）"></a>5. 队列 &#x2F; 双端队列（滑动窗口最大值）</h1><h3 id="5-1-滑动窗口最大值（LeetCode-239）"><a href="#5-1-滑动窗口最大值（LeetCode-239）" class="headerlink" title="5.1 滑动窗口最大值（LeetCode 239）"></a>5.1 滑动窗口最大值（LeetCode 239）</h3><p>思路：用双端队列维护当前窗口的“候选”下标（单调递减）。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; dq.peekFirst() &lt; i - k + <span class="number">1</span>) dq.pollFirst();</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt; nums[i]) dq.pollLast();</span><br><span class="line">        dq.offerLast(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) res[i - k + <span class="number">1</span>] = nums[dq.peekFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="6-堆（PriorityQueue）"><a href="#6-堆（PriorityQueue）" class="headerlink" title="6. 堆（PriorityQueue）"></a>6. 堆（PriorityQueue）</h1><h3 id="6-1-合并-K-个有序链表（LeetCode-23）"><a href="#6-1-合并-K-个有序链表（LeetCode-23）" class="headerlink" title="6.1 合并 K 个有序链表（LeetCode 23）"></a>6.1 合并 K 个有序链表（LeetCode 23）</h3><p>思路：把每个链表头放入最小堆，循环弹出最小节点并推进。复杂度 O(N log k)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; a.val - b.val);</span><br><span class="line">    <span class="keyword">for</span> (ListNode ln : lists) <span class="keyword">if</span> (ln != <span class="literal">null</span>) pq.offer(ln);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        cur.next = node; cur = cur.next;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="literal">null</span>) pq.offer(node.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-数据流中位数（MedianFinder）"><a href="#6-2-数据流中位数（MedianFinder）" class="headerlink" title="6.2 数据流中位数（MedianFinder）"></a>6.2 数据流中位数（MedianFinder）</h3><p>思路：维护两个堆（大顶堆保存较小一半，小顶堆保存较大一半）。复杂度 add O(log n)，findMedian O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; small = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a); <span class="comment">// max-heap</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; large = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">// min-heap</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        small.offer(num);</span><br><span class="line">        large.offer(small.poll());</span><br><span class="line">        <span class="keyword">if</span> (small.size() &lt; large.size()) small.offer(large.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (small.size() &gt; large.size()) <span class="keyword">return</span> small.peek();</span><br><span class="line">        <span class="keyword">return</span> (small.peek() + large.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="7-树高级题"><a href="#7-树高级题" class="headerlink" title="7. 树高级题"></a>7. 树高级题</h1><h3 id="7-1-二叉树序列化与反序列化（LeetCode-297）"><a href="#7-1-二叉树序列化与反序列化（LeetCode-297）" class="headerlink" title="7.1 二叉树序列化与反序列化（LeetCode 297）"></a>7.1 二叉树序列化与反序列化（LeetCode 297）</h3><p>思路：BFS（层序）用特殊符号表示 null，或用前序 + 标记 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS 序列化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="literal">null</span>) sb.append(<span class="string">&quot;#,&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(n.val).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                q.offer(n.left); q.offer(n.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span> || data.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        String[] arr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(arr[<span class="number">0</span>]));</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (!arr[i].equals(<span class="string">&quot;#&quot;</span>)) &#123; node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(arr[i])); q.offer(node.left); &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (!arr[i].equals(<span class="string">&quot;#&quot;</span>)) &#123; node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(arr[i])); q.offer(node.right); &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-最近公共祖先（LCA-二叉树，LeetCode-236）"><a href="#7-2-最近公共祖先（LCA-二叉树，LeetCode-236）" class="headerlink" title="7.2 最近公共祖先（LCA, 二叉树，LeetCode 236）"></a>7.2 最近公共祖先（LCA, 二叉树，LeetCode 236）</h3><p>思路：递归搜索左右子树，若左右都有非 null 返回当前结点。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-二叉树最大路径和（LeetCode-124）"><a href="#7-3-二叉树最大路径和（LeetCode-124）" class="headerlink" title="7.3 二叉树最大路径和（LeetCode 124）"></a>7.3 二叉树最大路径和（LeetCode 124）</h3><p>思路：每个节点计算经过该节点的最大向下路径贡献，维护全局最大。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, dfs(node.left));</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, dfs(node.right));</span><br><span class="line">    maxSum = Math.max(maxSum, node.val + left + right);</span><br><span class="line">    <span class="keyword">return</span> node.val + Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="8-图（高级）"><a href="#8-图（高级）" class="headerlink" title="8. 图（高级）"></a>8. 图（高级）</h1><h3 id="8-1-拓扑排序（Kahn-算法）"><a href="#8-1-拓扑排序（Kahn-算法）" class="headerlink" title="8.1 拓扑排序（Kahn 算法）"></a>8.1 拓扑排序（Kahn 算法）</h3><p>思路：入度为 0 的点入队，逐出并减小邻居入度。能检测有向无环图。复杂度 O(V+E)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">topoSort</span><span class="params">(<span class="type">int</span> n, List&lt;List&lt;Integer&gt;&gt; adj)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] indeg = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++) <span class="keyword">for</span> (<span class="type">int</span> v : adj.get(u)) indeg[v]++;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) q.offer(i);</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> q.poll(); res.add(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj.get(u)) <span class="keyword">if</span> (--indeg[v] == <span class="number">0</span>) q.offer(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.size() == n ? res : <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 若有环则返回空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-Dijkstra（带优先队列的邻接表版本）"><a href="#8-2-Dijkstra（带优先队列的邻接表版本）" class="headerlink" title="8.2 Dijkstra（带优先队列的邻接表版本）"></a>8.2 Dijkstra（带优先队列的邻接表版本）</h3><p>复杂度 O((V+E) log V)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> to, w; Edge(<span class="type">int</span> t, <span class="type">int</span> w)&#123;to=t;<span class="built_in">this</span>.w=w;&#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dijkstra(<span class="type">int</span> n, List&lt;List&lt;Edge&gt;&gt; graph, <span class="type">int</span> src) &#123;</span><br><span class="line">    <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">    dist[src] = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(a-&gt;a[<span class="number">0</span>]));</span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, src&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span>[] cur = pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> cur[<span class="number">0</span>], u = cur[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (d &gt; dist[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : graph.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] + e.w &lt; dist[e.to]) &#123;</span><br><span class="line">                dist[e.to] = dist[u] + e.w;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;dist[e.to], e.to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-Bellman-Ford（带负权检测）"><a href="#8-3-Bellman-Ford（带负权检测）" class="headerlink" title="8.3 Bellman-Ford（带负权检测）"></a>8.3 Bellman-Ford（带负权检测）</h3><p>复杂度 O(V*E)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bellmanFord(<span class="type">int</span> n, <span class="type">int</span> src, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">    dist[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// relax n-1 times</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> e[<span class="number">0</span>], v = e[<span class="number">1</span>], w = e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (dist[u] != Integer.MAX_VALUE &amp;&amp; dist[u] + w &lt; dist[v]) dist[v] = dist[u] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测负环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[e[<span class="number">0</span>]] != Integer.MAX_VALUE &amp;&amp; dist[e[<span class="number">0</span>]] + e[<span class="number">2</span>] &lt; dist[e[<span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 存在负环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-并查集（Union-Find）"><a href="#8-4-并查集（Union-Find）" class="headerlink" title="8.4 并查集（Union-Find）"></a>8.4 并查集（Union-Find）</h3><p>思路：用于连通性、群组合并、Kruskal 最小生成树等。带路径压缩和按秩合并。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent, rank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n]; rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rx</span> <span class="operator">=</span> find(x), ry = find(y);</span><br><span class="line">        <span class="keyword">if</span> (rx == ry) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[rx] &lt; rank[ry]) parent[rx] = ry;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[rx] &gt; rank[ry]) parent[ry] = rx;</span><br><span class="line">        <span class="keyword">else</span> &#123; parent[ry] = rx; rank[rx]++; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="9-动态规划（DP）"><a href="#9-动态规划（DP）" class="headerlink" title="9. 动态规划（DP）"></a>9. 动态规划（DP）</h1><h3 id="9-1-最长递增子序列（LIS）-—-O-n-log-n"><a href="#9-1-最长递增子序列（LIS）-—-O-n-log-n" class="headerlink" title="9.1 最长递增子序列（LIS） — O(n log n)"></a>9.1 最长递增子序列（LIS） — O(n log n)</h3><p>思路：维护 tails 数组，tails[i] &#x3D; 最小结尾值使得长度为 i+1。可选重建路径。复杂度 O(n log n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] tails = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Arrays.binarySearch(tails, <span class="number">0</span>, size, x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) i = -(i + <span class="number">1</span>);</span><br><span class="line">        tails[i] = x;</span><br><span class="line">        <span class="keyword">if</span> (i == size) size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-0-1-背包（经典-DP）"><a href="#9-2-0-1-背包（经典-DP）" class="headerlink" title="9.2 0&#x2F;1 背包（经典 DP）"></a>9.2 0&#x2F;1 背包（经典 DP）</h3><p>时间 O(nW)，空间可滚动到 O(W)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span>[] wt, <span class="type">int</span>[] val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wt.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> W; w &gt;= wt[i]; w--) &#123;</span><br><span class="line">            dp[w] = Math.max(dp[w], dp[w - wt[i]] + val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-字符串拆分（Word-Break，LeetCode-139）"><a href="#9-3-字符串拆分（Word-Break，LeetCode-139）" class="headerlink" title="9.3 字符串拆分（Word Break，LeetCode 139）"></a>9.3 字符串拆分（Word Break，LeetCode 139）</h3><p>思路：DP，dp[i] &#x3D; [0..i)是否可拆分。复杂度 O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123; dp[i] = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="10-回溯（Backtracking）"><a href="#10-回溯（Backtracking）" class="headerlink" title="10. 回溯（Backtracking）"></a>10. 回溯（Backtracking）</h1><h3 id="10-1-N-皇后（LeetCode-51）"><a href="#10-1-N-皇后（LeetCode-51）" class="headerlink" title="10.1 N 皇后（LeetCode 51）"></a>10.1 N 皇后（LeetCode 51）</h3><p>思路：回溯 + 列 &#x2F; 斜对角 剪枝，可用位运算优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[][] board = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>[] row : board) Arrays.fill(row, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    backtrack(<span class="number">0</span>, board, res, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">char</span>[][] board, List&lt;List&lt;String&gt;&gt; res, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        List&lt;String&gt; sol = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] r : board) sol.add(<span class="keyword">new</span> <span class="title class_">String</span>(r));</span><br><span class="line">        res.add(sol);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValid(board, row, col, n)) <span class="keyword">continue</span>;</span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        backtrack(row + <span class="number">1</span>, board, res, n);</span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-组合总和（Combination-Sum，LeetCode-39）"><a href="#10-2-组合总和（Combination-Sum，LeetCode-39）" class="headerlink" title="10.2 组合总和（Combination Sum，LeetCode 39）"></a>10.2 组合总和（Combination Sum，LeetCode 39）</h3><p>思路：回溯，注意去重与剪枝（排序后剪枝）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    back(candidates, <span class="number">0</span>, target, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">back</span><span class="params">(<span class="type">int</span>[] cand, <span class="type">int</span> idx, <span class="type">int</span> target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123; res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path)); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; cand.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cand[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">        path.add(cand[i]);</span><br><span class="line">        back(cand, i, target - cand[i], path, res); <span class="comment">// i 允许重复</span></span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="11-字符串算法"><a href="#11-字符串算法" class="headerlink" title="11. 字符串算法"></a>11. 字符串算法</h1><h3 id="11-1-KMP（计算-LPS）"><a href="#11-1-KMP（计算-LPS）" class="headerlink" title="11.1 KMP（计算 LPS）"></a>11.1 KMP（计算 LPS）</h3><p>思路：预处理模式串得到最长相同前后缀数组 lps，然后线性匹配。复杂度 O(n+m)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] computeLPS(String pat) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pat.length();</span><br><span class="line">    <span class="type">int</span>[] lps = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pat.charAt(i) == pat.charAt(len)) &#123; lps[i++] = ++len; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) len = lps[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123; lps[i++] = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kmp</span><span class="params">(String s, String pat)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] lps = computeLPS(pat);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == pat.charAt(j)) &#123; i++; j++; <span class="keyword">if</span> (j == pat.length()) <span class="keyword">return</span> i - j; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) j = lps[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-Rabin-Karp（字符串哈希）"><a href="#11-2-Rabin-Karp（字符串哈希）" class="headerlink" title="11.2 Rabin-Karp（字符串哈希）"></a>11.2 Rabin-Karp（字符串哈希）</h3><p>思路：用滚动哈希快速比较子串，注意哈希冲突处理。复杂度 平均 O(n).</p><hr><h1 id="12-字典树-Trie"><a href="#12-字典树-Trie" class="headerlink" title="12. 字典树 Trie"></a>12. 字典树 Trie</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node[] next = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">boolean</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) cur.next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="13-线段树-树状数组（Fenwick）"><a href="#13-线段树-树状数组（Fenwick）" class="headerlink" title="13. 线段树 &#x2F; 树状数组（Fenwick）"></a>13. 线段树 &#x2F; 树状数组（Fenwick）</h1><h3 id="13-1-树状数组（Fenwick）"><a href="#13-1-树状数组（Fenwick）" class="headerlink" title="13.1 树状数组（Fenwick）"></a>13.1 树状数组（Fenwick）</h3><p>功能：前缀和 &#x2F; 单点更新，构建简单，复杂度 O(log n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">int</span> n; <span class="type">int</span>[] bit;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fenwick</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="built_in">this</span>.n = n; bit = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> &#123; <span class="keyword">for</span> (; i &lt;= n; i += i &amp; -i) bit[i] += delta; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; <span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i -= i &amp; -i) s += bit[i]; <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> &#123; <span class="keyword">return</span> query(r) - query(l - <span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-线段树（区间和-区间更新）"><a href="#13-2-线段树（区间和-区间更新）" class="headerlink" title="13.2 线段树（区间和 &#x2F; 区间更新）"></a>13.2 线段树（区间和 &#x2F; 区间更新）</h3><p>实现略长，模式熟悉后直接写模板即可 —— 支持区间查询&#x2F;更新，复杂度 O(log n)。</p><hr><h1 id="14-位运算-数学小技巧"><a href="#14-位运算-数学小技巧" class="headerlink" title="14. 位运算 &#x2F; 数学小技巧"></a>14. 位运算 &#x2F; 数学小技巧</h1><ul><li>单数：<code>x &amp; 1</code>；取反 <code>~x</code>。</li><li>异或特性：<code>a ^ a = 0</code>，用于求单数、交换不需要临时变量等。</li><li><code>lowbit(x) = x &amp; -x</code>（树状数组用到）。</li><li>统计 1 的个数（Hamming weight）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123; n &amp;= (n - <span class="number">1</span>); cnt++; &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单数问题（数组中其它数出现两次，只有一个出现一次）：使用 XOR。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) res ^= x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="15-设计题：LRU-Cache（双向链表-哈希表）"><a href="#15-设计题：LRU-Cache（双向链表-哈希表）" class="headerlink" title="15. 设计题：LRU Cache（双向链表 + 哈希表）"></a>15. 设计题：LRU Cache（双向链表 + 哈希表）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123; <span class="type">int</span> key, val; Node prev, next; Node(<span class="type">int</span> k,<span class="type">int</span> v)&#123;key=k;val=v;&#125; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>,<span class="number">0</span>), tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        capacity = cap;</span><br><span class="line">        head.next = tail; tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next; node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.next = head.next; node.prev = head;</span><br><span class="line">        head.next.prev = node; head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        remove(node); addToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key); node.val = value;</span><br><span class="line">            remove(node); addToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">tailPrev</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">                remove(tailPrev);</span><br><span class="line">                map.remove(tailPrev.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            addToHead(node); map.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="小结与复习建议（给你一个刷题路线）"><a href="#小结与复习建议（给你一个刷题路线）" class="headerlink" title="小结与复习建议（给你一个刷题路线）"></a>小结与复习建议（给你一个刷题路线）</h1><ul><li>基础题（数组 &#x2F; 链表 &#x2F; 栈 &#x2F; 队列 &#x2F; 哈希表）：先熟练增删查遍历，能写模板。</li><li>递归 + 树（中序&#x2F;前序&#x2F;后序&#x2F;层序） → 再做 LCA、序列化、最低深度。</li><li>双指针 &#x2F; 滑动窗口 &#x2F; 单调栈：拿来解决子数组、子串类题。</li><li>堆 &#x2F; 并查集 &#x2F; 图（BFS&#x2F;DFS&#x2F;Dijkstra&#x2F;拓扑） → 面试常考。</li><li>动态规划：从经典 1D DP → 背包、序列 DP → 状态压缩。</li><li>回溯：背诵回溯模板，练 N 皇后、子集 &#x2F; 组合 &#x2F; 排列 变体。</li><li>设计题：LRU&#x2F;MedianFinder&#x2F;Trie&#x2F;SegmentTree 模板要熟悉。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web</title>
      <link href="/2025/09/11/web/"/>
      <url>/2025/09/11/web/</url>
      
        <content type="html"><![CDATA[<p>好的，让我们深入到 HTTP 协议的底层，全面解剖它的工作原理、请求-响应模型、以及各个组成部分。</p><hr><h3 id="一、HTTP-协议概述"><a href="#一、HTTP-协议概述" class="headerlink" title="一、HTTP 协议概述"></a>一、HTTP 协议概述</h3><p>HTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，它定义了 Web 客户端（如浏览器）和 Web 服务器之间交换数据的规则。它的核心特点是<strong>无状态（Stateless）</strong>，这意味着服务器不会保存客户端的任何信息，每次请求都是独立的。</p><hr><h3 id="二、HTTP-请求（Request）"><a href="#二、HTTP-请求（Request）" class="headerlink" title="二、HTTP 请求（Request）"></a>二、HTTP 请求（Request）</h3><p>一个完整的 HTTP 请求由四部分组成：</p><h4 id="1-请求行（Request-Line）"><a href="#1-请求行（Request-Line）" class="headerlink" title="1. 请求行（Request Line）"></a>1. 请求行（Request Line）</h4><p>这是请求的第一行，它定义了请求的基本信息。</p><ul><li><strong>请求方法（Method）</strong>：如 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 等，表示对资源的操作类型。</li><li><strong>请求 URL (URI)</strong>：资源的地址。</li><li><strong>HTTP 协议版本</strong>：如 <code>HTTP/1.1</code>, <code>HTTP/2.0</code>。</li></ul><p>示例：</p><p>GET &#x2F;index.html HTTP&#x2F;1.1</p><h4 id="2-请求头（Request-Headers）"><a href="#2-请求头（Request-Headers）" class="headerlink" title="2. 请求头（Request Headers）"></a>2. 请求头（Request Headers）</h4><p>请求头提供了关于客户端、请求体和一些其他元数据的信息。它们以键值对的形式存在。</p><ul><li><strong>Host</strong>：指定请求的目标服务器的域名和端口号。</li><li><strong>User-Agent</strong>：客户端的软件类型和版本，如浏览器信息。</li><li><strong>Accept</strong>：客户端能够处理的媒体类型，告诉服务器希望返回什么格式的数据（如 <code>application/json</code>, <code>text/html</code>）。</li><li><strong>Content-Type</strong>：<strong>请求体</strong>中的数据类型，只在有请求体时使用（如 <code>POST</code>）。常见的有：<ul><li><code>application/x-www-form-urlencoded</code>：默认编码，用于提交表单数据。</li><li><code>multipart/form-data</code>：用于上传文件。</li><li><code>application/json</code>：用于前后端分离，提交 JSON 数据。</li></ul></li><li><strong>Content-Length</strong>：请求体的长度（字节）。</li><li><strong>Cookie</strong>：客户端存储的 Cookie 信息，用于会话管理。</li><li><strong>Authorization</strong>：用于身份认证，如携带 Bearer Token。</li><li><strong>Referer</strong>：请求从哪个页面跳转而来。</li></ul><h4 id="3-空行"><a href="#3-空行" class="headerlink" title="3. 空行"></a>3. 空行</h4><p>一个空行用于分隔请求头和请求体。</p><h4 id="4-请求体（Request-Body）"><a href="#4-请求体（Request-Body）" class="headerlink" title="4. 请求体（Request Body）"></a>4. 请求体（Request Body）</h4><p>请求体包含客户端提交给服务器的数据，通常用于 <code>POST</code>、<code>PUT</code> 等请求。GET 请求通常没有请求体。</p><hr><h3 id="三、HTTP-响应（Response）"><a href="#三、HTTP-响应（Response）" class="headerlink" title="三、HTTP 响应（Response）"></a>三、HTTP 响应（Response）</h3><p>一个完整的 HTTP 响应由三部分组成：</p><h4 id="1-状态行（Status-Line）"><a href="#1-状态行（Status-Line）" class="headerlink" title="1. 状态行（Status Line）"></a>1. 状态行（Status Line）</h4><p>这是响应的第一行，定义了响应的基本信息。</p><ul><li><strong>HTTP 协议版本</strong>：如 <code>HTTP/1.1</code>。</li><li><strong>状态码（Status Code）</strong>：三位数字，表示请求结果。</li><li><strong>状态信息（Reason Phrase）</strong>：对状态码的简短描述。</li></ul><p>示例：</p><p>HTTP&#x2F;1.1 200 OK</p><h4 id="2-响应头（Response-Headers）"><a href="#2-响应头（Response-Headers）" class="headerlink" title="2. 响应头（Response Headers）"></a>2. 响应头（Response Headers）</h4><p>响应头提供了关于服务器、响应体和会话的元数据信息。</p><ul><li><strong>Content-Type</strong>：<strong>响应体</strong>的数据类型。</li><li><strong>Content-Length</strong>：响应体的长度。</li><li><strong>Set-Cookie</strong>：服务器向客户端发送 Cookie，用于存储会话 ID 等信息。</li><li><strong>Location</strong>：用于重定向，指定新的 URL。</li><li><strong>Cache-Control</strong>：控制浏览器缓存行为。</li></ul><h4 id="3-空行-1"><a href="#3-空行-1" class="headerlink" title="3. 空行"></a>3. 空行</h4><p>一个空行用于分隔响应头和响应体。</p><h4 id="4-响应体（Response-Body）"><a href="#4-响应体（Response-Body）" class="headerlink" title="4. 响应体（Response Body）"></a>4. 响应体（Response Body）</h4><p>响应体包含了服务器返回给客户端的实际数据，如 HTML 网页内容、JSON 数据或图片等。</p><hr><h3 id="四、HTTP-方法的幂等性与安全性"><a href="#四、HTTP-方法的幂等性与安全性" class="headerlink" title="四、HTTP 方法的幂等性与安全性"></a>四、HTTP 方法的幂等性与安全性</h3><ul><li><strong>安全性</strong>：指请求方法不会对服务器上的资源状态产生修改。<code>GET</code> 和 <code>HEAD</code> 方法是安全的。</li><li><strong>幂等性</strong>：指请求方法重复执行多次，对服务器上的资源状态产生的影响与执行一次的影响相同。<ul><li><strong>幂等方法</strong>：<code>GET</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>。</li><li><strong>非幂等方法</strong>：<code>POST</code>。</li></ul></li></ul><table><thead><tr><th>方法</th><th>安全性</th><th>幂等性</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>是</td><td>是</td><td>获取资源</td></tr><tr><td><strong>POST</strong></td><td>否</td><td>否</td><td>创建资源</td></tr><tr><td><strong>PUT</strong></td><td>否</td><td>是</td><td>更新或替换资源</td></tr><tr><td><strong>DELETE</strong></td><td>否</td><td>是</td><td>删除资源</td></tr></tbody></table><hr><h3 id="五、HTTP-的会话管理：Cookie"><a href="#五、HTTP-的会话管理：Cookie" class="headerlink" title="五、HTTP 的会话管理：Cookie"></a>五、HTTP 的会话管理：Cookie</h3><p>HTTP 本身是无状态的，但为了跟踪用户，引入了 Cookie。</p><ol><li><strong>创建</strong>：服务器通过响应头 <code>Set-Cookie</code> 向客户端发送一个 Cookie。</li><li><strong>存储</strong>：浏览器接收到 <code>Set-Cookie</code> 后，会将其存储在本地。</li><li><strong>携带</strong>：之后，每次对同一域名发起请求时，浏览器都会自动在请求头 <code>Cookie</code> 中带上这个 Cookie。</li></ol><p>通过在 Cookie 中存储一个 SessionID，服务器就可以在后续请求中找到对应的会话数据，从而实现状态管理。</p><hr><h3 id="六、HTTP-1-1-与-HTTP-2-的区别"><a href="#六、HTTP-1-1-与-HTTP-2-的区别" class="headerlink" title="六、HTTP&#x2F;1.1 与 HTTP&#x2F;2 的区别"></a>六、HTTP&#x2F;1.1 与 HTTP&#x2F;2 的区别</h3><ul><li><strong>多路复用（Multiplexing）</strong>：HTTP&#x2F;2 允许在<strong>一个 TCP 连接</strong>上同时发送多个请求和响应，解决了 HTTP&#x2F;1.1 队头阻塞的问题，显著提高了性能。</li><li><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;2 使用 HPACK 算法压缩请求和响应头，减少了数据传输量。</li><li><strong>服务器推送（Server Push）</strong>：服务器可以在客户端请求一个资源时，主动推送其他它认为客户端可能需要的资源，减少了客户端的请求次数。</li><li><strong>二进制分帧（Binary Framing）</strong>：HTTP&#x2F;2 将所有传输信息分割成更小的消息和帧，并采用二进制编码，使得解析更高效。</li></ul><p>好的，我们来详细补充 <strong>HTTP&#x2F;1.0</strong> 的核心概念，并对整个 HTTP 协议族进行全面的对比和深入解析。</p><hr><h3 id="一、HTTP-协议族演变：从-1-0-到-2-0"><a href="#一、HTTP-协议族演变：从-1-0-到-2-0" class="headerlink" title="一、HTTP 协议族演变：从 1.0 到 2.0"></a>一、HTTP 协议族演变：从 1.0 到 2.0</h3><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h4><p>HTTP&#x2F;1.0 是 HTTP 协议的早期版本，它的设计相对简单，主要用于满足基本的网页浏览需求。</p><ul><li><strong>核心特点：</strong><ul><li><strong>非持久连接（Non-persistent Connection）</strong>：这是 HTTP&#x2F;1.0 最显著的特点。每进行一次 HTTP 请求-响应，客户端和服务器之间就会建立一个新的 <strong>TCP 连接</strong>，并在请求完成后立即断开。<ul><li><strong>缺点</strong>：每次请求都需要经过 TCP 三次握手和四次挥手的过程，这带来了巨大的性能开销。如果一个网页包含多个图片、CSS 或 JavaScript 文件，浏览器需要为每个文件单独建立和断开连接，导致页面加载速度慢。</li></ul></li><li><strong>无主机头（No Host Header）</strong>：请求头中没有 <code>Host</code> 字段。这意味着一个 IP 地址只能对应一个域名。如果服务器上有多个网站，就无法通过 IP 地址来区分它们，这在虚拟主机时代是个大问题。</li><li><strong>不支持管线化（Pipelining）</strong>：客户端发送一个请求后，必须等待服务器的响应，才能发送下一个请求。</li></ul></li></ul><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h4><p>HTTP&#x2F;1.1 协议是对 1.0 的重大改进，解决了其大部分性能瓶颈。</p><ul><li><strong>核心特点：</strong><ul><li><strong>持久连接（Persistent Connection）</strong>：默认情况下，HTTP&#x2F;1.1 会在一次请求-响应之后<strong>保持 TCP 连接不断开</strong>。客户端可以继续在这个连接上发送后续请求。<ul><li><strong>优点</strong>：显著减少了 TCP 连接的建立和断开开销，提高了页面加载速度。这个特性也称为“Keep-Alive”。</li></ul></li><li><strong>支持主机头（Host Header）</strong>：请求头中引入了 <code>Host</code> 字段，允许在同一个 IP 地址上部署多个虚拟主机（域名）。</li><li><strong>支持管线化（Pipelining）</strong>：客户端可以在收到上一个响应之前，连续发送多个请求。<ul><li><strong>缺点</strong>：虽然提高了效率，但存在**队头阻塞（Head-of-Line Blocking）**问题。如果第一个请求处理时间很长，后面的请求即使已经处理完成，也必须等待它的响应，导致整个连接的效率降低。</li></ul></li><li><strong>引入缓存机制</strong>：通过 <code>Cache-Control</code>, <code>ETag</code>, <code>If-None-Match</code> 等请求头，HTTP&#x2F;1.1 提供了更完善的缓存机制，减少了不必要的请求。</li></ul></li></ul><h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h4><p>HTTP&#x2F;2.0 是为了解决 HTTP&#x2F;1.1 在移动互联网和高并发场景下的性能问题而设计的。它不是对 HTTP&#x2F;1.1 的简单升级，而是对协议底层进行了重构。</p><ul><li><strong>核心特点：</strong><ul><li><strong>多路复用（Multiplexing）</strong>：这是 HTTP&#x2F;2 的核心。它允许在<strong>一个 TCP 连接</strong>上同时处理多个 HTTP 请求和响应。<ul><li><strong>如何实现？</strong>：HTTP&#x2F;2 将所有数据流（Stream）分割成更小的二进制帧（Frame），每个帧都带有唯一的标识符。这样，客户端和服务器可以在同一个连接上交错发送和接收帧，然后根据标识符重新组装，从而彻底解决了 HTTP&#x2F;1.1 的队头阻塞问题。</li></ul></li><li><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;2 使用 HPACK 算法来压缩请求和响应头，尤其是对于重复发送的字段，大大减少了数据传输量。</li><li><strong>服务器推送（Server Push）</strong>：服务器可以在客户端请求一个资源（如 HTML 页面）时，主动推送其他它认为客户端可能需要的资源（如 CSS 和 JS 文件），而无需客户端显式请求，进一步提高了加载速度。</li><li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议，而不是文本协议，解析更高效、更不容易出错。</li></ul></li></ul><hr><h3 id="二、HTTP-协议版本对比总结"><a href="#二、HTTP-协议版本对比总结" class="headerlink" title="二、HTTP 协议版本对比总结"></a>二、HTTP 协议版本对比总结</h3><p>理解 HTTP 协议的演变历程，能让你更深刻地体会到 Web 性能优化的方向，以及现代 Web 框架如何利用这些底层协议特性来提供更高效的服务。</p><table><thead><tr><th>特性</th><th>HTTP&#x2F;1.0</th><th>HTTP&#x2F;1.1</th><th>HTTP&#x2F;2.0</th></tr></thead><tbody><tr><td><strong>TCP 连接</strong></td><td>非持久连接</td><td>默认持久连接</td><td>单个 TCP 连接多路复用</td></tr><tr><td><strong>性能瓶颈</strong></td><td>多次握手挥手开销</td><td>队头阻塞</td><td>无</td></tr><tr><td><strong>主机头</strong></td><td>不支持</td><td>支持 (<code>Host</code> Header)</td><td>支持</td></tr><tr><td><strong>并发请求</strong></td><td>串行（一个请求一个连接）</td><td>串行（一个连接一个请求）</td><td>并行（一个连接多个请求）</td></tr><tr><td><strong>数据格式</strong></td><td>文本协议</td><td>文本协议</td><td>二进制协议</td></tr><tr><td><strong>头部</strong></td><td>无压缩</td><td>无压缩</td><td>HPACK 算法压缩</td></tr><tr><td><strong>服务器推送</strong></td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table><p>好的，让我们把所有关于 Servlet 的知识点整合在一起，进行一次最全面、最深入的剖析。我们将从基础概念开始，逐步深入到它的生命周期、配置、核心方法以及与 Servlet 规范相关的其他重要组件。</p><hr><h3 id="Servlet-概述：Java-Web-的核心基石"><a href="#Servlet-概述：Java-Web-的核心基石" class="headerlink" title="Servlet 概述：Java Web 的核心基石"></a>Servlet 概述：Java Web 的核心基石</h3><p><strong>Servlet</strong> 是 Java EE 规范中的一个核心组件，它是一个运行在服务器端的 Java 程序，用于处理 HTTP 请求和生成动态响应。你可以把它看作是所有 Java Web 框架（如 Spring MVC）的底层引擎。</p><p><strong>它的核心作用</strong>是作为客户端（浏览器）和 Java 应用程序之间的“桥梁”。Servlet 容器（如 Tomcat、Jetty）负责监听网络请求，然后将请求分发给相应的 Servlet 进行处理。</p><h3 id="Servlet-的生命周期：由容器严格管理"><a href="#Servlet-的生命周期：由容器严格管理" class="headerlink" title="Servlet 的生命周期：由容器严格管理"></a>Servlet 的生命周期：由容器严格管理</h3><p>一个 Servlet 的生命周期由 Servlet 容器严格管理，通常分为三个阶段：</p><ol><li><strong>初始化（Initialization）</strong><ul><li><strong>时机</strong>：当 Servlet 容器第一次加载 Servlet 类并创建其实例后，立即调用 <code>init()</code> 方法。</li><li><strong>特性</strong>：这个方法<strong>只执行一次</strong>，通常用于加载配置文件、建立数据库连接池等一次性、耗时的任务。如果 <code>init()</code> 方法抛出异常，Servlet 将无法提供服务。</li></ul></li><li><strong>服务（Servicing）</strong><ul><li><strong>时机</strong>：每当一个客户端请求到达时，容器会为该请求创建一个新的线程，并调用 <code>service()</code> 方法。</li><li><strong>特性</strong>：<code>service()</code> 方法是 Servlet 的核心，它会根据请求类型（如 GET、POST）自动调用相应的 <code>doGet()</code>、<code>doPost()</code> 等方法。由于此方法会被多个线程并发调用，因此访问共享资源时必须注意<strong>线程安全</strong>。</li></ul></li><li><strong>销毁（Destruction）</strong><ul><li><strong>时机</strong>：当 Servlet 容器关闭或决定卸载某个 Servlet 时，会调用其 <code>destroy()</code> 方法。</li><li><strong>特性</strong>：这个方法也<strong>只执行一次</strong>，用于释放资源，如关闭数据库连接或文件流。</li></ul></li></ol><h3 id="Servlet-的配置和部署：两种主要方式"><a href="#Servlet-的配置和部署：两种主要方式" class="headerlink" title="Servlet 的配置和部署：两种主要方式"></a>Servlet 的配置和部署：两种主要方式</h3><p>为了让容器知道如何加载和映射 Servlet，你需要进行配置。</p><ol><li><strong>web.xml 配置（传统方式）</strong><ul><li>在 <code>web.xml</code> 文件中，使用 <code>&lt;servlet&gt;</code> 标签定义 Servlet 类，并使用 <code>&lt;servlet-mapping&gt;</code> 标签将它映射到一个 URL 路径。</li><li><strong>优点</strong>：配置集中，易于管理。</li><li><strong>缺点</strong>：如果 Servlet 很多，<code>web.xml</code> 文件会变得非常庞大。</li></ul></li><li><strong>注解配置（现代方式）</strong><ul><li>从 Servlet 3.0 规范开始，你可以使用 <code>@WebServlet</code> 注解来简化配置。只需在你的 Servlet 类上添加 <code>@WebServlet(&quot;/path&quot;)</code> 注解，容器就会自动识别和配置它。</li><li><strong>优点</strong>：配置简单，代码和配置在一起，提高了可读性。</li></ul></li></ol><h3 id="Servlet-的核心方法：处理请求和响应"><a href="#Servlet-的核心方法：处理请求和响应" class="headerlink" title="Servlet 的核心方法：处理请求和响应"></a>Servlet 的核心方法：处理请求和响应</h3><p>所有 Servlet 都应该实现 <code>javax.servlet.Servlet</code> 接口。通常，我们更常继承 <code>javax.servlet.http.HttpServlet</code>，因为它提供了更方便的 HTTP 请求处理方法。</p><ul><li><code>service(HttpServletRequest req, HttpServletResponse res)</code>：这是核心服务方法，由容器调用。它会根据请求的 HTTP 方法（GET、POST、PUT 等）来调用相应的 <code>doGet()</code>、<code>doPost()</code> 等方法。</li><li><code>doGet(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 GET 请求。</li><li><code>doPost(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 POST 请求。</li><li><code>doPut(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 PUT 请求。</li><li><code>doDelete(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 DELETE 请求。</li></ul><p>在这些方法中，你可以通过 <code>req</code> (请求) 和 <code>res</code> (响应) 对象来与客户端进行交互。</p><h3 id="Servlet-的请求和响应处理：与客户端交互"><a href="#Servlet-的请求和响应处理：与客户端交互" class="headerlink" title="Servlet 的请求和响应处理：与客户端交互"></a>Servlet 的请求和响应处理：与客户端交互</h3><ul><li><strong>获取请求参数</strong><ul><li><code>req.getParameter(&quot;paramName&quot;)</code>：获取单个参数值。</li><li><code>req.getParameterValues(&quot;paramName&quot;)</code>：获取具有相同名称的多个参数值（如复选框）。</li></ul></li><li><strong>设置响应头</strong><ul><li><code>res.setContentType(&quot;text/html;charset=UTF-8&quot;)</code>：设置响应的内容类型和字符编码。</li><li><code>res.setHeader(&quot;HeaderName&quot;, &quot;HeaderValue&quot;)</code>：设置自定义响应头。</li></ul></li><li><strong>写入响应内容</strong><ul><li><code>res.getWriter()</code>：获取一个 <code>PrintWriter</code>，用于向客户端发送文本响应。</li><li><code>res.getOutputStream()</code>：获取一个 <code>ServletOutputStream</code>，用于向客户端发送二进制响应（如图片、文件）。</li></ul></li></ul><h3 id="Servlet-的核心组件与作用域"><a href="#Servlet-的核心组件与作用域" class="headerlink" title="Servlet 的核心组件与作用域"></a>Servlet 的核心组件与作用域</h3><p>理解 Servlet 规范中的这些组件，能帮助你更合理地管理数据和资源。</p><ol><li><strong>ServletContext (应用上下文)</strong><ul><li><strong>作用</strong>：代表整个 Web 应用，它的生命周期与应用相同。</li><li><strong>作用域</strong>：数据在所有 Servlet、JSP 和 Filter 之间<strong>共享</strong>。</li><li><strong>用途</strong>：存储全局配置和共享数据。</li></ul></li><li><strong>ServletConfig (配置对象)</strong><ul><li><strong>作用</strong>：代表一个 Servlet 独有的配置。</li><li><strong>作用域</strong>：仅在它所关联的 Servlet 内部有效。</li><li><strong>用途</strong>：获取特定 Servlet 的初始化参数。</li></ul></li><li><strong>四大作用域</strong><ul><li><strong>PageContext (页面作用域)</strong>：仅在 JSP 页面内有效。</li><li><strong>HttpServletRequest (请求作用域)</strong>：在一次完整的请求-响应周期内有效，即使请求被转发，数据依然可见。</li><li><strong>HttpSession (会话作用域)</strong>：在同一个浏览器会话中有效，用于存储用户特定数据。</li><li><strong>ServletContext (应用作用域)</strong>：在整个 Web 应用中都有效，用于存储全局数据。</li></ul></li></ol><p>好的，我们来详细、深入地聊聊 Web 开发中至关重要的两个概念：Cookie 和 Session。它们是解决 HTTP 无状态问题的核心方案，但工作机制和应用场景却大不相同。</p><hr><h3 id="Cookie：客户端的“小纸条”"><a href="#Cookie：客户端的“小纸条”" class="headerlink" title="Cookie：客户端的“小纸条”"></a>Cookie：客户端的“小纸条”</h3><p><strong>Cookie</strong> 是服务器发送给浏览器并存储在客户端的一小段文本信息。浏览器在下次访问同一服务器时，会自动将该 Cookie 包含在请求中发送回去。</p><h4 id="核心工作机制"><a href="#核心工作机制" class="headerlink" title="核心工作机制"></a>核心工作机制</h4><ol><li><p>服务器创建 Cookie：</p><p>当用户首次访问网站时，服务器在响应头（Response Header）中添加一个 Set-Cookie 字段。</p><p>比如：Set-Cookie: JSESSIONID&#x3D;abcde12345; Path&#x3D;&#x2F;; HttpOnly</p></li><li><p>浏览器保存 Cookie：</p><p>浏览器接收到响应后，会解析 Set-Cookie 头，并将该信息以键值对的形式存储在本地。</p></li><li><p>浏览器发送 Cookie：</p><p>在后续的请求中，只要请求的域名和路径与 Cookie 的设置相符，浏览器就会自动在请求头（Request Header）中添加 Cookie 字段，将存储的 Cookie 信息发送给服务器。</p><p>比如：Cookie: JSESSIONID&#x3D;abcde12345</p></li></ol><h4 id="Cookie-的优缺点"><a href="#Cookie-的优缺点" class="headerlink" title="Cookie 的优缺点"></a>Cookie 的优缺点</h4><ul><li><strong>优点</strong>：<ul><li><strong>减轻服务器压力</strong>：数据存储在客户端，服务器不需要为每个用户维护状态，适用于大规模访问。</li><li><strong>可扩展性强</strong>：无状态，天然适合分布式架构。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>安全性差</strong>：数据以明文形式存储，容易被窃取和篡改。</li><li><strong>容量限制</strong>：单个 Cookie 的大小通常不超过 4KB，且一个域名下的 Cookie 总数也有限制。</li><li><strong>用户可禁用</strong>：如果用户禁用了浏览器 Cookie 功能，相关功能将无法使用。</li></ul></li></ul><hr><h3 id="Session：服务器的“个人档案”"><a href="#Session：服务器的“个人档案”" class="headerlink" title="Session：服务器的“个人档案”"></a>Session：服务器的“个人档案”</h3><p><strong>Session</strong> 是服务器为每个用户创建的一个对象，用于存储特定用户的会话数据。它将用户的状态信息保存在服务器端，并通过一个唯一的 <strong>Session ID</strong> 来识别不同的用户。</p><h4 id="核心工作机制-1"><a href="#核心工作机制-1" class="headerlink" title="核心工作机制"></a>核心工作机制</h4><ol><li><p>服务器创建 Session：</p><p>当用户首次访问 Web 应用时，服务器会创建一个 HttpSession 对象，并为其分配一个唯一的 Session ID。</p></li><li><p>传递 Session ID：</p><p>服务器将这个 Session ID 以 Cookie 的形式发送给浏览器（这个 Cookie 通常叫 JSESSIONID）。</p><ul><li>如果浏览器禁用了 Cookie，服务器可以通过 <strong>URL 重写</strong>的方式，将 Session ID 附加到每个 URL 的末尾，例如：<code>.../index.jsp;jsessionid=abcde12345</code>。</li></ul></li><li><p>服务器维护 Session：</p><p>Session ID 传递到客户端后，服务器会在内存中或持久化存储中保存这个 HttpSession 对象及其数据。</p></li><li><p>识别用户：</p><p>后续的请求中，浏览器都会带着包含 Session ID 的 Cookie。服务器通过这个 ID 就能从内存中找到对应的 HttpSession 对象，从而获取该用户的状态信息。</p></li></ol><h4 id="Session-的优缺点"><a href="#Session-的优缺点" class="headerlink" title="Session 的优缺点"></a>Session 的优缺点</h4><ul><li><strong>优点</strong>：<ul><li><strong>安全性高</strong>：核心数据存储在服务器，客户端只传递一个无法猜解的 ID。</li><li><strong>容量大</strong>：存储在服务器，理论上没有大小限制。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>占用服务器资源</strong>：每个活跃的 Session 都会占用服务器内存，在高并发场景下可能成为瓶颈。</li><li><strong>分布式挑战</strong>：在多台服务器组成的集群环境中，需要额外的机制（如 Session 共享或粘性会话）来确保用户的请求总是被转发到同一个 Session 所在的服务器，或者所有服务器都能访问到 Session 数据。</li></ul></li></ul><hr><h3 id="Cookie-与-Session-的对比总结"><a href="#Cookie-与-Session-的对比总结" class="headerlink" title="Cookie 与 Session 的对比总结"></a>Cookie 与 Session 的对比总结</h3><table><thead><tr><th>特性</th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td><strong>数据存储位置</strong></td><td>客户端（浏览器）</td><td>服务器端</td></tr><tr><td><strong>安全性</strong></td><td>较低，易被篡改</td><td>较高，数据安全</td></tr><tr><td><strong>数据容量</strong></td><td>较小（~4KB）</td><td>较大，无明显限制</td></tr><tr><td><strong>性能</strong></td><td>轻量，不占用服务器资源</td><td>占用服务器内存，可能影响性能</td></tr><tr><td><strong>可扩展性</strong></td><td>天然无状态，易于扩展</td><td>分布式环境下需要额外配置</td></tr><tr><td><strong>主要用途</strong></td><td>购物车、用户偏好、轻量级状态</td><td>登录状态、权限验证、敏感数据</td></tr></tbody></table><p>好的，我已将 GET 和 POST 请求的所有核心区别整理成一个简洁明了的表格，并补充了更多细节，使其更全面。</p><h3 id="GET-和-POST-请求的全面对比"><a href="#GET-和-POST-请求的全面对比" class="headerlink" title="GET 和 POST 请求的全面对比"></a>GET 和 POST 请求的全面对比</h3><table><thead><tr><th>特性</th><th>GET 请求</th><th>POST 请求</th><th>备注</th></tr></thead><tbody><tr><td><strong>基本作用</strong></td><td>从服务器<strong>获取</strong>资源</td><td>向服务器<strong>提交</strong>数据，通常用于<strong>创建</strong>资源。</td><td>语义不同是所有区别的根本。</td></tr><tr><td><strong>传参方式</strong></td><td>参数附加在 URL 中</td><td>参数放在请求体（Request Body）中</td><td>GET 参数可见，POST 参数隐藏。</td></tr><tr><td><strong>安全性</strong></td><td><strong>不安全</strong>，URL 暴露</td><td><strong>相对安全</strong>，参数隐藏在请求体中</td><td>这里的“安全”指数据不被暴露。</td></tr><tr><td><strong>幂等性</strong></td><td><strong>是</strong>（多次执行结果相同）</td><td><strong>否</strong>（多次执行可能产生新资源）</td><td>幂等性是 RESTful 设计的关键原则。</td></tr><tr><td><strong>浏览器行为</strong></td><td>回退无害，可被记录在历史、收藏为书签。</td><td>回退时通常会提示重新提交，不记录在历史、不可收藏。</td><td>防止意外提交导致数据重复。</td></tr><tr><td><strong>缓存</strong></td><td><strong>可以被缓存</strong></td><td><strong>不会被缓存</strong></td><td>缓存能提高性能，但仅限于只读操作。</td></tr><tr><td><strong>传输数据量</strong></td><td>有长度限制（URL长度限制）</td><td>无长度限制（取决于服务器配置）</td><td>GET 不适合传输大量数据。</td></tr><tr><td><strong>数据编码</strong></td><td>只支持 URL 编码</td><td>支持多种编码（如<code>application/json</code>）</td><td>POST 灵活性高，适合各种数据类型。</td></tr><tr><td><strong>发送文件</strong></td><td>不支持</td><td>支持 (<code>multipart/form-data</code>)</td><td>文件必须通过请求体传输。</td></tr><tr><td><strong>HTTP 报文</strong></td><td>无请求体</td><td>有请求体</td><td>GET 请求报文更小，更轻量。</td></tr><tr><td><strong>TCP&#x2F;IP 协议</strong></td><td>一次性发送所有数据包</td><td>浏览器通常会先发送请求头，服务器响应 100-continue 后再发送请求体</td><td>POST 的分步发送机制可以避免发送不必要的数据。</td></tr></tbody></table><p>好的，我们将以 Servlet 的详细剖析方式，全面、深入地介绍 WebSocket。我们将从它的概念、生命周期、核心 API，到它与 HTTP 的区别以及在现代 Web 中的应用，进行系统性的梳理。</p><hr><h3 id="WebSocket-概述：Web-通信的革命"><a href="#WebSocket-概述：Web-通信的革命" class="headerlink" title="WebSocket 概述：Web 通信的革命"></a>WebSocket 概述：Web 通信的革命</h3><p><strong>WebSocket</strong> 协议是 HTML5 开始提供的一种在单个 TCP 连接上进行<strong>全双工通信</strong>的协议。与传统的 HTTP 协议不同，它打破了请求-响应的单向模式，使得客户端和服务器可以<strong>实时地双向自由传输数据</strong>。</p><p><strong>它的核心作用</strong>是解决 Web 应用中<strong>实时通信</strong>的需求，例如：聊天应用、在线游戏、股票行情、实时协作工具等。它极大地减少了网络开销，提高了通信效率。</p><h3 id="WebSocket-的核心工作原理"><a href="#WebSocket-的核心工作原理" class="headerlink" title="WebSocket 的核心工作原理"></a>WebSocket 的核心工作原理</h3><p>要理解 WebSocket，必须首先理解它与 HTTP 的关系。</p><ol><li><strong>基于 HTTP 的握手（Handshake）</strong>：<ul><li>WebSocket 的连接建立过程是基于 HTTP 协议的。</li><li>客户端发送一个特殊的 HTTP 请求，其中包含 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code> 请求头，向服务器请求将 HTTP 协议升级到 WebSocket 协议。</li><li>这是一个**“握手”**过程。</li></ul></li><li><strong>协议升级与持久连接</strong>：<ul><li>如果服务器支持 WebSocket，它会返回一个特殊的 HTTP 响应（状态码 <code>101 Switching Protocols</code>）。</li><li>握手成功后，客户端和服务器之间的 TCP 连接将<strong>保持打开状态</strong>。</li><li>这时，协议就从 HTTP 升级到了 WebSocket，双方可以在这个<strong>持久的 TCP 连接</strong>上自由地双向发送数据，而无需再进行 HTTP 头部开销。</li></ul></li><li><strong>数据帧传输</strong>：<ul><li>WebSocket 协议定义了**数据帧（Data Frames）**的概念。它将数据分割成更小、更轻量级的帧，而不是像 HTTP 那样发送整个报文。</li><li>这样，即使传输少量数据，也不会有很大的协议开销，非常适合实时通信。</li></ul></li></ol><h3 id="WebSocket-的生命周期：事件驱动模型"><a href="#WebSocket-的生命周期：事件驱动模型" class="headerlink" title="WebSocket 的生命周期：事件驱动模型"></a>WebSocket 的生命周期：事件驱动模型</h3><p>WebSocket 的生命周期由客户端和服务器共同维护，由一系列事件驱动：</p><h4 id="1-连接建立（Connection-Establishment）"><a href="#1-连接建立（Connection-Establishment）" class="headerlink" title="1. 连接建立（Connection Establishment）"></a>1. 连接建立（Connection Establishment）</h4><ul><li><strong>客户端</strong>：通过 <code>new WebSocket(url)</code> 建立连接。</li><li><strong>服务器</strong>：当客户端发送握手请求后，服务器处理并接受连接，此时触发 <code>onopen</code> 事件。</li></ul><h4 id="2-数据传输（Data-Transmission）"><a href="#2-数据传输（Data-Transmission）" class="headerlink" title="2. 数据传输（Data Transmission）"></a>2. 数据传输（Data Transmission）</h4><ul><li><strong>发送</strong>：客户端和服务器都可以通过各自的 <code>send()</code> 方法向对方发送数据。</li><li><strong>接收</strong>：当一方接收到数据时，会触发 <code>onmessage</code> 事件。</li></ul><h4 id="3-连接关闭（Connection-Close）"><a href="#3-连接关闭（Connection-Close）" class="headerlink" title="3. 连接关闭（Connection Close）"></a>3. 连接关闭（Connection Close）</h4><ul><li><strong>主动关闭</strong>：客户端或服务器可以调用 <code>close()</code> 方法主动关闭连接。</li><li><strong>异常关闭</strong>：连接可能因网络故障、心跳超时等原因意外关闭。</li><li><strong>事件</strong>：无论是主动还是被动，连接关闭时都会触发 <code>onclose</code> 事件。</li></ul><h3 id="WebSocket-的核心-API（以-JavaScript-为例）"><a href="#WebSocket-的核心-API（以-JavaScript-为例）" class="headerlink" title="WebSocket 的核心 API（以 JavaScript 为例）"></a>WebSocket 的核心 API（以 JavaScript 为例）</h3><p>WebSocket 的 API 设计非常简洁，主要基于事件监听和方法调用。</p><ul><li><strong>new WebSocket(url)</strong>：创建一个 WebSocket 客户端实例。</li><li><strong>websocket.onopen</strong>：连接成功建立时触发。</li><li><strong>websocket.onmessage &#x3D; function(event)</strong>：接收到服务器数据时触发，数据在 <code>event.data</code> 中。</li><li><strong>websocket.onerror</strong>：连接发生错误时触发。</li><li><strong>websocket.onclose</strong>：连接关闭时触发。</li><li><strong>websocket.send(data)</strong>：向服务器发送数据。</li><li><strong>websocket.close()</strong>：关闭连接。</li></ul><h3 id="WebSocket-与-HTTP-的本质区别"><a href="#WebSocket-与-HTTP-的本质区别" class="headerlink" title="WebSocket 与 HTTP 的本质区别"></a>WebSocket 与 HTTP 的本质区别</h3><table><thead><tr><th>特性</th><th>HTTP</th><th>WebSocket</th><th>备注</th></tr></thead><tbody><tr><td><strong>通信模式</strong></td><td><strong>单向</strong>（请求-响应）</td><td><strong>双向</strong>（全双工）</td><td>HTTP 客户端必须先发请求，服务器才能响应。</td></tr><tr><td><strong>连接状态</strong></td><td><strong>无状态</strong>，短连接</td><td><strong>有状态</strong>，长连接</td><td>HTTP 每次请求都需要重新建立连接。</td></tr><tr><td><strong>协议开销</strong></td><td><strong>大</strong>（每次请求都携带头部）</td><td><strong>小</strong>（握手后只传输数据帧）</td><td>HTTP 适合传输大文件，WebSocket 适合小数据频繁传输。</td></tr><tr><td><strong>服务器主动性</strong></td><td><strong>被动</strong>（无法主动推送）</td><td><strong>主动</strong>（可随时推送数据）</td><td>WebSocket 解决了 HTTP 的“服务器推”难题。</td></tr><tr><td><strong>应用场景</strong></td><td>网页浏览、API 调用、文件下载</td><td>聊天、游戏、实时数据更新</td><td></td></tr></tbody></table><h3 id="WebSocket-在现代-Java-Web-中的应用"><a href="#WebSocket-在现代-Java-Web-中的应用" class="headerlink" title="WebSocket 在现代 Java Web 中的应用"></a>WebSocket 在现代 Java Web 中的应用</h3><p>在 Java 后端，WebSocket 通常由专门的框架或容器来实现，如：</p><ul><li><strong>JavaEE 7+ 的 WebSocket API</strong>：提供了 <code>javax.websocket</code> 包，可以直接在 Servlet 容器中开发 WebSocket 应用。</li><li><strong>Spring Framework</strong>：提供了强大的 WebSocket 支持，集成了 STOMP（Simple Text Oriented Messaging Protocol）协议，简化了消息路由和管理。</li></ul><p>在这些框架中，你通常会定义一个 WebSocket 端点（Endpoint），类似于 Servlet，它负责处理连接的建立、消息的接收和发送、以及连接的关闭。</p><p>总而言之，WebSocket 是 HTTP 协议在实时通信领域的有力补充。它通过一次性的握手建立一个持久的双向通道，极大地提高了 Web 应用的交互性和效率，是现代 Web 架构中不可或缺的一部分。</p><p>好的，为了更好地理解 WebSocket 的工作原理，我将提供几个具体的应用场景和相应的代码示例。这些示例将涵盖客户端（JavaScript）和服务器端（Java&#x2F;Spring Boot）的代码，以便你能够完整地看到双向通信是如何实现的。</p><hr><h3 id="示例一：实时聊天应用"><a href="#示例一：实时聊天应用" class="headerlink" title="示例一：实时聊天应用"></a>示例一：实时聊天应用</h3><p>这是 WebSocket 最经典的用例。</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a><strong>应用场景</strong>：</h4><p>多个用户连接到聊天室，当一个用户发送消息时，服务器将该消息实时广播给所有其他在线用户。</p><h4 id="核心逻辑："><a href="#核心逻辑：" class="headerlink" title="核心逻辑："></a><strong>核心逻辑</strong>：</h4><ul><li><strong>客户端</strong>：当用户在输入框中按下回车，JavaScript 将消息通过 WebSocket 连接发送给服务器。</li><li><strong>服务器</strong>：接收到消息后，遍历所有已连接的 WebSocket 会话，将消息逐一发送给每个会话。</li></ul><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a><strong>代码示例</strong>：</h4><p><strong>1. 客户端 (JavaScript)</strong></p><p>JavaScript</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接 WebSocket 服务器</span></span><br><span class="line"><span class="type">const</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/chat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接成功事件</span></span><br><span class="line">socket.onopen = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket连接已建立&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听接收消息事件</span></span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="variable">message</span> <span class="operator">=</span> event.data;</span><br><span class="line">  <span class="type">const</span> <span class="variable">chatBox</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;chat-box&#x27;</span>);</span><br><span class="line">  chatBox.innerHTML += `&lt;p&gt;$&#123;message&#125;&lt;/p&gt;`; <span class="comment">// 将消息添加到聊天框</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接关闭事件</span></span><br><span class="line">socket.onclose = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket连接已关闭&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听错误事件</span></span><br><span class="line">socket.onerror = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket发生错误:&quot;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息函数</span></span><br><span class="line">function <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="variable">input</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;message-input&#x27;</span>);</span><br><span class="line">  <span class="type">const</span> <span class="variable">message</span> <span class="operator">=</span> input.value;</span><br><span class="line">  <span class="keyword">if</span> (message) &#123;</span><br><span class="line">    socket.send(message); <span class="comment">// 通过 WebSocket 发送消息</span></span><br><span class="line">    input.value = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 清空输入框</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定回车事件</span></span><br><span class="line">document.getElementById(<span class="string">&#x27;message-input&#x27;</span>).addEventListener(<span class="string">&#x27;keypress&#x27;</span>, function(e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.key === <span class="string">&#x27;Enter&#x27;</span>) &#123;</span><br><span class="line">    sendMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>2. 服务器端 (Java&#x2F;Spring Boot)</strong></p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatWebSocketEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储所有连接的客户端会话</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端连接成功时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.add(session); <span class="comment">// 添加新会话</span></span><br><span class="line">        System.out.println(<span class="string">&quot;新连接：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端发送消息时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息：&quot;</span> + message + <span class="string">&quot; 来自：&quot;</span> + session.getId());</span><br><span class="line">        <span class="comment">// 遍历所有会话，广播消息</span></span><br><span class="line">        sessions.forEach(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当连接关闭时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.remove(session); <span class="comment">// 移除会话</span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接关闭：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当发生错误时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接发生错误：&quot;</span> + session.getId());</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="示例二：实时股票行情或数据看板"><a href="#示例二：实时股票行情或数据看板" class="headerlink" title="示例二：实时股票行情或数据看板"></a>示例二：实时股票行情或数据看板</h3><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a><strong>应用场景</strong>：</h4><p>客户端连接到服务器，服务器定期或在数据更新时，向所有连接的客户端推送最新的股票价格或监控数据。</p><h4 id="核心逻辑：-1"><a href="#核心逻辑：-1" class="headerlink" title="核心逻辑："></a><strong>核心逻辑</strong>：</h4><ul><li><strong>客户端</strong>：只监听 <code>onmessage</code> 事件，被动接收服务器推送的数据。</li><li><strong>服务器</strong>：在后台启动一个定时任务或数据监听器。当数据变化时，主动通过 WebSocket 连接将新数据发送给客户端。</li></ul><h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a><strong>代码示例</strong>：</h4><p><strong>1. 客户端 (JavaScript)</strong></p><p>JavaScript</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/stock&#x27;</span>);</span><br><span class="line"></span><br><span class="line">socket.onopen = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;股票行情连接已建立&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">  <span class="comment">// 假设服务器发送的是JSON格式的股票数据</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">stockData</span> <span class="operator">=</span> JSON.parse(event.data);</span><br><span class="line">  <span class="type">const</span> <span class="variable">stockPriceElement</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;stock-price&#x27;</span>);</span><br><span class="line">  stockPriceElement.innerText = `当前价格: $&#123;stockData.price&#125;`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无需 sendMessage 函数，因为是单向被动接收</span></span><br></pre></td></tr></table></figure><p><strong>2. 服务器端 (Java&#x2F;Spring Boot)</strong></p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/stock&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockWebSocketEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.add(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;新股票行情订阅者：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是一个定时任务，每隔5秒向所有客户端推送数据</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushStockData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟获取最新股票价格</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> Math.random() * <span class="number">100</span> + <span class="number">100</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;price\&quot;: &quot;</span> + String.format(<span class="string">&quot;%.2f&quot;</span>, price) + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有会话，推送数据</span></span><br><span class="line">        sessions.forEach(session -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                    session.getBasicRemote().sendText(json);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个例子清楚地展示了 WebSocket 如何通过<strong>持久连接</strong>和<strong>双向通信</strong>来解决实时应用中的核心痛点。</p><p>好的，让我们详细、清晰地解释<strong>静态资源</strong>和<strong>动态资源</strong>的概念，以及为什么某些服务器或工具只能处理静态资源。</p><hr><h3 id="一、静态资源-Static-Resources"><a href="#一、静态资源-Static-Resources" class="headerlink" title="一、静态资源 (Static Resources)"></a>一、静态资源 (Static Resources)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>静态资源</strong>是指在服务器端<strong>不需要经过任何处理或计算</strong>，就能直接返回给客户端的资源。它们的<strong>内容是固定不变</strong>的，无论何时、被谁请求，服务器返回的都是同一个文件。</p><h4 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h4><ul><li><strong>HTML 文件</strong> (<code>.html</code>)：纯 HTML 代码，浏览器直接渲染。</li><li><strong>CSS 样式表</strong> (<code>.css</code>)：定义网页样式。</li><li><strong>JavaScript 脚本</strong> (<code>.js</code>)：用于网页交互。</li><li><strong>图片</strong> (<code>.jpg</code>, <code>.png</code>, <code>.gif</code>)：图像文件。</li><li><strong>字体文件</strong> (<code>.woff</code>, <code>.ttf</code>)：网页字体。</li><li><strong>视频</strong> (<code>.mp4</code>, <code>.webm</code>)：视频文件。</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>客户端向服务器请求一个 URL，例如 <code>http://example.com/styles.css</code>。</li><li>服务器接收到请求，直接从<strong>文件系统</strong>中找到名为 <code>styles.css</code> 的文件。</li><li>服务器将 <code>styles.css</code> 的内容原封不动地返回给客户端。</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>高效</strong>：无需服务器计算，直接读取文件，响应速度极快。</li><li><strong>可缓存</strong>：由于内容不变，浏览器、代理服务器都可以对静态资源进行缓存，进一步减少网络传输。</li><li><strong>部署简单</strong>：只需将文件放在服务器的特定目录下即可。</li></ul><h3 id="二、动态资源-Dynamic-Resources"><a href="#二、动态资源-Dynamic-Resources" class="headerlink" title="二、动态资源 (Dynamic Resources)"></a>二、动态资源 (Dynamic Resources)</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>动态资源</strong>是指服务器端<strong>需要经过处理、计算或查询数据库</strong>，才能生成并返回给客户端的资源。它们的内容是<strong>可变</strong>的，不同的请求、不同的时间，返回的内容可能不同。</p><h4 id="常见类型-1"><a href="#常见类型-1" class="headerlink" title="常见类型"></a>常见类型</h4><ul><li><strong>Servlet&#x2F;JSP</strong>：Java 后端通过 Servlet 或 JSP 动态生成 HTML。</li><li><strong>PHP 脚本</strong> (<code>.php</code>)：PHP 后端生成 HTML。</li><li><strong>Python&#x2F;Django 视图</strong>：Python 后端处理请求并返回数据。</li><li><strong>RESTful API</strong>：返回 JSON、XML 等格式的数据。</li></ul><h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>客户端向服务器请求一个 URL，例如 <code>http://example.com/user/profile?id=123</code>。</li><li>服务器接收到请求，将请求转发给<strong>后端程序</strong>（如 Servlet 容器）。</li><li>后端程序接收请求，根据请求参数 <code>id=123</code> 查询数据库，获取该用户的信息。</li><li>后端程序将数据渲染到 HTML 模板中，或者将数据封装成 JSON 格式。</li><li>后端程序将<strong>动态生成的内容</strong>作为响应返回给服务器。</li><li>服务器将该响应发送给客户端。</li></ol><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>灵活</strong>：可以根据业务逻辑生成个性化内容。</li><li><strong>消耗资源</strong>：需要消耗 CPU、内存、数据库连接等资源进行计算。</li><li><strong>不可直接缓存</strong>：由于内容可变，通常无法像静态资源那样直接缓存。</li></ul><h3 id="三、是什么东西只能解析静态资源？"><a href="#三、是什么东西只能解析静态资源？" class="headerlink" title="三、是什么东西只能解析静态资源？"></a>三、是什么东西只能解析静态资源？</h3><p>这个问题的核心在于**“解析”<strong>这个词。能“解析”静态资源的，通常指的是</strong>Web 服务器**。</p><ul><li><strong>Web 服务器</strong>：一种软件，它的主要职责是处理 HTTP 请求并返回文件。</li></ul><h4 id="1-纯静态-Web-服务器-Static-Web-Server"><a href="#1-纯静态-Web-服务器-Static-Web-Server" class="headerlink" title="1. 纯静态 Web 服务器 (Static Web Server)"></a>1. 纯静态 Web 服务器 (Static Web Server)</h4><p><strong>这类服务器的核心功能就是提供静态文件服务。</strong> 它们只知道如何根据 URL 路径，去文件系统找到对应的文件，然后返回。</p><ul><li><strong>工作原理</strong>：它们没有内置的后端语言解析器（如 Java 虚拟机、PHP 解释器）。当它们收到一个请求时，只会将 URL 映射到文件目录。如果文件存在，就返回；如果不存在，就返回 404 错误。</li><li><strong>代表</strong>：<strong>Nginx</strong>（作为反向代理或静态文件服务器时）、<strong>Apache HTTP Server</strong>（作为静态文件服务器时）。</li></ul><p><strong>为什么它们不能解析动态资源？</strong></p><p>因为它们<strong>不具备</strong>执行后端代码的能力。例如，当 Nginx 收到一个对 <code>.jsp</code> 文件的请求时，它不知道如何运行 Java 代码来生成 HTML。它只会把 <code>.jsp</code> 文件当作一个普通的文本文件返回给浏览器，浏览器也无法正确地解析。</p><h4 id="2-动态-Web-服务器-Dynamic-Web-Server"><a href="#2-动态-Web-服务器-Dynamic-Web-Server" class="headerlink" title="2. 动态 Web 服务器 (Dynamic Web Server)"></a>2. 动态 Web 服务器 (Dynamic Web Server)</h4><p>这类服务器通常被称为 <strong>“应用服务器”</strong>，它们在 Web 服务器的功能上，<strong>内置了后端语言的运行环境</strong>。</p><ul><li><strong>工作原理</strong>：<ul><li>当它们收到静态资源请求时，行为与静态服务器相同：直接返回文件。</li><li>当它们收到动态资源请求时，会将请求转发给内置的<strong>后端程序运行环境</strong>。例如，Tomcat 会将 <code>.jsp</code> 文件交给 JSP 引擎来编译和执行。</li></ul></li><li><strong>代表</strong>：<strong>Apache Tomcat</strong>、<strong>Jetty</strong>。</li></ul><p>因此，在实际生产环境中，我们经常采用<strong>动静分离</strong>的架构：</p><ul><li><strong>静态资源</strong>（<code>index.html</code>、<code>style.css</code> 等）交给 <strong>Nginx</strong> 这样的高效静态服务器处理。</li><li><strong>动态资源</strong>（<code>api/user</code>, <code>.jsp</code> 等）交给 <strong>Tomcat</strong> 这样的应用服务器处理。</li></ul><p>这样做的目的是，让专业的工具做专业的事：Nginx 擅长高并发的静态文件服务，而 Tomcat 则专注于复杂的动态业务逻辑。</p><p>好的，让我们来系统、全面地梳理前端的核心知识，这不仅是前端工程师的必备技能，也是后端开发者理解整个 Web 应用架构的关键。</p><h3 id="一、基础三剑客：构建网页的基石"><a href="#一、基础三剑客：构建网页的基石" class="headerlink" title="一、基础三剑客：构建网页的基石"></a>一、基础三剑客：构建网页的基石</h3><p>这三者是所有前端技术的基础，就像建筑的钢筋、水泥和水电。</p><h4 id="1-HTML-HyperText-Markup-Language"><a href="#1-HTML-HyperText-Markup-Language" class="headerlink" title="1. HTML (HyperText Markup Language)"></a>1. HTML (HyperText Markup Language)</h4><ul><li><strong>是什么</strong>：超文本标记语言，用于<strong>定义网页的结构和内容</strong>。它由一系列标签（tag）组成，这些标签告诉浏览器如何组织页面内容，如段落、标题、图片、链接等。</li><li><strong>核心概念</strong>：<ul><li><strong>标签（Tags）</strong>：如 <code>&lt;p&gt;</code> (段落), <code>&lt;h1&gt;</code> (一级标题), <code>&lt;img&gt;</code> (图片), <code>&lt;a&gt;</code> (超链接)。</li><li><strong>元素（Elements）</strong>：由开始标签、内容和结束标签组成，例如 <code>&lt;p&gt;这是一个段落。&lt;/p&gt;</code>。</li><li><strong>属性（Attributes）</strong>：提供关于元素的额外信息，如 <code>&lt;img src=&quot;image.jpg&quot; alt=&quot;描述&quot;&gt;</code> 中的 <code>src</code> 和 <code>alt</code>。</li><li><strong>语义化（Semantic HTML）</strong>：使用恰当的标签来表达内容的含义，如 <code>&lt;header&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;footer&gt;</code>，这有助于搜索引擎优化（SEO）和无障碍访问。</li></ul></li></ul><h4 id="2-CSS-Cascading-Style-Sheets"><a href="#2-CSS-Cascading-Style-Sheets" class="headerlink" title="2. CSS (Cascading Style Sheets)"></a>2. CSS (Cascading Style Sheets)</h4><ul><li><strong>是什么</strong>：层叠样式表，用于<strong>定义网页的样式和表现</strong>。它告诉浏览器如何显示 HTML 元素，如颜色、字体、布局、大小等。</li><li><strong>核心概念</strong>：<ul><li><strong>选择器（Selectors）</strong>：用于选中要应用样式的 HTML 元素，如 <code>h1</code> (标签选择器), <code>.my-class</code> (类选择器), <code>#my-id</code> (ID 选择器)。</li><li><strong>盒模型（Box Model）</strong>：每个 HTML 元素都被视为一个矩形盒子，包含 <code>content</code>（内容）、<code>padding</code>（内边距）、<code>border</code>（边框）和 <code>margin</code>（外边距）。</li><li><strong>布局（Layout）</strong>：<ul><li><strong>传统布局</strong>：<code>float</code>, <code>position</code>, <code>display</code>。</li><li><strong>现代布局</strong>：<strong>Flexbox</strong> (弹性盒子，用于一维布局) 和 <strong>Grid</strong> (网格系统，用于二维布局)。这两种是目前最主流的布局方式。</li></ul></li><li><strong>响应式设计（Responsive Design）</strong>：使用 <code>@media</code> 查询来根据设备屏幕大小调整样式，使网页在不同设备上都能良好显示。</li></ul></li></ul><h4 id="3-JavaScript-JS"><a href="#3-JavaScript-JS" class="headerlink" title="3. JavaScript (JS)"></a>3. JavaScript (JS)</h4><ul><li><strong>是什么</strong>：一种高级编程语言，用于<strong>实现网页的动态行为和交互</strong>。它可以操作 HTML 和 CSS，处理用户事件，并与服务器进行通信。</li><li><strong>核心概念</strong>：<ul><li><strong>DOM (Document Object Model) 操作</strong>：通过 <code>document</code> 对象，JS 可以获取、修改、添加或删除页面上的 HTML 元素。例如 <code>document.getElementById(&#39;myId&#39;)</code>。</li><li><strong>事件处理（Event Handling）</strong>：响应用户的行为，如点击、输入、鼠标移动等。例如 <code>element.addEventListener(&#39;click&#39;, function() &#123; ... &#125;)</code>。</li><li><strong>异步编程（Asynchronous Programming）</strong>：处理耗时操作，如网络请求。<ul><li><strong>Callback (回调函数)</strong>：传统方式。</li><li><strong>Promise</strong>：ES6 引入，解决了回调地狱问题。</li><li><strong>async&#x2F;await</strong>：基于 <code>Promise</code> 的语法糖，使异步代码看起来像同步代码，更易读。</li></ul></li><li><strong>AJAX (Asynchronous JavaScript and XML)</strong>：在不重新加载整个页面的情况下，与服务器进行异步通信。现代应用中通常使用 <code>fetch()</code> API 或 <code>Axios</code> 库来发送 JSON 数据。</li></ul></li></ul><hr><h3 id="二、现代前端框架：提升开发效率"><a href="#二、现代前端框架：提升开发效率" class="headerlink" title="二、现代前端框架：提升开发效率"></a>二、现代前端框架：提升开发效率</h3><p>为了处理日益复杂的 Web 应用，开发者通常会使用以下框架。</p><ul><li><strong>React</strong>：由 Facebook 开发，<strong>组件化</strong>、<strong>声明式</strong>的 UI 库。<ul><li><strong>核心</strong>：<strong>组件（Components）</strong>，将 UI 拆分成独立、可复用的部分。</li><li><strong>工作原理</strong>：使用<strong>虚拟 DOM (Virtual DOM)</strong>，在内存中进行计算，然后只更新实际改变的部分，提高了性能。</li><li><strong>生态</strong>：庞大而活跃，有成熟的状态管理（Redux, Zustand）、路由（React Router）等解决方案。</li></ul></li><li><strong>Vue.js</strong>：由尤雨溪开发，易学易用，<strong>渐进式</strong>框架。<ul><li><strong>核心</strong>：<strong>响应式数据绑定</strong>，数据改变，视图自动更新。</li><li><strong>特点</strong>：上手快，文档友好，社区生态完善。</li></ul></li><li><strong>Angular</strong>：由 Google 开发，<strong>全能型</strong>框架。<ul><li><strong>核心</strong>：提供了完整的解决方案，包括路由、依赖注入、状态管理等。</li><li><strong>特点</strong>：适合大型企业级应用，学习曲线相对陡峭。</li></ul></li></ul><hr><h3 id="三、工程化：高效协作和自动化"><a href="#三、工程化：高效协作和自动化" class="headerlink" title="三、工程化：高效协作和自动化"></a>三、工程化：高效协作和自动化</h3><p>现代前端开发已经不仅仅是写代码，还需要使用一系列工具来提高效率。</p><ul><li><strong>包管理器</strong>：<code>npm</code>, <code>yarn</code>, <code>pnpm</code>。用于管理项目依赖。</li><li><strong>构建工具</strong>：<ul><li><strong>Webpack</strong>：将多个模块打包成一个或多个文件，并能处理资源依赖、代码压缩等。</li><li><strong>Vite</strong>：基于 ES Modules 的新一代构建工具，开发模式下速度极快。</li></ul></li><li><strong>转译工具</strong>：<strong>Babel</strong>。将 ES6+ 的代码转译为浏览器兼容的 ES5 代码。</li><li><strong>代码规范</strong>：<strong>ESLint</strong> (代码风格检查), <strong>Prettier</strong> (代码格式化)。</li><li><strong>版本控制</strong>：<strong>Git</strong>。用于团队协作和代码版本管理。</li></ul><p>好的，让我们详细、全面地介绍 CSS 选择器。选择器是 CSS 的核心，掌握它才能精确地控制网页样式。我们将从基础到高级，系统地梳理不同类型的选择器及其用法。</p><hr><h3 id="一、基础选择器-Basic-Selectors"><a href="#一、基础选择器-Basic-Selectors" class="headerlink" title="一、基础选择器 (Basic Selectors)"></a>一、基础选择器 (Basic Selectors)</h3><p>这些是 CSS 中最简单、最常用的选择器，用于直接选中元素。</p><h4 id="1-元素选择器-Type-Selector"><a href="#1-元素选择器-Type-Selector" class="headerlink" title="1. 元素选择器 (Type Selector)"></a>1. 元素选择器 (Type Selector)</h4><ul><li><strong>作用</strong>：根据元素的标签名来选择元素。</li><li><strong>语法</strong>：<code>element_name &#123; ... &#125;</code></li><li><strong>示例</strong>：<ul><li><code>p &#123; color: blue; &#125;</code>：选中所有 <code>&lt;p&gt;</code> 元素。</li><li><code>h1 &#123; font-size: 24px; &#125;</code>：选中所有 <code>&lt;h1&gt;</code> 元素。</li></ul></li></ul><h4 id="2-类选择器-Class-Selector"><a href="#2-类选择器-Class-Selector" class="headerlink" title="2. 类选择器 (Class Selector)"></a>2. 类选择器 (Class Selector)</h4><ul><li><strong>作用</strong>：根据元素的 <code>class</code> 属性来选择元素。</li><li><strong>语法</strong>：<code>.class_name &#123; ... &#125;</code></li><li><strong>特点</strong>：一个元素可以有多个类名，类名可以重复使用，非常灵活。</li><li><strong>示例</strong>：<ul><li><code>.highlight &#123; background-color: yellow; &#125;</code>：选中所有 <code>class</code> 属性中包含 <code>highlight</code> 的元素。</li></ul></li></ul><h4 id="3-ID-选择器-ID-Selector"><a href="#3-ID-选择器-ID-Selector" class="headerlink" title="3. ID 选择器 (ID Selector)"></a>3. ID 选择器 (ID Selector)</h4><ul><li><strong>作用</strong>：根据元素的 <code>id</code> 属性来选择元素。</li><li><strong>语法</strong>：<code>#id_name &#123; ... &#125;</code></li><li><strong>特点</strong>：在 HTML 文档中，一个 <code>id</code> 属性的值必须是<strong>唯一的</strong>。</li><li><strong>示例</strong>：<ul><li><code>#header &#123; height: 100px; &#125;</code>：选中 <code>id</code> 为 <code>header</code> 的唯一元素。</li></ul></li></ul><h4 id="4-通用选择器-Universal-Selector"><a href="#4-通用选择器-Universal-Selector" class="headerlink" title="4. 通用选择器 (Universal Selector)"></a>4. 通用选择器 (Universal Selector)</h4><ul><li><strong>作用</strong>：选择页面上的所有元素。</li><li><strong>语法</strong>：<code>* &#123; ... &#125;</code></li><li><strong>示例</strong>：<ul><li><code>* &#123; margin: 0; padding: 0; &#125;</code>：清除所有元素的默认外边距和内边距，常用于 CSS 重置。</li></ul></li></ul><hr><h3 id="二、组合选择器-Combinators"><a href="#二、组合选择器-Combinators" class="headerlink" title="二、组合选择器 (Combinators)"></a>二、组合选择器 (Combinators)</h3><p>这些选择器用于根据元素之间的关系来选择元素，如父子关系、兄弟关系等。</p><h4 id="1-后代选择器-Descendant-Selector"><a href="#1-后代选择器-Descendant-Selector" class="headerlink" title="1. 后代选择器 (Descendant Selector)"></a>1. 后代选择器 (Descendant Selector)</h4><ul><li><strong>作用</strong>：选择某个元素内部的<strong>所有</strong>后代元素（包括子元素、孙子元素等）。</li><li><strong>语法</strong>：<code>ancestor descendant &#123; ... &#125;</code>，用<strong>空格</strong>分隔。</li><li><strong>示例</strong>：<ul><li><code>ul li &#123; list-style-type: none; &#125;</code>：选中所有 <code>&lt;ul&gt;</code> 内部的 <code>&lt;li&gt;</code> 元素。</li></ul></li></ul><h4 id="2-子选择器-Child-Selector"><a href="#2-子选择器-Child-Selector" class="headerlink" title="2. 子选择器 (Child Selector)"></a>2. 子选择器 (Child Selector)</h4><ul><li><strong>作用</strong>：选择某个元素的<strong>直接子元素</strong>。</li><li><strong>语法</strong>：<code>parent &gt; child &#123; ... &#125;</code>，用 <code>&gt;</code> 分隔。</li><li><strong>示例</strong>：<ul><li><code>ul &gt; li &#123; list-style-type: none; &#125;</code>：只选中 <code>&lt;ul&gt;</code> 的直接子元素 <code>&lt;li&gt;</code>。</li><li><strong>区别</strong>：与后代选择器相比，更加精确，性能也更好。</li></ul></li></ul><h4 id="3-相邻兄弟选择器-Adjacent-Sibling-Selector"><a href="#3-相邻兄弟选择器-Adjacent-Sibling-Selector" class="headerlink" title="3. 相邻兄弟选择器 (Adjacent Sibling Selector)"></a>3. 相邻兄弟选择器 (Adjacent Sibling Selector)</h4><ul><li><strong>作用</strong>：选择紧接在另一个元素后面的<strong>兄弟元素</strong>。</li><li><strong>语法</strong>：<code>element + adjacent_element &#123; ... &#125;</code>，用 <code>+</code> 分隔。</li><li><strong>示例</strong>：<ul><li><code>h1 + p &#123; margin-top: 0; &#125;</code>：选中紧跟在 <code>&lt;h1&gt;</code> 后的第一个 <code>&lt;p&gt;</code> 元素。</li></ul></li></ul><h4 id="4-通用兄弟选择器-General-Sibling-Selector"><a href="#4-通用兄弟选择器-General-Sibling-Selector" class="headerlink" title="4. 通用兄弟选择器 (General Sibling Selector)"></a>4. 通用兄弟选择器 (General Sibling Selector)</h4><ul><li><strong>作用</strong>：选择某个元素后面<strong>所有</strong>的兄弟元素（不限于紧邻的）。</li><li><strong>语法</strong>：<code>element ~ sibling &#123; ... &#125;</code>，用 <code>~</code> 分隔。</li><li><strong>示例</strong>：<ul><li><code>h1 ~ p &#123; margin-top: 0; &#125;</code>：选中 <code>&lt;h1&gt;</code> 后的所有 <code>&lt;p&gt;</code> 元素。</li></ul></li></ul><hr><h3 id="三、属性选择器-Attribute-Selectors"><a href="#三、属性选择器-Attribute-Selectors" class="headerlink" title="三、属性选择器 (Attribute Selectors)"></a>三、属性选择器 (Attribute Selectors)</h3><p>这些选择器根据元素的属性及其值来选择元素。</p><ul><li><strong>[attribute]</strong>：选择具有该属性的元素。<ul><li><code>[title] &#123; ... &#125;</code>：选中所有具有 <code>title</code> 属性的元素。</li></ul></li><li><strong>[attribute&#x3D;”value”]</strong>：选择具有特定属性和值的元素。<ul><li><code>input[type=&quot;text&quot;] &#123; ... &#125;</code>：选中所有 <code>type</code> 属性值为 <code>text</code> 的 <code>&lt;input&gt;</code> 元素。</li></ul></li><li><strong>[attribute~&#x3D;”value”]</strong>：选择属性值中包含特定<strong>独立单词</strong>的元素。<ul><li><code>[class~=&quot;box&quot;] &#123; ... &#125;</code>：选中所有 <code>class</code> 属性中包含 <code>box</code> 这个独立单词的元素（如 <code>class=&quot;card box&quot;</code>）。</li></ul></li><li><strong>[attribute|&#x3D;”value”]</strong>：选择属性值以特定字符串开头（后跟连字符 <code>-</code>）的元素。<ul><li><code>[lang|=&quot;en&quot;] &#123; ... &#125;</code>：选中 <code>lang</code> 属性值为 <code>en</code> 或 <code>en-us</code> 等的元素。</li></ul></li><li><strong>[attribute^&#x3D;”value”]</strong>：选择属性值以特定字符串开头的元素。<ul><li><code>a[href^=&quot;https&quot;] &#123; ... &#125;</code>：选中所有 <code>href</code> 属性以 <code>https</code> 开头的 <code>&lt;a&gt;</code> 元素。</li></ul></li><li><strong>[attribute$&#x3D;”value”]</strong>：选择属性值以特定字符串结尾的元素。<ul><li><code>img[src$=&quot;.png&quot;] &#123; ... &#125;</code>：选中所有 <code>src</code> 属性以 <code>.png</code> 结尾的 <code>&lt;img&gt;</code> 元素。</li></ul></li><li><strong>[attribute*&#x3D;”value”]</strong>：选择属性值中包含特定字符串的元素。<ul><li><code>[title*=&quot;hello&quot;] &#123; ... &#125;</code>：选中所有 <code>title</code> 属性值中包含 <code>hello</code> 的元素。</li></ul></li></ul><hr><h3 id="四、伪类选择器-Pseudo-class-Selectors"><a href="#四、伪类选择器-Pseudo-class-Selectors" class="headerlink" title="四、伪类选择器 (Pseudo-class Selectors)"></a>四、伪类选择器 (Pseudo-class Selectors)</h3><p>伪类用于选择元素的<strong>特定状态</strong>。</p><ul><li><strong>a:link</strong>：未访问的链接。</li><li><strong>a:visited</strong>：已访问的链接。</li><li><strong>a:hover</strong>：鼠标悬停在元素上。</li><li><strong>a:active</strong>：元素被点击时。</li><li><strong>element:focus</strong>：元素获得焦点时（常用于表单）。</li><li><strong>:nth-child(n)</strong>：选择属于其父元素的第 n 个子元素。</li><li><strong>:first-child</strong>：选择属于其父元素的第一个子元素。</li><li><strong>:last-child</strong>：选择属于其父元素的最后一个子元素。</li><li><strong>:not(selector)</strong>：选择不匹配指定选择器的元素。</li><li><strong>:empty</strong>：选择没有子元素或文本内容的元素。</li></ul><hr><h3 id="五、伪元素选择器-Pseudo-element-Selectors"><a href="#五、伪元素选择器-Pseudo-element-Selectors" class="headerlink" title="五、伪元素选择器 (Pseudo-element Selectors)"></a>五、伪元素选择器 (Pseudo-element Selectors)</h3><p>伪元素用于选择元素的<strong>特定部分</strong>。</p><ul><li><strong>::first-line</strong>：选择元素的第一行。</li><li><strong>::first-letter</strong>：选择元素的首个字母。</li><li><strong>::before</strong>：在元素的内容前面插入生成的内容。</li><li><strong>::after</strong>：在元素的内容后面插入生成的内容。</li></ul><hr><h3 id="优先级与层叠"><a href="#优先级与层叠" class="headerlink" title="优先级与层叠"></a>优先级与层叠</h3><p>当多个选择器选中同一个元素并应用不同的样式时，浏览器会根据**优先级（Specificity）**来决定最终样式。</p><ul><li><strong>优先级计算</strong>：<ul><li><code>!important</code>：最高优先级。</li><li><strong>行内样式</strong>：1000</li><li><strong>ID 选择器</strong>：100</li><li><strong>类、属性、伪类选择器</strong>：10</li><li><strong>元素、伪元素选择器</strong>：1</li><li><strong>通用选择器</strong>：0</li></ul></li><li><strong>举例</strong>：<ul><li><code>p &#123; color: red; &#125;</code>（优先级 1）</li><li><code>.highlight &#123; color: blue; &#125;</code>（优先级 10）</li><li><code>#main p &#123; color: green; &#125;</code>（优先级 101）</li></ul></li></ul><p>在这个例子中，即使 <code>p</code> 的样式最先声明，但 <code>main p</code> 的优先级最高，因此 <code>&lt;p id=&quot;main&quot;&gt;</code> 的字体颜色最终会是绿色。</p><p>好的，让我们来全面、深入地介绍 Maven，并剖析一些关键细节以及面试中可能遇到的问题。</p><hr><h3 id="一、Maven-核心概念"><a href="#一、Maven-核心概念" class="headerlink" title="一、Maven 核心概念"></a>一、Maven 核心概念</h3><h4 id="1-什么是-Maven？"><a href="#1-什么是-Maven？" class="headerlink" title="1. 什么是 Maven？"></a>1. 什么是 Maven？</h4><p>Maven 是一个<strong>项目管理和构建自动化工具</strong>。它提供了一套标准化的项目结构、统一的构建生命周期，并依赖于一个<strong>中央仓库</strong>来管理项目所需的依赖。</p><p>它的核心思想是**“约定优于配置”（Convention over Configuration）**，这意味着它有一套默认的项目目录结构和构建流程。只要你遵循这些约定，就可以用很少的配置完成复杂的构建任务。</p><h4 id="2-为什么需要-Maven？"><a href="#2-为什么需要-Maven？" class="headerlink" title="2. 为什么需要 Maven？"></a>2. 为什么需要 Maven？</h4><p>在 Maven 出现之前，Java 项目的构建非常混乱：</p><ul><li><strong>项目结构不统一</strong>：每个项目都有自己的目录结构，新成员需要花时间熟悉。</li><li><strong>依赖管理混乱</strong>：需要手动下载所有 JAR 包，并添加到项目中，非常容易出错。</li><li><strong>构建过程不统一</strong>：编译、测试、打包等操作需要手动执行脚本，效率低下。</li></ul><p>Maven 通过<strong>标准化</strong>解决了这些问题：</p><ul><li><strong>标准化的项目结构</strong>：所有 Maven 项目都遵循相同的目录结构，如 <code>src/main/java</code>、<code>src/test/java</code> 等。</li><li><strong>统一的依赖管理</strong>：通过在 <code>pom.xml</code> 中声明依赖，Maven 会自动从仓库下载并管理。</li><li><strong>标准化的构建生命周期</strong>：定义了一系列标准的构建阶段（如 <code>compile</code>, <code>test</code>, <code>package</code>），可以一键执行。</li></ul><hr><h3 id="二、Maven-的核心组成部分"><a href="#二、Maven-的核心组成部分" class="headerlink" title="二、Maven 的核心组成部分"></a>二、Maven 的核心组成部分</h3><h4 id="1-POM-Project-Object-Model"><a href="#1-POM-Project-Object-Model" class="headerlink" title="1. POM (Project Object Model)"></a>1. POM (Project Object Model)</h4><ul><li><strong>概念</strong>：<code>pom.xml</code> 文件是 Maven 项目的<strong>核心配置文件</strong>。它定义了项目的元数据、依赖、插件、构建配置等所有信息。</li><li><strong>重要标签</strong>：<ul><li><code>&lt;project&gt;</code>：根元素。</li><li><code>&lt;groupId&gt;</code>, <code>&lt;artifactId&gt;</code>, <code>&lt;version&gt;</code>：项目的唯一标识符，通常称为 <strong>GAV 坐标</strong>。</li><li><code>&lt;packaging&gt;</code>：打包类型，如 <code>jar</code>, <code>war</code>, <code>pom</code>。</li><li><code>&lt;dependencies&gt;</code>：定义项目所需的依赖。</li><li><code>&lt;parent&gt;</code>：继承父 POM，实现依赖的统一管理。</li><li><code>&lt;build&gt;</code>：定义构建过程，如插件配置。</li></ul></li></ul><h4 id="2-依赖管理-Dependency-Management"><a href="#2-依赖管理-Dependency-Management" class="headerlink" title="2. 依赖管理 (Dependency Management)"></a>2. 依赖管理 (Dependency Management)</h4><ul><li><strong>概念</strong>：通过在 <code>&lt;dependencies&gt;</code> 中定义 GAV 坐标，Maven 会自动从本地或远程仓库下载依赖。</li><li><strong>传递性依赖</strong>：如果你的项目依赖 A，A 又依赖 B，Maven 会自动将 B 也下载下来。这是其强大的地方，但有时也可能导致版本冲突。</li><li><strong><dependencyManagement></strong>：这是一个非常重要的标签，通常在<strong>父 POM</strong> 中使用。它只定义依赖的版本，但<strong>不实际引入</strong>。子项目继承后，只需声明 <code>&lt;artifactId&gt;</code> 和 <code>&lt;groupId&gt;</code>，版本号会自动继承，这能确保整个项目所有模块的依赖版本一致。</li></ul><h4 id="3-仓库-Repositories"><a href="#3-仓库-Repositories" class="headerlink" title="3. 仓库 (Repositories)"></a>3. 仓库 (Repositories)</h4><p>Maven 仓库是用来存放所有依赖 JAR 包的地方。它分为三种：</p><ul><li><strong>本地仓库 (Local Repository)</strong>：<code>~/.m2/repository</code>，首次下载的依赖会存放在这里，后续构建时会优先从这里读取。</li><li><strong>远程仓库 (Remote Repository)</strong>：<ul><li><strong>中央仓库 (Central Repository)</strong>：Maven 官方维护的公共仓库，包含了绝大多数常用的开源库。</li><li><strong>私服 (Private Repository)</strong>：企业内部搭建的仓库，用于存放公司内部的 JAR 包或作为中央仓库的代理，加快下载速度。</li></ul></li></ul><h4 id="4-生命周期与阶段-Lifecycle-Phases"><a href="#4-生命周期与阶段-Lifecycle-Phases" class="headerlink" title="4. 生命周期与阶段 (Lifecycle &amp; Phases)"></a>4. 生命周期与阶段 (Lifecycle &amp; Phases)</h4><p>Maven 有一套标准的构建生命周期，分为三个：</p><ul><li><strong>clean</strong>：清理项目。<ul><li><code>clean</code>：删除 <code>target</code> 目录。</li></ul></li><li><strong>default</strong>：构建项目。<ul><li><code>validate</code></li><li><code>compile</code>：编译源代码。</li><li><code>test</code>：运行测试。</li><li><code>package</code>：打包。</li><li><code>install</code>：安装到本地仓库。</li><li><code>deploy</code>：部署到远程仓库。</li></ul></li><li><strong>site</strong>：生成项目站点。</li></ul><p><strong>重要规则</strong>：执行某个阶段时，它之前的所有阶段都会按顺序执行。例如，<code>mvn package</code> 会自动执行 <code>compile</code> 和 <code>test</code>。</p><hr><h3 id="三、面试常见问题与回答技巧"><a href="#三、面试常见问题与回答技巧" class="headerlink" title="三、面试常见问题与回答技巧"></a>三、面试常见问题与回答技巧</h3><h4 id="1-Maven-的-GAV-坐标是什么？有什么作用？"><a href="#1-Maven-的-GAV-坐标是什么？有什么作用？" class="headerlink" title="1. Maven 的 GAV 坐标是什么？有什么作用？"></a>1. Maven 的 GAV 坐标是什么？有什么作用？</h4><ul><li><strong>回答</strong>：GAV 坐标是 Maven 项目的唯一标识符，由 <code>&lt;groupId&gt;</code>, <code>&lt;artifactId&gt;</code>, 和 <code>&lt;version&gt;</code> 三个元素组成。</li><li><strong>作用</strong>：<ul><li><strong>唯一性</strong>：确保每个项目和每个版本的依赖在仓库中都是唯一的。</li><li><strong>定位</strong>：Maven 通过 GAV 坐标来查找和下载依赖。</li><li><strong>传递性</strong>：在传递性依赖中，通过 GAV 坐标来识别和处理依赖关系。</li></ul></li></ul><h4 id="2-和-有什么区别？"><a href="#2-和-有什么区别？" class="headerlink" title="2. &lt;dependencyManagement&gt; 和 &lt;dependencies&gt; 有什么区别？"></a>2. <code>&lt;dependencyManagement&gt;</code> 和 <code>&lt;dependencies&gt;</code> 有什么区别？</h4><ul><li><strong>回答</strong>：这是面试高频问题，需要清晰地说明两者的职责。</li><li><strong><dependencies></strong>：<strong>实际引入</strong>依赖。它用于在当前项目中添加一个具体的依赖，Maven 会立即下载并使用它。</li><li><strong><dependencyManagement></strong>：<strong>只定义版本</strong>。它只声明依赖的版本，但<strong>不实际引入</strong>。其主要目的是<strong>统一管理子模块的依赖版本</strong>。子模块继承父 POM 后，只需在自己的 <code>&lt;dependencies&gt;</code> 中声明 <code>&lt;groupId&gt;</code> 和 <code>&lt;artifactId&gt;</code>，版本号会自动从父 POM 中继承，这避免了版本不一致的问题。</li></ul><h4 id="3-什么是-Maven-的生命周期？mvn-install-和-mvn-deploy-有什么区别？"><a href="#3-什么是-Maven-的生命周期？mvn-install-和-mvn-deploy-有什么区别？" class="headerlink" title="3. 什么是 Maven 的生命周期？mvn install 和 mvn deploy 有什么区别？"></a>3. 什么是 Maven 的生命周期？<code>mvn install</code> 和 <code>mvn deploy</code> 有什么区别？</h4><ul><li><strong>回答</strong>：</li><li><strong>生命周期</strong>：Maven 有三个标准的生命周期：<code>clean</code>、<code>default</code> 和 <code>site</code>。其中 <code>default</code> 包含了从编译到部署的所有阶段。</li><li><strong>mvn install</strong>：执行 <code>default</code> 生命周期到 <code>install</code> 阶段。它会将项目打包，并安装到<strong>本地仓库</strong>。这样，其他本地项目就可以依赖这个包。</li><li><strong>mvn deploy</strong>：执行 <code>default</code> 生命周期到 <code>deploy</code> 阶段。它会将项目打包，并部署到<strong>远程仓库</strong>（私服或中央仓库）。这使得其他团队成员或项目可以从远程仓库获取并使用这个包。</li></ul><h4 id="4-Maven-依赖冲突如何解决？"><a href="#4-Maven-依赖冲突如何解决？" class="headerlink" title="4. Maven 依赖冲突如何解决？"></a>4. Maven 依赖冲突如何解决？</h4><ul><li><strong>回答</strong>：当多个依赖间接引入了同一个库的不同版本时，就会发生依赖冲突。</li><li><strong>解决策略</strong>：<ul><li><strong>依赖调解（Dependency Mediation）</strong>：Maven 的默认规则是“<strong>路径最短者优先</strong>”。即在依赖树中，路径最短的那个版本会被选中。</li><li><strong>手动排除（Exclusion）</strong>：如果默认规则不能解决问题，可以在 <code>&lt;dependency&gt;</code> 标签内使用 <code>&lt;exclusions&gt;</code> 标签手动排除有问题的传递性依赖。</li><li><strong>手动引入（Declaration）</strong>：在 <code>&lt;dependencies&gt;</code> 中明确声明需要使用的版本。Maven 的另一个规则是“<strong>最近声明者优先</strong>”，即如果两个依赖路径长度相同，先声明的那个会被使用。但更好的做法是直接在父 POM 的 <code>&lt;dependencyManagement&gt;</code> 中统一版本。</li></ul></li></ul><p>好的，我们来详细梳理你提供的这份关于会话技术的笔记，并按照你要求的逻辑，以一种更清晰、更专业的面试回答或技术讲解的方式进行重新组织和补充。</p><hr><h3 id="一、会话技术概述：解决-HTTP-无状态问题"><a href="#一、会话技术概述：解决-HTTP-无状态问题" class="headerlink" title="一、会话技术概述：解决 HTTP 无状态问题"></a>一、会话技术概述：解决 HTTP 无状态问题</h3><p>HTTP 协议本身是无状态的，它不记得上一次请求的任何信息。为了在多次请求之间共享数据并识别用户，引入了两种核心的会话技术：客户端会话（Cookie）和服务器端会话（Session）。</p><h3 id="二、客户端会话：Cookie"><a href="#二、客户端会话：Cookie" class="headerlink" title="二、客户端会话：Cookie"></a>二、客户端会话：Cookie</h3><p><strong>核心概念</strong>：Cookie 是服务器发送给浏览器并存储在客户端的一小段文本信息。浏览器在下次访问同一服务器时会自动将该 Cookie 携带在请求中。</p><h4 id="1-关于-Cookie-的几个常见问题"><a href="#1-关于-Cookie-的几个常见问题" class="headerlink" title="1. 关于 Cookie 的几个常见问题"></a>1. 关于 Cookie 的几个常见问题</h4><ul><li><strong>一次请求响应可以发送多个 Cookie 吗？</strong><ul><li><strong>回答</strong>：<strong>可以</strong>。服务器可以在一个响应中通过多个 <code>Set-Cookie</code> 响应头来设置多个 Cookie。浏览器会分别存储这些 Cookie，并在后续请求中将它们全部发送给服务器。</li></ul></li><li><strong>Cookie 支持中文传输吗？</strong><ul><li><strong>回答</strong>：<strong>在大多数现代服务器和浏览器中都支持。</strong> 在早期的 Servlet 容器（如 Tomcat 8.0 之前），Cookie 不能直接存储中文，需要手动进行 URL 编码（<code>URLEncoder</code>）和解码（<code>URLDecoder</code>）。<strong>在 Tomcat 8.0 及以后版本</strong>，容器默认支持 UTF-8 编码，可以直接存储中文。</li></ul></li><li><strong>Cookie 的过期时间如何设置？</strong><ul><li><strong>回答</strong>：通过 <code>response.addCookie(cookie)</code> 方法，并调用 <code>cookie.setMaxAge(int expiry)</code> 方法来设置。<ul><li><code>expiry &gt; 0</code>：表示 Cookie 将被<strong>持久化</strong>到客户端硬盘，有效期为 <code>expiry</code> 秒。即使浏览器关闭，Cookie 依然存在，直到过期。</li><li><code>expiry = 0</code>：表示<strong>立即删除</strong>该 Cookie。常用于退出登录功能。</li><li><code>expiry &lt; 0</code>：<strong>默认值</strong>。表示 Cookie 只在内存中存在，当<strong>浏览器关闭时</strong>，该 Cookie 就会被删除。</li></ul></li></ul></li></ul><h4 id="2-Cookie-的特点"><a href="#2-Cookie-的特点" class="headerlink" title="2. Cookie 的特点"></a>2. Cookie 的特点</h4><ul><li><strong>存储位置</strong>：存储在客户端（浏览器）。</li><li><strong>大小限制</strong>：单个 Cookie 最大约 4KB。</li><li><strong>数量限制</strong>：一个服务器最多可以向一个浏览器保存 20 个 Cookie，一个浏览器最多可以保存 300 个 Cookie（这些是早期的规范，现代浏览器已放宽，但仍有限制）。</li><li><strong>安全性</strong>：数据以明文形式存储，且容易被用户修改，安全性较差。</li></ul><h4 id="3-Cookie-案例：获取上一次访问时间"><a href="#3-Cookie-案例：获取上一次访问时间" class="headerlink" title="3. Cookie 案例：获取上一次访问时间"></a>3. Cookie 案例：获取上一次访问时间</h4><p>这个案例是经典的 Cookie 用法。</p><ul><li><strong>首次访问</strong>：服务器接收请求，判断 Cookie 中没有记录上次访问时间。服务器创建一个新的 Cookie，存储当前时间，并将其发送给浏览器。</li><li><strong>再次访问</strong>：浏览器自动将上次存储的 Cookie 发送给服务器。服务器读取 Cookie，获取上次访问时间，并将其显示给用户。然后，服务器可以更新 Cookie 的时间，再次发送给浏览器。</li></ul><h3 id="三、服务器端会话：HttpSession"><a href="#三、服务器端会话：HttpSession" class="headerlink" title="三、服务器端会话：HttpSession"></a>三、服务器端会话：HttpSession</h3><p><strong>核心概念</strong>：Session 是服务器端为每个客户端创建的一个对象，用于在一次会话的多个请求之间存储和共享数据。</p><h4 id="1-Session-的快速使用"><a href="#1-Session-的快速使用" class="headerlink" title="1. Session 的快速使用"></a>1. Session 的快速使用</h4><ul><li><strong>获取对象</strong>：通过 <code>HttpServletRequest</code> 对象的 <code>getSession()</code> 方法来获取 <code>HttpSession</code> 对象。</li><li><strong>使用对象（域对象）</strong>：Session 是一个<strong>域对象</strong>，提供了以下方法：<ul><li><code>void setAttribute(String name, Object value)</code>：将数据以键值对形式存储到 Session 中。</li><li><code>Object getAttribute(String name)</code>：根据键名获取存储的数据。</li><li><code>void removeAttribute(String name)</code>：根据键名删除存储的数据。</li></ul></li></ul><h4 id="2-Session-的失效时间"><a href="#2-Session-的失效时间" class="headerlink" title="2. Session 的失效时间"></a>2. Session 的失效时间</h4><ul><li><p><strong>服务器关闭</strong>：当服务器关闭时，所有 Session 对象都会被销毁。</p></li><li><p><strong>手动失效</strong>：调用 <code>session.invalidate()</code> 方法，可以立即强制 Session 失效。常用于用户退出登录。</p></li><li><p><strong>默认失效时间</strong>：默认情况下，Session 有一个超时时间，通常是 30 分钟。如果客户端在 30 分钟内没有向服务器发送任何请求，Session 就会自动失效。这个时间可以在 <code>web.xml</code> 中配置。</p></li><li><p>对的 👍，在 **Java Web 应用（Servlet 容器，比如 Tomcat）**里，<code>Session</code> 的默认失效时间通常是 <strong>30 分钟</strong>。</p><p>要修改它，可以在 <code>web.xml</code> 中配置 <code>&lt;session-config&gt;</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- session 过期时间设置（单位：分钟） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>60<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>📌 说明：</p><ul><li><code>60</code> 表示 Session 在 <strong>60 分钟</strong>无请求时会自动失效。</li><li>默认值是 <strong>30</strong> 分钟，如果不配置，就走默认。</li><li>这个配置对所有用户 Session 都生效。</li></ul><h3 id="🔧-在代码里动态设置（单个-Session）"><a href="#🔧-在代码里动态设置（单个-Session）" class="headerlink" title="🔧 在代码里动态设置（单个 Session）"></a>🔧 在代码里动态设置（单个 Session）</h3><p>除了在 <code>web.xml</code> 里全局配置，还可以针对某个用户的 Session 动态修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">session.setMaxInactiveInterval(<span class="number">120</span> * <span class="number">60</span>); <span class="comment">// 单位：秒，这里是 2 小时</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="🔧-特殊情况"><a href="#🔧-特殊情况" class="headerlink" title="🔧 特殊情况"></a>🔧 特殊情况</h3><ul><li>如果 <code>session-timeout</code> 设置为 <strong>0</strong> → Session 永不超时（危险 ⚠️，容易导致内存泄露）。</li><li>如果设置为 <strong>负数</strong>（如 -1） → 表示 Session 仅在浏览器关闭时销毁（有些容器支持，有些不支持。</li></ul><h4 id="3-Session-的特点"><a href="#3-Session-的特点" class="headerlink" title="3. Session 的特点"></a>3. Session 的特点</h4><ul><li><strong>存储位置</strong>：存储在服务器端。</li><li><strong>大小限制</strong>：可以存储任意类型、任意大小的数据（受限于服务器内存）。</li><li><strong>安全性</strong>：由于数据存储在服务器，客户端只传递一个 Session ID，安全性相对较高。</li></ul><h4 id="4-面试题：Cookie-和-Session-的区别？"><a href="#4-面试题：Cookie-和-Session-的区别？" class="headerlink" title="4. 面试题：Cookie 和 Session 的区别？"></a>4. 面试题：Cookie 和 Session 的区别？</h4><ul><li><strong>存储位置</strong>：Cookie 存储在<strong>客户端</strong>，Session 存储在<strong>服务器端</strong>。</li><li><strong>数据大小</strong>：Cookie 的大小<strong>有限制</strong>（约 4KB），Session 的大小<strong>没有限制</strong>。</li><li><strong>安全性</strong>：Session <strong>相对安全</strong>，Cookie <strong>相对不安全</strong>。因为 Session ID 难以被猜测，而 Cookie 存储的数据是明文。</li><li><strong>服务器开销</strong>：Session 会占用服务器内存，在高并发场景下可能成为性能瓶颈；而 Cookie 不占用服务器资源。</li></ul><h3 id="四、Servlet-三大域对象的关系（按照你的逻辑）"><a href="#四、Servlet-三大域对象的关系（按照你的逻辑）" class="headerlink" title="四、Servlet 三大域对象的关系（按照你的逻辑）"></a>四、Servlet 三大域对象的关系（按照你的逻辑）</h3><p><strong>域对象</strong>（Scope Object）是指那些可以用来在不同组件之间共享数据的对象。Servlet 规范提供了三个这样的对象，它们的生命周期不同，从而决定了数据的共享范围。</p><ul><li><strong>request 域</strong>：生命周期最短。数据只能在<strong>一次请求-响应</strong>的周期内共享。即使请求被转发（forward），数据也依然可见。</li><li><strong>session 域</strong>：生命周期中等。数据可以在<strong>一次会话</strong>（多个请求）之间共享。只要浏览器不关闭，且 Session 未超时或失效，数据就一直存在。</li><li><strong>servletContext 域</strong>：生命周期最长。数据可以在<strong>整个 Web 应用</strong>中共享。从 Web 应用启动到关闭，数据都一直存在。</li></ul><p><strong>三大域对象之间的关系是包含关系，即 request &lt; session &lt; servletContext。</strong></p><ul><li><strong>request 包含于 session</strong>：一个 Session 中可以有多个请求。</li><li><strong>session 包含于 servletContext</strong>：一个 Web 应用（ServletContext）中可以有多个 Session。</li></ul><p>这个关系图清晰地展示了它们各自的生命周期和数据共享范围，是理解 Servlet 域对象的关键。</p><p>啊哈～你这个场景就是 <strong>同一个库的两个版本必须共存</strong>，典型的 “深度 JAR hell” 🚨。<br> 比如：</p><ul><li>你的系统用到 <strong>老版本 log4j</strong>，</li><li>但某个第三方库硬性依赖 <strong>新版本 log4j</strong>。</li></ul><p>这时候如果放到同一个 classpath 里，肯定会冲突。解决思路主要有三类：</p><hr><h2 id="✅-两个版本-JAR-共存的解决方案"><a href="#✅-两个版本-JAR-共存的解决方案" class="headerlink" title="✅ 两个版本 JAR 共存的解决方案"></a>✅ 两个版本 JAR 共存的解决方案</h2><h3 id="1-ClassLoader-隔离（推荐方式）"><a href="#1-ClassLoader-隔离（推荐方式）" class="headerlink" title="1. ClassLoader 隔离（推荐方式）"></a>1. <strong>ClassLoader 隔离</strong>（推荐方式）</h3><p>利用 <strong>不同的类加载器</strong> 来隔离两个版本的依赖，让它们互不干扰。</p><ul><li><p><strong>Web 容器隔离</strong>：</p><ul><li>把一个版本放在 <code>WEB-INF/lib</code>，另一个放在全局 <code>lib/ext</code>。</li><li>通过 parent-first &#x2F; parent-last 策略控制加载。</li></ul></li><li><p><strong>自定义 ClassLoader</strong>：</p><ul><li><p>用 <code>URLClassLoader</code> 指定不同版本 JAR 的路径。</p></li><li><p>哪个模块需要哪个版本，就用哪个 ClassLoader。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">URLClassLoader loaderV1 = new URLClassLoader(</span><br><span class="line">    new URL[]&#123; new File(&quot;lib/lib-old.jar&quot;).toURI().toURL() &#125;,</span><br><span class="line">    null // 不委托父加载器</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">URLClassLoader loaderV2 = new URLClassLoader(</span><br><span class="line">    new URL[]&#123; new File(&quot;lib/lib-new.jar&quot;).toURI().toURL() &#125;,</span><br><span class="line">    null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; clazz1 = loaderV1.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">Class&lt;?&gt; clazz2 = loaderV2.loadClass(&quot;com.example.MyClass&quot;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>👉 OSGi、Spring Boot 的 <strong>ClassLoader 层级</strong>就是用这种方法解决多版本依赖的。</p><hr><h3 id="2-包重定位（Shading-Relocation）"><a href="#2-包重定位（Shading-Relocation）" class="headerlink" title="2. 包重定位（Shading &#x2F; Relocation）"></a>2. <strong>包重定位（Shading &#x2F; Relocation）</strong></h3><p>把其中一个版本的包路径 <strong>改名</strong>，让 JVM 认为它是完全不同的类库。</p><ul><li><p>工具：</p><ul><li><code>jarjar</code></li><li>Maven Shade（即使你不用 Maven，也可以单独跑插件）</li><li>Gradle Shadow</li></ul></li><li><p>原理：自动把 <code>org.apache.commons</code> 改成 <code>myproject.shaded.org.apache.commons</code>。</p></li><li><p>示例（JarJar 规则）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule org.apache.log4j.** com.myapp.shaded.log4j.@1</span><br></pre></td></tr></table></figure></li></ul><p>这样，项目就能同时用 <code>log4j-1.2</code> 和 <code>log4j-2.x</code>。</p><hr><h3 id="3-服务解耦-模块化"><a href="#3-服务解耦-模块化" class="headerlink" title="3. 服务解耦 &#x2F; 模块化"></a>3. <strong>服务解耦 &#x2F; 模块化</strong></h3><p>如果两个版本都要在 <strong>同一个 JVM 里用</strong>，但 ClassLoader 太麻烦：</p><ul><li><strong>拆分成微服务 &#x2F; 子进程</strong>，让不同进程使用不同版本的依赖。</li><li>或者在 <strong>Java 9+ 模块系统 (JPMS)</strong> 下，给不同模块声明不同依赖，避免直接冲突。</li></ul><hr><h2 id="🚀-实际建议"><a href="#🚀-实际建议" class="headerlink" title="🚀 实际建议"></a>🚀 实际建议</h2><ul><li>如果你是 <strong>自己开发的项目</strong> → 用 <strong>包重定位</strong> 比较简单。</li><li>如果是 <strong>插件式系统 &#x2F; 容器运行</strong> → 用 <strong>ClassLoader 隔离</strong>。</li><li>如果是 <strong>重量级系统</strong>（比如需要不同版本的 JDBC 驱动） → 拆进程更干净。</li></ul><hr><p>要不要我帮你写一个 <strong>最小可运行的 Java Demo</strong>（两个版本 JAR 同时运行，通过 ClassLoader 隔离）？这样你可以直接跑起来看看效果。</p><p>好的，我将根据您提供的这份详尽的笔记，以更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p><hr><h3 id="一、CSS-选择器概述：精准定位网页元素"><a href="#一、CSS-选择器概述：精准定位网页元素" class="headerlink" title="一、CSS 选择器概述：精准定位网页元素"></a>一、CSS 选择器概述：精准定位网页元素</h3><p><strong>选择器</strong>是 CSS 的核心，它用于<strong>精确地选择 HTML 文档中的元素</strong>，并为其应用样式。掌握不同类型的选择器及其组合，是高效编写 CSS 代码的关键。</p><h3 id="二、基础选择器-Basic-Selectors"><a href="#二、基础选择器-Basic-Selectors" class="headerlink" title="二、基础选择器 (Basic Selectors)"></a>二、基础选择器 (Basic Selectors)</h3><p>基础选择器用于根据最基本的属性（标签、类、ID）来选择元素。</p><h4 id="1-标签选择器-Type-Selector"><a href="#1-标签选择器-Type-Selector" class="headerlink" title="1. 标签选择器 (Type Selector)"></a>1. 标签选择器 (Type Selector)</h4><ul><li><p><strong>原理</strong>：根据元素的<strong>标签名称</strong>来匹配。</p></li><li><p><strong>优点</strong>：简单、直接，可以一次性选中所有同类型的元素。</p></li><li><p><strong>缺点</strong>：过于笼统，无法对个别元素进行精确控制。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123; color: red; &#125; /* 所有&lt;div&gt;标签的字体颜色都为红色 */</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-类选择器-Class-Selector-1"><a href="#2-类选择器-Class-Selector-1" class="headerlink" title="2. 类选择器 (Class Selector)"></a>2. 类选择器 (Class Selector)</h4><ul><li><p><strong>原理</strong>：根据元素的 <code>class</code> 属性值来匹配。</p></li><li><p><strong>优点</strong>：</p><ul><li><strong>高度复用</strong>：可以在多个元素上使用同一个类名。</li><li><strong>灵活</strong>：一个元素可以拥有多个类名，用空格分隔。</li></ul></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.cl1 &#123; color: red; &#125; /* 所有class属性包含cl1的元素，字体颜色为红色 */</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-ID-选择器-ID-Selector-1"><a href="#3-ID-选择器-ID-Selector-1" class="headerlink" title="3. ID 选择器 (ID Selector)"></a>3. ID 选择器 (ID Selector)</h4><ul><li><p><strong>原理</strong>：根据元素的 <code>id</code> 属性值来匹配。</p></li><li><p><strong>优点</strong>：<strong>唯一性</strong>，精确地选中文档中唯一的元素。</p></li><li><p><strong>缺点</strong>：不具复用性，一个 ID 在文档中只能出现一次。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#p1 &#123; color: red; &#125; /* id为p1的唯一元素，字体颜色为红色 */</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-通配符选择器-Universal-Selector"><a href="#4-通配符选择器-Universal-Selector" class="headerlink" title="4. 通配符选择器 (Universal Selector)"></a>4. 通配符选择器 (Universal Selector)</h4><ul><li><p><strong>原理</strong>：匹配文档中<strong>所有</strong>的元素。</p></li><li><p><strong>优点</strong>：可以快速设置全局样式，常用于重置浏览器默认样式。</p></li><li><p><strong>缺点</strong>：性能开销大，因为浏览器需要遍历所有元素，应谨慎使用。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123; margin: 0; padding: 0; &#125; /* 清除所有元素的内外边距 */</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="三、组合选择器-Combinators"><a href="#三、组合选择器-Combinators" class="headerlink" title="三、组合选择器 (Combinators)"></a>三、组合选择器 (Combinators)</h3><p>组合选择器通过符号连接多个选择器，根据元素之间的关系来匹配。</p><h4 id="1-交集选择器-Intersection-Selector"><a href="#1-交集选择器-Intersection-Selector" class="headerlink" title="1. 交集选择器 (Intersection Selector)"></a>1. 交集选择器 (Intersection Selector)</h4><ul><li><p><strong>原理</strong>：同时满足多个选择器条件的元素。</p></li><li><p><strong>语法</strong>：<code>selector1selector2 &#123; ... &#125;</code>，中间<strong>没有空格</strong>。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.cl1 &#123; color: red; &#125; /* 既是&lt;div&gt;标签，又拥有cl1这个class的元素 */</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-并集选择器-Union-Selector"><a href="#2-并集选择器-Union-Selector" class="headerlink" title="2. 并集选择器 (Union Selector)"></a>2. 并集选择器 (Union Selector)</h4><ul><li><p><strong>原理</strong>：匹配所有满足其中任意一个选择器条件的元素。</p></li><li><p><strong>语法</strong>：<code>selector1, selector2 &#123; ... &#125;</code>，以<strong>逗号</strong>分隔。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, p &#123; color: red; &#125; /* 所有&lt;a&gt;标签和所有&lt;p&gt;标签的字体颜色都为红色 */</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-子选择器-Child-Selector"><a href="#3-子选择器-Child-Selector" class="headerlink" title="3. 子选择器 (Child Selector)"></a>3. 子选择器 (Child Selector)</h4><ul><li><p><strong>原理</strong>：匹配<strong>直接</strong>子元素。</p></li><li><p><strong>语法</strong>：<code>parent &gt; child &#123; ... &#125;</code>，以 <code>&gt;</code> 符号分隔。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#outer &gt; span &#123; color: red; &#125; /* 只选中id为outer的&lt;div&gt;的直接子元素&lt;span&gt; */</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-后代选择器-Descendant-Selector"><a href="#4-后代选择器-Descendant-Selector" class="headerlink" title="4. 后代选择器 (Descendant Selector)"></a>4. 后代选择器 (Descendant Selector)</h4><ul><li><p><strong>原理</strong>：匹配所有位于祖先元素内部的<strong>所有后代</strong>元素。</p></li><li><p><strong>语法</strong>：<code>ancestor descendant &#123; ... &#125;</code>，以<strong>空格</strong>分隔。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#outer span &#123; color: red; &#125; /* 选中id为outer的&lt;div&gt;内部的所有&lt;span&gt;，无论嵌套多深 */</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="四、属性选择器-Attribute-Selectors"><a href="#四、属性选择器-Attribute-Selectors" class="headerlink" title="四、属性选择器 (Attribute Selectors)"></a>四、属性选择器 (Attribute Selectors)</h3><p>属性选择器根据元素的属性及其值来匹配。</p><ul><li><strong>[attribute]</strong>：匹配具有该属性的元素。<ul><li>示例：<code>[class]</code> 匹配所有具有 <code>class</code> 属性的元素。</li></ul></li><li><strong>[attribute&#x3D;”value”]</strong>：匹配属性值完全相等的元素。<ul><li>示例：<code>[type=&quot;text&quot;]</code> 匹配 <code>type</code> 属性值恰好为 <code>&quot;text&quot;</code> 的元素。</li></ul></li><li><strong>[attribute~&#x3D;”value”]</strong>：匹配属性值中包含该<strong>独立单词</strong>的元素。</li><li><strong>[attribute^&#x3D;”value”]</strong>：匹配属性值以该字符串<strong>开头</strong>的元素。</li><li><strong>[attribute$&#x3D;”value”]</strong>：匹配属性值以该字符串<strong>结尾</strong>的元素。</li><li><strong>[attribute*&#x3D;”value”]</strong>：匹配属性值中包含该字符串的<strong>任意位置</strong>的元素。</li></ul><hr><h3 id="五、伪类与伪元素选择器-Pseudo-class-Pseudo-element-Selectors"><a href="#五、伪类与伪元素选择器-Pseudo-class-Pseudo-element-Selectors" class="headerlink" title="五、伪类与伪元素选择器 (Pseudo-class &amp; Pseudo-element Selectors)"></a>五、伪类与伪元素选择器 (Pseudo-class &amp; Pseudo-element Selectors)</h3><ul><li><strong>伪类</strong>：用<strong>一个冒号 :</strong>，表示元素在<strong>特定状态</strong>下的样式。<ul><li><strong>:link</strong>：未访问的链接。</li><li><strong>:visited</strong>：已访问的链接。</li><li><strong>:hover</strong>：鼠标悬停状态。</li><li><strong>:active</strong>：被点击状态。</li><li><strong>:focus</strong>：获得焦点状态（常用于表单）。</li></ul></li><li><strong>伪元素</strong>：用<strong>两个冒号 ::</strong>，表示元素的<strong>特定部分</strong>。<ul><li><strong>::before</strong> 和 <strong>::after</strong>：在元素内容的前后插入内容。</li><li><strong>::first-line</strong>：元素的文本第一行。</li><li><strong>::first-letter</strong>：元素的文本第一个字母。</li></ul></li></ul><hr><h3 id="六、选择器优先级-Specificity"><a href="#六、选择器优先级-Specificity" class="headerlink" title="六、选择器优先级 (Specificity)"></a>六、选择器优先级 (Specificity)</h3><p>这是 CSS 的核心机制，决定了当多个规则应用到同一个元素时，哪一个会生效。</p><ul><li><strong>计算规则</strong>：优先级由<strong>选择器的类型</strong>和<strong>数量</strong>决定。<ol><li><strong>行内样式</strong>：优先级最高，为 <code>1000</code>。</li><li><strong>ID 选择器</strong>：优先级为 <code>100</code>。</li><li><strong>类、属性、伪类选择器</strong>：优先级为 <code>10</code>。</li><li><strong>元素、伪元素选择器</strong>：优先级为 <code>1</code>。</li><li><strong>通用选择器 *</strong>：优先级为 <code>0</code>。</li></ol></li><li><strong>!important</strong>：最高优先级，但会破坏层叠机制，应<strong>避免使用</strong>。</li></ul><p>如何计算：</p><p>将每个选择器的优先级数字相加，得到一个最终的权重值。权重值越高的规则越优先。</p><ul><li>示例：<ul><li><code>p</code>：权重 <code>1</code>。</li><li><code>.cl1</code>：权重 <code>10</code>。</li><li><code>div.cl1</code>：权重 <code>1 + 10 = 11</code>。</li><li><code>#p1</code>：权重 <code>100</code>。</li><li><code>#outer span</code>：权重 <code>100 + 1 = 101</code>。</li></ul></li></ul><p><strong>!important</strong> 会凌驾于所有这些规则之上。当你遇到样式不生效的问题时，首先要检查优先级，其次是是否有 <code>!important</code> 的存在。</p><p>好的，让我们来详细、深入地解释 <strong>BOM</strong> 和 <strong>DOM</strong> 这两个 JavaScript 在浏览器中操作网页的核心概念。</p><hr><h3 id="BOM-Browser-Object-Model"><a href="#BOM-Browser-Object-Model" class="headerlink" title="BOM (Browser Object Model)"></a>BOM (Browser Object Model)</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p><strong>BOM</strong>，即<strong>浏览器对象模型</strong>，是 JavaScript 用于<strong>操作浏览器窗口</strong>的一套 API。它没有统一的标准，而是由各个浏览器厂商各自实现的。BOM 的核心是 <code>window</code> 对象，它既代表了浏览器窗口本身，也是 JavaScript 全局作用域的唯一对象。</p><h4 id="2-BOM-的核心对象与功能"><a href="#2-BOM-的核心对象与功能" class="headerlink" title="2. BOM 的核心对象与功能"></a>2. BOM 的核心对象与功能</h4><p>BOM 提供了以下关键对象，用于与浏览器进行交互：</p><ul><li><strong>window 对象</strong>：<ul><li><strong>全局对象</strong>：<code>window</code> 是 JavaScript 的全局对象，所有全局变量和函数都是 <code>window</code> 对象的属性和方法。</li><li><strong>窗口控制</strong>：<code>window.open()</code> (打开新窗口), <code>window.close()</code> (关闭当前窗口)。</li><li><strong>定时器</strong>：<code>setTimeout()</code> 和 <code>setInterval()</code>，用于延迟或重复执行代码。</li><li><strong>导航与位置</strong>：<code>window.location</code>，用于获取和修改当前页面的 URL。</li></ul></li><li><strong>location 对象</strong>：<ul><li><strong>URL 信息</strong>：提供了当前 URL 的详细信息，如 <code>location.href</code> (完整 URL), <code>location.protocol</code> (协议), <code>location.hostname</code> (主机名), <code>location.pathname</code> (路径)。</li><li><strong>页面跳转</strong>：<code>location.href = &#39;new_url&#39;</code> 或 <code>location.assign(&#39;new_url&#39;)</code> (有历史记录), <code>location.replace(&#39;new_url&#39;)</code> (不留历史记录), <code>location.reload()</code> (刷新页面)。</li></ul></li><li><strong>history 对象</strong>：<ul><li><strong>历史记录</strong>：提供了对浏览器历史记录的访问。</li><li><strong>导航</strong>：<code>history.back()</code> (后退), <code>history.forward()</code> (前进), <code>history.go(n)</code> (前进或后退 n 页)。</li></ul></li><li><strong>navigator 对象</strong>：<ul><li><strong>浏览器信息</strong>：提供了关于浏览器本身的信息，如 <code>navigator.userAgent</code> (用户代理字符串), <code>navigator.platform</code> (操作系统), <code>navigator.onLine</code> (是否在线)。</li></ul></li><li><strong>screen 对象</strong>：<ul><li><strong>屏幕信息</strong>：提供了关于用户屏幕的信息，如 <code>screen.width</code> (屏幕宽度), <code>screen.height</code> (屏幕高度)。</li></ul></li></ul><h4 id="3-BOM-的特点"><a href="#3-BOM-的特点" class="headerlink" title="3. BOM 的特点"></a>3. BOM 的特点</h4><ul><li><strong>没有标准</strong>：BOM 没有 W3C 的正式标准，不同浏览器可能在实现上存在差异。</li><li><strong>以 window 为核心</strong>：所有 BOM 对象都是 <code>window</code> 对象的属性。</li></ul><hr><h3 id="DOM-Document-Object-Model"><a href="#DOM-Document-Object-Model" class="headerlink" title="DOM (Document Object Model)"></a>DOM (Document Object Model)</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h4><p><strong>DOM</strong>，即<strong>文档对象模型</strong>，是 JavaScript 用于<strong>操作 HTML 或 XML 文档</strong>的一套 API。它将整个 HTML 文档解析为一个<strong>树形结构</strong>，每个 HTML 标签、属性和文本都成为了树中的一个节点（Node）。DOM 是一个由 W3C 制定的标准。</p><h4 id="2-DOM-的核心对象与功能"><a href="#2-DOM-的核心对象与功能" class="headerlink" title="2. DOM 的核心对象与功能"></a>2. DOM 的核心对象与功能</h4><p>DOM 的核心是 <code>document</code> 对象，它是整个文档的入口。</p><ul><li><strong>document 对象</strong>：<ul><li><strong>DOM 树的根节点</strong>：代表整个 HTML 文档。</li><li><strong>元素获取</strong>：提供了多种方法来获取页面上的元素：<ul><li><code>document.getElementById(&#39;id&#39;)</code>：通过 ID 获取单个元素。</li><li><code>document.getElementsByClassName(&#39;class&#39;)</code>：通过类名获取元素集合。</li><li><code>document.getElementsByTagName(&#39;tag&#39;)</code>：通过标签名获取元素集合。</li><li><code>document.querySelector(&#39;css_selector&#39;)</code>：通过 CSS 选择器获取第一个匹配的元素。</li><li><code>document.querySelectorAll(&#39;css_selector&#39;)</code>：通过 CSS 选择器获取所有匹配的元素。</li></ul></li></ul></li><li><strong>元素节点（Element Nodes）</strong>：<ul><li><strong>操作元素</strong>：提供了操作 HTML 元素的方法和属性：<ul><li><code>element.innerHTML</code>：获取或设置元素的 HTML 内容。</li><li><code>element.style.color</code>：修改元素的行内样式。</li><li><code>element.setAttribute(&#39;attr&#39;, &#39;val&#39;)</code>：设置元素的属性。</li><li><code>element.addEventListener(&#39;event&#39;, handler)</code>：添加事件监听器。</li></ul></li></ul></li><li><strong>DOM 树操作</strong>：<ul><li><strong>创建</strong>：<code>document.createElement(&#39;tag&#39;)</code> (创建新元素)。</li><li><strong>添加</strong>：<code>parent.appendChild(child)</code> (添加子元素)。</li><li><strong>删除</strong>：<code>parent.removeChild(child)</code> (删除子元素)。</li><li><strong>替换</strong>：<code>parent.replaceChild(newChild, oldChild)</code> (替换子元素)。</li></ul></li></ul><h4 id="3-DOM-的特点"><a href="#3-DOM-的特点" class="headerlink" title="3. DOM 的特点"></a>3. DOM 的特点</h4><ul><li><strong>有标准</strong>：DOM 是由 W3C 制定的标准，因此在不同浏览器中的实现差异较小。</li><li><strong>树形结构</strong>：将 HTML 文档抽象为树形结构，使得我们可以通过编程的方式像操作树一样操作网页。</li></ul><hr><h3 id="BOM-和-DOM-的核心区别与联系"><a href="#BOM-和-DOM-的核心区别与联系" class="headerlink" title="BOM 和 DOM 的核心区别与联系"></a>BOM 和 DOM 的核心区别与联系</h3><table><thead><tr><th>特性</th><th>BOM (Browser Object Model)</th><th>DOM (Document Object Model)</th></tr></thead><tbody><tr><td><strong>主要功能</strong></td><td><strong>操作浏览器窗口</strong></td><td><strong>操作网页文档内容</strong></td></tr><tr><td><strong>核心对象</strong></td><td><code>window</code></td><td><code>document</code></td></tr><tr><td><strong>标准化</strong></td><td>无统一标准（各浏览器实现不同）</td><td>有 W3C 标准</td></tr><tr><td><strong>层级关系</strong></td><td><code>window</code> 包含了 <code>location</code>, <code>history</code>, <code>navigator</code> 等，<strong>也包含了 document 对象</strong>。</td><td><code>document</code> 包含了 HTML 元素的树形结构。</td></tr></tbody></table><p>它们的关系：</p><p>BOM 是 DOM 的超集。window 对象是所有 JavaScript 对象的全局对象，它包含了 document 对象。换句话说，window.document 就是 document。因此，当我们使用 document 对象来操作网页时，实际上是通过 window 对象来访问的。</p><p>这个关系可以理解为：</p><p>window -&gt; 浏览器窗口</p><p>document -&gt; 窗口中加载的文档</p><p>掌握 BOM 和 DOM 是成为一个合格前端工程师的基础，它们是 JavaScript 驱动 Web 页面交互的两个最重要的工具。</p><p>好的，我将根据您提供的这份 JS 学习笔记，以一种更深入、更条理化的方式，逐一进行详细的展开和补充。这不仅是对知识点的梳理，也包含了其背后的原理和一些进阶用法，使其更具面试和实战价值。</p><hr><h3 id="一、JavaScript-中的数据类型"><a href="#一、JavaScript-中的数据类型" class="headerlink" title="一、JavaScript 中的数据类型"></a>一、JavaScript 中的数据类型</h3><h4 id="1-基础数据类型（原始数据类型）"><a href="#1-基础数据类型（原始数据类型）" class="headerlink" title="1. 基础数据类型（原始数据类型）"></a>1. 基础数据类型（原始数据类型）</h4><ul><li><p><strong>number 类型</strong>：</p><ul><li><strong>深入</strong>：JS 采用 IEEE 754 标准的双精度 64 位浮点数来表示所有数字。这意味着它<strong>没有单独的整数类型</strong>，所有数字都是浮点数。</li><li><code>NaN</code> (Not a Number)：表示非数字值。需要注意的是，<code>typeof NaN</code> 结果是 <code>number</code>。<code>NaN</code> 不等于自身，<code>NaN === NaN</code> 结果为 <code>false</code>。</li><li><code>Infinity</code>：表示正无穷大，<code>+Infinity</code> 和 <code>-Infinity</code> 分别表示正负无穷大。</li><li><code>0.1 + 0.2 !== 0.3</code>：由于浮点数表示的精度问题，这个经典问题需要注意。</li></ul></li><li><p><strong>boolean 类型</strong>：</p><ul><li><strong>深入</strong>：<code>true</code> 和 <code>false</code>。在条件判断中，所有数据类型都会被隐式转换为布尔值。</li></ul></li><li><p><strong>undefined 类型</strong>：</p><ul><li><strong>深入</strong>：表示一个<strong>未定义</strong>的变量或变量<strong>未被赋值</strong>。<code>typeof undefined</code> 结果为 <code>undefined</code>。它是一个值也是一个类型。</li><li><code>null</code>：与 <code>undefined</code> 的区别在于，<code>null</code> 是一种<strong>意图</strong>，表示变量被显式地赋予了“空”值。<code>typeof null</code> 结果为 <code>object</code>，这是一个历史遗留的 bug。</li></ul></li><li><p><strong>string 类型</strong>：</p><ul><li><p><strong>深入</strong>：JS 中<strong>没有字符类型</strong>。字符串是不可变的，一旦创建就不能修改。</p></li><li><p><strong>反引号（     ）</strong>：ES6 引入，支持<strong>模板字面量</strong>。它允许在字符串中嵌入变量和表达式，并支持多行书写，极大提升了字符串拼接的便利性。</p><p>JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = &quot;张三&quot;;</span><br><span class="line">console.log(`你好，我的名字是$&#123;name&#125;。`);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-数据类型转换"><a href="#2-数据类型转换" class="headerlink" title="2. 数据类型转换"></a>2. 数据类型转换</h4><ul><li><p><strong>转换为 number</strong>：<code>Number(value)</code></p><ul><li><strong>深入</strong>：会尝试将参数转换为数字。非数字字符串会返回 <code>NaN</code>。<code>null</code> 转为 <code>0</code>，<code>undefined</code> 转为 <code>NaN</code>。</li></ul></li><li><p><strong>转换为 boolean</strong>：<code>Boolean(value)</code></p><ul><li><strong>深入</strong>：所有能被转换为 <code>false</code> 的值被称为<strong>假值（Falsy Value）</strong>。</li><li><strong>假值列表</strong>：<code>0</code>, <code>-0</code>, <code>null</code>, <code>false</code>, <code>NaN</code>, <code>undefined</code>, <code>&#39;&#39;</code> (空字符串)。</li><li><strong>真值（Truthy Value）</strong>：除上述假值外，所有值都是真值，包括空数组 <code>[]</code> 和空对象 <code>&#123;&#125;</code>。</li></ul></li><li><p><strong>转换为 string</strong>：<code>String(value)</code> 或 <code>value + &#39;&#39;</code></p><ul><li><strong>深入</strong>：<code>value + &#39;&#39;</code> 是最常用的技巧，利用了 JS 的隐式类型转换。</li></ul></li><li><p><strong>parseInt 和 parseFloat</strong>：</p><ul><li><p><strong>深入</strong>：这两个函数专门用于从<strong>字符串开头</strong>解析出数字。</p></li><li><p><code>parseInt</code>：解析<strong>整数</strong>。遇到第一个非数字字符就停止解析。</p><p>JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&quot;100px&quot;); // 100</span><br><span class="line">parseInt(&quot;a100&quot;);  // NaN</span><br></pre></td></tr></table></figure></li><li><p><code>parseFloat</code>：解析<strong>浮点数</strong>。遇到第一个非数字字符（除了小数点）就停止解析。</p></li></ul></li></ul><h3 id="二、JavaScript-中的弹出框"><a href="#二、JavaScript-中的弹出框" class="headerlink" title="二、JavaScript 中的弹出框"></a>二、JavaScript 中的弹出框</h3><p>这些是浏览器提供的 BOM API。</p><ul><li><code>alert(message)</code>：<strong>警告框</strong>。阻塞式，显示一条消息，不返回任何值。</li><li><code>prompt(message, default_value)</code>：<strong>询问框</strong>。返回用户输入的字符串，如果点击“取消”则返回 <code>null</code>。</li><li><code>confirm(message)</code>：<strong>确认框</strong>。返回一个布尔值，用户点击“确定”返回 <code>true</code>，点击“取消”返回 <code>false</code>。</li></ul><h3 id="三、条件运算符：-和"><a href="#三、条件运算符：-和" class="headerlink" title="三、条件运算符：== 和 ==="></a>三、条件运算符：<code>==</code> 和 <code>===</code></h3><ul><li><p><strong>&#x3D;&#x3D;（宽松相等）</strong>：只比较<strong>值</strong>，不比较类型。它在比较前会进行<strong>隐式类型转换</strong>。</p><p>JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 == &quot;5&quot;;     // true</span><br><span class="line">null == undefined; // true</span><br></pre></td></tr></table></figure></li><li><p><strong>&#x3D;&#x3D;&#x3D;（严格相等）</strong>：既比较<strong>值</strong>，也比较<strong>类型</strong>。不会进行类型转换。</p><p>JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 === &quot;5&quot;;    // false</span><br><span class="line">null === undefined; // false</span><br></pre></td></tr></table></figure></li><li><p><strong>面试建议</strong>：在实际开发中，<strong>强烈建议使用 &#x3D;&#x3D;&#x3D;</strong>，以避免不必要的类型转换带来的 bug。</p></li></ul><h3 id="四、字符串和数组"><a href="#四、字符串和数组" class="headerlink" title="四、字符串和数组"></a>四、字符串和数组</h3><ul><li><strong>字符串</strong>：<ul><li><strong>深入</strong>：<code>string</code> 是一个<strong>对象</strong>，拥有 <code>length</code> 属性和许多方法（如 <code>split()</code>, <code>slice()</code>, <code>indexOf()</code> 等），但它<strong>不可变</strong>。</li></ul></li><li><strong>数组</strong>：<ul><li><strong>特点</strong>：<ol><li><strong>动态长度</strong>：JS 数组的长度是可变的，你可以随时添加或删除元素。</li><li><strong>异构性</strong>：一个数组可以存放不同数据类型的元素，如 <code>[1, &quot;hello&quot;, true]</code>。</li></ol></li><li><strong>方法</strong>：<ul><li><code>push()</code>, <code>pop()</code>：在数组<strong>末尾</strong>添加和删除。</li><li><code>unshift()</code>, <code>shift()</code>：在数组<strong>开头</strong>添加和删除。</li><li><code>splice()</code>：功能强大的方法，用于删除、替换或添加元素。</li><li><code>forEach()</code>, <code>map()</code>, <code>filter()</code>：常用的遍历方法。</li></ul></li></ul></li></ul><h3 id="五、函数和对象"><a href="#五、函数和对象" class="headerlink" title="五、函数和对象"></a>五、函数和对象</h3><ul><li><strong>函数</strong>：<ul><li><strong>深入</strong>：在 JS 中，函数是<strong>一等公民（First-Class Citizens）</strong>。这意味着函数可以作为参数传递、作为返回值，也可以赋值给变量。</li></ul></li><li><strong>对象</strong>：<ul><li><strong>深入</strong>：JS 对象是<strong>键值对</strong>的集合。键是字符串，值可以是任意类型。</li><li><strong>访问属性</strong>：<ul><li>点语法：<code>obj.prop</code>。</li><li>中括号语法：<code>obj[&#39;prop&#39;]</code>。后者适用于键名包含特殊字符或动态键名的情况。</li></ul></li></ul></li></ul><h3 id="六、定时器"><a href="#六、定时器" class="headerlink" title="六、定时器"></a>六、定时器</h3><ul><li><strong>setTimeout(callback, delay)</strong>：<ul><li><strong>用途</strong>：只执行<strong>一次</strong>。</li><li><strong>深入</strong>：<code>delay</code> 参数是<strong>最小延迟时间</strong>。由于 JS 是单线程的，如果主线程被阻塞，<code>callback</code> 的执行会延迟。</li></ul></li><li><strong>setInterval(callback, delay)</strong>：<ul><li><strong>用途</strong>：<strong>重复</strong>执行。</li><li><strong>深入</strong>：每次执行完回调函数后，<code>setInterval</code> 都会将下一个回调任务放入队列。</li></ul></li></ul><h3 id="七、ES6-新特性（重要）"><a href="#七、ES6-新特性（重要）" class="headerlink" title="七、ES6 新特性（重要）"></a>七、ES6 新特性（重要）</h3><ul><li><strong>let 和 const</strong>：<ul><li><strong>var 的问题</strong>：全局作用域，可以被重复声明，有变量提升。</li><li><strong>let</strong>：<strong>块级作用域</strong>（<code>&#123;&#125;</code> 内），不能重复声明，没有变量提升。</li><li><strong>const</strong>：<strong>块级作用域</strong>，用于声明<strong>常量</strong>。一旦声明，其引用地址不能改变。</li></ul></li><li><strong>字符串模板字面量</strong>：使用反引号（<code>     </code>）创建多行字符串和嵌入变量。</li><li><strong>箭头函数</strong>：<ul><li><strong>语法</strong>：<code>const func = (param) =&gt; &#123; ... &#125;</code>。</li><li><strong>this 指向</strong>：箭头函数<strong>没有自己的 this</strong>，它会捕获其所在上下文的 <code>this</code> 值。这解决了传统函数中 <code>this</code> 绑定复杂的问题。</li></ul></li><li><strong>可变参数</strong>：<code>...args</code>，用于函数接收不确定数量的参数。</li></ul><h3 id="八、DOM"><a href="#八、DOM" class="headerlink" title="八、DOM"></a>八、DOM</h3><ul><li><strong>什么是 DOM</strong>：<ul><li><strong>深入</strong>：DOM 是浏览器将 HTML 文档解析后生成的<strong>树形结构</strong>，是 JavaScript 操作网页的接口。HTML 文件是文本，DOM 是一个对象，可以被 JS 编程控制。</li></ul></li><li><strong>DOM 操作</strong>：<ul><li><strong>获取标签对象</strong>：<ul><li><code>document.getElementById()</code></li><li><code>document.getElementsByClassName()</code></li><li><code>document.querySelector()</code> (更常用)</li></ul></li><li><strong>操作属性</strong>：<ul><li><code>element.attribute = &#39;...&#39;</code> (例如 <code>element.style.color = &#39;red&#39;</code>)</li><li><code>element.setAttribute(&#39;attr&#39;, &#39;value&#39;)</code></li></ul></li><li><strong>操作内容</strong>：<ul><li><code>element.innerHTML</code>：获取或设置元素的 HTML 内容（包括子标签）。</li><li><code>element.textContent</code>：获取或设置元素的文本内容（不含 HTML）。</li></ul></li></ul></li></ul><p>好的，我将根据您提供的这份详尽的 Web 技术笔记，以一种更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p><hr><h3 id="一、Web-架构与网络基础"><a href="#一、Web-架构与网络基础" class="headerlink" title="一、Web 架构与网络基础"></a>一、Web 架构与网络基础</h3><h4 id="1-常见的软件架构"><a href="#1-常见的软件架构" class="headerlink" title="1. 常见的软件架构"></a>1. 常见的软件架构</h4><ul><li><strong>B&#x2F;S 架构 (Browser&#x2F;Server)</strong>：<ul><li><strong>概念</strong>：浏览器和服务器架构。客户端只需安装一个通用的浏览器，业务逻辑和数据都存储在服务器端。</li><li><strong>优点</strong>：易于维护和升级，跨平台性好。</li><li><strong>缺点</strong>：对网络依赖性强，用户体验可能不如 C&#x2F;S 架构。</li></ul></li><li><strong>C&#x2F;S 架构 (Client&#x2F;Server)</strong>：<ul><li><strong>概念</strong>：客户端和服务器架构。客户端需要安装专用的应用程序，例如桌面 QQ、微信等。</li><li><strong>优点</strong>：用户体验好，响应速度快，可以离线使用。</li><li><strong>缺点</strong>：维护和升级复杂，需要为不同平台开发不同版本。</li></ul></li></ul><h4 id="2-网络编程三要素"><a href="#2-网络编程三要素" class="headerlink" title="2. 网络编程三要素"></a>2. 网络编程三要素</h4><p>这是所有网络通信的基础，理解这三点至关重要。</p><ul><li><strong>IP 地址</strong>：设备在网络上的唯一标识，类似于你的家庭住址。它用于在网络中定位到一台具体的计算机。</li><li><strong>端口号</strong>：应用程序在计算机上的唯一标识，类似于你家里的电话号码或门牌号。一台计算机上可以运行多个应用程序，端口号用于区分它们。</li><li><strong>协议</strong>：通信规则。就像人与人交流需要遵循共同的语言一样，网络设备之间通信也需要遵循特定的协议，如 HTTP、FTP、TCP 等。</li></ul><h4 id="3-资源的分类"><a href="#3-资源的分类" class="headerlink" title="3. 资源的分类"></a>3. 资源的分类</h4><ul><li><strong>静态资源</strong>：<ul><li><strong>特点</strong>：内容固定，无需服务器端处理，可由浏览器直接解析。</li><li><strong>原理</strong>：当浏览器请求静态资源时，Web 服务器直接从文件系统中读取文件并返回。</li><li><strong>示例</strong>：HTML、CSS、JS、图片等。</li></ul></li><li><strong>动态资源</strong>：<ul><li><strong>特点</strong>：内容动态生成，需要服务器端处理后才能返回给浏览器。</li><li><strong>原理</strong>：当浏览器请求动态资源时，Web 服务器将请求交给<strong>后台程序</strong>（如 Servlet 容器），后台程序执行业务逻辑，生成静态内容（如 HTML、JSON 等），然后返回给服务器，服务器再返回给浏览器。</li><li><strong>示例</strong>：Servlet、JSP、PHP、ASP 等。</li></ul></li></ul><h3 id="二、Web-服务器"><a href="#二、Web-服务器" class="headerlink" title="二、Web 服务器"></a>二、Web 服务器</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>Web 服务器（也称为 <strong>Web 容器</strong>）是一个软件，它负责处理 HTTP 请求，并提供静态资源和动态资源。它为动态资源（如 Servlet）提供了一个运行环境。</p><h4 id="2-常见的-Web-服务器"><a href="#2-常见的-Web-服务器" class="headerlink" title="2. 常见的 Web 服务器"></a>2. 常见的 Web 服务器</h4><ul><li><strong>Tomcat</strong>：Apache 基金组织开发，<strong>中小型的 JavaEE 服务器</strong>，<strong>免费</strong>且开源。它是一个<strong>Servlet 容器</strong>，能够运行 Servlet 和 JSP。</li><li><strong>WebSphere</strong>：IBM 公司开发，<strong>大型的 JavaEE 服务器</strong>，<strong>收费</strong>。功能强大，支持完整的 JavaEE 规范。</li><li><strong>WebLogic</strong>：Oracle 公司开发，<strong>大型的 JavaEE 服务器</strong>，<strong>收费</strong>。</li><li><strong>JBoss&#x2F;WildFly</strong>：开源，但其商业版收费。</li></ul><h3 id="三、Tomcat-的使用与配置"><a href="#三、Tomcat-的使用与配置" class="headerlink" title="三、Tomcat 的使用与配置"></a>三、Tomcat 的使用与配置</h3><ul><li><strong>安装与启动</strong>：Tomcat 是免安装的，解压即可。启动前需要配置 <code>JAVA_HOME</code> 环境变量。启动后，默认监听 <code>8080</code> 端口。</li><li><strong>端口号修改</strong>：<ul><li><strong>面试题</strong>：修改 Tomcat 端口号在哪个文件？</li><li><strong>回答</strong>：在 Tomcat 的 <code>conf</code> 目录下的 <code>server.xml</code> 文件中，修改 <code>&lt;Connector&gt;</code> 标签的 <code>port</code> 属性。</li><li><strong>注意</strong>：HTTP 协议的默认端口号是 <code>80</code>。如果将 Tomcat 端口号改为 <code>80</code>，那么访问时就可以省略端口号，例如 <code>http://localhost/</code>。</li></ul></li><li><strong>项目部署</strong>：<ul><li><strong>静态项目</strong>：将 HTML、CSS、JS 等文件直接放到 <code>webapps</code> 目录下的文件夹中。</li><li><strong>动态项目</strong>：将包含 <code>WEB-INF</code> 文件夹的整个项目目录放到 <code>webapps</code> 目录下。</li><li><strong>WEB-INF</strong>：这是动态项目的核心目录，具有特殊作用，外部无法直接通过 URL 访问该目录下的资源，保证了项目的安全性。<ul><li><code>classes</code>：存放所有编译后的 <code>.class</code> 字节码文件。</li><li><code>lib</code>：存放项目依赖的第三方 <code>.jar</code> 包。</li><li><code>web.xml</code>：Web 项目的<strong>核心配置文件</strong>，用于配置 Servlet、监听器、过滤器等。</li></ul></li></ul></li></ul><h3 id="四、Servlet-深入解析"><a href="#四、Servlet-深入解析" class="headerlink" title="四、Servlet 深入解析"></a>四、Servlet 深入解析</h3><h4 id="1-Servlet-的概念和本质"><a href="#1-Servlet-的概念和本质" class="headerlink" title="1. Servlet 的概念和本质"></a>1. Servlet 的概念和本质</h4><ul><li><strong>概念</strong>：Servlet 是运行在服务器端的 Java 程序，用于处理客户端请求并生成动态响应。它不是一个独立的程序，<strong>必须部署到支持 Servlet 的容器中</strong>（如 Tomcat）才能运行。</li><li><strong>本质</strong>：Servlet 的本质是一个<strong>接口</strong>。所有自定义的 Servlet 类都必须<strong>实现 javax.servlet.Servlet 接口</strong>。</li></ul><h4 id="2-Servlet-的执行原理（详细解释）"><a href="#2-Servlet-的执行原理（详细解释）" class="headerlink" title="2. Servlet 的执行原理（详细解释）"></a>2. Servlet 的执行原理（详细解释）</h4><p>这是一个非常重要的面试点，需要从请求-响应的整个流程来详细阐述。</p><ol><li><strong>客户端请求</strong>：用户在浏览器中输入 URL，向服务器发送一个 HTTP 请求。</li><li><strong>Web 服务器接收请求</strong>：Web 服务器（Tomcat）接收到这个请求。</li><li><strong>Servlet 容器处理</strong>：Tomcat 会根据请求 URL，在 <code>web.xml</code> 或通过注解（如 <code>@WebServlet</code>）查找匹配的 Servlet。</li><li><strong>Servlet 实例创建</strong>：<ul><li>如果是<strong>第一次</strong>访问该 Servlet，Servlet 容器会创建一个该 Servlet 的实例。</li><li><strong>面试点</strong>：Servlet 是<strong>单例的</strong>，一个 Servlet 在容器中只会被创建一次。</li></ul></li><li><strong>init() 方法执行</strong>：<ul><li>在 Servlet 实例创建后，容器会立即调用它的 <code>init()</code> 方法。</li><li><code>init()</code> 方法只在 Servlet 的<strong>生命周期中执行一次</strong>，用于完成一些初始化工作，如加载配置文件、数据库连接等。</li></ul></li><li><strong>service() 方法执行</strong>：<ul><li>每次客户端请求该 Servlet 时，容器都会调用它的 <code>service()</code> 方法。</li><li><code>service()</code> 方法根据请求的 HTTP 方法（GET、POST 等），将请求分发给相应的 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li><li><strong>面试点</strong>：<code>service()</code> 方法是处理请求的核心方法，它是<strong>多线程的</strong>，每个请求都会在新线程中执行 <code>service()</code> 方法。</li></ul></li><li><strong>destroy() 方法执行</strong>：<ul><li>当 Servlet 容器关闭，或者决定卸载该 Servlet 时，会调用其 <code>destroy()</code> 方法。</li><li><code>destroy()</code> 方法也只执行一次，用于释放资源，如关闭数据库连接池。</li></ul></li></ol><p><strong>总结</strong>：Servlet 的生命周期是：<strong>创建实例</strong> -&gt; <strong>调用 init()</strong> (只一次) -&gt; <strong>调用 service()</strong> (多次) -&gt; <strong>调用 destroy()</strong> (只一次) -&gt; <strong>销毁实例</strong>。</p><p>好的，我们来将“网络编程三要素”这一部分进行更深入、更详细的展开，并补充常见应用的默认端口号，使其更具实用性和面试价值。</p><hr><h3 id="一、网络编程三要素：深入解析"><a href="#一、网络编程三要素：深入解析" class="headerlink" title="一、网络编程三要素：深入解析"></a>一、网络编程三要素：深入解析</h3><p>网络编程的本质就是让不同的计算机上的应用程序能够进行通信。要实现这一点，必须解决三个核心问题：</p><ol><li><strong>找到对方计算机</strong>：IP 地址</li><li><strong>找到对方计算机上的应用程序</strong>：端口号</li><li><strong>以什么样的规则进行通信</strong>：协议</li></ol><p>这三者缺一不可。</p><h4 id="1-IP-地址-Internet-Protocol-Address"><a href="#1-IP-地址-Internet-Protocol-Address" class="headerlink" title="1. IP 地址 (Internet Protocol Address)"></a>1. IP 地址 (Internet Protocol Address)</h4><ul><li><strong>概念</strong>：IP 地址是分配给连接到网络中的设备（如计算机、手机、服务器）的一串数字标识。</li><li><strong>作用</strong>：它用于<strong>唯一地标识网络上的一个设备</strong>。数据包在网络中传输时，就是根据 IP 地址来路由和寻址的。</li><li><strong>版本</strong>：<ul><li><strong>IPv4</strong>：由 32 位二进制数组成，通常表示为四个十进制数，用点分隔（例如 <code>192.168.1.1</code>）。由于地址资源枯竭，现在已经不够用。</li><li><strong>IPv6</strong>：由 128 位二进制数组成，地址空间巨大，足以满足未来需求。</li></ul></li><li><strong>类型</strong>：<ul><li><strong>公网 IP</strong>：在互联网上是唯一的，可以直接访问。</li><li><strong>内网 IP</strong>：在局域网内是唯一的，不能直接在互联网上访问。例如 <code>192.168.x.x</code>、<code>10.x.x.x</code>。</li></ul></li></ul><h4 id="2-端口号-Port-Number"><a href="#2-端口号-Port-Number" class="headerlink" title="2. 端口号 (Port Number)"></a>2. 端口号 (Port Number)</h4><ul><li><strong>概念</strong>：端口号是用于<strong>区分一台计算机上不同应用程序</strong>的数字标识。它的范围是从 <code>0</code> 到 <code>65535</code>。</li><li><strong>作用</strong>：当一个数据包到达一台计算机时，操作系统会检查其目的端口号，然后将数据包交给监听该端口号的相应应用程序。</li><li><strong>与 IP 地址的关系</strong>：IP 地址解决了“数据包发送到哪台计算机”的问题，而端口号则解决了“数据包发送到这台计算机上的哪个应用程序”的问题。两者结合起来才能唯一确定一个网络连接的端点。</li></ul><h4 id="3-协议-Protocol"><a href="#3-协议-Protocol" class="headerlink" title="3. 协议 (Protocol)"></a>3. 协议 (Protocol)</h4><ul><li><strong>概念</strong>：协议是网络通信中<strong>数据传输的规则和约定</strong>。它定义了数据如何打包、传输、路由和接收。</li><li><strong>作用</strong>：确保通信双方能够理解彼此发送的数据。没有协议，数据包就是一堆无意义的字节。</li><li><strong>分层</strong>：网络协议通常是分层的，最经典的是 <strong>TCP&#x2F;IP 协议栈</strong>。<ul><li><strong>应用层</strong>：<strong>决定数据内容</strong>，如 HTTP、FTP、SMTP。</li><li><strong>传输层</strong>：<strong>决定数据如何传输</strong>，如 TCP 和 UDP。<ul><li><strong>TCP (Transmission Control Protocol)</strong>：面向连接、可靠、有序。适用于对数据完整性要求高的场景，如文件传输、网页浏览。</li><li><strong>UDP (User Datagram Protocol)</strong>：无连接、不可靠、速度快。适用于对实时性要求高的场景，如在线视频、游戏。</li></ul></li><li><strong>网络层</strong>：<strong>决定数据如何路由</strong>，如 IP 协议。</li><li><strong>数据链路层&#x2F;物理层</strong>：负责物理设备的通信。</li></ul></li></ul><hr><h3 id="二、常见应用的默认端口号"><a href="#二、常见应用的默认端口号" class="headerlink" title="二、常见应用的默认端口号"></a>二、常见应用的默认端口号</h3><p>了解这些默认端口号，可以帮助你更好地理解网络协议和服务。</p><ul><li><strong>Web 服务</strong><ul><li><strong>HTTP</strong> (HyperText Transfer Protocol)：<strong>80</strong></li><li><strong>HTTPS</strong> (HTTP Secure)：<strong>443</strong></li><li><strong>Tomcat</strong> (默认)：<strong>8080</strong></li><li><strong>WebLogic</strong> (默认)：<strong>7001</strong></li></ul></li><li><strong>文件传输</strong><ul><li><strong>FTP</strong> (File Transfer Protocol)：<strong>21</strong> (控制连接)</li><li><strong>SFTP</strong> (SSH File Transfer Protocol)：<strong>22</strong></li></ul></li><li><strong>远程登录与管理</strong><ul><li><strong>SSH</strong> (Secure Shell)：<strong>22</strong></li><li><strong>Telnet</strong>：<strong>23</strong></li><li><strong>RDP</strong> (Remote Desktop Protocol)：<strong>3389</strong></li></ul></li><li><strong>数据库服务</strong><ul><li><strong>MySQL</strong>：<strong>3306</strong></li><li><strong>PostgreSQL</strong>：<strong>5432</strong></li><li><strong>SQL Server</strong>：<strong>1433</strong></li><li><strong>Oracle</strong>：<strong>1521</strong></li></ul></li><li><strong>邮件服务</strong><ul><li><strong>SMTP</strong> (Simple Mail Transfer Protocol)：<strong>25</strong> (发送邮件)</li><li><strong>POP3</strong> (Post Office Protocol 3)：<strong>110</strong> (接收邮件)</li><li><strong>IMAP</strong> (Internet Message Access Protocol)：<strong>143</strong> (接收邮件)</li></ul></li><li><strong>其他常见服务</strong><ul><li><strong>DNS</strong> (Domain Name System)：<strong>53</strong></li><li><strong>Redis</strong>：<strong>6379</strong></li><li><strong>MongoDB</strong>：<strong>27017</strong></li><li><strong>Kafka</strong>：<strong>9092</strong></li></ul></li></ul><p>为什么需要默认端口号？</p><p>为了方便用户。当你在浏览器中访问 <a href="http://www.example.com/">www.example.com</a> 时，你不需要手动输入 <a href="http://www.example.com:80，因为浏览器知道">www.example.com:80，因为浏览器知道</a> HTTP 协议的默认端口就是 80。如果服务器的端口不是默认端口，你就必须手动指定，比如 <a href="http://www.example.com:8080。">www.example.com:8080。</a></p><p>好的，我将根据您提供的这份详尽的 Web 技术笔记，以一种更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p><hr><h3 id="一、Servlet-剩余部分"><a href="#一、Servlet-剩余部分" class="headerlink" title="一、Servlet 剩余部分"></a>一、Servlet 剩余部分</h3><h4 id="1-Servlet-的生命周期方法"><a href="#1-Servlet-的生命周期方法" class="headerlink" title="1. Servlet 的生命周期方法"></a>1. Servlet 的生命周期方法</h4><p>这是理解 Servlet 工作原理的核心。</p><ul><li><strong>init() 方法</strong>：<ul><li><strong>特点</strong>：只执行<strong>一次</strong>，用于初始化 Servlet 实例。</li><li><strong>执行时机</strong>：<ul><li><strong>默认（懒加载）</strong>：第一次被访问时执行。这是一种“按需加载”的策略，节省了服务器启动时的资源。</li><li><strong>预加载</strong>：可以在 <code>web.xml</code> 中通过 <code>&lt;load-on-startup&gt;</code> 标签来设置。如果值为非负整数（<code>0</code>或正数），Servlet 容器将在服务器启动时立即创建并初始化该 Servlet。这适用于需要立即提供服务、启动耗时较长的 Servlet。</li></ul></li></ul></li><li><strong>service() 方法</strong>：<ul><li><strong>特点</strong>：每次客户端请求该 Servlet 时，都会执行一次。</li><li><strong>原理</strong>：它是 Servlet 接口的核心方法，用于处理请求。对于 <code>HttpServlet</code> 来说，它会根据 HTTP 请求方法（GET、POST 等）来分发请求给相应的 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li><li><strong>重要性</strong>：<strong>service() 方法是多线程的</strong>。Servlet 容器会为每个请求创建一个新线程来执行 <code>service()</code> 方法，确保并发访问时互不影响。</li></ul></li><li><strong>destroy() 方法</strong>：<ul><li><strong>特点</strong>：只执行<strong>一次</strong>，在 Servlet 实例正常销毁时调用。</li><li><strong>执行时机</strong>：通常在 Web 应用关闭或 Servlet 容器关闭时。用于释放资源，如关闭数据库连接、文件句柄等。</li></ul></li></ul><h4 id="2-Servlet-的实现方式：XML-vs-注解"><a href="#2-Servlet-的实现方式：XML-vs-注解" class="headerlink" title="2. Servlet 的实现方式：XML vs. 注解"></a>2. Servlet 的实现方式：XML vs. 注解</h4><ul><li><p><strong>XML 配置方式</strong>：在 <code>web.xml</code> 文件中，通过 <code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code> 标签来配置 Servlet 的名称、类和访问路径。这是 Servlet 2.x 及以前版本的主流方式。</p></li><li><p><strong>注解方式</strong>：自 Servlet 3.0 开始引入，可以使用 <code>@WebServlet</code> 注解来代替 XML 配置。</p><ul><li><strong>优点</strong>：简化了配置，代码和配置更集中，提高了开发效率。</li><li><strong>示例</strong>：</li></ul><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;/demo&quot;)</span><br><span class="line">public class MyServlet extends HttpServlet &#123; ... &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Servlet-的体系结构"><a href="#3-Servlet-的体系结构" class="headerlink" title="3. Servlet 的体系结构"></a>3. Servlet 的体系结构</h4><ul><li><code>Servlet</code> <strong>接口</strong>：所有 Servlet 的顶层接口，定义了 <code>init()</code>, <code>service()</code>, <code>destroy()</code> 等核心方法。</li><li><code>GenericServlet</code> <strong>抽象类</strong>：实现了 <code>Servlet</code> 接口，并提供了 <code>init()</code>, <code>destroy()</code> 的空实现，以及一些通用方法。开发者可以继承它来编写协议无关的 Servlet。</li><li><code>HttpServlet</code> <strong>抽象类</strong>：继承自 <code>GenericServlet</code>，专门用于处理 <strong>HTTP 请求</strong>。它重写了 <code>service()</code> 方法，并根据请求方法分发给 <code>doGet()</code>, <code>doPost()</code> 等具体方法。</li><li><strong>总结</strong>：在 Web 项目中，我们几乎总是处理 HTTP 请求，因此<strong>继承 HttpServlet 是最常用、最推荐的方式</strong>。</li></ul><hr><h3 id="二、HTTP-协议"><a href="#二、HTTP-协议" class="headerlink" title="二、HTTP 协议"></a>二、HTTP 协议</h3><h4 id="1-概念与特点"><a href="#1-概念与特点" class="headerlink" title="1. 概念与特点"></a>1. 概念与特点</h4><ul><li><strong>概念</strong>：<strong>超文本传输协议</strong>，是 Web 应用层协议，基于 TCP&#x2F;IP。它规定了客户端和服务器之间的通信格式。</li><li><strong>特点</strong>：<ul><li><strong>基于 TCP&#x2F;IP</strong>：它位于 TCP&#x2F;IP 协议栈的应用层，利用了 TCP 的可靠传输特性。</li><li><strong>请求&#x2F;响应模型</strong>：客户端发送请求，服务器返回响应，一次请求只对应一次响应。</li><li><strong>无状态</strong>：这是 HTTP 的核心特征。服务器不保留任何关于客户端过去请求的信息。每个请求都是独立的。</li><li><strong>无状态带来的问题</strong>：服务器无法识别多个请求是否来自同一个用户，因此需要引入<strong>会话技术</strong>（如 Cookie 和 Session）来解决。</li></ul></li></ul><h4 id="2-HTTP-协议的数据格式"><a href="#2-HTTP-协议的数据格式" class="headerlink" title="2. HTTP 协议的数据格式"></a>2. HTTP 协议的数据格式</h4><p>HTTP 协议是文本格式，由<strong>请求格式</strong>和<strong>响应格式</strong>两部分组成。</p><ul><li><strong>请求格式</strong>：<ol><li><strong>请求行</strong>：<code>请求方式 虚拟路径/资源路径[?参数] 请求协议/版本</code>。</li><li><strong>请求头</strong>：键值对形式，提供额外信息。<ul><li><code>Host</code>：目标主机名。</li><li><code>User-Agent</code>：浏览器类型和版本。</li><li><code>Referer</code>：请求来源地址，常用于防盗链。</li></ul></li><li><strong>请求空行</strong>：一个空行，用于分隔请求头和请求体。</li><li><strong>请求体</strong>：<strong>只有 POST 请求才有</strong>，用于封装请求参数。</li></ol></li></ul><h4 id="3-ServletRequest-对象"><a href="#3-ServletRequest-对象" class="headerlink" title="3. ServletRequest 对象"></a>3. <code>ServletRequest</code> 对象</h4><p><code>ServletRequest</code> 是 Servlet 容器在接收到请求后，封装请求信息的对象。</p><ul><li><strong>获取请求行信息</strong>：<ul><li><code>getMethod()</code>：获取请求方式（GET&#x2F;POST）。</li><li><code>getContextPath()</code>：获取虚拟路径。</li><li><code>getRequestURI()</code>：获取 URI，如 <code>/web02/demo4</code>。</li><li><code>getRequestURL()</code>：获取 URL，如 <code>http://localhost:8080/web02/demo4</code>。</li></ul></li><li><strong>获取请求头信息</strong>：<ul><li><code>getHeader(name)</code>：根据请求头名获取值。</li><li><code>getHeaderNames()</code>：获取所有请求头名。</li></ul></li><li><strong>获取请求体信息</strong>：<ul><li><code>getReader()</code> (字符流) 和 <code>getInputStream()</code> (字节流)，用于读取 POST 请求的请求体内容。</li></ul></li><li><strong>获取请求参数（通用）</strong>：<ul><li><code>getParameter(name)</code>：获取单个参数值。</li><li><code>getParameterValues(name)</code>：获取参数值数组，用于复选框等。</li></ul></li><li><strong>中文乱码</strong>：<ul><li><strong>GET 请求</strong>：在 Tomcat 8.x 及以后版本，默认已解决。</li><li><strong>POST 请求</strong>：需要手动设置编码，<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code>。</li></ul></li></ul><h4 id="4-request-请求转发"><a href="#4-request-请求转发" class="headerlink" title="4. request 请求转发"></a>4. <code>request</code> 请求转发</h4><ul><li><strong>概念</strong>：是一种<strong>服务器内部</strong>的资源跳转方式。请求从一个 Servlet 转发到另一个 Servlet 或 JSP，<strong>浏览器地址栏不会发生改变</strong>。</li><li><strong>特点</strong>：<ol><li><strong>地址栏不变</strong>：用户不知道发生了跳转。</li><li><strong>一次请求&#x2F;响应</strong>：整个转发过程发生在一次 HTTP 请求和一次 HTTP 响应中。</li><li><strong>共享数据</strong>：由于是同一次请求，<code>request</code> 对象中的数据在转发前后是共享的。</li></ol></li></ul><h4 id="5-request-作为域对象"><a href="#5-request-作为域对象" class="headerlink" title="5. request 作为域对象"></a>5. <code>request</code> 作为域对象</h4><ul><li><strong>概念</strong>：<code>request</code> 是一种<strong>域对象</strong>，其作用范围是<strong>一次请求-响应的生命周期</strong>。</li><li><strong>共享数据</strong>：可以使用 <code>setAttribute()</code>, <code>getAttribute()</code>, <code>removeAttribute()</code> 方法在这次请求的生命周期内共享数据。</li><li><strong>应用场景</strong>：常用于在 Servlet 和 JSP 之间传递数据。</li><li><strong>与会话技术的联系</strong>：<code>request</code> 是三大域对象（<code>request</code>, <code>session</code>, <code>servletContext</code>）中作用范围最小的一个。</li></ul><p>好的，我将根据您提供的这份详尽的 Web 技术笔记，以一种更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p><hr><h3 id="一、HTTP-协议的响应格式"><a href="#一、HTTP-协议的响应格式" class="headerlink" title="一、HTTP 协议的响应格式"></a>一、HTTP 协议的响应格式</h3><h4 id="1-响应格式组成"><a href="#1-响应格式组成" class="headerlink" title="1. 响应格式组成"></a>1. 响应格式组成</h4><p>HTTP 响应格式由四部分组成：<code>响应行</code>、<code>响应头</code>、<code>响应空行</code>、<code>响应体</code>。这与 HTTP 请求格式相呼应。</p><h4 id="2-响应行"><a href="#2-响应行" class="headerlink" title="2. 响应行"></a>2. 响应行</h4><ul><li><strong>格式</strong>：<code>协议/版本号 状态码 状态描述</code>。例如：<code>HTTP/1.1 200 OK</code>。</li><li><strong>状态码</strong>：一个三位数的数字，服务器用于告诉浏览器本次响应的状态。<ul><li><strong>2xx 成功</strong>：<ul><li><strong>200 OK</strong>：请求成功，一切正常。</li></ul></li><li><strong>3xx 重定向</strong>：<ul><li><strong>302 Found</strong>：重定向。服务器告诉浏览器，资源临时移动到另一个位置，请重新发起请求。</li><li><strong>304 Not Modified</strong>：访问缓存。服务器告诉浏览器，请求的资源没有更新，可以使用浏览器本地的缓存副本。</li></ul></li><li><strong>4xx 客户端错误</strong>：<ul><li><strong>404 Not Found</strong>：找不到资源。请求的路径没有对应的资源。</li><li><strong>405 Method Not Allowed</strong>：请求方法不被允许。例如，客户端用 POST 请求访问了只支持 GET 方法的 Servlet。</li></ul></li><li><strong>5xx 服务器端错误</strong>：<ul><li><strong>500 Internal Server Error</strong>：服务器内部错误。通常是服务器端的代码出现了异常。</li></ul></li></ul></li><li><strong>面试题</strong>：列举 5 个常见的状态码：200、302、304、404、405、500。</li></ul><h4 id="3-响应头"><a href="#3-响应头" class="headerlink" title="3. 响应头"></a>3. 响应头</h4><ul><li><strong>作用</strong>：以键值对形式提供关于响应的额外信息。</li><li><strong>常见响应头</strong>：<ul><li><strong>Content-Type</strong>：告诉浏览器响应体的数据类型和字符编码，例如 <code>text/html;charset=utf-8</code>。</li><li><strong>Content-disposition</strong>：<ul><li><strong>inline</strong> (默认)：浏览器在当前页面内直接打开。</li><li><strong>attachment;filename&#x3D;xxx</strong>：浏览器将数据作为附件下载。</li></ul></li><li><strong>Location</strong>：与 <code>3xx</code> 状态码配合使用，用于告诉浏览器重定向到哪个 URL。</li></ul></li></ul><h3 id="二、ServletResponse-response"><a href="#二、ServletResponse-response" class="headerlink" title="二、ServletResponse (response)"></a>二、ServletResponse (response)</h3><ul><li><strong>简介</strong>：<code>ServletResponse</code> 对象由 Tomcat 创建，封装了服务器发送给客户端的响应消息。</li><li><strong>相关方法</strong>：<ul><li><strong>设置响应行</strong>：<code>setStatus(int sc)</code></li><li><strong>设置响应头</strong>：<code>setHeader(String name, String value)</code></li><li><strong>设置响应体</strong>：<ul><li><code>getWriter()</code>：获取字符输出流，用于发送<strong>文本</strong>数据。</li><li><code>getOutputStream()</code>：获取字节输出流，用于发送<strong>字节</strong>数据（如图片、视频）。</li></ul></li></ul></li></ul><h3 id="三、转发（Forward）和重定向（Redirect）的区别"><a href="#三、转发（Forward）和重定向（Redirect）的区别" class="headerlink" title="三、转发（Forward）和重定向（Redirect）的区别"></a>三、转发（Forward）和重定向（Redirect）的区别</h3><p>这是一个非常重要的面试题，需要从多个角度进行对比。</p><table><thead><tr><th>特性</th><th>转发（Forward）</th><th>重定向（Redirect）</th></tr></thead><tbody><tr><td><strong>发生方</strong></td><td>服务器内部</td><td>浏览器</td></tr><tr><td><strong>地址栏</strong></td><td><strong>不变</strong></td><td><strong>会改变</strong></td></tr><tr><td><strong>请求次数</strong></td><td><strong>一次</strong>请求，一次响应</td><td><strong>两次</strong>请求，两次响应</td></tr><tr><td><strong>共享数据</strong></td><td><code>request</code> 对象共享数据</td><td><code>request</code> 对象不共享数据</td></tr><tr><td><strong>跳转范围</strong></td><td><strong>只能</strong>在当前 Web 项目内部</td><td>可以跳出项目，访问外部资源</td></tr><tr><td><strong>调用方</strong></td><td><code>RequestDispatcher</code> (<code>request</code>)</td><td><code>ServletResponse</code> (<code>response</code>)</td></tr><tr><td><strong>底层实现</strong></td><td><code>request.getRequestDispatcher().forward()</code></td><td><code>response.sendRedirect()</code></td></tr></tbody></table><ul><li><strong>重定向的实现原理</strong>：<ol><li>服务器收到请求，执行 <code>response.sendRedirect()</code>，并发送 <code>302</code> 状态码和 <code>Location</code> 响应头（值为新的 URL）。</li><li>浏览器收到响应，解析到 <code>302</code> 和 <code>Location</code> 头后，会<strong>自动</strong>向新的 URL 发起<strong>第二次</strong>请求。</li></ol></li></ul><h3 id="四、ServletContext"><a href="#四、ServletContext" class="headerlink" title="四、ServletContext"></a>四、ServletContext</h3><h4 id="1-简介与特点"><a href="#1-简介与特点" class="headerlink" title="1. 简介与特点"></a>1. 简介与特点</h4><ul><li><strong>作用</strong>：代表<strong>整个 Web 应用</strong>。可以用来和服务器容器进行通信。</li><li><strong>特点</strong>：<ul><li><strong>单例</strong>：一个 Web 应用只有一个 <code>ServletContext</code> 对象。</li><li><strong>作用域</strong>：是<strong>最大的域对象</strong>，其作用范围是整个 Web 应用，从应用启动到关闭。</li></ul></li></ul><h4 id="2-获取-ServletContext-对象"><a href="#2-获取-ServletContext-对象" class="headerlink" title="2. 获取 ServletContext 对象"></a>2. 获取 <code>ServletContext</code> 对象</h4><ul><li><strong>通过 request</strong>：<code>request.getServletContext()</code></li><li><strong>通过 HttpServlet</strong>：<code>getServletContext()</code></li></ul><h4 id="3-ServletContext-的方法"><a href="#3-ServletContext-的方法" class="headerlink" title="3. ServletContext 的方法"></a>3. <code>ServletContext</code> 的方法</h4><ul><li><strong>获取文件 MIME 类型</strong>：<code>getMimeType(String file)</code>，返回文件的类型，如 <code>image/jpeg</code>。</li><li><strong>作为域对象</strong>：提供了 <code>setAttribute()</code>, <code>getAttribute()</code>, <code>removeAttribute()</code> 方法，用于在整个 Web 应用范围内共享数据。<ul><li><strong>示例</strong>：您提供的代码片段完美地展示了如何使用 <code>ServletContext</code> 来统计服务器的访问次数。这是 <code>ServletContext</code> 作为域对象最经典的用法。</li></ul></li><li><strong>获取文件真实路径</strong>：<code>getRealPath(String path)</code>，将相对路径转换为服务器上的绝对路径。</li></ul><h3 id="五、会话（Session）"><a href="#五、会话（Session）" class="headerlink" title="五、会话（Session）"></a>五、会话（Session）</h3><h4 id="1-概念与作用"><a href="#1-概念与作用" class="headerlink" title="1. 概念与作用"></a>1. 概念与作用</h4><ul><li><strong>概念</strong>：在 HTTP 协议的无状态特性基础上，通过会话技术将多次请求和响应联系起来，形成一个完整的会话。</li><li><strong>作用</strong>：在一次会话范围内的多次请求之间<strong>共享数据</strong>，从而识别用户。</li><li><strong>实现方式</strong>：<ul><li><strong>客户端会话（Cookie）</strong>：数据存储在客户端浏览器。</li><li><strong>服务器端会话（Session）</strong>：数据存储在服务器端。</li></ul></li></ul><h4 id="2-客户端会话：Cookie"><a href="#2-客户端会话：Cookie" class="headerlink" title="2. 客户端会话：Cookie"></a>2. 客户端会话：Cookie</h4><ul><li><strong>快速开始</strong>：<ol><li><strong>创建</strong>：<code>new Cookie(name, value)</code>。</li><li><strong>发送</strong>：<code>response.addCookie(cookie)</code>，将 Cookie 发送给浏览器。</li><li><strong>获取</strong>：<code>request.getCookies()</code>，从请求中获取所有 Cookie。</li></ol></li><li><strong>特点</strong>：数据存储在客户端，有大小限制，安全性低。</li></ul><p>这是一个非常好的问题，它触及了 Web 开发中一个容易混淆但至关重要的概念。<code>enctype</code> 和 <code>Content-Type</code> 确实有相似之处，但它们的作用域和角色是完全不同的。</p><p>让我来详细解释一下它们的区别：</p><hr><h3 id="一、enctype"><a href="#一、enctype" class="headerlink" title="一、enctype"></a>一、<code>enctype</code></h3><ul><li><strong>作用域</strong>：HTML <code>&lt;form&gt;</code> 标签的属性。</li><li><strong>角色</strong>：客户端<strong>表单的编码方式</strong>。</li><li><strong>概念</strong>：<code>enctype</code> (Encoding Type) 告诉<strong>浏览器</strong>如何将 <code>&lt;form&gt;</code> 表单中的数据<strong>编码</strong>成 HTTP 请求体中的数据。它只作用于<strong>表单提交</strong>这个行为。</li><li><strong>常见值</strong>：<ul><li><code>application/x-www-form-urlencoded</code>：默认值，用于文本数据。</li><li><code>multipart/form-data</code>：用于文件上传。</li><li><code>text/plain</code>：用于纯文本提交。</li></ul></li></ul><p><strong>简单来说，enctype 是“表单数据在浏览器端如何打包”的规则。</strong></p><h3 id="二、Content-Type"><a href="#二、Content-Type" class="headerlink" title="二、Content-Type"></a>二、<code>Content-Type</code></h3><ul><li><strong>作用域</strong>：HTTP 请求头或响应头。</li><li><strong>角色</strong>：<strong>通信数据的媒体类型</strong>。</li><li><strong>概念</strong>：<code>Content-Type</code> 告诉接收方（服务器或浏览器）请求体或响应体中的<strong>数据是什么格式</strong>。它是一个通用的 HTTP 头部，不仅限于表单提交。</li><li><strong>常见值</strong>：<ul><li><code>text/html</code>：HTML 文档。</li><li><code>application/json</code>：JSON 格式数据。</li><li><code>image/jpeg</code>：JPEG 图片。</li><li><code>application/xml</code>：XML 文档。</li><li><code>text/plain</code>：纯文本。</li></ul></li></ul><p><strong>简单来说，Content-Type 是“我发送给你的数据是什么类型”的声明。</strong></p><h3 id="三、核心区别与联系"><a href="#三、核心区别与联系" class="headerlink" title="三、核心区别与联系"></a>三、核心区别与联系</h3><table><thead><tr><th>特性</th><th><code>enctype</code></th><th><code>Content-Type</code></th></tr></thead><tbody><tr><td><strong>位置</strong></td><td>HTML <code>&lt;form&gt;</code> 标签的属性</td><td>HTTP 请求头或响应头</td></tr><tr><td><strong>谁定义</strong></td><td>开发者在 HTML 中设置</td><td>发送方（浏览器或服务器）在 HTTP 头部中设置</td></tr><tr><td><strong>作用</strong></td><td>告诉<strong>浏览器</strong>如何<strong>打包</strong>表单数据</td><td>告诉<strong>接收方</strong>如何<strong>解析</strong>数据</td></tr><tr><td><strong>关系</strong></td><td><strong>enctype 的值决定了 HTTP 请求头中 Content-Type 的值。</strong></td><td><code>Content-Type</code> 是 HTTP 协议的一部分，<code>enctype</code> 是 HTML 的一部分。</td></tr></tbody></table><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假设你有一个包含用户名和头像上传的表单：</p><p>HTML</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/profile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;avatar&quot;&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>当用户点击提交时，浏览器会做两件事：</p><ol><li><p><strong>根据 enctype&#x3D;”multipart&#x2F;form-data” 规则</strong>，浏览器会生成一个**多部分（<code>multipart</code>）**的请求体，包含用户名和头像文件的二进制数据。</p></li><li><p>在发送 HTTP 请求时，浏览器会在请求头中自动添加一个 <code>Content-Type</code> 字段，其值为<strong>与 enctype 匹配的</strong> <code>multipart/form-data</code>。</p><p>HTTP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /profile HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong>：</p><ul><li><strong>enctype 是一个前端概念</strong>，它是 HTML 表单的属性，用于指导浏览器如何构建请求体。</li><li><strong>Content-Type 是一个 HTTP 协议概念</strong>，它是 HTTP 头部的一个字段，用于告知数据格式。</li><li>两者之间存在<strong>联动关系</strong>：你在 HTML 中设置的 <code>enctype</code> 值，会<strong>最终影响</strong>浏览器在 HTTP 请求中设置的 <code>Content-Type</code> 头的值。</li></ul><p>好的，我来为你分别列出 <code>enctype</code> 和 <code>Content-Type</code> 各自常见的属性值，并简要说明其用途。</p><hr><h3 id="一、enctype-的常见值"><a href="#一、enctype-的常见值" class="headerlink" title="一、enctype 的常见值"></a>一、<code>enctype</code> 的常见值</h3><p><code>enctype</code> 是 HTML <code>&lt;form&gt;</code> 标签的属性，用于定义表单数据提交的编码方式。</p><ol><li><strong>application&#x2F;x-www-form-urlencoded</strong><ul><li><strong>用途</strong>：这是 <code>enctype</code> 的<strong>默认值</strong>。它将表单数据编码为键值对字符串，其中所有特殊字符都会被 URL 编码（例如空格被 <code>%20</code> 替代）。</li><li><strong>适用场景</strong>：只包含文本数据的普通表单提交。</li></ul></li><li><strong>multipart&#x2F;form-data</strong><ul><li><strong>用途</strong>：将表单数据分割成多个部分，每个部分都有独立的 <code>Content-Type</code> 和 <code>Content-Disposition</code> 头部。这种格式能够<strong>同时处理文本和二进制数据</strong>。</li><li><strong>适用场景</strong>：<strong>文件上传</strong>。</li></ul></li><li><strong>text&#x2F;plain</strong><ul><li><strong>用途</strong>：将表单数据以纯文本格式发送，不进行任何编码。数据以键值对的形式，用换行符分隔。</li><li><strong>适用场景</strong>：不常用，主要用于调试目的。</li></ul></li></ol><h3 id="二、Content-Type-的常见值"><a href="#二、Content-Type-的常见值" class="headerlink" title="二、Content-Type 的常见值"></a>二、<code>Content-Type</code> 的常见值</h3><p><code>Content-Type</code> 是 HTTP 头部字段，用于指定消息体的媒体类型（MIME 类型）。</p><h4 id="1-文本类型-text"><a href="#1-文本类型-text" class="headerlink" title="1. 文本类型 (text/)"></a>1. 文本类型 (<code>text/</code>)</h4><ul><li><strong>text&#x2F;plain</strong>：纯文本。</li><li><strong>text&#x2F;html</strong>：HTML 文档。这是浏览器渲染网页的默认类型。</li><li><strong>text&#x2F;css</strong>：CSS 样式表。</li><li><strong>text&#x2F;javascript</strong>：JavaScript 代码。</li></ul><h4 id="2-应用类型-application"><a href="#2-应用类型-application" class="headerlink" title="2. 应用类型 (application/)"></a>2. 应用类型 (<code>application/</code>)</h4><ul><li><strong>application&#x2F;json</strong>：JSON 格式的数据。目前最常用的前后端数据交互格式。</li><li><strong>application&#x2F;xml</strong>：XML 格式的数据。</li><li><strong>application&#x2F;pdf</strong>：PDF 文档。</li><li><strong>application&#x2F;octet-stream</strong>：通用的<strong>二进制流数据</strong>。通常用于<strong>强制浏览器下载</strong>未知类型的文件，因为它告诉浏览器“这是一个原始的字节流，请不要尝试解析它”。</li><li><strong>application&#x2F;x-www-form-urlencoded</strong>：与 <code>enctype</code> 的默认值对应，表明请求体是 URL 编码的键值对。</li><li><strong>application&#x2F;javascript</strong>：与 <code>text/javascript</code> 类似，更推荐使用。</li></ul><h4 id="3-图片类型-image"><a href="#3-图片类型-image" class="headerlink" title="3. 图片类型 (image/)"></a>3. 图片类型 (<code>image/</code>)</h4><ul><li><strong>image&#x2F;jpeg</strong>：JPEG&#x2F;JPG 格式的图片。</li><li><strong>image&#x2F;png</strong>：PNG 格式的图片。</li><li><strong>image&#x2F;gif</strong>：GIF 格式的图片。</li><li><strong>image&#x2F;svg+xml</strong>：SVG 矢量图。</li></ul><h4 id="4-音视频类型"><a href="#4-音视频类型" class="headerlink" title="4. 音视频类型"></a>4. 音视频类型</h4><ul><li><strong>audio&#x2F;mpeg</strong>：MP3 音频文件。</li><li><strong>video&#x2F;mp4</strong>：MP4 视频文件。</li></ul><h4 id="5-多部分类型-multipart"><a href="#5-多部分类型-multipart" class="headerlink" title="5. 多部分类型 (multipart/)"></a>5. 多部分类型 (<code>multipart/</code>)</h4><ul><li><strong>multipart&#x2F;form-data</strong>：用于文件上传，与 <code>enctype</code> 的值对应。</li><li><strong>multipart&#x2F;byteranges</strong>：用于分块下载，支持断点续传。</li></ul><p>好的，这是一个非常经典的面试题，也是理解 Web 基础知识的关键。我会详细、清晰地解释 URL 和 URI，并用通俗易懂的方式区分它们。</p><hr><h3 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h3><ul><li><strong>URI (Uniform Resource Identifier) - 统一资源标识符</strong><ul><li><strong>概念</strong>：URI 是一个用于<strong>标识</strong>互联网上<strong>任何资源</strong>的字符串。它不仅仅能标识网页，还可以标识文件、服务、电子邮箱等。</li><li><strong>作用</strong>：<strong>标识</strong>。URI 就像一个资源的“身份证号”，它能唯一地识别一个资源，但<strong>不一定</strong>告诉我们如何访问它。</li></ul></li><li><strong>URL (Uniform Resource Locator) - 统一资源定位符</strong><ul><li><strong>概念</strong>：URL 是一个用于<strong>定位</strong>互联网上资源的字符串。它是 URI 的一个<strong>子集</strong>。</li><li><strong>作用</strong>：<strong>定位</strong>。URL 就像一个资源的“详细地址”，它不仅标识了资源，还提供了<strong>如何访问该资源</strong>的完整信息，包括协议、主机名、端口号和路径等。</li></ul></li></ul><h3 id="二、URL-和-URI-的关系"><a href="#二、URL-和-URI-的关系" class="headerlink" title="二、URL 和 URI 的关系"></a>二、URL 和 URI 的关系</h3><p>用一个比喻来理解：</p><ul><li><strong>URI</strong> 就像一个人的<strong>名字</strong>。<code>张三</code>这个名字可以标识这个人，但你不知道他在哪里、怎么找到他。</li><li><strong>URL</strong> 就像一个人的<strong>家庭住址</strong>。<code>北京市海淀区中关村大街1号</code>。这个地址不仅标识了这个人，还告诉了你如何定位他。</li></ul><p><strong>因此，所有的 URL 都是 URI，但并非所有的 URI 都是 URL。</strong></p><h3 id="三、URL-和-URI-的具体结构"><a href="#三、URL-和-URI-的具体结构" class="headerlink" title="三、URL 和 URI 的具体结构"></a>三、URL 和 URI 的具体结构</h3><h4 id="URI-的结构："><a href="#URI-的结构：" class="headerlink" title="URI 的结构："></a>URI 的结构：</h4><p>一个 URI 通常由两部分组成：</p><p><code>scheme:[//authority][path][?query][#fragment]</code></p><ul><li><code>scheme</code>：协议，如 <code>http</code>, <code>ftp</code>, <code>mailto</code>。</li><li><code>path</code>：资源路径。</li></ul><h4 id="URL-的结构："><a href="#URL-的结构：" class="headerlink" title="URL 的结构："></a>URL 的结构：</h4><p>URL 包含了 URI 的所有组成部分，并加入了定位信息。</p><p><code>scheme://host:port/path?query#fragment</code></p><ul><li><code>scheme</code>：协议。如 <code>http</code>, <code>https</code>, <code>ftp</code>。</li><li><code>host</code>：主机名或 IP 地址。</li><li><code>port</code>：端口号（可选，如果使用默认端口则可以省略）。</li><li><code>path</code>：资源路径。</li><li><code>query</code>：查询参数，以 <code>?</code> 开始。</li><li><code>fragment</code>：片段标识符，以 <code>#</code> 开始。</li></ul><h3 id="四、举例说明"><a href="#四、举例说明" class="headerlink" title="四、举例说明"></a>四、举例说明</h3><table><thead><tr><th>字符串</th><th>类别</th><th>解释</th></tr></thead><tbody><tr><td><code>https://www.google.com/search?q=url+uri</code></td><td><strong>URL</strong> 和 <strong>URI</strong></td><td>既是 URI（标识），也是 URL（定位），提供了完整的访问信息。</td></tr><tr><td><code>urn:isbn:0451450523</code></td><td><strong>URI</strong> 但<strong>不是 URL</strong></td><td><code>urn:isbn</code> 是一个 URN (Uniform Resource Name)，它是 URI 的另一种类型，用于标识一本书。它标识了资源，但没有提供如何访问它的位置信息。</td></tr><tr><td><code>/images/logo.png</code></td><td><strong>URI</strong> 但<strong>不是 URL</strong></td><td>这是一个相对路径，它标识了资源，但没有完整的定位信息（如协议、主机名），需要结合当前页面的 URL 才能确定完整位置。</td></tr><tr><td><code>mailto:test@example.com</code></td><td><strong>URI</strong> 但<strong>不是 URL</strong></td><td>标识了一个邮箱资源，但无法通过它来定位到具体的文件或服务器。</td></tr></tbody></table><h3 id="五、面试回答总结"><a href="#五、面试回答总结" class="headerlink" title="五、面试回答总结"></a>五、面试回答总结</h3><ol><li><p><strong>开门见山</strong>：URL 是 URI 的子集。</p></li><li><p><strong>核心区别</strong>：</p><ul><li><strong>URI 是标识符</strong>，它只负责<strong>标识</strong>一个资源，不提供如何访问它的信息。</li><li><strong>URL 是定位符</strong>，它在标识资源的同时，还提供了<strong>定位</strong>该资源的完整信息，如协议、主机名等。</li></ul></li><li><p><strong>举例</strong>：</p><ul><li>URL：<code>https://www.example.com/index.html</code>，包含了协议、主机、路径，可以明确地定位一个资源。</li><li>URI：<code>urn:isbn:0451450523</code>，它标识了一本书，但你无法通过它来访问这本书的电子版。</li></ul></li><li><p><strong>关系图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------------+</span><br><span class="line">|      URI    |</span><br><span class="line">|             |</span><br><span class="line">|  +----------+---------+</span><br><span class="line">|  |   URL    |   URN   |</span><br><span class="line">|  | (定位)   |  (命名) |</span><br><span class="line">|  +----------+---------+</span><br><span class="line">|             |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>用这个图能非常清晰地展现它们之间的关系。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> servlet </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2025/09/11/%E7%AE%97%E6%B3%95/"/>
      <url>/2025/09/11/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="🔥-常见算法分类-Java实现"><a href="#🔥-常见算法分类-Java实现" class="headerlink" title="🔥 常见算法分类 + Java实现"></a>🔥 常见算法分类 + Java实现</h1><hr><h2 id="1-排序算法-Sorting"><a href="#1-排序算法-Sorting" class="headerlink" title="1. 排序算法 (Sorting)"></a>1. 排序算法 (Sorting)</h2><h3 id="1-1-冒泡排序-Bubble-Sort"><a href="#1-1-冒泡排序-Bubble-Sort" class="headerlink" title="1.1 冒泡排序 (Bubble Sort)"></a>1.1 冒泡排序 (Bubble Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-选择排序-Selection-Sort"><a href="#1-2-选择排序-Selection-Sort" class="headerlink" title="1.2 选择排序 (Selection Sort)"></a>1.2 选择排序 (Selection Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-插入排序-Insertion-Sort"><a href="#1-3-插入排序-Insertion-Sort" class="headerlink" title="1.3 插入排序 (Insertion Sort)"></a>1.3 插入排序 (Insertion Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-归并排序-Merge-Sort"><a href="#1-4-归并排序-Merge-Sort" class="headerlink" title="1.4 归并排序 (Merge Sort)"></a>1.4 归并排序 (Merge Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(arr, l, mid);</span><br><span class="line">    mergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        tmp[k++] = (arr[i] &lt;= arr[j]) ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = arr[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmp.length; i++) arr[l + i] = tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-快速排序-Quick-Sort"><a href="#1-5-快速排序-Quick-Sort" class="headerlink" title="1.5 快速排序 (Quick Sort)"></a>1.5 快速排序 (Quick Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(arr, l, r);</span><br><span class="line">    quickSort(arr, l, p - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[r], i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i]; arr[i] = arr[j]; arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i+<span class="number">1</span>]; arr[i+<span class="number">1</span>] = arr[r]; arr[r] = tmp;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-查找算法-Searching"><a href="#2-查找算法-Searching" class="headerlink" title="2. 查找算法 (Searching)"></a>2. 查找算法 (Searching)</h2><h3 id="2-1-顺序查找-Linear-Search"><a href="#2-1-顺序查找-Linear-Search" class="headerlink" title="2.1 顺序查找 (Linear Search)"></a>2.1 顺序查找 (Linear Search)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">linearSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == target) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-二分查找-Binary-Search-（数组有序）"><a href="#2-2-二分查找-Binary-Search-（数组有序）" class="headerlink" title="2.2 二分查找 (Binary Search)（数组有序）"></a>2.2 二分查找 (Binary Search)（数组有序）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-双指针算法-Two-Pointers"><a href="#3-双指针算法-Two-Pointers" class="headerlink" title="3. 双指针算法 (Two Pointers)"></a>3. 双指针算法 (Two Pointers)</h2><h3 id="3-1-反转数组"><a href="#3-1-反转数组" class="headerlink" title="3.1 反转数组"></a>3.1 反转数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[l]; arr[l] = arr[r]; arr[r] = tmp;</span><br><span class="line">        l++; r--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-三数之和-LeetCode-15"><a href="#3-2-三数之和-LeetCode-15" class="headerlink" title="3.2 三数之和 (LeetCode 15)"></a>3.2 三数之和 (LeetCode 15)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i+<span class="number">1</span>, r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l+<span class="number">1</span>]) l++;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r-<span class="number">1</span>]) r--;</span><br><span class="line">                l++; r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-动态规划-Dynamic-Programming"><a href="#4-动态规划-Dynamic-Programming" class="headerlink" title="4. 动态规划 (Dynamic Programming)"></a>4. 动态规划 (Dynamic Programming)</h2><h3 id="4-1-斐波那契数列"><a href="#4-1-斐波那契数列" class="headerlink" title="4.1 斐波那契数列"></a>4.1 斐波那契数列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-爬楼梯-LeetCode-70"><a href="#4-2-爬楼梯-LeetCode-70" class="headerlink" title="4.2 爬楼梯 (LeetCode 70)"></a>4.2 爬楼梯 (LeetCode 70)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a + b;</span><br><span class="line">        a = b; b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-最长公共子序列-LCS"><a href="#4-3-最长公共子序列-LCS" class="headerlink" title="4.3 最长公共子序列 (LCS)"></a>4.3 最长公共子序列 (LCS)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lcs</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length(), n = s2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-贪心算法-Greedy"><a href="#5-贪心算法-Greedy" class="headerlink" title="5. 贪心算法 (Greedy)"></a>5. 贪心算法 (Greedy)</h2><h3 id="5-1-跳跃游戏-LeetCode-55"><a href="#5-1-跳跃游戏-LeetCode-55" class="headerlink" title="5.1 跳跃游戏 (LeetCode 55)"></a>5.1 跳跃游戏 (LeetCode 55)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">farthest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; farthest) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        farthest = Math.max(farthest, i + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-分治算法-Divide-Conquer"><a href="#6-分治算法-Divide-Conquer" class="headerlink" title="6. 分治算法 (Divide &amp; Conquer)"></a>6. 分治算法 (Divide &amp; Conquer)</h2><h3 id="6-1-归并排序-见上"><a href="#6-1-归并排序-见上" class="headerlink" title="6.1 归并排序 (见上)"></a>6.1 归并排序 (见上)</h3><h3 id="6-2-快速排序-见上"><a href="#6-2-快速排序-见上" class="headerlink" title="6.2 快速排序 (见上)"></a>6.2 快速排序 (见上)</h3><hr><h2 id="7-回溯算法-Backtracking"><a href="#7-回溯算法-Backtracking" class="headerlink" title="7. 回溯算法 (Backtracking)"></a>7. 回溯算法 (Backtracking)</h2><h3 id="7-1-全排列-LeetCode-46"><a href="#7-1-全排列-LeetCode-46" class="headerlink" title="7.1 全排列 (LeetCode 46)"></a>7.1 全排列 (LeetCode 46)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    backtrack(nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length], <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        path.add(nums[i]);</span><br><span class="line">        backtrack(nums, used, path, res);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="8-图算法-Graph-Algorithms"><a href="#8-图算法-Graph-Algorithms" class="headerlink" title="8. 图算法 (Graph Algorithms)"></a>8. 图算法 (Graph Algorithms)</h2><h3 id="8-1-BFS（最短路径）"><a href="#8-1-BFS（最短路径）" class="headerlink" title="8.1 BFS（最短路径）"></a>8.1 BFS（最短路径）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    q.add(start); visited.add(start);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nei : graph.getOrDefault(node, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(nei)) &#123;</span><br><span class="line">                visited.add(nei);</span><br><span class="line">                q.add(nei);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-DFS"><a href="#8-2-DFS" class="headerlink" title="8.2 DFS"></a>8.2 DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="type">int</span> start, Set&lt;Integer&gt; visited)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.contains(start)) <span class="keyword">return</span>;</span><br><span class="line">    visited.add(start);</span><br><span class="line">    System.out.print(start + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nei : graph.getOrDefault(start, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">        dfs(graph, nei, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-Dijkstra-最短路径"><a href="#8-3-Dijkstra-最短路径" class="headerlink" title="8.3 Dijkstra 最短路径"></a>8.3 Dijkstra 最短路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dijkstra(<span class="type">int</span>[][] graph, <span class="type">int</span> src) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">    <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">    dist[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; (u == -<span class="number">1</span> || dist[j] &lt; dist[u])) u = j;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[u][v] != <span class="number">0</span> &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + graph[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础面试</title>
      <link href="/2025/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/"/>
      <url>/2025/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo, Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式</title>
      <link href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Spring-Cloud-体系"><a href="#1-Spring-Cloud-体系" class="headerlink" title="1. Spring Cloud 体系"></a><strong>1. Spring Cloud 体系</strong></h4><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h5><p>Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的<strong>规范和解决方案的集合</strong>。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。</p><h5 id="Netflix-OSS-常用组件（部分进入维护模式）"><a href="#Netflix-OSS-常用组件（部分进入维护模式）" class="headerlink" title="Netflix OSS 常用组件（部分进入维护模式）"></a><strong>Netflix OSS 常用组件（部分进入维护模式）</strong></h5><ul><li><strong>服务注册与发现 (Service Discovery): Eureka</strong><ul><li><strong>作用</strong>: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。</li><li><strong>使用</strong>: 服务端添加 <code>spring-cloud-starter-netflix-eureka-server</code> 依赖，并使用 <code>@EnableEurekaServer</code> 注解。客户端添加 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖，并配置 Eureka Server 地址。</li></ul></li><li><strong>服务调用与负载均衡 (RPC &amp; Load Balancing): OpenFeign + Ribbon</strong><ul><li><strong>作用</strong>: Feign 让远程服务调用变得像调用本地方法一样简单。开发者只需定义一个接口，并使用 <code>@FeignClient</code> 注解，即可完成对远程服务的调用。Ribbon（现已被 Spring Cloud LoadBalancer 替代）则提供了客户端负载均衡能力，当从 Eureka 获取到多个服务实例地址时，Ribbon 会根据配置的策略（如轮询、随机）选择一个实例进行调用。</li><li><strong>使用</strong>: 添加 <code>spring-cloud-starter-openfeign</code> 依赖，在启动类上加 <code>@EnableFeignClients</code>，创建接口并使用 <code>@FeignClient(&quot;service-name&quot;)</code> 注解。</li></ul></li><li><strong>熔断与降级 (Circuit Breaker): Hystrix</strong><ul><li><strong>作用</strong>: 当某个下游服务出现故障或响应缓慢时，为了防止故障在系统中蔓延（即“服务雪崩”），熔断器会快速失败，暂时切断对该服务的调用。同时，可以执行一个预定义的降级逻辑（Fallback），例如返回一个缓存的、默认的或友好的提示信息。</li><li><strong>状态</strong>: Hystrix 已进入维护模式，官方推荐使用 Resilience4j 或其他替代方案。</li></ul></li><li><strong>API 网关 (API Gateway): Zuul</strong><ul><li><strong>作用</strong>: 作为系统的统一入口，API 网关负责请求路由、协议转换、权限校验、流量控制、日志监控等。所有外部请求都先经过网关，再由网关分发到后端的各个微服务。</li><li><strong>状态</strong>: Zuul 1.x 已进入维护模式，官方推荐使用 Spring Cloud Gateway。</li></ul></li></ul><hr><h5 id="Spring-Cloud-Alibaba-详解"><a href="#Spring-Cloud-Alibaba-详解" class="headerlink" title="Spring Cloud Alibaba 详解"></a><strong>Spring Cloud Alibaba 详解</strong></h5><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案，是 Spring Cloud 体系的重要实现。它集成了阿里巴巴开源的优秀组件，为开发者提供了更符合国内技术生态的选择。</p><ul><li><strong>服务注册与发现 &amp; 分布式配置中心: Nacos</strong><ul><li><strong>作用</strong>: Nacos (Naming and Configuration Service) 是一个功能丰富的平台，完美整合了<strong>服务注册发现</strong>和<strong>配置管理</strong>两大核心功能。<ul><li><strong>服务发现</strong>: 与 Eureka 类似，提供服务注册、发现和健康检查。但 Nacos 支持基于 DNS 和 RPC 的服务发现，并提供更实时的健康检查机制。</li><li><strong>配置管理</strong>: 可以作为分布式配置中心，对所有微服务的配置进行集中化管理。支持配置的热更新，即修改配置后无需重启服务即可生效。还支持配置的版本管理、灰度发布等高级功能。</li></ul></li><li><strong>使用</strong>:<ol><li>引入 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 和 <code>spring-cloud-starter-alibaba-nacos-config</code> 依赖。</li><li>在 <code>bootstrap.properties</code> (或 <code>.yml</code>) 文件中配置 Nacos 服务器地址和应用名。</li><li>使用 <code>@Value</code> 或 <code>@ConfigurationProperties</code> 注解即可动态获取和刷新配置。</li></ol></li></ul></li><li><strong>熔断、降级与流量控制: Sentinel</strong><ul><li><strong>作用</strong>: Sentinel 是面向分布式服务架构的“流量的守护者”，以流量为切入点，从<strong>流量控制、熔断降级、系统负载保护</strong>等多个维度保护服务的稳定性。相较于 Hystrix，Sentinel 功能更强大，提供了可视化的监控和配置平台，并且支持热点参数限流等精细化控制。</li><li><strong>核心概念</strong>:<ul><li><strong>资源 (Resource)</strong>: Sentinel 中一切皆资源，可以是一个方法、一段代码或一个服务 URL。</li><li><strong>规则 (Rule)</strong>: 定义如何保护资源，包括流控规则、降级规则、系统保护规则等。</li></ul></li><li><strong>使用</strong>:<ol><li>引入 <code>spring-cloud-starter-alibaba-sentinel</code> 依赖。</li><li>配置 Sentinel 控制台地址。</li><li>通过 <code>@SentinelResource</code> 注解来定义资源，并指定 Fallback (降级逻辑) 和 BlockHandler (流控&#x2F;熔断逻辑)。</li></ol></li></ul></li><li><strong>分布式事务解决方案: Seata</strong><ul><li><strong>作用</strong>: Seata 是一个开源的分布式事务解决方案，提供了高性能且易于使用的分布式事务服务。它支持多种事务模式，包括 AT（自动补偿）、TCC、Saga 和 XA 模式，旨在解决微服务架构下的数据一致性问题。</li><li><strong>使用</strong>: 引入 <code>spring-cloud-starter-alibaba-seata</code> 依赖，配置 Seata Server 地址，并使用 <code>@GlobalTransactional</code> 注解开启全局事务。</li></ul></li></ul><hr><h4 id="2-分布式ID：雪花算法（Snowflake）"><a href="#2-分布式ID：雪花算法（Snowflake）" class="headerlink" title="2. 分布式ID：雪花算法（Snowflake）"></a><strong>2. 分布式ID：雪花算法（Snowflake）</strong></h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>Snowflake 是 Twitter 开源的一种分布式 ID 生成算法，它能生成一个 64 位的 <code>long</code> 型数字作为全局唯一 ID。这个 64 位的 ID 由四部分构成：</p><ul><li><strong>1位符号位</strong>: 最高位，固定为0，表示正数，无实际意义。</li><li><strong>41位时间戳 (Timestamp)</strong>: 精确到毫秒级，是 <code>(当前时间戳 - 起始时间戳)</code> 的差值。41位可以表示 (241−1) 毫秒，大约可以使用 69 年。</li><li><strong>10位工作机器ID (Worker ID)</strong>: 这 10 位可以被灵活划分，例如前 5 位代表数据中心 ID (Datacenter ID)，后 5 位代表机器 ID (Machine ID)。这样总共可以支持 210&#x3D;1024 台机器。</li><li><strong>12位序列号 (Sequence)</strong>: 表示在同一毫秒内，同一台机器上生成的 ID 序列号。12位意味着每台机器每毫秒可以生成 212&#x3D;4096 个不同的 ID。</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h5><ul><li><strong>全局唯一</strong>: 通过时间戳、机器 ID 和序列号的组合，可以保证在分布式环境下的 ID 唯一性。</li><li><strong>趋势递增</strong>: 由于时间戳在高位，所以生成的 ID 整体上是按时间趋势递增的，这对于数据库索引（特别是 B+树）非常友好，可以减少页分裂，提高插入性能。</li><li><strong>高性能</strong>: ID 在本地生成，不依赖任何外部服务（如数据库或 Redis），生成效率极高。</li><li><strong>高可用</strong>: 算法本身不依赖网络，部署简单，具有很高的可用性。</li></ul><h5 id="面试题：“雪花算法有时钟回拨问题，如何解决？”"><a href="#面试题：“雪花算法有时钟回拨问题，如何解决？”" class="headerlink" title="面试题：“雪花算法有时钟回拨问题，如何解决？”"></a><strong>面试题：“雪花算法有时钟回拨问题，如何解决？”</strong></h5><p>回答要点:</p><p>时钟回拨是指服务器时间被同步到一个过去的时间点。如果算法不做处理，可能会生成重复的 ID。解决方案通常是：在生成 ID 时，记录上一次生成 ID 时所使用的时间戳。当发现当前时间戳小于上次记录的时间戳时，就意味着发生了时钟回拨。</p><ul><li><strong>方案一（拒绝服务）</strong>: 直接抛出异常，拒绝生成 ID，等待时钟恢复正常。这种方案简单，但会暂时影响可用性，适合对 ID 连续性要求不高的场景。</li><li><strong>方案二（等待追赶）</strong>: 如果回拨幅度很小（比如几毫秒），程序可以 <code>while(currentTime &lt; lastTimestamp)</code> 这样自旋等待，直到当前时间追赶上上次的时间戳。这会造成短暂的线程阻塞。</li><li><strong>方案三（使用备用位）</strong>: 一些改进版的雪花算法会预留几位作为扩展位，当发生时钟回拨时，在这几位上做自增，从而在短时间回拨内仍能生成不同的 ID。（这种方案实现较为复杂）</li><li><strong>业界实践（美团 Leaf）</strong>: 在发生时钟回拨时，切换到另一种备用 ID 生成策略（如号段模式），或者直接报错。</li></ul><hr><h4 id="3-RBAC（基于角色的访问控制）"><a href="#3-RBAC（基于角色的访问控制）" class="headerlink" title="3. RBAC（基于角色的访问控制）"></a><strong>3. RBAC（基于角色的访问控制）</strong></h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>RBAC (Role-Based Access Control) 是一种主流且灵活的权限管理模型。它的核心思想是在 <strong>用户 (User)</strong> 和 <strong>权限 (Permission)</strong> 之间引入一个中间层——<strong>角色 (Role)</strong>。权限不再直接授予用户，而是授予角色；然后将角色分配给用户。这样，用户与权限实现了解耦，当需要修改大量用户的权限时，只需修改他们共同拥有的角色的权限即可，极大地简化了权限管理和维护。</p><h5 id="核心三要素"><a href="#核心三要素" class="headerlink" title="核心三要素"></a><strong>核心三要素</strong></h5><ul><li><strong>用户 (User)</strong>: 系统操作的主体。</li><li><strong>角色 (Role)</strong>: 权限的集合，代表了一组特定的职责或身份，如“管理员”、“文章编辑”、“普通会员”。</li><li><strong>权限 (Permission)</strong>: 对系统中特定资源进行特定操作的许可。通常用一个字符串表示，如 <code>user:create</code>、<code>order:delete</code>、<code>article:publish</code>。</li></ul><h5 id="面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”"><a href="#面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”" class="headerlink" title="面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”"></a><strong>面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”</strong></h5><p>回答要点:</p><p>一个基础的 RBAC 模型至少需要五张表：</p><ul><li><strong>用户表 (t_user)</strong>: 存储用户信息。<ul><li><code>user_id</code> (主键), <code>username</code>, <code>password</code>, …</li></ul></li><li><strong>角色表 (t_role)</strong>: 存储角色信息。<ul><li><code>role_id</code> (主键), <code>role_name</code> (角色名, 如”管理员”), <code>role_key</code> (角色标识, 如”admin”), …</li></ul></li><li><strong>权限表 (t_permission)</strong>: 存储具体的权限点信息。<ul><li><code>permission_id</code> (主键), <code>permission_name</code> (权限名称, 如“新增用户”), <code>permission_code</code> (权限标识, 如 <code>user:add</code>), <code>parent_id</code> (用于菜单层级), …</li></ul></li><li><strong>用户-角色关联表 (t_user_role)</strong>: 存储用户和角色的多对多关系。<ul><li><code>user_id</code> (外键), <code>role_id</code> (外键)。(主键是 <code>user_id</code> 和 <code>role_id</code> 的联合主键)</li></ul></li><li><strong>角色-权限关联表 (t_role_permission)</strong>: 存储角色和权限的多对多关系。<ul><li><code>role_id</code> (外键), <code>permission_id</code> (外键)。(主键是 <code>role_id</code> 和 <code>permission_id</code> 的联合主键)</li></ul></li></ul><hr><h4 id="4-Redis-进阶详解"><a href="#4-Redis-进阶详解" class="headerlink" title="4. Redis 进阶详解"></a><strong>4. Redis 进阶详解</strong></h4><h5 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h5><ul><li><strong>基于内存</strong>: Redis 是一个内存数据结构存储系统，所有数据都存放在内存中，因此读写速度极快。</li><li><strong>单线程模型</strong>: Redis 的核心网络模型处理客户端请求是单线程的。这避免了多线程环境下的上下文切换和锁竞争带来的开销。（注意：Redis 6.0 之后引入了多线程来处理 I&#x2F;O，但执行命令的核心仍然是单线程）。</li><li><strong>IO多路复用</strong>: 单线程能实现高性能的关键在于它使用了 IO 多路复用技术（如 Linux 下的 epoll）。该技术允许单个线程同时监听多个网络连接上的 IO 事件，当某个连接准备好读或写时，才去处理它，极大地提高了并发处理能力。</li><li><strong>丰富的数据类型</strong>: 支持 String, Hash, List, Set, Sorted Set, Bitmap, HyperLogLog, GEO 等多种数据结构。</li></ul><h5 id="缓存三大问题与解决方案"><a href="#缓存三大问题与解决方案" class="headerlink" title="缓存三大问题与解决方案"></a><strong>缓存三大问题与解决方案</strong></h5><ul><li><strong>缓存穿透</strong>:<ul><li><strong>问题</strong>: 客户端查询一个数据库和缓存中<strong>都</strong>不存在的数据。这导致每次请求都会绕过缓存，直接打到数据库上，当有大量此类请求时，会给数据库带来巨大压力。</li><li><strong>解决</strong>:<ol><li><strong>缓存空对象</strong>: 当从数据库查询不到数据时，也在缓存中存入一个特殊的空值（如 <code>null</code> 或特定字符串），并设置一个较短的过期时间。</li><li><strong>布隆过滤器 (Bloom Filter)</strong>: 在访问缓存之前，先通过布隆过滤器判断 key 是否<strong>可能</strong>存在。布隆过滤器可以高效地判断一个元素<strong>一定不存在</strong>，从而在第一层就拦截掉大量无效请求。</li></ol></li></ul></li><li><strong>缓存击穿</strong>:<ul><li><strong>问题</strong>: 某个<strong>热点 Key</strong> 在某一时刻突然失效，而此时恰好有大量的并发请求访问这个 Key，这些请求会同时穿透缓存，直接打到数据库上，可能导致数据库瞬间崩溃。</li><li><strong>解决</strong>:<ol><li><strong>设置热点 Key 永不过期</strong>: 对于一些访问极其频繁且数据相对固定的热点数据，可以考虑不设置过期时间，通过后台任务定时更新。</li><li><strong>使用分布式锁</strong>: 在查询数据库之前，先获取一个该 Key 对应的分布式锁。只有第一个获取到锁的线程才能去查询数据库并回写缓存，其他线程则等待或直接返回。</li></ol></li></ul></li><li><strong>缓存雪崩</strong>:<ul><li><strong>问题</strong>: 大量的缓存 Key 在<strong>同一时间集中失效</strong>（例如，在应用启动时缓存了大量数据，并设置了相同的过期时间），导致所有请求都瞬间涌向数据库，造成数据库压力剧增甚至宕机。</li><li><strong>解决</strong>:<ol><li><strong>过期时间加随机值</strong>: 在设置缓存的过期时间时，在一个基础时间上增加一个随机数，使得 Key 的失效时间点尽可能分散。</li><li><strong>多级缓存</strong>: 建立多级缓存体系，如 Nginx 缓存 + Redis 缓存 + JVM 本地缓存（Caffeine&#x2F;Guava Cache）。</li><li><strong>熔断降级</strong>: 使用 Hystrix 或 Sentinel 等组件，当检测到数据库压力过大时，进行熔断或降级处理，暂时不访问数据库，返回一个默认值或提示信息。</li></ol></li></ul></li></ul><hr><h4 id="5-消息队列（MQ）"><a href="#5-消息队列（MQ）" class="headerlink" title="5. 消息队列（MQ）"></a><strong>5. 消息队列（MQ）</strong></h4><h5 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a><strong>核心作用</strong></h5><ul><li><strong>异步 (Asynchronous)</strong>: 将耗时的操作（如发送邮件、生成报表）作为消息放入 MQ，主流程可以立即返回，无需等待这些操作完成，从而提高系统的响应速度和吞吐量。</li><li><strong>解耦 (Decoupling)</strong>: 生产者和消费者之间通过 MQ 进行通信，无需直接相互依赖。任何一方的修改、宕机或升级都不会影响到另一方，增强了系统的灵活性和可维护性。</li><li><strong>削峰 (Peak Shaving)</strong>: 在秒杀、大促等高并发场景下，将瞬时涌入的大量请求暂存在 MQ 中，下游的消费者系统可以按照自己的处理能力，平稳地从 MQ 中拉取并处理请求，避免了流量洪峰直接冲垮下游服务。</li></ul><h5 id="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"><a href="#面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”" class="headerlink" title="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"></a><strong>面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”</strong></h5><p><strong>回答要点</strong>:</p><ul><li><strong>消息丢失 (Message Loss)</strong>:<ul><li><strong>问题</strong>: 消息从生产者发出后，由于网络或 MQ 服务故障，未能成功到达消费者。</li><li><strong>解决</strong>:<ol><li><strong>生产者端</strong>: 开启生产者的 <code>confirm</code> 或 <code>ack</code> 机制，确保消息被 MQ 成功接收。如果发送失败，可以进行重试。</li><li><strong>MQ 服务端</strong>: 对消息进行持久化，防止 MQ 宕机导致消息丢失（如 RabbitMQ 的持久化队列和消息，Kafka 的磁盘存储）。</li><li><strong>消费者端</strong>: 消费者在处理完业务逻辑后，再向 MQ 发送确认应答（<code>ack</code>）。如果处理过程中消费者宕机，MQ 没有收到 <code>ack</code>，会将该消息重新投递给其他消费者。</li></ol></li></ul></li><li><strong>重复消费 (Duplicate Consumption)</strong>:<ul><li><strong>问题</strong>: 由于网络抖动、消费者 <code>ack</code> 超时等原因，MQ 可能会重复投递同一条消息。</li><li><strong>解决</strong>: 核心是保证消费逻辑的<strong>幂等性 (Idempotence)</strong>。即多次执行同一个操作，结果都是相同的。实现方式有：<ol><li>在数据库中为业务操作创建一个<strong>唯一键</strong>，每次操作前先检查该唯一键是否存在。</li><li>使用一个全局唯一的<strong>业务 ID</strong>（如订单号），在处理消息前，先查询这个 ID 是否已经被处理过（例如，存入 Redis Set 或数据库）。</li></ol></li></ul></li><li><strong>消息堆积 (Message Backlog)</strong>:<ul><li><strong>问题</strong>: 生产者的生产速度远大于消费者的消费速度，导致大量消息在 MQ 中积压，占用资源并可能导致消息超时丢失。</li><li><strong>解决</strong>:<ol><li><strong>水平扩展消费者</strong>: 增加消费者实例的数量，并行处理消息。这是最常用的方法。</li><li><strong>优化消费逻辑</strong>: 检查消费者代码，看是否有可以优化的慢操作（如 I&#x2F;O 密集型操作）。</li><li><strong>消息分片&#x2F;分区</strong>: 对 Topic 进行分区（Partitioning），让不同的消费者组处理不同的分区，提高并发度。</li><li><strong>增加预警监控</strong>: 对消息堆积数量设置阈值，达到阈值时及时告警，人工介入。</li></ol></li></ul></li></ul><hr><h4 id="6-分布式锁详解"><a href="#6-分布式锁详解" class="headerlink" title="6. 分布式锁详解"></a><strong>6. 分布式锁详解</strong></h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在分布式系统环境下，多个进程或服务器上的多个线程需要访问同一个共享资源时，为了保证数据的一致性和操作的原子性，需要一种机制来确保在同一时刻，只有一个客户端能够持有锁并访问该资源。</p><h5 id="实现方案对比"><a href="#实现方案对比" class="headerlink" title="实现方案对比"></a><strong>实现方案对比</strong></h5><table><thead><tr><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>基于数据库</strong></td><td>实现简单，直接利用数据库（如唯一索引、悲观锁 <code>for update</code>）。</td><td>性能开销大，有锁库锁表的风险，不可重入，不是阻塞锁，数据库单点故障问题。</td><td>并发度不高的简单场景。</td></tr><tr><td><strong>基于 ZooKeeper</strong></td><td>可靠性高，天然支持阻塞锁和可重入，解决死锁问题（临时节点），无锁过期问题，支持公平锁。</td><td>性能不如 Redis，实现复杂，依赖 ZK 集群。</td><td>对可靠性要求极高，且能容忍一定性能损耗的场景，如分布式协调。</td></tr><tr><td><strong>基于 Redis</strong></td><td>性能极高，实现相对简单，有成熟的框架 (Redisson) 可用。</td><td>可靠性相对 ZK 稍差，需要处理锁过期和业务未执行完的问题，非公平锁。</td><td>互联网高并发、对性能要求高的绝大多数场景。</td></tr></tbody></table><h5 id="基于-Redis-的实现进阶"><a href="#基于-Redis-的实现进阶" class="headerlink" title="基于 Redis 的实现进阶"></a><strong>基于 Redis 的实现进阶</strong></h5><ul><li><p>加锁的正确姿势:</p><p>使用 SET key value NX EX time 命令。</p><ul><li><p><code>SET key value</code>: 设置键值。<code>value</code> 通常是一个唯一的随机字符串（如 UUID），用于标识锁的持有者。</p></li><li><p><code>NX</code>: (if Not eXists)，确保只有在 key 不存在时才能设置成功，实现了“加锁”的原子性。</p></li><li><p>EX time: 设置一个自动过期时间（秒），防止因客户端宕机而导致死锁。</p><p>这三个参数必须在一个命令中执行，保证原子性。</p></li></ul></li><li><p><strong>解锁的正确姿势：Lua 脚本</strong></p><ul><li><p><strong>为什么需要 Lua</strong>: 解锁操作包含“判断”和“删除”两步：1. <code>GET</code> 锁的 <code>value</code>，判断是否与自己加锁时设置的随机字符串相等。2. 如果相等，则 <code>DEL</code> 锁。如果不用 Lua 脚本，在执行完第一步后，若该线程阻塞，此时锁恰好过期，另一个线程获取了锁，那么当原线程恢复执行第二步时，就会<strong>误删掉新线程的锁</strong>。</p></li><li><p><strong>Lua 脚本示例</strong>:</p><p>Lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 脚本接收两个参数：KEYS[1] 是锁的 key，ARGV[1] 是加锁时设置的唯一值</span><br><span class="line">if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><p>Lua 脚本可以确保多个命令在 Redis 服务端被原子性地执行，杜绝了上述问题。</p></li><li><p><strong>Redis 乐观锁：WATCH 命令</strong></p><ul><li><p><strong>作用</strong>: <code>WATCH</code> 命令可以监视一个或多个 key，如果在事务 <code>EXEC</code> 执行之前，任何一个被监视的 key 被其他命令修改了，那么整个事务将被取消，<code>EXEC</code> 返回 <code>nil</code>。</p></li><li><p><strong>原理</strong>: 这是一种<strong>检查后设置 (Check-And-Set, CAS)</strong> 的实现。它不是真正的加锁，而是在更新数据时检查数据是否被修改过。</p></li><li><p><strong>使用场景</strong>: 适用于<strong>读多写少</strong>的并发场景，可以减少锁的开销。例如，更新商品库存。</p><ol><li><p><code>WATCH stock_key</code> &#x2F;&#x2F; 监视库存</p></li><li><p><code>current_stock = GET stock_key</code> &#x2F;&#x2F; 获取当前库存</p></li><li><p>(在客户端代码中判断 <code>current_stock</code> 是否足够)</p></li><li><p><code>MULTI</code> &#x2F;&#x2F; 开启事务</p></li><li><p><code>SET stock_key new_stock</code> &#x2F;&#x2F; 准备更新库存</p></li><li><p>EXEC &#x2F;&#x2F; 执行事务</p><p>如果从 WATCH 到 EXEC 之间 stock_key 被其他客户端修改，EXEC 将失败，此时客户端需要重试整个操作。</p></li></ol></li></ul></li></ul><h5 id="面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”"><a href="#面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”" class="headerlink" title="面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”"></a><strong>面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”</strong></h5><p>回答要点:</p><p>这是分布式锁的一个经典问题，被称为锁的超时续期问题。</p><ul><li><strong>问题根源</strong>: 我们给锁设置了一个过期时间，比如 30 秒，但业务执行了 35 秒。在第 30 秒时锁会自动释放，其他线程就能获取到锁，导致并发问题。</li><li><strong>解决方案：“看门狗”(Watchdog)机制</strong>。<ul><li><strong>原理</strong>: 比如 Java 中的 Redisson 框架就内置了看门狗。当一个线程获取锁成功后，Redisson 会启动一个后台线程（看门狗），定期（例如每 10 秒）检查该线程是否还持有锁。如果持有，并且业务仍在执行，看门狗就会自动为这个锁<strong>延长过期时间</strong>（续期），比如再续 30 秒。这个过程会一直持续，直到业务执行完毕，线程主动释放锁，看门狗才会停止。</li><li><strong>总结</strong>: 看门狗机制通过后台线程自动续期，确保了在业务执行完成之前，锁不会因为超时而提前释放，从而保证了锁的可靠性。</li></ul></li></ul><hr><h4 id="7-分布式事务详解"><a href="#7-分布式事务详解" class="headerlink" title="7. 分布式事务详解"></a><strong>7. 分布式事务详解</strong></h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在微服务架构中，一个业务操作可能需要调用多个独立的服务来共同完成（例如，电商下单操作需要调用订单服务、库存服务、积分服务）。分布式事务旨在保证这些跨服务的数据库操作能够遵循 ACID 原则，要么全部成功，要么全部回滚，以确保数据的<strong>最终一致性</strong>。</p><h5 id="解决方案深入分析"><a href="#解决方案深入分析" class="headerlink" title="解决方案深入分析"></a><strong>解决方案深入分析</strong></h5><ul><li><strong>XA (2PC&#x2F;3PC)</strong>: 两阶段&#x2F;三阶段提交协议。<ul><li><strong>角色</strong>: 事务管理器 (Transaction Manager, TM) 和 资源管理器 (Resource Manager, RM)。</li><li><strong>流程 (2PC)</strong>:<ol><li><strong>准备阶段 (Prepare)</strong>: TM 通知所有 RM 准备提交，RM 执行本地事务并锁定资源，但不提交，然后向 TM 报告准备就绪。</li><li><strong>提交&#x2F;回滚阶段 (Commit&#x2F;Rollback)</strong>: 如果所有 RM 都准备就绪，TM 通知所有 RM 提交；否则，通知所有 RM 回滚。</li></ol></li><li><strong>评价</strong>: 是一种<strong>强一致性</strong>的方案，但协议复杂，性能差，同步阻塞模型会长时间锁定资源，且协调器存在单点故障风险，在互联网高并发场景下<strong>很少使用</strong>。</li></ul></li><li><strong>TCC (Try-Confirm-Cancel)</strong>: 补偿型事务。<ul><li><strong>核心</strong>: 是一种<strong>业务层面</strong>的柔性事务方案，对代码侵入性强。</li><li><strong>流程</strong>:<ol><li><strong>Try</strong>: 对业务资源进行<strong>检查和预留</strong>。例如，扣减库存操作，Try 阶段是冻结库存。</li><li><strong>Confirm</strong>: 如果所有服务的 Try 阶段都成功，则执行所有服务的 <strong>Confirm</strong> 操作，真正完成业务。例如，将冻结的库存真实扣减。</li><li><strong>Cancel</strong>: 如果任何一个服务的 Try 阶段失败，则执行所有已成功服务的 <strong>Cancel</strong> 操作，释放预留的资源。例如，解冻之前被冻结的库存。</li></ol></li><li><strong>评价</strong>: 性能较好，数据一致性高于可靠消息方案。但开发成本极高，需要为每个操作都编写 Try, Confirm, Cancel 三个幂等的方法。</li></ul></li><li><strong>Saga 模式</strong>: 长事务解决方案。<ul><li><strong>核心</strong>: 将一个大的分布式事务拆分成多个<strong>本地事务</strong>，每个本地事务都有一个对应的<strong>补偿操作</strong>。</li><li><strong>流程</strong>:<ul><li><strong>正向执行</strong>: Saga 协调器按顺序调用 T1, T2, T3…Tn。</li><li><strong>反向补偿</strong>: 如果 Ti 失败，Saga 会按相反顺序调用前面已成功事务的补偿操作 C(i-1)…C2, C1，进行回滚。</li></ul></li><li><strong>与 TCC 对比</strong>:<ul><li>TCC 有资源<strong>预留</strong>阶段，锁资源时间长；Saga 没有预留，直接提交本地事务，锁资源时间短。</li><li>TCC 的补偿是<strong>逆向操作</strong> (Cancel)；Saga 的补偿是<strong>反向操作</strong>。</li></ul></li><li><strong>评价</strong>: 适合于业务流程长、需要保证最终一致性的场景。同样对代码有侵入性，需要设计好每个子事务的补偿逻辑。</li></ul></li><li><strong>基于可靠消息的最终一致性 (常用)</strong>:<ul><li><strong>核心</strong>: 这是微服务架构中<strong>最常用</strong>的柔性事务方案。</li><li><strong>原理</strong>: 服务 A 在执行完本地事务后，发送一条消息到 MQ。服务 B 订阅该消息，消费消息并执行自己的本地事务。</li><li><strong>关键问题</strong>: 如何保证<strong>本地事务执行</strong>和<strong>消息发送</strong>的原子性？<ul><li><strong>事务消息 (RocketMQ 支持)</strong>: 生产者先发送一条“半消息”到 MQ，MQ 收到后不投递。然后生产者执行本地事务。如果事务成功，则向 MQ 发送确认，MQ 投递该消息；如果事务失败，则通知 MQ 删除该半消息。</li><li><strong>本地消息表</strong>: 业务操作和“待发送消息”记录在同一本地事务中。一个后台任务定时扫描这张表，将消息发送到 MQ，发送成功后更新表状态。</li></ul></li><li><strong>评价</strong>: 实现了服务间的解耦，性能高，吞吐量大。但它不保证数据的强一致性，只保证<strong>最终一致性</strong>，存在一个短暂的数据不一致状态窗口。需要处理好消息的可靠投递和幂等消费问题。</li></ul></li></ul><h3 id="Lua-脚本详解-在-Redis-中的应用"><a href="#Lua-脚本详解-在-Redis-中的应用" class="headerlink" title="Lua 脚本详解 (在 Redis 中的应用)"></a><strong>Lua 脚本详解 (在 Redis 中的应用)</strong></h3><h4 id="1-Lua-是什么？"><a href="#1-Lua-是什么？" class="headerlink" title="1. Lua 是什么？"></a><strong>1. Lua 是什么？</strong></h4><p>Lua 是一种轻量级、可扩展的脚本语言，被设计用于嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。它以其简洁的语法、高效的执行性能和极小的内存占用而闻名。</p><p>在 Redis 的上下文中，Lua 脚本提供了一种在 Redis 服务器端执行复杂逻辑的强大能力。</p><h4 id="2-为什么-Redis-要支持-Lua-脚本？"><a href="#2-为什么-Redis-要支持-Lua-脚本？" class="headerlink" title="2. 为什么 Redis 要支持 Lua 脚本？"></a><strong>2. 为什么 Redis 要支持 Lua 脚本？</strong></h4><ul><li><strong>原子性 (Atomicity)</strong>: 这是在 Redis 中使用 Lua 最核心的原因。Redis 会将整个 Lua 脚本作为一个单独的命令来执行，<strong>在脚本执行期间，不会有其他客户端的命令被插入执行</strong>。这完美地解决了需要组合多个 Redis 命令才能完成一个业务逻辑时，可能出现的竞态条件问题。例如前面提到的“判断锁并删除锁”的操作，如果分两步执行，就不是原子的，而封装在 Lua 脚本中就是原子的。</li><li><strong>减少网络开销</strong>: 对于需要多次与 Redis 交互的复杂操作，可以将所有逻辑封装在一个 Lua 脚本中，一次性发送给 Redis 服务器。客户端只需发送一次请求，而不是多次，这显著减少了客户端与服务器之间的网络往返时间（RTT），提升了性能。</li><li><strong>代码复用</strong>: 编写好的 Lua 脚本可以被缓存（通过 <code>SCRIPT LOAD</code> 命令生成一个 SHA1 校验和），之后客户端可以通过这个简短的 SHA1 校验和（使用 <code>EVALSHA</code> 命令）来调用脚本，避免了每次都发送完整的脚本内容。</li></ul><h4 id="3-如何在-Redis-中使用-Lua-脚本？"><a href="#3-如何在-Redis-中使用-Lua-脚本？" class="headerlink" title="3. 如何在 Redis 中使用 Lua 脚本？"></a><strong>3. 如何在 Redis 中使用 Lua 脚本？</strong></h4><p>通过 EVAL 或 EVALSHA 命令来执行。</p><p>EVAL script numkeys key [key …] arg [arg …]</p><ul><li><code>script</code>: 要执行的 Lua 脚本字符串。</li><li><code>numkeys</code>: 后面跟的 <code>key</code> 参数的数量。这有助于 Redis 正确地将参数区分为键名（<code>KEYS</code>）和普通参数（<code>ARGV</code>），这对于 Redis Cluster 模式下的路由至关重要。</li><li><code>key [key ...]</code>：脚本中要操作的 Redis 键，在 Lua 脚本中可以通过全局变量 <code>KEYS</code> table（例如 <code>KEYS[1]</code>）来访问。</li><li><code>arg [arg ...]</code>：传递给脚本的额外参数，在 Lua 脚本中可以通过全局变量 <code>ARGV</code> table（例如 <code>ARGV[1]</code>）来访问。</li></ul><p><strong>示例：实现一个安全的库存扣减</strong></p><p>Lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 脚本逻辑：检查库存是否充足，如果充足则扣减并返回1，否则返回0</span><br><span class="line">-- KEYS[1]: 库存的 key，例如 &quot;product:1001:stock&quot;</span><br><span class="line">-- ARGV[1]: 本次要扣减的数量</span><br><span class="line"></span><br><span class="line">local stock = tonumber(redis.call(&#x27;get&#x27;, KEYS[1]))</span><br><span class="line">local quantity = tonumber(ARGV[1])</span><br><span class="line"></span><br><span class="line">if stock &gt;= quantity then</span><br><span class="line">    redis.call(&#x27;decrby&#x27;, KEYS[1], quantity)</span><br><span class="line">    return 1</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这个脚本保证了“读取库存”和“扣减库存”两个操作的原子性，避免了在高并发下超卖的问题。</p><hr><h3 id="Token-认证机制详解"><a href="#Token-认证机制详解" class="headerlink" title="Token 认证机制详解"></a><strong>Token 认证机制详解</strong></h3><h4 id="1-Token-是什么？"><a href="#1-Token-是什么？" class="headerlink" title="1. Token 是什么？"></a><strong>1. Token 是什么？</strong></h4><p>Token（令牌）是在服务端生成的一串加密字符串，作为客户端进行请求的一个“凭证”。当用户第一次登录成功后，服务端会生成一个 Token 并返回给客户端。之后，客户端在每次请求需要身份认证的接口时，都需要在请求头（通常是 <code>Authorization</code> 字段）中携带这个 Token。服务端接收到请求后，会验证 Token 的有效性，如果验证通过，则处理该请求；否则，拒绝该请求。</p><p>一个典型的 Token 是 <strong>JWT (JSON Web Token)</strong>，它由三部分组成，用 <code>.</code> 分隔：</p><ul><li><strong>Header (头部)</strong>: 包含了令牌的类型（<code>typ</code>，即 JWT）和所使用的签名算法（<code>alg</code>，如 HMAC SHA256 或 RSA）。</li><li><strong>Payload (负载)</strong>: 包含了“声明 (claims)”，是存放实际需要传递的数据的地方。例如用户ID（<code>sub</code>）、签发时间（<code>iat</code>）、过期时间（<code>exp</code>）以及其他自定义的用户信息。<strong>注意：Payload 部分是 Base64 编码的，并非加密，因此不应存放敏感信息。</strong></li><li><strong>Signature (签名)</strong>: 对前两部分（Header 和 Payload）使用指定的算法和存储在服务端的密钥（secret）进行签名。这个签名的作用是<strong>防止数据被篡改</strong>。服务端收到 Token 后，会用同样的算法和密钥重新计算签名，并与 Token 中的签名进行比对，若一致，则说明 Token 未被篡改且是可信的。</li></ul><h4 id="2-Token-认证原理（工作流程）"><a href="#2-Token-认证原理（工作流程）" class="headerlink" title="2. Token 认证原理（工作流程）"></a><strong>2. Token 认证原理（工作流程）</strong></h4><ol><li><strong>登录</strong>: 用户使用用户名和密码发起登录请求。</li><li><strong>验证</strong>: 服务端验证用户的凭据是否正确。</li><li><strong>签发 Token</strong>: 验证成功后，服务端根据用户ID、角色等信息，结合密钥（secret），生成一个 Token。</li><li><strong>返回 Token</strong>: 服务端将生成的 Token 返回给客户端。</li><li><strong>存储 Token</strong>: 客户端（浏览器、App）将 Token 存储起来，通常放在 <code>localStorage</code>、<code>sessionStorage</code> 或 <code>HttpOnly</code> 的 Cookie 中。</li><li><strong>携带 Token 请求</strong>: 客户端在后续每次请求受保护的 API 时，都会在 HTTP 请求头的 <code>Authorization</code> 字段中附上 Token，格式通常为 <code>Bearer &lt;token&gt;</code>。</li><li><strong>验证 Token</strong>: 服务端收到请求后，从请求头中解析出 Token，然后：<ul><li>验证签名是否正确，确保 Token 未被篡改。</li><li>检查 Token 是否在有效期内（<code>exp</code> 声明）。</li><li>如果验证通过，则从 Payload 中获取用户信息，执行业务逻辑并返回结果。</li><li>如果验证失败，则返回 <code>401 Unauthorized</code> 错误。</li></ul></li></ol><h4 id="3-为什么使用-Token？（与-Session-的区别）"><a href="#3-为什么使用-Token？（与-Session-的区别）" class="headerlink" title="3. 为什么使用 Token？（与 Session 的区别）"></a><strong>3. 为什么使用 Token？（与 Session 的区别）</strong></h4><p>在 Web 开发早期，<code>Session-Cookie</code> 机制是主流。服务端在用户登录后创建一个 Session 对象存储在内存或 Redis 中，并生成一个 Session ID，通过 Cookie 返回给浏览器。浏览器后续请求会自动带上这个 Session ID，服务端根据 ID 找到对应的 Session 信息来识别用户。</p><p><strong>Token 机制相比 Session 机制，核心优势在于“无状态性 (Statelessness)”</strong>，这带来了以下好处：</p><table><thead><tr><th>特性对比</th><th>Session 机制</th><th>Token 机制</th><th>优势说明</th></tr></thead><tbody><tr><td><strong>状态存储</strong></td><td><strong>有状态 (Stateful)</strong>。Session 信息需存储在服务端。</td><td><strong>无状态 (Stateless)</strong>。用户信息包含在 Token 的 Payload 中，服务端无需存储。</td><td><strong>减轻服务端压力</strong>。服务端不需要为每个在线用户维护一个 Session 对象。</td></tr><tr><td><strong>可扩展性</strong></td><td><strong>差</strong>。在分布式或集群环境下，需要解决 Session 共享问题（如 Session Sticky、Session Replication、集中存储）。</td><td><strong>好</strong>。由于服务端不存储状态，任何一台服务器只要有相同的密钥，就能验证 Token，天然适合分布式和微服务架构。</td><td><strong>轻松实现水平扩展</strong>。增加服务器节点无需额外配置 Session 共享。</td></tr><tr><td><strong>跨域支持</strong></td><td><strong>有限</strong>。基于 Cookie 的 Session 机制在跨域（CORS）场景下处理起来比较麻烦。</td><td><strong>优秀</strong>。Token 可以通过 HTTP 请求头发送，不受同源策略限制，非常适合前后端分离和跨域 API 调用。</td><td><strong>适应现代架构</strong>。完美支持 SPA（单页应用）、移动 App 等多种客户端。</td></tr><tr><td><strong>安全性</strong></td><td>依赖 Cookie 机制，可能遭受 CSRF 攻击。</td><td>如果 Token 存储在 <code>localStorage</code>，可能遭受 XSS 攻击。需要综合考虑存储方式。</td><td>两者各有安全风险点，需配合其他安全策略。Token 机制不依赖 Cookie，更灵活。</td></tr><tr><td><strong>适用性</strong></td><td>适合传统的、一体化的 Web 应用。</td><td>适合现代的、分布式的、跨终端的（Web, Mobile, IoT）应用架构。</td><td>Token 更具通用性和前瞻性。</td></tr></tbody></table><h4 id="4-双令牌策略-Access-Token-Refresh-Token"><a href="#4-双令牌策略-Access-Token-Refresh-Token" class="headerlink" title="4. 双令牌策略 (Access Token + Refresh Token)"></a><strong>4. 双令牌策略 (Access Token + Refresh Token)</strong></h4><ul><li><strong>Q: 为什么不用单个 Token？</strong><ul><li><strong>如果 Token 有效期很长（如一个月）</strong>: 安全风险高。一旦 Token 在此期间被窃取，攻击者可以长时间冒充用户身份进行操作。</li><li><strong>如果 Token 有效期很短（如 15 分钟）</strong>: 用户体验差。用户需要频繁地重新登录，这是无法接受的。</li></ul></li><li><strong>A: 双令牌策略应运而生，完美平衡了安全性和用户体验。</strong><ul><li><strong>Access Token (访问令牌)</strong>: 它的有效期<strong>非常短</strong>（如 15 分钟到 1 小时）。它被用于访问受保护的资源，由于其生命周期短，即使被窃取，攻击者能造成的危害也有限。</li><li><strong>Refresh Token (刷新令牌)</strong>: 它的有效期<strong>很长</strong>（如 7 天或 30 天）。它的<strong>唯一作用</strong>是用来获取新的 Access Token。Refresh Token 本身不包含任何权限信息，不能用于直接访问 API。</li></ul></li><li><strong>双令牌工作流程（静默刷新）</strong><ol><li><strong>首次登录</strong>: 用户登录成功，服务端返回一个短期的 <code>Access Token</code> 和一个长期的 <code>Refresh Token</code>。客户端将两者都存储起来。</li><li><strong>正常访问</strong>: 客户端使用 <code>Access Token</code> 访问 API。服务端验证 <code>Access Token</code> 通过，返回数据。</li><li><strong>Access Token 过期</strong>: 客户端再次使用过期的 <code>Access Token</code> 访问 API，服务端返回 <code>401 Unauthorized</code> 错误，并可能带上一个特定错误码，告知客户端是“令牌过期”而非“无效令牌”。</li><li><strong>静默刷新</strong>: 客户端的请求拦截器捕获到这个 <code>401</code> 错误后，<strong>不会立即跳转到登录页</strong>。而是自动发起一个特殊的请求，携带那个长期的 <code>Refresh Token</code> 去访问一个专门的刷新接口（如 <code>/api/token/refresh</code>）。</li><li><strong>签发新令牌</strong>: 服务端验证 <code>Refresh Token</code> 的有效性（通常会将其存储在 Redis 或数据库中进行比对，以实现强制下线功能）。如果验证通过，就生成一个<strong>新的 Access Token</strong>（有时也会生成一个新的 <code>Refresh Token</code>，这被称为刷新令牌滚动策略）并返回给客户端。</li><li><strong>重试请求</strong>: 客户端收到新的 <code>Access Token</code> 后，用它替换掉本地旧的 <code>Access Token</code>，然后<strong>自动重新发送刚才因令牌过期而失败的那个请求</strong>。</li><li><strong>无感体验</strong>: 整个过程对用户是透明的，用户感觉不到令牌已经过期并被刷新，实现了“静默刷新”，体验非常流畅。</li><li><strong>Refresh Token 过期</strong>: 如果 <code>Refresh Token</code> 也过期了，那么刷新接口会返回错误，此时客户端才会真正清除用户凭证并引导用户重新登录。</li></ol></li></ul><h4 id="5-Token-相关场景与面试题"><a href="#5-Token-相关场景与面试题" class="headerlink" title="5. Token 相关场景与面试题"></a><strong>5. Token 相关场景与面试题</strong></h4><ul><li><strong>面试题 1：“Token 应该存储在哪里？localStorage、sessionStorage 还是 Cookie？”</strong><ul><li><strong>回答要点</strong>:<ul><li><strong>localStorage&#x2F;sessionStorage</strong>:<ul><li><strong>优点</strong>: 方便 JavaScript 直接读写，容量较大（5MB）。</li><li><strong>缺点</strong>: 容易受到 <strong>XSS (跨站脚本攻击)</strong>。如果网站存在 XSS 漏洞，攻击者可以执行 JS 代码直接窃取存储在其中的 Token。</li></ul></li><li><strong>Cookie (HttpOnly)</strong>:<ul><li><strong>优点</strong>: 设置为 <code>HttpOnly</code> 后，JavaScript 将无法读写该 Cookie，可以有效<strong>防御 XSS 攻击</strong>。浏览器会自动在同域请求中携带它。</li><li><strong>缺点</strong>: 容易受到 <strong>CSRF (跨站请求伪造)</strong> 攻击。攻击者可以诱导用户点击恶意链接，浏览器会自动带上用户的 Cookie 去请求你的网站，执行非用户本意的操作。需要配合 Anti-CSRF Token 等机制来防御。容量较小（4KB）。</li></ul></li><li><strong>最佳实践&#x2F;结论</strong>: 没有绝对完美的选择，需要权衡。<ul><li><strong>高安全性方案</strong>: 将 <code>Refresh Token</code> 存储在 <code>HttpOnly</code> 的 Cookie 中（防止 XSS），将 <code>Access Token</code> 存储在内存中（变量里，页面刷新丢失）或 <code>sessionStorage</code> 中。同时，后端接口必须实施 CSRF 防御策略。</li><li><strong>主流实践方案 (前后端分离)</strong>: 将 Token 存储在 <code>localStorage</code> 中，并在 <code>Authorization</code> 请求头中携带。同时，前端必须严格做好输入过滤和内容转义，尽最大努力防止 XSS 漏洞的出现。</li></ul></li></ul></li></ul></li><li><strong>面试题 2：“用户点击“退出登录”时，Token 如何失效？”</strong><ul><li><strong>回答要点</strong>:<ul><li><strong>对于无状态的 JWT</strong>: 由于所有信息都在 Token 自身，服务端无法主动让其失效。因此，“退出登录”主要是一个<strong>客户端行为</strong>。<ul><li><strong>客户端</strong>: 只需从 <code>localStorage</code> 或其他存储位置清除 Token 即可。用户将无法再发起认证请求。</li></ul></li><li><strong>如何实现服务端强制下线？</strong>: 如果需要实现“踢人下线”或“修改密码后所有设备强制下线”的功能，就必须打破纯粹的无状态。<ul><li><strong>黑名单机制</strong>: 服务端可以建立一个 Token 黑名单（例如，使用 Redis Set）。当用户退出登录时，将该 Token 的 <code>jti</code> (JWT ID) 或整个 Token 放入黑名单，并设置与 Token 剩余有效期相同的过期时间。在每次验证 Token 时，除了常规验证，还需检查该 Token 是否在黑名单中。</li><li><strong>基于 Refresh Token</strong>: 在双令牌模式下，退出登录时只需让服务端的 <code>Refresh Token</code> 失效（例如，从 Redis 中删除）。这样用户就无法再获取新的 <code>Access Token</code>，当旧的 <code>Access Token</code> 过期后，自然就下线了。</li></ul></li></ul></li></ul></li><li><strong>面试题 3：“请你设计一个支持 Web 端和 App 端统一登录的认证系统。”</strong><ul><li><strong>回答要点</strong>:<ul><li>这正是 Token 认证机制的典型应用场景。我会采用基于 <strong>OAuth 2.0&#x2F;OIDC</strong> 或自定义的**双令牌（Access&#x2F;Refresh Token）**方案。</li><li><strong>统一认证中心 (UAC)</strong>: 建立一个独立的认证服务，负责处理所有客户端（Web, iOS, Android）的登录、注册、Token 签发和刷新。</li><li><strong>API 网关</strong>: 所有业务请求都通过 API 网关。网关的核心职责之一就是<strong>统一鉴权</strong>。它会拦截所有请求，解析 <code>Authorization</code> 头中的 <code>Access Token</code>，调用认证中心或自行验证 Token 的有效性。验证通过后，可以将解析出的用户信息（如用户ID）附加到请求头中，再转发给后端的业务微服务。</li><li><strong>业务微服务</strong>: 业务微服务本身<strong>不再关心 Token 的验证细节</strong>，它们信任来自网关的请求，直接从请求头中获取用户信息进行业务处理，实现了业务与认证的解耦。</li><li><strong>流程</strong>:<ol><li>Web&#x2F;App 客户端引导用户到认证中心进行登录。</li><li>登录成功后，认证中心返回 <code>Access Token</code> 和 <code>Refresh Token</code>。</li><li>客户端保存令牌，后续访问业务 API 时，在请求头携带 <code>Access Token</code>。</li><li>API 网关拦截请求，验证 <code>Access Token</code>。</li><li><code>Access Token</code> 过期后，客户端使用 <code>Refresh Token</code> 向认证中心申请新令牌。</li></ol></li><li>这个架构具有高内聚、低耦合、可扩展性强、安全性高的优点。</li></ul></li></ul></li></ul><h1 id="Redis-详细技术解析"><a href="#Redis-详细技术解析" class="headerlink" title="Redis 详细技术解析"></a>Redis 详细技术解析</h1><h2 id="Redis-核心架构与原理"><a href="#Redis-核心架构与原理" class="headerlink" title="Redis 核心架构与原理"></a>Redis 核心架构与原理</h2><h3 id="内存模型与数据结构"><a href="#内存模型与数据结构" class="headerlink" title="内存模型与数据结构"></a>内存模型与数据结构</h3><p>Redis采用基于内存的存储架构，所有数据都保存在RAM中，这是其高性能的根本原因。Redis使用了多种底层数据结构来实现上层的抽象数据类型：</p><p><strong>SDS（Simple Dynamic String）</strong> Redis没有直接使用C语言的字符串，而是构建了SDS。SDS在字符串头部记录了长度信息，避免了strlen的O(n)复杂度，同时预分配空间减少内存重分配次数。</p><p><strong>跳跃表（Skip List）</strong> 有序集合的底层实现之一，是一种随机化的数据结构，通过多层链表实现O(log N)的查找复杂度。相比红黑树，跳跃表实现更简单，且支持范围查询。</p><p><strong>压缩列表（Ziplist）</strong> 当哈希、列表、有序集合元素较少时使用的紧凑存储结构，所有元素存储在一块连续内存中，节省内存但插入删除效率较低。</p><p><strong>字典（Dict）</strong> Redis的核心数据结构，使用开放寻址法解决哈希冲突，支持渐进式rehash。当负载因子过高时，会创建新的哈希表并逐步迁移数据。</p><h3 id="单线程模型与事件循环"><a href="#单线程模型与事件循环" class="headerlink" title="单线程模型与事件循环"></a>单线程模型与事件循环</h3><p>Redis 6.0之前采用单线程模型处理客户端请求，通过I&#x2F;O多路复用（epoll&#x2F;kqueue）实现高并发。单线程避免了线程切换开销和并发控制问题，但也限制了CPU利用率。</p><p><strong>事件循环机制</strong> Redis使用Reactor模式的事件循环，分为文件事件和时间事件：</p><ul><li>文件事件：处理客户端连接、读写请求</li><li>时间事件：处理定时任务，如过期键删除、持久化等</li></ul><p>Redis 6.0引入了多线程I&#x2F;O，但命令执行仍是单线程，多线程只用于网络I&#x2F;O操作的读写，这样既提高了网络处理能力，又保持了数据操作的原子性。</p><h2 id="数据类型详解与应用场景"><a href="#数据类型详解与应用场景" class="headerlink" title="数据类型详解与应用场景"></a>数据类型详解与应用场景</h2><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String是Redis最基础的数据类型，底层可以是SDS、整数或浮点数。</p><p><strong>常用命令</strong>：SET、GET、INCR、DECR、APPEND、GETRANGE <strong>应用场景</strong>：</p><ul><li>缓存：存储用户会话、配置信息</li><li>计数器：网站访问量、点赞数（INCR原子性保证）</li><li>分布式锁：SET key value NX EX seconds</li><li>限流：结合EXPIRE实现滑动窗口限流</li></ul><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash类型适合存储对象，避免了将对象序列化为JSON字符串的开销。</p><p><strong>底层实现</strong>：元素较少时使用ziplist，元素较多时使用hashtable <strong>应用场景</strong>：</p><ul><li>存储用户信息：HSET user:1001 name “张三” age 25</li><li>购物车：HSET cart:1001 product:123 2</li><li>配置管理：分类存储不同模块的配置</li></ul><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>List是双向链表实现，支持在两端进行O(1)的插入和删除操作。</p><p><strong>常用命令</strong>：LPUSH、RPUSH、LPOP、RPOP、LRANGE、BLPOP <strong>应用场景</strong>：</p><ul><li>消息队列：生产者LPUSH，消费者BRPOP实现阻塞队列</li><li>最新列表：朋友圈动态、商品评论</li><li>栈和队列：LPUSH+LPOP实现栈，LPUSH+RPOP实现队列</li></ul><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Set是无序集合，元素唯一，底层使用hashtable或intset实现。</p><p><strong>集合运算</strong>：SINTER（交集）、SUNION（并集）、SDIFF（差集） <strong>应用场景</strong>：</p><ul><li>去重：统计网站独立访客</li><li>社交关系：共同好友、推荐用户</li><li>标签系统：用户标签、文章分类</li><li>抽奖系统：SRANDMEMBER随机抽取</li></ul><h3 id="Sorted-Set类型"><a href="#Sorted-Set类型" class="headerlink" title="Sorted Set类型"></a>Sorted Set类型</h3><p>有序集合，每个元素关联一个分数，按分数排序。底层使用跳跃表和哈希表。</p><p><strong>应用场景</strong>：</p><ul><li>排行榜：游戏积分、热搜榜</li><li>延时队列：分数为执行时间戳</li><li>范围查询：按时间、按分数范围获取数据</li></ul><h2 id="持久化机制深度解析"><a href="#持久化机制深度解析" class="headerlink" title="持久化机制深度解析"></a>持久化机制深度解析</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB通过fork子进程，将内存数据快照写入磁盘。</p><p><strong>优点</strong>：</p><ul><li>文件紧凑，适合备份和灾难恢复</li><li>恢复速度快</li><li>对Redis性能影响小（子进程操作）</li></ul><p><strong>缺点</strong>：</p><ul><li>数据丢失风险：两次快照间的数据可能丢失</li><li>fork过程会阻塞主进程</li><li>大数据集fork耗时较长</li></ul><p><strong>触发条件</strong>：</p><ul><li>手动执行SAVE或BGSAVE命令</li><li>配置自动触发：save 900 1（900秒内至少1个键改变）</li><li>主从复制时自动生成RDB</li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF记录每个写命令，通过重放命令恢复数据。</p><p><strong>写入时机</strong>：</p><ul><li>always：每个写命令立即同步，安全但性能低</li><li>everysec：每秒同步一次，平衡安全性和性能</li><li>no：由操作系统决定同步时机，性能高但安全性低</li></ul><p><strong>AOF重写</strong>： AOF文件会越来越大，Redis提供重写机制优化：</p><ul><li>遍历内存数据，用最少命令重建AOF文件</li><li>重写期间的新命令写入AOF重写缓冲区</li><li>原子性替换旧AOF文件</li></ul><p><strong>混合持久化</strong>： Redis 4.0引入RDB+AOF混合模式，重写时以RDB格式写入基础数据，增量命令以AOF格式追加，兼顾了恢复速度和数据安全。</p><h2 id="缓存问题与解决方案"><a href="#缓存问题与解决方案" class="headerlink" title="缓存问题与解决方案"></a>缓存问题与解决方案</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在的数据，缓存无法生效，请求直达数据库。</p><p><strong>解决方案</strong>：</p><ol><li><strong>空值缓存</strong>：查询结果为空时也缓存，设置较短过期时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (data == null) &#123;</span><br><span class="line">    redis.setex(key, 60, &quot;null&quot;);  // 缓存空值60秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>布隆过滤器</strong>：预先将所有可能存在的数据哈希到位数组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BloomFilter&lt;String&gt; filter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()), 1000000, 0.01);</span><br><span class="line">// 查询前先检查布隆过滤器</span><br><span class="line">if (!filter.mightContain(key)) &#123;</span><br><span class="line">    return null;  // 一定不存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>参数校验</strong>：在API层面进行参数合法性校验</li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>热点数据过期瞬间，大量并发请求击穿缓存。</p><p><strong>解决方案</strong>：</p><ol><li><strong>互斥锁</strong>：只允许一个线程查询数据库并重建缓存</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public String getData(String key) &#123;</span><br><span class="line">    String data = redis.get(key);</span><br><span class="line">    if (data == null) &#123;</span><br><span class="line">        String lockKey = &quot;lock:&quot; + key;</span><br><span class="line">        if (redis.setnx(lockKey, &quot;1&quot;, 10)) &#123;  // 获取锁</span><br><span class="line">            try &#123;</span><br><span class="line">                data = database.query(key);  // 查询数据库</span><br><span class="line">                redis.setex(key, 3600, data);  // 重建缓存</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                redis.del(lockKey);  // 释放锁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Thread.sleep(50);  // 等待其他线程重建缓存</span><br><span class="line">            return getData(key);  // 递归重试</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>热点数据永不过期</strong>：逻辑上设置过期时间，物理上不过期，异步更新</li><li><strong>预热机制</strong>：系统启动时预先加载热点数据</li><li><strong>二级缓存</strong>：L1缓存过期后，先返回L2缓存数据，异步更新L1</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量缓存同时过期或Redis宕机，请求涌向数据库。</p><p><strong>解决方案</strong>：</p><ol><li><strong>过期时间随机化</strong>：避免同时过期</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int randomExpire = baseExpire + new Random().nextInt(300);  // 基础时间+随机时间</span><br><span class="line">redis.setex(key, randomExpire, data);</span><br></pre></td></tr></table></figure><ol><li><strong>多级缓存架构</strong>：<ul><li>L1：本地缓存（如Caffeine）</li><li>L2：Redis分布式缓存</li><li>L3：数据库</li></ul></li><li><strong>限流降级</strong>：使用Sentinel、Hystrix等组件</li><li><strong>Redis高可用</strong>：主从复制、哨兵模式、集群部署</li></ol><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>系统启动时预先加载热点数据到缓存。</p><p><strong>实现方式</strong>：</p><ol><li><strong>定时任务预热</strong>：凌晨低峰期执行</li><li><strong>手动预热</strong>：管理后台触发预热任务</li><li><strong>实时预热</strong>：监控系统发现热点数据自动预热</li></ol><h2 id="数据一致性保证"><a href="#数据一致性保证" class="headerlink" title="数据一致性保证"></a>数据一致性保证</h2><h3 id="Cache-Aside模式（旁路缓存）"><a href="#Cache-Aside模式（旁路缓存）" class="headerlink" title="Cache Aside模式（旁路缓存）"></a>Cache Aside模式（旁路缓存）</h3><p>应用程序负责维护缓存和数据库的一致性。</p><p><strong>读操作</strong>：</p><ol><li>先读缓存，命中则返回</li><li>缓存不命中，查询数据库</li><li>将数据写入缓存并返回</li></ol><p><strong>写操作</strong>：</p><ol><li>先更新数据库</li><li>删除缓存（让下次读取时重新加载）</li></ol><p><strong>为什么是删除而不是更新缓存？</strong></p><ul><li>更新缓存可能存在并发问题</li><li>复杂查询的缓存更新成本高</li><li>删除缓存更简单可靠</li></ul><h3 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h3><p>解决读写并发导致的数据不一致问题。</p><p><strong>实现步骤</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void updateData(String key, Object data) &#123;</span><br><span class="line">    // 1. 删除缓存</span><br><span class="line">    redis.del(key);</span><br><span class="line">    </span><br><span class="line">    // 2. 更新数据库</span><br><span class="line">    database.update(data);</span><br><span class="line">    </span><br><span class="line">    // 3. 延时删除缓存（异步）</span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);  // 延时500ms</span><br><span class="line">            redis.del(key);     // 再次删除缓存</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            log.error(&quot;延时删除缓存失败&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>延时时间设置</strong>：通常为主从同步时间 + 读数据库时间 + 几十毫秒</p><h3 id="基于消息队列的最终一致性"><a href="#基于消息队列的最终一致性" class="headerlink" title="基于消息队列的最终一致性"></a>基于消息队列的最终一致性</h3><p>使用消息队列异步处理缓存更新，保证最终一致性。</p><p><strong>实现流程</strong>：</p><ol><li>更新数据库，发送消息到队列</li><li>消息消费者删除相关缓存</li><li>消费失败时重试，保证最终一致性</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 发送缓存删除消息</span><br><span class="line">@Transactional</span><br><span class="line">public void updateUser(User user) &#123;</span><br><span class="line">    userDao.update(user);  // 更新数据库</span><br><span class="line">    </span><br><span class="line">    // 发送缓存删除消息（事务提交后发送）</span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(</span><br><span class="line">        new TransactionSynchronizationAdapter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void afterCommit() &#123;</span><br><span class="line">                cacheDeleteMQ.send(&quot;user:&quot; + user.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式事务方案"><a href="#分布式事务方案" class="headerlink" title="分布式事务方案"></a>分布式事务方案</h3><p>对于强一致性要求高的场景，可以使用分布式事务。</p><p><strong>2PC（两阶段提交）</strong>：</p><ul><li>准备阶段：协调者询问参与者是否准备好</li><li>提交阶段：所有参与者都准备好则提交，否则回滚</li></ul><p><strong>TCC（Try-Confirm-Cancel）</strong>：</p><ul><li>Try：尝试执行，预留资源</li><li>Confirm：确认提交</li><li>Cancel：取消执行，释放资源</li></ul><h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><h3 id="基于SET命令的分布式锁"><a href="#基于SET命令的分布式锁" class="headerlink" title="基于SET命令的分布式锁"></a>基于SET命令的分布式锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class RedisDistributedLock &#123;</span><br><span class="line">    private Jedis jedis;</span><br><span class="line">    </span><br><span class="line">    public boolean tryLock(String lockKey, String requestId, int expireTime) &#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, &quot;NX&quot;, &quot;PX&quot;, expireTime);</span><br><span class="line">        return &quot;OK&quot;.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean releaseLock(String lockKey, String requestId) &#123;</span><br><span class="line">        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                       &quot;return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey),</span><br><span class="line">                                 Collections.singletonList(requestId));</span><br><span class="line">        return &quot;1&quot;.equals(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用方式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = &quot;lock:user:1001&quot;;</span><br><span class="line">String requestId = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">if (tryLock(lockKey, requestId, 30000)) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 执行业务逻辑</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        releaseLock(lockKey, requestId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h3><p>为了解决单点故障问题，Redis官方提出了Redlock算法。</p><p><strong>算法步骤</strong>：</p><ol><li>获取当前时间戳</li><li>依次向N个Redis实例申请锁</li><li>如果在大多数实例（N&#x2F;2+1）上获取锁成功，且总耗时小于锁超时时间，则认为获取锁成功</li><li>锁的有效时间 &#x3D; 初始有效时间 - 获取锁消耗的时间</li><li>释放锁时，向所有Redis实例发送释放命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Redlock &#123;</span><br><span class="line">    private List&lt;Jedis&gt; jedisInstances;</span><br><span class="line">    </span><br><span class="line">    public boolean lock(String resource, int ttl) &#123;</span><br><span class="line">        int quorum = jedisInstances.size() / 2 + 1;</span><br><span class="line">        int successCount = 0;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        for (Jedis jedis : jedisInstances) &#123;</span><br><span class="line">            if (lockInstance(jedis, resource, ttl)) &#123;</span><br><span class="line">                successCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        long elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        if (successCount &gt;= quorum &amp;&amp; elapsedTime &lt; ttl) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            unlock(resource);  // 释放已获取的锁</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁的问题与优化"><a href="#锁的问题与优化" class="headerlink" title="锁的问题与优化"></a>锁的问题与优化</h3><p><strong>锁超时问题</strong>： 业务执行时间超过锁超时时间，锁自动释放，可能导致并发问题。</p><p><strong>解决方案</strong>：</p><ol><li><strong>看门狗机制</strong>：定时续期锁的过期时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class WatchDog &#123;</span><br><span class="line">    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);</span><br><span class="line">    </span><br><span class="line">    public void startWatchDog(String lockKey, String requestId) &#123;</span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            // 续期锁</span><br><span class="line">            String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                           &quot;return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) else return 0 end&quot;;</span><br><span class="line">            jedis.eval(script, Arrays.asList(lockKey), </span><br><span class="line">                      Arrays.asList(requestId, &quot;30&quot;));</span><br><span class="line">        &#125;, 10, 10, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>合理评估业务执行时间</strong>：设置足够的锁超时时间</li></ol><p><strong>锁竞争激烈问题</strong>： 大量线程竞争同一把锁，导致性能下降。</p><p><strong>解决方案</strong>：</p><ol><li><strong>分段锁</strong>：将资源分段，减少锁竞争</li><li><strong>队列锁</strong>：使用List实现公平锁</li><li><strong>自旋锁优化</strong>：适当的退避算法</li></ol><h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>假设会发生并发冲突，在操作数据前先获取锁。</p><p><strong>Redis实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 使用Redis分布式锁实现悲观锁</span><br><span class="line">public void updateWithPessimisticLock(String userId, int amount) &#123;</span><br><span class="line">    String lockKey = &quot;lock:account:&quot; + userId;</span><br><span class="line">    String requestId = UUID.randomUUID().toString();</span><br><span class="line">    </span><br><span class="line">    if (tryLock(lockKey, requestId, 30000)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 查询账户余额</span><br><span class="line">            int balance = getBalance(userId);</span><br><span class="line">            if (balance &gt;= amount) &#123;</span><br><span class="line">                // 扣减余额</span><br><span class="line">                updateBalance(userId, balance - amount);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InsufficientBalanceException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            releaseLock(lockKey, requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new LockAcquisitionException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>假设不会发生冲突，在更新时检查数据是否被修改。</p><p><strong>基于版本号的乐观锁</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public boolean updateWithOptimisticLock(String userId, int amount, int expectedVersion) &#123;</span><br><span class="line">    // 使用Lua脚本保证原子性</span><br><span class="line">    String script = </span><br><span class="line">        &quot;local current = redis.call(&#x27;hmget&#x27;, KEYS[1], &#x27;balance&#x27;, &#x27;version&#x27;) &quot; +</span><br><span class="line">        &quot;if current[2] == ARGV[2] then &quot; +</span><br><span class="line">        &quot;  if tonumber(current[1]) &gt;= tonumber(ARGV[1]) then &quot; +</span><br><span class="line">        &quot;    redis.call(&#x27;hmset&#x27;, KEYS[1], &#x27;balance&#x27;, current[1] - ARGV[1], &#x27;version&#x27;, current[2] + 1) &quot; +</span><br><span class="line">        &quot;    return 1 &quot; +</span><br><span class="line">        &quot;  else &quot; +</span><br><span class="line">        &quot;    return -1 &quot; +  // 余额不足</span><br><span class="line">        &quot;  end &quot; +</span><br><span class="line">        &quot;else &quot; +</span><br><span class="line">        &quot;  return 0 &quot; +     // 版本号不匹配</span><br><span class="line">        &quot;end&quot;;</span><br><span class="line">    </span><br><span class="line">    String key = &quot;account:&quot; + userId;</span><br><span class="line">    Object result = jedis.eval(script, Arrays.asList(key), </span><br><span class="line">                              Arrays.asList(String.valueOf(amount), String.valueOf(expectedVersion)));</span><br><span class="line">    </span><br><span class="line">    int code = ((Long) result).intValue();</span><br><span class="line">    if (code == 1) &#123;</span><br><span class="line">        return true;  // 更新成功</span><br><span class="line">    &#125; else if (code == 0) &#123;</span><br><span class="line">        throw new OptimisticLockException(&quot;数据已被修改&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new InsufficientBalanceException(&quot;余额不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于CAS的乐观锁</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void updateWithCAS(String key, Function&lt;String, String&gt; updater) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 1. 获取当前值</span><br><span class="line">        String currentValue = redis.get(key);</span><br><span class="line">        </span><br><span class="line">        // 2. 计算新值</span><br><span class="line">        String newValue = updater.apply(currentValue);</span><br><span class="line">        </span><br><span class="line">        // 3. CAS更新</span><br><span class="line">        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                       &quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[2]) else return nil end&quot;;</span><br><span class="line">        Object result = redis.eval(script, Arrays.asList(key), </span><br><span class="line">                                  Arrays.asList(currentValue, newValue));</span><br><span class="line">        </span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            break;  // 更新成功</span><br><span class="line">        &#125;</span><br><span class="line">        // 更新失败，重试</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="悲观锁-vs-乐观锁选择"><a href="#悲观锁-vs-乐观锁选择" class="headerlink" title="悲观锁 vs 乐观锁选择"></a>悲观锁 vs 乐观锁选择</h3><p><strong>悲观锁适用场景</strong>：</p><ul><li>写操作频繁，冲突概率高</li><li>业务逻辑复杂，重试成本高</li><li>对数据一致性要求严格</li></ul><p><strong>乐观锁适用场景</strong>：</p><ul><li>读多写少，冲突概率低</li><li>业务逻辑简单，重试成本低</li><li>对性能要求高</li></ul><h2 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Master负责写操作，Slave负责读操作，通过复制实现数据同步。</p><p><strong>复制原理</strong>：</p><ol><li>Slave向Master发送PSYNC命令</li><li>Master执行BGSAVE生成RDB文件</li><li>Master将RDB文件发送给Slave</li><li>Slave载入RDB文件</li><li>Master将缓冲区的写命令发送给Slave</li><li>后续写命令实时同步</li></ol><p><strong>部分重同步</strong>： 网络断连后，Slave只需要同步断连期间的命令，而不是完整重同步。</p><h3 id="哨兵模式（Sentinel）"><a href="#哨兵模式（Sentinel）" class="headerlink" title="哨兵模式（Sentinel）"></a>哨兵模式（Sentinel）</h3><p>哨兵负责监控Master状态，在Master故障时自动进行故障转移。</p><p><strong>哨兵职责</strong>：</p><ul><li>监控：定期ping Master和Slave</li><li>通知：故障时通知管理员和客户端</li><li>故障转移：自动将Slave提升为新Master</li><li>配置管理：为客户端提供服务发现</li></ul><p><strong>故障转移流程</strong>：</p><ol><li>哨兵发现Master下线（主观下线）</li><li>多个哨兵确认Master下线（客观下线）</li><li>选举领导哨兵执行故障转移</li><li>选择合适的Slave作为新Master</li><li>修改其他Slave的配置指向新Master</li><li>通知客户端Master地址变更</li></ol><h3 id="集群模式（Cluster）"><a href="#集群模式（Cluster）" class="headerlink" title="集群模式（Cluster）"></a>集群模式（Cluster）</h3><p>Redis Cluster通过分片实现横向扩展和高可用。</p><p><strong>分片算法</strong>： 使用CRC16算法计算key的哈希值，然后对16384取模得到槽位号。</p><p><strong>节点通信</strong>： 使用Gossip协议在节点间交换状态信息，包括节点上线&#x2F;下线、槽位分配等。</p><p><strong>故障转移</strong>： 当Master节点故障时，其Slave自动提升为新Master，过程对客户端透明。</p><p><strong>数据迁移</strong>： 集群扩容时，需要将部分槽位从现有节点迁移到新节点。</p><h2 id="性能监控与优化"><a href="#性能监控与优化" class="headerlink" title="性能监控与优化"></a>性能监控与优化</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>Redis提供慢查询日志功能，记录执行时间超过阈值的命令。</p><p><strong>配置参数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than 10000  # 超过10毫秒记录</span><br><span class="line">slowlog-max-len 128           # 最多保存128条记录</span><br></pre></td></tr></table></figure><p><strong>查看慢查询</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLOWLOG GET 10  # 获取最近10条慢查询</span><br></pre></td></tr></table></figure><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p>使用MEMORY命令分析内存使用情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MEMORY USAGE key         # 查看key占用内存</span><br><span class="line">MEMORY STATS            # 查看内存统计信息</span><br><span class="line">MEMORY DOCTOR           # 内存使用建议</span><br></pre></td></tr></table></figure><h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><p><strong>避免大key</strong>：</p><ul><li>单个key的value不要超过10KB</li><li>集合类型元素数量控制在合理范围</li><li>使用SCAN代替KEYS命令</li></ul><p><strong>合理使用数据结构</strong>：</p><ul><li>小对象使用Hash而不是多个String</li><li>合理设置ziplist等压缩结构的阈值</li><li>使用位图(bitmap)存储布尔类型大数据集</li></ul><p><strong>网络优化</strong>：</p><ul><li>使用Pipeline批量操作</li><li>合理设置客户端连接池</li><li>启用TCP_NODELAY选项</li></ul><p><strong>持久化优化</strong>：</p><ul><li>根据业务需求选择RDB或AOF</li><li>合理配置自动保存条件</li><li>在从节点上进行持久化操作</li></ul><p>这些详细的技术点涵盖了Redis的核心概念、常见问题解决方案和实际应用场景，是Redis技术面试的重要考查内容。掌握这些知识点并能结合实际项目经验进行说明，将大大提高面试通过率。</p><h2 id="内存管理与淘汰机制"><a href="#内存管理与淘汰机制" class="headerlink" title="内存管理与淘汰机制"></a>内存管理与淘汰机制</h2><h3 id="内存淘汰策略详解"><a href="#内存淘汰策略详解" class="headerlink" title="内存淘汰策略详解"></a>内存淘汰策略详解</h3><p>当Redis内存使用达到maxmemory限制时，会根据配置的策略淘汰数据。</p><p><strong>8种淘汰策略</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 针对所有key</span><br><span class="line">noeviction          # 不淘汰，写入返回错误</span><br><span class="line">allkeys-lru         # 所有key中淘汰最近最少使用</span><br><span class="line">allkeys-lfu         # 所有key中淘汰最少频率使用</span><br><span class="line">allkeys-random      # 所有key中随机淘汰</span><br><span class="line"></span><br><span class="line"># 针对设置了过期时间的key</span><br><span class="line">volatile-lru        # 过期key中淘汰最近最少使用</span><br><span class="line">volatile-lfu        # 过期key中淘汰最少频率使用</span><br><span class="line">volatile-random     # 过期key中随机淘汰</span><br><span class="line">volatile-ttl        # 过期key中淘汰即将过期的</span><br></pre></td></tr></table></figure><p><strong>LRU vs LFU 实现细节</strong>： Redis的LRU并非严格的LRU，而是近似LRU算法：</p><ul><li>每个key都有24位的时钟字段记录访问时间</li><li>淘汰时随机采样5个key（可配置），选择时钟值最小的</li></ul><p>LFU算法维护访问频率：</p><ul><li>高16位存储上次访问时间</li><li>低8位存储访问频率计数器</li><li>计数器采用概率性递增，避免频率无限增长</li></ul><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p><strong>产生原因</strong>：</p><ul><li>频繁的数据更新导致内存分配&#x2F;释放</li><li>Redis使用jemalloc内存分配器，存在内存对齐</li><li>删除大key后留下内存空洞</li></ul><p><strong>检测方法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"># 关注 mem_fragmentation_ratio 指标</span><br><span class="line"># 比值 &gt; 1.5 表示碎片较多</span><br><span class="line"># 比值 &lt; 1 表示使用了swap，性能严重下降</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><ol><li><strong>内存整理</strong>（Redis 4.0+）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET activedefrag yes        # 开启自动整理</span><br><span class="line">CONFIG SET active-defrag-threshold-lower 10  # 碎片率超过10%启动</span><br><span class="line">MEMORY PURGE                       # 手动触发整理</span><br></pre></td></tr></table></figure><ol><li><strong>重启Redis</strong>：最彻底但影响服务可用性</li><li><strong>优化数据结构</strong>：减少小对象，使用Hash存储相关数据</li></ol><h2 id="过期策略与删除机制"><a href="#过期策略与删除机制" class="headerlink" title="过期策略与删除机制"></a>过期策略与删除机制</h2><h3 id="三种过期删除策略"><a href="#三种过期删除策略" class="headerlink" title="三种过期删除策略"></a>三种过期删除策略</h3><p><strong>定时删除</strong>：设置过期时间时创建定时器，到期立即删除</p><ul><li>优点：及时释放内存</li><li>缺点：消耗CPU资源创建和管理定时器</li></ul><p><strong>惰性删除</strong>：访问key时检查是否过期，过期则删除</p><ul><li>优点：CPU友好，只在必要时删除</li><li>缺点：内存不友好，过期key可能长期占用内存</li></ul><p><strong>定期删除</strong>：定期随机检查部分key，删除过期的</p><ul><li>Redis的实际策略，平衡CPU和内存使用</li></ul><h3 id="Redis过期删除实现"><a href="#Redis过期删除实现" class="headerlink" title="Redis过期删除实现"></a>Redis过期删除实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 简化的过期删除逻辑</span><br><span class="line">void activeExpireCycle(int type) &#123;</span><br><span class="line">    static int current_db = 0;</span><br><span class="line">    static int timelimit_exit = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">        redisDb *db = server.db + current_db % server.dbnum;</span><br><span class="line">        </span><br><span class="line">        int iteration = 0;</span><br><span class="line">        while (iteration &lt; 20) &#123;  // 最多检查20个key</span><br><span class="line">            long sampled = 0, expired = 0;</span><br><span class="line">            </span><br><span class="line">            // 随机选择key检查过期</span><br><span class="line">            for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                dictEntry *de = dictGetRandomKey(db-&gt;expires);</span><br><span class="line">                if (de == NULL) break;</span><br><span class="line">                </span><br><span class="line">                sampled++;</span><br><span class="line">                if (keyIsExpired(db, de)) &#123;</span><br><span class="line">                    deleteExpiredKey(db, de);</span><br><span class="line">                    expired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 如果过期比例超过25%，继续下轮检查</span><br><span class="line">            if (expired &gt; 5) iteration++;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        current_db++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构底层实现深度解析"><a href="#数据结构底层实现深度解析" class="headerlink" title="数据结构底层实现深度解析"></a>数据结构底层实现深度解析</h2><h3 id="压缩列表（ZipList）演进"><a href="#压缩列表（ZipList）演进" class="headerlink" title="压缩列表（ZipList）演进"></a>压缩列表（ZipList）演进</h3><p>Redis 7.0用ListPack替代了ZipList，解决了级联更新问题。</p><p><strong>ZipList问题</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ZipList结构导致的级联更新</span><br><span class="line">// 当插入元素导致某个entry的长度改变时</span><br><span class="line">// 可能引起后续所有entry的重新编码</span><br></pre></td></tr></table></figure><p><strong>ListPack优势</strong>：</p><ul><li>每个元素独立编码，避免级联更新</li><li>支持从尾部遍历，提高某些操作效率</li></ul><h3 id="字典扩容与rehash"><a href="#字典扩容与rehash" class="headerlink" title="字典扩容与rehash"></a>字典扩容与rehash</h3><p>Redis字典使用增量式rehash避免阻塞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 渐进式rehash实现</span><br><span class="line">int dictRehash(dict *d, int n) &#123;</span><br><span class="line">    int empty_visits = n * 10;</span><br><span class="line">    </span><br><span class="line">    if (!dictIsRehashing(d)) return 0;</span><br><span class="line">    </span><br><span class="line">    while (n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;</span><br><span class="line">        // 跳过空桶</span><br><span class="line">        while (d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            if (--empty_visits == 0) return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 迁移桶中所有元素</span><br><span class="line">        dictEntry *de = d-&gt;ht[0].table[d-&gt;rehashidx];</span><br><span class="line">        while (de) &#123;</span><br><span class="line">            dictEntry *nextde = de-&gt;next;</span><br><span class="line">            unsigned int h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[1].table[h];</span><br><span class="line">            d-&gt;ht[1].table[h] = de;</span><br><span class="line">            d-&gt;ht[0].used--;</span><br><span class="line">            d-&gt;ht[1].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络模型与性能优化"><a href="#网络模型与性能优化" class="headerlink" title="网络模型与性能优化"></a>网络模型与性能优化</h2><h3 id="Redis-6-0-多线程I-O"><a href="#Redis-6-0-多线程I-O" class="headerlink" title="Redis 6.0 多线程I&#x2F;O"></a>Redis 6.0 多线程I&#x2F;O</h3><p>多线程只用于网络I&#x2F;O，命令执行仍是单线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 多线程I/O处理流程</span><br><span class="line">void *IOThreadMain(void *myid) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 等待主线程分配任务</span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[id]);</span><br><span class="line">        </span><br><span class="line">        while (io_threads_list[id] &amp;&amp; io_threads_pending[id] == 0) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;io_threads_cond[id], &amp;io_threads_mutex[id]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 处理读写任务</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line">        listRewind(io_threads_list[id], &amp;li);</span><br><span class="line">        </span><br><span class="line">        while ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *c = listNodeValue(ln);</span><br><span class="line">            if (io_threads_op == IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                writeToClient(c, 0);</span><br><span class="line">            &#125; else if (io_threads_op == IO_THREADS_OP_READ) &#123;</span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        io_threads_pending[id] = 0;</span><br><span class="line">        pthread_mutex_unlock(&amp;io_threads_mutex[id]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端连接管理"><a href="#客户端连接管理" class="headerlink" title="客户端连接管理"></a>客户端连接管理</h3><p><strong>连接池配置优化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Jedis连接池配置</span><br><span class="line">JedisPoolConfig config = new JedisPoolConfig();</span><br><span class="line">config.setMaxTotal(200);                    // 最大连接数</span><br><span class="line">config.setMaxIdle(50);                      // 最大空闲连接</span><br><span class="line">config.setMinIdle(10);                      // 最小空闲连接</span><br><span class="line">config.setTestOnBorrow(true);               // 获取连接时测试</span><br><span class="line">config.setTestOnReturn(true);               // 归还连接时测试</span><br><span class="line">config.setTestWhileIdle(true);              // 空闲时测试</span><br><span class="line">config.setTimeBetweenEvictionRunsMillis(30000);  // 检查间隔</span><br><span class="line">config.setNumTestsPerEvictionRun(10);       // 每次检查连接数</span><br><span class="line">config.setMinEvictableIdleTimeMillis(60000);     // 最小空闲时间</span><br><span class="line"></span><br><span class="line">JedisPool pool = new JedisPool(config, &quot;localhost&quot;, 6379);</span><br></pre></td></tr></table></figure><p><strong>Pipeline优化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Pipeline批量操作</span><br><span class="line">public void batchSet(Map&lt;String, String&gt; data) &#123;</span><br><span class="line">    try (Jedis jedis = pool.getResource()) &#123;</span><br><span class="line">        Pipeline pipeline = jedis.pipelined();</span><br><span class="line">        </span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : data.entrySet()) &#123;</span><br><span class="line">            pipeline.set(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Object&gt; results = pipeline.syncAndReturnAll();</span><br><span class="line">        // 处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级数据类型与应用"><a href="#高级数据类型与应用" class="headerlink" title="高级数据类型与应用"></a>高级数据类型与应用</h2><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>用于基数统计，占用内存固定（12KB），误差率0.81%。</p><p><strong>实现原理</strong>：</p><ul><li>基于概率算法，通过观察随机数的最大前导零个数估算基数</li><li>使用调和平均数减少误差</li><li>适用于UV统计等场景</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 网站UV统计</span><br><span class="line">PFADD uv:20230815 user1 user2 user3</span><br><span class="line">PFCOUNT uv:20230815                    # 获取UV数量</span><br><span class="line">PFMERGE uv:week uv:20230815 uv:20230816  # 合并多日数据</span><br></pre></td></tr></table></figure><h3 id="布隆过滤器（Redis-Module）"><a href="#布隆过滤器（Redis-Module）" class="headerlink" title="布隆过滤器（Redis Module）"></a>布隆过滤器（Redis Module）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Redis布隆过滤器模块</span><br><span class="line">BF.RESERVE myfilter 0.01 1000000       # 创建过滤器，误报率0.01%，预期元素100万</span><br><span class="line">BF.ADD myfilter &quot;user123&quot;              # 添加元素</span><br><span class="line">BF.EXISTS myfilter &quot;user123&quot;           # 检查元素是否存在</span><br><span class="line">BF.MADD myfilter item1 item2 item3     # 批量添加</span><br><span class="line">BF.MEXISTS myfilter item1 item2 item3  # 批量检查</span><br></pre></td></tr></table></figure><h3 id="Geo地理位置"><a href="#Geo地理位置" class="headerlink" title="Geo地理位置"></a>Geo地理位置</h3><p>基于Sorted Set实现，使用GeoHash算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 添加地理位置</span><br><span class="line">GEOADD cities 116.397128 39.916527 &quot;北京&quot; 121.473701 31.230416 &quot;上海&quot;</span><br><span class="line"></span><br><span class="line"># 计算距离</span><br><span class="line">GEODIST cities &quot;北京&quot; &quot;上海&quot; km</span><br><span class="line"></span><br><span class="line"># 范围查询</span><br><span class="line">GEORADIUS cities 116.397128 39.916527 1000 km WITHDIST WITHCOORD</span><br><span class="line"></span><br><span class="line"># 根据成员查询</span><br><span class="line">GEORADIUSBYMEMBER cities &quot;北京&quot; 1000 km</span><br></pre></td></tr></table></figure><h2 id="安全性问题与防护"><a href="#安全性问题与防护" class="headerlink" title="安全性问题与防护"></a>安全性问题与防护</h2><h3 id="常见安全漏洞"><a href="#常见安全漏洞" class="headerlink" title="常见安全漏洞"></a>常见安全漏洞</h3><p><strong>命令注入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 错误做法：直接拼接用户输入</span><br><span class="line">String key = &quot;user:&quot; + userInput;  // userInput可能包含恶意命令</span><br><span class="line">jedis.eval(&quot;return redis.call(&#x27;get&#x27;, &#x27;&quot; + key + &quot;&#x27;)&quot;, 0);</span><br><span class="line"></span><br><span class="line">// 正确做法：使用参数化查询</span><br><span class="line">jedis.eval(&quot;return redis.call(&#x27;get&#x27;, KEYS[1])&quot;, 1, key);</span><br></pre></td></tr></table></figure><p><strong>未授权访问</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># redis.conf安全配置</span><br><span class="line">bind 127.0.0.1                        # 绑定指定IP</span><br><span class="line">requirepass your_password              # 设置密码</span><br><span class="line">protected-mode yes                     # 开启保护模式</span><br><span class="line">port 0                                # 禁用默认端口</span><br><span class="line">port 6380                             # 使用非标准端口</span><br></pre></td></tr></table></figure><p><strong>危险命令禁用</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 重命名危险命令</span><br><span class="line">rename-command FLUSHDB &quot;&quot;             # 禁用FLUSHDB</span><br><span class="line">rename-command FLUSHALL &quot;&quot;            # 禁用FLUSHALL</span><br><span class="line">rename-command SHUTDOWN &quot;REDIS_SHUTDOWN&quot;  # 重命名SHUTDOWN</span><br><span class="line">rename-command CONFIG &quot;REDIS_CONFIG&quot;   # 重命名CONFIG</span><br></pre></td></tr></table></figure><h3 id="ACL访问控制（Redis-6-0-）"><a href="#ACL访问控制（Redis-6-0-）" class="headerlink" title="ACL访问控制（Redis 6.0+）"></a>ACL访问控制（Redis 6.0+）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户</span><br><span class="line">ACL SETUSER alice on &gt;password123 ~cached:* +get +set</span><br><span class="line"></span><br><span class="line"># 查看用户权限</span><br><span class="line">ACL LIST</span><br><span class="line"></span><br><span class="line"># 删除用户</span><br><span class="line">ACL DELUSER alice</span><br><span class="line"></span><br><span class="line"># 检查权限</span><br><span class="line">AUTH alice password123</span><br></pre></td></tr></table></figure><h2 id="监控与运维"><a href="#监控与运维" class="headerlink" title="监控与运维"></a>监控与运维</h2><h3 id="关键监控指标"><a href="#关键监控指标" class="headerlink" title="关键监控指标"></a>关键监控指标</h3><p><strong>性能指标</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 通过INFO命令获取</span><br><span class="line">INFO stats</span><br><span class="line"># 关注指标：</span><br><span class="line"># - instantaneous_ops_per_sec: QPS</span><br><span class="line"># - keyspace_hits/keyspace_misses: 命中率</span><br><span class="line"># - used_cpu_sys/used_cpu_user: CPU使用率</span><br><span class="line"># - connected_clients: 连接数</span><br><span class="line"># - blocked_clients: 阻塞连接数</span><br></pre></td></tr></table></figure><p><strong>内存指标</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"># 关注指标：</span><br><span class="line"># - used_memory: 已使用内存</span><br><span class="line"># - used_memory_rss: 物理内存占用</span><br><span class="line"># - mem_fragmentation_ratio: 内存碎片率</span><br><span class="line"># - used_memory_peak: 内存使用峰值</span><br></pre></td></tr></table></figure><p><strong>持久化指标</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO persistence</span><br><span class="line"># 关注指标：</span><br><span class="line"># - rdb_last_save_time: 最后RDB保存时间</span><br><span class="line"># - aof_last_rewrite_time_sec: AOF重写耗时</span><br><span class="line"># - aof_current_size: AOF文件大小</span><br></pre></td></tr></table></figure><h3 id="故障排查常用命令"><a href="#故障排查常用命令" class="headerlink" title="故障排查常用命令"></a>故障排查常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接信息</span><br><span class="line">CLIENT LIST</span><br><span class="line">CLIENT INFO</span><br><span class="line"></span><br><span class="line"># 慢查询分析</span><br><span class="line">SLOWLOG GET 10</span><br><span class="line">CONFIG GET slowlog-log-slower-than</span><br><span class="line"></span><br><span class="line"># 大key查找</span><br><span class="line">MEMORY USAGE keyname</span><br><span class="line">redis-cli --bigkeys</span><br><span class="line"></span><br><span class="line"># 热点key分析</span><br><span class="line">redis-cli --hotkeys</span><br><span class="line"></span><br><span class="line"># 延迟监控</span><br><span class="line">LATENCY HISTORY command</span><br><span class="line">CONFIG SET latency-monitor-threshold 100</span><br></pre></td></tr></table></figure><h2 id="特殊应用场景"><a href="#特殊应用场景" class="headerlink" title="特殊应用场景"></a>特殊应用场景</h2><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p><strong>固定窗口限流</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class RedisRateLimiter &#123;</span><br><span class="line">    public boolean isAllowed(String key, int limit, int window) &#123;</span><br><span class="line">        long current = System.currentTimeMillis() / 1000 / window;</span><br><span class="line">        String windowKey = key + &quot;:&quot; + current;</span><br><span class="line">        </span><br><span class="line">        String script = </span><br><span class="line">            &quot;local count = redis.call(&#x27;incr&#x27;, KEYS[1]) &quot; +</span><br><span class="line">            &quot;if count == 1 then &quot; +</span><br><span class="line">            &quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[1]) &quot; +</span><br><span class="line">            &quot;end &quot; +</span><br><span class="line">            &quot;return count&quot;;</span><br><span class="line">            </span><br><span class="line">        Long count = (Long) jedis.eval(script, Arrays.asList(windowKey), </span><br><span class="line">                                      Arrays.asList(String.valueOf(window)));</span><br><span class="line">        </span><br><span class="line">        return count &lt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滑动窗口限流</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean slidingWindowLimit(String key, int limit, int window) &#123;</span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line">    long windowStart = now - window * 1000;</span><br><span class="line">    </span><br><span class="line">    String script = </span><br><span class="line">        &quot;redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">        &quot;local count = redis.call(&#x27;zcard&#x27;, KEYS[1]) &quot; +</span><br><span class="line">        &quot;if count &lt; tonumber(ARGV[2]) then &quot; +</span><br><span class="line">        &quot;  redis.call(&#x27;zadd&#x27;, KEYS[1], ARGV[3], ARGV[3]) &quot; +</span><br><span class="line">        &quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[4]) &quot; +</span><br><span class="line">        &quot;  return 1 &quot; +</span><br><span class="line">        &quot;else &quot; +</span><br><span class="line">        &quot;  return 0 &quot; +</span><br><span class="line">        &quot;end&quot;;</span><br><span class="line">    </span><br><span class="line">    Long result = (Long) jedis.eval(script, Arrays.asList(key),</span><br><span class="line">        Arrays.asList(String.valueOf(windowStart), String.valueOf(limit),</span><br><span class="line">                     String.valueOf(now), String.valueOf(window)));</span><br><span class="line">    </span><br><span class="line">    return result == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisSessionManager &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    public void createSession(String sessionId, String userId, int timeout) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        Map&lt;String, Object&gt; sessionData = new HashMap&lt;&gt;();</span><br><span class="line">        sessionData.put(&quot;userId&quot;, userId);</span><br><span class="line">        sessionData.put(&quot;createTime&quot;, System.currentTimeMillis());</span><br><span class="line">        </span><br><span class="line">        redisTemplate.opsForHash().putAll(key, sessionData);</span><br><span class="line">        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean isValidSession(String sessionId) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        return redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void renewSession(String sessionId, int timeout) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        if (redisTemplate.hasKey(key)) &#123;</span><br><span class="line">            redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息队列实现"><a href="#消息队列实现" class="headerlink" title="消息队列实现"></a>消息队列实现</h3><p><strong>基于List的简单队列</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class RedisQueue &#123;</span><br><span class="line">    // 生产者</span><br><span class="line">    public void produce(String queue, String message) &#123;</span><br><span class="line">        jedis.lpush(queue, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 消费者（阻塞式）</span><br><span class="line">    public String consume(String queue, int timeout) &#123;</span><br><span class="line">        List&lt;String&gt; result = jedis.brpop(timeout, queue);</span><br><span class="line">        return result != null ? result.get(1) : null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于Stream的消息队列</strong>（Redis 5.0+）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 生产消息</span><br><span class="line">XADD mystream * field1 value1 field2 value2</span><br><span class="line"></span><br><span class="line"># 创建消费者组</span><br><span class="line">XGROUP CREATE mystream mygroup $ MKSTREAM</span><br><span class="line"></span><br><span class="line"># 消费消息</span><br><span class="line">XREADGROUP GROUP mygroup consumer1 COUNT 10 STREAMS mystream &gt;</span><br><span class="line"></span><br><span class="line"># 确认消息</span><br><span class="line">XACK mystream mygroup message_id</span><br></pre></td></tr></table></figure><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class RedisDelayQueue &#123;</span><br><span class="line">    </span><br><span class="line">    public void addDelayTask(String task, long delayTime) &#123;</span><br><span class="line">        long executeTime = System.currentTimeMillis() + delayTime;</span><br><span class="line">        jedis.zadd(&quot;delay_queue&quot;, executeTime, task);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public List&lt;String&gt; getReadyTasks() &#123;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        Set&lt;String&gt; tasks = jedis.zrangeByScore(&quot;delay_queue&quot;, 0, now);</span><br><span class="line">        </span><br><span class="line">        if (!tasks.isEmpty()) &#123;</span><br><span class="line">            // 原子性删除已获取的任务</span><br><span class="line">            String script = </span><br><span class="line">                &quot;local tasks = redis.call(&#x27;zrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">                &quot;if #tasks &gt; 0 then &quot; +</span><br><span class="line">                &quot;  redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">                &quot;end &quot; +</span><br><span class="line">                &quot;return tasks&quot;;</span><br><span class="line">            </span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            List&lt;String&gt; result = (List&lt;String&gt;) jedis.eval(script, </span><br><span class="line">                Arrays.asList(&quot;delay_queue&quot;), Arrays.asList(String.valueOf(now)));</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能调优技巧"><a href="#性能调优技巧" class="headerlink" title="性能调优技巧"></a>性能调优技巧</h2><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p><strong>使用Hash存储小对象</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 不推荐：为每个用户字段单独设置key</span><br><span class="line">jedis.set(&quot;user:1001:name&quot;, &quot;张三&quot;);</span><br><span class="line">jedis.set(&quot;user:1001:age&quot;, &quot;25&quot;);</span><br><span class="line">jedis.set(&quot;user:1001:email&quot;, &quot;zhang@example.com&quot;);</span><br><span class="line"></span><br><span class="line">// 推荐：使用Hash存储</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;name&quot;, &quot;张三&quot;);</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;age&quot;, &quot;25&quot;);</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;email&quot;, &quot;zhang@example.com&quot;);</span><br></pre></td></tr></table></figure><p><strong>合理设置过期时间</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 避免同时过期导致雪崩</span><br><span class="line">int baseExpire = 3600;  // 1小时</span><br><span class="line">int randomExpire = baseExpire + new Random().nextInt(300);  // 增加0-5分钟随机时间</span><br><span class="line">jedis.setex(key, randomExpire, value);</span><br></pre></td></tr></table></figure><h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p><strong>批量操作优化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用Pipeline</span><br><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    pipeline.set(&quot;key&quot; + i, &quot;value&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">pipeline.sync();</span><br><span class="line"></span><br><span class="line">// 或使用原生批量命令</span><br><span class="line">Map&lt;String, String&gt; batch = new HashMap&lt;&gt;();</span><br><span class="line">// ... 填充数据</span><br><span class="line">jedis.mset(flattenMap(batch));</span><br></pre></td></tr></table></figure><h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p><strong>Lua脚本减少网络往返</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 原子性增加库存</span><br><span class="line">local current = redis.call(&#x27;get&#x27;, KEYS[1])</span><br><span class="line">if current == false then</span><br><span class="line">    return -1  -- key不存在</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">current = tonumber(current)</span><br><span class="line">if current &gt;= tonumber(ARGV[1]) then</span><br><span class="line">    redis.call(&#x27;decrby&#x27;, KEYS[1], ARGV[1])</span><br><span class="line">    return current - tonumber(ARGV[1])</span><br><span class="line">else</span><br><span class="line">    return -2  -- 库存不足</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>你好，我很乐意为你详细讲解 Redis。</p><p>Redis 是一个开源的、基于内存的、高性能的键值存储系统。它通常被用作数据库、缓存和消息中间件。Redis 支持多种数据结构，如字符串、哈希、列表、集合和有序集合，这使得它在各种应用场景中都非常灵活。</p><h3 id="Redis-的核心特点"><a href="#Redis-的核心特点" class="headerlink" title="Redis 的核心特点"></a>Redis 的核心特点</h3><hr><ul><li><strong>高性能</strong>: Redis 的所有数据都存储在内存中，因此读写速度非常快。通常，单个 Redis 实例每秒能处理超过 10 万次读写操作。</li><li><strong>丰富的数据结构</strong>: Redis 不仅仅是简单的键值存储，它支持多种复杂的数据结构，这让它能满足更广泛的应用需求。</li><li><strong>持久化</strong>: 虽然 Redis 是基于内存的，但它提供了两种不同的持久化方式，可以将数据从内存中保存到磁盘上，以防止服务器重启后数据丢失。</li><li><strong>原子性</strong>: Redis 的所有操作都是原子性的。这意味着一个命令要么完全执行，要么根本不执行，中间不会被打断，这在多客户端并发访问时尤其重要。</li><li><strong>主从复制</strong>: Redis 支持主从复制，可以将数据从一个主节点（Master）同步到一个或多个从节点（Slave），从而实现数据的备份和读写分离，提高系统的可用性和扩展性。</li><li><strong>高可用性与集群</strong>: Redis 提供了 Sentinel（哨兵）和 Cluster（集群）两种方案，来保证系统的高可用性和扩展性。</li></ul><h3 id="Redis-的数据结构详解"><a href="#Redis-的数据结构详解" class="headerlink" title="Redis 的数据结构详解"></a>Redis 的数据结构详解</h3><hr><p>这是 Redis 最有特色的地方，理解这些数据结构是掌握 Redis 的关键。</p><h4 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1. String (字符串)"></a>1. String (字符串)</h4><ul><li><strong>最基本的数据结构</strong>，可以存储任何类型的数据，比如字符串、数字或二进制数据。一个键最多可以存储 512MB 的值。</li><li><strong>常用命令</strong>:<ul><li><code>SET key value</code>: 设置键值对。</li><li><code>GET key</code>: 获取键对应的值。</li><li><code>INCR key</code>: 将键对应的值加 1，常用于计数器。</li><li><code>MSET key1 value1 key2 value2</code>: 同时设置多个键值对。</li><li><code>MGET key1 key2</code>: 同时获取多个键的值。</li></ul></li><li><strong>应用场景</strong>: 缓存、计数器、分布式锁等。</li></ul><h4 id="2-Hash-哈希"><a href="#2-Hash-哈希" class="headerlink" title="2. Hash (哈希)"></a>2. Hash (哈希)</h4><ul><li><strong>类似于一个键值对的集合</strong>。一个哈希键可以存储多个字段（field）和对应的值（value），非常适合存储对象。</li><li><strong>常用命令</strong>:<ul><li><code>HSET key field value</code>: 设置哈希键中一个字段的值。</li><li><code>HGET key field</code>: 获取哈希键中一个字段的值。</li><li><code>HGETALL key</code>: 获取哈希键中所有的字段和值。</li><li><code>HMSET key field1 value1 field2 value2</code>: 同时设置多个字段。</li><li><code>HDEL key field1 field2</code>: 删除一个或多个字段。</li></ul></li><li><strong>应用场景</strong>: 存储用户信息（如<code>user:100</code>作为键，<code>name</code>、<code>age</code>、<code>city</code>作为字段），商品信息等。</li></ul><h4 id="3-List-列表"><a href="#3-List-列表" class="headerlink" title="3. List (列表)"></a>3. List (列表)</h4><ul><li><strong>一个有序的、可以重复的字符串集合</strong>。可以从列表的头部或尾部添加或删除元素。</li><li><strong>常用命令</strong>:<ul><li><code>LPUSH key value1 value2</code>: 从列表的头部插入一个或多个值。</li><li><code>RPUSH key value1 value2</code>: 从列表的尾部插入一个或多个值。</li><li><code>LPOP key</code>: 从列表的头部移除并返回一个值。</li><li><code>RPOP key</code>: 从列表的尾部移除并返回一个值。</li><li><code>LRANGE key start stop</code>: 获取列表中指定范围的元素。</li></ul></li><li><strong>应用场景</strong>: 消息队列（队列、栈）、最新文章列表、历史记录等。</li></ul><h4 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4. Set (集合)"></a>4. Set (集合)</h4><ul><li><strong>一个无序的、不重复的字符串集合</strong>。集合提供了交集、并集和差集等操作。</li><li><strong>常用命令</strong>:<ul><li><code>SADD key member1 member2</code>: 向集合中添加一个或多个成员。</li><li><code>SMEMBERS key</code>: 获取集合中的所有成员。</li><li><code>SISMEMBER key member</code>: 判断一个成员是否在集合中。</li><li><code>SINTER key1 key2</code>: 求两个集合的交集。</li><li><code>SUNION key1 key2</code>: 求两个集合的并集。</li></ul></li><li><strong>应用场景</strong>: 社交网络中的共同好友、标签系统、去重等。</li></ul><h4 id="5-Sorted-Set-有序集合"><a href="#5-Sorted-Set-有序集合" class="headerlink" title="5. Sorted Set (有序集合)"></a>5. Sorted Set (有序集合)</h4><ul><li><strong>和集合类似，但每个成员都会关联一个分数（score）</strong>。通过这个分数，可以对集合中的成员进行排序。分数可以重复，但成员必须唯一。</li><li><strong>常用命令</strong>:<ul><li><code>ZADD key score1 member1 score2 member2</code>: 向有序集合中添加一个或多个带分数的成员。</li><li><code>ZRANGE key start stop</code>: 按分数从小到大排序，获取指定范围的成员。</li><li><code>ZREVRANGE key start stop</code>: 按分数从大到小排序，获取指定范围的成员。</li><li><code>ZSCORE key member</code>: 获取一个成员的分数。</li><li><code>ZINCRBY key increment member</code>: 给指定成员的分数增加指定值。</li></ul></li><li><strong>应用场景</strong>: 排行榜（游戏分数、热点新闻）、带权重的任务队列等。</li></ul><h3 id="Redis-的持久化机制"><a href="#Redis-的持久化机制" class="headerlink" title="Redis 的持久化机制"></a>Redis 的持久化机制</h3><hr><p>Redis 提供了两种持久化方式，可以将数据从内存保存到硬盘，确保数据不会因为服务重启而丢失。</p><h4 id="1-RDB-Redis-Database"><a href="#1-RDB-Redis-Database" class="headerlink" title="1. RDB (Redis Database)"></a>1. RDB (Redis Database)</h4><ul><li><strong>快照方式</strong>。它会在指定的时间间隔内，将内存中的数据快照写入到磁盘上一个二进制文件中（<code>dump.rdb</code>）。</li><li><strong>优点</strong>: RDB 文件是一个非常紧凑的二进制文件，非常适合备份和灾难恢复。</li><li><strong>缺点</strong>: 每次保存都会丢失从上次快照到现在之间的数据。</li></ul><h4 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2. AOF (Append Only File)"></a>2. AOF (Append Only File)</h4><ul><li><strong>日志方式</strong>。它会记录每一次对 Redis 数据库的写操作命令，并以追加（append）的方式写入到文件中。当 Redis 重启时，会重新执行 AOF 文件中的命令来恢复数据。</li><li><strong>优点</strong>: 数据丢失风险低，可以配置为每秒同步一次，或者每执行一个命令就同步一次。</li><li><strong>缺点</strong>: AOF 文件通常比 RDB 文件大，且恢复速度可能较慢。</li></ul><p>在实际应用中，通常会<strong>同时使用 RDB 和 AOF</strong>，以获得更高的可靠性。</p><h3 id="Redis-的高可用性"><a href="#Redis-的高可用性" class="headerlink" title="Redis 的高可用性"></a>Redis 的高可用性</h3><hr><h4 id="1-主从复制-Replication"><a href="#1-主从复制-Replication" class="headerlink" title="1. 主从复制 (Replication)"></a>1. 主从复制 (Replication)</h4><ul><li><strong>基本原理</strong>: 将一个 Redis 实例（主节点）的数据复制到一个或多个其他实例（从节点）。从节点的数据是主节点的完整副本。</li><li><strong>作用</strong>:<ul><li><strong>数据备份</strong>: 从节点可以作为数据的热备份。</li><li><strong>读写分离</strong>: 大多数读操作可以分流到从节点上，减轻主节点的压力。</li></ul></li></ul><h4 id="2-Sentinel-哨兵"><a href="#2-Sentinel-哨兵" class="headerlink" title="2. Sentinel (哨兵)"></a>2. Sentinel (哨兵)</h4><ul><li><strong>作用</strong>: 自动化管理主从复制集群。它是一个监控系统，可以监控主节点和从节点是否正常运行。</li><li><strong>核心功能</strong>:<ul><li><strong>监控</strong>: 不断检查主从节点是否正常工作。</li><li><strong>通知</strong>: 当某个 Redis 实例出现问题时，会发送通知。</li><li><strong>故障转移</strong>: 如果主节点发生故障，Sentinel 会自动从剩下的从节点中选举一个新的主节点，并让其他从节点切换到这个新的主节点上，从而实现高可用。</li></ul></li></ul><h4 id="3-Redis-Cluster-集群"><a href="#3-Redis-Cluster-集群" class="headerlink" title="3. Redis Cluster (集群)"></a>3. Redis Cluster (集群)</h4><ul><li><strong>作用</strong>: 解决 Redis 单机内存容量和并发量的瓶颈问题。它将数据分散到多个节点上，每个节点只负责存储部分数据。</li><li><strong>核心功能</strong>:<ul><li><strong>数据分片</strong>: 自动将数据分布在多个节点上。</li><li><strong>高可用性</strong>: 即使部分节点宕机，集群也能继续正常工作。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 分布式微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写答案</title>
      <link href="/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/"/>
      <url>/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="1-实现单例模式-Singleton-Pattern"><a href="#1-实现单例模式-Singleton-Pattern" class="headerlink" title="1.实现单例模式 (Singleton Pattern)"></a>1.实现单例模式 (Singleton Pattern)</h3><h4 id="懒汉式："><a href="#懒汉式：" class="headerlink" title="懒汉式："></a>懒汉式：</h4><p>使用<strong>双重检查锁定 (DCL)</strong> 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有化构造器，防止外部直接 new 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供一个全局访问点，使用 DCL 确保线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查：如果实例已经存在，直接返回，避免不必要的同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一次检查失败，进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查：在同步块内部再次检查，防止多个线程同时通过第一次检查，</span></span><br><span class="line">                <span class="comment">// 导致创建多个实例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建实例</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个线程安全的懒汉式单例模式实例。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="饿汉式："><a href="#饿汉式：" class="headerlink" title="饿汉式："></a>饿汉式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonEager</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 在类加载时就创建静态实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonEager</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonEager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有化构造器，防止外部直接创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonEager</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供一个公共的静态方法来获取唯一实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonEager <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个线程安全的饿汉式单例模式实例。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-继承与多态-Inheritance-and-Polymorphism"><a href="#2-继承与多态-Inheritance-and-Polymorphism" class="headerlink" title="2.继承与多态 (Inheritance and Polymorphism)"></a>2.继承与多态 (Inheritance and Polymorphism)</h3><p>设计一个 <code>Animal</code> 抽象类，并创建 <code>Dog</code> 和 <code>Cat</code> 类来展示继承和多态。&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Animal 抽象类，定义通用行为</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Dog 类继承 Animal，并重写 eat() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗正在吃骨头。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Cat 类继承 Animal，并重写 eat() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫正在吃鱼。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 展示多态的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PolymorphismDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showPolymorphism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 父类引用指向子类对象，这就是多态</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用相同的方法，但由于指向不同的子类实例，执行不同的行为</span></span><br><span class="line">        myDog.eat(); <span class="comment">// 输出: 狗正在吃骨头。</span></span><br><span class="line">        myCat.eat(); <span class="comment">// 输出: 猫正在吃鱼。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="equals-和-hashCode"><a href="#equals-和-hashCode" class="headerlink" title="equals() 和 hashCode()"></a><code>equals()</code> 和 <code>hashCode()</code></h3><p>编写 <code>Student</code> 类，并重写 <code>equals()</code> 和 <code>hashCode()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 equals() 方法，根据 id 和 name 判断两个 Student 对象是否相等</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 检查是否为同一个对象的引用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 2. 检查对象是否为 null 或类型是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 3. 类型转换</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="comment">// 4. 比较关键字段 (id 和 name)</span></span><br><span class="line">        <span class="keyword">return</span> id == student.id &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 hashCode() 方法，为相等的对象生成相同的哈希码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Objects.hash() 方法生成哈希码，它会为多个字段生成一个组合哈希值</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 为什么需要两者一起重写？</span></span><br><span class="line"><span class="comment">* 1. 它们之间存在约定：如果两个对象通过 equals() 方法比较是相等的，那么它们的 hashCode() 方法返回的值也必须相等。</span></span><br><span class="line"><span class="comment">* 反之则不一定，不相等的对象可以有相同的哈希码（哈希冲突）。</span></span><br><span class="line"><span class="comment">* 2. 哈希表类（如 HashSet, HashMap）依赖于这个约定：当将对象存入哈希表时，</span></span><br><span class="line"><span class="comment">* 它会先调用 hashCode() 确定存储位置，再调用 equals() 来确认是否存在相同的对象。</span></span><br><span class="line"><span class="comment">* 3. 如果只重写 equals() 但不重写 hashCode()，可能导致两个逻辑上相等的对象被存储在不同的哈希位置，</span></span><br><span class="line"><span class="comment">* 从而无法正确查找和去重。例如，在 HashSet 中，即使两个 Student 对象 id 和 name 相同，</span></span><br><span class="line"><span class="comment">* 也会被认为是不同的对象而重复添加。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="接口与实现-Interfaces-and-Implementation"><a href="#接口与实现-Interfaces-and-Implementation" class="headerlink" title="接口与实现 (Interfaces and Implementation)"></a>接口与实现 (Interfaces and Implementation)</h3><p>设计 <code>Drawable</code> 接口，并由 <code>Circle</code> 和 <code>Rectangle</code> 实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义 Drawable 接口，包含一个抽象方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Circle 类实现 Drawable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在画一个圆形。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Rectangle 类实现 Drawable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在画一个矩形。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="异常处理-Exception-Handling"><a href="#异常处理-Exception-Handling" class="headerlink" title="异常处理 (Exception Handling)"></a>异常处理 (Exception Handling)</h3><p>使用 <code>try-catch-finally</code> 结构处理 <code>FileNotFoundException</code> 并确保资源关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 在 try 块外部声明，以便在 finally 块中访问</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试打开文件</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已成功打开。&quot;</span>);</span><br><span class="line">            <span class="comment">// 假设这里进行文件读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件未找到异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;错误：指定的文件不存在！路径：&quot;</span> + filePath);</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印异常堆栈信息</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论是否发生异常，finally 块都会执行</span></span><br><span class="line">            <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 确保文件流被关闭，防止资源泄露</span></span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件流已在 finally 块中关闭。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;关闭文件流时发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a><code>try-with-resources</code></h3><p>使用 <code>try-with-resources</code> 重写上一个题目，展示其简化优势。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TryWithResourcesDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processFileWithResources</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">// try-with-resources 语句，自动管理实现了 AutoCloseable 接口的资源</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已成功打开。&quot;</span>);</span><br><span class="line">            <span class="comment">// 假设这里进行文件读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件未找到异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;错误：指定的文件不存在！路径：&quot;</span> + filePath);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件关闭时可能发生的异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;关闭文件流时发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不需要单独的 finally 块来关闭资源，JVM 会自动完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件流已在 try-with-resources 语句中自动关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* try-with-resources 的优势：</span></span><br><span class="line"><span class="comment">* 1. 简化代码：不再需要显式的 finally 块来关闭资源，代码更简洁。</span></span><br><span class="line"><span class="comment">* 2. 避免资源泄露：无论 try 块是否正常完成或抛出异常，资源都会被自动关闭，</span></span><br><span class="line"><span class="comment">* 有效防止了因忘记关闭资源而导致的内存和文件句柄泄露。</span></span><br><span class="line"><span class="comment">* 3. 更好的异常处理：如果 try 块和资源关闭时都抛出异常，try-with-resources 会</span></span><br><span class="line"><span class="comment">* 将资源关闭时抛出的异常作为被抑制（suppressed）的异常，主异常保持不变，</span></span><br><span class="line"><span class="comment">* 便于调试。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 (Bubble Sort)"></a>冒泡排序 (Bubble Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortingAlgorithms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">// 外层循环控制比较轮数，共进行 n-1 轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 优化：如果在某一轮没有发生交换，说明数组已经有序</span></span><br><span class="line">            <span class="comment">// 内层循环负责每轮比较和交换，将最大元素“冒”到数组末尾</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换元素</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    swapped = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果没有发生交换，提前结束排序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortingAlgorithms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 找到基准元素的正确位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">            <span class="comment">// 递归地对左子数组进行排序</span></span><br><span class="line">            quickSort(arr, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归地对右子数组进行排序</span></span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择最右边的元素作为基准</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (low - <span class="number">1</span>); <span class="comment">// i 指向小于等于基准的元素的最后一个位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素小于等于基准</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 交换 arr[i] 和 arr[j]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基准元素放到正确的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i + <span class="number">1</span>];</span><br><span class="line">        arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">        arr[high] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二分查找-Binary-Search"><a href="#二分查找-Binary-Search" class="headerlink" title="二分查找 (Binary Search)"></a>二分查找 (Binary Search)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchAlgorithms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止整数溢出</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// 找到目标，返回索引</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 目标在右半部分，更新左边界</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 目标在左半部分，更新右边界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 没有找到目标</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="链表反转-Reverse-Linked-List"><a href="#链表反转-Reverse-Linked-List" class="headerlink" title="链表反转 (Reverse Linked List)"></a>链表反转 (Reverse Linked List)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 前一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head; <span class="comment">// 当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextTemp</span> <span class="operator">=</span> current.next; <span class="comment">// 暂存下一个节点</span></span><br><span class="line">            current.next = prev; <span class="comment">// 将当前节点的指针指向前一个节点</span></span><br><span class="line">            prev = current; <span class="comment">// 前一个节点向前移动</span></span><br><span class="line">            current = nextTemp; <span class="comment">// 当前节点向前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev; <span class="comment">// prev 最终会是新的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="链表中间节点-Middle-of-Linked-List"><a href="#链表中间节点-Middle-of-Linked-List" class="headerlink" title="链表中间节点 (Middle of Linked List)"></a>链表中间节点 (Middle of Linked List)</h3><p>使用<strong>快慢指针</strong>，快指针每次走两步，慢指针每次走一步。当快指针到达链表末尾时，慢指针正好在中间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findMiddleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head; <span class="comment">// 慢指针，每次走一步</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head; <span class="comment">// 快指针，每次走两步</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当快指针到达末尾时，慢指针正好在中间</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="移除重复元素-Remove-Duplicates"><a href="#移除重复元素-Remove-Duplicates" class="headerlink" title="移除重复元素 (Remove Duplicates)"></a>移除重复元素 (Remove Duplicates)</h3><p>不使用 <code>Set</code>，通过双层循环或排序后遍历实现。这里使用排序后遍历的方法，因为它更高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeDuplicates</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span> || list.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(list); <span class="comment">// 先排序，使得重复元素相邻</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 倒序遍历，移除重复元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).equals(list.get(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                list.remove(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串反转-Reverse-String"><a href="#字符串反转-Reverse-String" class="headerlink" title="字符串反转 (Reverse String)"></a>字符串反转 (Reverse String)</h3><p>不使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 的 <code>reverse()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> charArray.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 交换首尾字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> charArray[left];</span><br><span class="line">            charArray[left] = charArray[right];</span><br><span class="line">            charArray[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="回文字符串-Palindrome-String"><a href="#回文字符串-Palindrome-String" class="headerlink" title="回文字符串 (Palindrome String)"></a>回文字符串 (Palindrome String)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将字符串转换为小写并移除非字母数字字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cleanedStr</span> <span class="operator">=</span> str.toLowerCase().replaceAll(<span class="string">&quot;[^a-z0-9]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> cleanedStr.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cleanedStr.charAt(left) != cleanedStr.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="计算阶乘-Factorial-Calculation"><a href="#计算阶乘-Factorial-Calculation" class="headerlink" title="计算阶乘 (Factorial Calculation)"></a>计算阶乘 (Factorial Calculation)</h3><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">factorialRecursive</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Factorial is not defined for negative numbers.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * factorialRecursive(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MathProblems &#123;</span><br><span class="line">    public static long factorialIterative(int n) &#123;</span><br><span class="line">        if (n &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Factorial is not defined for negative numbers.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        long result = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            result *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="斐波那契数列-Fibonacci-Sequence"><a href="#斐波那契数列-Fibonacci-Sequence" class="headerlink" title="斐波那契数列 (Fibonacci Sequence)"></a>斐波那契数列 (Fibonacci Sequence)</h3><h4 id="递归方式-1"><a href="#递归方式-1" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fibonacciRecursive</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid input for Fibonacci sequence.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibonacciRecursive(n - <span class="number">1</span>) + fibonacciRecursive(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方式-1"><a href="#非递归方式-1" class="headerlink" title="非递归方式"></a>非递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fibonacciIterative</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid input for Fibonacci sequence.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串中字符计数-Character-Count"><a href="#字符串中字符计数-Character-Count" class="headerlink" title="字符串中字符计数 (Character Count)"></a>字符串中字符计数 (Character Count)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Character, Integer&gt; <span class="title function_">countCharacters</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; charCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> charCountMap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            charCountMap.put(c, charCountMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> charCountMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="两数之和-Two-Sum"><a href="#两数之和-Two-Sum" class="headerlink" title="两数之和 (Two Sum)"></a>两数之和 (Two Sum)</h3><p>使用 <code>HashMap</code> 将值和索引存储起来，实现一次遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; numMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (numMap.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;numMap.get(complement), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            numMap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;; <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数组中最大-小值-Max-Min-in-Array"><a href="#数组中最大-小值-Max-Min-in-Array" class="headerlink" title="数组中最大&#x2F;小值 (Max&#x2F;Min in Array)"></a>数组中最大&#x2F;小值 (Max&#x2F;Min in Array)</h3><p>一次遍历找到最大值和最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findMaxMin(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Array cannot be null or empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;max, min&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="质数判断-Prime-Number"><a href="#质数判断-Prime-Number" class="headerlink" title="质数判断 (Prime Number)"></a>质数判断 (Prime Number)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1 和更小的数都不是质数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只需要检查到 n 的平方根</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="集合交集-List-Intersection"><a href="#集合交集-List-Intersection" class="headerlink" title="集合交集 (List Intersection)"></a>集合交集 (List Intersection)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">intersection</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span> &#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">null</span> || list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历第一个列表，检查元素是否在第二个列表中</span></span><br><span class="line">        <span class="keyword">for</span> (T element : list1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list2.contains(element) &amp;&amp; !result.contains(element)) &#123;</span><br><span class="line">                result.add(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数组合并-Merge-Sorted-Arrays"><a href="#数组合并-Merge-Sorted-Arrays" class="headerlink" title="数组合并 (Merge Sorted Arrays)"></a>数组合并 (Merge Sorted Arrays)</h3><p>将两个已排序的数组合并为一个新的已排序数组，使用<strong>双指针</strong>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeSortedArrays(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="type">int</span>[] merged = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length + arr2.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] &lt; arr2[j]) &#123;</span><br><span class="line">                merged[k++] = arr1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged[k++] = arr2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr1.length) &#123;</span><br><span class="line">            merged[k++] = arr1[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; arr2.length) &#123;</span><br><span class="line">            merged[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="判断回文数-Palindrome-Number"><a href="#判断回文数-Palindrome-Number" class="headerlink" title="判断回文数 (Palindrome Number)"></a>判断回文数 (Palindrome Number)</h3><p>不使用 <code>String</code> 转换，通过数学方法反转一半数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindromeNumber</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 负数和以 0 结尾的非 0 数字都不是回文</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">reversedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; reversedNumber) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lastDigit</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">            reversedNumber = reversedNumber * <span class="number">10</span> + lastDigit;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偶数位数字时，x 等于 reversedNumber</span></span><br><span class="line">        <span class="comment">// 奇数位数字时，x 等于 reversedNumber 除以 10</span></span><br><span class="line">        <span class="keyword">return</span> x == reversedNumber || x == reversedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="罗马数字转整数-Roman-to-Integer"><a href="#罗马数字转整数-Roman-to-Integer" class="headerlink" title="罗马数字转整数 (Roman to Integer)"></a>罗马数字转整数 (Roman to Integer)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; romanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        romanMap.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentVal</span> <span class="operator">=</span> romanMap.get(s.charAt(i));</span><br><span class="line">            <span class="comment">// 如果当前字符的值小于下一个字符的值，则需要减去当前值</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; s.length() - <span class="number">1</span> &amp;&amp; currentVal &lt; romanMap.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                result -= currentVal;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += currentVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="爬楼梯-Climbing-Stairs"><a href="#爬楼梯-Climbing-Stairs" class="headerlink" title="爬楼梯 (Climbing Stairs)"></a>爬楼梯 (Climbing Stairs)</h3><p>这是经典的<strong>动态规划</strong>问题。</p><h4 id="动态规划方式-非递归"><a href="#动态规划方式-非递归" class="headerlink" title="动态规划方式 (非递归)"></a>动态规划方式 (非递归)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 爬 1 级台阶，有 1 种方法</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>; <span class="comment">// 爬 2 级台阶，有 2 种方法 (1+1, 2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 到达第 i 级台阶的方法数 = (从 i-1 级爬 1 级的方法数) + (从 i-2 级爬 2 级的方法数)</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，以下是基于  语言的线程基础与同步的实现，并附带详细注释。</p><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><h4 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1. 继承 Thread 类"></a>1. 继承 <code>Thread</code> 类</h4><p>通过继承 <code>java.lang.Thread</code> 类并重写其 <code>run()</code> 方法来创建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承 Thread 类创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用继承 Thread 类的方式创建的线程正在运行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现-Runnable-接口"><a href="#2-实现-Runnable-接口" class="headerlink" title="2. 实现 Runnable 接口"></a>2. 实现 <code>Runnable</code> 接口</h4><p>通过实现 <code>java.lang.Runnable</code> 接口并将其作为参数传递给 <code>Thread</code> 类的构造函数来创建线程。这种方式更灵活，推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Runnable 接口创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用实现 Runnable 接口的方式创建的线程正在运行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep() 与 yield()"></a><code>sleep()</code> 与 <code>yield()</code></h3><p><code>sleep()</code> 和 <code>yield()</code> 都是线程调度的方法，但它们的作用和效果不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepYieldDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 sleep() 的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// sleep() 使线程暂停指定时间，进入 WAITING 状态，但不会释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程 A: 准备睡眠 2 秒...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 A: 睡眠结束，继续执行。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 yield() 的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 B: 开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 B: 正在执行 &quot;</span> + i);</span><br><span class="line">                <span class="comment">// yield() 提示线程调度器让出 CPU 时间，但不保证一定生效</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 B: 执行完毕。&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>sleep()</strong>: 使当前线程<strong>暂停执行指定的时间</strong>，进入 <strong>TIMED_WAITING</strong> 状态。它会<strong>释放 CPU 资源</strong>，但<strong>不释放锁</strong>。</li><li><strong>yield()</strong>: 提示线程调度器，当前线程愿意<strong>让出当前 CPU 时间片</strong>。线程会从 <strong>RUNNING</strong> 状态转换为 <strong>RUNNABLE</strong> 状态，与其他线程竞争 CPU，但<strong>不保证</strong>其他线程能立即获得执行。它主要用于优化线程调度，通常在多线程程序中<strong>不应依赖</strong>其行为来保证正确性。</li></ul><hr><h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join() 方法"></a><code>join()</code> 方法</h3><p><code>join()</code> 方法允许一个线程等待另一个线程执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JoinDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程: 正在执行...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;子线程: 执行完毕。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        workerThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 等待子线程执行完毕...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用 join() 方法，主线程进入等待状态，直到 workerThread 执行完毕</span></span><br><span class="line">        workerThread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 子线程已执行完毕，主线程继续执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="非线程安全计数器"><a href="#非线程安全计数器" class="headerlink" title="非线程安全计数器"></a>非线程安全计数器</h3><p>在多线程环境下，多个线程同时对共享资源进行读写操作，可能导致数据不一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 这一行代码并非原子操作，它包含三个步骤：读、加 1、写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafetyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">UnsafeCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsafeCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果不一定是 100 * 10000 = 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;非线程安全计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><code>synchronized</code> 关键字</h3><p>使用 <code>synchronized</code> 关键字可以保证同一时刻只有一个线程访问共享资源，从而解决线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 关键字修饰方法，锁住整个对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SynchronizedCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果为 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="synchronized-块与方法"><a href="#synchronized-块与方法" class="headerlink" title="synchronized 块与方法"></a><code>synchronized</code> 块与方法</h3><ul><li><strong>synchronized 方法</strong>: 锁定的是当前对象实例 (<code>this</code>)。</li><li><strong>synchronized 块</strong>: 提供了更细粒度的控制，可以指定锁定的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedBlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized 方法，锁定当前对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synchronizedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入 synchronized 方法。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 离开 synchronized 方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized 块，锁定指定的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedBlock1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取 lock1...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已获取 lock1。&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放 lock1。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedBlock2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取 lock2...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已获取 lock2。&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放 lock2。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 区别与适用场景:</span></span><br><span class="line"><span class="comment"> * - synchronized 方法: 简单易用，但锁定范围大，可能导致性能问题。当需要同步整个方法时使用。</span></span><br><span class="line"><span class="comment"> * - synchronized 块: 锁定范围小，可以只同步需要保护的代码段，提高并发性能。当只需要同步部分代码时使用。</span></span><br><span class="line"><span class="comment"> * 同时，可以通过锁定不同的对象来避免不必要的阻塞，实现更高的并发度。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><code>volatile</code> 关键字</h3><p><code>volatile</code> 关键字保证了变量在多线程间的<strong>可见性</strong>，但不保证<strong>原子性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">    <span class="comment">// volatile 保证所有线程看到的是该变量的最新值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 正在等待标志位变为 true。&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="comment">// 空循环，等待 ready 变为 true</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 标志位已变为 true，循环结束。&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 确保线程 A 先运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 正在将标志位设置为 true。&quot;</span>);</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为什么 volatile 不能保证原子性?</span></span><br><span class="line"><span class="comment"> * - 原子性是指一个操作是不可中断的，要么全部执行，要么都不执行。</span></span><br><span class="line"><span class="comment"> * - volatile 只能保证变量的读写操作是原子的，但像 `count++` 这样的复合操作（读、加、写）</span></span><br><span class="line"><span class="comment"> * 依然不是原子的。多个线程可能同时读到旧值，导致最终结果不正确。</span></span><br><span class="line"><span class="comment"> * - volatile 主要用于一写多读的场景，或者用于控制线程执行流程的标志位。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a><code>AtomicInteger</code></h3><p><code>AtomicInteger</code> 是一个原子类，它使用 CAS (Compare-and-Swap) 机制来保证操作的原子性，从而实现线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 AtomicInteger 替代 int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet(); <span class="comment">// 这是一个原子操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果为 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicInteger 计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>使用 <code>wait()</code> 和 <code>notifyAll()</code> 实现两个线程交替打印奇数和偶数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintNumbers</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOdd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果是偶数，则等待</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEven</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count % <span class="number">2</span> != <span class="number">0</span>) &#123; <span class="comment">// 如果是奇数，则等待</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNumbers</span> <span class="variable">pn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumbers</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">oddThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(pn::printOdd, <span class="string">&quot;奇数线程&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">evenThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(pn::printEven, <span class="string">&quot;偶数线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        oddThread.start();</span><br><span class="line">        evenThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，以下是  中高级并发编程的实现，并附带详细注释。</p><h3 id="生产者-消费者模式-使用-wait-和-notifyAll"><a href="#生产者-消费者模式-使用-wait-和-notifyAll" class="headerlink" title="生产者-消费者模式 (使用 wait() 和 notifyAll())"></a>生产者-消费者模式 (使用 <code>wait()</code> 和 <code>notifyAll()</code>)</h3><p>这是一个经典的线程协作问题。生产者生产数据，放入共享队列；消费者从队列中取出数据进行消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerClassic</span> &#123;</span><br><span class="line">    <span class="comment">// 共享队列，使用 LinkedList 实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 队列最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 如果队列已满，生产者等待</span></span><br><span class="line">                <span class="keyword">while</span> (queue.size() == MAX_SIZE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列已满，生产者等待...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 生产数据并放入队列</span></span><br><span class="line">                queue.offer(i);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 唤醒所有等待的线程（包括消费者）</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟生产时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 如果队列为空，消费者等待</span></span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列为空，消费者等待...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 消费数据</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">                <span class="comment">// 唤醒所有等待的线程（包括生产者）</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">// 模拟消费时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="生产者-消费者模式-使用-BlockingQueue"><a href="#生产者-消费者模式-使用-BlockingQueue" class="headerlink" title="生产者-消费者模式 (使用 BlockingQueue)"></a>生产者-消费者模式 (使用 <code>BlockingQueue</code>)</h3><p><code>java.util.concurrent.BlockingQueue</code> 接口提供了线程安全的队列操作，简化了生产者-消费者模型的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerBlockingQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 BlockingQueue，它内部已经处理了线程同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// put() 方法在队列满时会自动阻塞</span></span><br><span class="line">            queue.put(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// take() 方法在队列空时会自动阻塞</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h3><p>使用 <code>ReentrantLock</code> 实现线程安全计数器，并解释其与 <code>synchronized</code> 的区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReentrantLockCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++; <span class="comment">// 在 try 块中执行需要同步的代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 在 finally 块中释放锁，确保锁总是被释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* ReentrantLock 与 synchronized 的区别:</span></span><br><span class="line"><span class="comment">* 1. 语法层面: `synchronized` 是 JVM 的内置关键字，而 `ReentrantLock` 是一个类。</span></span><br><span class="line"><span class="comment">* 2. 灵活性: `ReentrantLock` 提供了更灵活的锁定控制。例如，它支持公平锁（按请求顺序获取锁），</span></span><br><span class="line"><span class="comment">* 可以尝试非阻塞地获取锁（`tryLock()`），以及支持中断（`lockInterruptibly()`）。</span></span><br><span class="line"><span class="comment">* 3. 性能: 在早期版本中，`ReentrantLock` 通常性能更好。但随着  对 `synchronized` 优化（偏向锁、轻量级锁），</span></span><br><span class="line"><span class="comment">* 两者性能已非常接近。在简单场景下，`synchronized` 更简洁。</span></span><br><span class="line"><span class="comment">* 4. 协作: `ReentrantLock` 必须配合 `Condition` 接口才能实现线程间的等待/唤醒机制，而 `synchronized` 直接</span></span><br><span class="line"><span class="comment">* 使用 `Object` 的 `wait()` 和 `notify()`。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="ReentrantLock-与-Condition"><a href="#ReentrantLock-与-Condition" class="headerlink" title="ReentrantLock 与 Condition"></a><code>ReentrantLock</code> 与 <code>Condition</code></h3><p>使用 <code>ReentrantLock</code> 和 <code>Condition</code> 重新实现生产者-消费者模型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerCondition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 创建两个 Condition 实例，分别用于生产者和消费者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">producerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">consumerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == MAX_SIZE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列已满，生产者等待...&quot;</span>);</span><br><span class="line">                    producerCondition.await(); <span class="comment">// 生产者等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                consumerCondition.signalAll(); <span class="comment">// 唤醒所有消费者</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列为空，消费者等待...&quot;</span>);</span><br><span class="line">                    consumerCondition.await(); <span class="comment">// 消费者等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">                producerCondition.signalAll(); <span class="comment">// 唤醒所有生产者</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><code>ExecutorService</code></h3><p>创建一个固定大小的线程池，并向其提交多个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutorServiceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小为 3 的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 执行。&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池，不再接收新任务，已提交的任务会继续执行</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Callable-与-Future"><a href="#Callable-与-Future" class="headerlink" title="Callable 与 Future"></a><code>Callable</code> 与 <code>Future</code></h3><p>使用 <code>Callable</code> 提交任务，并使用 <code>Future</code> 获取返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 Callable 任务，它会返回一个字符串</span></span><br><span class="line">        Callable&lt;String&gt; task = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务开始执行...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;任务执行完毕，返回结果！&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务并获得 Future 对象</span></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(task);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 任务已提交，继续执行其他操作...&quot;</span>);</span><br><span class="line">        <span class="comment">// get() 方法会阻塞，直到任务完成并返回结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 获得任务结果 -&gt; &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h3><p><code>CountDownLatch</code> 允许一个或多个线程等待直到在其他线程中执行的一组操作完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">workerCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 计数器，当计数器减到 0 时，主线程会被唤醒</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(workerCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 开始执行任务...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">2000</span>)); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 任务完成。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown(); <span class="comment">// 任务完成后，计数器减 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 等待所有工作线程完成...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 阻塞主线程，直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 所有工作线程已完成，继续执行下一步。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code> 允许一组线程相互等待，直到所有线程都到达一个共同的屏障点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">partySize</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 当 3 个线程都到达屏障时，执行一个屏障动作</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(partySize, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n所有线程已到达屏障点！继续执行下一阶段。\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(partySize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; partySize; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在执行第一阶段任务...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 第一阶段任务完成，到达屏障。&quot;</span>);</span><br><span class="line">                    barrier.await(); <span class="comment">// 线程在此处等待</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在执行第二阶段任务...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h3><p><code>Semaphore</code>（信号量）用来控制对资源的并发访问数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 允许 3 个线程同时访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessResource</span><span class="params">(<span class="type">int</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 获取许可</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在访问资源...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟资源访问时间</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 访问资源完毕。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SemaphoreDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SemaphoreDemo</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; demo.accessResource(threadId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><h4 id="1-死锁演示"><a href="#1-死锁演示" class="headerlink" title="1. 死锁演示"></a>1. 死锁演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B: 已获得 lock2，尝试获取 lock1...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B: 已获得 lock1。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadA, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadB, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 死锁产生条件:</span></span><br><span class="line"><span class="comment">* 1. 互斥条件: 资源是独占的，一个线程在使用时，其他线程无法使用。</span></span><br><span class="line"><span class="comment">* 2. 请求与保持条件: 线程已经持有至少一个资源，但又请求其他资源，同时又保持对已有资源的占有。</span></span><br><span class="line"><span class="comment">* 3. 不可剥夺条件: 资源只能在持有它的线程完成任务后由它自己释放。</span></span><br><span class="line"><span class="comment">* 4. 循环等待条件: 存在一个线程资源的循环链，每个线程都在等待下一个线程所持有的资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>通过打破死锁的四个必要条件之一来预防死锁。这里通过<strong>资源有序分配</strong>来打破<strong>循环等待</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockPrevention</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 A 按顺序先获取 lock1，再获取 lock2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 B 也按顺序先获取 lock1，再获取 lock2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockPrevention</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockPrevention</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadA, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadB, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 两个线程都按相同的顺序获取锁，不会发生死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p><code>ThreadLocal</code> 为每个线程提供了一个独立的变量副本，实现了线程间的数据隔离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAndPrint</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置线程本地变量</span></span><br><span class="line">        threadLocal.set(value);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务</span></span><br><span class="line">            <span class="comment">// 获取并打印当前线程的变量值</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的变量值: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 最佳实践：使用完后移除，防止内存泄漏</span></span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 A 的数据&quot;</span>), <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 B 的数据&quot;</span>), <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 原理和作用:</span></span><br><span class="line"><span class="comment">* 原理: ThreadLocal 内部有一个 `ThreadLocalMap`，每个线程都有一个独立的 `ThreadLocalMap`。</span></span><br><span class="line"><span class="comment">* 当我们调用 `set()` 方法时，实际上是将值存储到了当前线程的 `ThreadLocalMap` 中，</span></span><br><span class="line"><span class="comment">* 键为 `ThreadLocal` 实例本身。</span></span><br><span class="line"><span class="comment">* 作用:</span></span><br><span class="line"><span class="comment">* 1. 数据隔离: 解决了多线程访问共享变量的线程安全问题，但其本质不是同步，而是通过“以空间换时间”的方式，</span></span><br><span class="line"><span class="comment">* 为每个线程提供独立副本，避免了竞争。</span></span><br><span class="line"><span class="comment">* 2. 传递参数: 在整个方法调用链中，无需层层传递参数，可以方便地在任何地方获取当前线程的上下文信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="线程安全单例-静态内部类"><a href="#线程安全单例-静态内部类" class="headerlink" title="线程安全单例 (静态内部类)"></a>线程安全单例 (静态内部类)</h3><p>静态内部类方式是实现线程安全的懒汉式单例的最佳实践之一。它利用了 JVM 类加载机制的线程安全特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonThreadSafe</span> &#123;</span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonThreadSafe</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类，它只在 SingletonThreadSafe 被首次调用时才会被加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 静态成员变量，在类加载时初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonThreadSafe</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonThreadSafe</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供全局访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonThreadSafe <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 优点:</span></span><br><span class="line"><span class="comment">* 1. 线程安全: 类的加载是线程安全的，因此 INSTANCE 的初始化是原子的。</span></span><br><span class="line"><span class="comment">* 2. 懒加载: 只有在调用 getInstance() 方法时，SingletonHolder 类才会被加载，</span></span><br><span class="line"><span class="comment">* 从而实现懒加载。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a><code>ReadWriteLock</code></h3><p><code>ReadWriteLock</code> 适用于读多写少的场景，它允许多个线程同时进行读操作，但写操作必须是互斥的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sharedData</span> <span class="operator">=</span> <span class="string">&quot;初始数据&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在读取数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> (String) sharedData;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String newData)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在写入数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">// sharedData = newData; // 实际更新数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><p><code>ExecutorService</code> 的两种关闭方式：<code>shutdown()</code> 和 <code>shutdownNow()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShutdownDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交 5 个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在执行...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 被中断。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// shutdown() vs shutdownNow()</span></span><br><span class="line">        <span class="comment">// executor.shutdown(); // 优雅关闭</span></span><br><span class="line">        executor.shutdownNow(); <span class="comment">// 暴力关闭</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池已关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 区别:</span></span><br><span class="line"><span class="comment">* - shutdown(): 优雅关闭。不再接受新的任务，但会等待已提交的任务（包括正在执行和在队列中的）全部执行完毕。</span></span><br><span class="line"><span class="comment">* 执行后，isShutdown() 返回 true，isTerminated() 返回 false，直到所有任务完成。</span></span><br><span class="line"><span class="comment">* - shutdownNow(): 暴力关闭。立即停止所有正在执行的任务，并返回在队列中等待执行的任务列表。</span></span><br><span class="line"><span class="comment">* 它会向所有线程发送 interrupt() 中断信号。</span></span><br><span class="line"><span class="comment">* 执行后，isShutdown() 返回 true，isTerminated() 立即返回 true。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>一个线程通过响应 <code>interrupt()</code> 调用来正确停止自身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptedThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; <span class="comment">// 检查中断标志</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程正在执行...&quot;</span>);</span><br><span class="line">                    <span class="comment">// sleep()、wait() 等方法会抛出 InterruptedException 并清除中断标志</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程被中断！&quot;</span>);</span><br><span class="line">                    <span class="comment">// 重新设置中断标志，以便外层循环能正确退出</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">// 或者直接 return 退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程已退出。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        worker.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送中断信号</span></span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子数组求和-Subarray-Sum"><a href="#子数组求和-Subarray-Sum" class="headerlink" title="子数组求和 (Subarray Sum)"></a>子数组求和 (Subarray Sum)</h3><p>使用<strong>滑动窗口</strong>或<strong>前缀和 + 哈希表</strong>两种方式解决。这里演示前缀和 + 哈希表，它能处理负数情况且时间复杂度更优。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出和等于目标值的连续子数组。</span></span><br><span class="line"><span class="comment">     * 使用前缀和与哈希表的方式，时间复杂度为 O(n)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums   整数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到，返回子数组的起始和结束索引；否则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findSubarraySum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key: 前缀和, value: 出现该前缀和的索引</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; prefixSumMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        prefixSumMap.put(<span class="number">0</span>, -<span class="number">1</span>); <span class="comment">// 初始化，处理从数组开头开始的子数组</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            currentSum += nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否存在 (currentSum - target) 这样的前缀和</span></span><br><span class="line">            <span class="keyword">if</span> (prefixSumMap.containsKey(currentSum - target)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> prefixSumMap.get(currentSum - target) + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prefixSumMap.put(currentSum, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串去重-Remove-Duplicates-from-String"><a href="#字符串去重-Remove-Duplicates-from-String" class="headerlink" title="字符串去重 (Remove Duplicates from String)"></a>字符串去重 (Remove Duplicates from String)</h3><p>使用 <code>LinkedHashSet</code> 保持相对顺序或手动遍历。这里手动遍历实现，避免使用额外数据结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对一个字符串进行去重，并保持原有字符的相对顺序。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 待去重的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 去重后的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">removeDuplicates</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">boolean</span>[] charSet = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>]; <span class="comment">// 假设为 ASCII 字符集</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!charSet[c]) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                charSet[c] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="最长不重复子串-Longest-Substring-Without-Repeating-Characters"><a href="#最长不重复子串-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="最长不重复子串 (Longest Substring Without Repeating Characters)"></a>最长不重复子串 (Longest Substring Without Repeating Characters)</h3><p>使用<strong>滑动窗口</strong>加<strong>哈希表</strong>或<strong>数组</strong>来高效解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出最长不重复子串的长度。</span></span><br><span class="line"><span class="comment">     * 使用滑动窗口（双指针）和哈希表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 输入字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长不重复子串的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key: 字符, value: 字符的最新索引</span></span><br><span class="line">        Map&lt;Character, Integer&gt; charIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 滑动窗口的左边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">currentChar</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前字符已在窗口内，更新左边界</span></span><br><span class="line">            <span class="keyword">if</span> (charIndexMap.containsKey(currentChar)) &#123;</span><br><span class="line">                left = Math.max(left, charIndexMap.get(currentChar) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            charIndexMap.put(currentChar, right);</span><br><span class="line">            maxLength = Math.max(maxLength, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串转整数-String-to-Integer-atoi"><a href="#字符串转整数-String-to-Integer-atoi" class="headerlink" title="字符串转整数 (String to Integer - atoi)"></a>字符串转整数 (String to Integer - atoi)</h3><p>实现 <code>atoi</code> 函数，需要考虑各种边界情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 atoi 函数，将字符串转换为整数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换后的整数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.trim(); <span class="comment">// 1. 去掉前导空格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2. 处理正负号</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(index) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = -<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(index) == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(index);</span><br><span class="line">            <span class="comment">// 3. 检查是否为数字</span></span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(c)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            result = result * <span class="number">10</span> + digit;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 处理溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="number">1</span> &amp;&amp; result &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sign == -<span class="number">1</span> &amp;&amp; -result &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (result * sign);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="判断子串-Substring-Check"><a href="#判断子串-Substring-Check" class="headerlink" title="判断子串 (Substring Check)"></a>判断子串 (Substring Check)</h3><p>使用 <code>String.indexOf()</code> 是最直接的方式。如果不能使用内置方法，可以通过双指针或 KMP 算法实现。这里提供双指针的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个字符串是否是另一个字符串的子串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mainStr 主字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subStr  子字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果 subStr 是 mainStr 的子串，返回 true；否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSubstring</span><span class="params">(String mainStr, String subStr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mainStr == <span class="literal">null</span> || subStr == <span class="literal">null</span> || mainStr.length() &lt; subStr.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subStr.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= mainStr.length() - subStr.length(); i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; subStr.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mainStr.charAt(i + j) != subStr.charAt(j)) &#123;</span><br><span class="line">                    match = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数组旋转-Array-Rotation"><a href="#数组旋转-Array-Rotation" class="headerlink" title="数组旋转 (Array Rotation)"></a>数组旋转 (Array Rotation)</h3><p>向右旋转 <code>k</code> 步，可以通过三次反转或使用额外数组实现。这里使用空间复杂度为 <code>O(1)</code> 的三次反转方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个整数数组向右旋转 k 步。</span></span><br><span class="line"><span class="comment">     * 使用三次反转的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 整数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k    旋转步数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k %= nums.length; <span class="comment">// 处理 k 大于数组长度的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 反转整个数组</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 2. 反转前 k 个元素</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 反转剩下的元素</span></span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="交错字符串-Interleaving-String"><a href="#交错字符串-Interleaving-String" class="headerlink" title="交错字符串 (Interleaving String)"></a>交错字符串 (Interleaving String)</h3><p>判断 <code>s3</code> 是否由 <code>s1</code> 和 <code>s2</code> 交错而成，可以使用<strong>动态规划</strong>解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两个字符串交错形成的字符串是否等于第三个字符串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1 字符串1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2 字符串2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3 字符串3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是交错字符串，返回 true；否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s1 的前 i 个字符和 s2 的前 j 个字符能否交错组成 s3 的前 i+j 个字符</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行 (s1 不取字符)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s2.length(); j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一列 (s2 不取字符)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s1.length(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充 DP 表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s2.length(); j++) &#123;</span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>)) ||</span><br><span class="line">                           (dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="最长公共前缀-Longest-Common-Prefix"><a href="#最长公共前缀-Longest-Common-Prefix" class="headerlink" title="最长公共前缀 (Longest Common Prefix)"></a>最长公共前缀 (Longest Common Prefix)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出字符串数组中的最长公共前缀。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs 字符串数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长公共前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 循环比较，直到找到子串</span></span><br><span class="line">            <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 每次缩短 prefix</span></span><br><span class="line">                prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (prefix.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串压缩-String-Compression"><a href="#字符串压缩-String-Compression" class="headerlink" title="字符串压缩 (String Compression)"></a>字符串压缩 (String Compression)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现基本的字符串压缩，例如 aabcccccaaa 压缩为 a2b1c5a3。</span></span><br><span class="line"><span class="comment">     * 如果压缩后的字符串没有变短，则返回原字符串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 待压缩的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 压缩后的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">compressString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">compressed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; str.length() &amp;&amp; str.charAt(i) == str.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                compressed.append(str.charAt(i - <span class="number">1</span>)).append(count);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (compressed.length() &gt;= str.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> str; <span class="comment">// 如果压缩后没有变短，返回原字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compressed.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="寻找重复数-Find-the-Duplicate-Number"><a href="#寻找重复数-Find-the-Duplicate-Number" class="headerlink" title="寻找重复数 (Find the Duplicate Number)"></a>寻找重复数 (Find the Duplicate Number)</h3><p>给定一个包含 <code>n+1</code> 个整数的数组，数字都在 <code>1</code> 到 <code>n</code> 的范围内。找出这个重复的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用**快慢指针**（类似于检测链表环）来寻找重复数。</span></span><br><span class="line"><span class="comment">     * 假设数组是一个链表，索引 `i` 指向 `nums[i]`</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 包含 n+1 个整数的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 重复的数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 寻找环的入口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 找到环后，从头开始，快慢指针以相同速度前进，相遇点即为环的入口（重复数）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = nums[p1];</span><br><span class="line">            p2 = nums[p2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="链表、栈与队列"><a href="#链表、栈与队列" class="headerlink" title="链表、栈与队列"></a>链表、栈与队列</h3><h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>使用<strong>双指针</strong>方法，创建一个新的链表，遍历两个输入链表，比较节点值并依次添加到新链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个哑节点，简化操作</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                current.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将剩余的节点添加到新链表末尾</span></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            current.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            current.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表倒数第-k-个节点"><a href="#链表倒数第-k-个节点" class="headerlink" title="链表倒数第 k 个节点"></a>链表倒数第 k 个节点</h4><p>使用<strong>快慢指针</strong>，只遍历一次。快指针先走 <code>k</code> 步，然后快慢指针同时前进，当快指针到达末尾时，慢指针正好在倒数第 <code>k</code> 个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快指针先走 k 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 链表长度小于 k</span></span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针同时前进，直到快指针到达末尾</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除重复节点"><a href="#删除重复节点" class="headerlink" title="删除重复节点"></a>删除重复节点</h4><p>给定一个已排序的链表，删除所有重复的节点，使得每个元素只出现一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.val == current.next.val) &#123;</span><br><span class="line">                current.next = current.next.next; <span class="comment">// 删除下一个重复节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.next; <span class="comment">// 前进到下一个不重复的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h4><p>使用<strong>快慢指针</strong>。如果链表有环，快指针最终会追上慢指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已经到达末尾，没有环</span></span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h4><p>两个非负整数由链表表示，每个节点包含一个数字。计算它们的和。这里假设链表按<strong>逆序</strong>存储数字（个位在前）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h4><p>使用两个栈，一个用于入队 (<code>inStack</code>)，一个用于出队 (<code>outStack</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        outStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            transfer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            transfer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h4><p>使用两个队列，一个用于入栈 (<code>q1</code>)，一个用于辅助 (<code>q2</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; q1;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; q2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        q1.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (q1.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            q2.offer(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> q1.poll();</span><br><span class="line">        Queue&lt;Integer&gt; temp = q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pop();</span><br><span class="line">        q1.offer(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h4><p>使用一个<strong>栈</strong>来检查括号是否匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                    (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                    (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="树与递归"><a href="#树与递归" class="headerlink" title="树与递归"></a>树与递归</h3><p>定义一个简单的二叉树节点类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树前序遍历-Preorder-Traversal"><a href="#二叉树前序遍历-Preorder-Traversal" class="headerlink" title="二叉树前序遍历 (Preorder Traversal)"></a>二叉树前序遍历 (Preorder Traversal)</h4><p><strong>递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">preorderTraversalRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        preorder(node.left, list);</span><br><span class="line">        preorder(node.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">preorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="comment">// 先压入右子节点，再压入左子节点，保证弹出时先处理左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树中序遍历-Inorder-Traversal"><a href="#二叉树中序遍历-Inorder-Traversal" class="headerlink" title="二叉树中序遍历 (Inorder Traversal)"></a>二叉树中序遍历 (Inorder Traversal)</h4><p><strong>递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">inorderTraversalRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node.left, list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        inorder(node.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">inorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 将所有左子节点压入栈</span></span><br><span class="line">            <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(current);</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 弹出栈顶节点，并处理其右子树</span></span><br><span class="line">            current = stack.pop();</span><br><span class="line">            result.add(current.val);</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树后序遍历-Postorder-Traversal"><a href="#二叉树后序遍历-Postorder-Traversal" class="headerlink" title="二叉树后序遍历 (Postorder Traversal)"></a>二叉树后序遍历 (Postorder Traversal)</h4><p><strong>递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">postorderTraversalRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(node.left, list);</span><br><span class="line">        postorder(node.right, list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">postorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">// 倒序插入</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result); <span class="comment">// 将结果反转</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树层序遍历-Level-Order-Traversal"><a href="#二叉树层序遍历-Level-Order-Traversal" class="headerlink" title="二叉树层序遍历 (Level Order Traversal)"></a>二叉树层序遍历 (Level Order Traversal)</h4><p>使用<strong>队列</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">levelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; currentLevel = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                currentLevel.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currentLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对称二叉树-Symmetric-Tree"><a href="#对称二叉树-Symmetric-Tree" class="headerlink" title="对称二叉树 (Symmetric Tree)"></a>对称二叉树 (Symmetric Tree)</h4><p>使用<strong>递归</strong>，检查根节点的左右子树是否是镜像对称的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (t1.val == t2.val) &amp;&amp; isMirror(t1.right, t2.left) &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大深度-Maximum-Depth-of-Binary-Tree"><a href="#最大深度-Maximum-Depth-of-Binary-Tree" class="headerlink" title="最大深度 (Maximum Depth of Binary Tree)"></a>最大深度 (Maximum Depth of Binary Tree)</h4><p>使用<strong>递归</strong>（深度优先搜索）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证二叉搜索树-Validate-Binary-Search-Tree"><a href="#验证二叉搜索树-Validate-Binary-Search-Tree" class="headerlink" title="验证二叉搜索树 (Validate Binary Search Tree)"></a>验证二叉搜索树 (Validate Binary Search Tree)</h4><p>使用<strong>递归</strong>或<strong>中序遍历</strong>。二叉搜索树的中序遍历结果是升序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查当前节点的值是否在有效范围内</span></span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归检查左右子树，并缩小有效范围</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(node.left, min, node.val) &amp;&amp; isValidBST(node.right, node.val, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="最大子数组和-Maximum-Subarray-Sum"><a href="#最大子数组和-Maximum-Subarray-Sum" class="headerlink" title="最大子数组和 (Maximum Subarray Sum)"></a>最大子数组和 (Maximum Subarray Sum)</h4><p>使用<strong>动态规划</strong> (Kadane’s algorithm)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSoFar</span> <span class="operator">=</span> nums[<span class="number">0</span>]; <span class="comment">// 迄今为止的最大和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxEndingHere</span> <span class="operator">=</span> nums[<span class="number">0</span>]; <span class="comment">// 以当前位置结尾的最大和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// maxEndingHere 的值是：(当前元素) 或 (当前元素 + 之前的最大和)</span></span><br><span class="line">            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);</span><br><span class="line">            maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两数相加-Large-Number-Addition"><a href="#两数相加-Large-Number-Addition" class="headerlink" title="两数相加 (Large Number Addition)"></a>两数相加 (Large Number Addition)</h4><p>将两个超长正整数字符串相加，模拟小学加法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit1</span> <span class="operator">=</span> (i &gt;= <span class="number">0</span>) ? num1.charAt(i--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit2</span> <span class="operator">=</span> (j &gt;= <span class="number">0</span>) ? num2.charAt(j--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> digit1 + digit2 + carry;</span><br><span class="line">            sb.append(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="位运算实现加法-Addition-with-Bitwise-Operators"><a href="#位运算实现加法-Addition-with-Bitwise-Operators" class="headerlink" title="位运算实现加法 (Addition with Bitwise Operators)"></a>位运算实现加法 (Addition with Bitwise Operators)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        <span class="type">int</span> carry;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算无进位的和（异或）</span></span><br><span class="line">            sum = a ^ b;</span><br><span class="line">            <span class="comment">// 计算进位（与&amp;左移）</span></span><br><span class="line">            carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全排列-Permutations"><a href="#全排列-Permutations" class="headerlink" title="全排列 (Permutations)"></a>全排列 (Permutations)</h4><p>使用<strong>回溯算法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BacktrackingProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrackPermute(result, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtrackPermute</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList, <span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempList.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrackPermute(result, tempList, nums, used);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子集-Subsets"><a href="#子集-Subsets" class="headerlink" title="子集 (Subsets)"></a>子集 (Subsets)</h4><p>使用<strong>回溯算法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BacktrackingProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrackSubsets(result, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtrackSubsets</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList, <span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrackSubsets(result, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跳台阶-Climbing-Stairs"><a href="#跳台阶-Climbing-Stairs" class="headerlink" title="跳台阶 (Climbing Stairs)"></a>跳台阶 (Climbing Stairs)</h4><p>这是经典的<strong>动态规划</strong>问题，与斐波那契数列类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现一个简单的-Trie-前缀树"><a href="#实现一个简单的-Trie-前缀树" class="headerlink" title="实现一个简单的 Trie (前缀树)"></a>实现一个简单的 Trie (前缀树)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    Map&lt;Character, TrieNode&gt; children;</span><br><span class="line">    <span class="type">boolean</span> isEndOfWord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        isEndOfWord = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            current = current.children.computeIfAbsent(c, k -&gt; <span class="keyword">new</span> <span class="title class_">TrieNode</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        current.isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!current.children.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.children.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!current.children.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.children.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转链表-II-Reverse-Linked-List-II"><a href="#反转链表-II-Reverse-Linked-List-II" class="headerlink" title="反转链表 II (Reverse Linked List II)"></a>反转链表 II (Reverse Linked List II)</h4><p>反转链表从位置 <code>m</code> 到 <code>n</code> 的部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre.next; <span class="comment">// 移动到反转部分的前一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next; <span class="comment">// 反转部分的起始节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">then</span> <span class="operator">=</span> start.next; <span class="comment">// 待反转的第二个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">            start.next = then.next;</span><br><span class="line">            then.next = pre.next;</span><br><span class="line">            pre.next = then;</span><br><span class="line">            then = start.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LRU-缓存-LRU-Cache"><a href="#LRU-缓存-LRU-Cache" class="headerlink" title="LRU 缓存 (LRU Cache)"></a>LRU 缓存 (LRU Cache)</h4><p>使用 <code>LinkedHashMap</code> 可以非常方便地实现 LRU 缓存，因为它本身就维护了插入顺序或访问顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity, <span class="number">0.75f</span>, <span class="literal">true</span>); <span class="comment">// true 表示按访问顺序排序</span></span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="comment">// 当容量超过限制时，自动移除最老的（最久未访问的）条目</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getOrDefault(key, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断回文链表-Palindrome-Linked-List"><a href="#判断回文链表-Palindrome-Linked-List" class="headerlink" title="判断回文链表 (Palindrome Linked List)"></a>判断回文链表 (Palindrome Linked List)</h4><p>可以使用快慢指针找到中点，然后反转后半部分，最后比较两部分是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 快慢指针找中点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转后半部分</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">secondHalf</span> <span class="operator">=</span> reverseList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 比较前半部分和反转后的后半部分</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">firstHalf</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (secondHalf != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstHalf.val != secondHalf.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            firstHalf = firstHalf.next;</span><br><span class="line">            secondHalf = secondHalf.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextTemp</span> <span class="operator">=</span> current.next;</span><br><span class="line">            current.next = prev;</span><br><span class="line">            prev = current;</span><br><span class="line">            current = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ReadWriteLock-1"><a href="#ReadWriteLock-1" class="headerlink" title="ReadWriteLock"></a><code>ReadWriteLock</code></h3><p><code>ReadWriteLock</code> 允许多个线程同时进行读操作，但只允许一个线程进行写操作，从而提高读多写少的场景下的并发性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;初始数据&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作：允许多个线程同时访问</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在读取数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作：同一时刻只能有一个线程访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String newData)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在写入数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h3><p><code>CountDownLatch</code> 允许一个线程等待，直到其他线程都完成了某项工作。它就像一个倒计时器，一旦计数为零，等待的线程就会被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 创建一个计数器，初始值为 5</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(workerCount);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：启动 &quot;</span> + workerCount + <span class="string">&quot; 个工作线程...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 开始执行任务...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">2000</span>)); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 任务完成。&quot;</span>);</span><br><span class="line">                    latch.countDown(); <span class="comment">// 任务完成后，计数器减 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：等待所有工作线程完成...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 阻塞主线程，直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：所有工作线程已完成，继续执行下一步。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CyclicBarrier-1"><a href="#CyclicBarrier-1" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code> 允许一组线程在到达一个共同的屏障点后，再一起继续执行。它就像赛跑的起跑线，所有选手都准备好后，发令枪才响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">runnerCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 创建一个屏障，当 3 个线程都到达时，执行一个屏障动作</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(runnerCount, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n所有赛跑者都已就位，发令枪响！\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(runnerCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; runnerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">runnerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;赛跑者 &quot;</span> + runnerId + <span class="string">&quot; 正在走向起跑线...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">3000</span>)); <span class="comment">// 模拟准备时间</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;赛跑者 &quot;</span> + runnerId + <span class="string">&quot; 到达起跑线，准备就绪。&quot;</span>);</span><br><span class="line">                    barrier.await(); <span class="comment">// 线程在此处等待，直到所有线程都到达</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;赛跑者 &quot;</span> + runnerId + <span class="string">&quot; 开始跑步！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Semaphore-1"><a href="#Semaphore-1" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h3><p><code>Semaphore</code>（信号量）用来控制对某个资源的并发访问数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 停车场最多允许 3 辆车停放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">int</span> carId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;汽车 &quot;</span> + carId + <span class="string">&quot; 正在寻找车位...&quot;</span>);</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">            System.out.println(<span class="string">&quot;汽车 &quot;</span> + carId + <span class="string">&quot; 成功进入停车场。&quot;</span>);</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">3000</span>)); <span class="comment">// 模拟停车时间</span></span><br><span class="line">            System.out.println(<span class="string">&quot;汽车 &quot;</span> + carId + <span class="string">&quot; 离开停车场。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SemaphoreDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SemaphoreDemo</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>); <span class="comment">// 10 辆车</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">carId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; demo.park(carId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="死锁预防-按锁顺序"><a href="#死锁预防-按锁顺序" class="headerlink" title="死锁预防 (按锁顺序)"></a>死锁预防 (按锁顺序)</h3><p>通过<strong>资源有序分配</strong>来打破死锁的<strong>循环等待</strong>条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockPrevention</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 1: 已获得 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 1: 已获得 lockB。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 两个线程都按相同的顺序（先 A 后 B）获取锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 2: 已获得 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 2: 已获得 lockB。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockPrevention</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockPrevention</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadOne, <span class="string">&quot;Thread-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadTwo, <span class="string">&quot;Thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程池异常"><a href="#线程池异常" class="headerlink" title="线程池异常"></a>线程池异常</h3><p>使用 <code>Future.get()</code> 或在任务中捕获异常来处理线程池中任务抛出的异常。<code>execute()</code> 方法无法直接捕获异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPoolExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交一个会抛出运行时异常的任务</span></span><br><span class="line">        Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;这是一个模拟的任务执行异常。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取任务结果来捕获异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;捕获到任务执行异常：&quot;</span> + e.getCause().getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 execute() 提交任务，异常会被吞掉，除非自定义 UncaughtExceptionHandler</span></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;另一个任务开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;这个异常会被吞掉。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ThreadLocal-1"><a href="#ThreadLocal-1" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p><code>ThreadLocal</code> 为每个线程提供了独立的变量副本，实现了数据隔离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAndPrint</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        threadLocal.set(value); <span class="comment">// 设置当前线程的变量副本</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的变量值: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadLocal.remove(); <span class="comment">// 最佳实践：使用完后移除，防止内存泄漏</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 A 的数据&quot;</span>), <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 B 的数据&quot;</span>), <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a><code>LockSupport</code></h3><p><code>LockSupport.park()</code> 和 <code>LockSupport.unpark()</code> 提供了更灵活的线程阻塞和唤醒机制，类似于 <code>wait()</code> 和 <code>notify()</code>，但不需要依赖锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockSupportDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;工作线程: 任务准备就绪，即将阻塞...&quot;</span>);</span><br><span class="line">            LockSupport.park(); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            System.out.println(<span class="string">&quot;工作线程: 被唤醒，继续执行。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        workerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 确保工作线程已执行 park()</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 唤醒工作线程。&quot;</span>);</span><br><span class="line">        LockSupport.unpark(workerThread); <span class="comment">// 唤醒指定线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程通信-按顺序打印"><a href="#线程通信-按顺序打印" class="headerlink" title="线程通信 (按顺序打印)"></a>线程通信 (按顺序打印)</h3><p>使用 <code>wait()</code> 和 <code>notifyAll()</code> 实现三个线程按顺序打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SequentialPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 0: A, 1: B, 2: C</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String letter, <span class="type">int</span> expectedState)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (state != expectedState) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(letter);</span><br><span class="line">                state = (state + <span class="number">1</span>) % <span class="number">3</span>; <span class="comment">// 切换到下一个状态</span></span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SequentialPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequentialPrinter</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printA);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printB);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printC);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line"></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line">        threadC.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n打印完成。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="ThreadPoolExecutor-的七个参数"><a href="#ThreadPoolExecutor-的七个参数" class="headerlink" title="ThreadPoolExecutor 的七个参数"></a><code>ThreadPoolExecutor</code> 的七个参数</h4><ol><li><code>corePoolSize</code>: 核心线程数。线程池中常驻的线程数量，即使空闲也不会被销毁。</li><li><code>maximumPoolSize</code>: 最大线程数。当工作队列已满，且任务量继续增加时，线程池可以创建的最大线程数。</li><li><code>keepAliveTime</code>: 空闲线程存活时间。当线程数大于 <code>corePoolSize</code> 时，非核心线程的空闲存活时间。</li><li><code>unit</code>: <code>keepAliveTime</code> 的时间单位。</li><li><code>workQueue</code>: 工作队列。用于存放等待执行的任务，常用的有 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等。</li><li><code>threadFactory</code>: 线程工厂。用于创建新线程，可以自定义线程的名称、优先级等。</li><li><code>handler</code>: 拒绝策略。当线程池和工作队列都已满时，用于处理新来的任务，例如抛出异常、由调用者执行等。</li></ol><h4 id="手写一个自定义线程池"><a href="#手写一个自定义线程池" class="headerlink" title="手写一个自定义线程池"></a>手写一个自定义线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">5</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">60L</span>, <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), <span class="comment">// 工作队列容量为 10</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 默认线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略：由调用者线程执行</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 执行。&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>使用 <code>AtomicBoolean</code> 或 <code>AtomicReference</code> 解决并发问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicBooleanDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 确保只有一个线程执行初始化操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 只有当 initialized 为 false 时，才将其设置为 true 并执行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialized.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 开始执行初始化操作...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 初始化完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 初始化已被其他线程执行，跳过。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(AtomicBooleanDemo::initialize, <span class="string">&quot;Thread-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="volatile-内存语义"><a href="#volatile-内存语义" class="headerlink" title="volatile 内存语义"></a><code>volatile</code> 内存语义</h3><p><code>volatile</code> 确保了<strong>可见性</strong>和<strong>有序性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileMemorySemantics</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 可见性：当一个线程修改了 ready 的值，其他线程能立即看到最新值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriterThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            number = <span class="number">42</span>; <span class="comment">// 修改 number</span></span><br><span class="line">            ready = <span class="literal">true</span>; <span class="comment">// 修改 ready</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="comment">// 等待 ready 变为 true</span></span><br><span class="line">                <span class="comment">// 如果没有 volatile，这里可能会陷入死循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 有序性：写 volatile 变量（ready = true）之前的操作（number = 42）</span></span><br><span class="line">            <span class="comment">// 对其他线程都是可见的。保证了 number 的值是 42。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读取到的 number 值: &quot;</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WriterThread</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="中断机制-1"><a href="#中断机制-1" class="headerlink" title="中断机制"></a>中断机制</h3><p>一个线程通过响应 <code>interrupt()</code> 调用来正确停止自身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptibleThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; <span class="comment">// 检查中断标志</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程正在执行...&quot;</span>);</span><br><span class="line">                    <span class="comment">// sleep()、wait() 等方法会抛出 InterruptedException 并清除中断标志</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程被中断，即将退出...&quot;</span>);</span><br><span class="line">                    <span class="comment">// 重新设置中断标志，以便外层循环能正确退出</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">// 或者直接 break 或 return 退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程已优雅地退出。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        worker.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 发送中断信号。&quot;</span>);</span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h3><p><code>ConcurrentHashMap</code> 的并发原理是**分段锁（ 7）**或 <strong>CAS + Synchronized（ 8）</strong>，只对操作的桶进行锁定，大大提高了并发性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcurrentHashMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 10 个线程，每个线程向 map 中添加 1000 个键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key-&quot;</span> + (threadId * <span class="number">1000</span> + j);</span><br><span class="line">                    map.put(key, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终 map 的大小: &quot;</span> + map.size()); <span class="comment">// 期望值为 10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a><code>ForkJoinPool</code></h3><p><code>ForkJoinPool</code> 是一个用于分治任务的线程池，<code>RecursiveTask</code> 是可返回结果的分治任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 任务分解的阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SumTask</span><span class="params">(<span class="type">long</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务规模小于等于阈值，则直接计算</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，将任务分解成两个子任务</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, start, mid);</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, mid, end);</span><br><span class="line"></span><br><span class="line">            leftTask.fork(); <span class="comment">// 提交左子任务</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.compute(); <span class="comment">// 同步计算右子任务</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join(); <span class="comment">// 等待左子任务结果</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] array = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">1000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br><span class="line">        System.out.println(<span class="string">&quot;大数组的和为: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-语言基础"><a href="#1-语言基础" class="headerlink" title="1.  语言基础"></a>1.  语言基础</h3><h4 id="变量与数据类型"><a href="#变量与数据类型" class="headerlink" title="变量与数据类型"></a>变量与数据类型</h4><p> 的基本数据类型决定了变量可以存储的数据范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTypesDetailed</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 整数类型：默认为 int</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 占用 1 字节，-128 到 127</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 占用 2 字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100000</span>; <span class="comment">// 占用 4 字节</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">10000000000L</span>; <span class="comment">// 占用 8 字节，需要 L 或 l 后缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浮点类型：默认为 double</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.14f</span>; <span class="comment">// 占用 4 字节，需要 f 或 F 后缀</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.1415926535</span>; <span class="comment">// 占用 8 字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符类型</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 单个字符，占用 2 字节</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">65</span>; <span class="comment">// 也可以使用 ASCII 码或 Unicode</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1 和 c2 是否相等？ &quot;</span> + (c1 == c2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 布尔类型</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFun</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;学Java有趣吗？&quot;</span> + isFun);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p> 中，从小范围类型向大范围类型转换是<strong>自动</strong>的（隐式转换）；从大范围向小范围转换需要<strong>强制</strong>转换（显式转换），可能造成数据丢失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeCasting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 隐式转换：int -&gt; long</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">myInt</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">myLong</span> <span class="operator">=</span> myInt;</span><br><span class="line">        System.out.println(<span class="string">&quot;隐式转换后的 long 类型: &quot;</span> + myLong);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式转换：double -&gt; int</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">myDouble</span> <span class="operator">=</span> <span class="number">9.99</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">myInteger</span> <span class="operator">=</span> (<span class="type">int</span>) myDouble; <span class="comment">// 强制转换，小数部分被丢弃</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显式转换后的 int 类型: &quot;</span> + myInteger); <span class="comment">// 输出 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是存储<strong>固定大小</strong>同类型元素的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明并初始化一个整数数组</span></span><br><span class="line">        <span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 创建一个长度为 5 的数组</span></span><br><span class="line">        numbers[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        numbers[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明、初始化并赋值</span></span><br><span class="line">        String[] fruits = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有水果:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String fruit : fruits) &#123; <span class="comment">// 增强 for 循环</span></span><br><span class="line">            System.out.println(fruit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-面向对象编程-OOP"><a href="#2-面向对象编程-OOP" class="headerlink" title="2. 面向对象编程 (OOP)"></a>2. 面向对象编程 (OOP)</h3><h4 id="构造方法与方法重载"><a href="#构造方法与方法重载" class="headerlink" title="构造方法与方法重载"></a>构造方法与方法重载</h4><p><strong>构造方法</strong>是一种特殊方法，用于创建对象时初始化。<strong>方法重载</strong>是指在同一个类中，方法名相同但参数列表不同（参数类型、数量或顺序）的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;未知&quot;</span>, <span class="number">0</span>, <span class="string">&quot;000&quot;</span>); <span class="comment">// 调用本类的三参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = <span class="string">&quot;000&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法重载: 计算两个数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承、多态与抽象"><a href="#继承、多态与抽象" class="headerlink" title="继承、多态与抽象"></a>继承、多态与抽象</h4><p>继承实现代码复用，多态实现行为多样化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类：抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String brand; <span class="comment">// 子类可以访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vehicle</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;品牌是: &quot;</span> + brand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：继承 Vehicle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汽车正在路上行驶...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：继承 Vehicle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bicycle</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bicycle</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自行车正在骑行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphismDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;BMW&quot;</span>); <span class="comment">// 多态引用</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">myBicycle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bicycle</span>(<span class="string">&quot;Giant&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个方法调用，不同行为</span></span><br><span class="line">        myCar.run(); <span class="comment">// 输出 &quot;汽车正在路上行驶...&quot;</span></span><br><span class="line">        myBicycle.run(); <span class="comment">// 输出 &quot;自行车正在骑行...&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-核心类库"><a href="#3-核心类库" class="headerlink" title="3.  核心类库"></a>3.  核心类库</h3><p>好的，这次我们将把<strong>各种方法的使用代码</strong>直接嵌入到每个知识点的解释中，让您在学习概念的同时，就能看到具体的代码实现和效果。我们将专注于<strong>数组、字符串和集合</strong>这三大核心部分，把它们的创建、遍历、和各种常用方法的代码示例都清晰地展示出来。</p><hr><h3 id="1-数组（Array）"><a href="#1-数组（Array）" class="headerlink" title="1. 数组（Array）"></a>1. 数组（Array）</h3><p>数组是一种固定大小的、用于存储同类型元素的容器。</p><h4 id="创建和遍历"><a href="#创建和遍历" class="headerlink" title="创建和遍历"></a>创建和遍历</h4><p>这里展示两种最常见的创建数组的方式，并使用两种循环进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式一：声明并分配空间，系统赋默认值</span></span><br><span class="line">        <span class="type">int</span>[] intArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">// 创建一个包含3个整数的数组，默认值都是0</span></span><br><span class="line">        intArray[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        intArray[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">        intArray[<span class="number">2</span>] = <span class="number">30</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;数组 intArray 的第一个元素是: &quot;</span> + intArray[<span class="number">0</span>]); <span class="comment">// 输出: 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式二：声明并直接初始化</span></span><br><span class="line">        String[] stringArray = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;Java&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方式一：使用 for 循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 使用 for 循环遍历 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringArray.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stringArray[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + stringArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历方式二：使用增强 for 循环（更简洁）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 使用增强 for 循环遍历 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : stringArray) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;元素: &quot;</span> + element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Arrays-类的常用方法"><a href="#Arrays-类的常用方法" class="headerlink" title="Arrays 类的常用方法"></a><code>Arrays</code> 类的常用方法</h4><p><code>java.util.Arrays</code> 类提供了很多静态方法，方便我们对数组进行操作，比如排序、查找、复制等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysMethodExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 排序：Arrays.sort()</span></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后: &quot;</span> + Arrays.toString(numbers)); <span class="comment">// 输出: [1, 2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 查找：Arrays.binarySearch() (必须先排序)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素 6 的索引是: &quot;</span> + index); <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 填充：Arrays.fill()</span></span><br><span class="line">        <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        Arrays.fill(newArray, <span class="number">99</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;填充后: &quot;</span> + Arrays.toString(newArray)); <span class="comment">// 输出: [99, 99, 99, 99, 99]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 复制：Arrays.copyOf()</span></span><br><span class="line">        <span class="type">int</span>[] copiedArray = Arrays.copyOf(numbers, <span class="number">3</span>); <span class="comment">// 复制前3个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;复制前3个元素: &quot;</span> + Arrays.toString(copiedArray)); <span class="comment">// 输出: [1, 2, 4]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 比较：Arrays.equals()</span></span><br><span class="line">        <span class="type">int</span>[] anotherArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;两个数组是否相等: &quot;</span> + Arrays.equals(numbers, anotherArray)); <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-字符串（String）"><a href="#2-字符串（String）" class="headerlink" title="2. 字符串（String）"></a>2. 字符串（String）</h3><p><code>String</code> 是一个不可变的字符序列，这意味着一旦创建，它的内容就不能被修改。所有修改操作都会返回一个新的 <code>String</code> 对象。</p><h4 id="创建和常用方法"><a href="#创建和常用方法" class="headerlink" title="创建和常用方法"></a>创建和常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;  Java is a great language. &quot;</span>; <span class="comment">// 字面量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java is a great language.&quot;</span>); <span class="comment">// 使用 new 关键字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常用方法</span></span><br><span class="line">        <span class="comment">// 1. 获取长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str1.length();</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度: &quot;</span> + length); <span class="comment">// 输出: 29</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 访问字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> str1.charAt(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第3个字符是: &quot;</span> + firstChar); <span class="comment">// 输出: J</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 截取子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> str1.substring(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;截取子串: &quot;</span> + sub); <span class="comment">// 输出: is</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 查找位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str1.indexOf(<span class="string">&quot;great&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&#x27;great&#x27; 的索引: &quot;</span> + index); <span class="comment">// 输出: 11</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 判断</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> str1.contains(<span class="string">&quot;language&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含 &#x27;language&#x27;: &quot;</span> + contains); <span class="comment">// 输出: true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">startsWith</span> <span class="operator">=</span> str1.startsWith(<span class="string">&quot;  Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否以 &#x27;  Java&#x27; 开头: &quot;</span> + startsWith); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 替换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">replacedStr</span> <span class="operator">=</span> str1.replace(<span class="string">&quot;great&quot;</span>, <span class="string">&quot;wonderful&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;替换后: &quot;</span> + replacedStr); <span class="comment">// 输出:   Java is a wonderful language. </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 大小写转换和去空格</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">trimmedStr</span> <span class="operator">=</span> str1.trim();</span><br><span class="line">        System.out.println(<span class="string">&quot;去除首尾空格: &#x27;&quot;</span> + trimmedStr + <span class="string">&quot;&#x27;&quot;</span>); <span class="comment">// 输出: &#x27;Java is a great language.&#x27;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;转为大写: &quot;</span> + trimmedStr.toUpperCase());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 8. 分割和连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line">        String[] fruits = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;分割后: &quot;</span> + Arrays.toString(fruits)); <span class="comment">// 输出: [apple, banana, orange]</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">joinedString</span> <span class="operator">=</span> String.join(<span class="string">&quot; - &quot;</span>, fruits);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接后: &quot;</span> + joinedString); <span class="comment">// 输出: apple - banana - orange</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StringBuilder-和-StringBuffer"><a href="#StringBuilder-和-StringBuffer" class="headerlink" title="StringBuilder 和 StringBuffer"></a><code>StringBuilder</code> 和 <code>StringBuffer</code></h4><p>对于需要频繁修改字符串的场景，应使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 以提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 追加内容</span></span><br><span class="line">        sb.append(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;追加后: &quot;</span> + sb); <span class="comment">// 输出: Hello World</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 插入内容</span></span><br><span class="line">        sb.insert(<span class="number">6</span>, <span class="string">&quot;Beautiful &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;插入后: &quot;</span> + sb); <span class="comment">// 输出: Hello Beautiful World</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 删除内容</span></span><br><span class="line">        sb.delete(<span class="number">6</span>, <span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + sb); <span class="comment">// 输出: Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-集合（Collections）"><a href="#3-集合（Collections）" class="headerlink" title="3. 集合（Collections）"></a>3. 集合（Collections）</h3><p>Java 集合框架提供了强大的数据结构来存储和操作对象。</p><h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a><strong>List</strong>（列表）</h4><p><code>List</code> 是一种有序、可重复的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 ArrayList（查询快）</span></span><br><span class="line">        List&lt;String&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        fruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 添加元素</span></span><br><span class="line">        fruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        fruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 允许重复</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;列表元素: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Banana, Apple]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个元素: &quot;</span> + fruits.get(<span class="number">0</span>)); <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;列表大小: &quot;</span> + fruits.size());</span><br><span class="line"></span><br><span class="line">        fruits.set(<span class="number">1</span>, <span class="string">&quot;Grape&quot;</span>); <span class="comment">// 替换第二个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;替换后: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Grape, Apple]</span></span><br><span class="line"></span><br><span class="line">        fruits.remove(<span class="number">1</span>); <span class="comment">// 删除第二个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Apple]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Set（集）"><a href="#Set（集）" class="headerlink" title="Set（集）"></a><strong>Set</strong>（集）</h4><p><code>Set</code> 是一种无序、不可重复的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashSet</span></span><br><span class="line">        Set&lt;String&gt; uniqueFruits = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 添加重复元素，会失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;集合元素: &quot;</span> + uniqueFruits); <span class="comment">// 输出: [Apple, Banana] (顺序不定)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">containsBanana</span> <span class="operator">=</span> uniqueFruits.contains(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含 &#x27;Banana&#x27;: &quot;</span> + containsBanana); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">        uniqueFruits.remove(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + uniqueFruits); <span class="comment">// 输出: [Apple]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Map（映射）"><a href="#Map（映射）" class="headerlink" title="Map（映射）"></a><strong>Map</strong>（映射）</h4><p><code>Map</code> 存储键值对，键是唯一的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap</span></span><br><span class="line">        Map&lt;String, Integer&gt; studentScores = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        studentScores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">95</span>); <span class="comment">// 添加键值对</span></span><br><span class="line">        studentScores.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">88</span>);</span><br><span class="line">        studentScores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">100</span>); <span class="comment">// 键已存在，会覆盖旧值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Alice 的分数: &quot;</span> + studentScores.get(<span class="string">&quot;Alice&quot;</span>)); <span class="comment">// 输出: 100</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历 Map 的三种方式</span></span><br><span class="line">        <span class="comment">// 方式一：遍历键集</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历键集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : studentScores.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名: &quot;</span> + name + <span class="string">&quot;, 分数: &quot;</span> + studentScores.get(name));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式二：遍历值集</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历值集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer score : studentScores.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分数: &quot;</span> + score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式三：遍历键值对集 (Entry Set)，最常用且高效</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历键值对集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : studentScores.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名: &quot;</span> + entry.getKey() + <span class="string">&quot;, 分数: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题目</title>
      <link href="/2025/09/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
      <url>/2025/09/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Java-基础语法-关键字"><a href="#一、Java-基础语法-关键字" class="headerlink" title="一、Java 基础语法 &amp; 关键字"></a>一、Java 基础语法 &amp; 关键字</h2><h2 id="1-JDK、JRE-和-JVM-的区别"><a href="#1-JDK、JRE-和-JVM-的区别" class="headerlink" title="1. JDK、JRE 和 JVM 的区别"></a>1. JDK、JRE 和 JVM 的区别</h2><ul><li><strong>JVM（Java Virtual Machine）</strong>：Java 虚拟机，负责执行字节码（<code>.class</code>）。提供类加载、字节码校验、内存管理（堆、方法区）、执行引擎、垃圾回收、线程调度等。是抽象的规范，具体由不同厂商实现（HotSpot、OpenJ9 等）。</li><li><strong>JRE（Java Runtime Environment）</strong>：运行环境，包含 JVM、核心类库（rt.jar 或 modules）、以及运行时需要的其它资源。用于运行 Java 程序。</li><li><strong>JDK（Java Development Kit）</strong>：开发工具包，包含 JRE + 开发工具（<code>javac</code>、<code>jar</code>、<code>javadoc</code>、调试工具等）。用于开发 Java 程序。<br> 总结：JDK ⊃ JRE ⊃ JVM（JDK 包含 JRE，JRE 包含 JVM）。</li></ul><hr><h2 id="2-Java-的跨平台原理是什么？"><a href="#2-Java-的跨平台原理是什么？" class="headerlink" title="2. Java 的跨平台原理是什么？"></a>2. Java 的跨平台原理是什么？</h2><ul><li>Java 程序先由 <code>javac</code> 编译成与平台无关的 <strong>字节码</strong>（<code>.class</code>）。字节码不是机器码，而是供 JVM 执行的指令集。</li><li>每个平台（Windows&#x2F;Linux&#x2F;macOS）有相应的 JVM 实现，JVM 把字节码翻译成该平台的机器指令（通过解释器、JIT 编译器等）。因此同一套 <code>.class</code> 可以在不同平台的 JVM 上运行 —— “一次编写，处处运行”（Write Once, Run Anywhere）。</li><li>其它保证跨平台的要点：标准库隐藏平台差异（I&#x2F;O、线程等），需避免使用与平台绑定的本地代码（JNI）。</li></ul><hr><h2 id="3-Java-的基本数据类型有哪些？各自的默认值？"><a href="#3-Java-的基本数据类型有哪些？各自的默认值？" class="headerlink" title="3. Java 的基本数据类型有哪些？各自的默认值？"></a>3. Java 的基本数据类型有哪些？各自的默认值？</h2><p>8 种基本类型及默认值（成员变量&#x2F;数组元素；局部变量无默认值必须初始化）：</p><ul><li><code>byte</code>：1 byte，默认值 <code>0</code></li><li><code>short</code>：2 bytes，默认值 <code>0</code></li><li><code>int</code>：4 bytes，默认值 <code>0</code></li><li><code>long</code>：8 bytes，默认值 <code>0L</code></li><li><code>float</code>：4 bytes，默认值 <code>0.0f</code></li><li><code>double</code>：8 bytes，默认值 <code>0.0d</code></li><li><code>char</code>：2 bytes（UTF-16 code unit），默认值 <code>&#39;\u0000&#39;</code>（即 0）</li><li><code>boolean</code>：JVM 语义上用 1 bit 表示，默认值 <code>false</code></li></ul><p>另外，<strong>引用类型</strong>（对象、数组等）的默认值是 <code>null</code>。</p><hr><h2 id="4-byte、short、int、long-各占多少字节？"><a href="#4-byte、short、int、long-各占多少字节？" class="headerlink" title="4. byte、short、int、long 各占多少字节？"></a>4. <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> 各占多少字节？</h2><ul><li><code>byte</code>：<strong>1 字节</strong>（8 位）</li><li><code>short</code>：<strong>2 字节</strong>（16 位）</li><li><code>int</code>：<strong>4 字节</strong>（32 位）</li><li><code>long</code>：<strong>8 字节</strong>（64 位）</li></ul><p>（上述为 Java 语言规范定义，与平台无关。）</p><hr><h2 id="5-float-和-double-的区别？"><a href="#5-float-和-double-的区别？" class="headerlink" title="5. float 和 double 的区别？"></a>5. <code>float</code> 和 <code>double</code> 的区别？</h2><ul><li>精度与存储：<ul><li><code>float</code>：32 位单精度浮点（IEEE 754），约 6~7 位有效数字。</li><li><code>double</code>：64 位双精度浮点（IEEE 754），约 15~16 位有效数字。</li></ul></li><li>精度更高的 <code>double</code> 更常用；<code>float</code> 用于节省内存或与特定 API（如图形库）兼容。</li><li>注意：浮点数有精度误差，不适合做精确货币计算（应使用 <code>BigDecimal</code>）。</li><li>默认浮点字面量为 <code>double</code>（例如 <code>1.2</code> 是 <code>double</code>，写成 <code>1.2f</code> 才是 <code>float</code>）。</li></ul><hr><h2 id="6-char-类型占几个字节？能存汉字吗？"><a href="#6-char-类型占几个字节？能存汉字吗？" class="headerlink" title="6. char 类型占几个字节？能存汉字吗？"></a>6. <code>char</code> 类型占几个字节？能存汉字吗？</h2><ul><li><code>char</code> 占 <strong>2 字节</strong>（16 位），表示 UTF-16 的一个 code unit。</li><li>能否存汉字：多数常用汉字（位于基本多文种平面 BMP）可以用单个 <code>char</code> 表示（例如 <code>&#39;你&#39;</code>）；但有些罕见汉字或 emoji 属于补充平面（Supplementary Planes），它们需要 <strong>两个 char（称为 surrogate pair）</strong> 来表示。</li><li>因此，单个 <code>char</code> 能表示一个 UTF-16 code unit，而不是完整的 Unicode code point。处理 Unicode 字符时注意使用 <code>int codePoint</code> &#x2F; <code>Character</code> 的相关 API。</li></ul><hr><h2 id="7-自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？"><a href="#7-自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？" class="headerlink" title="7. 自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？"></a>7. 自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？</h2><ul><li><p><strong>概念</strong>：</p><ul><li>装箱：把基本类型自动转换成对应的包装类型（如 <code>int</code> → <code>Integer</code>）。</li><li>拆箱：把包装类型自动转换回基本类型（如 <code>Integer</code> → <code>int</code>）。</li></ul></li><li><p><strong>编译器行为</strong>：自动装箱&#x2F;拆箱是在编译期由 Java 编译器插入对应的调用，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 10;        // 编译器会转换为 Integer.valueOf(10)</span><br><span class="line">int b = a;             // 编译器会转换为 a.intValue()</span><br></pre></td></tr></table></figure></li><li><p><strong>valueOf 缓存</strong>：包装类（如 <code>Integer.valueOf(int)</code>）会对小整数（默认 -128 到 127）做缓存以重用对象，减少频繁创建对象。</p></li><li><p><strong>注意事项</strong>：</p><ul><li><p>拆箱 <code>null</code> 会抛出 <code>NullPointerException</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = null;</span><br><span class="line">int y = x; // NPE</span><br></pre></td></tr></table></figure></li><li><p>装箱&#x2F;拆箱会有性能开销（对象创建、装箱&#x2F;拆箱方法调用），在性能敏感场景尽量使用基本类型或手动优化。</p></li><li><p>比较时注意：<code>Integer a = 100; Integer b = 100; a==b</code> 在缓存范围内可能为 <code>true</code>，超出范围则通常为 <code>false</code>。</p></li></ul></li></ul><hr><h2 id="8-和-equals-的区别？"><a href="#8-和-equals-的区别？" class="headerlink" title="8. == 和 equals() 的区别？"></a>8. <code>==</code> 和 <code>equals()</code> 的区别？</h2><ul><li><strong>&#x3D;&#x3D;</strong>：<ul><li>对于基本类型：比较 <strong>值</strong>（数值是否相等）。</li><li>对于引用类型：比较 <strong>引用地址</strong>（是否是同一个对象）。</li></ul></li><li><strong>equals()</strong>：<ul><li>是 <code>Object</code> 的方法，默认实现也是比较引用（等价于 <code>==</code>）。</li><li>许多类（如 <code>String</code>、<code>Integer</code>、集合类等）重写了 <code>equals()</code>，用于比较<strong>逻辑&#x2F;内容相等</strong>。</li></ul></li><li><strong>使用建议</strong>：<ul><li>比较对象内容用 <code>equals()</code>（需检查 <code>null</code>），比较是否同一实例用 <code>==</code>。</li><li>与 <code>equals()</code> 配套应重写 <code>hashCode()</code>（见下题）。</li></ul></li></ul><hr><h2 id="9-hashCode-和-equals-的关系？"><a href="#9-hashCode-和-equals-的关系？" class="headerlink" title="9. hashCode 和 equals 的关系？"></a>9. <code>hashCode</code> 和 <code>equals</code> 的关系？</h2><ul><li><strong>合同（Contract）</strong>（重要）：<ol><li>如果两个对象通过 <code>equals()</code> 被判定为相等（<code>a.equals(b)</code> 为 <code>true</code>），那么 <code>a.hashCode() == b.hashCode()</code> 必须成立。</li><li>反之不要求：<code>hashCode</code> 相等的对象不一定 <code>equals()</code> 相等（哈希冲突允许）。</li></ol></li><li><strong>在哈希集合中的角色</strong>：<ul><li>哈希表（<code>HashMap</code>&#x2F;<code>HashSet</code>）先用 <code>hashCode()</code> 找到桶（bucket），若桶中有多个元素，再用 <code>equals()</code> 逐个比较确认相等或冲突。</li><li>如果只重写 <code>equals()</code> 而不重写 <code>hashCode()</code> 会破坏集合行为（例如放入 <code>HashSet</code> 后无法正确查找）。</li></ul></li><li><strong>实现要点</strong>：<ul><li><code>hashCode()</code> 要尽量分散（降低冲突），并在对象不可变字段上基于相同规则计算。</li><li>若对象可变，若用于哈希集合要小心：修改字段会导致 <code>hashCode()</code> 改变，破坏集合内部结构。</li></ul></li></ul><hr><h2 id="10-String、StringBuffer、StringBuilder-的区别？"><a href="#10-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="10. String、StringBuffer、StringBuilder 的区别？"></a>10. <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code> 的区别？</h2><ul><li><strong>String</strong>：<ul><li>不可变（immutable），每次修改都会产生新的对象（或新内部 char&#x2F;byte 数组）。</li><li>线程安全（因为不可变），适合频繁读取、少量修改的场景。</li></ul></li><li><strong>StringBuffer</strong>：<ul><li>可变的字符序列（内部有缓冲区 <code>char[]</code>&#x2F;<code>byte[]</code>），几乎与 <code>StringBuilder</code> 接口相同。</li><li><strong>线程安全</strong>，其方法大多使用 <code>synchronized</code>，因此在多线程下可以被多个线程安全使用。</li><li>相对较慢（同步开销）。</li></ul></li><li><strong>StringBuilder（Java 5+）</strong>：<ul><li>可变，<strong>非线程安全</strong>（没有同步），比 <code>StringBuffer</code> 快。</li><li>推荐在单线程或外部已同步的场景下使用。</li></ul></li><li><strong>选择建议</strong>：<ul><li>多线程需要可变字符串：<code>StringBuffer</code>（或外部同步）。</li><li>单线程&#x2F;局部构造字符串：<code>StringBuilder</code>。</li><li>常量字符串或少量拼接：<code>String</code>（编译器对 <code>+</code> 会优化为 <code>StringBuilder</code>）。</li></ul></li></ul><hr><h2 id="11-为什么-String-是不可变的（immutable）？"><a href="#11-为什么-String-是不可变的（immutable）？" class="headerlink" title="11. 为什么 String 是不可变的（immutable）？"></a>11. 为什么 <code>String</code> 是不可变的（immutable）？</h2><p>原因（几条重要理由）：</p><ol><li><strong>安全性</strong>：<code>String</code> 经常用于关键场景（类加载器、网络地址、文件名、权限检查、数据库连接字符串等）。不可变保证在传递引用时不被恶意或意外修改。</li><li><strong>线程安全</strong>：不可变对象固有线程安全，多个线程可共享同一 <code>String</code> 实例而无需同步。</li><li><strong>性能（缓存 hashCode）</strong>：<code>String</code> 的哈希值可缓存（<code>hash</code> 字段），便于作为 Map 的 key，避免重复计算。</li><li><strong>字符串常量池</strong>：可安全地将字面量放入池中重用，不用复制或担心修改。</li><li><strong>优化</strong>：JVM 可进行共享、常量折叠等优化（更易于实现某些编译期&#x2F;运行期优化）。</li></ol><hr><h2 id="12-String-常量池的实现机制？"><a href="#12-String-常量池的实现机制？" class="headerlink" title="12. String 常量池的实现机制？"></a>12. <code>String</code> 常量池的实现机制？</h2><ul><li><strong>概念</strong>：编译期和运行期维护一个字符串池（String Intern Pool），用于存放字符串字面量（literal）和显式 <code>intern()</code> 后的字符串，以便重用相同内容的 <code>String</code> 实例。</li><li><strong>编译期</strong>：源代码中的字符串字面量（如 <code>&quot;abc&quot;</code>）会被放到常量池（编译后的 class 文件常量池），类加载后这些字面量会放入运行时的字符串池。</li><li><strong>运行期</strong>：<ul><li>以前（Java 6 及更早）：字符串常量池在 PermGen（方法区）中。</li><li>Java 7 起：常量池迁移到 Java 堆（运行时常量池也在堆里），避免 PermGen 问题。</li></ul></li><li><strong>intern()</strong>：当调用 <code>s.intern()</code> 时，JVM 会检查池中是否已有相同内容的字符串：<ul><li>若存在，返回池中的引用；</li><li>若不存在，将该字符串的引用加入池并返回它。</li></ul></li><li><strong>编译时优化</strong>：字符串常量的拼接（编译时常量）会在编译期合并，如 <code>&quot;a&quot; + &quot;b&quot;</code> → <code>&quot;ab&quot;</code>，直接放入常量池；而运行时拼接（变量参与）则使用 <code>StringBuilder</code>。</li></ul><hr><h2 id="13-new-String-abc-创建了几个对象？"><a href="#13-new-String-abc-创建了几个对象？" class="headerlink" title="13. new String(&quot;abc&quot;) 创建了几个对象？"></a>13. <code>new String(&quot;abc&quot;)</code> 创建了几个对象？</h2><ul><li><strong>通常情形</strong>：<ul><li>若 <code>&quot;abc&quot;</code> 字面量尚未在常量池中存在，执行 <code>new String(&quot;abc&quot;)</code> 会导致 <strong>两个对象</strong> 被创建：常量池中的 <code>&quot;abc&quot;</code>（一个 <code>String</code>）和堆中通过 <code>new</code> 创建的新的 <code>String</code> 实例（内容通常是对常量池中字符数组的复制或共享，具体实现随 Java 版本而异）。</li><li>如果字面量 <code>&quot;abc&quot;</code> 已经存在于常量池中（例如之前被加载过），那么 <code>new String(&quot;abc&quot;)</code> 只会创建 <strong>一个堆对象</strong>（new 的那个 <code>String</code>）。</li></ul></li><li><strong>注意</strong>：自 Java 7&#x2F;9 后 <code>String</code> 内部实现改变（压缩字符串、byte[] 存储等），但逻辑上上述结论成立：通常 1 或 2 个对象，取决于常量池中是否已存在该字面量。</li></ul><hr><h2 id="14-final-关键字的作用？"><a href="#14-final-关键字的作用？" class="headerlink" title="14. final 关键字的作用？"></a>14. <code>final</code> 关键字的作用？</h2><ul><li><strong>用于类（final class）</strong>：类不可被继承（如 <code>String</code>）。</li><li><strong>用于方法（final 方法）</strong>：方法不能被子类重写（override），用于确保行为不可变。</li><li><strong>用于变量（final 字段&#x2F;局部变量）</strong>：<ul><li>对基本类型：赋值后值不可改变（常量）。</li><li>对引用类型：引用不可改变（不能指向另一个对象），但所指向对象的内部状态仍可变（除非对象本身不可变）。</li><li><code>static final</code> 常用来定义常量（编译期常量）。</li></ul></li><li><strong>用于参数</strong>（方法形参可以声明为 <code>final</code>）：代表方法内不能修改该参数引用&#x2F;值。</li><li><strong>其它用途</strong>：在多线程中，<code>final</code> 字段的写-构造过程被 JMM（Java 内存模型）处理，确保构造完成后其他线程可见（安全发布方面有好处）。</li></ul><hr><h2 id="15-static-关键字的作用？"><a href="#15-static-关键字的作用？" class="headerlink" title="15. static 关键字的作用？"></a>15. <code>static</code> 关键字的作用？</h2><ul><li>用于声明类级别成员（字段、方法、初始化块、嵌套类），不依赖实例。</li><li><strong>static 变量</strong>：类变量，所有实例共享一份。内存中仅有一份副本。</li><li><strong>static 方法</strong>：类方法，可通过 <code>ClassName.method()</code> 调用；不能直接访问非静态成员（因无 this）。</li><li><strong>static 代码块</strong>：类加载时执行一次（用于静态初始化）。</li><li><strong>static 嵌套类</strong>：可以声明为静态的内部类（静态嵌套类），没有外部实例引用。</li></ul><hr><h2 id="16-static-修饰变量、方法、代码块分别意味着什么？"><a href="#16-static-修饰变量、方法、代码块分别意味着什么？" class="headerlink" title="16. static 修饰变量、方法、代码块分别意味着什么？"></a>16. <code>static</code> 修饰变量、方法、代码块分别意味着什么？</h2><ul><li><strong>static 变量（类变量）</strong>：<ul><li>随类加载而创建，所有对象共享同一份数据。</li><li>可通过 <code>ClassName.field</code> 或 <code>instance.field</code>（不推荐）访问。</li></ul></li><li><strong>static 方法</strong>：<ul><li>属于类，调用时无需实例。</li><li>不能使用 <code>this</code>、不能直接访问非静态成员。</li><li>可作为工具方法（如 <code>Math.abs()</code>）。</li></ul></li><li><strong>static 代码块</strong>：<ul><li>在类加载阶段执行一次，用于复杂静态初始化（比如初始化静态常量、加载本地库等）。</li><li>执行顺序：静态块按定义顺序执行，类加载时运行（在实例化之前）。</li></ul></li></ul><hr><h2 id="17-static-和-final-能一起用吗？"><a href="#17-static-和-final-能一起用吗？" class="headerlink" title="17. static 和 final 能一起用吗？"></a>17. <code>static</code> 和 <code>final</code> 能一起用吗？</h2><ul><li><p><strong>能</strong>。<code>static final</code> 常用于定义类常量（尤其是基本类型和 <code>String</code>），例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static final int MAX = 100;</span><br><span class="line">public static final String NAME = &quot;abc&quot;;</span><br></pre></td></tr></table></figure></li><li><p><strong>区别</strong>：</p><ul><li>如果是编译期常量（<code>static final</code> 基本类型或 <code>String</code> 且在编译时可以确定），编译器会将其内联到使用处（被引用的类编译后看到的是常量值），注意跨模块修改可能导致需要重新编译引用方。</li><li>如果是 <code>static final</code> 引用对象且不是编译期常量，则引用本身不可变，但对象内容可能可变。</li></ul></li></ul><hr><h2 id="18-static-内部类和非静态内部类的区别？"><a href="#18-static-内部类和非静态内部类的区别？" class="headerlink" title="18. static 内部类和非静态内部类的区别？"></a>18. <code>static</code> 内部类和非静态内部类的区别？</h2><ul><li><strong>静态内部类（static nested class）</strong>：<ul><li>相当于外部类的一个静态成员。</li><li><strong>没有</strong>对外部类实例的隐式引用（不能直接访问外部类的非静态成员）。</li><li>可以像普通类那样实例化：<code>Outer.StaticInner inner = new Outer.StaticInner();</code></li></ul></li><li><strong>非静态内部类（inner class）</strong>：<ul><li>每个实例隐式持有一个外部类实例引用（<code>Outer.this</code>），可以直接访问外部类的所有成员（包括私有成员）。</li><li>创建方式：<code>Outer outer = new Outer(); Outer.Inner inner = outer.new Inner();</code></li><li>占用外部类对象的内存引用，可能导致内存泄露（如果长期持有内部类实例导致外部类不能被回收）。</li></ul></li><li><strong>选择原则</strong>：如果内部类不需要访问外部实例成员，优先使用 <code>static</code> 嵌套类，避免额外引用。</li></ul><hr><h2 id="19-Java-中的-this-和-super-的区别？"><a href="#19-Java-中的-this-和-super-的区别？" class="headerlink" title="19. Java 中的 this 和 super 的区别？"></a>19. Java 中的 <code>this</code> 和 <code>super</code> 的区别？</h2><ul><li><strong>this</strong>：<ul><li>引用当前对象的引用。</li><li>用于访问当前类的实例变量、调用当前类的其他构造器（<code>this(...)</code>）、或传递当前对象引用。</li></ul></li><li><strong>super</strong>：<ul><li>引用当前对象的父类部分。</li><li>用于访问父类被覆盖的方法（<code>super.method()</code>）、父类字段（若有同名字段）、以及在子类构造器第一行调用父类构造器（<code>super(...)</code>）。</li></ul></li><li><strong>注意</strong>：<ul><li><code>this()</code> 或 <code>super()</code> 必须在构造器的第一行（两者不能同时出现）。</li><li><code>super</code> 不能用于访问父类的 private 成员（编译期限制）。</li></ul></li></ul><hr><h2 id="20-Java-中构造方法能否被重写？"><a href="#20-Java-中构造方法能否被重写？" class="headerlink" title="20. Java 中构造方法能否被重写？"></a>20. Java 中构造方法能否被重写？</h2><ul><li><strong>不能</strong>。重写（override）适用于实例方法，构造方法不是继承的成员，子类不能重写父类的构造器。</li><li><strong>可以重载（overload）</strong>：在同一类中同名构造器有不同参数列表属于重载。</li><li>子类构造器可通过 <code>super(...)</code> 显式调用父类构造器来完成父类初始化。</li></ul><hr><h2 id="21-接口和抽象类的区别？"><a href="#21-接口和抽象类的区别？" class="headerlink" title="21. 接口和抽象类的区别？"></a>21. 接口和抽象类的区别？</h2><ul><li><strong>接口（interface）</strong>：<ul><li>早期（Java 7 之前）：只包含抽象方法（默认是 <code>public abstract</code>）和 <code>public static final</code> 常量。</li><li>Java 8+：可以包含 <code>default</code> 方法与 <code>static</code> 方法（可以有部分实现）；Java 9+ 允许 <code>private</code> 方法。</li><li>支持多继承（一个类可以实现多个接口）。</li><li>没有实例字段（除 <code>static final</code> 常量外）。</li></ul></li><li><strong>抽象类（abstract class）</strong>：<ul><li>可以有实例字段（非静态成员变量）、已有实现的方法（具体方法）、构造器。</li><li>适合表示一类有共同行为并共享状态的类层次。</li><li>类只能单继承（只能继承一个抽象类）。</li></ul></li><li><strong>选择建议</strong>：<ul><li>如果需要多继承行为、只定义方法契约且不需要状态，使用接口。</li><li>如果需要提供共有实现和状态，使用抽象类。</li></ul></li></ul><hr><h2 id="22-接口中可以有-default-方法和-static-方法吗？"><a href="#22-接口中可以有-default-方法和-static-方法吗？" class="headerlink" title="22. 接口中可以有 default 方法和 static 方法吗？"></a>22. 接口中可以有 <code>default</code> 方法和 <code>static</code> 方法吗？</h2><ul><li><strong>可以（Java 8 起）</strong>。<ul><li><code>default</code> 方法：为实现类提供默认实现，避免破坏已有实现（接口演化）。实现类可以覆盖（override）。</li><li><code>static</code> 方法：属于接口自身，可以通过 <code>InterfaceName.method()</code> 调用，不能通过实例调用。</li></ul></li><li>Java 9 及以后还可有 <code>private</code> 方法，供接口内部复用实现逻辑。</li></ul><hr><h2 id="23-Java-8-接口新增了什么？"><a href="#23-Java-8-接口新增了什么？" class="headerlink" title="23. Java 8 接口新增了什么？"></a>23. Java 8 接口新增了什么？</h2><ul><li>Java 8 在接口中新增了 <strong>default 方法</strong> 和 <strong>static 方法</strong>，允许接口提供带实现的方法，从而便于接口的演化（向后兼容）。这也是 Java 8 引入函数式编程支持的基础之一（允许接口作为函数式接口）。</li></ul><hr><h2 id="24-Java-8-有什么新特性，并详细介绍（重点）"><a href="#24-Java-8-有什么新特性，并详细介绍（重点）" class="headerlink" title="24. Java 8 有什么新特性，并详细介绍（重点）"></a>24. Java 8 有什么新特性，并详细介绍（重点）</h2><hr><h1 id="一、Java-8-新特性深入解析"><a href="#一、Java-8-新特性深入解析" class="headerlink" title="一、Java 8 新特性深入解析"></a>一、Java 8 新特性深入解析</h1><h2 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1. Lambda 表达式"></a>1. Lambda 表达式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>匿名函数，允许把行为作为参数传递。</li><li>简化匿名内部类写法，实现函数式编程。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">Collections.sort(list, (s1, s2) -&gt; s1.length() - s2.length());</span><br></pre></td></tr></table></figure><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>编译器生成静态&#x2F;实例方法 + <code>invokedynamic</code> 指令。</li><li>JVM 调用 <code>LambdaMetafactory</code> 动态生成函数对象，实现 <strong>函数式接口</strong>。</li><li>捕获外部变量通过闭包机制存储（必须是 <code>effectively final</code>）。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>语法简洁</li><li>可作为参数传递行为</li><li>性能高于匿名内部类（减少对象创建）</li></ul><hr><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>仅有一个抽象方法的接口，用作 Lambda 表达式的目标类型。</li><li>可用 <code>@FunctionalInterface</code> 标识。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Converter&lt;String, Integer&gt; c = Integer::valueOf;</span><br><span class="line">System.out.println(c.convert(&quot;123&quot;)); // 123</span><br></pre></td></tr></table></figure><h3 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>Lambda 表达式编译时生成实现函数式接口的函数对象。</li><li>捕获变量通过闭包对象保存。</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>简化匿名类</li><li>支持函数式编程</li><li>可与 Stream &#x2F; Optional 等结合</li></ul><hr><h2 id="3-Stream-API"><a href="#3-Stream-API" class="headerlink" title="3. Stream API"></a>3. Stream API</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li>对集合进行声明式操作（过滤、映射、归约）。</li><li>支持 <strong>惰性求值</strong> 和 <strong>并行处理</strong>。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;);</span><br><span class="line">List&lt;String&gt; filtered = names.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt; 3)</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">System.out.println(filtered); // [ALICE, CHARLIE]</span><br></pre></td></tr></table></figure><h3 id="底层原理-2"><a href="#底层原理-2" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>Stream 是流水线对象，中间操作返回新的 Stream，终端操作触发计算。</li><li>串行流：顺序迭代器处理</li><li>并行流：ForkJoinPool 分块处理</li></ul><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>声明式、链式操作</li><li>支持并行</li><li>可与 Lambda &#x2F; 方法引用结合</li></ul><hr><h2 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul><li>Lambda 表达式的简化写法，引用现有方法。</li><li>类型：<ol><li>静态方法引用：<code>ClassName::staticMethod</code></li><li>实例方法引用：<code>instance::method</code></li><li>构造器引用：<code>ClassName::new</code></li></ol></li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;);</span><br><span class="line">names.forEach(System.out::println); // 实例方法引用</span><br><span class="line">Supplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::new; // 构造器引用</span><br></pre></td></tr></table></figure><h3 id="底层原理-3"><a href="#底层原理-3" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>编译器转成 Lambda 表达式 + invokedynamic。</li><li>JVM 生成实现函数式接口的函数对象，内部持有方法引用。</li></ul><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul><li>简洁直观</li><li>可减少 Lambda 代码</li><li>与 Stream &#x2F; Optional 配合使用</li></ul><hr><h2 id="5-java-time-API"><a href="#5-java-time-API" class="headerlink" title="5. java.time API"></a>5. java.time API</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><ul><li>替代 <code>Date</code> &#x2F; <code>Calendar</code>，不可变、线程安全。</li><li>核心类：<ul><li><code>LocalDate</code> &#x2F; <code>LocalTime</code> &#x2F; <code>LocalDateTime</code>（无时区）</li><li><code>ZonedDateTime</code>（带时区）</li><li><code>Duration</code> &#x2F; <code>Period</code>（时间段）</li></ul></li></ul><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plusDays(1);</span><br><span class="line">ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(&quot;Asia/Singapore&quot;));</span><br><span class="line">System.out.println(tomorrow);</span><br><span class="line">System.out.println(zdt);</span><br></pre></td></tr></table></figure><h3 id="底层原理-4"><a href="#底层原理-4" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>内部字段 <code>final</code> 保存值，不可变。</li><li>工厂方法创建对象，链式操作返回新对象。</li><li>使用 enum + 整型&#x2F;字节优化存储（如 LocalDate 年月日用 int）。</li></ul><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul><li>不可变，线程安全</li><li>链式操作，易组合</li><li>支持各种历法和时区计算</li></ul><hr><h2 id="6-Optional"><a href="#6-Optional" class="headerlink" title="6. Optional"></a>6. Optional</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><ul><li>容器对象，防止 <code>NullPointerException</code>。</li><li>可以包含值或为空（empty）。</li></ul><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt1 = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">Optional&lt;String&gt; opt2 = Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(opt1.isPresent()); <span class="comment">// true</span></span><br><span class="line">System.out.println(opt2.orElse(<span class="string">&quot;Default&quot;</span>)); <span class="comment">// Default</span></span><br><span class="line">opt1.map(String::toUpperCase).ifPresent(System.out::println); <span class="comment">// HELLO</span></span><br></pre></td></tr></table></figure><h3 id="底层原理-5"><a href="#底层原理-5" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>内部 <code>value</code> 字段存储非空值，空值使用单例 <code>EMPTY</code>。</li><li><code>map</code> &#x2F; <code>flatMap</code> &#x2F; <code>filter</code> 返回新的 Optional，对象不可变。</li><li>与 Lambda &#x2F; 函数式接口结合实现链式安全操作。</li></ul><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><ul><li>避免显式 null 判断</li><li>支持链式调用</li><li>可与 Stream &#x2F; Lambda 配合</li></ul><hr><h2 id="Java-8-六大核心特性底层对比表"><a href="#Java-8-六大核心特性底层对比表" class="headerlink" title="Java 8 六大核心特性底层对比表"></a>Java 8 六大核心特性底层对比表</h2><table><thead><tr><th>特性</th><th>底层实现</th><th>核心原理</th><th>优势</th></tr></thead><tbody><tr><td>Lambda</td><td>invokedynamic + LambdaMetafactory</td><td>动态生成函数对象</td><td>简洁、性能高</td></tr><tr><td>函数式接口</td><td>单抽象方法接口</td><td>捕获变量通过闭包存储</td><td>简化匿名类，函数式编程</td></tr><tr><td>Stream API</td><td>流水线 + 延迟求值</td><td>中间操作惰性，终端触发</td><td>声明式、可并行</td></tr><tr><td>方法引用</td><td>Lambda 简化语法 + invokedynamic</td><td>内部持有方法引用</td><td>简洁直观，减少代码</td></tr><tr><td>java.time</td><td>不可变对象 + 工厂方法</td><td>final字段保存值，链式返回新对象</td><td>线程安全，可组合</td></tr><tr><td>Optional</td><td>包装对象 + 单例 EMPTY</td><td>不可变容器，函数式链式调用</td><td>避免 NPE，安全链式操作</td></tr></tbody></table><hr><h1 id="二、synchronized-底层原理深入解析"><a href="#二、synchronized-底层原理深入解析" class="headerlink" title="二、synchronized 底层原理深入解析"></a>二、synchronized 底层原理深入解析</h1><h2 id="1-JVM-锁的类型"><a href="#1-JVM-锁的类型" class="headerlink" title="1. JVM 锁的类型"></a>1. JVM 锁的类型</h2><table><thead><tr><th>锁类型</th><th>特点</th><th>性能</th></tr></thead><tbody><tr><td>偏向锁 (Biased Lock)</td><td>无竞争时偏向第一个线程，轻量</td><td>高</td></tr><tr><td>轻量级锁 (Lightweight)</td><td>竞争少时使用 CAS 升级锁</td><td>中</td></tr><tr><td>重量级锁 (Monitor)</td><td>高竞争时使用 OS mutex，阻塞线程</td><td>低</td></tr></tbody></table><hr><h2 id="2-synchronized-对象头结构"><a href="#2-synchronized-对象头结构" class="headerlink" title="2. synchronized 对象头结构"></a>2. synchronized 对象头结构</h2><ul><li>每个对象在 JVM 内存中都有 <strong>对象头（Mark Word）</strong>，存储锁信息、哈希码、GC 标记等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象头 Mark Word (32/64bit)</span><br><span class="line">+----------------+----------------+----------------+</span><br><span class="line">| HashCode       | GC info        | Lock info      |</span><br><span class="line">+----------------+----------------+----------------+</span><br></pre></td></tr></table></figure><ul><li><strong>锁标记位</strong>：<ul><li>00：无锁</li><li>01：偏向锁</li><li>10：轻量级锁</li><li>11：重量级锁</li></ul></li></ul><hr><h2 id="3-synchronized-执行流程"><a href="#3-synchronized-执行流程" class="headerlink" title="3. synchronized 执行流程"></a>3. synchronized 执行流程</h2><h3 id="a-偏向锁（无竞争）"><a href="#a-偏向锁（无竞争）" class="headerlink" title="a) 偏向锁（无竞争）"></a>a) 偏向锁（无竞争）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程获取锁 -&gt; 在对象头打上线程ID -&gt; 执行 -&gt; 释放锁 -&gt; 保持偏向状态</span><br></pre></td></tr></table></figure><h3 id="b-轻量级锁（CAS竞争）"><a href="#b-轻量级锁（CAS竞争）" class="headerlink" title="b) 轻量级锁（CAS竞争）"></a>b) 轻量级锁（CAS竞争）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程尝试CAS抢锁 -&gt; 成功：持有锁 -&gt; 执行 -&gt; 释放</span><br><span class="line">                      |-&gt; 失败：升级为重量级锁</span><br></pre></td></tr></table></figure><h3 id="c-重量级锁（阻塞）"><a href="#c-重量级锁（阻塞）" class="headerlink" title="c) 重量级锁（阻塞）"></a>c) 重量级锁（阻塞）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程无法获取锁 -&gt; 阻塞（OS等待队列） -&gt; 被唤醒 -&gt; 获取锁 -&gt; 执行 -&gt; 释放锁</span><br></pre></td></tr></table></figure><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|  synchronized()  |</span><br><span class="line">+------------------+</span><br><span class="line">          |</span><br><span class="line">    JVM对象头Mark Word</span><br><span class="line">          |</span><br><span class="line">+------------------------+</span><br><span class="line">| 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure><hr><h2 id="4-synchronized-方法示例"><a href="#4-synchronized-方法示例" class="headerlink" title="4. synchronized 方法示例"></a>4. synchronized 方法示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>锁对象</strong>：实例方法锁住 <code>this</code>，静态方法锁住类对象 <code>ClassName.class</code>。</li><li><strong>效果</strong>：同一时间只有一个线程能进入 <code>increment()</code>，保证 <code>count++</code> 操作的原子性。</li></ul><hr><h2 id="5-JVM-优化"><a href="#5-JVM-优化" class="headerlink" title="5. JVM 优化"></a>5. JVM 优化</h2><ul><li><strong>锁消除</strong>：编译器或 JIT 可检测无竞争情况，消除同步锁。</li><li><strong>锁粗化</strong>：把多次连续的小范围锁合并，减少加锁次数。</li><li><strong>偏向锁 &#x2F; 轻量级锁 &#x2F; 重量级锁升级</strong>：动态适应竞争情况，兼顾性能与正确性。</li></ul><h2 id="25-多态的实现机制是什么？"><a href="#25-多态的实现机制是什么？" class="headerlink" title="25.多态的实现机制是什么？"></a>25.多态的实现机制是什么？</h2><ul><li><strong>概念</strong>：同一操作作用于不同对象时表现出不同的行为（主要表现为方法的动态绑定）。</li><li><strong>实现机制</strong>：<ul><li><strong>编译时</strong>：根据引用类型检查方法签名（静态类型检查）。</li><li><strong>运行时</strong>：实际调用的方法根据对象的实际类型（运行时类型）决定；即 <strong>动态绑定（dynamic dispatch）</strong>。</li><li>JVM 通常通过 <strong>虚方法表（vtable）&#x2F;方法查找机制</strong> 实现。调用一个非 <code>static</code>、非 <code>private</code>、非 <code>final</code> 的方法时，会在运行时查找实际类的实现并调用。</li></ul></li><li><strong>结果</strong>：子类可以覆盖父类方法，调用者使用父类引用指向子类对象时，调用的是子类的覆盖方法（运行时决定）。</li><li><strong>注意</strong>：<code>static</code>、<code>private</code>、<code>final</code> 方法不会被动态绑定（是静态绑定）。</li></ul><hr><h2 id="26-方法重载（overload）和方法重写（override）的区别？"><a href="#26-方法重载（overload）和方法重写（override）的区别？" class="headerlink" title="26. 方法重载（overload）和方法重写（override）的区别？"></a>26. 方法重载（overload）和方法重写（override）的区别？</h2><ul><li><p><strong>方法重载（Overloading）</strong>：</p><ul><li>同一类中方法名相同、参数列表不同（参数类型&#x2F;个数&#x2F;顺序），返回类型可以不同。</li><li>编译时决定（重载解析在编译期完成），与继承关系无关。</li></ul></li><li><p><strong>方法重写（Overriding）</strong>：</p><ul><li>子类定义与父类相同方法签名（方法名 + 参数类型相同）的实现，目的是改变&#x2F;扩展父类行为。</li><li>运行时动态绑定，必须满足访问权限不能更严格，抛出的受检异常不能超过父类版本等规则。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overload</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(String s)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// override</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;&#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; <span class="meta">@Override</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;&#125; &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="27-Java-支持多继承吗？如何实现类似效果？"><a href="#27-Java-支持多继承吗？如何实现类似效果？" class="headerlink" title="27. Java 支持多继承吗？如何实现类似效果？"></a>27. Java 支持多继承吗？如何实现类似效果？</h2><ul><li><strong>类的多继承</strong>：Java <strong>不支持类的多继承</strong>（不能继承多个类），以避免菱形继承问题（diamond problem）。</li><li><strong>实现类似效果的方法</strong>：<ul><li><strong>接口多实现</strong>：一个类可以实现多个接口（Java 8 的 <code>default</code> 方法也带来类似多继承方法实现的可能，但有冲突解决规则）。</li><li><strong>组合&#x2F;委托（composition&#x2F;delegation）</strong>：在类中持有其它类的实例并把调用委托给它们（优于继承的面向对象设计原则）。</li></ul></li><li><strong>接口冲突解决</strong>：若多个接口提供相同默认方法，类必须重写该方法并明确调用哪个接口的默认实现（<code>InterfaceName.super.method()</code>）。</li></ul><hr><h2 id="28-Java-的四种访问修饰符？"><a href="#28-Java-的四种访问修饰符？" class="headerlink" title="28. Java 的四种访问修饰符？"></a>28. Java 的四种访问修饰符？</h2><ul><li><code>public</code>：对所有类可见（任何包）。</li><li><code>protected</code>：对同包类和子类可见（即同包或子类可以访问）。</li><li><strong>默认（包私有，package-private）</strong>（不写修饰符）：对同包类可见，包外不可见。</li><li><code>private</code>：仅在本类内可见，包外&#x2F;子类不可访问（子类无法直接访问父类 private 成员）。</li><li><strong>注意</strong>：对类（顶层类）只能使用 <code>public</code> 或默认（包私有），不能声明为 <code>private</code>&#x2F;<code>protected</code>。</li></ul><hr><h2 id="29-transient-关键字的作用？"><a href="#29-transient-关键字的作用？" class="headerlink" title="29. transient 关键字的作用？"></a>29. <code>transient</code> 关键字的作用？</h2><ul><li>用于标记字段在 Java 序列化（<code>Serializable</code>）过程中<strong>不被序列化</strong>。</li><li>被标记为 <code>transient</code> 的字段在序列化后不会写入序列化流，反序列化时这些字段会以默认值恢复（基本类型 0，引用类型 <code>null</code>）。</li><li>常用于敏感信息（密码）、不需要持久化的缓存字段、或可重建的状态字段。</li><li>注意：<code>static</code> 字段本身也不会被序列化（因为是类级别，不属于实例状态）。</li></ul><hr><h2 id="30-volatile-关键字的作用？"><a href="#30-volatile-关键字的作用？" class="headerlink" title="30. volatile 关键字的作用？"></a>30. <code>volatile</code> 关键字的作用？</h2><ul><li><strong>可见性</strong>：保证对 <code>volatile</code> 变量的写入对其它线程立即可见（读取总是从主内存而不是线程缓存读取）。</li><li><strong>禁止指令重排序（部分）</strong>：读&#x2F;写 <code>volatile</code> 存在的内存屏障能保证一定的有序性（写 <code>volatile</code> 发生在后续读的可见性上，更多细节参考 JMM）。</li><li><strong>不保证原子性</strong>：对单次读&#x2F;写操作是原子的（对 <code>long</code>&#x2F;<code>double</code> 在 Java 5 后也保证原子），但非原子操作（如 <code>i++</code>）不是原子的。</li><li><strong>典型用途</strong>：<ul><li>状态标志（如 <code>volatile boolean running</code>）。</li><li>用于实现双重检查锁定（DCL）单例中的 <code>instance</code>（在 Java 5+ 环境下有效）。</li></ul></li><li><strong>与 synchronized 比较</strong>：<ul><li><code>volatile</code> 轻量，只保证可见性与部分有序性，不保证互斥；适用于简单状态通信。</li><li><code>synchronized</code> 提供互斥和可见性保证（更重），并可配合 <code>wait/notify</code>。</li></ul></li></ul><hr><h2 id="31-synchronized-的作用及底层原理？"><a href="#31-synchronized-的作用及底层原理？" class="headerlink" title="31. synchronized 的作用及底层原理？"></a>31. <code>synchronized</code> 的作用及底层原理？</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>互斥（排它）</strong>：保证同一时间只有一个线程可以执行被 <code>synchronized</code> 修饰的代码块或方法（针对同一把锁）。</li><li><strong>可见性</strong>：进入&#x2F;退出同步块会建立 happens-before 关系，确保锁释放前的写对随后获取该锁的线程可见。</li><li><strong>用途</strong>：保护临界区、确保多个线程对共享可变状态的安全访问。</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul><li><strong>方法级别</strong>：<ul><li><code>synchronized void m() &#123; ... &#125;</code>：等价于 <code>synchronized(this)</code>（实例方法）或 <code>synchronized (ClassName.class)</code>（静态方法）。</li></ul></li><li><strong>代码块级别</strong>：<ul><li><code>synchronized(this) &#123; ... &#125;</code> 或 <code>synchronized(lockObj) &#123; ... &#125;</code> 更灵活，能减小锁的粒度。</li></ul></li></ul><h3 id="底层原理（HotSpot-实现概要）"><a href="#底层原理（HotSpot-实现概要）" class="headerlink" title="底层原理（HotSpot 实现概要）"></a>底层原理（HotSpot 实现概要）</h3><ul><li>JVM 使用对象头（object header）中的 <strong>mark word</strong> 和关联数据结构维护锁状态。</li><li>锁优化策略（为提升性能，HotSpot 引入若干优化）：<ol><li><strong>偏向锁（Biased Locking）</strong>：在没有竞争的情况下，锁会偏向于第一次获得它的线程，重复获取无需 CAS，减少开销。</li><li><strong>轻量级锁（Lightweight Locking）</strong>：使用 CAS 操作在栈上记录加锁记录，避免进入重量级监视器（monitor）。</li><li><strong>重量级锁（Monitor&#x2F;Mutex）</strong>：当竞争激烈或 CAS 失败时，升级为重量级锁，使用操作系统互斥量（可能涉及线程阻塞&#x2F;唤醒）。</li></ol></li><li><code>monitorenter</code> &#x2F; <code>monitorexit</code> 是字节码指令（由编译器&#x2F;字节码生成器生成）。</li><li>JIT 编译器可进行锁消除、锁粗化、锁优化等（当能证明无并发访问或已外部同步时）。</li></ul><h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait/notify&#x2F;notifyAll"></a><code>wait/notify</code>&#x2F;<code>notifyAll</code></h3><ul><li><code>Object.wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 必须在持有对象监视器（即在 <code>synchronized</code> 块内）时调用，用于线程间协作（条件等待&#x2F;通知）。</li><li><code>wait()</code> 会释放锁并进入等待队列；<code>notify()</code> 唤醒等待队列中的一个线程（被唤醒线程在重新获得锁后继续）。</li></ul><h3 id="注意与陷阱"><a href="#注意与陷阱" class="headerlink" title="注意与陷阱"></a>注意与陷阱</h3><ul><li>锁粒度：避免用过大锁（如 <code>synchronized</code> 在方法头部锁住大量操作），谨慎使用 <code>String</code> 或装箱对象作为锁（可能会导致多个实例共用同一锁或锁被外部持有）。</li><li>死锁：多线程锁顺序不当可能死锁；设计时谨防。</li><li>性能：在高并发下可考虑使用 <code>java.util.concurrent</code> 包（<code>ReentrantLock</code>、<code>ConcurrentHashMap</code>、<code>AtomicXxx</code>）等更细粒度、高性能的并发工具。</li></ul><hr><h2 id="二、面向对象编程（OOP）"><a href="#二、面向对象编程（OOP）" class="headerlink" title="二、面向对象编程（OOP）"></a>二、面向对象编程（OOP）</h2><hr><h2 id="1-面向对象的三大特性是什么？"><a href="#1-面向对象的三大特性是什么？" class="headerlink" title="1. 面向对象的三大特性是什么？"></a><strong>1. 面向对象的三大特性是什么？</strong></h2><ul><li><strong>封装（Encapsulation）</strong>：隐藏实现细节，只暴露必要接口。</li><li><strong>继承（Inheritance）</strong>：子类复用父类属性和方法，扩展功能。</li><li><strong>多态（Polymorphism）</strong>：同一接口，不同实现。表现为方法重写、方法重载。</li></ul><hr><h2 id="2-封装的作用是什么？"><a href="#2-封装的作用是什么？" class="headerlink" title="2. 封装的作用是什么？"></a><strong>2. 封装的作用是什么？</strong></h2><ul><li>隐藏对象内部实现细节，只暴露必要接口。</li><li>提高代码复用性、安全性，避免数据被随意修改。</li><li>例如：类的成员变量用 <code>private</code>，提供 <code>getter/setter</code> 访问。</li></ul><hr><h2 id="3-多态的优点是什么？"><a href="#3-多态的优点是什么？" class="headerlink" title="3. 多态的优点是什么？"></a><strong>3. 多态的优点是什么？</strong></h2><ul><li><strong>接口统一</strong>：不同实现类可通过父类&#x2F;接口操作。</li><li><strong>可扩展性强</strong>：新增子类不影响原有代码。</li><li><strong>解耦</strong>：调用方只依赖抽象，而不依赖具体实现。</li><li>例：<code>List list = new ArrayList();</code>，后续可换成 <code>LinkedList</code>。</li></ul><hr><h2 id="4-重写方法时返回值能否不同？"><a href="#4-重写方法时返回值能否不同？" class="headerlink" title="4. 重写方法时返回值能否不同？"></a><strong>4. 重写方法时返回值能否不同？</strong></h2><ul><li><strong>不能完全不同</strong>。</li><li>Java 允许 <strong>协变返回类型</strong>：子类方法的返回值类型可以是父类方法返回值的子类。</li><li>例如：父类返回 <code>Number</code>，子类可以返回 <code>Integer</code>。</li></ul><hr><h2 id="5-构造函数能否被继承？"><a href="#5-构造函数能否被继承？" class="headerlink" title="5. 构造函数能否被继承？"></a><strong>5. 构造函数能否被继承？</strong></h2><ul><li><strong>不能继承</strong>，因为构造函数名必须与类名相同。</li><li>但子类可通过 <code>super(...)</code> 调用父类构造方法。</li></ul><hr><h2 id="6-构造函数能否-private？"><a href="#6-构造函数能否-private？" class="headerlink" title="6. 构造函数能否 private？"></a><strong>6. 构造函数能否 private？</strong></h2><ul><li><strong>可以</strong>，常见于单例模式（饿汉&#x2F;懒汉&#x2F;枚举单例）。</li><li>作用：禁止外部 <code>new</code>，只能通过类提供的方法获取实例。</li></ul><hr><h2 id="7-单例模式的几种实现方式？"><a href="#7-单例模式的几种实现方式？" class="headerlink" title="7. 单例模式的几种实现方式？"></a><strong>7. 单例模式的几种实现方式？</strong></h2><ol><li>饿汉式（类加载即实例化，线程安全，但可能浪费内存）。</li><li>懒汉式（延迟加载，需加 <code>synchronized</code> 保证线程安全）。</li><li>双重检查锁（DCL，volatile + synchronized，性能优）。</li><li>静态内部类（推荐，利用类加载机制，线程安全）。</li><li>枚举单例（最佳实践，防止反射和反序列化攻击）。</li></ol><hr><h2 id="8-饿汉式和懒汉式单例的区别？"><a href="#8-饿汉式和懒汉式单例的区别？" class="headerlink" title="8. 饿汉式和懒汉式单例的区别？"></a><strong>8. 饿汉式和懒汉式单例的区别？</strong></h2><ul><li><strong>饿汉式</strong>：类加载时实例化 → 线程安全，启动时可能浪费内存。</li><li><strong>懒汉式</strong>：第一次使用时才实例化 → 节省资源，但需加锁保证线程安全。</li></ul><hr><h2 id="9-为什么要使用内部类？"><a href="#9-为什么要使用内部类？" class="headerlink" title="9. 为什么要使用内部类？"></a><strong>9. 为什么要使用内部类？</strong></h2><ul><li>内部类可以 <strong>访问外部类的私有成员</strong>。</li><li>更好地组织代码，使逻辑更紧密。</li><li>在需要回调或事件监听时常用。</li></ul><hr><h2 id="10-成员内部类、局部内部类、静态内部类的区别？"><a href="#10-成员内部类、局部内部类、静态内部类的区别？" class="headerlink" title="10. 成员内部类、局部内部类、静态内部类的区别？"></a><strong>10. 成员内部类、局部内部类、静态内部类的区别？</strong></h2><ul><li><strong>成员内部类</strong>：依附于外部类实例，可以访问外部类实例变量。</li><li><strong>局部内部类</strong>：定义在方法内部，作用范围仅在方法内。</li><li><strong>静态内部类</strong>：不依赖外部类实例，只能访问外部类静态成员。</li></ul><hr><h2 id="11-Java-中对象的创建方式有哪些？"><a href="#11-Java-中对象的创建方式有哪些？" class="headerlink" title="11. Java 中对象的创建方式有哪些？"></a><strong>11. Java 中对象的创建方式有哪些？</strong></h2><ol><li><code>new</code> 关键字。</li><li>反射 <code>Class.newInstance()</code>。</li><li><code>Constructor.newInstance()</code>。</li><li>通过 <code>clone()</code>。</li><li>通过反序列化 <code>ObjectInputStream.readObject()</code>。</li></ol><hr><h2 id="12-对象之间的浅拷贝和深拷贝的区别？"><a href="#12-对象之间的浅拷贝和深拷贝的区别？" class="headerlink" title="12. 对象之间的浅拷贝和深拷贝的区别？"></a><strong>12. 对象之间的浅拷贝和深拷贝的区别？</strong></h2><ul><li><strong>浅拷贝</strong>：只复制对象本身，引用字段仍指向同一对象。</li><li><strong>深拷贝</strong>：连引用对象也复制一份，完全独立。</li></ul><hr><h2 id="13-clone-方法的原理？"><a href="#13-clone-方法的原理？" class="headerlink" title="13. clone() 方法的原理？"></a><strong>13. clone() 方法的原理？</strong></h2><ul><li>来自 <code>Object</code> 类，默认是 <strong>浅拷贝</strong>。</li><li>必须实现 <code>Cloneable</code> 接口，否则抛出 <code>CloneNotSupportedException</code>。</li><li>可重写 <code>clone()</code> 实现深拷贝。</li></ul><hr><h2 id="14-为什么-Java-不支持多继承？"><a href="#14-为什么-Java-不支持多继承？" class="headerlink" title="14. 为什么 Java 不支持多继承？"></a><strong>14. 为什么 Java 不支持多继承？</strong></h2><ul><li>为了避免 <strong>菱形继承问题</strong>（多个父类方法冲突）。</li><li>Java 使用 <strong>接口</strong> 来实现多继承特性。</li></ul><hr><h2 id="15-Java-是值传递还是引用传递？"><a href="#15-Java-是值传递还是引用传递？" class="headerlink" title="15. Java 是值传递还是引用传递？"></a><strong>15. Java 是值传递还是引用传递？</strong></h2><ul><li>Java <strong>只有值传递</strong>。</li><li>对象参数传递的是 <strong>引用的副本</strong>（值），但指向同一对象。</li></ul><hr><h2 id="16-方法参数传递时是如何处理对象的？"><a href="#16-方法参数传递时是如何处理对象的？" class="headerlink" title="16. 方法参数传递时是如何处理对象的？"></a><strong>16. 方法参数传递时是如何处理对象的？</strong></h2><ul><li>方法内修改对象的字段 → 会影响外部对象。</li><li>方法内给引用变量重新赋值 → 不会影响外部对象。</li></ul><hr><h2 id="17-封装性体现在哪些方面？"><a href="#17-封装性体现在哪些方面？" class="headerlink" title="17. 封装性体现在哪些方面？"></a><strong>17. 封装性体现在哪些方面？</strong></h2><ul><li>使用 <code>private</code> 修饰成员变量。</li><li>提供 <code>getter/setter</code> 控制访问权限。</li><li>使用访问修饰符（public&#x2F;protected&#x2F;default&#x2F;private）控制类和方法的可见性。</li></ul><hr><h2 id="18-为什么需要继承？"><a href="#18-为什么需要继承？" class="headerlink" title="18. 为什么需要继承？"></a><strong>18. 为什么需要继承？</strong></h2><ul><li>代码复用（减少重复）。</li><li>提高扩展性（子类扩展父类功能）。</li><li>实现多态，解耦业务逻辑。</li></ul><hr><h2 id="19-重写-Object-类的-toString-方法的意义？"><a href="#19-重写-Object-类的-toString-方法的意义？" class="headerlink" title="19. 重写 Object 类的 toString 方法的意义？"></a><strong>19. 重写 Object 类的 toString 方法的意义？</strong></h2><ul><li>提高可读性，方便调试和日志记录。</li><li>默认 <code>toString()</code> 打印类名+hashcode，不直观。</li><li>重写后可打印对象核心字段信息。</li></ul><hr><h2 id="20-重写-Object-类的-equals-方法时需要注意什么？"><a href="#20-重写-Object-类的-equals-方法时需要注意什么？" class="headerlink" title="20. 重写 Object 类的 equals 方法时需要注意什么？"></a><strong>20. 重写 Object 类的 equals 方法时需要注意什么？</strong></h2><ul><li>必须满足 <strong>自反性、对称性、传递性、一致性</strong>。</li><li>与 <code>hashCode()</code> 保持一致：相等对象必须有相同的 hashCode。</li><li>避免 <code>NullPointerException</code>。</li></ul><hr><h2 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h2><hr><h3 id="1-Java-的异常体系结构？"><a href="#1-Java-的异常体系结构？" class="headerlink" title="1. Java 的异常体系结构？"></a>1. Java 的异常体系结构？</h3><ul><li><strong>顶层类</strong>：<code>Throwable</code><ul><li><strong>Error</strong>（错误，程序无法处理，通常由 JVM 抛出）<ul><li>如：<code>OutOfMemoryError</code>、<code>StackOverflowError</code></li></ul></li><li><strong>Exception</strong>（异常，程序可处理）<ul><li><strong>Checked Exception</strong>（受检异常，编译期检查）<ul><li>如：<code>IOException</code>、<code>SQLException</code></li></ul></li><li><strong>Unchecked Exception</strong>（运行时异常，编译器不强制处理）<ul><li>如：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code></li></ul></li></ul></li></ul></li></ul><p>👉 结构图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Throwable</span><br><span class="line"> ├── Error</span><br><span class="line"> └── Exception</span><br><span class="line">      ├── Checked Exception</span><br><span class="line">      └── Unchecked Exception (RuntimeException)</span><br></pre></td></tr></table></figure><hr><h3 id="2-Checked-Exception-和-Unchecked-Exception-的区别？"><a href="#2-Checked-Exception-和-Unchecked-Exception-的区别？" class="headerlink" title="2. Checked Exception 和 Unchecked Exception 的区别？"></a>2. Checked Exception 和 Unchecked Exception 的区别？</h3><ul><li><strong>Checked Exception（受检异常）</strong><ul><li>必须显式处理（try-catch 或 throws 声明）。</li><li>编译器强制检查，否则无法通过编译。</li><li>典型场景：IO、数据库、网络调用。</li></ul></li><li><strong>Unchecked Exception（非受检异常 &#x2F; 运行时异常）</strong><ul><li>不强制处理，编译器不检查。</li><li>通常由程序逻辑错误导致。</li><li>典型场景：NPE、除零、数组越界。</li></ul></li></ul><hr><h3 id="3-throw-和-throws-的区别？"><a href="#3-throw-和-throws-的区别？" class="headerlink" title="3. throw 和 throws 的区别？"></a>3. throw 和 throws 的区别？</h3><ul><li><strong>throw</strong><ul><li>用于方法体内部，<strong>抛出具体的异常对象</strong>。</li><li>语法：<code>throw new Exception(&quot;msg&quot;);</code></li></ul></li><li><strong>throws</strong><ul><li>用于方法声明处，<strong>标识该方法可能抛出的异常类型</strong>。</li><li>语法：<code>public void test() throws IOException &#123;&#125;</code></li></ul></li></ul><p>👉 总结：</p><ul><li><code>throw</code> &#x3D; 抛出异常实例。</li><li><code>throws</code> &#x3D; 声明可能抛出的异常类型。</li></ul><hr><h3 id="4-try-catch-finally-的执行顺序？"><a href="#4-try-catch-finally-的执行顺序？" class="headerlink" title="4. try-catch-finally 的执行顺序？"></a>4. try-catch-finally 的执行顺序？</h3><ol><li><code>try</code> 块先执行。</li><li>如果发生异常，跳到对应 <code>catch</code> 执行。</li><li><code>finally</code> <strong>一定会执行</strong>（除非 <code>System.exit()</code>）。</li><li>如果 <code>try</code> 或 <code>catch</code> 有 <code>return</code>，会先执行 <code>finally</code>，再返回结果。</li></ol><hr><h3 id="5-finally-中的-return-会覆盖-try-中的-return-吗？"><a href="#5-finally-中的-return-会覆盖-try-中的-return-吗？" class="headerlink" title="5. finally 中的 return 会覆盖 try 中的 return 吗？"></a>5. finally 中的 return 会覆盖 try 中的 return 吗？</h3><p>✅ <strong>会覆盖</strong>。</p><ul><li>如果 <code>try</code> 中有 <code>return</code>，但 <code>finally</code> 中也有 <code>return</code>，最终返回的是 <code>finally</code> 的结果。<br> 👉 因此实际开发中 <strong>不推荐在 finally 中写 return</strong>。</li></ul><hr><h3 id="6-try-with-resources-的作用？"><a href="#6-try-with-resources-的作用？" class="headerlink" title="6. try-with-resources 的作用？"></a>6. try-with-resources 的作用？</h3><ul><li>Java 7 引入，简化资源管理（如流、数据库连接）。</li><li>自动关闭实现了 <code>AutoCloseable</code> 或 <code>Closeable</code> 接口的资源。</li><li>避免忘记 <code>finally &#123; resource.close(); &#125;</code>。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>))) &#123;</span><br><span class="line">    System.out.println(br.readLine());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-自定义异常类如何实现？"><a href="#7-自定义异常类如何实现？" class="headerlink" title="7. 自定义异常类如何实现？"></a>7. 自定义异常类如何实现？</h3><ul><li>继承 <code>Exception</code>（Checked）或 <code>RuntimeException</code>（Unchecked）。</li><li>提供构造方法：无参、带 message、带 cause。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-Error-和-Exception-的区别？"><a href="#8-Error-和-Exception-的区别？" class="headerlink" title="8. Error 和 Exception 的区别？"></a>8. Error 和 Exception 的区别？</h3><ul><li><strong>Error</strong>：系统级错误，JVM 无法恢复，程序不应该捕获。<ul><li>如 <code>OutOfMemoryError</code>、<code>StackOverflowError</code>。</li></ul></li><li><strong>Exception</strong>：应用级异常，程序应该处理。<ul><li>如 <code>IOException</code>、<code>SQLException</code>、<code>NullPointerException</code>。</li></ul></li></ul><hr><h3 id="9-NullPointerException-常见场景有哪些？"><a href="#9-NullPointerException-常见场景有哪些？" class="headerlink" title="9. NullPointerException 常见场景有哪些？"></a>9. NullPointerException 常见场景有哪些？</h3><ol><li>调用空对象的方法：<code>obj.toString()</code>。</li><li>访问空数组：<code>arr.length</code>。</li><li>访问空集合：<code>list.size()</code>。</li><li>自动拆箱：<code>Integer num = null; int n = num;</code>。</li><li>Map 查找为 null，再调用方法：<code>map.get(&quot;key&quot;).toString()</code>。</li><li>依赖注入&#x2F;未初始化的对象。</li></ol><hr><h3 id="10-运行时异常需要捕获吗？为什么"><a href="#10-运行时异常需要捕获吗？为什么" class="headerlink" title="10. 运行时异常需要捕获吗？为什么"></a>10. 运行时异常需要捕获吗？为什么</h3><ul><li><strong>通常不需要显式捕获</strong>，因为它们多由逻辑错误导致（如 NPE、除零）。</li><li>捕获运行时异常并不能解决问题，应该<strong>通过修改代码逻辑</strong>避免。</li><li>但在某些关键服务（如 API 层）可以用统一异常处理（如 Spring @ControllerAdvice）拦截，避免程序直接崩溃。</li></ul><hr><h2 id="四、集合框架（Collections）"><a href="#四、集合框架（Collections）" class="headerlink" title="四、集合框架（Collections）"></a>四、集合框架（Collections）</h2><hr><h3 id="1-Collection-和-Collections-的区别？"><a href="#1-Collection-和-Collections-的区别？" class="headerlink" title="1. Collection 和 Collections 的区别？"></a>1. Collection 和 Collections 的区别？</h3><ul><li><strong>Collection</strong>：集合接口，是所有集合类的父接口（List、Set）。</li><li><strong>Collections</strong>：工具类，提供操作集合的静态方法（排序、搜索、同步包装等）。</li></ul><hr><h3 id="2-List、Set、Map-的区别？"><a href="#2-List、Set、Map-的区别？" class="headerlink" title="2. List、Set、Map 的区别？"></a>2. List、Set、Map 的区别？</h3><ul><li><strong>List</strong>：有序、可重复，按索引访问（ArrayList、LinkedList）。</li><li><strong>Set</strong>：无序、不可重复，基于哈希或树（HashSet、TreeSet）。</li><li><strong>Map</strong>：键值对存储，Key 不可重复，Value 可重复（HashMap、TreeMap）。</li></ul><hr><h3 id="3-ArrayList-和-LinkedList-的区别？"><a href="#3-ArrayList-和-LinkedList-的区别？" class="headerlink" title="3. ArrayList 和 LinkedList 的区别？"></a>3. ArrayList 和 LinkedList 的区别？</h3><ul><li><strong>ArrayList</strong>：基于动态数组，查询快（O(1)），增删慢（O(n)）。</li><li><strong>LinkedList</strong>：基于双向链表，增删快（O(1)），查询慢（O(n)）。</li></ul><hr><h3 id="4-HashMap-的底层实现？"><a href="#4-HashMap-的底层实现？" class="headerlink" title="4. HashMap 的底层实现？"></a>4. HashMap 的底层实现？</h3><ul><li><strong>JDK 1.7</strong>：数组 + 链表。</li><li><strong>JDK 1.8</strong>：数组 + 链表 + 红黑树（链表长度 ≥ 8 时转为树）。</li></ul><hr><h3 id="5-HashMap-1-7-和-1-8-的区别？"><a href="#5-HashMap-1-7-和-1-8-的区别？" class="headerlink" title="5. HashMap 1.7 和 1.8 的区别？"></a>5. HashMap 1.7 和 1.8 的区别？</h3><ol><li>1.7：数组 + 链表，采用头插法，易出现并发死循环。</li><li>1.8：数组 + 链表&#x2F;红黑树，尾插法，避免死循环，提高性能。</li><li>1.8 引入红黑树，查找效率从 O(n) 优化为 O(log n)。</li></ol><hr><h3 id="6-HashMap-如何解决哈希冲突？"><a href="#6-HashMap-如何解决哈希冲突？" class="headerlink" title="6. HashMap 如何解决哈希冲突？"></a>6. HashMap 如何解决哈希冲突？</h3><ul><li>方法：拉链法（链表）+ 红黑树。</li><li>冲突时，将元素挂到链表&#x2F;树上。</li></ul><hr><h3 id="7-HashSet-的底层实现？"><a href="#7-HashSet-的底层实现？" class="headerlink" title="7. HashSet 的底层实现？"></a>7. HashSet 的底层实现？</h3><ul><li>基于 <strong>HashMap</strong> 实现。</li><li><code>HashSet</code> 的元素存储在 <code>HashMap</code> 的 key 上，value 为一个固定对象 <code>PRESENT</code>。</li></ul><hr><h3 id="8-ConcurrentHashMap-的底层实现？"><a href="#8-ConcurrentHashMap-的底层实现？" class="headerlink" title="8. ConcurrentHashMap 的底层实现？"></a>8. ConcurrentHashMap 的底层实现？</h3><ul><li><strong>JDK 1.7</strong>：分段锁（Segment + HashEntry）。</li><li><strong>JDK 1.8</strong>：CAS + synchronized，数据结构与 HashMap 类似，数组 + 链表 + 红黑树。</li></ul><hr><h3 id="9-Hashtable-和-HashMap-的区别？"><a href="#9-Hashtable-和-HashMap-的区别？" class="headerlink" title="9. Hashtable 和 HashMap 的区别？"></a>9. Hashtable 和 HashMap 的区别？</h3><ul><li><strong>线程安全性</strong>：Hashtable 是同步的，HashMap 不是。</li><li><strong>null</strong>：Hashtable 不允许 key、value 为 null；HashMap 允许一个 null key 和多个 null value。</li><li><strong>效率</strong>：HashMap 更高效。</li></ul><hr><h3 id="10-TreeMap-和-HashMap-的区别？"><a href="#10-TreeMap-和-HashMap-的区别？" class="headerlink" title="10. TreeMap 和 HashMap 的区别？"></a>10. TreeMap 和 HashMap 的区别？</h3><ul><li><strong>TreeMap</strong>：基于红黑树，有序（按 Key 排序）。</li><li><strong>HashMap</strong>：基于哈希表，无序。</li></ul><hr><h3 id="11-WeakHashMap-的特点？"><a href="#11-WeakHashMap-的特点？" class="headerlink" title="11. WeakHashMap 的特点？"></a>11. WeakHashMap 的特点？</h3><ul><li>Key 使用 <strong>弱引用</strong>，当没有强引用指向该 Key 时，会被 GC 回收。</li><li>常用于缓存。</li></ul><hr><h3 id="12-CopyOnWriteArrayList-的应用场景？"><a href="#12-CopyOnWriteArrayList-的应用场景？" class="headerlink" title="12. CopyOnWriteArrayList 的应用场景？"></a>12. CopyOnWriteArrayList 的应用场景？</h3><ul><li>写时复制：写操作时复制新数组，读操作不加锁。</li><li>适用于 <strong>读多写少</strong> 的并发场景，比如缓存、订阅列表。</li></ul><hr><h3 id="13-LinkedHashMap-的底层原理？"><a href="#13-LinkedHashMap-的底层原理？" class="headerlink" title="13. LinkedHashMap 的底层原理？"></a>13. LinkedHashMap 的底层原理？</h3><ul><li>基于 HashMap + 双向链表。</li><li>保证插入顺序（或 LRU 顺序）。</li></ul><hr><h3 id="14-Map-的-key-是否可以为-null？"><a href="#14-Map-的-key-是否可以为-null？" class="headerlink" title="14. Map 的 key 是否可以为 null？"></a>14. Map 的 key 是否可以为 null？</h3><ul><li><strong>HashMap</strong>：允许一个 null key。</li><li><strong>Hashtable &#x2F; TreeMap</strong>：不允许 null key。</li></ul><hr><h3 id="15-ArrayList-扩容机制？"><a href="#15-ArrayList-扩容机制？" class="headerlink" title="15. ArrayList 扩容机制？"></a>15. ArrayList 扩容机制？</h3><ul><li>初始容量 10，超过容量时扩容为原来的 1.5 倍。</li><li>通过 <code>Arrays.copyOf()</code> 实现数组复制。</li></ul><hr><h3 id="16-Vector-和-ArrayList-的区别？"><a href="#16-Vector-和-ArrayList-的区别？" class="headerlink" title="16. Vector 和 ArrayList 的区别？"></a>16. Vector 和 ArrayList 的区别？</h3><ul><li><strong>Vector</strong>：线程安全（方法加 synchronized），扩容为 2 倍。</li><li><strong>ArrayList</strong>：非线程安全，扩容为 1.5 倍。</li></ul><hr><h3 id="17-PriorityQueue-的底层实现？"><a href="#17-PriorityQueue-的底层实现？" class="headerlink" title="17. PriorityQueue 的底层实现？"></a>17. PriorityQueue 的底层实现？</h3><ul><li>基于 <strong>二叉小顶堆</strong>，保证队头元素是最小值。</li><li>插入、删除操作时间复杂度 O(log n)。</li></ul><hr><h3 id="18-BlockingQueue-的几种实现类？"><a href="#18-BlockingQueue-的几种实现类？" class="headerlink" title="18. BlockingQueue 的几种实现类？"></a>18. BlockingQueue 的几种实现类？</h3><ul><li><strong>ArrayBlockingQueue</strong>：数组结构，有界。</li><li><strong>LinkedBlockingQueue</strong>：链表结构，可选容量。</li><li><strong>PriorityBlockingQueue</strong>：优先级队列。</li><li><strong>DelayQueue</strong>：延时队列。</li><li><strong>SynchronousQueue</strong>：不存储元素，直接移交。</li></ul><hr><h3 id="19-HashMap-死循环问题出现在哪个版本？"><a href="#19-HashMap-死循环问题出现在哪个版本？" class="headerlink" title="19. HashMap 死循环问题出现在哪个版本？"></a>19. HashMap 死循环问题出现在哪个版本？</h3><ul><li><strong>JDK 1.7</strong> 多线程扩容时，链表采用头插法，可能形成环，导致死循环。</li><li><strong>JDK 1.8</strong> 使用尾插法，解决该问题。</li></ul><hr><h3 id="20-fail-fast-和-fail-safe-的区别？"><a href="#20-fail-fast-和-fail-safe-的区别？" class="headerlink" title="20. fail-fast 和 fail-safe 的区别？"></a>20. fail-fast 和 fail-safe 的区别？</h3><ul><li><strong>fail-fast</strong>：迭代过程中结构被修改，会抛出 <code>ConcurrentModificationException</code>。如：ArrayList、HashMap。</li><li><strong>fail-safe</strong>：迭代基于副本，不会抛异常。如：CopyOnWriteArrayList、ConcurrentHashMap。</li></ul><hr><h2 id="五、并发编程（JUC）"><a href="#五、并发编程（JUC）" class="headerlink" title="五、并发编程（JUC）"></a>五、并发编程（JUC）</h2><hr><h3 id="1-Java-中的线程生命周期？"><a href="#1-Java-中的线程生命周期？" class="headerlink" title="1. Java 中的线程生命周期？"></a>1. Java 中的线程生命周期？</h3><ul><li><strong>NEW（新建）</strong>：<code>new Thread()</code> 后，还没调用 <code>start()</code>。</li><li><strong>RUNNABLE（就绪&#x2F;运行中）</strong>：调用 <code>start()</code>，等待 CPU 调度。</li><li><strong>BLOCKED（阻塞）</strong>：等待锁。</li><li><strong>WAITING（无限等待）</strong>：调用 <code>wait()</code>、<code>join()</code>，需其他线程唤醒。</li><li><strong>TIMED_WAITING（限时等待）</strong>：调用 <code>sleep()</code>、<code>wait(timeout)</code>。</li><li><strong>TERMINATED（终止）</strong>：线程执行完毕或异常退出。</li></ul><hr><h3 id="2-Runnable-和-Callable-的区别？"><a href="#2-Runnable-和-Callable-的区别？" class="headerlink" title="2. Runnable 和 Callable 的区别？"></a>2. Runnable 和 Callable 的区别？</h3><ul><li><strong>Runnable</strong>：无返回值，不能抛出受检异常。</li><li><strong>Callable</strong>：有返回值（Future 获取），可抛出异常。</li></ul><hr><h3 id="3-ThreadPoolExecutor-的参数有哪些？"><a href="#3-ThreadPoolExecutor-的参数有哪些？" class="headerlink" title="3. ThreadPoolExecutor 的参数有哪些？"></a>3. ThreadPoolExecutor 的参数有哪些？</h3><ul><li><strong>corePoolSize</strong>：核心线程数。</li><li><strong>maximumPoolSize</strong>：最大线程数。</li><li><strong>keepAliveTime</strong>：非核心线程存活时间。</li><li><strong>unit</strong>：时间单位。</li><li><strong>workQueue</strong>：任务队列（BlockingQueue）。</li><li><strong>threadFactory</strong>：线程工厂（自定义线程名）。</li><li><strong>handler</strong>：拒绝策略。</li></ul><hr><h3 id="4-线程池的拒绝策略有哪些？"><a href="#4-线程池的拒绝策略有哪些？" class="headerlink" title="4. 线程池的拒绝策略有哪些？"></a>4. 线程池的拒绝策略有哪些？</h3><ul><li><strong>AbortPolicy</strong>（默认）：抛 <code>RejectedExecutionException</code>。</li><li><strong>CallerRunsPolicy</strong>：任务交给提交任务的线程执行。</li><li><strong>DiscardPolicy</strong>：直接丢弃任务。</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列里最旧的任务，再尝试提交。</li></ul><hr><h3 id="5-创建线程的四种方式？"><a href="#5-创建线程的四种方式？" class="headerlink" title="5. 创建线程的四种方式？"></a>5. 创建线程的四种方式？</h3><ol><li>继承 Thread 类。</li><li>实现 Runnable 接口。</li><li>实现 Callable + FutureTask。</li><li>使用线程池（ExecutorService）。</li></ol><hr><h3 id="6-synchronized-的底层实现原理？"><a href="#6-synchronized-的底层实现原理？" class="headerlink" title="6. synchronized 的底层实现原理？"></a>6. synchronized 的底层实现原理？</h3><ul><li>基于 <strong>对象头 (Mark Word)</strong> 和 <strong>Monitor（管程）</strong>。</li><li>进入同步块时，尝试获取对象的 Monitor，获取不到则阻塞。</li><li>底层依赖 <strong>JVM 指令</strong>：<code>monitorenter</code>、<code>monitorexit</code>。</li></ul><hr><h3 id="7-synchronized-和-ReentrantLock-的区别？"><a href="#7-synchronized-和-ReentrantLock-的区别？" class="headerlink" title="7. synchronized 和 ReentrantLock 的区别？"></a>7. synchronized 和 ReentrantLock 的区别？</h3><ul><li><strong>锁类型</strong>：synchronized 是 JVM 级别，ReentrantLock 是 JUC 提供的 API。</li><li><strong>功能</strong>：ReentrantLock 支持公平锁&#x2F;非公平锁、可中断、尝试加锁、条件变量。</li><li><strong>可重入性</strong>：两者都可重入。</li><li><strong>性能</strong>：synchronized 在 JDK1.6 之后优化（偏向锁、轻量级锁）性能已提升。</li></ul><hr><h3 id="8-公平锁和非公平锁的区别？"><a href="#8-公平锁和非公平锁的区别？" class="headerlink" title="8. 公平锁和非公平锁的区别？"></a>8. 公平锁和非公平锁的区别？</h3><ul><li><strong>公平锁</strong>：按照等待顺序获取锁。</li><li><strong>非公平锁</strong>：允许“插队”，减少上下文切换，提高吞吐量。</li><li>ReentrantLock 默认非公平。</li></ul><hr><h3 id="9-AQS-的原理？"><a href="#9-AQS-的原理？" class="headerlink" title="9. AQS 的原理？"></a>9. AQS 的原理？</h3><ul><li><strong>AQS（AbstractQueuedSynchronizer）</strong> 是构建锁和同步器的框架。</li><li>内部维护一个 <strong>state</strong>（表示资源数量）和 <strong>FIFO 双向队列</strong>。</li><li>通过 CAS 修改 state，失败则将线程加入等待队列，挂起阻塞，等资源释放再唤醒。</li></ul><hr><h3 id="10-CountDownLatch-的应用场景？"><a href="#10-CountDownLatch-的应用场景？" class="headerlink" title="10. CountDownLatch 的应用场景？"></a>10. CountDownLatch 的应用场景？</h3><ul><li>倒计数器：一个线程等待多个线程完成后再执行。</li><li>例子：主线程等待多个子任务执行完毕。</li></ul><hr><h3 id="11-CyclicBarrier-的应用场景？"><a href="#11-CyclicBarrier-的应用场景？" class="headerlink" title="11. CyclicBarrier 的应用场景？"></a>11. CyclicBarrier 的应用场景？</h3><ul><li>栅栏：一组线程互相等待，直到所有线程到达屏障点再继续。</li><li>例子：多人游戏，所有玩家都准备好再开始。</li></ul><hr><h3 id="12-Semaphore-的应用场景？"><a href="#12-Semaphore-的应用场景？" class="headerlink" title="12. Semaphore 的应用场景？"></a>12. Semaphore 的应用场景？</h3><ul><li>信号量：控制并发访问的线程数量。</li><li>例子：停车场限制车位数、数据库连接池。</li></ul><hr><h3 id="13-Exchanger-的应用场景？"><a href="#13-Exchanger-的应用场景？" class="headerlink" title="13. Exchanger 的应用场景？"></a>13. Exchanger 的应用场景？</h3><ul><li>线程间数据交换：两个线程配对交换数据。</li><li>例子：生产者和消费者交换缓冲区。</li></ul><hr><h3 id="14-volatile-能保证原子性吗？"><a href="#14-volatile-能保证原子性吗？" class="headerlink" title="14. volatile 能保证原子性吗？"></a>14. volatile 能保证原子性吗？</h3><ul><li><strong>不能</strong>，只能保证可见性和禁止指令重排。</li><li>例子：<code>count++</code> 在多线程下仍然不安全。</li></ul><hr><h3 id="15-CAS-的原理？"><a href="#15-CAS-的原理？" class="headerlink" title="15. CAS 的原理？"></a>15. CAS 的原理？</h3><ul><li>Compare And Swap：比较内存值是否为预期值，如果是则更新，否则重试。</li><li>底层依赖 CPU 的 <strong>cmpxchg</strong> 指令，保证原子性。</li></ul><hr><h3 id="16-ABA-问题是什么？怎么解决？"><a href="#16-ABA-问题是什么？怎么解决？" class="headerlink" title="16. ABA 问题是什么？怎么解决？"></a>16. ABA 问题是什么？怎么解决？</h3><ul><li><strong>问题</strong>：CAS 只比较值，无法感知值被改过。例如 A→B→A。</li><li><strong>解决</strong>：使用 <strong>版本号&#x2F;时间戳</strong>（AtomicStampedReference、AtomicMarkableReference）。</li></ul><hr><h3 id="17-ThreadLocal-的作用及原理？"><a href="#17-ThreadLocal-的作用及原理？" class="headerlink" title="17. ThreadLocal 的作用及原理？"></a>17. ThreadLocal 的作用及原理？</h3><ul><li><strong>作用</strong>：为每个线程提供独立变量副本，避免共享数据冲突。</li><li><strong>原理</strong>：Thread 内部有个 ThreadLocalMap，以 ThreadLocal 为 key 存储变量。</li></ul><hr><h3 id="18-ThreadLocal-内存泄漏的原因？"><a href="#18-ThreadLocal-内存泄漏的原因？" class="headerlink" title="18. ThreadLocal 内存泄漏的原因？"></a>18. ThreadLocal 内存泄漏的原因？</h3><ul><li>ThreadLocalMap 的 key 是 <strong>弱引用</strong>，可能被回收，value 却还存在，导致泄漏。</li><li>解决：用完及时 <code>remove()</code>。</li></ul><hr><h3 id="19-JUC-中的原子类有哪些？"><a href="#19-JUC-中的原子类有哪些？" class="headerlink" title="19. JUC 中的原子类有哪些？"></a>19. JUC 中的原子类有哪些？</h3><ul><li><strong>基本类型原子类</strong>：AtomicInteger、AtomicLong、AtomicBoolean。</li><li><strong>引用类型原子类</strong>：AtomicReference、AtomicStampedReference。</li><li><strong>数组原子类</strong>：AtomicIntegerArray、AtomicLongArray。</li><li><strong>对象属性更新器</strong>：AtomicIntegerFieldUpdater 等。</li></ul><hr><h3 id="20-乐观锁和悲观锁的区别？"><a href="#20-乐观锁和悲观锁的区别？" class="headerlink" title="20. 乐观锁和悲观锁的区别？"></a>20. 乐观锁和悲观锁的区别？</h3><ul><li><strong>悲观锁</strong>：假设会发生冲突，先加锁再操作（synchronized、ReentrantLock）。</li><li><strong>乐观锁</strong>：假设不会冲突，先操作再检查（CAS）。</li></ul><hr><h2 id="六、JVM-内存模型"><a href="#六、JVM-内存模型" class="headerlink" title="六、JVM &amp; 内存模型"></a>六、JVM &amp; 内存模型</h2><hr><h3 id="1-JVM-内存结构？"><a href="#1-JVM-内存结构？" class="headerlink" title="1. JVM 内存结构？"></a>1. JVM 内存结构？</h3><p>JVM 运行时主要分为：</p><ul><li><strong>堆（Heap）</strong>：存放对象实例，垃圾回收的主要区域。</li><li><strong>虚拟机栈（Stack）</strong>：存放方法调用的局部变量、操作数栈、动态链接、返回地址。</li><li><strong>本地方法栈（Native Method Stack）</strong>：为 native 方法服务。</li><li><strong>程序计数器（PC Register）</strong>：记录线程当前执行的字节码位置。</li><li><strong>方法区（Method Area &#x2F; Metaspace）</strong>：存放类元数据、常量池、静态变量、JIT 编译后的代码。</li></ul><hr><h3 id="2-堆和栈的区别？"><a href="#2-堆和栈的区别？" class="headerlink" title="2. 堆和栈的区别？"></a>2. 堆和栈的区别？</h3><ul><li><strong>堆</strong>：存放对象实例，线程共享，需垃圾回收。</li><li><strong>栈</strong>：存放方法帧、局部变量，线程私有，生命周期随线程结束。</li></ul><hr><h3 id="3-堆内存的分代模型？"><a href="#3-堆内存的分代模型？" class="headerlink" title="3. 堆内存的分代模型？"></a>3. 堆内存的分代模型？</h3><ul><li><strong>新生代（Young Generation）</strong>：Eden + Survivor（S0&#x2F;S1）。</li><li><strong>老年代（Old Generation）</strong>：存放长生命周期对象。</li><li><strong>永久代&#x2F;元空间</strong>：存放类元信息、常量池。</li></ul><hr><h3 id="4-新生代、老年代、永久代的区别？"><a href="#4-新生代、老年代、永久代的区别？" class="headerlink" title="4. 新生代、老年代、永久代的区别？"></a>4. 新生代、老年代、永久代的区别？</h3><ul><li><strong>新生代</strong>：对象新建时分配，大部分对象“朝生夕死”。</li><li><strong>老年代</strong>：存活时间长或大对象直接进入。</li><li><strong>永久代（JDK 7 及之前）</strong>：存放类信息、静态变量。</li><li><strong>元空间（JDK 8 之后）</strong>：替代永久代，使用本地内存，避免 OOM: PermGen。</li></ul><hr><h3 id="5-元空间和永久代的区别？"><a href="#5-元空间和永久代的区别？" class="headerlink" title="5. 元空间和永久代的区别？"></a>5. 元空间和永久代的区别？</h3><ul><li>永久代（PermGen）：使用 JVM 内存，容易 OOM。</li><li>元空间（Metaspace）：使用本地内存，理论上更大，更灵活。</li></ul><hr><h3 id="6-对象在堆中的分配过程？"><a href="#6-对象在堆中的分配过程？" class="headerlink" title="6. 对象在堆中的分配过程？"></a>6. 对象在堆中的分配过程？</h3><ol><li>在 Eden 区分配。</li><li>Minor GC 时，幸存的对象进入 Survivor 区。</li><li>多次 Minor GC 仍存活 → 晋升老年代。</li><li>大对象（如大数组）可能直接进入老年代。</li></ol><hr><h3 id="7-对象什么时候进入老年代？"><a href="#7-对象什么时候进入老年代？" class="headerlink" title="7. 对象什么时候进入老年代？"></a>7. 对象什么时候进入老年代？</h3><ul><li>在 Survivor 区经过多次 Minor GC，达到晋升阈值（默认 15 次）。</li><li>大对象超过阈值，直接进入老年代。</li><li>Survivor 区放不下，直接进入老年代。</li></ul><hr><h3 id="8-JVM-的垃圾回收算法？"><a href="#8-JVM-的垃圾回收算法？" class="headerlink" title="8. JVM 的垃圾回收算法？"></a>8. JVM 的垃圾回收算法？</h3><ul><li><strong>标记-清除</strong>：标记存活对象，清除未标记。缺点：碎片多。</li><li><strong>标记-整理</strong>：标记存活对象并移动，整理内存，避免碎片。</li><li><strong>复制算法</strong>：将活对象复制到新区域，清空旧区域，适合新生代。</li></ul><hr><h3 id="9-垃圾收集器有哪些？"><a href="#9-垃圾收集器有哪些？" class="headerlink" title="9. 垃圾收集器有哪些？"></a>9. 垃圾收集器有哪些？</h3><ul><li><strong>Serial</strong>（单线程，适合小内存）。</li><li><strong>ParNew</strong>（多线程版 Serial）。</li><li><strong>Parallel Scavenge（吞吐量优先）</strong>。</li><li><strong>CMS（低延迟，响应快）</strong>。</li><li><strong>G1（区域化，均衡停顿时间）</strong>。</li><li><strong>ZGC、Shenandoah（超低延迟，适合大内存场景）</strong>。</li></ul><hr><h3 id="10-CMS-和-G1-的区别？"><a href="#10-CMS-和-G1-的区别？" class="headerlink" title="10. CMS 和 G1 的区别？"></a>10. CMS 和 G1 的区别？</h3><ul><li><strong>CMS</strong>：并发收集，低延迟，但可能产生内存碎片。</li><li><strong>G1</strong>：基于分区（Region），可预测停顿时间，整理内存，适合大堆内存。</li></ul><hr><h3 id="11-Minor-GC-和-Full-GC-的区别？"><a href="#11-Minor-GC-和-Full-GC-的区别？" class="headerlink" title="11. Minor GC 和 Full GC 的区别？"></a>11. Minor GC 和 Full GC 的区别？</h3><ul><li><strong>Minor GC</strong>：回收新生代，速度快，频繁。</li><li><strong>Full GC</strong>：回收整个堆（新生代 + 老年代 + 元空间），耗时长，频率低。</li></ul><hr><h3 id="12-什么是-Stop-The-World？"><a href="#12-什么是-Stop-The-World？" class="headerlink" title="12. 什么是 Stop The World？"></a>12. 什么是 Stop The World？</h3><ul><li>GC 期间，所有工作线程必须停下来等待，造成应用暂停（STW）。</li><li>STW 是不可避免的，只能尽量减少时长。</li></ul><hr><h3 id="13-JVM-常见的调优参数？"><a href="#13-JVM-常见的调优参数？" class="headerlink" title="13. JVM 常见的调优参数？"></a>13. JVM 常见的调优参数？</h3><ul><li><code>-Xms</code> 初始堆大小。</li><li><code>-Xmx</code> 最大堆大小。</li><li><code>-Xmn</code> 新生代大小。</li><li><code>-XX:SurvivorRatio</code> Eden:Survivor 比例。</li><li><code>-XX:+PrintGCDetails</code> 打印 GC 日志。</li><li><code>-XX:+UseG1GC</code> 指定垃圾收集器。</li><li><code>-XX:MaxMetaspaceSize</code> 元空间大小。</li></ul><hr><h3 id="14-类加载的双亲委派机制？"><a href="#14-类加载的双亲委派机制？" class="headerlink" title="14. 类加载的双亲委派机制？"></a>14. 类加载的双亲委派机制？</h3><ul><li><strong>过程</strong>：加载请求先交给父加载器，如果父加载器无法加载，再由子加载器加载。</li></ul><hr><h3 id="15-双亲委派的好处？"><a href="#15-双亲委派的好处？" class="headerlink" title="15. 双亲委派的好处？"></a>15. 双亲委派的好处？</h3><ul><li>避免类重复加载。</li><li>保证核心类（如 java.lang.String）不会被篡改。</li></ul><hr><h3 id="16-类加载器的种类？"><a href="#16-类加载器的种类？" class="headerlink" title="16. 类加载器的种类？"></a>16. 类加载器的种类？</h3><ul><li><strong>Bootstrap ClassLoader</strong>：加载核心类库。</li><li><strong>Extension ClassLoader</strong>：加载扩展类。</li><li><strong>Application ClassLoader</strong>：加载用户应用类。</li><li><strong>自定义 ClassLoader</strong>：用户自己扩展。</li></ul><hr><h3 id="17-OOM-的常见类型？"><a href="#17-OOM-的常见类型？" class="headerlink" title="17. OOM 的常见类型？"></a>17. OOM 的常见类型？</h3><ul><li><strong>Java heap space</strong>：堆溢出。</li><li><strong>GC overhead limit exceeded</strong>：GC 回收无效。</li><li><strong>Metaspace</strong>：元空间溢出。</li><li><strong>Direct buffer memory</strong>：直接内存溢出。</li><li><strong>Unable to create new native thread</strong>：线程数过多。</li></ul><hr><h3 id="18-内存泄漏和内存溢出的区别？"><a href="#18-内存泄漏和内存溢出的区别？" class="headerlink" title="18. 内存泄漏和内存溢出的区别？"></a>18. 内存泄漏和内存溢出的区别？</h3><ul><li><strong>内存泄漏</strong>：不再使用的对象仍然被引用，不能被 GC 回收。</li><li><strong>内存溢出</strong>：内存不足，申请不到更多空间。</li></ul><hr><h3 id="19-finalize-方法的作用？"><a href="#19-finalize-方法的作用？" class="headerlink" title="19. finalize() 方法的作用？"></a>19. finalize() 方法的作用？</h3><ul><li>对象被 GC 前执行一次清理逻辑。</li><li>缺点：执行不确定、性能差，JDK9 开始废弃，推荐使用 <strong>try-with-resources&#x2F;AutoCloseable</strong>。</li></ul><hr><h3 id="20-Java-内存模型（JMM）的核心内容？"><a href="#20-Java-内存模型（JMM）的核心内容？" class="headerlink" title="20. Java 内存模型（JMM）的核心内容？"></a>20. Java 内存模型（JMM）的核心内容？</h3><ul><li>定义了多线程如何共享内存。</li><li>关键点：<ul><li><strong>主内存</strong>：存放共享变量。</li><li><strong>工作内存</strong>：每个线程的本地副本。</li><li><strong>happens-before 规则</strong>：保证可见性、有序性。</li><li><strong>volatile、synchronized、final</strong> 提供内存语义。</li></ul></li></ul><hr><h2 id="七、泛型、注解、反射"><a href="#七、泛型、注解、反射" class="headerlink" title="七、泛型、注解、反射"></a>七、泛型、注解、反射</h2><hr><h3 id="1-什么是泛型？"><a href="#1-什么是泛型？" class="headerlink" title="1. 什么是泛型？"></a>1. 什么是泛型？</h3><ul><li><p><strong>定义</strong>：泛型（Generic）是 <strong>参数化类型</strong>，让类、接口、方法可以操作不同类型的数据，而不用编写重复代码。</p></li><li><p><strong>好处</strong>：</p><ol><li><strong>类型安全</strong>（编译期检查，避免 <code>ClassCastException</code>）。</li><li><strong>代码复用</strong>（相同逻辑可适配多种类型）。</li><li><strong>可读性高</strong>（类型明确）。</li></ol></li><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 编译期检查类型</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-泛型的类型擦除机制？"><a href="#2-泛型的类型擦除机制？" class="headerlink" title="2. 泛型的类型擦除机制？"></a>2. 泛型的类型擦除机制？</h3><ul><li><p><strong>原理</strong>：Java 的泛型是 <strong>伪泛型</strong>，只在 <strong>编译期有效</strong>，编译后泛型信息被擦除（Type Erasure）。</p></li><li><p><strong>结果</strong>：</p><ul><li><code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在运行时是同一个类型：<code>List</code>。</li><li>泛型方法的类型参数会被擦除为 <strong>上界（extends）或 Object</strong>。</li></ul></li><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; l2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">System.out.println(l1.getClass() == l2.getClass()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-泛型通配符-extends-和-super-的区别？"><a href="#3-泛型通配符-extends-和-super-的区别？" class="headerlink" title="3. 泛型通配符 ? extends 和 ? super 的区别？"></a>3. 泛型通配符 ? extends 和 ? super 的区别？</h3><ul><li><code>? extends T</code>：表示类型的 <strong>上界</strong>，接受 <code>T</code> 及其子类。<ul><li>适合 <strong>生产者（Producer）</strong>，只读，不可写。</li></ul></li><li><code>? super T</code>：表示类型的 <strong>下界</strong>，接受 <code>T</code> 及其父类。<ul><li>适合 <strong>消费者（Consumer）</strong>，可以写入 T 及其子类对象。</li></ul></li><li><strong>口诀</strong>：PECS（Producer Extends, Consumer Super）。</li></ul><hr><h3 id="4-注解的作用是什么？"><a href="#4-注解的作用是什么？" class="headerlink" title="4. 注解的作用是什么？"></a>4. 注解的作用是什么？</h3><ul><li><strong>作用</strong>：注解（Annotation）是 <strong>元数据</strong>，为代码提供说明信息。</li><li><strong>分类</strong>：<ul><li>编译期使用（如 <code>@Override</code>, <code>@SuppressWarnings</code>）。</li><li>运行时使用（结合反射，驱动框架逻辑，如 <code>@Autowired</code>）。</li></ul></li><li><strong>应用场景</strong>：框架开发（Spring、Hibernate）、编译器检查、文档生成等。</li></ul><hr><h3 id="5-元注解有哪些？"><a href="#5-元注解有哪些？" class="headerlink" title="5. 元注解有哪些？"></a>5. 元注解有哪些？</h3><p>Java 提供了四个元注解（注解的注解）：</p><ol><li><code>@Target</code> —— 指定注解可用的位置（类、方法、字段、参数等）。</li><li><code>@Retention</code> —— 指定注解的生命周期（源码&#x2F;编译期&#x2F;运行时）。</li><li><code>@Documented</code> —— 是否包含在 javadoc 中。</li><li><code>@Inherited</code> —— 子类是否能继承父类的注解。</li></ol><hr><h3 id="6-自定义注解如何实现？"><a href="#6-自定义注解如何实现？" class="headerlink" title="6. 自定义注解如何实现？"></a>6. 自定义注解如何实现？</h3><ul><li><p><strong>定义</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>解析</strong>（反射）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">ann</span> <span class="operator">=</span> m.getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(ann.value());</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-反射的作用？"><a href="#7-反射的作用？" class="headerlink" title="7. 反射的作用？"></a>7. 反射的作用？</h3><ul><li><strong>定义</strong>：反射（Reflection）允许程序在 <strong>运行时</strong> 获取类的信息，并操作其属性、方法、构造器。</li><li><strong>作用</strong>：<ul><li>框架（如 Spring、MyBatis）自动注入和配置。</li><li>动态代理。</li><li>动态加载类。</li></ul></li></ul><hr><h3 id="8-反射的性能问题？"><a href="#8-反射的性能问题？" class="headerlink" title="8. 反射的性能问题？"></a>8. 反射的性能问题？</h3><ul><li><strong>原因</strong>：<ul><li>反射调用方法比直接调用多了安全检查、方法查找，性能差 10~20 倍。</li></ul></li><li><strong>优化</strong>：<ul><li>使用 <code>setAccessible(true)</code> 关闭安全检查。</li><li>使用 <code>MethodHandle</code>（JDK7+）。</li><li>使用 <code>LambdaMetafactory</code>（JDK8+）做动态代理。</li></ul></li></ul><hr><h3 id="9-反射能否访问私有字段？"><a href="#9-反射能否访问私有字段？" class="headerlink" title="9. 反射能否访问私有字段？"></a>9. 反射能否访问私有字段？</h3><ul><li><p><strong>能</strong>，需要 <code>setAccessible(true)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(obj, <span class="string">&quot;newValue&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：JDK 9 模块化后，跨模块访问可能会有 <code>InaccessibleObjectException</code>。</p></li></ul><hr><h3 id="10-动态代理的两种实现方式？"><a href="#10-动态代理的两种实现方式？" class="headerlink" title="10. 动态代理的两种实现方式？"></a>10. 动态代理的两种实现方式？</h3><ol><li><strong>JDK 动态代理</strong>：基于 <code>InvocationHandler + Proxy</code>，只能代理 <strong>接口</strong>。</li><li><strong>CGLIB 动态代理</strong>：基于 ASM 字节码生成，继承目标类，能代理 <strong>类</strong>。</li></ol><hr><h3 id="11-JDK-动态代理和-CGLIB-的区别？"><a href="#11-JDK-动态代理和-CGLIB-的区别？" class="headerlink" title="11. JDK 动态代理和 CGLIB 的区别？"></a>11. JDK 动态代理和 CGLIB 的区别？</h3><ul><li><strong>JDK 动态代理</strong>：<ul><li>代理接口。</li><li>JDK 自带，无需依赖。</li><li>性能略低。</li></ul></li><li><strong>CGLIB</strong>：<ul><li>代理类（生成子类）。</li><li>不能代理 <code>final</code> 类&#x2F;方法。</li><li>性能更高（字节码生成）。</li></ul></li></ul><hr><h3 id="12-反射如何创建对象？"><a href="#12-反射如何创建对象？" class="headerlink" title="12. 反射如何创建对象？"></a>12. 反射如何创建对象？</h3><ol><li><p><strong>使用 Class 的 <code>newInstance()</code></strong>（已废弃）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Constructor</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt; ctor = clazz.getConstructor(String.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ctor.newInstance(<span class="string">&quot;param&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="13-Class-forName-和-ClassLoader-loadClass-的区别？"><a href="#13-Class-forName-和-ClassLoader-loadClass-的区别？" class="headerlink" title="13. Class.forName 和 ClassLoader.loadClass 的区别？"></a>13. Class.forName 和 ClassLoader.loadClass 的区别？</h3><ul><li><strong>Class.forName</strong>：加载并 <strong>初始化</strong> 类（会执行静态代码块）。</li><li><strong>ClassLoader.loadClass</strong>：仅加载，不初始化（延迟执行 <code>&lt;clinit&gt;</code>）。</li></ul><hr><h3 id="14-注解和反射结合能实现哪些功能？"><a href="#14-注解和反射结合能实现哪些功能？" class="headerlink" title="14. 注解和反射结合能实现哪些功能？"></a>14. 注解和反射结合能实现哪些功能？</h3><ul><li>IOC &#x2F; DI（依赖注入，Spring 的 <code>@Autowired</code>）。</li><li>ORM 框架（MyBatis 的 <code>@Mapper</code>，JPA 的 <code>@Entity</code>）。</li><li>AOP（<code>@Aspect</code>）。</li><li>配置驱动开发（<code>@Configuration</code>, <code>@Value</code>）。</li></ul><hr><h3 id="15-注解处理器（APT）的作用？"><a href="#15-注解处理器（APT）的作用？" class="headerlink" title="15. 注解处理器（APT）的作用？"></a>15. 注解处理器（APT）的作用？</h3><ul><li><strong>APT（Annotation Processing Tool）</strong>：编译期扫描注解并生成代码。</li><li><strong>典型应用</strong>：<ul><li>Dagger2（依赖注入）。</li><li>ButterKnife（视图注入）。</li><li>Lombok（自动生成 getter&#x2F;setter&#x2F;toString 等）。</li></ul></li></ul><hr><h2 id="八、Java-8-新特性"><a href="#八、Java-8-新特性" class="headerlink" title="八、Java 8+ 新特性"></a>八、Java 8+ 新特性</h2><ol><li>Lambda 表达式的作用？</li><li>函数式接口有哪些？</li><li>Stream 流的常见操作？</li><li>Optional 的作用？</li><li>CompletableFuture 的作用？</li><li>Java 8 接口的默认方法和静态方法？</li><li>forEach 和传统 for 的区别？</li><li>parallelStream 的原理？</li><li>Java 9 模块化系统（Jigsaw）是什么？</li><li>Java 14 的 switch 表达式增强？</li><li>Java 16 的 record 特性？</li><li>Java 17 的 sealed class 特性？</li><li>var 关键字是什么？</li><li>ZGC 的特性？</li><li>Project Loom 的虚拟线程是什么？</li></ol><h2 id="九、IO"><a href="#九、IO" class="headerlink" title="九、IO"></a>九、IO</h2><hr><h2 id="一、Java-IO-基础与流（1–20）"><a href="#一、Java-IO-基础与流（1–20）" class="headerlink" title="一、Java IO 基础与流（1–20）"></a>一、Java IO 基础与流（1–20）</h2><hr><h3 id="1-Java-IO-的总体体系结构是什么？"><a href="#1-Java-IO-的总体体系结构是什么？" class="headerlink" title="1. Java IO 的总体体系结构是什么？"></a>1. Java IO 的总体体系结构是什么？</h3><ul><li><strong>IO 的两大基类</strong>：<ul><li>字节流：<code>InputStream</code>、<code>OutputStream</code>（处理二进制数据）。</li><li>字符流：<code>Reader</code>、<code>Writer</code>（处理文本字符）。</li></ul></li><li><strong>按功能划分</strong>：<ul><li>节点流（直接对接数据源，如 <code>FileInputStream</code>、<code>FileReader</code>）。</li><li>处理流（包装其他流，如 <code>BufferedReader</code>、<code>DataInputStream</code>）。</li></ul></li><li><strong>核心设计模式</strong>：装饰器模式（Decorator Pattern），通过层层包装增强功能。</li></ul><hr><h3 id="2-InputStream-OutputStream-的常见子类有哪些？"><a href="#2-InputStream-OutputStream-的常见子类有哪些？" class="headerlink" title="2. InputStream &#x2F; OutputStream 的常见子类有哪些？"></a>2. InputStream &#x2F; OutputStream 的常见子类有哪些？</h3><ul><li><strong>InputStream</strong>：<code>FileInputStream</code>、<code>BufferedInputStream</code>、<code>DataInputStream</code>、<code>ObjectInputStream</code>、<code>ByteArrayInputStream</code>。</li><li><strong>OutputStream</strong>：<code>FileOutputStream</code>、<code>BufferedOutputStream</code>、<code>DataOutputStream</code>、<code>ObjectOutputStream</code>、<code>ByteArrayOutputStream</code>。</li></ul><hr><h3 id="3-Reader-Writer-的常见子类有哪些？"><a href="#3-Reader-Writer-的常见子类有哪些？" class="headerlink" title="3. Reader &#x2F; Writer 的常见子类有哪些？"></a>3. Reader &#x2F; Writer 的常见子类有哪些？</h3><ul><li><strong>Reader</strong>：<code>FileReader</code>、<code>BufferedReader</code>、<code>InputStreamReader</code>、<code>CharArrayReader</code>、<code>StringReader</code>。</li><li><strong>Writer</strong>：<code>FileWriter</code>、<code>BufferedWriter</code>、<code>OutputStreamWriter</code>、<code>CharArrayWriter</code>、<code>StringWriter</code>。</li></ul><hr><h3 id="4-字节流与字符流的本质区别和使用场景？"><a href="#4-字节流与字符流的本质区别和使用场景？" class="headerlink" title="4. 字节流与字符流的本质区别和使用场景？"></a>4. 字节流与字符流的本质区别和使用场景？</h3><ul><li><strong>字节流</strong>（8bit）：面向二进制数据，如图片、音视频、压缩文件。</li><li><strong>字符流</strong>（16bit，基于 Unicode）：面向文本，自动处理字符编码。</li><li><strong>联系</strong>：字符流常常通过 <code>InputStreamReader/OutputStreamWriter</code> 包装字节流并指定编码。</li></ul><hr><h3 id="5-为什么要有缓冲流？"><a href="#5-为什么要有缓冲流？" class="headerlink" title="5. 为什么要有缓冲流？"></a>5. 为什么要有缓冲流？</h3><ul><li><strong>原因</strong>：文件 IO 属于系统调用，每次读写代价高。</li><li><strong>作用</strong>：减少磁盘交互次数，提高性能。</li><li><strong>例子</strong>：<code>BufferedReader.readLine()</code> 能按行读取，效率远高于 <code>FileReader.read()</code>。</li></ul><hr><h3 id="6-flush-与-close-的区别？"><a href="#6-flush-与-close-的区别？" class="headerlink" title="6. flush() 与 close() 的区别？"></a>6. flush() 与 close() 的区别？</h3><ul><li><strong>flush()</strong>：将内存缓冲区数据立刻写入目标（但不关闭流）。</li><li><strong>close()</strong>：先执行 <code>flush()</code>，然后释放底层资源。</li><li><strong>注意点</strong>：<ul><li>若忘记 <code>flush()</code>，可能导致部分数据未写入文件。</li><li><code>close()</code> 后再调用 <code>write()</code> 会抛异常。</li></ul></li></ul><hr><h3 id="7-try-with-resources-的工作原理？"><a href="#7-try-with-resources-的工作原理？" class="headerlink" title="7. try-with-resources 的工作原理？"></a>7. try-with-resources 的工作原理？</h3><ul><li><strong>语法糖</strong>：<code>try (Resource r = ...) &#123;&#125;</code>，要求资源实现 <code>AutoCloseable</code>。</li><li><strong>原理</strong>：编译器自动生成 <code>finally &#123; r.close() &#125;</code>。</li><li><strong>suppressed exceptions</strong>：如果 <code>try</code> 和 <code>close()</code> 都抛异常，关闭时的异常会被标记为 <strong>suppressed</strong>，可通过 <code>Throwable.getSuppressed()</code> 获取。</li></ul><hr><h3 id="8-装饰器模式在-Java-IO-中如何体现？"><a href="#8-装饰器模式在-Java-IO-中如何体现？" class="headerlink" title="8. 装饰器模式在 Java IO 中如何体现？"></a>8. 装饰器模式在 Java IO 中如何体现？</h3><ul><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>), StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure></li><li><p><strong>本质</strong>：每层流只关心自己的功能（缓冲、解码、行读取），通过链式组合增强能力。</p></li></ul><hr><h3 id="9-File-类的能力与限制？"><a href="#9-File-类的能力与限制？" class="headerlink" title="9. File 类的能力与限制？"></a>9. File 类的能力与限制？</h3><ul><li><strong>能做的</strong>：文件&#x2F;目录的元数据操作（路径、存在性、权限、大小、修改时间等）。</li><li><strong>不能做的</strong>：不支持读写文件内容，需结合 <code>InputStream/OutputStream</code>。</li></ul><hr><h3 id="10-RandomAccessFile-的用途？"><a href="#10-RandomAccessFile-的用途？" class="headerlink" title="10. RandomAccessFile 的用途？"></a>10. RandomAccessFile 的用途？</h3><ul><li><strong>功能</strong>：支持随机读写，内部有一个文件指针，可 <code>seek()</code> 到任意位置读写。</li><li><strong>典型场景</strong>：日志文件、数据库存储文件。</li><li><strong>并发问题</strong>：不是线程安全的，多线程写需加锁。</li></ul><hr><h3 id="11-FileInputStream-与-FileReader-的区别？"><a href="#11-FileInputStream-与-FileReader-的区别？" class="headerlink" title="11. FileInputStream 与 FileReader 的区别？"></a>11. FileInputStream 与 FileReader 的区别？</h3><ul><li><strong>FileInputStream</strong>：字节流，直接读二进制。</li><li><strong>FileReader</strong>：字符流，内部用 <code>InputStreamReader</code> 并默认使用平台编码。</li><li><strong>使用建议</strong>：<ul><li>非文本 → <code>FileInputStream</code>。</li><li>文本（需编码处理） → <code>FileReader</code>（但最好用 <code>InputStreamReader</code> 显式指定编码）。</li></ul></li></ul><hr><h3 id="12-常见文件拷贝方式性能对比"><a href="#12-常见文件拷贝方式性能对比" class="headerlink" title="12. 常见文件拷贝方式性能对比"></a>12. 常见文件拷贝方式性能对比</h3><ol><li><strong>裸 read&#x2F;write</strong>：逐字节拷贝，最慢。</li><li><strong>带缓冲</strong>：<code>BufferedInputStream/BufferedOutputStream</code>，性能提升 5~10 倍。</li><li><strong>NIO <code>FileChannel.transferTo()</code></strong>：利用零拷贝，性能最高。</li></ol><hr><h3 id="13-如何安全处理字符编码？"><a href="#13-如何安全处理字符编码？" class="headerlink" title="13. 如何安全处理字符编码？"></a>13. 如何安全处理字符编码？</h3><ul><li><p><strong>方式</strong>：使用 <code>InputStreamReader</code>&#x2F;<code>OutputStreamWriter</code> 并显式指定编码。</p></li><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="14-字符编码常见坑？"><a href="#14-字符编码常见坑？" class="headerlink" title="14. 字符编码常见坑？"></a>14. 字符编码常见坑？</h3><ul><li>UTF-8 vs GBK 混用：解码错误，出现乱码。</li><li>BOM（Byte Order Mark）：部分 UTF-8 文件前 3 字节 BOM 可能导致解析失败。</li><li>截断：写入时按字节截断 UTF-8 多字节字符 → 乱码。</li><li><strong>解决</strong>：统一编码（UTF-8），避免隐式编码。</li></ul><hr><h3 id="15-文件追加（append）方式？"><a href="#15-文件追加（append）方式？" class="headerlink" title="15. 文件追加（append）方式？"></a>15. 文件追加（append）方式？</h3><ul><li><p><strong>实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>原子性问题</strong>：多线程写入需加锁，否则可能交叉覆盖。</p></li></ul><hr><h3 id="16-如何判断并处理文件状态？"><a href="#16-如何判断并处理文件状态？" class="headerlink" title="16. 如何判断并处理文件状态？"></a>16. 如何判断并处理文件状态？</h3><ul><li><strong>存在性</strong>：<code>file.exists()</code>。</li><li><strong>权限</strong>：<code>file.canRead()</code>, <code>file.canWrite()</code>。</li><li><strong>占用</strong>：只能通过打开尝试，若被占用会抛异常。</li></ul><hr><h3 id="17-File-mkdirs-与-mkdir-区别？"><a href="#17-File-mkdirs-与-mkdir-区别？" class="headerlink" title="17. File.mkdirs() 与 mkdir() 区别？"></a>17. File.mkdirs() 与 mkdir() 区别？</h3><ul><li><strong>mkdir()</strong>：只创建当前目录，父目录不存在则失败。</li><li><strong>mkdirs()</strong>：会递归创建所有不存在的父目录。</li><li><strong>返回值</strong>：成功返回 <code>true</code>，否则 <code>false</code>。</li></ul><hr><h3 id="18-临时文件（createTempFile）的用途？"><a href="#18-临时文件（createTempFile）的用途？" class="headerlink" title="18. 临时文件（createTempFile）的用途？"></a>18. 临时文件（createTempFile）的用途？</h3><ul><li><strong>方法</strong>：<code>File.createTempFile(&quot;prefix&quot;, &quot;.tmp&quot;)</code>。</li><li><strong>特点</strong>：自动生成唯一文件名。</li><li><strong>删除策略</strong>：<code>file.deleteOnExit()</code> JVM 退出时删除，但依赖于正常退出。</li></ul><hr><h3 id="19-文件的读写锁与并发访问？"><a href="#19-文件的读写锁与并发访问？" class="headerlink" title="19. 文件的读写锁与并发访问？"></a>19. 文件的读写锁与并发访问？</h3><ul><li><strong>Java NIO</strong>：<code>FileChannel.lock()</code> 提供文件锁（独占锁、共享锁）。</li><li><strong>注意</strong>：文件锁是 OS 级别，跨进程生效；性能开销较大，不适合频繁操作。</li></ul><hr><h3 id="20-流关闭异常处理最佳实践"><a href="#20-流关闭异常处理最佳实践" class="headerlink" title="20. 流关闭异常处理最佳实践"></a>20. 流关闭异常处理最佳实践</h3><ul><li><strong>传统写法</strong>：try-finally 手动关闭流。</li><li><strong>推荐</strong>：try-with-resources，避免遗漏关闭。</li><li><strong>关闭异常</strong>：只 log，不影响主要业务异常处理。</li></ul><hr><h2 id="二、Java-IO-设计与模式（21–40）"><a href="#二、Java-IO-设计与模式（21–40）" class="headerlink" title="二、Java IO 设计与模式（21–40）"></a>二、Java IO 设计与模式（21–40）</h2><ol><li>InputStream&#x2F;OutputStream 的装饰器链常见组合（Buffered -&gt; GZIP -&gt; Cipher 等）。</li><li>PushbackInputStream、SequenceInputStream 的作用与应用场景。</li><li>PipedInputStream &#x2F; PipedOutputStream（管道流）的使用与线程注意点。</li><li>FilterInputStream&#x2F;FilterOutputStream 的设计与扩展。</li><li>IO 与异常处理：IOException 的常见子类与处理策略。</li><li>流复制的常见实现模板（模板方法式代码）。</li><li>NIO 引入前的 IO 局限性（可扩展性、线程模型）。</li><li>如何实现一个带超时的读操作（Socket&#x2F;Channel）？</li><li>流式处理与内存友好型处理（流式处理大文件）实践。</li><li>Base64 编解码在流中的高效集成方法。</li><li>加密&#x2F;解密流（CipherInputStream&#x2F;CipherOutputStream）如何正确关闭？</li><li>GZIPInputStream&#x2F;GZIPOutputStream 的压缩流使用注意事项。</li><li>ObjectInputStream&#x2F;ObjectOutputStream 的工作机制（类元数据、句柄表）。</li><li>如何实现跨语言的序列化兼容（JSON&#x2F;Protobuf&#x2F;Avro）？</li><li>实现自定义 InputStream 子类时需要注意什么（read 方法语义）？</li><li>设计用于日志写入的高吞吐 IO 模式（异步批量写）。</li><li>流复制时如何统计速率与进度（带进度回调）？</li><li>如何安全处理二进制文件（流边界、magic header）？</li><li>大对象&#x2F;大数组写入流时的内存优化策略（分块、流化）。</li><li>如何实现可重入&#x2F;可恢复的断点续传文件写入？</li></ol><hr><h2 id="三、文件系统、锁与操作（41–60）"><a href="#三、文件系统、锁与操作（41–60）" class="headerlink" title="三、文件系统、锁与操作（41–60）"></a>三、文件系统、锁与操作（41–60）</h2><ol><li>Java 中文件锁 FileLock 的类型（共享&#x2F;独占）及实现原理。</li><li>FileLock 的局限性（跨 JVM、跨 OS 行为差异）。</li><li>文件描述符泄露的常见原因与定位方法。</li><li>文件句柄上限（ulimit）对 Java 服务的影响与排查。</li><li>硬链接与软链接在 Java 中如何区分与操作？</li><li>MappedByteBuffer（内存映射文件）的优劣与风险（内存回收、文件锁）。</li><li>大文件分片读取与并发合并策略。</li><li>如何高效统计大日志文件中某条件的行数（分块 + 并行）？</li><li>文件系统缓存（PageCache）对读写性能的影响机制。</li><li>fsync &#x2F; FileDescriptor.sync 在持久化保障上的作用。</li><li>文件顺序写与随机写的性能差异与优化建议。</li><li>磁盘类型（SSD vs HDD）对 IO 策略的影响。</li><li>原子重命名（renameTo&#x2F;Files.move）的跨平台差异。</li><li>文件监控（WatchService）的实现限制与替代方案。</li><li>处理日志切割（rotation）时的文件句柄管理策略。</li><li>如何实现零停机部署中对文件的平滑迁移？</li><li>软删除（标记删除）与物理删除的 IO 考量。</li><li>备份&#x2F;快照策略对 IO 的影响（冷备 vs 热备）。</li><li>大文件校验（MD5&#x2F;SHA）在流式处理中的实现。</li><li>文件系统一致性问题（写入后立即读取到不同步）如何诊断。</li></ol><hr><h2 id="四、序列化与反序列化（61–75）"><a href="#四、序列化与反序列化（61–75）" class="headerlink" title="四、序列化与反序列化（61–75）"></a>四、序列化与反序列化（61–75）</h2><ol><li>Java 原生序列化（Serializable）的机制和对象写入格式。</li><li>serialVersionUID 的作用、自动生成与兼容性策略。</li><li>transient 字段、static 字段在序列化中的处理。</li><li>Externalizable 与 Serializable 的区别与使用场景。</li><li>Java 序列化的安全风险（反序列化漏洞）与防护措施。</li><li>高性能二进制序列化方案对比：Kryo、Protostuff、Protobuf、Avro。</li><li>JSON 和二进制序列化的权衡（可读性 vs 性能&#x2F;大小）。</li><li>如何实现可演化的序列化协议（向前&#x2F;向后兼容）？</li><li>对象图序列化时循环引用的处理（句柄机制）。</li><li>对象序列化性能调优要点（缓冲、对象重用）。</li><li>在分布式系统中如何管理序列化策略（跨服务版本）？</li><li>自定义序列化（writeObject&#x2F;readObject）常见陷阱。</li><li>序列化时如何处理类加载器问题？</li><li>大对象序列化时的内存与 GC 风险如何降低？</li><li>使用序列化作为缓存（Redis&#x2F;Memcached）时的注意事项。</li></ol><hr><h2 id="五、NIO-深入：Buffer-Channel-Selector（76–100）"><a href="#五、NIO-深入：Buffer-Channel-Selector（76–100）" class="headerlink" title="五、NIO 深入：Buffer &#x2F; Channel &#x2F; Selector（76–100）"></a>五、NIO 深入：Buffer &#x2F; Channel &#x2F; Selector（76–100）</h2><hr><h3 id="1-NIO-三大核心（Buffer、Channel、Selector）"><a href="#1-NIO-三大核心（Buffer、Channel、Selector）" class="headerlink" title="1. NIO 三大核心（Buffer、Channel、Selector）"></a>1. NIO 三大核心（Buffer、Channel、Selector）</h3><ul><li><strong>Buffer</strong>：数据容器，所有读写操作都要通过它完成。</li><li><strong>Channel</strong>：通道，连接数据源与 Buffer，支持双向读写。</li><li><strong>Selector</strong>：多路复用器，检测多个 Channel 的事件（读、写、连接等），实现非阻塞 IO。</li></ul><hr><h3 id="2-ByteBuffer-的-position-limit-capacity"><a href="#2-ByteBuffer-的-position-limit-capacity" class="headerlink" title="2. ByteBuffer 的 position &#x2F; limit &#x2F; capacity"></a>2. ByteBuffer 的 position &#x2F; limit &#x2F; capacity</h3><ul><li><strong>capacity</strong>：缓冲区的总容量，创建时确定。</li><li><strong>position</strong>：当前读写指针，表示下一个操作的位置。</li><li><strong>limit</strong>：可操作的边界，写模式下&#x3D;capacity，读模式下&#x3D;写入的数据量。</li></ul><hr><h3 id="3-flip-clear-rewind-compact"><a href="#3-flip-clear-rewind-compact" class="headerlink" title="3. flip(), clear(), rewind(), compact()"></a>3. flip(), clear(), rewind(), compact()</h3><ul><li><strong>flip()</strong>：切换写 → 读模式（limit&#x3D;position，position&#x3D;0）。</li><li><strong>clear()</strong>：清空缓冲，准备写（position&#x3D;0，limit&#x3D;capacity）。</li><li><strong>rewind()</strong>：重新读（position&#x3D;0，limit 不变）。</li><li><strong>compact()</strong>：未读数据前移，position 指向未读数据末尾。</li></ul><hr><h3 id="4-DirectByteBuffer-vs-HeapByteBuffer"><a href="#4-DirectByteBuffer-vs-HeapByteBuffer" class="headerlink" title="4. DirectByteBuffer vs HeapByteBuffer"></a>4. DirectByteBuffer vs HeapByteBuffer</h3><ul><li><strong>HeapByteBuffer</strong>：数据在 JVM 堆内存，GC 管理，拷贝到内核态多一份。</li><li><strong>DirectByteBuffer</strong>：数据在堆外内存，IO 时零拷贝，性能更高，但分配释放代价大。</li></ul><hr><h3 id="5-ByteBuffer-slice-asReadOnlyBuffer"><a href="#5-ByteBuffer-slice-asReadOnlyBuffer" class="headerlink" title="5. ByteBuffer slice() &#x2F; asReadOnlyBuffer()"></a>5. ByteBuffer slice() &#x2F; asReadOnlyBuffer()</h3><ul><li><strong>slice()</strong>：共享底层数据，新的缓冲区 position&#x3D;0，limit&#x3D;剩余。</li><li><strong>asReadOnlyBuffer()</strong>：生成只读视图，修改会抛 <code>ReadOnlyBufferException</code>。</li></ul><hr><h3 id="6-Scatter-Gather-IO"><a href="#6-Scatter-Gather-IO" class="headerlink" title="6. Scatter&#x2F;Gather IO"></a>6. Scatter&#x2F;Gather IO</h3><ul><li><strong>Scatter Read</strong>：一个 Channel → 多个 Buffer（适合固定头+体）。</li><li><strong>Gather Write</strong>：多个 Buffer → 一个 Channel（避免拼接）。</li></ul><hr><h3 id="7-FileChannel-的关键方法"><a href="#7-FileChannel-的关键方法" class="headerlink" title="7. FileChannel 的关键方法"></a>7. FileChannel 的关键方法</h3><ul><li><strong>position()</strong>：获取&#x2F;设置文件指针。</li><li><strong>size()</strong>：返回文件大小。</li><li><strong>truncate(long size)</strong>：截断文件。</li><li><strong>force(boolean metaData)</strong>：强制写入磁盘。</li></ul><hr><h3 id="8-MappedByteBuffer（内存映射）"><a href="#8-MappedByteBuffer（内存映射）" class="headerlink" title="8. MappedByteBuffer（内存映射）"></a>8. MappedByteBuffer（内存映射）</h3><ul><li><strong>创建</strong>：<code>FileChannel.map(mode, position, size)</code></li><li><strong>优点</strong>：直接操作内存映射，效率高。</li><li><strong>释放</strong>：JDK 无直接 API，通常通过反射 <code>Cleaner.clean()</code>，需注意内存泄露。</li></ul><hr><h3 id="9-Channel-vs-Stream"><a href="#9-Channel-vs-Stream" class="headerlink" title="9. Channel vs Stream"></a>9. Channel vs Stream</h3><ul><li><strong>Stream</strong>：单向、阻塞。</li><li><strong>Channel</strong>：双向、可非阻塞，可和 Selector 配合。</li></ul><hr><h3 id="10-Selector-工作流程"><a href="#10-Selector-工作流程" class="headerlink" title="10. Selector 工作流程"></a>10. Selector 工作流程</h3><ol><li><strong>注册</strong>：<code>channel.register(selector, ops)</code></li><li><strong>选择</strong>：<code>selector.select(timeout)</code></li><li><strong>遍历</strong>：<code>selectedKeys()</code> 遍历处理</li><li><strong>取消</strong>：调用 <code>key.cancel()</code></li></ol><hr><h3 id="11-Selector-底层实现"><a href="#11-Selector-底层实现" class="headerlink" title="11. Selector 底层实现"></a>11. Selector 底层实现</h3><ul><li><strong>Linux</strong>：epoll</li><li><strong>Windows</strong>：select</li><li><strong>macOS</strong>：kqueue<br> 影响性能和可扩展性（epoll 适合高并发）。</li></ul><hr><h3 id="12-非阻塞-Channel-的-read-write-返回值"><a href="#12-非阻塞-Channel-的-read-write-返回值" class="headerlink" title="12. 非阻塞 Channel 的 read&#x2F;write 返回值"></a>12. 非阻塞 Channel 的 read&#x2F;write 返回值</h3><ul><li><p><strong>read</strong>：</p><ul><li><blockquote><p>0：读取字节数</p></blockquote></li><li><p>0：无数据</p></li><li><p>-1：EOF（关闭）</p></li></ul></li><li><p><strong>write</strong>：</p><ul><li><blockquote><p>0：写入字节数</p></blockquote></li><li><p>0：内核缓冲区满</p></li></ul></li></ul><hr><h3 id="13-粘包-拆包问题"><a href="#13-粘包-拆包问题" class="headerlink" title="13. 粘包&#x2F;拆包问题"></a>13. 粘包&#x2F;拆包问题</h3><p>原因：TCP 流式传输无边界。<br> 解决策略：</p><ul><li>固定长度（定长协议）</li><li>分隔符（如 <code>\n</code>）</li><li>长度前置（常见）</li></ul><hr><h3 id="14-超时断开-心跳检测"><a href="#14-超时断开-心跳检测" class="headerlink" title="14. 超时断开 &amp; 心跳检测"></a>14. 超时断开 &amp; 心跳检测</h3><ul><li><strong>超时断开</strong>：在 <code>select(timeout)</code> 中检测长时间无读写的连接。</li><li><strong>心跳检测</strong>：客户端&#x2F;服务端定期发送 <code>PING</code>，无响应则断开。</li></ul><hr><h3 id="15-Pipe-在-NIO-中的作用"><a href="#15-Pipe-在-NIO-中的作用" class="headerlink" title="15. Pipe 在 NIO 中的作用"></a>15. Pipe 在 NIO 中的作用</h3><ul><li>单向通信（写端 → 读端），常用于线程间通信。</li><li>但性能不如 BlockingQueue。</li></ul><hr><h3 id="16-多-Selector-多-Reactor"><a href="#16-多-Selector-多-Reactor" class="headerlink" title="16. 多 Selector &#x2F; 多 Reactor"></a>16. 多 Selector &#x2F; 多 Reactor</h3><ul><li><strong>单 Reactor</strong>：一个线程负责 Selector。</li><li><strong>多 Reactor</strong>：主 Reactor 处理 accept，子 Reactor 处理 read&#x2F;write。</li><li><strong>多 Selector</strong>：线程池分担 Channel 负载。</li></ul><hr><h3 id="17-ByteBuffer-多线程问题"><a href="#17-ByteBuffer-多线程问题" class="headerlink" title="17. ByteBuffer 多线程问题"></a>17. ByteBuffer 多线程问题</h3><ul><li><strong>不是线程安全的</strong>。</li><li>解决：每个线程独立 Buffer，或外部加锁。</li></ul><hr><h3 id="18-DirectByteBuffer-避免泄露"><a href="#18-DirectByteBuffer-避免泄露" class="headerlink" title="18. DirectByteBuffer 避免泄露"></a>18. DirectByteBuffer 避免泄露</h3><ul><li>使用 <code>ByteBuffer.allocateDirect()</code> 代价大。</li><li>建议：使用 <code>-XX:+UseLargePages</code>、池化管理（Netty 的 <code>PooledByteBufAllocator</code>）。</li></ul><hr><h3 id="19-Selector-selectedKeys-正确用法"><a href="#19-Selector-selectedKeys-正确用法" class="headerlink" title="19. Selector selectedKeys 正确用法"></a>19. Selector selectedKeys 正确用法</h3><ul><li>遍历 <code>selectedKeys()</code></li><li>处理完一个 key → <code>iterator.remove()</code></li><li>否则下次循环仍会触发。</li></ul><hr><h3 id="20-NIO-高效读写循环模板"><a href="#20-NIO-高效读写循环模板" class="headerlink" title="20. NIO 高效读写循环模板"></a>20. NIO 高效读写循环模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    selector.select();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.read(buf);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) sc.close();</span><br><span class="line">            <span class="keyword">else</span> &#123; buf.flip(); sc.write(buf); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="21-transferTo-transferFrom（零拷贝）"><a href="#21-transferTo-transferFrom（零拷贝）" class="headerlink" title="21. transferTo&#x2F;transferFrom（零拷贝）"></a>21. transferTo&#x2F;transferFrom（零拷贝）</h3><ul><li>直接在内核空间完成文件复制（减少用户态拷贝）。</li><li>局限：Windows 一次传输大小有限，需循环。</li></ul><hr><h3 id="22-FileChannel-高效复制"><a href="#22-FileChannel-高效复制" class="headerlink" title="22. FileChannel 高效复制"></a>22. FileChannel 高效复制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src).getChannel();</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest).getChannel()) &#123;</span><br><span class="line">    in.transferTo(<span class="number">0</span>, in.size(), out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="23-高并发服务器瓶颈"><a href="#23-高并发服务器瓶颈" class="headerlink" title="23. 高并发服务器瓶颈"></a>23. 高并发服务器瓶颈</h3><ul><li>单线程 Selector 性能不足。</li><li>Buffer&#x2F;Direct 内存泄露。</li><li>大量小包（TCP 粘拆包）。</li><li>epoll 空轮询 bug（CPU 飙高）。</li></ul><hr><h3 id="24-Windows-vs-Linux"><a href="#24-Windows-vs-Linux" class="headerlink" title="24. Windows vs Linux"></a>24. Windows vs Linux</h3><ul><li><strong>Linux</strong>：epoll，可伸缩到百万连接。</li><li><strong>Windows</strong>：select，fd 数量受限，扩展性差。</li></ul><hr><h3 id="25-简单-Echo-Server-思路"><a href="#25-简单-Echo-Server-思路" class="headerlink" title="25. 简单 Echo Server 思路"></a>25. 简单 Echo Server 思路</h3><ol><li>创建 <code>Selector</code></li><li>注册 <code>ServerSocketChannel</code></li><li>循环 <code>select()</code></li><li>处理 <code>accept</code> → 注册 SocketChannel</li><li>处理 <code>read</code> → 回写数据</li></ol><hr><p>⚡总结：NIO 的核心是 <strong>缓冲区管理</strong>（ByteBuffer）、<strong>多路复用</strong>（Selector）、<strong>零拷贝优化</strong>（FileChannel.transferTo&#x2F;MappedByteBuffer）。<br> 在高并发系统里（如 Netty），这些 API 会结合线程模型和内存池进一步优化。</p><hr><h2 id="六、Socket-TCP-UDP-WebSocket（101–140）"><a href="#六、Socket-TCP-UDP-WebSocket（101–140）" class="headerlink" title="六、Socket &#x2F; TCP &#x2F; UDP &#x2F; WebSocket（101–140）"></a>六、Socket &#x2F; TCP &#x2F; UDP &#x2F; WebSocket（101–140）</h2><ol><li>Socket 的基本概念：端点、三元组&#x2F;四元组（IP:port + peer）。</li><li>Java 中 Socket、ServerSocket、DatagramSocket 的主要 API 区别。</li><li>TCP 与 UDP 的核心差异（可靠性、有序性、连接性）。</li><li>TCP 三次握手（SYN、SYN-ACK、ACK）与四次挥手流程详解。</li><li>TIME_WAIT、CLOSE_WAIT、FIN_WAIT1&#x2F;2 等 TCP 状态含义与产生原因。</li><li>半开连接（half-open）是什么，如何检测与恢复？</li><li>TCP 的流量控制（窗口）与拥塞控制（慢启动、拥塞避免、快重传、快恢复）基础。</li><li>Nagle 算法（TCP_NODELAY）的原理和在延迟场景下的影响。</li><li>TCP 延迟确认（delayed ACK）对交互型应用的影响。</li><li>Socket 选项 SO_TIMEOUT、SO_KEEPALIVE、SO_REUSEADDR、SO_REUSEPORT、SO_LINGER 含义与使用场景。</li><li>backlog 参数（ServerSocket 构造或 listen）与 accept 队列（syn, accept 队列）区别。</li><li>ephemeral port（短暂端口）与端口耗尽问题及解决办法。</li><li>SYN flood 攻击的原理和防护（SYN cookies、firewall）。</li><li>TCP 快速打开（TCP Fast Open）是什么，有何优劣？（简述）</li><li>MTU、MSS 与 IP 分片对传输的影响与诊断方法。</li><li>UDP 的组播（Multicast）与广播（Broadcast）机制与 Java 支持（MulticastSocket）。</li><li>UDP 丢包、乱序、包大小限制（最佳实践）。</li><li>UDP 穿透 NAT（STUN&#x2F;ICE）的基本原理。</li><li>如何在 Java 中实现高性能 UDP 服务器？（NIO + DatagramChannel）</li><li>WebSocket 协议基础（握手、帧格式、ping&#x2F;pong、close）。</li><li>Java 实现 WebSocket 的常见库（javax.websocket、Netty websocket、Undertow）。</li><li>TLS over TCP（HTTPS）的握手流程要点（证书验证、对称密钥协商）。</li><li>使用 SSLSocket &#x2F; SSLServerSocket 和 SSLEngine 的差别及适用场景。</li><li>SSL&#x2F;TLS 握手的重用（session resumption）与性能优化。</li><li>中间人攻击（MITM）与证书链、CA、信任根的角色。</li><li>如何在 Socket 程序中实现心跳、超时与断线重连？</li><li>TCP Keepalive 与应用层心跳的区别和协同使用。</li><li>如何通过抓包（tcpdump&#x2F;wireshark）诊断 Socket 连接问题？</li><li>Socket 的非阻塞 accept&#x2F;read&#x2F;write 实现注意点（资源&#x2F;异步安全）。</li><li>如何避免 TCP 粘包&#x2F;拆包在 Socket 原生编程中的影响（流式协议设计）？</li><li>实战：实现一个带长度前缀的 TCP 协议的 Java 服务端&#x2F;客户端（思路）。</li><li>如何优雅处理大量短连接的场景？（连接池、HTTP keep-alive）</li><li>Socket 端口复用（SO_REUSEADDR vs SO_REUSEPORT）在负载均衡中的用法。</li><li>多路复用（select&#x2F;poll&#x2F;epoll）与 socket 大连接数的处理。</li><li>网络字节序（big-endian）与数据编解码注意点。</li><li>使用 TCP_NODELAY（禁用 Nagle）时的 CPU&#x2F;网络 trade-off。</li><li>如何在 Java 中做到零拷贝文件传输（Socket + FileChannel.transferTo）？</li><li>Socket 关闭流程中遇到阻塞（SO_LINGER）的处理办法。</li><li>如何防止或检测 “socket half-closed” 的资源泄漏？</li><li>实战题：用 BIO、NIO、Netty 各实现一个简易的聊天服务器，比较性能与代码复杂度（思路要点）。</li></ol><hr><h2 id="七、异步-IO、IO-模型与高阶模式（141–150）"><a href="#七、异步-IO、IO-模型与高阶模式（141–150）" class="headerlink" title="七、异步 IO、IO 模型与高阶模式（141–150）"></a>七、异步 IO、IO 模型与高阶模式（141–150）</h2><ol><li>IO 模型分类：同步阻塞、同步非阻塞、IO 多路复用、信号驱动、异步（AIO）。</li><li>Reactor 模式与 Proactor 模式的原理与区别。</li><li>Java AIO（AsynchronousChannel、AsynchronousSocketChannel）API 介绍。</li><li>CompletionHandler 与 Future 风格的异步回调比较。</li><li>高并发下选择 NIO 还是 AIO 的实际考量（实现复杂度、平台支持）。</li><li>事件驱动系统的 back-pressure 设计（流控、速率限制）。</li><li>线程模型设计：acceptors &#x2F; io workers &#x2F; business workers 的权衡。</li><li>RCU、无锁队列在高并发 IO 框架中的应用场景。</li><li>如何在应用层实现请求队列与排队策略来缓解突发流量？</li><li>实战题：设计一个支持百万连接的服务器架构（核心组件与 IO 策略）。</li></ol><hr><h2 id="八、零拷贝、内核与性能调优（151–160）"><a href="#八、零拷贝、内核与性能调优（151–160）" class="headerlink" title="八、零拷贝、内核与性能调优（151–160）"></a>八、零拷贝、内核与性能调优（151–160）</h2><ol><li>零拷贝（zero-copy）概念和常见实现（sendfile, mmap, splice）。</li><li>FileChannel.transferTo&#x2F;transferFrom 在 Linux 下如何利用 sendfile 实现零拷贝？</li><li>mmap（内存映射文件）的实现原理与 GC &#x2F;回收问题。</li><li>DMA（Direct Memory Access）在零拷贝中的作用与限制。</li><li>内核态 &#x2F; 用户态拷贝次数与零拷贝带来的减少效果。</li><li>TCP 窗口、拥塞控制调优参数（net.ipv4.tcp_* 系列常见项）。</li><li>系统级调优：文件描述符上限（ulimit -n）、somaxconn、backlog、epoll_limits 等。</li><li>高并发网络服务的监控指标（fd 使用、accept latency、context switch、cpu steal）。</li><li>性能诊断工具与流程：iostat, vmstat, sar, perf, tcpdump, ss, strace。</li><li>实战题：如何定位并修复一个高并发服务器的 accept 阻塞 &#x2F; 连接丢失 问题（诊断步骤）。</li></ol><hr><h1 id="Java-基础面试题"><a href="#Java-基础面试题" class="headerlink" title="Java 基础面试题"></a>Java 基础面试题</h1><h3 id="一、语言特性-基础语法"><a href="#一、语言特性-基础语法" class="headerlink" title="一、语言特性 &amp; 基础语法"></a>一、语言特性 &amp; 基础语法</h3><hr><h3 id="1-Java-中的-和-equals-有什么区别？如何正确重写-equals-？"><a href="#1-Java-中的-和-equals-有什么区别？如何正确重写-equals-？" class="headerlink" title="1. Java 中的 &#x3D;&#x3D; 和 equals() 有什么区别？如何正确重写 equals()？"></a>1. Java 中的 &#x3D;&#x3D; 和 equals() 有什么区别？如何正确重写 equals()？</h3><ul><li><strong>&#x3D;&#x3D;</strong><ul><li>对于基本数据类型：比较值是否相等。</li><li>对于引用类型：比较两个引用是否指向同一块内存地址（即是否是同一个对象）。</li></ul></li><li><strong>equals()</strong><ul><li>定义在 <code>Object</code> 类中，默认实现也是 <code>==</code>。</li><li>一般会被类（如 <code>String</code>、<code>Integer</code> 等）重写，用来比较“内容”是否相同，而不是内存地址。</li></ul></li></ul><p>👉 正确重写 <code>equals()</code> 要满足 <strong>自反性、对称性、传递性、一致性</strong>，并且和 <code>null</code> 比较时返回 <code>false</code>。<br> 典型实现步骤：</p><ol><li>判断 <code>this == obj</code>，若相等直接返回 <code>true</code>。</li><li>判断 <code>obj</code> 是否为同类实例。</li><li>强制类型转换后逐个比较关键字段。</li></ol><hr><h3 id="2-为什么重写-equals-时必须重写-hashCode-？不重写会怎样？"><a href="#2-为什么重写-equals-时必须重写-hashCode-？不重写会怎样？" class="headerlink" title="2. 为什么重写 equals() 时必须重写 hashCode()？不重写会怎样？"></a>2. 为什么重写 equals() 时必须重写 hashCode()？不重写会怎样？</h3><ul><li><strong>原因</strong>：因为 <code>HashMap</code>、<code>HashSet</code> 等基于哈希表的集合使用 <code>hashCode()</code> 来决定元素存放位置，然后再用 <code>equals()</code> 判断元素是否相同。</li><li><strong>契约</strong>（JDK 文档规定）：<ul><li>如果两个对象 <code>equals()</code> 相等，那么它们的 <code>hashCode()</code> 必须相等。</li><li>反之，<code>hashCode()</code> 相等并不一定意味着 <code>equals()</code> 相等。</li></ul></li><li><strong>不重写会怎样</strong>：<ul><li>两个内容相同的对象可能 <code>equals()</code> 为 true，但 <code>hashCode()</code> 不同，导致放进 <code>HashSet</code> 时被当作两个对象存储，违背集合“不重复”的原则。</li></ul></li></ul><hr><h3 id="3-Object-类有哪些方法？哪些方法经常需要重写？"><a href="#3-Object-类有哪些方法？哪些方法经常需要重写？" class="headerlink" title="3. Object 类有哪些方法？哪些方法经常需要重写？"></a>3. Object 类有哪些方法？哪些方法经常需要重写？</h3><ul><li><strong>常用方法</strong>：<ul><li><code>equals()</code>：对象内容比较。</li><li><code>hashCode()</code>：哈希值，配合 <code>equals</code>。</li><li><code>toString()</code>：对象的字符串表示。</li><li><code>clone()</code>：对象克隆（浅拷贝，需实现 <code>Cloneable</code>）。</li><li><code>finalize()</code>：对象被 GC 前调用（已不推荐使用）。</li></ul></li><li><strong>同步方法</strong>：<ul><li><code>wait()</code> &#x2F; <code>notify()</code> &#x2F; <code>notifyAll()</code>：线程通信。</li></ul></li><li><strong>类相关方法</strong>：<ul><li><code>getClass()</code>：获取对象的运行时类型。</li></ul></li></ul><p>👉 经常需要重写的：<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>。</p><hr><h3 id="4-final、finally、finalize-有什么区别？"><a href="#4-final、finally、finalize-有什么区别？" class="headerlink" title="4. final、finally、finalize() 有什么区别？"></a>4. final、finally、finalize() 有什么区别？</h3><ul><li><strong>final</strong>：关键字<ul><li>修饰类：类不能被继承。</li><li>修饰方法：方法不能被重写。</li><li>修饰变量：变量成为常量，只能赋值一次。</li></ul></li><li><strong>finally</strong>：关键字<ul><li>用于 <code>try-catch-finally</code>，无论是否有异常，<code>finally</code> 块中的代码一定会执行（除非 <code>System.exit(0)</code>）。</li></ul></li><li><strong>finalize()</strong>：方法<ul><li><code>Object</code> 类定义，在 GC 前调用，常用于释放非托管资源。</li><li>已被标记为废弃（Java 9 开始），因为不可预测、不可靠。</li></ul></li></ul><hr><h3 id="5-Java-中的-instanceof-关键字是如何实现的？"><a href="#5-Java-中的-instanceof-关键字是如何实现的？" class="headerlink" title="5. Java 中的 instanceof 关键字是如何实现的？"></a>5. Java 中的 instanceof 关键字是如何实现的？</h3><ul><li><strong>作用</strong>：判断某个对象是否为某个类或其子类的实例。</li><li><strong>实现原理</strong>：<ul><li>JVM 在对象头中存储了对象所属的类的元数据指针。</li><li><code>instanceof</code> 实际是检查该类元数据是否是指定类或其子类。</li><li>编译器会将 <code>obj instanceof A</code> 转换为字节码 <code>instanceof</code> 指令，由 JVM 在运行时判断。</li></ul></li></ul><hr><h3 id="6-接口和抽象类的区别？接口能不能有构造函数？"><a href="#6-接口和抽象类的区别？接口能不能有构造函数？" class="headerlink" title="6. 接口和抽象类的区别？接口能不能有构造函数？"></a>6. 接口和抽象类的区别？接口能不能有构造函数？</h3><ul><li><strong>接口</strong>：<ul><li>只能定义方法（Java 8 之后可有 <code>default</code> 和 <code>static</code> 方法）。</li><li>不能有构造函数（因为接口不能直接实例化）。</li><li>可以实现 <strong>多继承</strong>（一个类可以实现多个接口）。</li></ul></li><li><strong>抽象类</strong>：<ul><li>可以有普通方法、抽象方法、成员变量。</li><li>可以有构造函数（但不能直接 new，用于子类构造时调用）。</li><li>只能单继承。</li></ul></li></ul><hr><h3 id="7-接口可以多继承吗？抽象类可以实现接口吗？"><a href="#7-接口可以多继承吗？抽象类可以实现接口吗？" class="headerlink" title="7. 接口可以多继承吗？抽象类可以实现接口吗？"></a>7. 接口可以多继承吗？抽象类可以实现接口吗？</h3><ul><li><strong>接口可以多继承</strong>：<code>interface A extends B, C &#123;&#125;</code></li><li><strong>抽象类可以实现接口</strong>：可以选择性实现接口的方法，未实现的方法仍保持 <code>abstract</code>，由子类实现。</li></ul><hr><h3 id="8-default-方法和-static-方法在接口中的意义是什么？"><a href="#8-default-方法和-static-方法在接口中的意义是什么？" class="headerlink" title="8. default 方法和 static 方法在接口中的意义是什么？"></a>8. default 方法和 static 方法在接口中的意义是什么？</h3><ul><li><strong>default 方法</strong>：<ul><li>Java 8 引入，接口中可以有默认实现的方法。</li><li>解决接口扩展的兼容性问题（给老接口新增方法不会导致所有实现类报错）。</li></ul></li><li><strong>static 方法</strong>：<ul><li>属于接口本身，而不是实现类。</li><li>用于提供工具方法或公共逻辑（类似 <code>Collections</code> 的工具类方法）。</li></ul></li></ul><hr><h3 id="9-什么是内部类？分为哪几种？"><a href="#9-什么是内部类？分为哪几种？" class="headerlink" title="9. 什么是内部类？分为哪几种？"></a>9. 什么是内部类？分为哪几种？</h3><ul><li><strong>内部类</strong>：定义在类中的类，可以访问外部类的成员。</li><li><strong>种类</strong>：<ol><li><strong>成员内部类</strong>（非静态内部类）<ul><li>依赖外部类实例，不能有 <code>static</code> 成员。</li></ul></li><li><strong>静态内部类</strong><ul><li>类似普通类，但作用域在外部类内，可以有 <code>static</code> 成员。</li></ul></li><li><strong>局部内部类</strong><ul><li>定义在方法体或代码块中，只能在该范围内使用。</li></ul></li><li><strong>匿名内部类</strong><ul><li>没有名字，通常在需要“临时实现接口或继承类”的场景使用。</li></ul></li></ol></li></ul><hr><h3 id="10-匿名内部类和-Lambda-表达式的区别？"><a href="#10-匿名内部类和-Lambda-表达式的区别？" class="headerlink" title="10. 匿名内部类和 Lambda 表达式的区别？"></a>10. 匿名内部类和 Lambda 表达式的区别？</h3><ul><li><strong>匿名内部类</strong>：<ul><li>实现接口&#x2F;继承抽象类的 <strong>具体匿名类对象</strong>。</li><li>可以有多个方法，但通常只重写需要的方法。</li><li>生成 <code>.class</code> 文件（额外开销）。</li></ul></li><li><strong>Lambda 表达式</strong>：<ul><li>仅能用于 <strong>函数式接口</strong>（只有一个抽象方法的接口）。</li><li>更简洁，本质是语法糖，编译后生成 <code>invokedynamic</code> 字节码指令，调用运行时生成的函数对象。</li><li>不会创建新的 <code>.class</code> 文件，更轻量。</li></ul></li></ul><hr><h3 id="二、数据类型-内存"><a href="#二、数据类型-内存" class="headerlink" title="二、数据类型 &amp; 内存"></a>二、数据类型 &amp; 内存</h3><hr><h3 id="1-Java-中的基本数据类型和包装类型有哪些区别？"><a href="#1-Java-中的基本数据类型和包装类型有哪些区别？" class="headerlink" title="1. Java 中的基本数据类型和包装类型有哪些区别？"></a>1. Java 中的基本数据类型和包装类型有哪些区别？</h3><ul><li><strong>基本数据类型</strong>（primitive）：<code>byte, short, int, long, float, double, char, boolean</code><ul><li>存储在栈上（或寄存器），效率高，空间占用固定。</li><li>不能为 <code>null</code>，默认值固定（如 <code>int</code> 默认 <code>0</code>，<code>boolean</code> 默认 <code>false</code>）。</li></ul></li><li><strong>包装类型</strong>（wrapper）：<code>Byte, Short, Integer, Long, Float, Double, Character, Boolean</code><ul><li>是对象，存储在堆中。</li><li>可以为 <code>null</code>，有丰富的 API。</li><li>可以参与集合类（如 <code>ArrayList</code> 只能存对象）。</li></ul></li><li><strong>自动装箱&#x2F;拆箱</strong>：Java 会在基本类型和包装类之间自动转换。</li></ul><hr><h3 id="2-为什么-Integer-有缓存机制？范围是多少？"><a href="#2-为什么-Integer-有缓存机制？范围是多少？" class="headerlink" title="2. 为什么 Integer 有缓存机制？范围是多少？"></a>2. 为什么 Integer 有缓存机制？范围是多少？</h3><ul><li><strong>原因</strong>：<ul><li>为了避免频繁创建对象，提高性能。</li><li>小整数使用频率高（如循环、下标），所以缓存常用的整数。</li></ul></li><li><strong>范围</strong>：<code>-128 ~ 127</code>。</li><li><strong>实现</strong>：<ul><li><code>IntegerCache</code> 静态内部类在类加载时初始化缓存数组。</li><li><code>Integer.valueOf(int i)</code> 方法会先查缓存，再决定是否 new 对象。</li></ul></li></ul><hr><h3 id="3-为什么-new-Integer-127-new-Integer-127-为-false，而-Integer-valueOf-127-Integer-valueOf-127-为-true？"><a href="#3-为什么-new-Integer-127-new-Integer-127-为-false，而-Integer-valueOf-127-Integer-valueOf-127-为-true？" class="headerlink" title="3. 为什么 new Integer(127) == new Integer(127) 为 false，而 Integer.valueOf(127) == Integer.valueOf(127) 为 true？"></a>3. 为什么 <code>new Integer(127) == new Integer(127)</code> 为 false，而 <code>Integer.valueOf(127) == Integer.valueOf(127)</code> 为 true？</h3><ul><li><code>new Integer(127)</code>：每次都会创建新对象，内存地址不同，所以 <code>==</code> 为 false。</li><li><code>Integer.valueOf(127)</code>：会查缓存，<code>127</code> 在 <code>-128~127</code> 范围内，返回同一个对象引用，所以 <code>==</code> 为 true。</li></ul><p>👉 <strong>总结</strong>：</p><ul><li><code>==</code> 比较的是引用地址。</li><li><code>equals()</code> 才是比较数值。</li></ul><hr><h3 id="4-NaN-和-Infinity-在-Java-中如何表示？"><a href="#4-NaN-和-Infinity-在-Java-中如何表示？" class="headerlink" title="4. NaN 和 Infinity 在 Java 中如何表示？"></a>4. NaN 和 Infinity 在 Java 中如何表示？</h3><ul><li><strong>NaN（Not a Number）</strong>：<ul><li>如 <code>0.0 / 0.0</code> 或 <code>Math.sqrt(-1)</code>。</li><li>特点：<code>NaN != NaN</code>，要用 <code>Double.isNaN()</code> 检测。</li></ul></li><li><strong>Infinity（正&#x2F;负无穷大）</strong>：<ul><li>如 <code>1.0 / 0.0 = Infinity</code>，<code>-1.0 / 0.0 = -Infinity</code>。</li><li>用 <code>Double.isInfinite()</code> 检测。</li></ul></li></ul><hr><h3 id="5-为什么浮点数计算有精度问题？如何避免？"><a href="#5-为什么浮点数计算有精度问题？如何避免？" class="headerlink" title="5. 为什么浮点数计算有精度问题？如何避免？"></a>5. 为什么浮点数计算有精度问题？如何避免？</h3><ul><li><strong>原因</strong>：<ul><li>浮点数采用 <strong>IEEE 754 二进制浮点表示</strong>，大多数十进制小数（如 <code>0.1</code>）不能精确表示，只能存储近似值。</li><li>计算时会累积误差。</li></ul></li><li><strong>避免方法</strong>：<ul><li>使用 <code>BigDecimal</code>（推荐）。</li><li>或使用整数替代（如金额用分而不是元）。</li></ul></li></ul><hr><h3 id="6-BigDecimal-为什么能解决浮点数精度问题？"><a href="#6-BigDecimal-为什么能解决浮点数精度问题？" class="headerlink" title="6. BigDecimal 为什么能解决浮点数精度问题？"></a>6. BigDecimal 为什么能解决浮点数精度问题？</h3><ul><li><strong>原理</strong>：<ul><li>内部使用 <strong>BigInteger + 精度标识 scale</strong> 表示任意精度的十进制数。</li><li>不依赖二进制浮点存储，而是基于字符串或整数进行精确计算。</li></ul></li><li><strong>注意</strong>：<ul><li>不能用 <code>new BigDecimal(double)</code>（会带入二进制误差）。</li><li>推荐 <code>BigDecimal.valueOf(double)</code> 或 <code>new BigDecimal(String)</code>。</li></ul></li></ul><hr><h3 id="7-Java-中的字符集默认是什么？在不同平台上会不一样吗？"><a href="#7-Java-中的字符集默认是什么？在不同平台上会不一样吗？" class="headerlink" title="7. Java 中的字符集默认是什么？在不同平台上会不一样吗？"></a>7. Java 中的字符集默认是什么？在不同平台上会不一样吗？</h3><ul><li>Java 内部使用 <strong>UTF-16（Unicode）</strong> 存储 <code>char</code> 和 <code>String</code>。</li><li>默认字符集（<code>Charset.defaultCharset()</code>）会随平台不同而不同：<ul><li>Windows（中文环境）：<code>GBK</code> 或 <code>GB2312</code>。</li><li>Linux &#x2F; macOS：通常是 <code>UTF-8</code>。<br> 👉 这会影响文件读写、网络传输等。</li></ul></li></ul><hr><h3 id="8-String、StringBuilder、StringBuffer-区别？线程安全性？"><a href="#8-String、StringBuilder、StringBuffer-区别？线程安全性？" class="headerlink" title="8. String、StringBuilder、StringBuffer 区别？线程安全性？"></a>8. String、StringBuilder、StringBuffer 区别？线程安全性？</h3><ul><li><strong>String</strong><ul><li>不可变类（底层 <code>final char[]</code>），每次拼接都会生成新对象。</li></ul></li><li><strong>StringBuilder</strong><ul><li>可变字符序列（底层 <code>char[]</code>），高效，<strong>非线程安全</strong>。</li></ul></li><li><strong>StringBuffer</strong><ul><li>可变字符序列，方法加了 <code>synchronized</code>，<strong>线程安全</strong>，效率比 <code>StringBuilder</code> 低。</li></ul></li></ul><p>👉 单线程推荐 <code>StringBuilder</code>，多线程推荐 <code>StringBuffer</code>。</p><hr><h3 id="9-为什么-String-是不可变的？背后实现细节？"><a href="#9-为什么-String-是不可变的？背后实现细节？" class="headerlink" title="9. 为什么 String 是不可变的？背后实现细节？"></a>9. 为什么 String 是不可变的？背后实现细节？</h3><ul><li><strong>原因</strong>：<ol><li><strong>安全性</strong>：如网络请求 URL、文件路径、ClassLoader 名称等，一旦创建不可修改，避免被篡改。</li><li><strong>线程安全</strong>：不可变对象天然线程安全。</li><li><strong>哈希值缓存</strong>：<code>String</code> 缓存了 <code>hashCode</code>，不可变保证哈希值不会变化。</li><li><strong>字符串常量池优化</strong>：不可变对象可被复用。</li></ol></li><li><strong>实现</strong>：<ul><li><code>private final char[] value</code>（JDK 9 以后改成 <code>byte[]</code> + <code>coder</code>，节省内存）。</li></ul></li></ul><hr><h3 id="10-intern-方法的作用是什么？"><a href="#10-intern-方法的作用是什么？" class="headerlink" title="10. intern() 方法的作用是什么？"></a>10. intern() 方法的作用是什么？</h3><ul><li><p><strong>作用</strong>：</p><ul><li>将字符串放入 <strong>字符串常量池</strong>，返回池中的引用。</li><li>若池中已有等值字符串，则返回已有对象引用。</li></ul></li><li><p><strong>意义</strong>：</p><ul><li>减少内存占用，提高比较效率（常量池中的 <code>String</code> 可以直接用 <code>==</code> 比较）。</li></ul></li><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s2 == s3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="三、集合框架"><a href="#三、集合框架" class="headerlink" title="三、集合框架"></a>三、集合框架</h3><hr><h2 id="1-ArrayList-和-Vector-的区别"><a href="#1-ArrayList-和-Vector-的区别" class="headerlink" title="1. ArrayList 和 Vector 的区别"></a><strong>1. ArrayList 和 Vector 的区别</strong></h2><table><thead><tr><th>特性</th><th>ArrayList</th><th>Vector</th></tr></thead><tbody><tr><td>线程安全</td><td>非线程安全</td><td>线程安全（方法加 synchronized）</td></tr><tr><td>扩容机制</td><td>默认 1.5 倍</td><td>默认 2 倍</td></tr><tr><td>性能</td><td>高（无锁）</td><td>低（同步开销）</td></tr><tr><td>用途</td><td>多线程外部不安全</td><td>适合多线程共享场景，但现在较少使用</td></tr><tr><td>面试拓展</td><td>如何在多线程下安全使用 ArrayList？可用 <code>Collections.synchronizedList()</code> 或 <code>CopyOnWriteArrayList</code></td><td></td></tr></tbody></table><p><strong>原理</strong>：</p><ul><li>都基于动态数组实现</li><li>添加元素时如果容量不够，会创建一个新的数组并复制原数组内容</li></ul><hr><h2 id="2-为什么-ArrayList-的扩容是-1-5-倍？"><a href="#2-为什么-ArrayList-的扩容是-1-5-倍？" class="headerlink" title="2. 为什么 ArrayList 的扩容是 1.5 倍？"></a><strong>2. 为什么 ArrayList 的扩容是 1.5 倍？</strong></h2><ul><li><p><strong>目的</strong>：平衡 <strong>内存消耗</strong> 和 <strong>扩容频率</strong></p></li><li><p><strong>原理</strong>：</p><ul><li>过小扩容：频繁创建新数组，复制开销大</li><li>过大扩容：浪费内存</li></ul></li><li><p>JDK 1.8 的扩容公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 相当于 1.5 倍</span></span><br></pre></td></tr></table></figure></li><li><p>面试点：</p><ul><li>LinkedList 不需要扩容，因为链表动态增长</li><li>如何自定义扩容策略？</li></ul></li></ul><hr><h2 id="3-LinkedList-是双向链表还是单向链表？"><a href="#3-LinkedList-是双向链表还是单向链表？" class="headerlink" title="3. LinkedList 是双向链表还是单向链表？"></a><strong>3. LinkedList 是双向链表还是单向链表？</strong></h2><ul><li><p><strong>Java 中 LinkedList 是双向链表</strong></p></li><li><p><strong>结构</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>优点</strong>：</p><ul><li>支持快速插入&#x2F;删除（O(1)）</li><li>支持从头尾遍历</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>随机访问慢（O(n)）</li><li>内存占用大（需要 prev 指针）</li></ul></li></ul><hr><h2 id="4-HashSet-底层实现"><a href="#4-HashSet-底层实现" class="headerlink" title="4. HashSet 底层实现"></a><strong>4. HashSet 底层实现</strong></h2><ul><li><strong>底层使用 HashMap 实现</strong></li><li><strong>原理</strong>：<ul><li>每个元素作为 <code>HashMap</code> 的 key</li><li>value 使用一个固定的 Object 对象 <code>PRESENT</code></li></ul></li><li><strong>特点</strong>：<ul><li>不允许重复</li><li>无序存储</li></ul></li><li><strong>性能</strong>：<ul><li>插入、删除、查找均 O(1) 平均</li></ul></li><li>面试拓展：HashSet 和 LinkedHashSet 的区别？<ul><li>LinkedHashSet 维护了插入顺序</li></ul></li></ul><hr><h2 id="5-TreeSet-和-TreeMap-的底层实现"><a href="#5-TreeSet-和-TreeMap-的底层实现" class="headerlink" title="5. TreeSet 和 TreeMap 的底层实现"></a><strong>5. TreeSet 和 TreeMap 的底层实现</strong></h2><ul><li><strong>TreeMap</strong>：基于 <strong>红黑树</strong> 实现</li><li><strong>TreeSet</strong>：内部使用 TreeMap 存储元素</li><li><strong>特点</strong>：<ul><li>自动排序（自然排序或 Comparator）</li><li>查找、插入、删除 O(log n)</li></ul></li><li><strong>红黑树特性</strong>：<ul><li>自平衡二叉搜索树</li><li>插入&#x2F;删除保持平衡，通过旋转和染色操作</li></ul></li></ul><hr><h2 id="6-PriorityQueue-的底层数据结构"><a href="#6-PriorityQueue-的底层数据结构" class="headerlink" title="6. PriorityQueue 的底层数据结构"></a><strong>6. PriorityQueue 的底层数据结构</strong></h2><ul><li><p><strong>基于堆实现</strong>（默认最小堆）</p></li><li><p><strong>特性</strong>：</p><ul><li>插入 O(log n)</li><li>取出最小值 O(log n)</li></ul></li><li><p><strong>内部实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] queue; <span class="comment">// 动态数组存储堆</span></span><br></pre></td></tr></table></figure></li><li><p><strong>应用</strong>：</p><ul><li>定时任务调度</li><li>Dijkstra 算法</li></ul></li><li><p>面试拓展：如何实现最大堆？</p><ul><li>使用 Comparator 或覆写 compare 方法</li></ul></li></ul><hr><h2 id="7-ConcurrentSkipListMap-的底层原理"><a href="#7-ConcurrentSkipListMap-的底层原理" class="headerlink" title="7. ConcurrentSkipListMap 的底层原理"></a><strong>7. ConcurrentSkipListMap 的底层原理</strong></h2><ul><li><strong>基于跳表实现</strong></li><li><strong>特点</strong>：<ul><li>有序 Map，支持并发操作</li><li>读操作无锁（lock-free），写操作使用 CAS&#x2F;锁粒度较小</li></ul></li><li><strong>跳表原理</strong>：<ul><li>多层链表</li><li>顶层链表间隔大</li><li>查找、插入、删除 O(log n) 平均</li></ul></li></ul><hr><h2 id="8-CopyOnWriteArrayList-的写时复制"><a href="#8-CopyOnWriteArrayList-的写时复制" class="headerlink" title="8. CopyOnWriteArrayList 的写时复制"></a><strong>8. CopyOnWriteArrayList 的写时复制</strong></h2><ul><li><strong>原理</strong>：<ul><li>每次写操作（add、remove）都会复制一份底层数组</li><li>读操作不加锁，直接读取旧数组</li></ul></li><li><strong>优点</strong>：<ul><li>高度并发读性能</li><li>避免 ConcurrentModificationException</li></ul></li><li><strong>缺点</strong>：<ul><li>写操作成本高（数组复制）</li><li>内存开销大</li></ul></li><li><strong>应用场景</strong>：<ul><li>读多写少（如监听器列表、配置缓存）</li></ul></li></ul><hr><h2 id="9-EnumMap-和-EnumSet"><a href="#9-EnumMap-和-EnumSet" class="headerlink" title="9. EnumMap 和 EnumSet"></a><strong>9. EnumMap 和 EnumSet</strong></h2><ul><li><strong>EnumMap</strong>：<ul><li>Key 是枚举类型</li><li>底层使用数组存储，效率高</li></ul></li><li><strong>EnumSet</strong>：<ul><li>元素为枚举</li><li>底层使用 <strong>位向量(bit vector)</strong> 存储</li></ul></li><li><strong>特点</strong>：<ul><li>高效，占用内存小</li><li>遍历速度快</li></ul></li><li><strong>应用</strong>：<ul><li>状态机、标志位集合</li></ul></li></ul><hr><h2 id="10-WeakHashMap-和-HashMap-的区别"><a href="#10-WeakHashMap-和-HashMap-的区别" class="headerlink" title="10. WeakHashMap 和 HashMap 的区别"></a><strong>10. WeakHashMap 和 HashMap 的区别</strong></h2><table><thead><tr><th>特性</th><th>HashMap</th><th>WeakHashMap</th></tr></thead><tbody><tr><td>Key 引用类型</td><td>强引用</td><td>弱引用</td></tr><tr><td>GC 行为</td><td>不受垃圾回收影响</td><td>Key 被回收时自动删除 Entry</td></tr><tr><td>用途</td><td>普通 Map</td><td>缓存、内存敏感对象的映射</td></tr><tr><td>面试点</td><td>WeakHashMap 如何防止内存泄漏？</td><td></td></tr></tbody></table><p><strong>原理</strong>：</p><ul><li>WeakHashMap 的 key 是 <code>WeakReference</code></li><li>当 key 不再被外部强引用时，垃圾回收器回收，并通过 ReferenceQueue 清理 Entry</li></ul><hr><h3 id="四、异常-错误处理"><a href="#四、异常-错误处理" class="headerlink" title="四、异常 &amp; 错误处理"></a>四、异常 &amp; 错误处理</h3><hr><h2 id="1-Java-中的异常分为哪两大类？"><a href="#1-Java-中的异常分为哪两大类？" class="headerlink" title="1. Java 中的异常分为哪两大类？"></a><strong>1. Java 中的异常分为哪两大类？</strong></h2><ul><li><strong>Error（错误）</strong>：<ul><li>系统级错误，通常无法恢复</li><li>例子：<code>OutOfMemoryError</code>、<code>StackOverflowError</code></li><li>不建议捕获</li></ul></li><li><strong>Exception（异常）</strong>：<ul><li>程序可以捕获、处理</li><li>子类：<ol><li><strong>受检异常（CheckedException）</strong>：必须 try&#x2F;catch 或 throws 抛出<ul><li>例子：<code>IOException</code>、<code>SQLException</code></li></ul></li><li><strong>非受检异常（UncheckedException &#x2F; RuntimeException）</strong>：可选择捕获<ul><li>例子：<code>NullPointerException</code>、<code>IllegalArgumentException</code></li></ul></li></ol></li></ul></li></ul><p><strong>面试点</strong>：</p><ul><li>Checked vs Unchecked 异常的设计初衷：<ul><li>Checked 异常强制处理，提高程序健壮性</li><li>RuntimeException 用于编程错误，不必强制捕获</li></ul></li></ul><hr><h2 id="2-Error-和-Exception-的区别"><a href="#2-Error-和-Exception-的区别" class="headerlink" title="2. Error 和 Exception 的区别"></a><strong>2. Error 和 Exception 的区别</strong></h2><table><thead><tr><th>特性</th><th>Error</th><th>Exception</th></tr></thead><tbody><tr><td>是否可恢复</td><td>不可恢复</td><td>可恢复（程序可处理）</td></tr><tr><td>捕获建议</td><td>不建议捕获</td><td>建议捕获和处理</td></tr><tr><td>子类示例</td><td>OutOfMemoryError</td><td>IOException, SQLException</td></tr><tr><td>使用场景</td><td>JVM 内部错误</td><td>应用程序异常处理</td></tr></tbody></table><hr><h2 id="3-受检异常和非受检异常区别"><a href="#3-受检异常和非受检异常区别" class="headerlink" title="3. 受检异常和非受检异常区别"></a><strong>3. 受检异常和非受检异常区别</strong></h2><table><thead><tr><th>特性</th><th>CheckedException</th><th>UncheckedException</th></tr></thead><tbody><tr><td>编译器检查</td><td>编译器强制要求处理</td><td>编译器不要求</td></tr><tr><td>继承关系</td><td>Exception 除 RuntimeException</td><td>RuntimeException 子类</td></tr><tr><td>使用场景</td><td>可恢复异常，如文件不存在</td><td>编程错误，如空指针</td></tr></tbody></table><p><strong>面试点</strong>：</p><ul><li>Checked 异常在 API 设计中可提示调用者</li><li>RuntimeException 多用于程序逻辑错误，防止过多 try&#x2F;catch</li></ul><hr><h2 id="4-throw-和-throws-的区别"><a href="#4-throw-和-throws-的区别" class="headerlink" title="4. throw 和 throws 的区别"></a><strong>4. throw 和 throws 的区别</strong></h2><table><thead><tr><th>特性</th><th>throw</th><th>throws</th></tr></thead><tbody><tr><td>位置</td><td>方法体内</td><td>方法声明上</td></tr><tr><td>用途</td><td>抛出具体异常实例</td><td>声明方法可能抛出的异常类型</td></tr><tr><td>个数限制</td><td>一次抛出一个</td><td>可声明多个异常</td></tr><tr><td>面试示例</td><td><code>throw new IOException()</code></td><td><code>void read() throws IOException</code></td></tr></tbody></table><hr><h2 id="5-try-with-resources-的底层原理"><a href="#5-try-with-resources-的底层原理" class="headerlink" title="5. try-with-resources 的底层原理"></a><strong>5. try-with-resources 的底层原理</strong></h2><ul><li><p><strong>语法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>底层实现</strong>：</p><ul><li><p>自动调用资源的 <code>close()</code> 方法</p></li><li><p>资源必须实现 <strong>AutoCloseable</strong> 接口</p></li><li><p>编译器将其转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="literal">null</span>) br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>优势</strong>：</p><ul><li>自动关闭资源，避免资源泄漏</li><li>支持多个资源声明</li></ul></li><li><p><strong>面试拓展</strong>：多资源关闭的异常抑制机制 (<code>addSuppressed</code>)</p></li></ul><hr><h2 id="6-自定义异常如何设计？继承哪个类"><a href="#6-自定义异常如何设计？继承哪个类" class="headerlink" title="6. 自定义异常如何设计？继承哪个类"></a><strong>6. 自定义异常如何设计？继承哪个类</strong></h2><ul><li><p><strong>继承 RuntimeException</strong>：</p><ul><li>用于非受检异常（编程错误、业务逻辑异常）</li></ul></li><li><p><strong>继承 Exception</strong>：</p><ul><li>用于受检异常（需要调用者处理）</li></ul></li><li><p><strong>实现建议</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBusinessException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBusinessException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>面试点</strong>：</p><ul><li>自定义异常加上异常链（cause）</li><li>规范异常信息，便于日志追踪</li></ul></li></ul><hr><h2 id="7-为什么不建议捕获-Throwable？"><a href="#7-为什么不建议捕获-Throwable？" class="headerlink" title="7. 为什么不建议捕获 Throwable？"></a><strong>7. 为什么不建议捕获 Throwable？</strong></h2><ul><li>Throwable 包含 Error 和 Exception</li><li>捕获 Throwable 会：<ul><li>捕获系统级错误（OutOfMemoryError）</li><li>破坏 JVM 正常工作</li></ul></li><li><strong>最佳实践</strong>：<ul><li>只捕获可恢复的 Exception 或 RuntimeException</li><li>捕获 Throwable 仅用于日志收集或监控</li></ul></li></ul><hr><h2 id="8-异常链（Exception-Chaining）是什么"><a href="#8-异常链（Exception-Chaining）是什么" class="headerlink" title="8. 异常链（Exception Chaining）是什么"></a><strong>8. 异常链（Exception Chaining）是什么</strong></h2><ul><li><p><strong>概念</strong>：</p><ul><li>在捕获一个异常时，将原异常封装在新异常中抛出</li></ul></li><li><p><strong>实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;读取文件失败&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>优势</strong>：</p><ul><li>保留原始异常信息</li><li>便于调试和日志追踪</li></ul></li></ul><hr><h2 id="9-Java-8-之后对异常处理的改进"><a href="#9-Java-8-之后对异常处理的改进" class="headerlink" title="9. Java 8 之后对异常处理的改进"></a><strong>9. Java 8 之后对异常处理的改进</strong></h2><ul><li><p><strong>Lambda 表达式</strong>：</p><ul><li>对受检异常的处理更加简洁，但需要特殊处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(item -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; process(item); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(IOException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Optional &amp; Streams</strong>：</p><ul><li>避免空指针异常</li><li>可以在 <code>map</code>&#x2F;<code>filter</code> 中处理异常</li></ul></li><li><p><strong>面试拓展</strong>：</p><ul><li>异常在并行 Stream 中如何传递</li><li><code>CompletableFuture</code> 异常处理</li></ul></li></ul><hr><h2 id="10-多线程环境下如何正确传递异常"><a href="#10-多线程环境下如何正确传递异常" class="headerlink" title="10. 多线程环境下如何正确传递异常"></a><strong>10. 多线程环境下如何正确传递异常</strong></h2><ul><li><p><strong>问题</strong>：</p><ul><li>子线程异常不会直接抛给主线程</li></ul></li><li><p><strong>解决方案</strong>：</p><ol><li><p><strong>Future &#x2F; Callable</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executor.submit(() -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error&quot;</span>); &#125;);</span><br><span class="line">future.get(); <span class="comment">// 会抛 ExecutionException</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Thread.UncaughtExceptionHandler</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setUncaughtExceptionHandler((t, e) -&gt; log.error(<span class="string">&quot;线程异常&quot;</span>, e));</span><br></pre></td></tr></table></figure></li><li><p><strong>CompletableFuture.exceptionally</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(); &#125;)</span><br><span class="line">                 .exceptionally(ex -&gt; &#123; log.error(ex); <span class="keyword">return</span> <span class="literal">null</span>; &#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>面试拓展</strong>：</p><ul><li>如何处理线程池中未捕获异常</li><li>异步任务异常链追踪</li></ul></li></ul><hr><h3 id="五、JVM-内存管理"><a href="#五、JVM-内存管理" class="headerlink" title="五、JVM &amp; 内存管理"></a>五、JVM &amp; 内存管理</h3><hr><h2 id="1-Java-内存模型（JMM）是什么？"><a href="#1-Java-内存模型（JMM）是什么？" class="headerlink" title="1. Java 内存模型（JMM）是什么？"></a><strong>1. Java 内存模型（JMM）是什么？</strong></h2><ul><li><strong>定义</strong>：<ul><li>Java 内存模型（Java Memory Model，JMM）是 Java 虚拟机规范中定义的一套规范，用于描述 <strong>Java 程序中各个线程如何访问共享内存以及如何保证可见性、原子性、有序性</strong>。</li></ul></li><li><strong>核心作用</strong>：<ol><li><strong>解决多线程可见性问题</strong></li><li><strong>规定内存操作顺序</strong>（happens-before 原则）</li><li><strong>定义变量访问原子性</strong></li></ol></li><li><strong>关键概念</strong>：<ul><li><strong>主内存（Main Memory）</strong>：共享变量存储位置</li><li><strong>工作内存（Working Memory &#x2F; Thread Local Cache）</strong>：线程私有缓存</li><li><strong>volatile、synchronized、final</strong> 的语义保证不同层次的可见性和原子性</li></ul></li></ul><hr><h2 id="2-JVM-内存分为哪几个区域？每个区域的作用是什么？"><a href="#2-JVM-内存分为哪几个区域？每个区域的作用是什么？" class="headerlink" title="2. JVM 内存分为哪几个区域？每个区域的作用是什么？"></a><strong>2. JVM 内存分为哪几个区域？每个区域的作用是什么？</strong></h2><ol><li><strong>程序计数器（PC Register）</strong><ul><li>每个线程私有</li><li>保存当前线程执行的字节码指令地址</li><li>支持线程切换和方法调用返回</li></ul></li><li><strong>虚拟机栈（Stack）</strong><ul><li>每个线程私有</li><li>存储局部变量、操作栈、动态链接信息、方法出口</li><li>栈帧：方法执行的最小单位</li><li>异常：StackOverflowError</li></ul></li><li><strong>本地方法栈（Native Method Stack）</strong><ul><li>JVM 调用本地方法（C&#x2F;C++实现）使用</li><li>HotSpot 通常与虚拟机栈合并</li></ul></li><li><strong>堆（Heap）</strong><ul><li>所有线程共享</li><li>存储对象实例及数组</li><li>垃圾收集的主要区域</li><li>子区域：<ul><li><strong>年轻代（Young Generation）</strong>：Eden + Survivor0 + Survivor1</li><li><strong>老年代（Old Generation）</strong></li><li><strong>元空间（Metaspace &#x2F; 方法区）</strong>：存放类元信息</li></ul></li></ul></li><li><strong>方法区（Metaspace &#x2F; 以前称为 PermGen）</strong><ul><li>存储类信息、常量池、静态变量</li><li>Metaspace 从本地内存分配（不再受 JVM 堆大小限制）</li></ul></li><li><strong>运行时常量池</strong><ul><li>类加载时生成</li><li>存放字面量、符号引用、字符串常量等</li></ul></li></ol><hr><h2 id="3-为什么-String-常量池要放在堆里而不是方法区？"><a href="#3-为什么-String-常量池要放在堆里而不是方法区？" class="headerlink" title="3. 为什么 String 常量池要放在堆里而不是方法区？"></a><strong>3. 为什么 String 常量池要放在堆里而不是方法区？</strong></h2><ul><li><strong>历史原因</strong>：<ul><li>JDK 1.6 及以前：字符串常量池在永久代（PermGen），易导致 OOM</li></ul></li><li><strong>现代实现</strong>：<ul><li>JDK 7+ 将常量池移到堆</li></ul></li><li><strong>优势</strong>：<ol><li>垃圾回收可管理</li><li>内存分配灵活，避免方法区溢出</li><li>多线程访问安全性提升（与堆对象 GC 同步）</li></ol></li></ul><hr><h2 id="4-什么是垃圾回收（GC）的可达性分析算法？"><a href="#4-什么是垃圾回收（GC）的可达性分析算法？" class="headerlink" title="4. 什么是垃圾回收（GC）的可达性分析算法？"></a><strong>4. 什么是垃圾回收（GC）的可达性分析算法？</strong></h2><ul><li><p><strong>可达性分析（Reachability Analysis）</strong>：</p><ul><li>从 <strong>GC Roots</strong> 开始，通过引用链判断对象是否可达</li><li><strong>不可达对象</strong>即为垃圾，可以回收</li></ul></li><li><p><strong>示意</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GC Roots</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">Object A --&gt; Object B</span><br></pre></td></tr></table></figure><ul><li>如果 Object B 无法通过 GC Roots 访问，则被回收</li></ul></li></ul><hr><h2 id="5-哪些对象可以作为-GC-Roots？"><a href="#5-哪些对象可以作为-GC-Roots？" class="headerlink" title="5. 哪些对象可以作为 GC Roots？"></a><strong>5. 哪些对象可以作为 GC Roots？</strong></h2><p>常见 GC Roots：</p><ol><li><strong>虚拟机栈中的引用</strong>（局部变量、方法参数）</li><li><strong>静态变量</strong>（类静态成员）</li><li><strong>常量引用</strong>（常量池引用）</li><li><strong>JNI 引用</strong>（本地方法栈中的引用）</li></ol><hr><h2 id="6-强引用、软引用、弱引用、虚引用的区别"><a href="#6-强引用、软引用、弱引用、虚引用的区别" class="headerlink" title="6. 强引用、软引用、弱引用、虚引用的区别"></a><strong>6. 强引用、软引用、弱引用、虚引用的区别</strong></h2><table><thead><tr><th>类型</th><th>特点</th><th>GC 行为</th><th>面试应用</th></tr></thead><tbody><tr><td>强引用（Strong Reference）</td><td>普通对象引用</td><td>不可回收</td><td>普通对象</td></tr><tr><td>软引用（Soft Reference）</td><td>通过 SoftReference 引用</td><td>内存不足时回收</td><td>缓存（Memory-sensitive cache）</td></tr><tr><td>弱引用（Weak Reference）</td><td>WeakReference 引用</td><td>GC 时立即回收</td><td>ThreadLocal 清理、缓存</td></tr><tr><td>虚引用（Phantom Reference）</td><td>PhantomReference 引用</td><td>仅做引用队列通知</td><td>对象回收前做清理、资源释放</td></tr></tbody></table><hr><h2 id="7-GC-算法"><a href="#7-GC-算法" class="headerlink" title="7. GC 算法"></a><strong>7. GC 算法</strong></h2><ol><li><strong>标记-清除（Mark-Sweep）</strong><ul><li>标记可达对象，清除未标记对象</li><li>优点：简单</li><li>缺点：产生碎片</li></ul></li><li><strong>标记-整理（Mark-Compact）</strong><ul><li>标记可达对象</li><li>将存活对象移动到一端</li><li>优点：解决碎片问题</li><li>缺点：移动对象成本高</li></ul></li><li><strong>复制算法（Copying）</strong><ul><li>将内存分为两块</li><li>将存活对象复制到另一块，清理旧块</li><li>优点：分配快，整理快</li><li>缺点：内存利用率低</li></ul></li></ol><hr><h2 id="8-常见的垃圾收集器"><a href="#8-常见的垃圾收集器" class="headerlink" title="8. 常见的垃圾收集器"></a><strong>8. 常见的垃圾收集器</strong></h2><table><thead><tr><th>垃圾收集器</th><th>适用场景</th><th>特点</th></tr></thead><tbody><tr><td>Serial GC</td><td>单核</td><td>STW 串行，简单、高吞吐量低</td></tr><tr><td>Parallel GC</td><td>多核</td><td>并行回收年轻代，高吞吐量</td></tr><tr><td>CMS GC</td><td>多核</td><td>并发回收老年代，减少 STW</td></tr><tr><td>G1 GC</td><td>大堆</td><td>分区回收，低延迟，预测停顿</td></tr><tr><td>ZGC</td><td>超大堆</td><td>并发标记-清理，低延迟</td></tr><tr><td>Shenandoah</td><td>大堆</td><td>并发标记-整理，减少 STW</td></tr></tbody></table><hr><h2 id="9-什么是-Stop-The-World-STW-？"><a href="#9-什么是-Stop-The-World-STW-？" class="headerlink" title="9. 什么是 Stop-The-World (STW)？"></a><strong>9. 什么是 Stop-The-World (STW)？</strong></h2><ul><li><strong>定义</strong>：JVM 暂停所有应用线程执行，专门进行 GC</li><li><strong>原因</strong>：<ul><li>防止对象被修改导致回收错误</li></ul></li><li><strong>面试拓展</strong>：<ul><li>G1&#x2F;ZGC&#x2F;Shenandoah 尽量缩短 STW 时间</li><li>并发 GC 与 STW 的折中</li></ul></li></ul><hr><h2 id="10-JVM-调优常见参数"><a href="#10-JVM-调优常见参数" class="headerlink" title="10. JVM 调优常见参数"></a><strong>10. JVM 调优常见参数</strong></h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-Xmx</code></td><td>最大堆大小</td></tr><tr><td><code>-Xms</code></td><td>初始堆大小</td></tr><tr><td><code>-Xmn</code></td><td>年轻代大小</td></tr><tr><td><code>-XX:SurvivorRatio</code></td><td>Eden&#x2F;Survivor 比例</td></tr><tr><td><code>-XX:+UseG1GC</code></td><td>使用 G1 GC</td></tr><tr><td><code>-XX:MaxGCPauseMillis</code></td><td>最大停顿时间</td></tr><tr><td><code>-XX:+PrintGCDetails</code></td><td>打印 GC 日志</td></tr><tr><td><code>-XX:+HeapDumpOnOutOfMemoryError</code></td><td>OOM 时生成堆转储</td></tr></tbody></table><p><strong>面试拓展</strong>：</p><ul><li>如何调优老年代和年轻代比例？</li><li>GC 日志分析示例：年轻代满、老年代晋升、STW 停顿</li></ul><hr><h3 id="六、并发编程基础"><a href="#六、并发编程基础" class="headerlink" title="六、并发编程基础"></a>六、并发编程基础</h3><hr><h2 id="1-Java-中的-volatile-关键字的底层实现原理"><a href="#1-Java-中的-volatile-关键字的底层实现原理" class="headerlink" title="1. Java 中的 volatile 关键字的底层实现原理"></a><strong>1. Java 中的 volatile 关键字的底层实现原理</strong></h2><ul><li><strong>作用</strong>：<ol><li><strong>保证可见性</strong>：一个线程修改变量后，其他线程立即可见</li><li><strong>禁止指令重排</strong>：保证顺序性</li></ol></li><li><strong>原理</strong>：<ul><li>底层通过 <strong>内存屏障（Memory Barrier &#x2F; Fence）</strong> 实现</li><li><code>volatile</code> 读操作：<ul><li>加载屏障（LoadLoad + LoadStore）</li></ul></li><li><code>volatile</code> 写操作：<ul><li>写屏障（StoreStore + StoreLoad）</li></ul></li></ul></li><li><strong>注意</strong>：<ul><li>不能保证 <strong>原子性</strong></li><li>适合 <strong>状态标识、开关变量</strong></li></ul></li></ul><hr><h2 id="2-synchronized-的实现原理"><a href="#2-synchronized-的实现原理" class="headerlink" title="2. synchronized 的实现原理"></a><strong>2. synchronized 的实现原理</strong></h2><ul><li><strong>作用</strong>：<ul><li>保证 <strong>互斥访问</strong></li><li>保证 <strong>可见性</strong></li></ul></li><li><strong>底层机制</strong>：<ul><li>Java 对象头包含 <strong>Mark Word</strong></li><li>每个对象可以关联一个 <strong>Monitor</strong></li><li><strong>Monitor</strong> 用于管理线程的加锁、阻塞、唤醒</li></ul></li><li><strong>锁升级流程</strong>：<ol><li><strong>偏向锁</strong>（默认轻量级线程无竞争）</li><li><strong>轻量级锁</strong>（CAS 竞争，膨胀前）</li><li><strong>重量级锁</strong>（锁膨胀，阻塞其他线程）</li></ol></li></ul><hr><h2 id="3-偏向锁、轻量级锁、重量级锁"><a href="#3-偏向锁、轻量级锁、重量级锁" class="headerlink" title="3. 偏向锁、轻量级锁、重量级锁"></a><strong>3. 偏向锁、轻量级锁、重量级锁</strong></h2><table><thead><tr><th>锁类型</th><th>适用场景</th><th>实现方式</th><th>优缺点</th></tr></thead><tbody><tr><td>偏向锁</td><td>单线程</td><td>在对象头标记线程 ID</td><td>减少无竞争开销</td></tr><tr><td>轻量级锁</td><td>多线程竞争轻量</td><td>CAS 自旋 + 栈记录锁</td><td>高效，避免阻塞</td></tr><tr><td>重量级锁</td><td>多线程竞争严重</td><td>Monitor + 阻塞</td><td>开销大，可能 STW</td></tr></tbody></table><p><strong>面试拓展</strong>：</p><ul><li>如何通过 <code>-XX:+PrintFlagsFinal</code> 查看锁标志位</li><li>偏向锁默认延迟 4 秒启用</li></ul><hr><h2 id="4-什么是-CAS-操作？ABA-问题如何解决？"><a href="#4-什么是-CAS-操作？ABA-问题如何解决？" class="headerlink" title="4. 什么是 CAS 操作？ABA 问题如何解决？"></a><strong>4. 什么是 CAS 操作？ABA 问题如何解决？</strong></h2><ul><li><p><strong>CAS（Compare-And-Swap）</strong>：</p><ul><li>原子操作</li><li>比较内存值是否为预期值，如果是就更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAS(V, A, B)</span><br></pre></td></tr></table></figure></li><li><p><strong>ABA 问题</strong>：</p><ul><li>值先从 A 改成 B，又改回 A</li><li>CAS 无法检测变化，可能出错</li></ul></li><li><p><strong>解决方案</strong>：</p><ol><li><strong>版本号机制</strong>（AtomicStampedReference）</li><li><strong>加锁</strong></li></ol></li></ul><hr><h2 id="5-什么是线程安全？举例线程安全类"><a href="#5-什么是线程安全？举例线程安全类" class="headerlink" title="5. 什么是线程安全？举例线程安全类"></a><strong>5. 什么是线程安全？举例线程安全类</strong></h2><ul><li><strong>定义</strong>：多个线程访问同一个对象时，不会破坏对象的状态，并保证正确性</li><li><strong>线程安全类示例</strong>：<ul><li>集合类：<code>Vector</code>, <code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code></li><li>原子类：<code>AtomicInteger</code>, <code>AtomicReference</code></li><li>工具类：<code>ThreadLocal</code>, <code>BlockingQueue</code></li></ul></li></ul><hr><h2 id="6-ThreadLocal-的底层原理与内存泄漏问题"><a href="#6-ThreadLocal-的底层原理与内存泄漏问题" class="headerlink" title="6. ThreadLocal 的底层原理与内存泄漏问题"></a><strong>6. ThreadLocal 的底层原理与内存泄漏问题</strong></h2><ul><li><strong>原理</strong>：<ul><li>每个线程维护一个 <code>ThreadLocalMap</code></li><li>key 是 <strong>ThreadLocal 对象</strong></li><li>value 是对应的值</li></ul></li><li><strong>内存泄漏原因</strong>：<ul><li>ThreadLocalMap 的 key 是 <strong>弱引用</strong></li><li>如果 ThreadLocal 对象被回收，但线程仍存活，value 仍然存在</li></ul></li><li><strong>解决方法</strong>：<ul><li>使用 <code>remove()</code> 方法</li><li>避免长生命周期线程存储大量 ThreadLocal</li></ul></li></ul><hr><h2 id="7-线程池的核心参数"><a href="#7-线程池的核心参数" class="headerlink" title="7. 线程池的核心参数"></a><strong>7. 线程池的核心参数</strong></h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程数，常驻线程</td></tr><tr><td>maximumPoolSize</td><td>最大线程数</td></tr><tr><td>keepAliveTime</td><td>非核心线程空闲存活时间</td></tr><tr><td>workQueue</td><td>等待队列，用于存放任务</td></tr><tr><td>threadFactory</td><td>线程创建工厂</td></tr><tr><td>RejectedExecutionHandler</td><td>拒绝策略</td></tr></tbody></table><hr><h2 id="8-什么是拒绝策略"><a href="#8-什么是拒绝策略" class="headerlink" title="8. 什么是拒绝策略"></a><strong>8. 什么是拒绝策略</strong></h2><ul><li><strong>触发场景</strong>：线程池满了，队列满了</li><li><strong>常见策略</strong>：<ol><li><strong>AbortPolicy</strong>：抛异常，默认</li><li><strong>CallerRunsPolicy</strong>：由调用线程执行任务</li><li><strong>DiscardPolicy</strong>：直接丢弃任务</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列中最旧任务</li></ol></li></ul><hr><h2 id="9-Executors-提供的常见线程池"><a href="#9-Executors-提供的常见线程池" class="headerlink" title="9. Executors 提供的常见线程池"></a><strong>9. Executors 提供的常见线程池</strong></h2><table><thead><tr><th>线程池类型</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td>FixedThreadPool</td><td>固定线程数</td><td>CPU密集型任务</td></tr><tr><td>CachedThreadPool</td><td>可扩容线程池</td><td>短生命周期任务</td></tr><tr><td>SingleThreadExecutor</td><td>单线程顺序执行</td><td>顺序任务</td></tr><tr><td>ScheduledThreadPool</td><td>支持定时&#x2F;周期执行</td><td>定时任务</td></tr></tbody></table><p><strong>面试拓展</strong>：</p><ul><li>Executors.newFixedThreadPool 会使用 <strong>LinkedBlockingQueue</strong></li><li>CachedThreadPool 使用 <strong>SynchronousQueue</strong>，任务直接交给线程</li></ul><hr><h2 id="10-Future-和-CompletableFuture-区别"><a href="#10-Future-和-CompletableFuture-区别" class="headerlink" title="10. Future 和 CompletableFuture 区别"></a><strong>10. Future 和 CompletableFuture 区别</strong></h2><table><thead><tr><th>特性</th><th>Future</th><th>CompletableFuture</th></tr></thead><tbody><tr><td>异步</td><td>提交任务后可阻塞获取结果</td><td>可链式异步操作</td></tr><tr><td>API</td><td>get() 阻塞</td><td>thenApply, thenAccept 等链式</td></tr><tr><td>异常处理</td><td>阻塞式，捕获 ExecutionException</td><td>支持 exceptionally&#x2F;handle</td></tr><tr><td>组合任务</td><td>组合困难</td><td>支持 allOf &#x2F; anyOf &#x2F; thenCombine</td></tr></tbody></table><p><strong>面试点</strong>：</p><ul><li>CompletableFuture 适合多异步任务组合</li><li>FutureTask 可作为 Future 的实现类</li></ul><hr><h3 id="七、编译-运行时"><a href="#七、编译-运行时" class="headerlink" title="七、编译 &amp; 运行时"></a>七、编译 &amp; 运行时</h3><hr><h2 id="1-Java-的反射机制是什么？底层原理？"><a href="#1-Java-的反射机制是什么？底层原理？" class="headerlink" title="1. Java 的反射机制是什么？底层原理？"></a><strong>1. Java 的反射机制是什么？底层原理？</strong></h2><ul><li><p><strong>概念</strong>：</p><ul><li>反射机制允许在运行时 <strong>获取类的信息、实例化对象、访问字段和方法</strong>，而不需要在编译期知道具体类型</li></ul></li><li><p><strong>常用 API</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.User&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line">method.invoke(obj, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>底层原理</strong>：</p><ul><li>JVM 中类对象 <code>Class</code> 对应内存中的元数据（方法表、字段表、常量池）</li><li>通过 <strong>Native 方法</strong> 调用，访问类的元数据和对象实例</li></ul></li><li><p><strong>面试拓展</strong>：</p><ul><li>反射可访问私有字段&#x2F;方法（<code>setAccessible(true)</code>）</li><li>反射适用于框架（Spring、MyBatis）</li></ul></li></ul><hr><h2 id="2-为什么反射性能差？JDK-9-之后如何优化？"><a href="#2-为什么反射性能差？JDK-9-之后如何优化？" class="headerlink" title="2. 为什么反射性能差？JDK 9 之后如何优化？"></a><strong>2. 为什么反射性能差？JDK 9 之后如何优化？</strong></h2><ul><li><strong>性能差原因</strong>：<ol><li>每次访问方法&#x2F;字段都要进行动态解析</li><li>JVM 无法做内联优化（方法调用不是静态绑定）</li><li>需要检查权限、类型转换</li></ol></li><li><strong>优化措施</strong>：<ul><li><strong>JDK 7 及以后</strong>：<code>MethodHandle</code> 和 <code>invokeDynamic</code></li><li><strong>JDK 9+</strong>：增强模块化（模块边界检查优化）</li><li><strong>热点编译器 JIT</strong> 可以对反射调用做内联</li></ul></li></ul><hr><h2 id="3-什么是动态代理？JDK-动态代理和-CGLIB-区别？"><a href="#3-什么是动态代理？JDK-动态代理和-CGLIB-区别？" class="headerlink" title="3. 什么是动态代理？JDK 动态代理和 CGLIB 区别？"></a><strong>3. 什么是动态代理？JDK 动态代理和 CGLIB 区别？</strong></h2><ul><li><p><strong>动态代理</strong>：</p><ul><li>在运行时生成代理对象，拦截方法调用，增强行为</li></ul></li><li><p><strong>JDK 动态代理</strong>：</p><ul><li>基于接口</li><li>使用 <code>Proxy.newProxyInstance</code></li><li>通过 <code>InvocationHandler.invoke</code> 调用</li></ul></li><li><p><strong>CGLIB</strong>：</p><ul><li>基于子类继承（无接口也可代理）</li><li>使用 ASM 字节码生成子类</li><li>注意 final 类&#x2F;方法不能被代理</li></ul></li><li><p><strong>对比</strong>：</p><table><thead><tr><th>特性</th><th>JDK 动态代理</th><th>CGLIB</th></tr></thead><tbody><tr><td>是否需要接口</td><td>必须</td><td>不需要</td></tr><tr><td>原理</td><td>Proxy + InvocationHandler</td><td>ASM 字节码生成子类</td></tr><tr><td>性能</td><td>略慢</td><td>较快</td></tr><tr><td>局限性</td><td>无</td><td>final 类&#x2F;方法不可代理</td></tr></tbody></table></li></ul><hr><h2 id="4-注解的底层原理是什么？运行时注解如何实现？"><a href="#4-注解的底层原理是什么？运行时注解如何实现？" class="headerlink" title="4. 注解的底层原理是什么？运行时注解如何实现？"></a><strong>4. 注解的底层原理是什么？运行时注解如何实现？</strong></h2><ul><li><strong>概念</strong>：<ul><li>注解是一种 <strong>元数据</strong>，用于给类、方法、字段等提供信息</li></ul></li><li><strong>底层原理</strong>：<ul><li>编译时生成 <code>.class</code> 文件中 <code>RuntimeVisibleAnnotations</code> 属性</li><li>JVM 通过 <code>java.lang.reflect.AnnotatedElement</code> 获取</li></ul></li><li><strong>运行时注解</strong>：<ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code></li><li>通过反射 API 读取注解并执行逻辑</li></ul></li><li><strong>应用场景</strong>：<ul><li>Spring 注解（<code>@Autowired</code>、<code>@Service</code>）</li><li>JPA 注解（<code>@Entity</code>、<code>@Column</code>）</li></ul></li></ul><hr><h2 id="5-ClassLoader-的双亲委派模型是什么？"><a href="#5-ClassLoader-的双亲委派模型是什么？" class="headerlink" title="5. ClassLoader 的双亲委派模型是什么？"></a><strong>5. ClassLoader 的双亲委派模型是什么？</strong></h2><ul><li><p><strong>原理</strong>：</p><ul><li>当类加载请求到来时，<strong>先委托父 ClassLoader 加载</strong></li><li>如果父 ClassLoader 加载失败，再由子 ClassLoader 加载</li></ul></li><li><p><strong>优点</strong>：</p><ol><li>避免重复加载</li><li>保证核心类（如 <code>java.lang.*</code>）唯一性</li></ol></li><li><p><strong>示意</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap -&gt; Extension -&gt; App -&gt; Custom</span><br></pre></td></tr></table></figure></li><li><p><strong>面试拓展</strong>：</p><ul><li>双亲委派模型是保证 JVM 核心类安全的重要机制</li></ul></li></ul><hr><h2 id="6-如何打破双亲委派？"><a href="#6-如何打破双亲委派？" class="headerlink" title="6. 如何打破双亲委派？"></a><strong>6. 如何打破双亲委派？</strong></h2><ul><li>自定义 ClassLoader</li><li>在 <code>loadClass</code> 中先加载自己定义的类，再委派父类（逆向委派）</li><li>注意：破坏双亲委派可能引发类冲突、内存泄漏</li></ul><hr><h2 id="7-什么是-SPI（Service-Provider-Interface）机制？"><a href="#7-什么是-SPI（Service-Provider-Interface）机制？" class="headerlink" title="7. 什么是 SPI（Service Provider Interface）机制？"></a><strong>7. 什么是 SPI（Service Provider Interface）机制？</strong></h2><ul><li><strong>概念</strong>：<ul><li>Java 提供的一种服务发现机制</li><li>通过接口 + 配置文件，动态加载实现类</li></ul></li><li><strong>实现</strong>：<ol><li>接口 <code>MyService</code></li><li>文件 <code>META-INF/services/com.example.MyService</code><ul><li>内容：实现类全限定名</li></ul></li><li><code>ServiceLoader.load(MyService.class)</code> 自动加载实现类</li></ol></li><li><strong>应用</strong>：<ul><li>JDBC 驱动加载</li><li>Logging 框架（SLF4J）</li></ul></li></ul><hr><h2 id="8-Java-是如何实现跨平台的？"><a href="#8-Java-是如何实现跨平台的？" class="headerlink" title="8. Java 是如何实现跨平台的？"></a><strong>8. Java 是如何实现跨平台的？</strong></h2><ul><li><strong>原理</strong>：<ol><li>Java 代码 -&gt; 编译成 <strong>字节码（.class）</strong></li><li>JVM 负责字节码解释或即时编译（JIT）执行</li><li>JVM 将字节码映射到不同操作系统和 CPU</li></ol></li><li><strong>面试拓展</strong>：<ul><li>字节码验证机制确保安全性</li><li>HotSpot JIT 提供本地优化</li></ul></li></ul><hr><h2 id="9-JIT（即时编译器）优化了哪些东西？"><a href="#9-JIT（即时编译器）优化了哪些东西？" class="headerlink" title="9. JIT（即时编译器）优化了哪些东西？"></a><strong>9. JIT（即时编译器）优化了哪些东西？</strong></h2><ul><li><strong>JIT（Just-In-Time Compiler）</strong>：<ul><li>将热点字节码动态编译成本地机器码</li></ul></li><li><strong>优化策略</strong>：<ol><li><strong>方法内联</strong>：减少方法调用开销</li><li><strong>循环优化</strong>：消除冗余计算</li><li><strong>逃逸分析</strong>：栈上分配对象</li><li><strong>锁消除&#x2F;锁粗化</strong>：减少锁开销</li><li><strong>指令重排序优化</strong></li></ol></li></ul><hr><h2 id="10-什么是逃逸分析？"><a href="#10-什么是逃逸分析？" class="headerlink" title="10. 什么是逃逸分析？"></a><strong>10. 什么是逃逸分析？</strong></h2><ul><li><strong>概念</strong>：<ul><li>分析对象的引用范围</li><li>判断对象是否“逃逸”出方法或线程</li></ul></li><li><strong>优化应用</strong>：<ol><li><strong>栈上分配</strong>：对象不逃逸可以直接分配在栈上</li><li><strong>标量替换</strong>：将对象拆解为基本类型，提高缓存命中</li><li><strong>锁消除</strong>：对象不逃逸，synchronized 可被消除</li></ol></li><li><strong>面试拓展</strong>：<ul><li>JIT 结合逃逸分析可显著提升性能</li><li>适用于短生命周期对象</li></ul></li></ul><hr><h3 id="八、常见场景-设计"><a href="#八、常见场景-设计" class="headerlink" title="八、常见场景 &amp; 设计"></a>八、常见场景 &amp; 设计</h3><hr><h2 id="1-单例模式在-Java-中有哪些实现方式？哪种最优？"><a href="#1-单例模式在-Java-中有哪些实现方式？哪种最优？" class="headerlink" title="1. 单例模式在 Java 中有哪些实现方式？哪种最优？"></a><strong>1. 单例模式在 Java 中有哪些实现方式？哪种最优？</strong></h2><ul><li><p><strong>常见实现方式</strong>：</p><ol><li><p><strong>饿汉式（静态常量）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：线程安全，简单</li><li>缺点：类加载即初始化，不支持延迟加载</li></ul></li><li><p><strong>懒汉式（加锁）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：支持延迟加载</li><li>缺点：每次访问都有同步开销</li></ul></li><li><p><strong>双重检查锁（Double-Checked Locking）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：线程安全 + 延迟加载 + 高性能</li><li><strong>推荐</strong></li></ul></li><li><p><strong>静态内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123; <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> Holder.INSTANCE; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原理：JVM 保证类加载线程安全</li><li>优点：懒加载 + 高性能</li><li><strong>最佳实践之一</strong></li></ul></li><li><p><strong>枚举单例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123; INSTANCE; &#125;</span><br></pre></td></tr></table></figure><ul><li>原理：JVM 保证枚举类型单例</li><li>优点：线程安全、防止反射和序列化破坏</li><li><strong>最佳实践</strong></li></ul></li></ol></li></ul><hr><h2 id="2-懒汉模式和饿汉模式的区别"><a href="#2-懒汉模式和饿汉模式的区别" class="headerlink" title="2. 懒汉模式和饿汉模式的区别"></a><strong>2. 懒汉模式和饿汉模式的区别</strong></h2><table><thead><tr><th>特性</th><th>懒汉模式</th><th>饿汉模式</th></tr></thead><tbody><tr><td>加载时机</td><td>延迟加载，第一次使用</td><td>类加载即初始化</td></tr><tr><td>线程安全</td><td>需加锁&#x2F;双重检查</td><td>天然线程安全</td></tr><tr><td>性能</td><td>多线程同步有开销</td><td>无额外开销</td></tr><tr><td>内存使用</td><td>按需分配</td><td>类加载时分配</td></tr></tbody></table><hr><h2 id="3-枚举单例为什么是最佳实践"><a href="#3-枚举单例为什么是最佳实践" class="headerlink" title="3. 枚举单例为什么是最佳实践"></a><strong>3. 枚举单例为什么是最佳实践</strong></h2><ul><li>JVM 保证枚举实例唯一性</li><li><strong>防止反射和序列化破坏</strong></li><li>实现简洁，无需手动同步</li><li>面试常考点：相比双重检查锁更安全</li></ul><hr><h2 id="4-为什么要用工厂模式？"><a href="#4-为什么要用工厂模式？" class="headerlink" title="4. 为什么要用工厂模式？"></a><strong>4. 为什么要用工厂模式？</strong></h2><ul><li><strong>作用</strong>：<ul><li>隐藏对象创建逻辑</li><li>解耦调用方和实现类</li></ul></li><li><strong>类型</strong>：<ol><li><strong>简单工厂</strong>：静态方法返回对象</li><li><strong>工厂方法</strong>：子类决定创建哪种对象</li><li><strong>抽象工厂</strong>：一组相关对象的创建</li></ol></li><li><strong>优势</strong>：<ul><li>可扩展性高</li><li>符合开闭原则</li></ul></li></ul><hr><h2 id="5-装饰器模式和代理模式区别"><a href="#5-装饰器模式和代理模式区别" class="headerlink" title="5. 装饰器模式和代理模式区别"></a><strong>5. 装饰器模式和代理模式区别</strong></h2><table><thead><tr><th>特性</th><th>装饰器模式</th><th>代理模式</th></tr></thead><tbody><tr><td>目的</td><td>动态增强对象功能</td><td>控制对象访问</td></tr><tr><td>结构</td><td>包装原对象，继承接口</td><td>持有原对象，方法委托</td></tr><tr><td>场景</td><td>IO 流（BufferedReader）</td><td>远程调用、权限控制</td></tr><tr><td>动态性</td><td>高</td><td>可以通过动态代理实现</td></tr></tbody></table><hr><h2 id="6-Java-中的事件监听模型是怎么实现的？"><a href="#6-Java-中的事件监听模型是怎么实现的？" class="headerlink" title="6. Java 中的事件监听模型是怎么实现的？"></a><strong>6. Java 中的事件监听模型是怎么实现的？</strong></h2><ul><li><strong>机制</strong>：<ol><li><strong>事件源（Event Source）</strong>：产生事件</li><li><strong>事件监听器（Listener）</strong>：接口，定义回调方法</li><li><strong>注册与触发</strong>：源对象维护监听器列表，事件发生时通知监听器</li></ol></li><li><strong>典型应用</strong>：<ul><li>Swing&#x2F;AWT 事件</li><li>Spring ApplicationEvent</li></ul></li></ul><hr><h2 id="7-为什么-Java-不支持多继承？"><a href="#7-为什么-Java-不支持多继承？" class="headerlink" title="7. 为什么 Java 不支持多继承？"></a><strong>7. 为什么 Java 不支持多继承？</strong></h2><ul><li><strong>原因</strong>：<ul><li>避免 <strong>钻石问题</strong>（多继承产生方法冲突）</li><li>简化对象模型，保证 JVM 类型安全</li></ul></li><li><strong>替代方案</strong>：<ul><li>接口多继承 + 默认方法（Java 8+）</li><li>组合设计模式（优先使用 has-a 而不是 is-a）</li></ul></li></ul><hr><h2 id="8-如何用-Java-实现回调机制？"><a href="#8-如何用-Java-实现回调机制？" class="headerlink" title="8. 如何用 Java 实现回调机制？"></a><strong>8. 如何用 Java 实现回调机制？</strong></h2><ul><li><p><strong>原理</strong>：</p><ul><li>将函数封装成对象或接口传递给另一个对象</li><li>由被调用对象在合适时机调用接口方法</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123; <span class="keyword">void</span> <span class="title function_">onDone</span><span class="params">(String result)</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">asyncProcess</span><span class="params">(Callback callback)</span> &#123; <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; callback.onDone(<span class="string">&quot;ok&quot;</span>)).start(); &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="9-Java-中如何实现观察者模式？"><a href="#9-Java-中如何实现观察者模式？" class="headerlink" title="9. Java 中如何实现观察者模式？"></a><strong>9. Java 中如何实现观察者模式？</strong></h2><ul><li><p><strong>机制</strong>：</p><ol><li><strong>Subject（被观察者）</strong>：维护观察者列表，提供注册&#x2F;注销方法</li><li><strong>Observer（观察者）</strong>：接口，定义 update 方法</li><li><strong>触发事件</strong>：Subject 状态变化时调用所有 Observer 的 update</li></ol></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123; <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String msg)</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer o)</span> &#123; observers.add(o); &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        observers.forEach(o -&gt; o.update(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="10-Optional-的设计初衷是什么？"><a href="#10-Optional-的设计初衷是什么？" class="headerlink" title="10. Optional 的设计初衷是什么？"></a><strong>10. Optional 的设计初衷是什么？</strong></h2><ul><li><p><strong>目的</strong>：</p><ul><li>避免 null 值导致的 <strong>NullPointerException</strong></li><li>提供函数式 API，提高可读性</li></ul></li><li><p><strong>使用方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.ofNullable(getValue());</span><br><span class="line">optional.ifPresent(System.out::println);</span><br><span class="line"><span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> optional.orElse(<span class="string">&quot;default&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>优势</strong>：</p><ul><li>显示处理缺失值</li><li>支持链式调用、函数式风格</li></ul></li><li><p><strong>面试拓展</strong>：</p><ul><li>Optional 不适合用于集合属性，避免滥用</li></ul></li></ul><hr><h2 id="二、Java-并发编程（30题）"><a href="#二、Java-并发编程（30题）" class="headerlink" title="二、Java 并发编程（30题）"></a>二、Java 并发编程（30题）</h2><hr><h2 id="1-线程的生命周期"><a href="#1-线程的生命周期" class="headerlink" title="1. 线程的生命周期"></a><strong>1. 线程的生命周期</strong></h2><ul><li><strong>状态</strong>：<ol><li><strong>NEW</strong>：创建后，未调用 <code>start()</code></li><li><strong>RUNNABLE</strong>：调用 <code>start()</code>，可运行（线程调度器决定何时执行）</li><li><strong>BLOCKED</strong>：等待锁</li><li><strong>WAITING</strong>：无限期等待（<code>Object.wait()</code> &#x2F; <code>LockSupport.park()</code>）</li><li><strong>TIMED_WAITING</strong>：超时等待（<code>sleep()</code>, <code>join(timeout)</code>）</li><li><strong>TERMINATED</strong>：执行完毕</li></ol></li></ul><hr><h2 id="2-创建线程的方式"><a href="#2-创建线程的方式" class="headerlink" title="2. 创建线程的方式"></a><strong>2. 创建线程的方式</strong></h2><ol><li><strong>继承 Thread 类</strong></li><li><strong>实现 Runnable 接口</strong></li><li><strong>实现 Callable + FutureTask</strong></li><li><strong>线程池（推荐）</strong></li></ol><hr><h2 id="3-Runnable-和-Callable-区别"><a href="#3-Runnable-和-Callable-区别" class="headerlink" title="3. Runnable 和 Callable 区别"></a><strong>3. Runnable 和 Callable 区别</strong></h2><table><thead><tr><th>特性</th><th>Runnable</th><th>Callable</th></tr></thead><tbody><tr><td>返回值</td><td>无</td><td>可以有返回值</td></tr><tr><td>异常</td><td>不可抛出检查异常</td><td>可以抛出异常</td></tr><tr><td>执行方式</td><td>new Thread(runnable)</td><td>ExecutorService.submit(callable)</td></tr></tbody></table><hr><h2 id="4-Future-和-CompletableFuture-区别"><a href="#4-Future-和-CompletableFuture-区别" class="headerlink" title="4. Future 和 CompletableFuture 区别"></a><strong>4. Future 和 CompletableFuture 区别</strong></h2><ul><li><strong>Future</strong>：<ul><li>阻塞式获取结果</li><li>不支持链式异步处理</li></ul></li><li><strong>CompletableFuture</strong>：<ul><li>支持链式异步处理（thenApply, thenCombine, exceptionally）</li><li>可组合多个异步任务</li></ul></li></ul><hr><h2 id="5-ThreadLocal-原理"><a href="#5-ThreadLocal-原理" class="headerlink" title="5. ThreadLocal 原理"></a><strong>5. ThreadLocal 原理</strong></h2><ul><li>每个线程持有一个 <strong>ThreadLocalMap</strong></li><li>key 是 <strong>ThreadLocal 对象</strong>，value 是线程私有变量</li><li>内存泄漏风险：<ul><li>ThreadLocal 弱引用被 GC，value 没有被回收</li></ul></li><li>解决方法：<ul><li>使用 <code>remove()</code> 清理</li></ul></li></ul><hr><h2 id="6-synchronized-的锁优化机制"><a href="#6-synchronized-的锁优化机制" class="headerlink" title="6. synchronized 的锁优化机制"></a><strong>6. synchronized 的锁优化机制</strong></h2><ol><li><strong>偏向锁</strong>：减少无竞争开销</li><li><strong>轻量级锁</strong>：CAS + 自旋</li><li><strong>重量级锁</strong>：Monitor 阻塞线程</li><li><strong>锁消除&#x2F;锁粗化</strong>：JIT 优化</li></ol><hr><h2 id="7-ReentrantLock-实现原理"><a href="#7-ReentrantLock-实现原理" class="headerlink" title="7. ReentrantLock 实现原理"></a><strong>7. ReentrantLock 实现原理</strong></h2><ul><li>基于 <strong>AQS（AbstractQueuedSynchronizer）</strong></li><li>内部维护一个 <strong>state</strong> 表示锁状态</li><li>队列 FIFO 管理等待线程</li><li>支持公平锁&#x2F;非公平锁</li></ul><hr><h2 id="8-公平锁和非公平锁区别"><a href="#8-公平锁和非公平锁区别" class="headerlink" title="8. 公平锁和非公平锁区别"></a><strong>8. 公平锁和非公平锁区别</strong></h2><table><thead><tr><th>特性</th><th>公平锁</th><th>非公平锁</th></tr></thead><tbody><tr><td>加锁顺序</td><td>FIFO</td><td>不保证</td></tr><tr><td>性能</td><td>低</td><td>高（线程争抢）</td></tr><tr><td>场景</td><td>避免饥饿</td><td>高性能锁场景</td></tr></tbody></table><hr><h2 id="9-乐观锁和悲观锁区别"><a href="#9-乐观锁和悲观锁区别" class="headerlink" title="9. 乐观锁和悲观锁区别"></a><strong>9. 乐观锁和悲观锁区别</strong></h2><ul><li><strong>悲观锁</strong>：假设会发生冲突，直接加锁（如 synchronized &#x2F; ReentrantLock）</li><li><strong>乐观锁</strong>：假设冲突少，使用 CAS（如 Atomic 类）</li></ul><hr><h2 id="10-AQS-原理"><a href="#10-AQS-原理" class="headerlink" title="10. AQS 原理"></a><strong>10. AQS 原理</strong></h2><ul><li><strong>核心</strong>：state + CLH 队列</li><li><strong>特性</strong>：<ul><li>独占模式 &#x2F; 共享模式</li><li>基于 FIFO 队列管理等待线程</li></ul></li><li><strong>应用</strong>：<ul><li>ReentrantLock、Semaphore、CountDownLatch、FutureTask</li></ul></li></ul><hr><h2 id="11-CountDownLatch-和-CyclicBarrier-区别"><a href="#11-CountDownLatch-和-CyclicBarrier-区别" class="headerlink" title="11. CountDownLatch 和 CyclicBarrier 区别"></a><strong>11. CountDownLatch 和 CyclicBarrier 区别</strong></h2><table><thead><tr><th>特性</th><th>CountDownLatch</th><th>CyclicBarrier</th></tr></thead><tbody><tr><td>使用次数</td><td>一次性</td><td>可重复使用</td></tr><tr><td>功能</td><td>等待线程完成</td><td>等待线程到达同一点</td></tr><tr><td>场景</td><td>线程结束同步</td><td>多线程并行分段</td></tr></tbody></table><hr><h2 id="12-Semaphore-的实现原理"><a href="#12-Semaphore-的实现原理" class="headerlink" title="12. Semaphore 的实现原理"></a><strong>12. Semaphore 的实现原理</strong></h2><ul><li>控制并发线程数量</li><li>基于 AQS 的共享锁</li><li>acquire() 获取许可，release() 释放许可</li></ul><hr><h2 id="13-Exchanger-的使用场景"><a href="#13-Exchanger-的使用场景" class="headerlink" title="13. Exchanger 的使用场景"></a><strong>13. Exchanger 的使用场景</strong></h2><ul><li>两个线程交换数据</li><li>典型场景：生产者-消费者线程交换缓冲区</li></ul><hr><h2 id="14-ForkJoinPool-的原理"><a href="#14-ForkJoinPool-的原理" class="headerlink" title="14. ForkJoinPool 的原理"></a><strong>14. ForkJoinPool 的原理</strong></h2><ul><li><strong>工作窃取算法</strong>：<ul><li>空闲线程从其他线程队列中窃取任务</li></ul></li><li>适合 <strong>递归任务</strong></li><li>通过 <strong>ForkJoinTask</strong> 递归拆分计算</li></ul><hr><h2 id="15-CAS-操作的底层实现"><a href="#15-CAS-操作的底层实现" class="headerlink" title="15. CAS 操作的底层实现"></a><strong>15. CAS 操作的底层实现</strong></h2><ul><li>基于 CPU <strong>原子指令（CMPXCHG）</strong></li><li>JVM <code>Unsafe</code> 提供支持</li><li><strong>优点</strong>：无锁、线程安全</li><li><strong>缺点</strong>：ABA 问题</li></ul><hr><h2 id="16-ABA-问题及解决"><a href="#16-ABA-问题及解决" class="headerlink" title="16. ABA 问题及解决"></a><strong>16. ABA 问题及解决</strong></h2><ul><li><strong>问题</strong>：值先 A → B → A，CAS 无法判断变化</li><li><strong>解决</strong>：<ul><li>版本号机制（AtomicStampedReference）</li><li>双重检查</li></ul></li></ul><hr><h2 id="17-Atomic-原子类原理"><a href="#17-Atomic-原子类原理" class="headerlink" title="17. Atomic 原子类原理"></a><strong>17. Atomic 原子类原理</strong></h2><ul><li>基于 <strong>CAS + Unsafe + volatile</strong></li><li>实现非阻塞线程安全</li><li>示例：<code>AtomicInteger</code> 使用 <code>compareAndSwapInt</code></li></ul><hr><h2 id="18-BlockingQueue-实现原理"><a href="#18-BlockingQueue-实现原理" class="headerlink" title="18. BlockingQueue 实现原理"></a><strong>18. BlockingQueue 实现原理</strong></h2><ul><li>内部维护 <strong>锁 + 条件队列</strong></li><li>put 阻塞满队列，take 阻塞空队列</li><li>常用实现：<ul><li>ArrayBlockingQueue（数组 + ReentrantLock）</li><li>LinkedBlockingQueue（链表 + ReentrantLock）</li></ul></li></ul><hr><h2 id="19-ConcurrentHashMap-的分段锁机制"><a href="#19-ConcurrentHashMap-的分段锁机制" class="headerlink" title="19. ConcurrentHashMap 的分段锁机制"></a><strong>19. ConcurrentHashMap 的分段锁机制</strong></h2><ul><li>JDK 1.7：<ul><li><strong>Segment[] + synchronized</strong></li></ul></li><li>JDK 1.8：<ul><li><strong>CAS + synchronized 链表 + 红黑树 + Node</strong></li></ul></li><li>支持高并发读写</li></ul><hr><h2 id="20-ConcurrentHashMap-扩容机制"><a href="#20-ConcurrentHashMap-扩容机制" class="headerlink" title="20. ConcurrentHashMap 扩容机制"></a><strong>20. ConcurrentHashMap 扩容机制</strong></h2><ul><li>采用 <strong>分段扩容 + CAS</strong></li><li>链表转红黑树提高查找性能</li><li>扩容过程中使用 <strong>迁移节点</strong></li></ul><hr><h2 id="21-CopyOnWriteArrayList-原理"><a href="#21-CopyOnWriteArrayList-原理" class="headerlink" title="21. CopyOnWriteArrayList 原理"></a><strong>21. CopyOnWriteArrayList 原理</strong></h2><ul><li>写时复制：<ol><li>写操作复制数组</li><li>修改后替换引用</li></ol></li><li>适合读多写少场景</li></ul><hr><h2 id="22-线程池核心参数"><a href="#22-线程池核心参数" class="headerlink" title="22. 线程池核心参数"></a><strong>22. 线程池核心参数</strong></h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程数</td></tr><tr><td>maximumPoolSize</td><td>最大线程数</td></tr><tr><td>keepAliveTime</td><td>非核心线程存活时间</td></tr><tr><td>workQueue</td><td>任务队列</td></tr><tr><td>RejectedExecutionHandler</td><td>拒绝策略</td></tr></tbody></table><hr><h2 id="23-线程池拒绝策略"><a href="#23-线程池拒绝策略" class="headerlink" title="23. 线程池拒绝策略"></a><strong>23. 线程池拒绝策略</strong></h2><ol><li>AbortPolicy（默认，抛异常）</li><li>CallerRunsPolicy（调用线程执行）</li><li>DiscardPolicy（丢弃任务）</li><li>DiscardOldestPolicy（丢弃队列最老任务）</li></ol><hr><h2 id="24-线程池工作流程"><a href="#24-线程池工作流程" class="headerlink" title="24. 线程池工作流程"></a><strong>24. 线程池工作流程</strong></h2><ol><li>提交任务 → 放入队列</li><li>核心线程未满 → 创建线程</li><li>队列满 → 创建非核心线程</li><li>达到最大线程 → 触发拒绝策略</li></ol><hr><h2 id="25-ThreadPoolExecutor-vs-ScheduledThreadPoolExecutor"><a href="#25-ThreadPoolExecutor-vs-ScheduledThreadPoolExecutor" class="headerlink" title="25. ThreadPoolExecutor vs ScheduledThreadPoolExecutor"></a><strong>25. ThreadPoolExecutor vs ScheduledThreadPoolExecutor</strong></h2><table><thead><tr><th>特性</th><th>ThreadPoolExecutor</th><th>ScheduledThreadPoolExecutor</th></tr></thead><tbody><tr><td>功能</td><td>通用线程池</td><td>支持定时 &#x2F; 周期任务</td></tr><tr><td>队列</td><td>BlockingQueue</td><td>DelayQueue</td></tr><tr><td>场景</td><td>并发任务</td><td>定时任务</td></tr></tbody></table><hr><h2 id="26-为什么不建议使用-Executors-创建线程池"><a href="#26-为什么不建议使用-Executors-创建线程池" class="headerlink" title="26. 为什么不建议使用 Executors 创建线程池"></a><strong>26. 为什么不建议使用 Executors 创建线程池</strong></h2><ul><li>Executors 会产生 <strong>无限队列</strong>（如 newCachedThreadPool）</li><li>容易 <strong>OOM &#x2F; 线程数过多</strong></li><li>推荐：手动使用 <strong>ThreadPoolExecutor</strong> 配置核心参数</li></ul><hr><h2 id="27-JMM-内存可见性问题"><a href="#27-JMM-内存可见性问题" class="headerlink" title="27. JMM 内存可见性问题"></a><strong>27. JMM 内存可见性问题</strong></h2><ul><li>多线程访问共享变量，修改不立即可见</li><li><strong>解决方法</strong>：<ul><li><code>volatile</code></li><li><code>synchronized</code> &#x2F; Lock</li></ul></li></ul><hr><h2 id="28-happens-before-规则"><a href="#28-happens-before-规则" class="headerlink" title="28. happens-before 规则"></a><strong>28. happens-before 规则</strong></h2><ul><li><strong>保证操作顺序与可见性</strong></li><li>常见规则：<ol><li><strong>锁的解锁 → 加锁</strong></li><li><strong>volatile 写 → 读</strong></li><li><strong>线程 start() → run()</strong></li><li><strong>线程 join() → 结束</strong></li></ol></li></ul><hr><h2 id="29-死锁产生条件及避免"><a href="#29-死锁产生条件及避免" class="headerlink" title="29. 死锁产生条件及避免"></a><strong>29. 死锁产生条件及避免</strong></h2><ul><li><strong>四个必要条件</strong>：<ol><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ol></li><li><strong>避免方法</strong>：<ul><li>避免循环等待，按顺序加锁</li><li>使用 tryLock + 超时</li><li>使用单一锁</li></ul></li></ul><hr><h2 id="30-常见并发容器及区别"><a href="#30-常见并发容器及区别" class="headerlink" title="30. 常见并发容器及区别"></a><strong>30. 常见并发容器及区别</strong></h2><table><thead><tr><th>容器</th><th>特性</th></tr></thead><tbody><tr><td>ConcurrentHashMap</td><td>高并发读写，分段&#x2F;链表+红黑树</td></tr><tr><td>CopyOnWriteArrayList</td><td>写时复制，读多写少</td></tr><tr><td>ConcurrentLinkedQueue</td><td>非阻塞</td></tr></tbody></table><p>队列，基于 CAS |<br> | BlockingQueue（Array&#x2F;Linked） | 支持阻塞 put&#x2F;take |<br> | ConcurrentSkipListMap | 有序，基于跳表，线程安全 |</p><hr><h2 id="三、JVM-与性能优化（30题）"><a href="#三、JVM-与性能优化（30题）" class="headerlink" title="三、JVM 与性能优化（30题）"></a>三、JVM 与性能优化（30题）</h2><hr><h2 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1. JVM 内存结构"></a><strong>1. JVM 内存结构</strong></h2><ul><li><strong>方法区 &#x2F; 元空间（Metaspace）</strong>：存放类信息、常量、静态变量</li><li><strong>堆（Heap）</strong>：对象实例、GC 管理区</li><li><strong>栈（Stack）</strong>：方法调用、局部变量</li><li><strong>程序计数器（PC）</strong>：记录线程执行地址</li><li><strong>本地方法栈（Native Stack）</strong>：执行 native 方法</li><li><strong>直接内存（Direct Memory）</strong>：堆外内存，用于 NIO</li></ul><hr><h2 id="2-堆和栈的区别"><a href="#2-堆和栈的区别" class="headerlink" title="2. 堆和栈的区别"></a><strong>2. 堆和栈的区别</strong></h2><table><thead><tr><th>特性</th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td>存储内容</td><td>对象实例</td><td>方法调用帧、局部变量</td></tr><tr><td>生命周期</td><td>GC 管理</td><td>随方法结束释放</td></tr><tr><td>线程共享</td><td>是</td><td>否（线程私有）</td></tr><tr><td>访问速度</td><td>较慢</td><td>快</td></tr><tr><td>内存大小</td><td>大</td><td>小</td></tr></tbody></table><hr><h2 id="3-新生代、老年代、永久代（元空间）的区别"><a href="#3-新生代、老年代、永久代（元空间）的区别" class="headerlink" title="3. 新生代、老年代、永久代（元空间）的区别"></a><strong>3. 新生代、老年代、永久代（元空间）的区别</strong></h2><ul><li><strong>新生代</strong>（Young Generation）：<ul><li>存放新创建对象</li><li>分为 Eden + 2 个 Survivor 区</li><li>Minor GC 主要发生在此</li></ul></li><li><strong>老年代</strong>（Old&#x2F;Tenured Generation）：<ul><li>长寿命对象</li><li>Full GC 主要作用区域</li></ul></li><li><strong>永久代 &#x2F; 元空间</strong>：<ul><li>存放类元数据</li><li>Java 8+ 使用 Metaspace（Native 内存）</li></ul></li></ul><hr><h2 id="4-对象的创建过程"><a href="#4-对象的创建过程" class="headerlink" title="4. 对象的创建过程"></a><strong>4. 对象的创建过程</strong></h2><ol><li><strong>类加载检查</strong></li><li><strong>分配内存</strong>：<ul><li>堆上分配对象空间（TLAB&#x2F;大对象直接分配）</li></ul></li><li><strong>初始化零值</strong></li><li><strong>构造器初始化</strong></li><li><strong>引用赋值</strong></li></ol><hr><h2 id="5-对象的内存分配策略"><a href="#5-对象的内存分配策略" class="headerlink" title="5. 对象的内存分配策略"></a><strong>5. 对象的内存分配策略</strong></h2><ul><li><strong>年轻代分配</strong>：TLAB（Thread Local Allocation Buffer）</li><li><strong>大对象直接进入老年代</strong>（如数组 &gt; 1MB）</li><li><strong>长期存活对象晋升到老年代</strong></li><li><strong>栈上分配</strong>：通过逃逸分析优化</li></ul><hr><h2 id="6-GC-Roots"><a href="#6-GC-Roots" class="headerlink" title="6. GC Roots"></a><strong>6. GC Roots</strong></h2><ul><li><strong>常见类型</strong>：<ul><li>栈帧中的引用变量</li><li>方法区静态变量</li><li>常量引用</li><li>本地方法栈引用</li></ul></li></ul><hr><h2 id="7-垃圾回收算法"><a href="#7-垃圾回收算法" class="headerlink" title="7. 垃圾回收算法"></a><strong>7. 垃圾回收算法</strong></h2><ul><li><strong>引用计数</strong>（不可解决循环引用）</li><li><strong>可达性分析</strong>（GC Roots）</li><li><strong>具体回收算法</strong>：<ul><li>标记-清除</li><li>标记-整理</li><li>复制算法</li><li>分代回收</li></ul></li></ul><hr><h2 id="8-CMS-垃圾回收器流程"><a href="#8-CMS-垃圾回收器流程" class="headerlink" title="8. CMS 垃圾回收器流程"></a><strong>8. CMS 垃圾回收器流程</strong></h2><ol><li>初始标记（Stop-The-World）</li><li>并发标记（标记可回收对象）</li><li>并发预清理</li><li>重新标记（Stop-The-World）</li><li>并发清理（回收老年代）</li></ol><ul><li><strong>特点</strong>：低停顿，但有浮动垃圾和内存碎片问题</li></ul><hr><h2 id="9-G1-垃圾回收器原理"><a href="#9-G1-垃圾回收器原理" class="headerlink" title="9. G1 垃圾回收器原理"></a><strong>9. G1 垃圾回收器原理</strong></h2><ul><li><strong>Region（分区）管理堆</strong></li><li><strong>分代+并行+增量收集</strong></li><li><strong>垃圾回收策略</strong>：<ul><li>优先回收回收成本低的 Region</li><li>并发标记 + 并行清理</li></ul></li><li><strong>目标</strong>：控制停顿时间</li><li><strong>优势</strong>：无碎片、可预测停顿</li></ul><hr><h2 id="10-ZGC-和-Shenandoah-特点"><a href="#10-ZGC-和-Shenandoah-特点" class="headerlink" title="10. ZGC 和 Shenandoah 特点"></a><strong>10. ZGC 和 Shenandoah 特点</strong></h2><ul><li><strong>低延迟 GC</strong>，停顿时间 &lt; 10ms</li><li><strong>并发标记 + 并发压缩</strong></li><li><strong>内存可扩展性好</strong></li><li>支持大内存 (&gt;100GB)</li><li>面试常问区别：ZGC 使用 <strong>Load Barrier</strong>，Shenandoah 使用 <strong>Region Pinning</strong></li></ul><hr><h2 id="11-Minor-GC-与-Full-GC-区别"><a href="#11-Minor-GC-与-Full-GC-区别" class="headerlink" title="11. Minor GC 与 Full GC 区别"></a><strong>11. Minor GC 与 Full GC 区别</strong></h2><table><thead><tr><th>特性</th><th>Minor GC</th><th>Full GC</th></tr></thead><tbody><tr><td>触发区域</td><td>新生代</td><td>整个堆（包括老年代）</td></tr><tr><td>停顿时间</td><td>短</td><td>长</td></tr><tr><td>频率</td><td>高</td><td>低</td></tr><tr><td>GC 类型</td><td>复制算法</td><td>标记-整理 &#x2F; CMS &#x2F; G1</td></tr></tbody></table><hr><h2 id="12-OOM-常见类型及排查"><a href="#12-OOM-常见类型及排查" class="headerlink" title="12. OOM 常见类型及排查"></a><strong>12. OOM 常见类型及排查</strong></h2><ul><li><strong>Java Heap Space</strong>：堆内存不足</li><li><strong>GC Overhead Limit</strong>：GC 花费过多时间</li><li><strong>Metaspace</strong>：类元信息过多</li><li><strong>Direct Memory</strong>：堆外内存溢出</li><li><strong>排查工具</strong>：<ul><li>jmap、jstack、VisualVM、MAT</li></ul></li></ul><hr><h2 id="13-类加载器分类"><a href="#13-类加载器分类" class="headerlink" title="13. 类加载器分类"></a><strong>13. 类加载器分类</strong></h2><ul><li>Bootstrap（根类加载器）</li><li>Extension（扩展类加载器）</li><li>Application（系统类加载器）</li><li>自定义 ClassLoader</li></ul><hr><h2 id="14-双亲委派模型破坏场景"><a href="#14-双亲委派模型破坏场景" class="headerlink" title="14. 双亲委派模型破坏场景"></a><strong>14. 双亲委派模型破坏场景</strong></h2><ul><li>动态加载不同版本类</li><li>热部署、插件化框架（Tomcat、OSGi）</li></ul><hr><h2 id="15-JVM-常见参数调优"><a href="#15-JVM-常见参数调优" class="headerlink" title="15. JVM 常见参数调优"></a><strong>15. JVM 常见参数调优</strong></h2><ul><li><strong>堆大小</strong>：<code>-Xms -Xmx</code></li><li><strong>新生代比例</strong>：<code>-XX:NewRatio</code></li><li><strong>GC 类型</strong>：<code>-XX:+UseG1GC</code></li><li><strong>线程栈大小</strong>：<code>-Xss</code></li><li><strong>Metaspace</strong>：<code>-XX:MetaspaceSize</code></li></ul><hr><h2 id="16-内存泄漏-vs-内存溢出"><a href="#16-内存泄漏-vs-内存溢出" class="headerlink" title="16. 内存泄漏 vs 内存溢出"></a><strong>16. 内存泄漏 vs 内存溢出</strong></h2><ul><li><strong>内存泄漏</strong>：对象不再使用，但仍有引用</li><li><strong>内存溢出（OOM）</strong>：申请内存失败</li></ul><hr><h2 id="17-逃逸分析"><a href="#17-逃逸分析" class="headerlink" title="17. 逃逸分析"></a><strong>17. 逃逸分析</strong></h2><ul><li><strong>作用</strong>：<ul><li>分析对象作用域</li><li>栈上分配、锁消除、同步优化</li></ul></li><li><strong>JVM 优化</strong>：<ul><li>栈上分配（不入堆）</li><li>去掉无用锁（锁消除）</li></ul></li></ul><hr><h2 id="18-方法内联"><a href="#18-方法内联" class="headerlink" title="18. 方法内联"></a><strong>18. 方法内联</strong></h2><ul><li>JIT 优化</li><li>小方法直接替换调用，减少方法调用开销</li><li>增加 CPU 指令局部性，提高性能</li></ul><hr><h2 id="19-JIT-编译器优化"><a href="#19-JIT-编译器优化" class="headerlink" title="19. JIT 编译器优化"></a><strong>19. JIT 编译器优化</strong></h2><ul><li>方法内联</li><li>循环展开</li><li>逃逸分析</li><li>常量折叠</li><li>逃逸分析 + 栈上分配</li></ul><hr><h2 id="20-Safepoint-机制"><a href="#20-Safepoint-机制" class="headerlink" title="20. Safepoint 机制"></a><strong>20. Safepoint 机制</strong></h2><ul><li>所有线程暂停，进行 GC 或其他全局操作</li><li>JVM 可安全修改线程状态</li></ul><hr><h2 id="21-Stop-The-World-STW"><a href="#21-Stop-The-World-STW" class="headerlink" title="21. Stop The World (STW)"></a><strong>21. Stop The World (STW)</strong></h2><ul><li><strong>定义</strong>：暂停所有用户线程进行 GC 或其他 JVM 内部操作</li><li><strong>影响</strong>：应用停顿，低延迟场景需控制 STW 时间</li></ul><hr><h2 id="22-Finalize-方法问题"><a href="#22-Finalize-方法问题" class="headerlink" title="22. Finalize 方法问题"></a><strong>22. Finalize 方法问题</strong></h2><ul><li>不确定执行时间</li><li>性能开销大</li><li>可导致对象“复活”，增加内存压力</li><li><strong>替代方案</strong>：try-with-resources &#x2F; Cleaner</li></ul><hr><h2 id="23-JVM-如何判断对象可回收"><a href="#23-JVM-如何判断对象可回收" class="headerlink" title="23. JVM 如何判断对象可回收"></a><strong>23. JVM 如何判断对象可回收</strong></h2><ul><li><strong>可达性分析</strong>：从 GC Roots 出发，未被可达的对象可回收</li></ul><hr><h2 id="24-TLAB（Thread-Local-Allocation-Buffer）作用"><a href="#24-TLAB（Thread-Local-Allocation-Buffer）作用" class="headerlink" title="24. TLAB（Thread Local Allocation Buffer）作用"></a><strong>24. TLAB（Thread Local Allocation Buffer）作用</strong></h2><ul><li>每个线程独享一块 Eden 内存</li><li><strong>作用</strong>：<ul><li>减少多线程竞争</li><li>提高对象分配效率</li></ul></li></ul><hr><h2 id="25-Direct-Memory-为什么会-OOM"><a href="#25-Direct-Memory-为什么会-OOM" class="headerlink" title="25. Direct Memory 为什么会 OOM"></a><strong>25. Direct Memory 为什么会 OOM</strong></h2><ul><li>堆外内存不足</li><li>NIO Buffer 使用 <code>Unsafe</code> 分配</li><li>不受堆内存限制，但 JVM 无法直接管理</li></ul><hr><h2 id="26-Metaspace-作用"><a href="#26-Metaspace-作用" class="headerlink" title="26. Metaspace 作用"></a><strong>26. Metaspace 作用</strong></h2><ul><li>存放类元数据</li><li>Java 8+ 替代永久代</li><li>可以通过 <code>-XX:MetaspaceSize</code> 限制</li></ul><hr><h2 id="27-Full-GC-触发条件"><a href="#27-Full-GC-触发条件" class="headerlink" title="27. Full GC 触发条件"></a><strong>27. Full GC 触发条件</strong></h2><ul><li>老年代空间不足</li><li>永久代 &#x2F; 元空间不足</li><li>System.gc() 调用</li><li>内存分配失败</li></ul><hr><h2 id="28-查看-JVM-内存使用情况"><a href="#28-查看-JVM-内存使用情况" class="headerlink" title="28. 查看 JVM 内存使用情况"></a><strong>28. 查看 JVM 内存使用情况</strong></h2><ul><li><code>jstat -gc &lt;pid&gt;</code></li><li><code>jmap -heap &lt;pid&gt;</code></li><li><code>VisualVM</code> &#x2F; <code>JConsole</code></li><li><code>MAT</code> 分析 heap dump</li></ul><hr><h2 id="29-Arthas-常用命令"><a href="#29-Arthas-常用命令" class="headerlink" title="29. Arthas 常用命令"></a><strong>29. Arthas 常用命令</strong></h2><ul><li><code>dashboard</code>：系统指标</li><li><code>thread</code>：线程状态</li><li><code>heapdump</code>：堆转储</li><li><code>monitor</code>：方法耗时</li><li><code>watch</code>：方法参数&#x2F;返回值</li><li><code>jad</code>：反编译类</li></ul><hr><h2 id="30-JVM-调优常见面试题"><a href="#30-JVM-调优常见面试题" class="headerlink" title="30. JVM 调优常见面试题"></a><strong>30. JVM 调优常见面试题</strong></h2><ul><li>堆大小设置策略</li><li>新生代&#x2F;老年代比例</li><li>GC 选择（G1 &#x2F; CMS &#x2F; Parallel）</li><li>TLAB 与对象分配优化</li><li>Full GC 触发条件</li><li>内存泄漏排查与 MAT 使用</li></ul><hr><h2 id="四、Spring-Spring-Boot（30题）"><a href="#四、Spring-Spring-Boot（30题）" class="headerlink" title="四、Spring &amp; Spring Boot（30题）"></a>四、Spring &amp; Spring Boot（30题）</h2><h3 id="1-Spring-的-IoC-容器原理？"><a href="#1-Spring-的-IoC-容器原理？" class="headerlink" title="1. Spring 的 IoC 容器原理？"></a>1. Spring 的 IoC 容器原理？</h3><p><strong>核心回答：</strong><br> IoC（控制反转）是通过容器管理对象创建和依赖注入，开发者不需要手动 new 对象，而是由 Spring 容器统一管理。</p><p><strong>深入解析：</strong></p><ul><li>IoC 容器的核心是 <strong>BeanFactory</strong> 和 <strong>ApplicationContext</strong>。</li><li>工作流程：<ol><li><strong>配置解析</strong>：读取 XML &#x2F; 注解 &#x2F; JavaConfig；</li><li><strong>BeanDefinition</strong>：将配置转成 BeanDefinition；</li><li><strong>Bean 实例化</strong>：通过反射或 CGLIB 创建对象；</li><li><strong>依赖注入</strong>：根据构造方法 &#x2F; Setter &#x2F; @Autowired 注入依赖；</li><li><strong>初始化回调</strong>：执行 BeanPostProcessor &#x2F; InitializingBean；</li><li><strong>放入单例池</strong>：容器保存对象供全局使用。</li></ol></li></ul><p><strong>延伸思考：</strong></p><ul><li>IoC 是 <strong>依赖查找（DL）</strong> 和 <strong>依赖注入（DI）</strong> 的结合。</li><li>面试可能追问：Spring 如何实现延迟加载？（@Lazy + 单例池管理）</li><li>实战：配置文件少时用 XML，大项目推荐 <strong>JavaConfig + 注解</strong>。</li></ul><hr><h3 id="2-Bean-的生命周期？"><a href="#2-Bean-的生命周期？" class="headerlink" title="2. Bean 的生命周期？"></a>2. Bean 的生命周期？</h3><p><strong>核心回答：</strong><br> 创建 → 属性注入 → 初始化 → 使用 → 销毁。</p><p><strong>深入解析：</strong></p><ol><li><strong>实例化</strong>：通过反射创建对象；</li><li><strong>依赖注入</strong>：注入属性；</li><li><strong>Aware 接口回调</strong>：如 BeanNameAware、ApplicationContextAware；</li><li><strong>BeanPostProcessor 前置处理</strong>：比如 @Autowired 的处理；</li><li><strong>初始化方法</strong>：@PostConstruct &#x2F; InitializingBean.afterPropertiesSet() &#x2F; init-method；</li><li><strong>BeanPostProcessor 后置处理</strong>；</li><li><strong>就绪使用</strong>；</li><li><strong>销毁回调</strong>：@PreDestroy &#x2F; DisposableBean.destroy() &#x2F; destroy-method。</li></ol><p><strong>延伸思考：</strong></p><ul><li>面试常追问：Spring 容器关闭时，单例 Bean 会被销毁吗？（会，调用 destroy 回调）。</li><li>原型作用域 Bean 不会被销毁，需要开发者手动管理。</li></ul><hr><h3 id="3-BeanFactory-和-ApplicationContext-的区别？"><a href="#3-BeanFactory-和-ApplicationContext-的区别？" class="headerlink" title="3. BeanFactory 和 ApplicationContext 的区别？"></a>3. BeanFactory 和 ApplicationContext 的区别？</h3><p><strong>核心回答：</strong></p><ul><li><strong>BeanFactory</strong>：最基础 IoC 容器，懒加载，轻量级；</li><li><strong>ApplicationContext</strong>：继承 BeanFactory，支持 AOP、国际化、事件机制、自动装配，默认预实例化。</li></ul><p><strong>深入解析：</strong></p><ul><li>BeanFactory：面向低资源环境，功能有限；</li><li>ApplicationContext：常用实现有 ClassPathXmlApplicationContext、AnnotationConfigApplicationContext。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试常问：为什么 ApplicationContext 默认是预加载？（减少运行时性能开销，启动时完成依赖检查）。</li></ul><hr><h3 id="4-单例-Bean-如何保证线程安全？"><a href="#4-单例-Bean-如何保证线程安全？" class="headerlink" title="4. 单例 Bean 如何保证线程安全？"></a>4. 单例 Bean 如何保证线程安全？</h3><p><strong>核心回答：</strong><br> Spring <strong>不保证单例 Bean 的线程安全</strong>，需要开发者在代码中保证。</p><p><strong>深入解析：</strong></p><ul><li>IoC 容器中的单例 Bean 是 <strong>多线程共享的</strong>；</li><li>常见的线程安全措施：<ol><li><strong>无状态设计</strong>（推荐）；</li><li><strong>使用 ThreadLocal 保存状态</strong>；</li><li><strong>方法内部使用局部变量</strong>；</li><li><strong>必要时加锁（synchronized &#x2F; Lock）</strong>。</li></ol></li></ul><p><strong>延伸思考：</strong></p><ul><li>面试陷阱：Spring 单例 Bean 是不是线程安全的？答：不是。</li><li>例子：Controller、Service 通常是无状态的，可以安全单例。</li></ul><hr><h3 id="5-Spring-AOP-的实现原理？"><a href="#5-Spring-AOP-的实现原理？" class="headerlink" title="5. Spring AOP 的实现原理？"></a>5. Spring AOP 的实现原理？</h3><p><strong>核心回答：</strong><br> AOP（面向切面编程）通过 <strong>动态代理</strong> 实现，在方法执行前后插入增强逻辑。</p><p><strong>深入解析：</strong></p><ul><li>实现方式：<ol><li><strong>JDK 动态代理</strong>：基于接口；</li><li><strong>CGLIB 代理</strong>：基于子类字节码增强。</li></ol></li><li>AOP 核心组件：<ul><li>JoinPoint（连接点）、Pointcut（切点）、Advice（通知）、Weaving（织入）、Proxy（代理对象）。</li></ul></li><li>AOP 流程：调用目标方法 → 代理对象拦截 → 执行切面逻辑 → 继续执行原方法。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官可能问：Spring 默认用哪种代理？<ul><li>如果有接口 → JDK 动态代理；</li><li>没有接口 → CGLIB。</li></ul></li><li>JDK 代理只能基于接口，CGLIB 可以基于类。</li></ul><hr><h3 id="6-JDK-动态代理和-CGLIB-的区别？"><a href="#6-JDK-动态代理和-CGLIB-的区别？" class="headerlink" title="6. JDK 动态代理和 CGLIB 的区别？"></a>6. JDK 动态代理和 CGLIB 的区别？</h3><p><strong>核心回答：</strong></p><ul><li>JDK：基于接口，生成实现类；</li><li>CGLIB：基于继承，生成子类字节码。</li></ul><p><strong>深入解析：</strong></p><ul><li>JDK 动态代理：利用 <code>Proxy.newProxyInstance</code>，性能较高；</li><li>CGLIB：利用 ASM 字节码操作生成子类，性能稍慢，但支持类代理；</li><li>Spring 默认优先使用 JDK，如果没有接口再用 CGLIB。</li></ul><p><strong>延伸思考：</strong></p><ul><li>限制：CGLIB 无法代理 <code>final</code> 类 &#x2F; <code>final</code> 方法；</li><li>Spring Boot 可通过 <code>spring.aop.proxy-target-class=true</code> 强制使用 CGLIB。</li></ul><hr><h3 id="7-Spring-事务的传播机制？"><a href="#7-Spring-事务的传播机制？" class="headerlink" title="7. Spring 事务的传播机制？"></a>7. Spring 事务的传播机制？</h3><p><strong>核心回答：</strong><br> 事务传播机制定义了方法在调用时事务的边界，常见类型：</p><ul><li>REQUIRED（默认）、REQUIRES_NEW、NESTED、SUPPORTS、NOT_SUPPORTED、MANDATORY、NEVER。</li></ul><p><strong>深入解析：</strong></p><ul><li><strong>REQUIRED</strong>：有事务就加入，没有就新建；</li><li><strong>REQUIRES_NEW</strong>：挂起当前事务，新建一个；</li><li><strong>NESTED</strong>：嵌套事务（依赖保存点 rollback）；</li><li><strong>SUPPORTS</strong>：有就用，没有就不用；</li><li><strong>NOT_SUPPORTED</strong>：挂起事务，以非事务运行；</li><li><strong>MANDATORY</strong>：必须在事务中调用；</li><li><strong>NEVER</strong>：必须在非事务中运行。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试陷阱：嵌套事务和新事务的区别？<ul><li>嵌套事务依赖外层事务回滚；</li><li>新事务互相独立。</li></ul></li></ul><hr><h3 id="8-Spring-事务的隔离级别？"><a href="#8-Spring-事务的隔离级别？" class="headerlink" title="8. Spring 事务的隔离级别？"></a>8. Spring 事务的隔离级别？</h3><p><strong>核心回答：</strong><br> 事务隔离级别解决并发问题，Spring 支持数据库的 5 种隔离级别：</p><ul><li>DEFAULT（数据库默认）</li><li>READ_UNCOMMITTED（可能脏读）</li><li>READ_COMMITTED（防脏读）</li><li>REPEATABLE_READ（防脏读、不可重复读）</li><li>SERIALIZABLE（防脏读、不可重复读、幻读）</li></ul><p><strong>深入解析：</strong></p><ul><li>InnoDB 默认是 <strong>REPEATABLE_READ</strong>；</li><li>Oracle 默认是 <strong>READ_COMMITTED</strong>。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试可能追问：MySQL 的 REPEATABLE_READ 如何避免幻读？（MVCC + 间隙锁）。</li></ul><hr><h3 id="9-Transactional-的实现原理？"><a href="#9-Transactional-的实现原理？" class="headerlink" title="9. @Transactional 的实现原理？"></a>9. @Transactional 的实现原理？</h3><p><strong>核心回答：</strong><br> @Transactional 通过 <strong>AOP 代理</strong>，在方法执行前后控制事务。</p><p><strong>深入解析：</strong></p><ul><li>Spring 容器解析 @Transactional → 生成代理 → 在代理方法里执行事务增强逻辑：<ol><li>获取事务管理器；</li><li>开启事务；</li><li>执行目标方法；</li><li>异常回滚 &#x2F; 正常提交；</li><li>清理资源。</li></ol></li></ul><p><strong>延伸思考：</strong></p><ul><li>默认只回滚 RuntimeException 和 Error，检查异常需要 <code>rollbackFor</code>。</li><li>面试常问：为什么 @Transactional 方法用 <code>private</code> 修饰无效？<br> → 因为 AOP 代理无法拦截 private 方法。</li></ul><hr><h3 id="10-循环依赖如何解决？"><a href="#10-循环依赖如何解决？" class="headerlink" title="10. 循环依赖如何解决？"></a>10. 循环依赖如何解决？</h3><p><strong>核心回答：</strong><br> Spring 通过 <strong>三级缓存</strong> 解决单例 Bean 的循环依赖。</p><p><strong>深入解析：</strong></p><ul><li>三级缓存：<ol><li>singletonObjects（成品对象）</li><li>earlySingletonObjects（提前暴露的对象，半成品）</li><li>singletonFactories（对象工厂，提供代理对象）</li></ol></li><li>流程：A → 依赖 B → B 依赖 A → 提前暴露 A 的引用给 B → 依赖注入成功。</li></ul><p><strong>延伸思考：</strong></p><ul><li>只能解决 <strong>单例 + setter 注入</strong> 的循环依赖；</li><li><strong>构造器注入循环依赖</strong> 无法解决，会抛出异常。</li></ul><h3 id="11-Spring-的三级缓存解决了什么问题？"><a href="#11-Spring-的三级缓存解决了什么问题？" class="headerlink" title="11. Spring 的三级缓存解决了什么问题？"></a>11. Spring 的三级缓存解决了什么问题？</h3><p><strong>核心回答：</strong><br> 解决 <strong>单例 Bean 的循环依赖</strong>，保证在创建过程中能提前暴露代理对象。</p><p><strong>深入解析：</strong></p><ul><li>Spring 单例池维护了 <strong>三级缓存</strong>：<ol><li><code>singletonObjects</code> → 一级缓存（完全初始化的单例）；</li><li><code>earlySingletonObjects</code> → 二级缓存（提前暴露的半成品对象）；</li><li><code>singletonFactories</code> → 三级缓存（对象工厂，通常生成代理对象）。</li></ol></li><li>流程：<ul><li>当 A 依赖 B，B 又依赖 A 时：<ol><li>创建 A → 放入三级缓存；</li><li>B 依赖 A 时，先从三级缓存拿到 A 的工厂，暴露提前代理对象 → 放入二级缓存；</li><li>等 A 完成初始化后，替换为一级缓存。</li></ol></li></ul></li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官可能追问：为什么要三级缓存，不是二级就够了吗？<br> → 因为 AOP 代理对象需要通过工厂提前暴露，不能只放半成品对象。</li><li>只支持 <strong>setter 注入的循环依赖</strong>，不支持 <strong>构造函数循环依赖</strong>。</li></ul><hr><h3 id="12-Spring-MVC-的工作流程？"><a href="#12-Spring-MVC-的工作流程？" class="headerlink" title="12. Spring MVC 的工作流程？"></a>12. Spring MVC 的工作流程？</h3><p><strong>核心回答：</strong><br> 请求 → DispatcherServlet → HandlerMapping → HandlerAdapter → Controller → ViewResolver → 响应。</p><p><strong>深入解析：</strong></p><ol><li>用户请求到达 DispatcherServlet；</li><li>DispatcherServlet 调用 HandlerMapping 寻找处理器；</li><li>通过 HandlerAdapter 调用具体 Controller；</li><li>Controller 执行业务逻辑，返回 ModelAndView；</li><li>ViewResolver 解析视图；</li><li>DispatcherServlet 渲染并返回响应给客户端。</li></ol><p><strong>延伸思考：</strong></p><ul><li>面试官常问：DispatcherServlet 是单例还是多例？（单例，线程安全依赖于无状态设计）。</li><li>实战：可以用 <code>@RestController</code> 直接返回 JSON，省略 ViewResolver。</li></ul><hr><h3 id="13-DispatcherServlet-的作用？"><a href="#13-DispatcherServlet-的作用？" class="headerlink" title="13. DispatcherServlet 的作用？"></a>13. DispatcherServlet 的作用？</h3><p><strong>核心回答：</strong><br> Spring MVC 的 <strong>前端控制器</strong>，负责请求分发和响应渲染。</p><p><strong>深入解析：</strong></p><ul><li>职责：<ol><li>拦截请求；</li><li>调用 HandlerMapping 找到 Controller；</li><li>调用 HandlerAdapter 执行 Controller；</li><li>调用 ViewResolver 渲染视图；</li><li>返回响应。</li></ol></li><li>核心思想：<strong>统一入口，集中控制</strong>。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试追问：DispatcherServlet 在 Spring Boot 中怎么注册的？<br> → 自动配置类 <code>DispatcherServletAutoConfiguration</code> 注册。</li></ul><hr><h3 id="14-Spring-Boot-的自动装配原理？"><a href="#14-Spring-Boot-的自动装配原理？" class="headerlink" title="14. Spring Boot 的自动装配原理？"></a>14. Spring Boot 的自动装配原理？</h3><p><strong>核心回答：</strong><br> 基于 <code>@EnableAutoConfiguration</code> + <code>SpringFactoriesLoader</code> 实现，根据 classpath 条件加载配置类。</p><p><strong>深入解析：</strong></p><ol><li><code>@SpringBootApplication</code> → 启用 <code>@EnableAutoConfiguration</code>；</li><li><code>SpringFactoriesLoader</code> 读取 <code>META-INF/spring.factories</code> 文件；</li><li>根据 <code>@Conditional</code> 注解判断是否加载；</li><li>把匹配的 Bean 注册到容器。</li></ol><p><strong>延伸思考：</strong></p><ul><li>面试官可能追问：怎么禁用某个自动配置？<br> → <code>@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</code></li><li>或者在 <code>application.yml</code> 中配置 <code>spring.autoconfigure.exclude</code>。</li></ul><hr><h3 id="15-Spring-Boot-Starter-的机制？"><a href="#15-Spring-Boot-Starter-的机制？" class="headerlink" title="15. Spring Boot Starter 的机制？"></a>15. Spring Boot Starter 的机制？</h3><p><strong>核心回答：</strong><br> Starter 是一组 <strong>依赖封装 + 自动配置</strong>，简化第三方库集成。</p><p><strong>深入解析：</strong></p><ul><li>命名规范：<code>spring-boot-starter-xxx</code>；</li><li>依赖 Starter → 自动引入必要依赖 + 自动装配类；</li><li>例子：<code>spring-boot-starter-web</code> → 引入 Spring MVC + Tomcat + Jackson，并自动配置 DispatcherServlet。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官常问：怎么写一个自定义 Starter？<ol><li>提供 <code>AutoConfiguration</code> 类；</li><li>在 <code>META-INF/spring.factories</code> 注册；</li><li>打包发布。</li></ol></li></ul><hr><h3 id="16-ConfigurationProperties-和-Value-的区别？"><a href="#16-ConfigurationProperties-和-Value-的区别？" class="headerlink" title="16. @ConfigurationProperties 和 @Value 的区别？"></a>16. @ConfigurationProperties 和 @Value 的区别？</h3><p><strong>核心回答：</strong></p><ul><li><code>@Value</code>：单个属性注入；</li><li><code>@ConfigurationProperties</code>：批量绑定配置，支持类型安全。</li></ul><p><strong>深入解析：</strong></p><ul><li><code>@Value(&quot;$&#123;key&#125;&quot;)</code>：只能注入单个值；</li><li><code>@ConfigurationProperties(prefix = &quot;xxx&quot;)</code>：把配置文件中 <code>xxx.*</code> 映射到 JavaBean。</li><li><code>@ConfigurationProperties</code> 更适合复杂配置对象。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官可能追问：推荐用哪个？<br> → <code>@ConfigurationProperties</code>，因为支持校验（<code>@Validated</code>）、IDE 提示。</li><li>实战：数据库配置常用 <code>@ConfigurationProperties</code>。</li></ul><hr><h3 id="17-Spring-Boot-如何实现热部署？"><a href="#17-Spring-Boot-如何实现热部署？" class="headerlink" title="17. Spring Boot 如何实现热部署？"></a>17. Spring Boot 如何实现热部署？</h3><p><strong>核心回答：</strong><br> 主要通过 <strong>Spring Boot DevTools</strong> 或 <strong>JRebel</strong>。</p><p><strong>深入解析：</strong></p><ul><li>DevTools：监控 classpath 文件变化，触发 SpringContext 重启；</li><li>JRebel：字节码增强，做到无感知热替换；</li><li>IDE（IntelliJ IDEA &#x2F; Eclipse）也支持 Build 自动 reload。</li></ul><p><strong>延伸思考：</strong></p><ul><li>DevTools 适合开发，JRebel 更强大但收费。</li><li>生产环境不建议热部署，而是灰度发布&#x2F;滚动更新。</li></ul><hr><h3 id="18-Spring-Boot-如何处理配置文件？"><a href="#18-Spring-Boot-如何处理配置文件？" class="headerlink" title="18. Spring Boot 如何处理配置文件？"></a>18. Spring Boot 如何处理配置文件？</h3><p><strong>核心回答：</strong><br> Spring Boot 读取 <code>application.yml/properties</code>，并支持多环境和优先级加载。</p><p><strong>深入解析：</strong></p><ul><li>默认加载顺序：<ol><li>命令行参数；</li><li><code>application.properties</code> &#x2F; <code>application.yml</code>；</li><li>外部配置文件（config 目录）；</li><li>默认配置。</li></ol></li><li>支持多环境：<code>application-dev.yml</code>、<code>application-prod.yml</code>，通过 <code>spring.profiles.active=dev</code> 切换。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官可能问：优先级谁最高？<br> → 命令行参数。</li><li>实战：生产环境常用外部化配置（如 <code>--spring.config.location</code>）。</li></ul><hr><h3 id="19-Conditional-注解的作用？"><a href="#19-Conditional-注解的作用？" class="headerlink" title="19. @Conditional 注解的作用？"></a>19. @Conditional 注解的作用？</h3><p><strong>核心回答：</strong><br> 用于 <strong>条件装配</strong>，根据环境 &#x2F; 配置 &#x2F; Bean 是否存在决定是否加载 Bean。</p><p><strong>深入解析：</strong></p><ul><li>常见实现：<ul><li><code>@ConditionalOnClass</code>（类存在时装配）；</li><li><code>@ConditionalOnMissingBean</code>（没有 Bean 时装配）；</li><li><code>@ConditionalOnProperty</code>（配置项满足条件时装配）；</li><li><code>@ConditionalOnWebApplication</code>。</li></ul></li><li>广泛用于自动配置。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试追问：怎么写自定义条件？<br> → 实现 <code>Condition</code> 接口，重写 <code>matches()</code> 方法。</li></ul><hr><h3 id="20-Spring-Boot-常见的优化点？"><a href="#20-Spring-Boot-常见的优化点？" class="headerlink" title="20. Spring Boot 常见的优化点？"></a>20. Spring Boot 常见的优化点？</h3><p><strong>核心回答：</strong></p><ul><li>启动优化：懒加载、裁剪 Starter；</li><li>内存优化：减小 Bean 数量、引入轻量组件；</li><li>数据库优化：连接池、批量操作；</li><li>生产优化：Actuator 监控、外部化配置。</li></ul><p><strong>深入解析：</strong></p><ol><li><strong>启动性能</strong>：<code>spring.main.lazy-initialization=true</code>；</li><li><strong>数据库性能</strong>：HikariCP 连接池、批处理 SQL；</li><li><strong>缓存优化</strong>：整合 Redis、Caffeine；</li><li><strong>日志优化</strong>：异步日志（Logback AsyncAppender）；</li><li><strong>部署优化</strong>：分层构建（Layered Jar）、Docker 镜像加速。</li></ol><p><strong>延伸思考：</strong></p><ul><li>面试常问：Spring Boot 为什么启动比 Spring 慢？<br> → 因为要做自动装配和环境扫描。</li><li>实战：生产中可用 <code>spring-context-indexer</code> 加快启动。</li></ul><hr><h3 id="21-Spring-Boot-的自动配置原理"><a href="#21-Spring-Boot-的自动配置原理" class="headerlink" title="21. Spring Boot 的自动配置原理"></a><strong>21. Spring Boot 的自动配置原理</strong></h3><p><strong>核心回答</strong><br> Spring Boot 的自动配置基于 <strong>SpringFactoriesLoader + @EnableAutoConfiguration + 条件注解（@ConditionalXXX）</strong>。<br> 它会根据 classpath 中依赖的 jar 包和已有 Bean 自动装配所需的配置。</p><p><strong>深入解析</strong></p><ol><li><strong>关键入口</strong>：<ul><li><code>@SpringBootApplication</code> → <code>@EnableAutoConfiguration</code> → <code>AutoConfigurationImportSelector</code>。</li></ul></li><li><strong>配置来源</strong>：<ul><li><code>META-INF/spring.factories</code> 或 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>。</li></ul></li><li><strong>条件装配</strong>：<ul><li>通过 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等来避免重复配置。</li></ul></li><li><strong>运行时流程</strong>：<ul><li>启动时加载所有候选配置类 → 根据条件筛选 → 注册 BeanDefinition → 实例化 Bean。</li></ul></li></ol><p><strong>延伸思考</strong></p><ul><li>面试追问：如何排查“为什么某个 Bean 没有生效”？<br> → 使用 <code>--debug</code> 参数查看 <strong>自动配置报告</strong>。</li><li>实战：如果不想加载某个自动配置，可以用 <code>@SpringBootApplication(exclude=XXXAutoConfiguration.class)</code>。</li></ul><hr><h3 id="22-Spring-Boot-的启动流程"><a href="#22-Spring-Boot-的启动流程" class="headerlink" title="22. Spring Boot 的启动流程"></a><strong>22. Spring Boot 的启动流程</strong></h3><p><strong>核心回答</strong><br> 启动流程：</p><ol><li>创建 <code>SpringApplication</code> 对象。</li><li>准备环境（Environment）。</li><li>加载 ApplicationContext。</li><li>调用自动配置。</li><li>启动内嵌容器（Tomcat&#x2F;Jetty&#x2F;Netty）。</li><li>执行 <code>CommandLineRunner</code> 和 <code>ApplicationRunner</code>。</li></ol><p><strong>深入解析</strong></p><ul><li><strong>源码入口</strong>：<code>SpringApplication.run()</code>。</li><li><strong>事件监听</strong>：<ul><li><code>ApplicationStartingEvent</code>（最早事件），</li><li><code>ApplicationReadyEvent</code>（启动完成）。</li></ul></li><li><strong>Bean 加载</strong>：<ul><li>先加载主类所在包及子包的组件（<code>@ComponentScan</code>）。</li><li>再结合自动配置。</li></ul></li></ul><p><strong>延伸思考</strong></p><ul><li>面试官可能问：<strong>Spring Boot 如何支持外部配置？</strong><br> → 通过 <code>ConfigFileApplicationListener</code> 解析 <code>application.properties</code> &#x2F; <code>application.yml</code> 并注入 Environment。</li></ul><hr><h3 id="23-Spring-Boot-的配置文件加载顺序"><a href="#23-Spring-Boot-的配置文件加载顺序" class="headerlink" title="23. Spring Boot 的配置文件加载顺序"></a><strong>23. Spring Boot 的配置文件加载顺序</strong></h3><p><strong>核心回答</strong><br> Spring Boot 的配置优先级（从高到低）：</p><ol><li>命令行参数</li><li><code>application.properties/yml</code>（在 <code>config/</code> &gt; 当前目录 &gt; classpath 下）</li><li>外部系统环境变量</li><li>JNDI、系统属性</li><li>默认配置</li></ol><p><strong>深入解析</strong></p><ul><li><strong>多 profile</strong>：<code>application-dev.yml</code> 会在 <code>--spring.profiles.active=dev</code> 时覆盖默认配置。</li><li><strong>优先级控制</strong>：同一属性多次定义时，高优先级覆盖低优先级。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：如果配置冲突，如何快速定位？<br> → 启动时加参数 <code>--debug</code>，查看配置源和优先级。</li></ul><hr><h3 id="24-Spring-Boot-如何实现热部署"><a href="#24-Spring-Boot-如何实现热部署" class="headerlink" title="24. Spring Boot 如何实现热部署"></a><strong>24. Spring Boot 如何实现热部署</strong></h3><p><strong>核心回答</strong><br> 通过 <strong>Spring Boot DevTools</strong> 或 <strong>JRebel</strong> 实现热部署。</p><p><strong>深入解析</strong></p><ul><li><strong>DevTools 原理</strong>：<ul><li>使用两个 ClassLoader：<ul><li>Base ClassLoader（第三方依赖不会变），</li><li>Restart ClassLoader（自己代码，改动后只重新加载）。</li></ul></li></ul></li><li><strong>局限性</strong>：修改依赖库不会触发热部署，只能重启。</li></ul><p><strong>延伸思考</strong></p><ul><li>实际开发中推荐用 <strong>DevTools + IDEA 自动构建</strong>。</li><li>面试追问：生产环境如何实现热更新？<br> → 使用 Spring Cloud Config + 动态刷新（<code>/actuator/refresh</code>）。</li></ul><hr><h3 id="25-Spring-Boot-中的监控和健康检查"><a href="#25-Spring-Boot-中的监控和健康检查" class="headerlink" title="25. Spring Boot 中的监控和健康检查"></a><strong>25. Spring Boot 中的监控和健康检查</strong></h3><p><strong>核心回答</strong><br> Spring Boot 提供 <strong>Actuator 模块</strong>，可监控应用运行状态。</p><p><strong>深入解析</strong></p><ul><li>常见端点：<ul><li><code>/actuator/health</code>（健康检查）</li><li><code>/actuator/metrics</code>（性能指标）</li><li><code>/actuator/env</code>（环境变量）</li><li><code>/actuator/beans</code>（已加载 Bean）</li></ul></li><li>健康检查可扩展：实现 <code>HealthIndicator</code> 接口，自定义检查逻辑（如 Redis、MQ）。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：如何在 Kubernetes 中结合健康检查？<br> → 配置 <strong>livenessProbe</strong> 和 <strong>readinessProbe</strong> 调用 <code>/actuator/health</code>。</li></ul><hr><h3 id="26-Spring-Boot-如何集成数据库（JDBC、JPA、MyBatis）"><a href="#26-Spring-Boot-如何集成数据库（JDBC、JPA、MyBatis）" class="headerlink" title="26. Spring Boot 如何集成数据库（JDBC、JPA、MyBatis）"></a><strong>26. Spring Boot 如何集成数据库（JDBC、JPA、MyBatis）</strong></h3><p><strong>核心回答</strong><br> Spring Boot 提供 <code>spring-boot-starter-jdbc</code>、<code>spring-boot-starter-data-jpa</code> 等 starter，支持开箱即用。</p><p><strong>深入解析</strong></p><ul><li><strong>JDBC</strong>：直接操作数据库，结合 <code>JdbcTemplate</code>。</li><li><strong>JPA</strong>：基于 Hibernate，支持声明式 ORM（<code>@Entity</code>）。</li><li><strong>MyBatis</strong>：需引入第三方 starter（<code>mybatis-spring-boot-starter</code>），用 <code>@MapperScan</code>。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：<strong>Spring Data JPA 与 MyBatis 区别？</strong><ul><li>JPA → ORM 自动化，适合快速开发。</li><li>MyBatis → SQL 手写，灵活可控，适合复杂业务。</li></ul></li></ul><hr><h3 id="27-Spring-Boot-如何实现日志管理"><a href="#27-Spring-Boot-如何实现日志管理" class="headerlink" title="27. Spring Boot 如何实现日志管理"></a><strong>27. Spring Boot 如何实现日志管理</strong></h3><p><strong>核心回答</strong><br> Spring Boot 默认使用 <strong>SLF4J + Logback</strong>，可支持 Log4j2。</p><p><strong>深入解析</strong></p><ul><li><strong>配置方式</strong>：<ul><li><code>application.yml</code> 或 <code>logback-spring.xml</code>。</li></ul></li><li><strong>日志级别</strong>：<code>TRACE</code> &lt; <code>DEBUG</code> &lt; <code>INFO</code> &lt; <code>WARN</code> &lt; <code>ERROR</code>。</li><li><strong>多环境日志</strong>：<ul><li><code>logback-spring.xml</code> + <code>springProfile</code> 标签可区分 dev &#x2F; prod。</li></ul></li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：如何将日志输出到 ELK（ElasticSearch + Logstash + Kibana）？<br> → 使用 <code>logstash-logback-encoder</code>。</li></ul><hr><h3 id="28-Spring-Boot-如何处理跨域问题（CORS）"><a href="#28-Spring-Boot-如何处理跨域问题（CORS）" class="headerlink" title="28. Spring Boot 如何处理跨域问题（CORS）"></a><strong>28. Spring Boot 如何处理跨域问题（CORS）</strong></h3><p><strong>核心回答</strong><br> 通过 <strong>@CrossOrigin</strong> 或全局配置 <code>CorsFilter</code>。</p><p><strong>深入解析</strong></p><ul><li><p><strong>方式1：注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins=&quot;http://example.com&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/api/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方式2：全局配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WebMvcConfigurer <span class="title function_">corsConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">            registry.addMapping(<span class="string">&quot;/**&quot;</span>).allowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：CORS 和 Nginx 反向代理跨域的区别？<ul><li>CORS → Spring Boot 处理，适合单应用。</li><li>Nginx → 网关层处理，适合微服务架构。</li></ul></li></ul><hr><h3 id="29-Spring-Boot-中的安全机制（Spring-Security）"><a href="#29-Spring-Boot-中的安全机制（Spring-Security）" class="headerlink" title="29. Spring Boot 中的安全机制（Spring Security）"></a><strong>29. Spring Boot 中的安全机制（Spring Security）</strong></h3><p><strong>核心回答</strong><br> Spring Security 提供认证（Authentication）+ 授权（Authorization）。</p><p><strong>深入解析</strong></p><ol><li><strong>认证流程</strong>：<ul><li>用户请求 → <code>UsernamePasswordAuthenticationFilter</code> → AuthenticationManager → UserDetailsService → 认证成功 → SecurityContext 保存信息。</li></ul></li><li><strong>授权机制</strong>：<ul><li>基于 URL（拦截路径）、方法级（<code>@PreAuthorize</code>）、表达式。</li></ul></li><li><strong>默认用户</strong>：Spring Boot 2.x 默认生成随机密码（日志中输出）。</li></ol><p><strong>延伸思考</strong></p><ul><li>面试追问：如何在 Spring Security 中集成 JWT？<ul><li>自定义过滤器，解析 JWT 并注入 SecurityContext。</li></ul></li></ul><hr><h3 id="30-如何优化-Spring-Boot-启动速度"><a href="#30-如何优化-Spring-Boot-启动速度" class="headerlink" title="30. 如何优化 Spring Boot 启动速度"></a><strong>30. 如何优化 Spring Boot 启动速度</strong></h3><p><strong>核心回答</strong><br> 优化手段：减少自动配置、延迟初始化、引入轻量依赖。</p><p><strong>深入解析</strong></p><ul><li><strong>延迟加载</strong>：<code>spring.main.lazy-initialization=true</code>。</li><li><strong>移除不必要的 starter</strong>。</li><li><strong>本地调试时跳过安全&#x2F;监控配置</strong>。</li><li><strong>使用 GraalVM Native Image 加速启动</strong>。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：Spring Boot 启动慢，如何排查？<ul><li>使用 <code>--debug</code> 和 <code>ApplicationStartup</code> 查看 Bean 加载耗时。</li></ul></li></ul><hr><h2 id="五、Spring-Cloud（30题）"><a href="#五、Spring-Cloud（30题）" class="headerlink" title="五、Spring Cloud（30题）"></a>五、Spring Cloud（30题）</h2><hr><h2 id="1-Spring-Cloud-是什么？"><a href="#1-Spring-Cloud-是什么？" class="headerlink" title="1. Spring Cloud 是什么？"></a><strong>1. Spring Cloud 是什么？</strong></h2><p><strong>核心回答</strong><br> Spring Cloud 是基于 Spring Boot 的微服务治理框架，提供了分布式系统所需的全套组件：服务注册发现、负载均衡、配置中心、网关、熔断限流、链路追踪等。</p><p><strong>深入原理</strong></p><ul><li><strong>定位</strong>：微服务的 “生态整合者”，不是单一技术，而是一套解决方案。</li><li><strong>核心组件</strong>：<ul><li>Eureka（注册中心）</li><li>Ribbon &#x2F; LoadBalancer（客户端负载均衡）</li><li>Feign（声明式远程调用）</li><li>Hystrix &#x2F; Resilience4j &#x2F; Sentinel（熔断限流）</li><li>Config Server（配置中心）</li><li>Gateway（网关）</li><li>Sleuth + Zipkin（链路追踪）</li></ul></li><li><strong>本质</strong>：解决分布式复杂性，降低开发门槛。</li></ul><p><strong>面试延伸</strong></p><ul><li>Spring Cloud 与 Kubernetes Service Mesh 的区别：前者 SDK 模式，后者 Sidecar 模式。</li></ul><hr><h2 id="2-Spring-Cloud-和-Dubbo-的区别？"><a href="#2-Spring-Cloud-和-Dubbo-的区别？" class="headerlink" title="2. Spring Cloud 和 Dubbo 的区别？"></a><strong>2. Spring Cloud 和 Dubbo 的区别？</strong></h2><p><strong>核心回答</strong></p><ul><li>Dubbo：高性能 RPC 框架，核心是远程调用。</li><li>Spring Cloud：全家桶式微服务生态，功能更全面。</li></ul><p><strong>深入原理</strong></p><ul><li>协议层：Dubbo 用 TCP&#x2F;自定义协议，性能高；Spring Cloud 多用 REST&#x2F;HTTP。</li><li>功能覆盖：Dubbo 主要做服务调用，Spring Cloud 包含注册、配置、熔断、网关等。</li><li>演进：Dubbo3.0 开始支持 gRPC&#x2F;Triple 协议，与 Spring Cloud 越来越接近。</li></ul><p><strong>面试延伸</strong></p><ul><li>公司内网场景（追求性能） → Dubbo；</li><li>大规模分布式互联网场景（追求生态） → Spring Cloud。</li></ul><hr><h2 id="3-Eureka-的工作原理？"><a href="#3-Eureka-的工作原理？" class="headerlink" title="3. Eureka 的工作原理？"></a><strong>3. Eureka 的工作原理？</strong></h2><p><strong>核心回答</strong><br> Eureka 是 Netflix 开源的注册中心，负责 <strong>服务注册与发现</strong>，遵循 <strong>AP</strong> 原则。</p><p><strong>深入原理</strong></p><ul><li><strong>注册</strong>：服务启动后将自身信息（IP、端口、状态）注册到 Eureka Server。</li><li><strong>续约</strong>：服务定期发送心跳（默认 30s）。</li><li><strong>下线</strong>：服务关闭时发送下线请求。</li><li><strong>拉取</strong>：客户端定期从 Server 拉取注册表（默认 30s），本地缓存，提高可用性。</li></ul><p><strong>面试延伸</strong></p><ul><li>面试官可能问：Eureka 与 Zookeeper 区别？<ul><li>Eureka AP → 保证可用性（即使部分节点挂了仍能服务）；</li><li>Zookeeper CP → 强一致性（选举可能导致服务不可用）。</li></ul></li></ul><hr><h2 id="4-Eureka-的自我保护机制？"><a href="#4-Eureka-的自我保护机制？" class="headerlink" title="4. Eureka 的自我保护机制？"></a><strong>4. Eureka 的自我保护机制？</strong></h2><p><strong>核心回答</strong><br> Eureka 会在网络分区或心跳丢失时，<strong>不立即移除服务实例</strong>，保证可用性。</p><p><strong>深入原理</strong></p><ul><li>触发条件：在 15 分钟内心跳失败比例 &gt; 85%。</li><li>行为：<ul><li>暂停剔除失效服务。</li><li>保留已有注册表，允许客户端继续获取服务。</li></ul></li><li>好处：防止因网络抖动导致“服务雪崩”。</li></ul><p><strong>面试延伸</strong></p><ul><li>缺点：可能把已经宕机的实例继续暴露出去。</li><li>可配置 <code>eureka.server.enable-self-preservation=false</code> 来关闭。</li></ul><hr><h2 id="5-Ribbon-的负载均衡策略？"><a href="#5-Ribbon-的负载均衡策略？" class="headerlink" title="5. Ribbon 的负载均衡策略？"></a><strong>5. Ribbon 的负载均衡策略？</strong></h2><p><strong>核心回答</strong><br> Ribbon 是客户端负载均衡组件，常见策略有：</p><ul><li>轮询（RoundRobin）</li><li>随机（Random）</li><li>权重（WeightedResponseTimeRule）</li><li>最小并发（BestAvailableRule）</li></ul><p><strong>深入原理</strong><br> Ribbon 在客户端维护服务列表，从注册中心拉取后，根据策略选择目标服务发起请求。</p><p><strong>面试延伸</strong></p><ul><li>与 Nginx 的区别：Ribbon 是 <strong>客户端负载均衡</strong>（调用方决定），Nginx 是 <strong>服务端负载均衡</strong>（请求先到代理）。</li></ul><hr><h2 id="6-Ribbon-和-Nginx-的区别？"><a href="#6-Ribbon-和-Nginx-的区别？" class="headerlink" title="6. Ribbon 和 Nginx 的区别？"></a><strong>6. Ribbon 和 Nginx 的区别？</strong></h2><p><strong>核心回答</strong></p><ul><li>Ribbon：客户端负载均衡，本地决定调用哪台服务。</li><li>Nginx：服务端负载均衡，所有流量先经过代理。</li></ul><p><strong>深入原理</strong></p><ul><li><strong>部署位置</strong>：Ribbon 在调用方应用中，Nginx 独立部署。</li><li><strong>扩展性</strong>：Ribbon 与 Eureka 配合，支持动态上下线；Nginx 需手动改配置或借助 Consul&#x2F;Keepalived。</li></ul><p><strong>面试延伸</strong></p><ul><li>面试官追问：为什么微服务更倾向于 Ribbon？<ul><li>因为客户端模式更灵活，可以无感知扩容&#x2F;缩容。</li></ul></li></ul><hr><h2 id="7-Feign-的工作原理？"><a href="#7-Feign-的工作原理？" class="headerlink" title="7. Feign 的工作原理？"></a><strong>7. Feign 的工作原理？</strong></h2><p><strong>核心回答</strong><br> Feign 是声明式 HTTP 客户端，通过接口 + 注解的方式调用远程服务。</p><p><strong>深入原理</strong></p><ul><li>运行时基于 <strong>动态代理</strong>（JDK Proxy）。</li><li>结合 Ribbon 负载均衡，自动选择服务实例。</li><li>可集成 Hystrix&#x2F;Sentinel，支持熔断。</li></ul><p><strong>面试延伸</strong></p><ul><li>面试官问：Feign 和 RestTemplate 的区别？<ul><li>RestTemplate → 代码侵入性强，需要手动拼接请求。</li><li>Feign → 声明式，更优雅。</li></ul></li></ul><hr><h2 id="8-Feign-如何支持熔断？"><a href="#8-Feign-如何支持熔断？" class="headerlink" title="8. Feign 如何支持熔断？"></a><strong>8. Feign 如何支持熔断？</strong></h2><p><strong>核心回答</strong><br> Feign 可集成 Hystrix 或 Sentinel，通过 <strong>Fallback</strong> 提供降级逻辑。</p><p><strong>深入原理</strong></p><ul><li>Hystrix：在请求失败&#x2F;超时时调用 fallback 方法。</li><li>Sentinel：通过注解 @SentinelResource + fallback 实现。</li></ul><p><strong>面试延伸</strong></p><ul><li>面试官追问：熔断和降级区别？<ul><li>熔断：保护系统不被拖垮。</li><li>降级：提供兜底逻辑，保证用户体验。</li></ul></li></ul><hr><h2 id="9-Hystrix-的工作原理？"><a href="#9-Hystrix-的工作原理？" class="headerlink" title="9. Hystrix 的工作原理？"></a><strong>9. Hystrix 的工作原理？</strong></h2><p><strong>核心回答</strong><br> Hystrix 通过 <strong>线程池隔离 + 熔断器机制</strong> 保护服务，防止雪崩效应。</p><p><strong>深入原理</strong></p><ul><li><strong>线程池隔离</strong>：不同服务调用用不同线程池，避免相互影响。</li><li><strong>熔断机制</strong>：<ul><li>统计请求失败率。</li><li>达到阈值 → 熔断打开，直接走 fallback。</li><li>一段时间后 → 尝试半开，成功则恢复。</li></ul></li></ul><p><strong>面试延伸</strong></p><ul><li>Hystrix 已停止维护，推荐用 Resilience4j 或 Sentinel。</li></ul><hr><h2 id="10-Hystrix-的线程池隔离和信号量隔离？"><a href="#10-Hystrix-的线程池隔离和信号量隔离？" class="headerlink" title="10. Hystrix 的线程池隔离和信号量隔离？"></a><strong>10. Hystrix 的线程池隔离和信号量隔离？</strong></h2><p><strong>核心回答</strong></p><ul><li><strong>线程池隔离</strong>：每个依赖用独立线程池，适合耗时操作。</li><li><strong>信号量隔离</strong>：限制并发数，不开线程池，适合低延迟操作。</li></ul><p><strong>深入原理</strong></p><ul><li>线程池隔离：开销大，但最安全。</li><li>信号量隔离：轻量，但不能防止调用阻塞线程。</li></ul><p><strong>面试延伸</strong></p><ul><li>实战经验：大多数 IO 调用用线程池隔离，本地计算或轻量调用用信号量隔离。</li></ul><hr><h2 id="11-Resilience4j-和-Hystrix-区别？"><a href="#11-Resilience4j-和-Hystrix-区别？" class="headerlink" title="11. Resilience4j 和 Hystrix 区别？"></a><strong>11. Resilience4j 和 Hystrix 区别？</strong></h2><ul><li>Resilience4j 基于 Java 8 函数式接口，更轻量，支持熔断、限流、重试、隔离等；</li><li>Hystrix 已停止维护，功能单一（熔断+线程隔离）。</li><li>Resilience4j 模块化，可按需引入。</li></ul><hr><h2 id="12-Gateway-的核心功能？"><a href="#12-Gateway-的核心功能？" class="headerlink" title="12. Gateway 的核心功能？"></a><strong>12. Gateway 的核心功能？</strong></h2><ul><li><strong>路由转发</strong>（根据路径、Header、参数转发请求）。</li><li><strong>过滤器机制</strong>（统一鉴权、日志、限流）。</li><li><strong>负载均衡</strong>（结合注册中心）。</li><li><strong>协议支持</strong>（WebSocket、HTTPS）。</li></ul><hr><h2 id="13-Gateway-和-Zuul-的区别？"><a href="#13-Gateway-和-Zuul-的区别？" class="headerlink" title="13. Gateway 和 Zuul 的区别？"></a><strong>13. Gateway 和 Zuul 的区别？</strong></h2><ul><li>Zuul1 基于 Servlet，阻塞 IO，性能差。</li><li>Gateway 基于 Netty + Reactor，支持响应式，性能高。</li><li>Zuul2 虽然改为异步，但生态上 Gateway 更推荐。</li></ul><hr><h2 id="14-Config-Server-的作用？"><a href="#14-Config-Server-的作用？" class="headerlink" title="14. Config Server 的作用？"></a><strong>14. Config Server 的作用？</strong></h2><ul><li>统一管理微服务配置，支持 Git、SVN 等存储。</li><li>动态刷新配置，保证环境一致性。</li><li>与 Bus 结合可广播刷新。</li></ul><hr><h2 id="15-Config-Server-如何保证配置实时刷新？"><a href="#15-Config-Server-如何保证配置实时刷新？" class="headerlink" title="15. Config Server 如何保证配置实时刷新？"></a><strong>15. Config Server 如何保证配置实时刷新？</strong></h2><ul><li>客户端通过 <code>@RefreshScope</code> 实现动态刷新。</li><li>手动触发 <code>/actuator/refresh</code>。</li><li>结合 Spring Cloud Bus，可用消息队列广播刷新。</li></ul><hr><h2 id="16-Spring-Cloud-Bus-的原理？"><a href="#16-Spring-Cloud-Bus-的原理？" class="headerlink" title="16. Spring Cloud Bus 的原理？"></a><strong>16. Spring Cloud Bus 的原理？</strong></h2><ul><li>底层基于消息队列（Kafka、RabbitMQ）。</li><li>当配置变更时，Bus 广播事件，所有服务接收并刷新配置。</li></ul><hr><h2 id="17-Sleuth-的作用？"><a href="#17-Sleuth-的作用？" class="headerlink" title="17. Sleuth 的作用？"></a><strong>17. Sleuth 的作用？</strong></h2><ul><li>在微服务调用链路中，自动生成 <strong>TraceId &#x2F; SpanId</strong>。</li><li>实现请求链路追踪，定位性能瓶颈。</li></ul><hr><h2 id="18-Sleuth-与-Zipkin-的关系？"><a href="#18-Sleuth-与-Zipkin-的关系？" class="headerlink" title="18. Sleuth 与 Zipkin 的关系？"></a><strong>18. Sleuth 与 Zipkin 的关系？</strong></h2><ul><li>Sleuth：负责埋点、生成日志。</li><li>Zipkin：负责收集、存储、展示调用链数据。</li></ul><hr><h2 id="19-分布式链路追踪的原理？"><a href="#19-分布式链路追踪的原理？" class="headerlink" title="19. 分布式链路追踪的原理？"></a><strong>19. 分布式链路追踪的原理？</strong></h2><ul><li>通过唯一 TraceId 贯穿整个调用链。</li><li>每次远程调用生成新的 SpanId。</li><li>数据上报到集中式系统（Zipkin&#x2F;Jaeger）。</li></ul><hr><h2 id="20-Spring-Cloud-Stream-的作用？"><a href="#20-Spring-Cloud-Stream-的作用？" class="headerlink" title="20. Spring Cloud Stream 的作用？"></a><strong>20. Spring Cloud Stream 的作用？</strong></h2><ul><li>封装消息中间件（Kafka&#x2F;RabbitMQ）。</li><li>提供统一编程模型，屏蔽底层差异。</li><li>支持消息驱动架构。</li></ul><hr><h2 id="21-消息驱动模型和事件驱动模型区别？"><a href="#21-消息驱动模型和事件驱动模型区别？" class="headerlink" title="21. 消息驱动模型和事件驱动模型区别？"></a><strong>21. 消息驱动模型和事件驱动模型区别？</strong></h2><ul><li>消息驱动：强调解耦，消息可靠投递。</li><li>事件驱动：强调系统对事件的响应。</li><li>Spring Cloud Stream 更偏消息驱动，但也支持事件模式。</li></ul><hr><h2 id="22-Nacos-和-Eureka-的区别？"><a href="#22-Nacos-和-Eureka-的区别？" class="headerlink" title="22. Nacos 和 Eureka 的区别？"></a><strong>22. Nacos 和 Eureka 的区别？</strong></h2><ul><li>Nacos 除了服务注册发现，还提供配置中心功能。</li><li>Nacos 支持 <strong>AP&#x2F;CP 模式切换</strong>；Eureka 固定 AP。</li><li>Nacos 提供 UI，更易运维。</li></ul><hr><h2 id="23-Nacos-配置中心和注册中心的实现原理？"><a href="#23-Nacos-配置中心和注册中心的实现原理？" class="headerlink" title="23. Nacos 配置中心和注册中心的实现原理？"></a><strong>23. Nacos 配置中心和注册中心的实现原理？</strong></h2><ul><li>配置中心：基于推拉结合（长轮询 + Server 推送）。</li><li>注册中心：基于心跳机制维护服务健康状态。</li></ul><hr><h2 id="24-Sentinel-的工作原理？"><a href="#24-Sentinel-的工作原理？" class="headerlink" title="24. Sentinel 的工作原理？"></a><strong>24. Sentinel 的工作原理？</strong></h2><ul><li>基于 <strong>滑动窗口统计</strong> 请求 QPS、响应时间。</li><li>支持多种限流、熔断、降级规则。</li><li>与 Dubbo&#x2F;Spring Cloud&#x2F;Feign 无缝集成。</li></ul><hr><h2 id="25-限流的常见算法（令牌桶、漏桶）？"><a href="#25-限流的常见算法（令牌桶、漏桶）？" class="headerlink" title="25. 限流的常见算法（令牌桶、漏桶）？"></a><strong>25. 限流的常见算法（令牌桶、漏桶）？</strong></h2><ul><li><strong>令牌桶</strong>：系统以固定速率生成令牌，请求需拿到令牌才执行。</li><li><strong>漏桶</strong>：请求先进入桶，系统以固定速率处理，超出则丢弃。</li><li>区别：令牌桶允许突发流量，漏桶更平滑。</li></ul><hr><h2 id="26-熔断和降级的区别？"><a href="#26-熔断和降级的区别？" class="headerlink" title="26. 熔断和降级的区别？"></a><strong>26. 熔断和降级的区别？</strong></h2><ul><li>熔断：系统保护机制，拒绝调用，防止雪崩。</li><li>降级：业务兜底方案，返回备用结果。</li><li>熔断是“硬防护”，降级是“软兜底”。</li></ul><hr><h2 id="27-CAP-定理和-Spring-Cloud-的关系？"><a href="#27-CAP-定理和-Spring-Cloud-的关系？" class="headerlink" title="27. CAP 定理和 Spring Cloud 的关系？"></a><strong>27. CAP 定理和 Spring Cloud 的关系？</strong></h2><ul><li>CAP：一致性（C）、可用性（A）、分区容错性（P）。</li><li>Eureka → AP；Consul → CP；Nacos → AP&#x2F;CP 切换。</li></ul><hr><h2 id="28-Spring-Cloud-与-Kubernetes-的关系？"><a href="#28-Spring-Cloud-与-Kubernetes-的关系？" class="headerlink" title="28. Spring Cloud 与 Kubernetes 的关系？"></a><strong>28. Spring Cloud 与 Kubernetes 的关系？</strong></h2><ul><li>Spring Cloud：偏应用层，开发框架。</li><li>Kubernetes：偏基础设施，容器编排。</li><li>可结合使用：Spring Cloud 负责应用治理，K8s 负责资源调度。</li></ul><hr><h2 id="29-微服务中的灰度发布？"><a href="#29-微服务中的灰度发布？" class="headerlink" title="29. 微服务中的灰度发布？"></a><strong>29. 微服务中的灰度发布？</strong></h2><ul><li>指新版本只对部分用户开放。</li><li>实现方式：<ul><li>Nginx&#x2F;Gateway 按用户 ID 或流量比例路由。</li><li>Service Mesh（Istio）支持更灵活的流量控制。</li></ul></li></ul><hr><h2 id="30-Spring-Cloud-如何实现服务网格？"><a href="#30-Spring-Cloud-如何实现服务网格？" class="headerlink" title="30. Spring Cloud 如何实现服务网格？"></a><strong>30. Spring Cloud 如何实现服务网格？</strong></h2><ul><li>原生 Spring Cloud 偏 SDK 模式，缺乏服务网格能力。</li><li>可结合 <strong>Spring Cloud + Istio&#x2F;Envoy</strong>，实现流量治理、观测、熔断、灰度。</li><li>越来越多团队采用 <strong>Spring Cloud Alibaba + Service Mesh</strong> 的混合方案。</li></ul><hr><h2 id="六、微服务架构-分布式系统（30题）"><a href="#六、微服务架构-分布式系统（30题）" class="headerlink" title="六、微服务架构 &amp; 分布式系统（30题）"></a>六、微服务架构 &amp; 分布式系统（30题）</h2><hr><h2 id="1-什么是微服务？"><a href="#1-什么是微服务？" class="headerlink" title="1. 什么是微服务？"></a><strong>1. 什么是微服务？</strong></h2><p><strong>核心回答</strong><br> 微服务是一种架构风格，将单体应用拆分为一组小型、独立部署的服务，每个服务聚焦某个业务能力，通过 API（HTTP&#x2F;gRPC&#x2F;MQ）通信。</p><p><strong>深入原理</strong></p><ul><li>每个服务独立开发、部署、扩容。</li><li>服务自治：有自己的数据库、缓存、逻辑。</li><li>通常结合容器化、CI&#x2F;CD、服务治理框架（如 Spring Cloud、Dubbo、K8s）。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：和单体应用区别？ → 单体耦合度高，微服务解耦但更复杂。</li></ul><hr><h2 id="2-微服务与-SOA-的区别？"><a href="#2-微服务与-SOA-的区别？" class="headerlink" title="2. 微服务与 SOA 的区别？"></a><strong>2. 微服务与 SOA 的区别？</strong></h2><p><strong>核心回答</strong></p><ul><li><strong>SOA</strong>：面向服务的架构，通常依赖 ESB（企业服务总线）。</li><li><strong>微服务</strong>：轻量级、去中心化，强调小而独立，常用 REST&#x2F;gRPC。</li></ul><p><strong>深入原理</strong></p><ul><li>SOA → 偏企业内部，服务较大，依赖统一中间件（如 ESB）。</li><li>微服务 → 服务更小，避免单点中心，强调去中心化自治。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：为什么微服务比 SOA 更流行？ → 云原生背景下，微服务更适应敏捷开发和快速迭代。</li></ul><hr><h2 id="3-微服务的优缺点？"><a href="#3-微服务的优缺点？" class="headerlink" title="3. 微服务的优缺点？"></a><strong>3. 微服务的优缺点？</strong></h2><p><strong>核心回答</strong></p><ul><li>优点：独立部署、技术多样性、弹性伸缩、快速迭代。</li><li>缺点：分布式复杂性、运维难度高、数据一致性挑战、服务治理成本高。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试官常问：什么时候不适合微服务？ → 业务小、团队小、系统简单时。</li></ul><hr><h2 id="4-微服务的拆分原则？"><a href="#4-微服务的拆分原则？" class="headerlink" title="4. 微服务的拆分原则？"></a><strong>4. 微服务的拆分原则？</strong></h2><p><strong>核心回答</strong></p><ul><li>按业务边界（DDD 的领域驱动设计）。</li><li>高内聚、低耦合。</li><li>一个服务只聚焦一个核心业务能力。</li></ul><p><strong>深入原理</strong></p><ul><li>拆分方式：按业务（订单、用户、支付）、按场景（核心 vs 辅助）、按非功能需求（性能瓶颈点）。</li></ul><p><strong>延伸思考</strong></p><ul><li>常见错误：按数据库表拆分，导致过度依赖跨服务调用。</li></ul><hr><h2 id="5-如何保证微服务之间的数据一致性？"><a href="#5-如何保证微服务之间的数据一致性？" class="headerlink" title="5. 如何保证微服务之间的数据一致性？"></a><strong>5. 如何保证微服务之间的数据一致性？</strong></h2><p><strong>核心回答</strong></p><ul><li>避免强一致，采用 <strong>最终一致性</strong>。</li><li>方案：分布式事务、消息驱动、补偿机制。</li></ul><p><strong>深入原理</strong></p><ul><li>同步方案：XA（两阶段提交）。</li><li>异步方案：TCC、SAGA、可靠消息。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试官追问：你在项目中怎么做？ → 消息队列（事务消息&#x2F;本地消息表）。</li></ul><hr><h2 id="6-分布式事务有哪些解决方案？"><a href="#6-分布式事务有哪些解决方案？" class="headerlink" title="6. 分布式事务有哪些解决方案？"></a><strong>6. 分布式事务有哪些解决方案？</strong></h2><p><strong>核心回答</strong></p><ul><li>XA（两阶段提交）</li><li>TCC（Try-Confirm-Cancel）</li><li>SAGA（长事务补偿）</li><li>本地消息表 &#x2F; 事务消息</li></ul><p><strong>深入原理</strong></p><ul><li>XA：强一致性，但性能差。</li><li>TCC：业务入侵高，但灵活。</li><li>SAGA：长事务场景，失败时用补偿。</li><li>本地消息表：保证最终一致性。</li></ul><hr><h2 id="7-TCC、SAGA、XA-的区别？"><a href="#7-TCC、SAGA、XA-的区别？" class="headerlink" title="7. TCC、SAGA、XA 的区别？"></a><strong>7. TCC、SAGA、XA 的区别？</strong></h2><ul><li><strong>XA</strong>：数据库层两阶段提交，强一致，性能差。</li><li><strong>TCC</strong>：应用层三步（预留资源、确认、回滚），侵入性高。</li><li><strong>SAGA</strong>：长事务，每步都有补偿动作，保证最终一致性。</li></ul><hr><h2 id="8-本地消息表和可靠消息最终一致性？"><a href="#8-本地消息表和可靠消息最终一致性？" class="headerlink" title="8. 本地消息表和可靠消息最终一致性？"></a><strong>8. 本地消息表和可靠消息最终一致性？</strong></h2><ul><li>本地消息表：在本地事务中写业务表 + 消息表 → MQ 异步投递 → 消费端确认。</li><li>可靠消息：MQ 支持事务（如 RocketMQ 半消息），确保消息必达，保证最终一致性。</li></ul><hr><h2 id="9-分布式锁的实现方式？"><a href="#9-分布式锁的实现方式？" class="headerlink" title="9. 分布式锁的实现方式？"></a><strong>9. 分布式锁的实现方式？</strong></h2><ul><li>数据库锁（悲观锁&#x2F;唯一索引）。</li><li>Redis 分布式锁（setnx + expire）。</li><li>Zookeeper 分布式锁（临时顺序节点）。</li></ul><hr><h2 id="10-Redis-分布式锁的缺陷？"><a href="#10-Redis-分布式锁的缺陷？" class="headerlink" title="10. Redis 分布式锁的缺陷？"></a><strong>10. Redis 分布式锁的缺陷？</strong></h2><ul><li>单点问题（需 Redis Cluster 或 Redlock）。</li><li>锁过期可能导致误释放。</li><li>不能保证严格公平。</li></ul><hr><h2 id="11-Zookeeper-分布式锁的实现？"><a href="#11-Zookeeper-分布式锁的实现？" class="headerlink" title="11. Zookeeper 分布式锁的实现？"></a><strong>11. Zookeeper 分布式锁的实现？</strong></h2><ul><li>利用 <strong>临时顺序节点</strong>：<ul><li>客户端创建顺序节点。</li><li>判断自己是否是最小节点 → 获取锁。</li><li>不是则监听前一个节点的删除事件。</li></ul></li></ul><hr><h2 id="12-数据库分库分表策略？"><a href="#12-数据库分库分表策略？" class="headerlink" title="12. 数据库分库分表策略？"></a><strong>12. 数据库分库分表策略？</strong></h2><ul><li>垂直分库（按业务拆分）。</li><li>水平分表（按用户 ID、时间做分片）。</li><li>常见路由方式：哈希取模、范围、时间。</li></ul><hr><h2 id="13-水平拆分与垂直拆分区别？"><a href="#13-水平拆分与垂直拆分区别？" class="headerlink" title="13. 水平拆分与垂直拆分区别？"></a><strong>13. 水平拆分与垂直拆分区别？</strong></h2><ul><li><strong>水平拆分</strong>：同一张表的数据分到多个库表（按范围&#x2F;哈希）。</li><li><strong>垂直拆分</strong>：不同业务表放到不同库（用户库、订单库）。</li></ul><hr><h2 id="14-分布式-ID-生成方案？"><a href="#14-分布式-ID-生成方案？" class="headerlink" title="14. 分布式 ID 生成方案？"></a><strong>14. 分布式 ID 生成方案？</strong></h2><ul><li>UUID（无序，不适合数据库）。</li><li>数据库自增 ID（单点瓶颈）。</li><li>Redis 自增。</li><li>雪花算法（Snowflake）。</li><li>Leaf（美团开源）。</li></ul><hr><h2 id="15-雪花算法的原理？"><a href="#15-雪花算法的原理？" class="headerlink" title="15. 雪花算法的原理？"></a><strong>15. 雪花算法的原理？</strong></h2><ul><li>64 位长整型：<ul><li>时间戳（41 位）</li><li>机器 ID（10 位）</li><li>序列号（12 位）</li></ul></li><li>保证全局唯一、有序。</li></ul><hr><h2 id="16-API-网关的作用？"><a href="#16-API-网关的作用？" class="headerlink" title="16. API 网关的作用？"></a><strong>16. API 网关的作用？</strong></h2><ul><li>统一入口，做路由转发。</li><li>鉴权、安全控制。</li><li>流量控制、熔断、降级。</li><li>日志监控。</li></ul><hr><h2 id="17-服务注册与发现机制？"><a href="#17-服务注册与发现机制？" class="headerlink" title="17. 服务注册与发现机制？"></a><strong>17. 服务注册与发现机制？</strong></h2><ul><li>服务启动 → 注册中心注册（IP&#x2F;端口&#x2F;状态）。</li><li>调用方 → 从注册中心获取地址列表。</li><li>注册中心 → 通过心跳维持健康状态。</li></ul><hr><h2 id="18-微服务如何保证高可用？"><a href="#18-微服务如何保证高可用？" class="headerlink" title="18. 微服务如何保证高可用？"></a><strong>18. 微服务如何保证高可用？</strong></h2><ul><li>服务冗余（多实例部署）。</li><li>负载均衡。</li><li>熔断、降级、限流。</li><li>自动故障转移（K8s + 服务治理框架）。</li></ul><hr><h2 id="19-微服务中的限流和熔断？"><a href="#19-微服务中的限流和熔断？" class="headerlink" title="19. 微服务中的限流和熔断？"></a><strong>19. 微服务中的限流和熔断？</strong></h2><ul><li>限流：控制流量，保护系统（令牌桶&#x2F;漏桶）。</li><li>熔断：当下游服务异常时，直接失败并快速返回。</li></ul><hr><h2 id="20-微服务如何保证安全性？"><a href="#20-微服务如何保证安全性？" class="headerlink" title="20. 微服务如何保证安全性？"></a><strong>20. 微服务如何保证安全性？</strong></h2><ul><li>认证授权（OAuth2、JWT）。</li><li>HTTPS、加密通信。</li><li>API 网关统一鉴权。</li><li>数据脱敏。</li></ul><hr><h2 id="21-OAuth2-的原理？"><a href="#21-OAuth2-的原理？" class="headerlink" title="21. OAuth2 的原理？"></a><strong>21. OAuth2 的原理？</strong></h2><ul><li>基于令牌的认证授权协议。</li><li>四种模式：授权码、密码、客户端凭证、简化模式。</li><li>典型流程：用户 → 授权服务器 → 获取 Token → 调用资源服务器。</li></ul><hr><h2 id="22-JWT-的作用？"><a href="#22-JWT-的作用？" class="headerlink" title="22. JWT 的作用？"></a><strong>22. JWT 的作用？</strong></h2><ul><li>JSON Web Token，一种无状态令牌。</li><li>内容包含三部分：Header、Payload、Signature。</li><li>适合分布式系统做认证，无需存储 Session。</li></ul><hr><h2 id="23-单点登录-SSO-的实现？"><a href="#23-单点登录-SSO-的实现？" class="headerlink" title="23. 单点登录 SSO 的实现？"></a><strong>23. 单点登录 SSO 的实现？</strong></h2><ul><li>用户只需登录一次，获取全局 Token&#x2F;Session。</li><li>常见实现：CAS、OAuth2、JWT。</li><li>核心：统一认证中心。</li></ul><hr><h2 id="24-配置中心的作用？"><a href="#24-配置中心的作用？" class="headerlink" title="24. 配置中心的作用？"></a><strong>24. 配置中心的作用？</strong></h2><ul><li>集中化配置管理。</li><li>支持动态刷新。</li><li>环境隔离（dev&#x2F;test&#x2F;prod）。</li></ul><hr><h2 id="25-微服务中的监控体系？"><a href="#25-微服务中的监控体系？" class="headerlink" title="25. 微服务中的监控体系？"></a><strong>25. 微服务中的监控体系？</strong></h2><ul><li>指标监控：Prometheus + Grafana。</li><li>日志监控：ELK（Elasticsearch + Logstash + Kibana）。</li><li>链路追踪：Sleuth + Zipkin&#x2F;Jaeger。</li></ul><hr><h2 id="26-Prometheus-的原理？"><a href="#26-Prometheus-的原理？" class="headerlink" title="26. Prometheus 的原理？"></a><strong>26. Prometheus 的原理？</strong></h2><ul><li>基于 Pull 模型，定期从应用&#x2F;Exporter 拉取指标。</li><li>TSDB（时间序列数据库）存储数据。</li><li>结合 Grafana 做可视化。</li></ul><hr><h2 id="27-ELK-在微服务中的应用？"><a href="#27-ELK-在微服务中的应用？" class="headerlink" title="27. ELK 在微服务中的应用？"></a><strong>27. ELK 在微服务中的应用？</strong></h2><ul><li>Logstash：日志采集。</li><li>Elasticsearch：日志存储、搜索。</li><li>Kibana：日志分析、可视化。</li><li>用于统一日志平台。</li></ul><hr><h2 id="28-服务调用链路追踪的意义？"><a href="#28-服务调用链路追踪的意义？" class="headerlink" title="28. 服务调用链路追踪的意义？"></a><strong>28. 服务调用链路追踪的意义？</strong></h2><ul><li>解决“调用链不清楚”的问题。</li><li>快速定位性能瓶颈、错误位置。</li><li>提升运维可观测性。</li></ul><hr><h2 id="29-服务雪崩效应是什么？"><a href="#29-服务雪崩效应是什么？" class="headerlink" title="29. 服务雪崩效应是什么？"></a><strong>29. 服务雪崩效应是什么？</strong></h2><ul><li>一个服务故障 → 引发调用它的服务故障 → 最终导致整个系统崩溃。</li><li>原因：依赖调用无保护（无熔断&#x2F;限流）。</li></ul><hr><h2 id="30-如何设计一个高并发的微服务系统？"><a href="#30-如何设计一个高并发的微服务系统？" class="headerlink" title="30. 如何设计一个高并发的微服务系统？"></a><strong>30. 如何设计一个高并发的微服务系统？</strong></h2><p><strong>核心思路</strong></p><ul><li>架构：微服务 + API 网关 + 服务治理。</li><li>高可用：负载均衡、多副本、自动故障转移。</li><li>高性能：缓存（Redis）、异步化、限流、降级。</li><li>数据层：分库分表、读写分离。</li><li>安全：OAuth2&#x2F;JWT。</li><li>可观测性：监控 + 日志 + 链路追踪。</li></ul><hr><h2 id="七、数据库-缓存（30题）"><a href="#七、数据库-缓存（30题）" class="headerlink" title="七、数据库 &amp; 缓存（30题）"></a>七、数据库 &amp; 缓存（30题）</h2><hr><h2 id="1-MySQL-的存储引擎区别"><a href="#1-MySQL-的存储引擎区别" class="headerlink" title="1. MySQL 的存储引擎区别"></a><strong>1. MySQL 的存储引擎区别</strong></h2><ul><li><strong>存储引擎</strong>是 MySQL 管理数据的底层组件，决定了数据存储方式、事务支持、锁机制、索引支持等。</li><li><strong>主要存储引擎</strong>：<ul><li><strong>InnoDB</strong>：事务型，支持行级锁、外键、MVCC、崩溃恢复。适合高并发、事务要求高的场景。</li><li><strong>MyISAM</strong>：非事务型，表级锁，支持全文索引。适合读多写少、日志或统计类表。</li><li><strong>Memory</strong>：数据存储在内存中，访问速度快，但断电数据丢失。适合临时表。</li><li><strong>Archive</strong>：归档引擎，只支持插入和查询，不支持更新，压缩存储。</li></ul></li><li><strong>面试重点</strong>：<ul><li>选择存储引擎需根据业务需求：事务要求、并发量、数据量和恢复策略。</li></ul></li></ul><hr><h2 id="2-InnoDB-和-MyISAM-的区别"><a href="#2-InnoDB-和-MyISAM-的区别" class="headerlink" title="2. InnoDB 和 MyISAM 的区别"></a><strong>2. InnoDB 和 MyISAM 的区别</strong></h2><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>事务</td><td>支持 ACID</td><td>不支持</td></tr><tr><td>锁类型</td><td>行级锁+表锁</td><td>表级锁</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>崩溃恢复</td><td>自动恢复</td><td>需手动修复</td></tr><tr><td>全文索引</td><td>5.6+ 支持</td><td>支持</td></tr><tr><td>并发场景</td><td>高并发写+读</td><td>读多写少</td></tr><tr><td>适用案例</td><td>金融、电商订单</td><td>日志分析、统计表</td></tr></tbody></table><hr><h2 id="3-MySQL-事务特性"><a href="#3-MySQL-事务特性" class="headerlink" title="3. MySQL 事务特性"></a><strong>3. MySQL 事务特性</strong></h2><ul><li><strong>ACID 原则</strong>：<ol><li><strong>原子性（Atomic）</strong>：事务全部执行或全部回滚。</li><li><strong>一致性（Consistency）</strong>：事务执行前后数据库状态合法。</li><li><strong>隔离性（Isolation）</strong>：事务互不干扰。</li><li><strong>持久性（Durability）</strong>：提交后数据不会丢失。</li></ol></li><li><strong>隔离级别</strong>：<ul><li><strong>Read Uncommitted</strong>：允许脏读。</li><li><strong>Read Committed</strong>：防止脏读，但可能不可重复读。</li><li><strong>Repeatable Read（默认 InnoDB）</strong>：防止不可重复读，间隙锁解决幻读。</li><li><strong>Serializable</strong>：完全串行执行，性能最低，但完全隔离。</li></ul></li><li><strong>面试追问</strong>：隔离级别与死锁、性能的权衡。</li></ul><hr><h2 id="4-MVCC-的实现原理"><a href="#4-MVCC-的实现原理" class="headerlink" title="4. MVCC 的实现原理"></a><strong>4. MVCC 的实现原理</strong></h2><ul><li><strong>原理</strong>：<ul><li>InnoDB 为每行增加隐藏列 <code>trx_id</code> 和 <code>roll_pointer</code>。</li><li>查询时根据事务 ID 判断哪一版本可见。</li><li>读操作不阻塞写操作，实现 <strong>非阻塞读</strong>。</li></ul></li><li><strong>应用</strong>：提高并发性能，避免读写互相阻塞。</li><li><strong>面试追问</strong>：MVCC 如何实现 Repeatable Read，为什么不锁表。</li></ul><hr><h2 id="5-MySQL-的索引类型"><a href="#5-MySQL-的索引类型" class="headerlink" title="5. MySQL 的索引类型"></a><strong>5. MySQL 的索引类型</strong></h2><ul><li><strong>B+ 树索引</strong>：范围查询、排序，叶子节点按顺序连接。</li><li><strong>哈希索引</strong>：精确查找快（Memory 引擎）。</li><li><strong>全文索引</strong>：文本搜索。</li><li><strong>空间索引</strong>：地理信息查询（R-Tree）。</li><li><strong>面试追问</strong>：什么时候选择组合索引，覆盖索引优化查询。</li></ul><hr><h2 id="6-聚簇索引-vs-非聚簇索引"><a href="#6-聚簇索引-vs-非聚簇索引" class="headerlink" title="6. 聚簇索引 vs 非聚簇索引"></a><strong>6. 聚簇索引 vs 非聚簇索引</strong></h2><ul><li><strong>聚簇索引</strong>：<ul><li>数据行存储顺序与主键顺序一致。</li><li>查询范围、排序效率高。</li></ul></li><li><strong>非聚簇索引</strong>：<ul><li>索引存 key + 主键，回表获取其他字段。</li></ul></li><li><strong>面试追问</strong>：聚簇索引插入顺序对性能影响，回表成本。</li></ul><hr><h2 id="7-B-树索引原理"><a href="#7-B-树索引原理" class="headerlink" title="7. B+ 树索引原理"></a><strong>7. B+ 树索引原理</strong></h2><ul><li>内节点：存 key + 子节点指针</li><li>叶子节点：存完整记录或指针，并链表连接</li><li><strong>特点</strong>：<ul><li>支持范围查询</li><li>磁盘 IO 高效</li></ul></li><li><strong>面试追问</strong>：为什么 MySQL 选择 B+ 树而不是 B 树或 Hash。</li></ul><hr><h2 id="8-覆盖索引-vs-回表"><a href="#8-覆盖索引-vs-回表" class="headerlink" title="8. 覆盖索引 vs 回表"></a><strong>8. 覆盖索引 vs 回表</strong></h2><ul><li><strong>覆盖索引</strong>：索引包含所有查询字段，无需访问表。</li><li><strong>回表</strong>：索引只包含部分字段，需要通过主键查表。</li><li><strong>优化方法</strong>：尽量让热点查询使用覆盖索引，减少 IO。</li></ul><hr><h2 id="9-索引下推优化"><a href="#9-索引下推优化" class="headerlink" title="9. 索引下推优化"></a><strong>9. 索引下推优化</strong></h2><ul><li>WHERE 条件在存储引擎层过滤，减少返回上层的数据量。</li><li>特别在组合索引或函数查询时有效。</li><li><strong>面试追问</strong>：索引下推能否应用于非 InnoDB 存储引擎。</li></ul><hr><h2 id="10-MySQL-锁机制"><a href="#10-MySQL-锁机制" class="headerlink" title="10. MySQL 锁机制"></a><strong>10. MySQL 锁机制</strong></h2><ul><li><strong>表锁</strong>：锁整张表，低并发。</li><li><strong>行锁</strong>：锁单行，InnoDB 默认。</li><li><strong>意向锁</strong>：表级锁意图，避免死锁。</li><li><strong>间隙锁</strong>：防止幻读。</li><li><strong>面试追问</strong>：行锁、表锁的实现原理，锁冲突如何处理。</li></ul><hr><h2 id="11-行锁-vs-表锁"><a href="#11-行锁-vs-表锁" class="headerlink" title="11. 行锁 vs 表锁"></a><strong>11. 行锁 vs 表锁</strong></h2><ul><li>行锁：粒度小，高并发，事务安全。</li><li>表锁：粒度大，适合批量操作。</li><li><strong>应用场景</strong>：高并发写用行锁，批量更新可用表锁。</li></ul><hr><h2 id="12-间隙锁"><a href="#12-间隙锁" class="headerlink" title="12. 间隙锁"></a><strong>12. 间隙锁</strong></h2><ul><li>锁定索引间隙，防止其他事务插入幻读。</li><li>与记录锁结合形成 <strong>Next-Key Lock</strong>。</li><li>默认在 Repeatable Read 下使用。</li></ul><hr><h2 id="13-死锁排查"><a href="#13-死锁排查" class="headerlink" title="13. 死锁排查"></a><strong>13. 死锁排查</strong></h2><ul><li><code>SHOW ENGINE INNODB STATUS\G</code> 查看最新死锁。</li><li>优化：<ol><li>统一访问表顺序。</li><li>尽量缩短事务时间。</li><li>加索引减少扫描行数。</li></ol></li></ul><hr><h2 id="14-SQL-执行计划"><a href="#14-SQL-执行计划" class="headerlink" title="14. SQL 执行计划"></a><strong>14. SQL 执行计划</strong></h2><ul><li>使用 <code>EXPLAIN</code> 分析：<ul><li>type：访问类型（ALL &lt; INDEX &lt; REF &lt; CONST）</li><li>key：使用的索引</li><li>rows：扫描行数</li><li>Extra：如 Using index, Using temporary</li></ul></li></ul><hr><h2 id="15-慢查询优化"><a href="#15-慢查询优化" class="headerlink" title="15. 慢查询优化"></a><strong>15. 慢查询优化</strong></h2><ul><li>建索引（覆盖索引、组合索引）</li><li>避免 SELECT *</li><li>避免在列上函数操作</li><li>分库分表</li><li>缓存（Redis&#x2F;Caffeine）</li></ul><hr><h2 id="16-分库分表难点"><a href="#16-分库分表难点" class="headerlink" title="16. 分库分表难点"></a><strong>16. 分库分表难点</strong></h2><ul><li>跨库 join、分页</li><li>分布式事务</li><li>全局唯一 ID</li><li>数据路由、迁移</li></ul><hr><h2 id="17-分布式事务"><a href="#17-分布式事务" class="headerlink" title="17. 分布式事务"></a><strong>17. 分布式事务</strong></h2><ul><li><strong>XA</strong>：两阶段提交，保证强一致性。</li><li><strong>TCC</strong>：Try → Confirm → Cancel，业务补偿操作。</li><li><strong>SAGA</strong>：长事务补偿。</li><li><strong>本地消息表 + MQ</strong>：最终一致性。</li></ul><hr><h2 id="18-Redis-数据结构"><a href="#18-Redis-数据结构" class="headerlink" title="18. Redis 数据结构"></a><strong>18. Redis 数据结构</strong></h2><ul><li><strong>String</strong>、<strong>Hash</strong>、<strong>List</strong>、<strong>Set</strong>、<strong>Sorted Set</strong></li><li>Bitmap、HyperLogLog、Geo</li><li>应用：排行榜、计数、集合操作、地理位置、布隆过滤器</li></ul><hr><h2 id="19-Redis-为什么快"><a href="#19-Redis-为什么快" class="headerlink" title="19. Redis 为什么快"></a><strong>19. Redis 为什么快</strong></h2><ul><li>全内存存储</li><li>单线程 + epoll</li><li>高效数据结构</li><li>避免锁竞争</li></ul><hr><h2 id="20-Redis-持久化"><a href="#20-Redis-持久化" class="headerlink" title="20. Redis 持久化"></a><strong>20. Redis 持久化</strong></h2><ul><li><strong>RDB</strong>：定期快照</li><li><strong>AOF</strong>：写命令日志，append only</li><li><strong>混合持久化</strong>：RDB + AOF，提高安全性与效率</li></ul><hr><h2 id="21-Redis-过期策略"><a href="#21-Redis-过期策略" class="headerlink" title="21. Redis 过期策略"></a><strong>21. Redis 过期策略</strong></h2><ul><li><strong>惰性删除</strong>：访问时检查 TTL</li><li><strong>定期删除</strong>：周期性扫描</li><li><strong>定时删除</strong>：每个 key 单独定时器</li></ul><hr><h2 id="22-Redis-内存淘汰策略"><a href="#22-Redis-内存淘汰策略" class="headerlink" title="22. Redis 内存淘汰策略"></a><strong>22. Redis 内存淘汰策略</strong></h2><ul><li>noeviction、allkeys-lru、volatile-lru、allkeys-lfu、volatile-ttl</li><li>LRU：最近最少使用</li><li>LFU：使用频率最低</li><li>TTL：临期优先淘汰</li></ul><hr><h2 id="23-Redis-主从复制"><a href="#23-Redis-主从复制" class="headerlink" title="23. Redis 主从复制"></a><strong>23. Redis 主从复制</strong></h2><ul><li>异步复制</li><li>全量复制 + 增量复制</li><li>读写分离，提升扩展性</li></ul><hr><h2 id="24-Redis-哨兵机制"><a href="#24-Redis-哨兵机制" class="headerlink" title="24. Redis 哨兵机制"></a><strong>24. Redis 哨兵机制</strong></h2><ul><li>监控、通知、故障转移</li><li>Sentinel 投票机制切换主节点</li><li>高可用架构核心组件</li></ul><hr><h2 id="25-Redis-集群模式"><a href="#25-Redis-集群模式" class="headerlink" title="25. Redis 集群模式"></a><strong>25. Redis 集群模式</strong></h2><ul><li>16384 个哈希槽分片</li><li>Master + Slave</li><li>跨槽操作有限制</li><li>高可用 + 水平扩展</li></ul><hr><h2 id="26-Redis-分布式锁"><a href="#26-Redis-分布式锁" class="headerlink" title="26. Redis 分布式锁"></a><strong>26. Redis 分布式锁</strong></h2><ul><li><strong>单机</strong>：SETNX + EXPIRE</li><li><strong>Redisson</strong>：<ul><li>自动续期（看门狗机制）</li><li>可重入锁</li><li>公平锁</li></ul></li><li><strong>RedLock</strong>：多节点强一致性</li></ul><hr><h2 id="27-Redis-常见问题"><a href="#27-Redis-常见问题" class="headerlink" title="27. Redis 常见问题"></a><strong>27. Redis 常见问题</strong></h2><ul><li>内存不足 &#x2F; OOM</li><li>热点 key</li><li>bigkey 导致阻塞</li><li>RDB fork 阻塞</li><li>主从延迟</li></ul><hr><h2 id="28-缓存穿透、击穿、雪崩"><a href="#28-缓存穿透、击穿、雪崩" class="headerlink" title="28. 缓存穿透、击穿、雪崩"></a><strong>28. 缓存穿透、击穿、雪崩</strong></h2><ul><li><strong>穿透</strong>：不存在数据频繁访问 → 布隆过滤器</li><li><strong>击穿</strong>：热点 key 瞬间失效 → 互斥锁&#x2F;永不过期缓存</li><li><strong>雪崩</strong>：大量 key 同时过期 → TTL + 随机值</li></ul><hr><h2 id="29-缓存与数据库一致性"><a href="#29-缓存与数据库一致性" class="headerlink" title="29. 缓存与数据库一致性"></a><strong>29. 缓存与数据库一致性</strong></h2><ul><li><strong>Cache Aside</strong>：先 DB，再删缓存</li><li><strong>双写</strong>：DB + 缓存同步更新</li><li><strong>异步消息</strong>：MQ + 延时队列，实现最终一致性</li></ul><hr><h2 id="30-Redis-vs-Caffeine"><a href="#30-Redis-vs-Caffeine" class="headerlink" title="30. Redis vs Caffeine"></a><strong>30. Redis vs Caffeine</strong></h2><table><thead><tr><th>特性</th><th>Redis</th><th>Caffeine</th></tr></thead><tbody><tr><td>类型</td><td>分布式缓存</td><td>本地缓存</td></tr><tr><td>持久化</td><td>RDB &#x2F; AOF</td><td>不支持</td></tr><tr><td>集群</td><td>支持</td><td>不支持</td></tr><tr><td>访问速度</td><td>毫秒级</td><td>纳秒级</td></tr><tr><td>场景</td><td>分布式共享，高并发</td><td>本地热点缓存</td></tr></tbody></table><p><strong>最佳实践</strong>：Caffeine（本地缓存）+ Redis（分布式缓存）+ DB → 多级缓存结构。</p><hr><h2 id="八、消息队列（30题）"><a href="#八、消息队列（30题）" class="headerlink" title="八、消息队列（30题）"></a>八、消息队列（30题）</h2><hr><h2 id="1-为什么要使用消息队列？"><a href="#1-为什么要使用消息队列？" class="headerlink" title="1. 为什么要使用消息队列？"></a><strong>1. 为什么要使用消息队列？</strong></h2><ul><li><strong>解耦系统</strong>：生产者与消费者不直接调用，通过队列传递消息。</li><li><strong>异步处理</strong>：用户请求不等待后端业务完成，提高响应速度。</li><li><strong>削峰填谷</strong>：缓冲高峰流量，避免数据库或服务压力过大。</li><li><strong>可靠传输</strong>：通过持久化、ACK 机制保证消息不丢失。</li><li><strong>可扩展性</strong>：增加消费者可水平扩展，提高系统吞吐量。</li><li><strong>面试追问</strong>：为什么 MQ 可以解决微服务间耦合问题？</li></ul><hr><h2 id="2-消息队列的优缺点"><a href="#2-消息队列的优缺点" class="headerlink" title="2. 消息队列的优缺点"></a><strong>2. 消息队列的优缺点</strong></h2><ul><li><strong>优点</strong>：<ul><li>异步处理提升吞吐量</li><li>系统解耦</li><li>支持削峰填谷</li><li>消息可靠性可控</li></ul></li><li><strong>缺点</strong>：<ul><li>系统复杂度增加</li><li>消息延迟</li><li>顺序和重复消费需要额外处理</li></ul></li><li><strong>优化点</strong>：结合幂等设计、延迟队列和批量处理</li></ul><hr><h2 id="3-RabbitMQ-核心组件"><a href="#3-RabbitMQ-核心组件" class="headerlink" title="3. RabbitMQ 核心组件"></a><strong>3. RabbitMQ 核心组件</strong></h2><ul><li><strong>Producer</strong>：发送消息</li><li><strong>Exchange</strong>：路由消息（Direct、Fanout、Topic、Headers）</li><li><strong>Queue</strong>：存储消息</li><li><strong>Binding</strong>：绑定 Exchange 和 Queue</li><li><strong>Consumer</strong>：接收消息</li><li><strong>原理</strong>：Exchange 决定路由规则，Queue 负责缓冲和投递</li></ul><hr><h2 id="4-RabbitMQ-消息确认机制"><a href="#4-RabbitMQ-消息确认机制" class="headerlink" title="4. RabbitMQ 消息确认机制"></a><strong>4. RabbitMQ 消息确认机制</strong></h2><ul><li><strong>生产者端</strong>：<ul><li>Publisher Confirm，确保消息写入 Broker</li></ul></li><li><strong>消费者端</strong>：<ul><li>自动 ack：消费即确认</li><li>手动 ack：成功处理后确认</li></ul></li><li><strong>应用实践</strong>：手动 ack 可处理异常重试，保证消息不丢失</li></ul><hr><h2 id="5-Kafka-核心概念"><a href="#5-Kafka-核心概念" class="headerlink" title="5. Kafka 核心概念"></a><strong>5. Kafka 核心概念</strong></h2><ul><li><strong>Producer&#x2F;Consumer</strong>：消息发送和接收</li><li><strong>Topic&#x2F;Partition</strong>：主题和分区</li><li><strong>Broker&#x2F;Cluster</strong>：节点和集群</li><li><strong>Consumer Group</strong>：消费组实现负载均衡</li><li><strong>Offset</strong>：记录消费位置</li><li><strong>原理</strong>：生产者写入 Partition，消费者根据 Offset 消费</li></ul><hr><h2 id="6-Kafka-分区机制"><a href="#6-Kafka-分区机制" class="headerlink" title="6. Kafka 分区机制"></a><strong>6. Kafka 分区机制</strong></h2><ul><li><strong>Partition 提高并行</strong></li><li><strong>分区内顺序保证</strong></li><li><strong>路由策略</strong>：默认轮询，或 Key 哈希分区</li><li><strong>面试点</strong>：如何保证全局顺序？只能保证分区内顺序</li></ul><hr><h2 id="7-Kafka-副本机制"><a href="#7-Kafka-副本机制" class="headerlink" title="7. Kafka 副本机制"></a><strong>7. Kafka 副本机制</strong></h2><ul><li><strong>Leader&#x2F;Follower 结构</strong></li><li><strong>同步机制</strong>：ISR 列表跟随 Leader</li><li><strong>高可用</strong>：Leader 异常自动切换</li><li><strong>面试拓展</strong>：副本同步模式对性能的影响</li></ul><hr><h2 id="8-Kafka-ISR-原理"><a href="#8-Kafka-ISR-原理" class="headerlink" title="8. Kafka ISR 原理"></a><strong>8. Kafka ISR 原理</strong></h2><ul><li><strong>ISR（In-Sync Replicas）</strong>：跟上 Leader 的副本集合</li><li><strong>消息提交规则</strong>：只要 ISR 内副本写入才算成功</li><li><strong>优化</strong>：副本数量与 ACK 策略可调节可靠性与吞吐量</li></ul><hr><h2 id="9-Kafka-消费组原理"><a href="#9-Kafka-消费组原理" class="headerlink" title="9. Kafka 消费组原理"></a><strong>9. Kafka 消费组原理</strong></h2><ul><li>同一组内的每个 Partition 只被一个 Consumer 消费</li><li>多组可重复消费，实现广播</li><li>提高并行消费，减少重复消费</li><li><strong>拓展</strong>：消费组重平衡、再均衡机制</li></ul><hr><h2 id="10-Kafka-Offset-提交方式"><a href="#10-Kafka-Offset-提交方式" class="headerlink" title="10. Kafka Offset 提交方式"></a><strong>10. Kafka Offset 提交方式</strong></h2><ul><li>自动提交：消费完成后自动提交 Offset</li><li>手动提交：<ul><li>同步提交：阻塞等待</li><li>异步提交：性能高，可能丢少量消息</li></ul></li><li><strong>实践</strong>：结合事务实现 Exactly Once</li></ul><hr><h2 id="11-Kafka-高吞吐量原理"><a href="#11-Kafka-高吞吐量原理" class="headerlink" title="11. Kafka 高吞吐量原理"></a><strong>11. Kafka 高吞吐量原理</strong></h2><ul><li>顺序写磁盘，避免随机 IO</li><li>批量发送消息，减少网络开销</li><li>零拷贝机制，减少 CPU 消耗</li><li><strong>面试拓展</strong>：如何调整批量大小提高吞吐量</li></ul><hr><h2 id="12-Kafka-零拷贝机制"><a href="#12-Kafka-零拷贝机制" class="headerlink" title="12. Kafka 零拷贝机制"></a><strong>12. Kafka 零拷贝机制</strong></h2><ul><li>直接从磁盘 buffer 传到网络 buffer，无用户态复制</li><li>利用 sendfile() 提升大流量传输效率</li></ul><hr><h2 id="13-RocketMQ-核心特点"><a href="#13-RocketMQ-核心特点" class="headerlink" title="13. RocketMQ 核心特点"></a><strong>13. RocketMQ 核心特点</strong></h2><ul><li>高可靠，高性能</li><li>顺序消息、事务消息原生支持</li><li>Broker 无状态，易水平扩展</li><li>支持多语言客户端</li><li>消息存储：CommitLog + ConsumeQueue + IndexFile</li></ul><hr><h2 id="14-RocketMQ-顺序消息"><a href="#14-RocketMQ-顺序消息" class="headerlink" title="14. RocketMQ 顺序消息"></a><strong>14. RocketMQ 顺序消息</strong></h2><ul><li>通过 Key 哈希映射到队列</li><li>队列内顺序严格保证</li><li>应用场景：订单支付、流水处理</li></ul><hr><h2 id="15-RocketMQ-事务消息"><a href="#15-RocketMQ-事务消息" class="headerlink" title="15. RocketMQ 事务消息"></a><strong>15. RocketMQ 事务消息</strong></h2><ul><li><strong>半消息机制</strong>：<ol><li>发送半消息到 Broker</li><li>执行本地事务</li><li>提交或回滚消息</li></ol></li><li>保证分布式事务最终一致性</li></ul><hr><h2 id="16-如何保证消息不丢失"><a href="#16-如何保证消息不丢失" class="headerlink" title="16. 如何保证消息不丢失"></a><strong>16. 如何保证消息不丢失</strong></h2><ul><li><strong>生产者端</strong>：确认机制</li><li><strong>Broker端</strong>：消息持久化</li><li><strong>消费者端</strong>：手动 ack + 幂等消费</li></ul><hr><h2 id="17-如何保证消息不重复消费"><a href="#17-如何保证消息不重复消费" class="headerlink" title="17. 如何保证消息不重复消费"></a><strong>17. 如何保证消息不重复消费</strong></h2><ul><li>消息幂等：唯一 ID + 数据库唯一约束 + Redis 去重</li><li>Kafka Exactly Once + 事务处理</li></ul><hr><h2 id="18-如何保证消息有序"><a href="#18-如何保证消息有序" class="headerlink" title="18. 如何保证消息有序"></a><strong>18. 如何保证消息有序</strong></h2><ul><li><strong>Kafka</strong>：Partition 内顺序</li><li><strong>RocketMQ</strong>：队列内顺序</li><li><strong>注意</strong>：多 Partition 并行可能导致整体无序</li></ul><hr><h2 id="19-消息堆积解决办法"><a href="#19-消息堆积解决办法" class="headerlink" title="19. 消息堆积解决办法"></a><strong>19. 消息堆积解决办法</strong></h2><ul><li>增加消费者数量</li><li>扩展队列分区</li><li>流量削峰</li><li>消费端批量处理，提高吞吐量</li></ul><hr><h2 id="20-如何设计延迟队列"><a href="#20-如何设计延迟队列" class="headerlink" title="20. 如何设计延迟队列"></a><strong>20. 如何设计延迟队列</strong></h2><ul><li><strong>RabbitMQ</strong>：TTL + Dead Letter Queue</li><li><strong>Kafka</strong>：延迟消息插件 &#x2F; 时间轮</li><li><strong>Redis</strong>：SortedSet + 轮询</li><li><strong>场景</strong>：订单超时、短信延迟发送</li></ul><hr><h2 id="21-死信队列作用"><a href="#21-死信队列作用" class="headerlink" title="21. 死信队列作用"></a><strong>21. 死信队列作用</strong></h2><ul><li>消费失败消息收集到死信队列</li><li>支持重试、告警和问题排查</li><li>提高系统可靠性</li></ul><hr><h2 id="22-幂等实现方式"><a href="#22-幂等实现方式" class="headerlink" title="22. 幂等实现方式"></a><strong>22. 幂等实现方式</strong></h2><ul><li>消息唯一 ID</li><li>数据库唯一约束</li><li>Redis 去重缓存</li><li>本地事务结合 MQ 保证幂等</li></ul><hr><h2 id="23-消息队列限流方式"><a href="#23-消息队列限流方式" class="headerlink" title="23. 消息队列限流方式"></a><strong>23. 消息队列限流方式</strong></h2><ul><li>消费者限流：处理速率限制</li><li>生产者限流：令牌桶&#x2F;漏桶</li><li>Broker 队列容量限制 + 拒绝策略</li></ul><hr><h2 id="24-消息队列监控"><a href="#24-消息队列监控" class="headerlink" title="24. 消息队列监控"></a><strong>24. 消息队列监控</strong></h2><ul><li>消息堆积量</li><li>消费速率</li><li>Broker 健康状态</li><li>延迟时间</li><li>工具：Prometheus + Grafana、Kafka Manager、RocketMQ Console、RabbitMQ Management</li></ul><hr><h2 id="25-Kafka-vs-RabbitMQ"><a href="#25-Kafka-vs-RabbitMQ" class="headerlink" title="25. Kafka vs RabbitMQ"></a><strong>25. Kafka vs RabbitMQ</strong></h2><table><thead><tr><th>特性</th><th>Kafka</th><th>RabbitMQ</th></tr></thead><tbody><tr><td>模型</td><td>Pub&#x2F;Sub + Queue</td><td>AMQP</td></tr><tr><td>消息存储</td><td>持久化日志</td><td>队列存储</td></tr><tr><td>顺序保证</td><td>Partition 内顺序</td><td>队列顺序</td></tr><tr><td>高吞吐</td><td>高（批量 + 零拷贝）</td><td>中等</td></tr><tr><td>消费模式</td><td>Pull &#x2F; Push</td><td>Push</td></tr><tr><td>使用场景</td><td>大数据流、日志、事件驱动</td><td>任务队列、异步处理、可靠投递</td></tr></tbody></table><hr><h2 id="26-Kafka-vs-RocketMQ"><a href="#26-Kafka-vs-RocketMQ" class="headerlink" title="26. Kafka vs RocketMQ"></a><strong>26. Kafka vs RocketMQ</strong></h2><table><thead><tr><th>特性</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>顺序消息</td><td>Partition 内顺序</td><td>队列内顺序全局可控</td></tr><tr><td>事务消息</td><td>限制较多</td><td>原生支持</td></tr><tr><td>存储方式</td><td>CommitLog</td><td>CommitLog + ConsumeQueue + IndexFile</td></tr><tr><td>高可用</td><td>ISR + 副本</td><td>Master-Slave + HA</td></tr><tr><td>生态</td><td>Flink、Spark 集成</td><td>分布式事务、支付系统应用</td></tr></tbody></table><hr><h2 id="27-Pulsar-特点"><a href="#27-Pulsar-特点" class="headerlink" title="27. Pulsar 特点"></a><strong>27. Pulsar 特点</strong></h2><ul><li>多租户支持</li><li>持久化使用 BookKeeper</li><li>Topic 可分 Partition</li><li>支持事务、延迟消息</li><li>Push&#x2F;Pull 消费模式灵活</li></ul><hr><h2 id="28-消息中间件如何保证高可用"><a href="#28-消息中间件如何保证高可用" class="headerlink" title="28. 消息中间件如何保证高可用"></a><strong>28. 消息中间件如何保证高可用</strong></h2><ul><li>多副本 + 自动切换</li><li>Broker 集群</li><li>消息持久化</li><li>客户端重试</li><li>Zookeeper&#x2F;Controller 管理元数据</li></ul><hr><h2 id="29-消息队列水平扩展"><a href="#29-消息队列水平扩展" class="headerlink" title="29. 消息队列水平扩展"></a><strong>29. 消息队列水平扩展</strong></h2><ul><li>Kafka：增加 Partition &#x2F; Broker</li><li>RabbitMQ：集群 + Shovel&#x2F;Federation</li><li>RocketMQ：增加 Broker + Topic 分区</li><li><strong>注意</strong>：分区扩展可能影响顺序，需要 Key 路由</li></ul><hr><h2 id="30-消息队列-vs-事件总线"><a href="#30-消息队列-vs-事件总线" class="headerlink" title="30. 消息队列 vs 事件总线"></a><strong>30. 消息队列 vs 事件总线</strong></h2><ul><li>MQ：关注消息可靠性、顺序、确认</li><li>EventBus：关注解耦、广播、轻量级</li><li>MQ 偏向可靠持久化，EventBus 偏向系统内部事件触发</li></ul><hr><h2 id="九、DevOps-容器化（30题）"><a href="#九、DevOps-容器化（30题）" class="headerlink" title="九、DevOps &amp; 容器化（30题）"></a>九、DevOps &amp; 容器化（30题）</h2><hr><h2 id="1-CI-CD-的流程"><a href="#1-CI-CD-的流程" class="headerlink" title="1. CI&#x2F;CD 的流程"></a><strong>1. CI&#x2F;CD 的流程</strong></h2><ul><li><strong>CI（Continuous Integration，持续集成）</strong>：<ul><li>开发者提交代码 → 自动构建 → 自动单元测试 → 自动生成构建产物</li></ul></li><li><strong>CD（Continuous Delivery&#x2F;Deployment，持续交付&#x2F;部署）</strong>：<ul><li>自动部署到测试&#x2F;生产环境 → 自动化验证 → 生产发布</li></ul></li><li><strong>工具链</strong>：<ul><li>Jenkins、GitLab CI、Argo CD</li></ul></li><li><strong>实践要点</strong>：<ul><li>流程自动化</li><li>保证构建产物可回滚</li></ul></li><li><strong>面试拓展</strong>：CI&#x2F;CD 与 DevOps 的关系</li></ul><hr><h2 id="2-Jenkins-的作用"><a href="#2-Jenkins-的作用" class="headerlink" title="2. Jenkins 的作用"></a><strong>2. Jenkins 的作用</strong></h2><ul><li>自动化构建、测试、部署工具</li><li><strong>核心功能</strong>：<ul><li>支持多种 SCM（Git、SVN）</li><li>Pipeline 管理</li><li>插件生态丰富（Docker、K8s 集成）</li></ul></li><li><strong>面试追问</strong>：Pipeline 如何保证构建可重复、可回滚</li></ul><hr><h2 id="3-Docker-核心原理"><a href="#3-Docker-核心原理" class="headerlink" title="3. Docker 核心原理"></a><strong>3. Docker 核心原理</strong></h2><ul><li><strong>容器化技术</strong>：<ul><li>Linux <strong>namespace</strong> 隔离（进程、网络、文件系统）</li><li>Linux <strong>cgroups</strong> 限制资源（CPU、内存）</li><li>**联合文件系统（UnionFS）**实现镜像分层</li></ul></li><li><strong>容器 ≈ 轻量级虚拟机</strong>，共享宿主 OS 内核</li></ul><hr><h2 id="4-Docker-镜像-vs-容器"><a href="#4-Docker-镜像-vs-容器" class="headerlink" title="4. Docker 镜像 vs 容器"></a><strong>4. Docker 镜像 vs 容器</strong></h2><table><thead><tr><th>区别</th><th>镜像</th><th>容器</th></tr></thead><tbody><tr><td>定义</td><td>只读模板</td><td>镜像运行实例</td></tr><tr><td>存储</td><td>分层只读文件系统</td><td>读写层 + 镜像</td></tr><tr><td>生命周期</td><td>永久</td><td>临时，可停止&#x2F;删除</td></tr><tr><td>用途</td><td>构建应用</td><td>运行应用</td></tr></tbody></table><hr><h2 id="5-Dockerfile-常用指令"><a href="#5-Dockerfile-常用指令" class="headerlink" title="5. Dockerfile 常用指令"></a><strong>5. Dockerfile 常用指令</strong></h2><ul><li><code>FROM</code>：基础镜像</li><li><code>RUN</code>：执行命令构建镜像</li><li><code>COPY</code>&#x2F;<code>ADD</code>：复制文件到镜像</li><li><code>CMD</code>&#x2F;<code>ENTRYPOINT</code>：容器启动命令</li><li><code>EXPOSE</code>：声明端口</li><li><code>ENV</code>：环境变量</li><li><strong>优化</strong>：减少镜像层，顺序合理缓存</li></ul><hr><h2 id="6-镜像分层机制"><a href="#6-镜像分层机制" class="headerlink" title="6. 镜像分层机制"></a><strong>6. 镜像分层机制</strong></h2><ul><li>镜像每条指令生成一个只读层</li><li>联合文件系统（UnionFS）叠加这些层</li><li>容器启动时增加读写层</li><li><strong>优势</strong>：<ul><li>共享公共层，节省空间</li><li>支持增量构建</li></ul></li></ul><hr><h2 id="7-容器-vs-虚拟机"><a href="#7-容器-vs-虚拟机" class="headerlink" title="7. 容器 vs 虚拟机"></a><strong>7. 容器 vs 虚拟机</strong></h2><table><thead><tr><th>区别</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>内核</td><td>共享宿主 OS 内核</td><td>独立 OS</td></tr><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>资源占用</td><td>轻量</td><td>重量</td></tr><tr><td>隔离</td><td>进程级</td><td>硬件级</td></tr></tbody></table><hr><h2 id="8-Kubernetes-核心组件"><a href="#8-Kubernetes-核心组件" class="headerlink" title="8. Kubernetes 核心组件"></a><strong>8. Kubernetes 核心组件</strong></h2><ul><li><strong>Master</strong>：<ul><li>API Server：接收用户请求</li><li>Scheduler：Pod 调度</li><li>Controller Manager：状态管理</li><li>etcd：分布式配置存储</li></ul></li><li><strong>Node</strong>：<ul><li>Kubelet：Pod 生命周期管理</li><li>Kube-proxy：服务网络代理</li><li>Container Runtime（Docker&#x2F;CRI-O）</li></ul></li></ul><hr><h2 id="9-Pod-生命周期"><a href="#9-Pod-生命周期" class="headerlink" title="9. Pod 生命周期"></a><strong>9. Pod 生命周期</strong></h2><ul><li><strong>Pending</strong> → <strong>Running</strong> → <strong>Succeeded&#x2F;Failed</strong></li><li><strong>状态管理</strong>：<ul><li>initContainer → main container → postStop Hook</li></ul></li><li><strong>面试点</strong>：Pod 重启策略（Always&#x2F;OnFailure&#x2F;Never）</li></ul><hr><h2 id="10-Deployment-vs-StatefulSet"><a href="#10-Deployment-vs-StatefulSet" class="headerlink" title="10. Deployment vs StatefulSet"></a><strong>10. Deployment vs StatefulSet</strong></h2><table><thead><tr><th>特性</th><th>Deployment</th><th>StatefulSet</th></tr></thead><tbody><tr><td>Pod 标识</td><td>无固定名字</td><td>有固定名字</td></tr><tr><td>顺序更新</td><td>可并行更新</td><td>严格顺序更新</td></tr><tr><td>持久化存储</td><td>共享卷</td><td>独立持久卷</td></tr><tr><td>应用场景</td><td>无状态服务</td><td>数据库、Kafka Broker 等状态服务</td></tr></tbody></table><hr><h2 id="11-K8s-服务发现机制"><a href="#11-K8s-服务发现机制" class="headerlink" title="11. K8s 服务发现机制"></a><strong>11. K8s 服务发现机制</strong></h2><ul><li><strong>ClusterIP</strong>：集群内部访问</li><li><strong>NodePort</strong>：节点端口访问</li><li><strong>LoadBalancer</strong>：外部访问</li><li><strong>DNS + kube-proxy</strong>：Pod 名称解析 + iptables 转发</li></ul><hr><h2 id="12-ConfigMap-和-Secret"><a href="#12-ConfigMap-和-Secret" class="headerlink" title="12. ConfigMap 和 Secret"></a><strong>12. ConfigMap 和 Secret</strong></h2><table><thead><tr><th>特性</th><th>ConfigMap</th><th>Secret</th></tr></thead><tbody><tr><td>数据类型</td><td>明文配置</td><td>Base64 编码敏感信息</td></tr><tr><td>使用方式</td><td>Env&#x2F;Volume</td><td>Env&#x2F;Volume</td></tr><tr><td>安全性</td><td>不加密</td><td>加密可集成 KMS</td></tr></tbody></table><hr><h2 id="13-Ingress-的作用"><a href="#13-Ingress-的作用" class="headerlink" title="13. Ingress 的作用"></a><strong>13. Ingress 的作用</strong></h2><ul><li>集群外部访问 Pod 的入口</li><li>功能：<ul><li>路由到不同服务</li><li>TLS 终端</li><li>负载均衡</li></ul></li><li><strong>面试点</strong>：Ingress Controller vs Service LB</li></ul><hr><h2 id="14-K8s-水平扩缩容机制"><a href="#14-K8s-水平扩缩容机制" class="headerlink" title="14. K8s 水平扩缩容机制"></a><strong>14. K8s 水平扩缩容机制</strong></h2><ul><li><strong>HPA（Horizontal Pod Autoscaler）</strong>：根据 CPU、内存或自定义指标调整 Pod 数量</li><li><strong>VPA（Vertical Pod Autoscaler）</strong>：自动调整 Pod 资源配置</li><li><strong>Cluster Autoscaler</strong>：节点自动扩缩容</li></ul><hr><h2 id="15-K8s-滚动更新机制"><a href="#15-K8s-滚动更新机制" class="headerlink" title="15. K8s 滚动更新机制"></a><strong>15. K8s 滚动更新机制</strong></h2><ul><li><strong>Deployment</strong> 滚动更新策略：<ul><li><code>maxUnavailable</code>：最大不可用 Pod</li><li><code>maxSurge</code>：最大新增 Pod</li></ul></li><li><strong>保证无中断升级</strong></li></ul><hr><h2 id="16-K8s-灰度发布"><a href="#16-K8s-灰度发布" class="headerlink" title="16. K8s 灰度发布"></a><strong>16. K8s 灰度发布</strong></h2><ul><li><strong>方法</strong>：<ul><li>分流流量（Ingress&#x2F;Service Mesh）</li><li>多版本 Deployment</li><li>Canary Pod + 路由权重</li></ul></li></ul><hr><h2 id="17-K8s-调度策略"><a href="#17-K8s-调度策略" class="headerlink" title="17. K8s 调度策略"></a><strong>17. K8s 调度策略</strong></h2><ul><li><strong>默认调度</strong>：基于资源（CPU&#x2F;Memory）</li><li><strong>亲和性&#x2F;反亲和性</strong>：<ul><li>NodeAffinity</li><li>PodAffinity &#x2F; PodAntiAffinity</li></ul></li><li><strong>Taints &amp; Tolerations</strong>：节点污点控制 Pod 调度</li></ul><hr><h2 id="18-K8s-网络模型"><a href="#18-K8s-网络模型" class="headerlink" title="18. K8s 网络模型"></a><strong>18. K8s 网络模型</strong></h2><ul><li><strong>要求</strong>：<ul><li>Pod 可以直接互相通信</li><li>Pod 与 Node 通信</li></ul></li><li><strong>方案</strong>：<ul><li>Flannel、Calico、Cilium 等</li></ul></li><li><strong>面试点</strong>：Overlay 网络 vs Underlay 网络</li></ul><hr><h2 id="19-Service-Mesh-作用"><a href="#19-Service-Mesh-作用" class="headerlink" title="19. Service Mesh 作用"></a><strong>19. Service Mesh 作用</strong></h2><ul><li>透明通信管理</li><li>流量控制、熔断、限流</li><li>可观察性（Tracing、Metrics）</li><li>安全（mTLS）</li></ul><hr><h2 id="20-Istio-工作原理"><a href="#20-Istio-工作原理" class="headerlink" title="20. Istio 工作原理"></a><strong>20. Istio 工作原理</strong></h2><ul><li><strong>Sidecar Proxy</strong>：每个 Pod 注入 Envoy</li><li><strong>控制平面（Pilot）</strong>：下发路由规则</li><li><strong>Mixer &#x2F; Telemetry</strong>：采集指标和日志</li><li><strong>应用</strong>：<ul><li>灰度发布、流量镜像、故障注入、服务间安全通信</li></ul></li></ul><hr><h2 id="21-Helm-的作用"><a href="#21-Helm-的作用" class="headerlink" title="21. Helm 的作用"></a><strong>21. Helm 的作用</strong></h2><ul><li>Kubernetes 包管理工具</li><li><strong>功能</strong>：<ul><li>Chart 模板化部署</li><li>版本管理</li><li>一键升级&#x2F;回滚</li></ul></li><li><strong>面试拓展</strong>：Helm 与 Kustomize 区别</li></ul><hr><h2 id="22-K8s-存储方案"><a href="#22-K8s-存储方案" class="headerlink" title="22. K8s 存储方案"></a><strong>22. K8s 存储方案</strong></h2><ul><li><strong>临时存储</strong>：emptyDir</li><li><strong>持久卷</strong>：PersistentVolume + PersistentVolumeClaim</li><li><strong>存储类型</strong>：<ul><li>本地存储</li><li>NFS</li><li>Ceph &#x2F; GlusterFS</li><li>云存储（EBS、OSS）</li></ul></li></ul><hr><h2 id="23-Prometheus-监控体系"><a href="#23-Prometheus-监控体系" class="headerlink" title="23. Prometheus 监控体系"></a><strong>23. Prometheus 监控体系</strong></h2><ul><li>Pull 模型采集指标</li><li>TSDB 存储时间序列数据</li><li>AlertManager 告警</li><li>可监控 K8s 组件、Pod、应用指标</li></ul><hr><h2 id="24-Grafana-的作用"><a href="#24-Grafana-的作用" class="headerlink" title="24. Grafana 的作用"></a><strong>24. Grafana 的作用</strong></h2><ul><li>可视化 Prometheus 数据</li><li>仪表盘定制</li><li>支持多数据源（InfluxDB、ElasticSearch）</li><li>面试点：报警可视化和多租户支持</li></ul><hr><h2 id="25-K8s-安全机制"><a href="#25-K8s-安全机制" class="headerlink" title="25. K8s 安全机制"></a><strong>25. K8s 安全机制</strong></h2><ul><li><strong>认证（Authentication）</strong>：Token &#x2F; X.509 &#x2F; OIDC</li><li><strong>授权（Authorization）</strong>：RBAC</li><li><strong>网络策略（NetworkPolicy）</strong></li><li><strong>Secret 加密</strong></li></ul><hr><h2 id="26-容器资源限制"><a href="#26-容器资源限制" class="headerlink" title="26. 容器资源限制"></a><strong>26. 容器资源限制</strong></h2><ul><li><strong>CPU &#x2F; Memory</strong>：requests &#x2F; limits</li><li><strong>QoS 分类</strong>：<ul><li>Guaranteed、Burstable、BestEffort</li></ul></li><li><strong>面试点</strong>：容器 OOM 及限流策略</li></ul><hr><h2 id="27-Docker-Compose-作用"><a href="#27-Docker-Compose-作用" class="headerlink" title="27. Docker Compose 作用"></a><strong>27. Docker Compose 作用</strong></h2><ul><li>多容器应用管理</li><li>本地开发、测试</li><li>声明式配置网络、依赖关系</li></ul><hr><h2 id="28-DevOps-最佳实践"><a href="#28-DevOps-最佳实践" class="headerlink" title="28. DevOps 最佳实践"></a><strong>28. DevOps 最佳实践</strong></h2><ul><li>持续集成&#x2F;持续交付</li><li>基础设施即代码（IaC）</li><li>自动化测试与部署</li><li>微服务 + 容器化 + 云原生</li></ul><hr><h2 id="29-GitOps-理念"><a href="#29-GitOps-理念" class="headerlink" title="29. GitOps 理念"></a><strong>29. GitOps 理念</strong></h2><ul><li>将 Git 作为单一真源</li><li>K8s 自动同步 Git 状态</li><li>优点：<ul><li>可追踪、可回滚</li><li>流程统一、可审计</li></ul></li></ul><hr><h2 id="30-K8s-如何保证高可用"><a href="#30-K8s-如何保证高可用" class="headerlink" title="30. K8s 如何保证高可用"></a><strong>30. K8s 如何保证高可用</strong></h2><ul><li>Master 节点多副本（HA）</li><li>ETCD 集群存储</li><li>Pod 多副本 + Deployment&#x2F;StatefulSet</li><li>Service + LoadBalancer 提供稳定访问</li><li>Cluster Autoscaler 支持节点弹性扩展</li></ul><hr><h2 id="十、场景设计题（30题）"><a href="#十、场景设计题（30题）" class="headerlink" title="十、场景设计题（30题）"></a>十、场景设计题（30题）</h2><ol><li>如何设计一个秒杀系统？</li><li>如何设计一个短链系统？</li><li>如何设计一个分布式 ID 生成系统？</li><li>如何设计一个高可用缓存系统？</li><li>如何设计一个订单系统？</li><li>如何设计一个支付系统？</li><li>如何设计一个消息推送系统？</li><li>如何设计一个日志收集系统？</li><li>如何设计一个搜索引擎？</li><li>如何设计一个推荐系统？</li><li>如何设计一个分布式锁？</li><li>如何设计一个统一鉴权系统？</li><li>如何设计一个限流系统？</li><li>如何设计一个灰度发布系统？</li><li>如何设计一个电商购物车？</li><li>如何设计一个库存系统？</li><li>如何设计一个分布式文件存储系统？</li><li>如何设计一个微服务网关？</li><li>如何设计一个分布式任务调度系统？</li><li>如何设计一个监控报警系统？</li><li>如何设计一个高并发聊天室？</li><li>如何设计一个排行榜系统？</li><li>如何设计一个评论系统？</li><li>如何设计一个分布式事务系统？</li><li>如何设计一个高可用注册中心？</li><li>如何设计一个数据同步系统？</li><li>如何设计一个 API 限速系统？</li><li>如何设计一个高可用的支付网关？</li><li>如何设计一个跨境电商架构？</li><li>如何设计一个金融级别的微服务系统？</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> 题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点</title>
      <link href="/2025/09/11/java%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2025/09/11/java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一、网络基础概念"><a href="#一、网络基础概念" class="headerlink" title="一、网络基础概念"></a>一、网络基础概念</h1><ol><li><strong>网络的定义</strong><br> 网络是多个计算机及通信设备通过通信介质互联的系统，用于信息传输、资源共享、协同工作。<ul><li>核心目标：可靠、高效、可扩展的数据传输。</li><li>设计原则：分层、模块化、接口标准化。</li></ul></li><li><strong>数据传输方式</strong><ul><li><strong>单工</strong>：单向传输（电视广播）。</li><li><strong>半双工</strong>：双向传输，但不能同时发送（对讲机）。</li><li><strong>全双工</strong>：双向同时传输（电话、以太网交换机端口）。</li></ul></li><li><strong>通信方式</strong><ul><li><strong>点对点</strong>：两个节点直接通信（PPP）。</li><li><strong>广播</strong>：单点发送，多点接收（Ethernet）。</li><li><strong>组播</strong>：单点发送，特定组接收（IP 多播）。</li></ul></li><li><strong>网络分类</strong><ul><li><strong>按地理范围</strong>：LAN、MAN、WAN。</li><li><strong>按拓扑结构</strong>：星型、总线型、环型、混合型。</li><li><strong>按访问控制方式</strong>：CSMA&#x2F;CD（Ethernet）、令牌环（Token Ring）。</li></ul></li></ol><hr><h1 id="二、OSI-七层模型"><a href="#二、OSI-七层模型" class="headerlink" title="二、OSI 七层模型"></a>二、OSI 七层模型</h1><p>OSI 模型将网络通信划分为七层，每层负责特定功能，确保模块化与互操作性。</p><table><thead><tr><th>层</th><th>功能</th><th>数据单位</th><th>典型协议&#x2F;设备</th><th>面试易问点</th></tr></thead><tbody><tr><td><strong>物理层</strong></td><td>比特流传输，电气&#x2F;光学&#x2F;机械接口</td><td>比特 Bit</td><td>网线、光纤、集线器、网卡物理部分、调制解调器</td><td>电压、传输速率、双工模式、光纤与铜缆区别</td></tr><tr><td><strong>数据链路层</strong></td><td>节点间帧传输，差错控制、流量控制、MAC 地址</td><td>帧 Frame</td><td>以太网、PPP、交换机、网桥</td><td>CSMA&#x2F;CD 工作原理、MAC 地址格式、VLAN</td></tr><tr><td><strong>网络层</strong></td><td>主机到主机传输，逻辑寻址、路由、拥塞控制</td><td>数据包 Packet</td><td>IP、ICMP、IGMP、路由器</td><td>路由选择算法（RIP&#x2F;OSPF&#x2F;BGP）、子网掩码计算、NAT</td></tr><tr><td><strong>传输层</strong></td><td>端到端通信，端口映射、分段重组、流量控制</td><td>报文段 Segment (TCP)、数据报 Datagram (UDP)</td><td>TCP、UDP</td><td>TCP 三次握手、四次挥手、滑动窗口、端口号分类</td></tr><tr><td><strong>会话层</strong></td><td>管理应用会话，数据同步</td><td>会话数据</td><td>NetBIOS、RPC、NFS、SQL</td><td>断点续传、会话保持机制</td></tr><tr><td><strong>表示层</strong></td><td>数据表示、编码、加密压缩</td><td>表示数据</td><td>JPEG、MPEG、ASCII、Unicode、TLS&#x2F;SSL</td><td>大端&#x2F;小端、编码转换、加密&#x2F;解密流程</td></tr><tr><td><strong>应用层</strong></td><td>提供用户服务，直接与应用交互</td><td>应用数据</td><td>HTTP、FTP、SMTP、POP3&#x2F;IMAP、DNS、Telnet、SNMP</td><td>HTTP 请求&#x2F;响应报文结构、DNS 查询流程、FTP 主动&#x2F;被动模式</td></tr></tbody></table><h3 id="1-物理层深度"><a href="#1-物理层深度" class="headerlink" title="1. 物理层深度"></a>1. 物理层深度</h3><ul><li><strong>电气特性</strong>：电压幅值、频率、信号调制。</li><li><strong>传输介质差异</strong>：<ul><li>铜缆（双绞线、同轴）: 成本低、易干扰。</li><li>光纤: 高速、长距离、抗电磁干扰。</li></ul></li><li><strong>面试常问</strong>：光纤单模和多模区别、网卡速率、半双工&#x2F;全双工。</li></ul><h3 id="2-数据链路层深度"><a href="#2-数据链路层深度" class="headerlink" title="2. 数据链路层深度"></a>2. 数据链路层深度</h3><ul><li><strong>MAC 地址</strong>：唯一标识网卡，48 位（前 24 位厂商号，后 24 位设备号）。</li><li><strong>流量控制</strong>：<ul><li>停止等待（Stop-and-Wait）</li><li>滑动窗口（Sliding Window）</li></ul></li><li><strong>差错控制</strong>：CRC 校验、帧校验序列 (FCS)。</li><li><strong>VLAN</strong>：逻辑分隔网络，减少广播风暴。</li></ul><h3 id="3-网络层深度"><a href="#3-网络层深度" class="headerlink" title="3. 网络层深度"></a>3. 网络层深度</h3><ul><li><strong>逻辑寻址</strong>：IPv4&#x2F;IPv6</li><li><strong>子网划分</strong>：CIDR、VLSM。</li><li><strong>路由协议</strong>：<ul><li><strong>RIP</strong>：跳数最短，收敛慢。</li><li><strong>OSPF</strong>：链路状态，快速收敛。</li><li><strong>BGP</strong>：自治系统间，策略路由。</li></ul></li><li><strong>NAT</strong>：私网 IP 转换为公网 IP，节约 IP。</li></ul><h3 id="4-传输层深度"><a href="#4-传输层深度" class="headerlink" title="4. 传输层深度"></a>4. 传输层深度</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li><strong>可靠性机制</strong>：<ul><li>序列号与确认号。</li><li>滑动窗口。</li><li>重传机制（超时&#x2F;快速重传）。</li></ul></li><li><strong>三次握手（建立连接）</strong><ul><li><strong>第一次 (SYN)</strong>：客户端请求，seq&#x3D;client_ISN。</li><li><strong>第二次 (SYN-ACK)</strong>：服务器确认客户端，seq&#x3D;server_ISN, ack&#x3D;client_ISN+1。</li><li><strong>第三次 (ACK)</strong>：客户端确认服务器，ack&#x3D;server_ISN+1。</li></ul></li><li><strong>四次挥手（断开连接）</strong><ul><li>FIN&#x2F;ACK 交替关闭双向。</li><li>TIME_WAIT: 2MSL，保证最后 ACK 到达并避免旧报文干扰。</li></ul></li><li><strong>流量控制</strong>：滑动窗口</li><li><strong>拥塞控制</strong>：慢启动、拥塞避免、快速重传、快速恢复。</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li><strong>特点</strong>：无连接、无序、不保证到达。</li><li><strong>应用</strong>：DNS、VoIP、视频直播。</li><li><strong>优点</strong>：低延迟、开销小。</li></ul><h3 id="5-会话层深度"><a href="#5-会话层深度" class="headerlink" title="5. 会话层深度"></a>5. 会话层深度</h3><ul><li><strong>会话管理</strong>：<ul><li>会话建立、保持、终止。</li><li>数据同步点（断点续传）。</li></ul></li><li><strong>面试点</strong>：HTTP 是无状态协议，如何实现会话保持？（Cookie&#x2F;Session&#x2F;Token）</li></ul><h3 id="6-表示层深度"><a href="#6-表示层深度" class="headerlink" title="6. 表示层深度"></a>6. 表示层深度</h3><ul><li><strong>数据格式化</strong>：ASCII、Unicode、EBCDIC。</li><li><strong>压缩&#x2F;解压</strong>：JPEG、MPEG、ZIP。</li><li><strong>加密&#x2F;解密</strong>：TLS&#x2F;SSL，实现安全通信。</li><li><strong>面试点</strong>：大端小端，Base64 编码。</li></ul><h3 id="7-应用层深度"><a href="#7-应用层深度" class="headerlink" title="7. 应用层深度"></a>7. 应用层深度</h3><ul><li><strong>HTTP</strong>：<ul><li>请求方法：GET&#x2F;POST&#x2F;PUT&#x2F;DELETE&#x2F;OPTIONS。</li><li>状态码：1xx-5xx。</li></ul></li><li><strong>DNS</strong>：<ul><li>查询类型：A&#x2F;AAAA&#x2F;CNAME&#x2F;MX。</li><li>递归&#x2F;迭代查询。</li></ul></li><li><strong>SMTP&#x2F;POP3&#x2F;IMAP</strong>：<ul><li>发送与接收流程。</li></ul></li><li><strong>面试点</strong>：<ul><li>FTP 主动&#x2F;被动模式差异。</li><li>HTTPS 握手流程（证书交换 + 对称密钥）。</li></ul></li></ul><hr><h1 id="三、TCP-IP-协议族（详细版）"><a href="#三、TCP-IP-协议族（详细版）" class="headerlink" title="三、TCP&#x2F;IP 协议族（详细版）"></a>三、TCP&#x2F;IP 协议族（详细版）</h1><table><thead><tr><th>层</th><th>功能</th><th>协议</th><th>特点</th><th>面试易问点</th></tr></thead><tbody><tr><td>应用层</td><td>用户应用服务</td><td>HTTP、DNS、FTP、SMTP</td><td>与用户交互</td><td>HTTP 状态码、DNS 查询过程</td></tr><tr><td>传输层</td><td>端到端通信</td><td>TCP、UDP</td><td>TCP 可靠、UDP 高效</td><td>三次握手、四次挥手、流量控制</td></tr><tr><td>网络层</td><td>主机到主机</td><td>IP、ICMP、ARP</td><td>IP 无连接、路由选择</td><td>子网划分、NAT、ICMP 报文</td></tr><tr><td>网络接口层</td><td>物理链路传输</td><td>Ethernet、PPP</td><td>比特传输</td><td>MAC 地址、冲突检测</td></tr></tbody></table><hr><h3 id="TCP-三次握手总结"><a href="#TCP-三次握手总结" class="headerlink" title="TCP 三次握手总结"></a>TCP 三次握手总结</h3><ol><li>客户端发送 SYN，告知初始序列号。</li><li>服务器返回 SYN-ACK，确认收到 SYN 并告知自身序列号。</li><li>客户端 ACK 确认，双方 ESTABLISHED。</li></ol><h3 id="TCP-四次挥手总结"><a href="#TCP-四次挥手总结" class="headerlink" title="TCP 四次挥手总结"></a>TCP 四次挥手总结</h3><ol><li>主动方 FIN，关闭发送。</li><li>被动方 ACK，确认。</li><li>被动方 FIN，关闭发送。</li><li>主动方 ACK，进入 TIME_WAIT，等待 2MSL。</li></ol><hr><h2 id="一、TCP-与-UDP-区别（深入版）"><a href="#一、TCP-与-UDP-区别（深入版）" class="headerlink" title="一、TCP 与 UDP 区别（深入版）"></a>一、TCP 与 UDP 区别（深入版）</h2><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td><strong>连接方式</strong></td><td>面向连接，需要三次握手建立连接</td><td>无连接，直接发送数据报</td></tr><tr><td><strong>可靠性</strong></td><td>可靠传输，确保数据完整、有序、不丢失</td><td>不可靠传输，不能保证顺序和到达</td></tr><tr><td><strong>数据单位</strong></td><td>报文段 (Segment)</td><td>数据报 (Datagram)</td></tr><tr><td><strong>速度</strong></td><td>较慢，需要建立连接、确认和重传机制</td><td>快，无握手和重传，开销小</td></tr><tr><td><strong>传输顺序</strong></td><td>保证顺序，序列号 + ACK 确认</td><td>不保证顺序，独立发送</td></tr><tr><td><strong>拥塞控制</strong></td><td>有，TCP 拥塞控制算法（慢启动、拥塞避免、快速重传、快速恢复）</td><td>无</td></tr><tr><td><strong>应用场景</strong></td><td>文件传输 (FTP)、网页访问 (HTTP&#x2F;HTTPS)、邮件 (SMTP&#x2F;POP3)</td><td>实时视频&#x2F;语音 (VoIP、直播)、DNS 查询、DHCP</td></tr><tr><td><strong>面试拓展点</strong></td><td>TCP 适合可靠性要求高的场景</td><td>UDP 适合低延迟、可容忍丢包的场景</td></tr></tbody></table><p><strong>面试问法示例：</strong></p><ul><li>“TCP 为什么可靠，UDP 为什么不可靠？”<br> <strong>回答要点</strong>：TCP 使用序列号、ACK 确认、重传机制、流量控制和拥塞控制来保证可靠性；UDP 没有这些机制，直接发送报文，速度快，但不保证到达和顺序。</li></ul><hr><h2 id="二、三次握手的意义（深入版）"><a href="#二、三次握手的意义（深入版）" class="headerlink" title="二、三次握手的意义（深入版）"></a>二、三次握手的意义（深入版）</h2><p><strong>三次握手步骤复习</strong>：</p><ol><li><strong>客户端 → 服务器</strong>：SYN 报文，请求建立连接，发送 client_ISN。</li><li><strong>服务器 → 客户端</strong>：SYN-ACK 报文，确认客户端 SYN，并发送 server_ISN。</li><li><strong>客户端 → 服务器</strong>：ACK 报文，确认 server_ISN，连接建立。</li></ol><p><strong>为什么需要三次握手？</strong></p><ol><li><strong>防止旧连接报文误建</strong><ul><li>如果只有两次握手，旧的 SYN 报文可能延迟到达，服务器误认为是新连接。</li><li>三次握手确保客户端主动确认，服务器不会因为旧报文进入 ESTABLISHED。</li></ul></li><li><strong>双向确认收发能力</strong><ul><li>第一次握手：客户端告诉服务器它能发。</li><li>第二次握手：服务器告诉客户端它能发，也确认客户端能发。</li><li>第三次握手：客户端确认服务器能收。</li><li><strong>面试常问拓展</strong>：为什么第一次握手服务器不直接进入 ESTABLISHED？<br> <strong>答案</strong>：服务器不能确定客户端已经准备好接收数据，需第三次握手确认。</li></ul></li></ol><hr><h2 id="三、TIME-WAIT-的意义（深入版）"><a href="#三、TIME-WAIT-的意义（深入版）" class="headerlink" title="三、TIME_WAIT 的意义（深入版）"></a>三、TIME_WAIT 的意义（深入版）</h2><ul><li><strong>TCP 四次挥手后客户端进入 TIME_WAIT</strong></li><li><strong>作用</strong>：<ol><li><strong>确保最后 ACK 能到达服务器</strong><ul><li>如果 ACK 丢失，服务器会重发 FIN，客户端在 TIME_WAIT 状态可以重新响应。</li></ul></li><li><strong>防止旧报文干扰新连接</strong><ul><li>2MSL（Maximum Segment Lifetime）内保证网络中旧报文被清除。</li></ul></li></ol></li><li><strong>典型面试问法</strong>：<ul><li>“为什么客户端主动关闭连接进入 TIME_WAIT，而服务器不进入？”<br> <strong>答案</strong>：主动关闭方需要确保 ACK 能到达被动关闭方并防止旧报文干扰新连接；被动关闭方在收到 ACK 后即可关闭。</li><li>“TIME_WAIT 为什么要等待 2MSL？”<br> <strong>答案</strong>：MSL 是报文在网络中的最大生存时间，等待 2MSL 可以确保所有可能滞留的报文消失。</li></ul></li></ul><hr><h2 id="四、OSI-七层-vs-TCP-IP-模型（深入版）"><a href="#四、OSI-七层-vs-TCP-IP-模型（深入版）" class="headerlink" title="四、OSI 七层 vs TCP&#x2F;IP 模型（深入版）"></a>四、OSI 七层 vs TCP&#x2F;IP 模型（深入版）</h2><table><thead><tr><th>模型</th><th>层数</th><th>功能</th><th>面试关注点</th></tr></thead><tbody><tr><td><strong>OSI</strong></td><td>7 层：应用、表示、会话、传输、网络、数据链路、物理</td><td>理论模型，描述网络通信的完整功能</td><td>面试常考“每层功能、数据单位、协议、典型设备”</td></tr><tr><td><strong>TCP&#x2F;IP</strong></td><td>4 层：应用、传输、网络、网络接口</td><td>实际互联网使用的模型，简化 OSI，结合实际协议</td><td>面试常考“TCP&#x2F;IP 与 OSI 的对应关系、核心协议、应用场景”</td></tr></tbody></table><p><strong>OSI 与 TCP&#x2F;IP 对应关系</strong>：</p><ul><li>OSI 应用&#x2F;表示&#x2F;会话层 → TCP&#x2F;IP 应用层</li><li>OSI 传输层 → TCP&#x2F;IP 传输层</li><li>OSI 网络层 → TCP&#x2F;IP 网络层</li><li>OSI 数据链路层 + 物理层 → TCP&#x2F;IP 网络接口层</li></ul><p><strong>面试拓展点</strong>：</p><ol><li>TCP&#x2F;IP 为什么只有 4 层？<ul><li>因为实际应用中，表示层与会话层功能通常由应用层实现，硬件设备的物理和链路层可合并。</li></ul></li><li>OSI 模型为什么重要？<ul><li>理论指导，帮助理解网络通信分层设计、模块化、互操作性。</li></ul></li><li>面试常问：OSI 七层模型每层面试问法示例<ul><li><strong>物理层</strong>：双绞线和光纤区别？全双工和半双工区别？</li><li><strong>数据链路层</strong>：MAC 地址格式？交换机与网桥区别？VLAN 原理？</li><li><strong>网络层</strong>：IP 地址分类？子网掩码？RIP vs OSPF？</li><li><strong>传输层</strong>：TCP&#x2F;UDP 区别？三次握手流程？滑动窗口原理？</li><li><strong>会话层</strong>：HTTP 无状态如何实现会话保持？</li><li><strong>表示层</strong>：编码转换？大端小端？TLS 加密流程？</li><li><strong>应用层</strong>：HTTP 状态码？FTP 主动&#x2F;被动模式？DNS 查询过程？</li></ul></li></ol><hr><h2 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1. 物理层"></a>1. 物理层</h2><p><strong>Q1：双绞线和光纤区别？</strong><br> <strong>A1</strong>：</p><table><thead><tr><th>特性</th><th>双绞线</th><th>光纤</th></tr></thead><tbody><tr><td>传输介质</td><td>铜线</td><td>光纤（玻璃或塑料）</td></tr><tr><td>传输方式</td><td>电信号</td><td>光信号</td></tr><tr><td>抗干扰性</td><td>容易受电磁干扰</td><td>抗电磁干扰强</td></tr><tr><td>传输距离</td><td>短（100米左右）</td><td>长（可达数公里）</td></tr><tr><td>传输速率</td><td>10Mbps~10Gbps</td><td>1Gbps~400Gbps</td></tr><tr><td>成本</td><td>低</td><td>高</td></tr><tr><td><strong>面试要点</strong>：光纤适合高速、长距离、数据中心或核心网，双绞线适合局域网。</td><td></td><td></td></tr></tbody></table><p><strong>Q2：全双工和半双工区别？</strong><br> <strong>A2</strong>：</p><ul><li><strong>半双工</strong>：数据双向传输，但同一时间只能一个方向（如对讲机）。</li><li><strong>全双工</strong>：数据双向传输，可同时收发（如现代交换机端口）。<br> <strong>面试要点</strong>：半双工容易冲突，需要 CSMA&#x2F;CD，降低效率；全双工无需冲突检测，速率翻倍。</li></ul><hr><h2 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2. 数据链路层"></a>2. 数据链路层</h2><p><strong>Q1：MAC 地址格式？</strong><br> <strong>A1</strong>：</p><ul><li>48 位二进制，通常写作 6 组十六进制：<code>00:1A:2B:3C:4D:5E</code></li><li>前 24 位：厂商标识（OUI）</li><li>后 24 位：网卡序列号</li><li>唯一标识网卡设备<br> <strong>面试要点</strong>：MAC 地址用于局域网内通信，交换机通过 MAC 表转发帧。</li></ul><p><strong>Q2：交换机与网桥区别？</strong></p><table><thead><tr><th>特性</th><th>网桥 (Bridge)</th><th>交换机 (Switch)</th></tr></thead><tbody><tr><td>端口数</td><td>少</td><td>多</td></tr><tr><td>功能</td><td>转发帧、过滤广播</td><td>转发帧、学习 MAC、分割冲突域</td></tr><tr><td>性能</td><td>较低</td><td>高</td></tr><tr><td><strong>面试要点</strong>：交换机可以理解为多端口网桥，隔离冲突域，效率更高。</td><td></td><td></td></tr></tbody></table><p><strong>Q3：VLAN 原理？</strong><br> <strong>A3</strong>：</p><ul><li>虚拟局域网（Virtual LAN）在同一物理交换机上划分不同逻辑网段。</li><li>通过 <strong>802.1Q 标签</strong> 给帧打标签，实现逻辑隔离。</li><li>优点：隔离广播域，提高安全性和管理性。<br> <strong>面试要点</strong>：同一交换机内不同 VLAN 之间通信需要路由器或三层交换机。</li></ul><hr><h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h2><p><strong>Q1：IP 地址分类？</strong></p><table><thead><tr><th>类别</th><th>起始位</th><th>范围</th><th>默认子网掩码</th><th>用途</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1.0.0.0–126.255.255.255</td><td>255.0.0.0</td><td>大型网络</td></tr><tr><td>B</td><td>10</td><td>128.0.0.0–191.255.255.255</td><td>255.255.0.0</td><td>中型网络</td></tr><tr><td>C</td><td>110</td><td>192.0.0.0–223.255.255.255</td><td>255.255.255.0</td><td>小型网络</td></tr><tr><td>D</td><td>1110</td><td>224.0.0.0–239.255.255.255</td><td>N&#x2F;A</td><td>多播</td></tr><tr><td>E</td><td>1111</td><td>240.0.0.0–255.255.255.255</td><td>N&#x2F;A</td><td>实验&#x2F;保留</td></tr></tbody></table><p><strong>Q2：子网掩码作用？</strong></p><ul><li>用于区分网络号和主机号。</li><li>通过按位与运算确定同一网段内主机。</li><li>面试问法：给 IP&#x2F;子网掩码计算可用主机数或广播地址。</li></ul><p><strong>Q3：RIP vs OSPF</strong></p><table><thead><tr><th>特性</th><th>RIP</th><th>OSPF</th></tr></thead><tbody><tr><td>类型</td><td>距离矢量</td><td>链路状态</td></tr><tr><td>收敛速度</td><td>慢</td><td>快</td></tr><tr><td>度量</td><td>跳数</td><td>带宽&#x2F;延迟</td></tr><tr><td>缺点</td><td>路径可能环路</td><td>配置复杂</td></tr><tr><td><strong>面试要点</strong>：RIP 简单、适合小网络；OSPF 复杂、适合大型网络。</td><td></td><td></td></tr></tbody></table><hr><h2 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4. 传输层"></a>4. 传输层</h2><p><strong>Q1：TCP&#x2F;UDP 区别</strong><br> 详见上条回答。</p><p><strong>Q2：三次握手流程</strong><br> 详见上条回答，可画图辅助说明。</p><p><strong>Q3：滑动窗口原理</strong></p><ul><li>TCP 使用滑动窗口进行流量控制。</li><li><strong>发送方</strong>可发送窗口大小内的数据而不必等待 ACK。</li><li><strong>接收方</strong>通过窗口大小告知可接收缓冲区容量。</li><li><strong>好处</strong>：提高链路利用率，避免频繁等待确认。</li><li>面试问法：滑动窗口与停止等待区别？答案：滑动窗口一次可发送多段，停止等待一次只能发送一段。</li></ul><hr><h2 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5. 会话层"></a>5. 会话层</h2><p><strong>Q1：HTTP 无状态如何实现会话保持？</strong></p><ul><li>HTTP 本身无状态，每次请求独立。</li><li><strong>实现方式</strong>：<ol><li><strong>Cookie</strong>：客户端保存会话 ID，随请求发送。</li><li><strong>Session</strong>：服务端保存用户状态，客户端发送标识。</li><li><strong>Token&#x2F;JWT</strong>：无状态方式，将用户信息加密放在客户端。</li></ol></li></ul><hr><h2 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6. 表示层"></a>6. 表示层</h2><p><strong>Q1：编码转换</strong></p><ul><li>ASCII、UTF-8、Unicode 等，用于不同系统间字符表示兼容。</li><li>面试问法：中文 UTF-8 编码占多少字节？<br> <strong>答案</strong>：汉字 3 字节，英文 1 字节。</li></ul><p><strong>Q2：大端小端</strong></p><ul><li><strong>大端</strong>（Big Endian）：高位字节存放在低地址。</li><li><strong>小端</strong>（Little Endian）：低位字节存放在低地址。</li><li>面试问法：网络传输使用哪种？<br> <strong>答案</strong>：大端（网络字节序）。</li></ul><p><strong>Q3：TLS 加密流程</strong></p><ol><li>客户端发送 ClientHello（支持加密算法）。</li><li>服务器返回 ServerHello，发送证书。</li><li>客户端验证证书，生成会话密钥。</li><li>双方用会话密钥加密通信。</li></ol><ul><li>面试要点：讲清楚“证书验证”和“对称密钥加密数据”。</li></ul><hr><h2 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7. 应用层"></a>7. 应用层</h2><p><strong>Q1：HTTP 状态码</strong></p><table><thead><tr><th>类型</th><th>示例</th><th>含义</th></tr></thead><tbody><tr><td>1xx</td><td>100 Continue</td><td>信息性响应</td></tr><tr><td>2xx</td><td>200 OK</td><td>成功</td></tr><tr><td>3xx</td><td>301 Moved Permanently</td><td>重定向</td></tr><tr><td>4xx</td><td>404 Not Found</td><td>客户端错误</td></tr><tr><td>5xx</td><td>500 Internal Server Error</td><td>服务器错误</td></tr></tbody></table><p><strong>Q2：FTP 主动&#x2F;被动模式</strong></p><ul><li><strong>主动模式</strong>：客户端建立控制连接，服务器主动建立数据连接。</li><li><strong>被动模式</strong>：客户端建立控制连接和数据连接，服务器被动监听。</li><li>面试要点：被动模式用于客户端在防火墙后的情况。</li></ul><p><strong>Q3：DNS 查询过程</strong></p><ol><li>客户端向本地 DNS 发起递归查询。</li><li>本地 DNS 如果缓存没有，向根 DNS 查询 → 顶级域 → 权威 DNS。</li><li>权威 DNS 返回解析结果到本地 DNS，本地返回给客户端。</li></ol><ul><li>面试要点：递归查询 vs 迭代查询区别。</li></ul><hr><hr><h2 id="一、前后端交互的基本流程"><a href="#一、前后端交互的基本流程" class="headerlink" title="一、前后端交互的基本流程"></a><strong>一、前后端交互的基本流程</strong></h2><ol><li><strong>前端发起请求</strong><ul><li>用户在浏览器或客户端操作，比如点击按钮、提交表单。</li><li>前端通过 HTTP&#x2F;HTTPS 或 WebSocket 向后端发送请求。</li><li>请求包含：URL、请求方法（GET&#x2F;POST&#x2F;PUT&#x2F;DELETE 等）、请求头（Header）、请求体（Body，POST&#x2F;PUT 时）和参数。</li></ul></li><li><strong>后端接收请求</strong><ul><li>后端服务器（如 Java&#x2F;Spring、Node.js、Python Flask&#x2F;Django）解析请求。</li><li>后端根据 URL 路径、HTTP 方法匹配路由到对应的处理函数（Controller&#x2F;Handler）。</li></ul></li><li><strong>后端处理请求</strong><ul><li>后端进行业务逻辑处理：<ul><li>数据库查询&#x2F;更新（CRUD）</li><li>调用其他服务或 API</li><li>数据验证、权限校验</li></ul></li><li>处理完成后，生成响应数据（通常为 JSON、XML、HTML 或二进制文件）。</li></ul></li><li><strong>后端返回响应</strong><ul><li>响应包含：状态码（HTTP Status Code）、响应头、响应体（Body）。</li><li>状态码示例：<ul><li>200 OK：请求成功</li><li>201 Created：资源创建成功</li><li>400 Bad Request：请求错误</li><li>401 Unauthorized：未授权</li><li>500 Internal Server Error：服务器错误</li></ul></li></ul></li><li><strong>前端接收响应</strong><ul><li>前端根据状态码判断请求结果。</li><li>前端解析响应体并更新界面（UI），例如渲染数据表格、显示提示信息。</li><li>如果是异步请求（AJAX&#x2F;Fetch&#x2F;axios），前端可以在回调或 Promise 中处理响应。</li></ul></li></ol><hr><h2 id="二、前后端交互方式"><a href="#二、前后端交互方式" class="headerlink" title="二、前后端交互方式"></a><strong>二、前后端交互方式</strong></h2><h3 id="1-HTTP-请求-响应模式"><a href="#1-HTTP-请求-响应模式" class="headerlink" title="1. HTTP 请求-响应模式"></a>1. <strong>HTTP 请求-响应模式</strong></h3><ul><li><strong>同步请求</strong>（传统表单提交）：浏览器提交表单，等待响应页面刷新。</li><li><strong>异步请求</strong>（AJAX&#x2F;Fetch&#x2F;axios）：页面不刷新，通过 JavaScript 异步获取数据。</li></ul><h3 id="2-WebSocket-实时通信"><a href="#2-WebSocket-实时通信" class="headerlink" title="2. WebSocket 实时通信"></a>2. <strong>WebSocket 实时通信</strong></h3><ul><li>前端与后端建立长连接。</li><li>可以实时双向通信，不需要每次都发 HTTP 请求。</li><li>适用场景：聊天应用、在线游戏、实时监控。</li></ul><h3 id="3-Server-Sent-Events（SSE）"><a href="#3-Server-Sent-Events（SSE）" class="headerlink" title="3. Server-Sent Events（SSE）"></a>3. <strong>Server-Sent Events（SSE）</strong></h3><ul><li>后端主动向前端推送事件流。</li><li>单向通信（后端 → 前端）。</li><li>适用于消息通知、实时数据更新。</li></ul><h3 id="4-GraphQL"><a href="#4-GraphQL" class="headerlink" title="4. GraphQL"></a>4. <strong>GraphQL</strong></h3><ul><li>前端发送一个查询请求，后端根据查询返回精确的数据。</li><li>相比 REST，可以减少冗余数据传输。</li></ul><hr><h2 id="三、前后端响应示例"><a href="#三、前后端响应示例" class="headerlink" title="三、前后端响应示例"></a><strong>三、前后端响应示例</strong></h2><p><strong>前端（JavaScript fetch）</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/users&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;网络错误&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;用户数据:&quot;</span>, data);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;请求失败:&quot;</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>后端（Node.js&#x2F;Express）</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/users&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> users = [</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(users);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>前端发起 GET 请求 → 后端返回 JSON → 前端解析 JSON 更新页面。</li></ul><hr><h2 id="四、状态码与响应流程"><a href="#四、状态码与响应流程" class="headerlink" title="四、状态码与响应流程"></a><strong>四、状态码与响应流程</strong></h2><table><thead><tr><th>状态码</th><th>含义</th><th>前端处理方式</th></tr></thead><tbody><tr><td>200 OK</td><td>请求成功</td><td>解析数据更新 UI</td></tr><tr><td>201 Created</td><td>资源创建成功</td><td>可以跳转或提示成功</td></tr><tr><td>400 Bad Request</td><td>请求参数错误</td><td>提示用户检查输入</td></tr><tr><td>401 Unauthorized</td><td>未授权</td><td>跳转登录页或请求授权</td></tr><tr><td>404 Not Found</td><td>资源不存在</td><td>显示 404 页面</td></tr><tr><td>500 Internal Server Error</td><td>后端错误</td><td>显示错误提示或重试</td></tr></tbody></table><hr><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>好的，我来给你整理一份 <strong>Linux 常见知识点清单</strong>，涵盖基础命令、系统管理、权限、网络、进程、文件系统等方面，适合面试或日常运维参考。我会按模块整理，并给出重点说明。</p><hr><h2 id="一、基础命令"><a href="#一、基础命令" class="headerlink" title="一、基础命令"></a><strong>一、基础命令</strong></h2><h3 id="1-文件和目录操作"><a href="#1-文件和目录操作" class="headerlink" title="1. 文件和目录操作"></a>1. 文件和目录操作</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>ls</code></td><td>列出目录内容</td></tr><tr><td><code>cd</code></td><td>切换目录</td></tr><tr><td><code>pwd</code></td><td>查看当前路径</td></tr><tr><td><code>mkdir</code></td><td>创建目录</td></tr><tr><td><code>rm</code></td><td>删除文件&#x2F;目录（<code>-r</code>递归）</td></tr><tr><td><code>cp</code></td><td>复制文件&#x2F;目录</td></tr><tr><td><code>mv</code></td><td>移动或重命名</td></tr><tr><td><code>find</code></td><td>查找文件</td></tr><tr><td><code>locate</code></td><td>快速查找文件（需更新索引）</td></tr></tbody></table><h3 id="2-文件查看与编辑"><a href="#2-文件查看与编辑" class="headerlink" title="2. 文件查看与编辑"></a>2. 文件查看与编辑</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>cat</code></td><td>查看文件内容</td></tr><tr><td><code>less</code> &#x2F; <code>more</code></td><td>分页浏览</td></tr><tr><td><code>head</code> &#x2F; <code>tail</code></td><td>查看开头&#x2F;结尾行</td></tr><tr><td><code>grep</code></td><td>文件内容搜索</td></tr><tr><td><code>wc</code></td><td>统计行数、字数、字符数</td></tr><tr><td><code>vim</code> &#x2F; <code>nano</code></td><td>文本编辑</td></tr></tbody></table><hr><h2 id="二、用户与权限管理"><a href="#二、用户与权限管理" class="headerlink" title="二、用户与权限管理"></a><strong>二、用户与权限管理</strong></h2><h3 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1. 用户管理"></a>1. 用户管理</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>useradd</code></td><td>添加用户</td></tr><tr><td><code>usermod</code></td><td>修改用户</td></tr><tr><td><code>passwd</code></td><td>修改用户密码</td></tr><tr><td><code>userdel</code></td><td>删除用户</td></tr><tr><td><code>id</code></td><td>查看用户信息</td></tr></tbody></table><h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2. 权限管理"></a>2. 权限管理</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>chmod</code></td><td>修改文件权限（数字&#x2F;符号模式）</td></tr><tr><td><code>chown</code></td><td>修改文件所有者</td></tr><tr><td><code>chgrp</code></td><td>修改文件所属组</td></tr><tr><td><code>umask</code></td><td>设置默认权限掩码</td></tr><tr><td><code>sudo</code></td><td>提权执行命令</td></tr></tbody></table><hr><h2 id="三、进程管理"><a href="#三、进程管理" class="headerlink" title="三、进程管理"></a><strong>三、进程管理</strong></h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>ps</code></td><td>查看进程</td></tr><tr><td><code>top</code> &#x2F; <code>htop</code></td><td>动态查看进程和资源</td></tr><tr><td><code>kill</code> &#x2F; <code>killall</code></td><td>结束进程</td></tr><tr><td><code>nice</code> &#x2F; <code>renice</code></td><td>设置进程优先级</td></tr><tr><td><code>jobs</code> &#x2F; <code>fg</code> &#x2F; <code>bg</code></td><td>作业控制（后台&#x2F;前台）</td></tr></tbody></table><hr><h2 id="四、网络管理"><a href="#四、网络管理" class="headerlink" title="四、网络管理"></a><strong>四、网络管理</strong></h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>ifconfig</code> &#x2F; <code>ip addr</code></td><td>查看网卡IP信息</td></tr><tr><td><code>ping</code></td><td>测试网络连通性</td></tr><tr><td><code>traceroute</code> &#x2F; <code>tracepath</code></td><td>路由跟踪</td></tr><tr><td><code>netstat</code> &#x2F; <code>ss</code></td><td>查看端口&#x2F;连接信息</td></tr><tr><td><code>curl</code> &#x2F; <code>wget</code></td><td>下载文件或访问URL</td></tr><tr><td><code>scp</code> &#x2F; <code>rsync</code></td><td>远程复制文件</td></tr><tr><td><code>iptables</code> &#x2F; <code>firewalld</code></td><td>防火墙管理</td></tr></tbody></table><hr><h2 id="五、包管理"><a href="#五、包管理" class="headerlink" title="五、包管理"></a><strong>五、包管理</strong></h2><ul><li><strong>Debian&#x2F;Ubuntu 系列</strong>：<ul><li><code>apt update</code> &#x2F; <code>apt upgrade</code></li><li><code>apt install &lt;package&gt;</code> &#x2F; <code>apt remove &lt;package&gt;</code></li></ul></li><li><strong>RedHat&#x2F;CentOS 系列</strong>：<ul><li><code>yum install &lt;package&gt;</code> &#x2F; <code>yum remove &lt;package&gt;</code></li><li><code>dnf</code>（新版本替代 yum）</li></ul></li></ul><hr><h2 id="六、磁盘与文件系统管理"><a href="#六、磁盘与文件系统管理" class="headerlink" title="六、磁盘与文件系统管理"></a><strong>六、磁盘与文件系统管理</strong></h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>df -h</code></td><td>查看磁盘空间</td></tr><tr><td><code>du -h</code></td><td>查看目录&#x2F;文件大小</td></tr><tr><td><code>mount</code> &#x2F; <code>umount</code></td><td>挂载&#x2F;卸载分区</td></tr><tr><td><code>lsblk</code></td><td>查看磁盘分区</td></tr><tr><td><code>fdisk</code> &#x2F; <code>parted</code></td><td>分区管理</td></tr><tr><td><code>mkfs</code></td><td>格式化文件系统</td></tr><tr><td><code>fsck</code></td><td>检查文件系统</td></tr></tbody></table><hr><h2 id="七、日志管理"><a href="#七、日志管理" class="headerlink" title="七、日志管理"></a><strong>七、日志管理</strong></h2><table><thead><tr><th>文件&#x2F;命令</th><th>功能</th></tr></thead><tbody><tr><td><code>/var/log/messages</code></td><td>系统日志</td></tr><tr><td><code>/var/log/syslog</code></td><td>系统事件</td></tr><tr><td><code>/var/log/auth.log</code></td><td>用户登录与认证</td></tr><tr><td><code>journalctl</code></td><td>查看 systemd 日志</td></tr><tr><td><code>dmesg</code></td><td>查看内核启动和硬件日志</td></tr></tbody></table><hr><h2 id="八、系统管理"><a href="#八、系统管理" class="headerlink" title="八、系统管理"></a><strong>八、系统管理</strong></h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>uptime</code></td><td>系统运行时间</td></tr><tr><td><code>uname -a</code></td><td>系统信息</td></tr><tr><td><code>free -h</code></td><td>内存使用</td></tr><tr><td><code>vmstat</code></td><td>系统资源统计</td></tr><tr><td><code>df -h</code></td><td>磁盘使用情况</td></tr><tr><td><code>systemctl</code></td><td>管理服务（启动&#x2F;停止&#x2F;重启）</td></tr><tr><td><code>crontab</code></td><td>定时任务管理</td></tr></tbody></table><hr><h2 id="九、压缩与解压"><a href="#九、压缩与解压" class="headerlink" title="九、压缩与解压"></a><strong>九、压缩与解压</strong></h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>tar -cvf</code> &#x2F; <code>tar -xvf</code></td><td>打包&#x2F;解包</td></tr><tr><td><code>gzip</code> &#x2F; <code>gunzip</code></td><td>压缩&#x2F;解压</td></tr><tr><td><code>zip</code> &#x2F; <code>unzip</code></td><td>压缩&#x2F;解压</td></tr></tbody></table><hr><h2 id="十、Shell-脚本基础（详细版）"><a href="#十、Shell-脚本基础（详细版）" class="headerlink" title="十、Shell 脚本基础（详细版）"></a><strong>十、Shell 脚本基础（详细版）</strong></h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><ul><li><strong>定义变量</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME=<span class="string">&quot;Charlotte&quot;</span></span><br><span class="line">AGE=25</span><br></pre></td></tr></table></figure><ul><li><strong>访问变量</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$NAME</span></span><br></pre></td></tr></table></figure><ul><li><strong>只读变量</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">readonly</span> NAME</span><br></pre></td></tr></table></figure><ul><li><strong>环境变量</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/new/path</span><br></pre></td></tr></table></figure><hr><h3 id="2-条件判断"><a href="#2-条件判断" class="headerlink" title="2. 条件判断"></a>2. 条件判断</h3><ul><li><strong>if 语句</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$AGE</span> -ge 18 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;成年人&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;未成年人&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li><strong>常用条件表达式</strong>：<table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>等于</td></tr><tr><td><code>-ne</code></td><td>不等于</td></tr><tr><td><code>-gt</code></td><td>大于</td></tr><tr><td><code>-lt</code></td><td>小于</td></tr><tr><td><code>-ge</code></td><td>大于等于</td></tr><tr><td><code>-le</code></td><td>小于等于</td></tr><tr><td><code>-f filename</code></td><td>文件存在且为普通文件</td></tr><tr><td><code>-d dirname</code></td><td>目录存在</td></tr><tr><td><code>-x filename</code></td><td>可执行文件</td></tr></tbody></table></li></ul><hr><h3 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3. 循环语句"></a>3. 循环语句</h3><ul><li><strong>for 循环</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 1 2 3 4 5; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第 <span class="variable">$i</span> 次循环&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li><strong>while 循环</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;计数 <span class="variable">$count</span>&quot;</span></span><br><span class="line">    count=$((count+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li><strong>until 循环</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count=1</span><br><span class="line"><span class="keyword">until</span> [ <span class="variable">$count</span> -gt 5 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;计数 <span class="variable">$count</span>&quot;</span></span><br><span class="line">    count=$((count+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">greet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet <span class="string">&quot;Charlotte&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>$1</code> 表示函数传入的第一个参数</li><li><code>$@</code> 表示所有参数</li><li><code>return</code> 返回状态码（0表示成功，非0表示失败）</li></ul><hr><h3 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5. 输入输出"></a>5. 输入输出</h3><ul><li><strong>标准输入&#x2F;输出&#x2F;错误</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span>         <span class="comment"># stdout</span></span><br><span class="line"><span class="built_in">read</span> name            <span class="comment"># stdin</span></span><br><span class="line"><span class="built_in">ls</span> nonexist 2&gt; error.log  <span class="comment"># stderr重定向</span></span><br></pre></td></tr></table></figure><ul><li><strong>管道与重定向</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file.txt | grep <span class="string">&quot;hello&quot;</span> &gt; result.txt</span><br></pre></td></tr></table></figure><hr><h3 id="6-脚本执行权限"><a href="#6-脚本执行权限" class="headerlink" title="6. 脚本执行权限"></a>6. 脚本执行权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x script.sh</span><br><span class="line">./script.sh</span><br></pre></td></tr></table></figure><hr><h3 id="7-实用示例"><a href="#7-实用示例" class="headerlink" title="7. 实用示例"></a>7. 实用示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 统计当前目录下所有文件数</span></span><br><span class="line">count=$(<span class="built_in">ls</span> -l | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前目录文件数量: <span class="variable">$count</span>&quot;</span></span><br></pre></td></tr></table></figure><hr><h1 id="十一、Linux-面试常问知识点（全面版）"><a href="#十一、Linux-面试常问知识点（全面版）" class="headerlink" title="十一、Linux 面试常问知识点（全面版）"></a><strong>十一、Linux 面试常问知识点（全面版）</strong></h1><hr><h2 id="1-文件权限与权限管理"><a href="#1-文件权限与权限管理" class="headerlink" title="1. 文件权限与权限管理"></a><strong>1. 文件权限与权限管理</strong></h2><h3 id="核心知识点："><a href="#核心知识点：" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul><li><strong>权限类型</strong>：读（r）、写（w）、执行（x）</li><li><strong>三类用户</strong>：<ul><li>拥有者（u）</li><li>用户组（g）</li><li>其他用户（o）</li></ul></li><li><strong>权限表示</strong>：<ul><li>符号表示法：<code>rwxr-xr-x</code></li><li>数字表示法：<code>chmod 755 file</code> → 7&#x3D;rw, x; 5&#x3D;r-x; 5&#x3D;r-x</li></ul></li></ul><h3 id="面试常问问题："><a href="#面试常问问题：" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol><li><p><strong>命令 chmod、chown、chgrp 有什么作用？</strong></p><ul><li><code>chmod</code>：修改权限</li><li><code>chown</code>：修改文件所有者</li><li><code>chgrp</code>：修改文件所属组</li></ul></li><li><p><strong>硬链接和软链接区别？</strong></p><table><thead><tr><th>项目</th><th>硬链接</th><th>软链接</th></tr></thead><tbody><tr><td>inode</td><td>相同</td><td>不同</td></tr><tr><td>跨分区</td><td>不行</td><td>可以</td></tr><tr><td>删除原文件</td><td>内容仍存在</td><td>链接失效</td></tr><tr><td>命令</td><td><code>ln source target</code></td><td><code>ln -s source target</code></td></tr></tbody></table></li><li><p><strong>文件描述符和重定向</strong></p><ul><li><code>0</code> stdin, <code>1</code> stdout, <code>2</code> stderr</li><li>示例：<code>command &gt; out.log 2&gt;&amp;1</code> → stdout 和 stderr 都写入 out.log</li></ul></li></ol><hr><h2 id="2-进程与作业管理"><a href="#2-进程与作业管理" class="headerlink" title="2. 进程与作业管理"></a><strong>2. 进程与作业管理</strong></h2><h3 id="核心知识点：-1"><a href="#核心知识点：-1" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul><li><strong>查看进程</strong>：<ul><li><code>ps aux</code>、<code>top</code>、<code>htop</code></li></ul></li><li><strong>结束进程</strong>：<ul><li><code>kill PID</code>、<code>kill -9 PID</code>、<code>killall process_name</code></li></ul></li><li><strong>后台&#x2F;前台任务</strong>：<ul><li><code>&amp;</code>：后台执行</li><li><code>jobs</code>：查看后台任务</li><li><code>fg %1</code>：切换到前台</li></ul></li><li><strong>优先级</strong>：<ul><li><code>nice</code>、<code>renice</code> 设置 CPU 优先级</li></ul></li></ul><h3 id="面试常问问题：-1"><a href="#面试常问问题：-1" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol><li><p><strong>如何查看端口被哪个进程占用？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :8080</span><br><span class="line">netstat -tulpn | grep 8080</span><br><span class="line">ss -tulpn | grep 8080</span><br></pre></td></tr></table></figure></li><li><p><strong>如何终止占用端口的进程？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="3-文件系统与磁盘管理"><a href="#3-文件系统与磁盘管理" class="headerlink" title="3. 文件系统与磁盘管理"></a><strong>3. 文件系统与磁盘管理</strong></h2><h3 id="核心知识点：-2"><a href="#核心知识点：-2" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul><li><code>df -h</code> 查看磁盘空间</li><li><code>du -h</code> 查看目录大小</li><li><code>lsblk</code> 查看分区信息</li><li><code>mount / umount</code> 挂载卸载</li><li><code>fdisk / parted</code> 分区</li><li><code>mkfs</code> 格式化文件系统</li><li><code>fsck</code> 检查文件系统</li></ul><h3 id="面试常问问题：-2"><a href="#面试常问问题：-2" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol><li><p><strong>硬链接和软链接在文件系统中有什么区别？</strong></p></li><li><p><strong>如何查看磁盘空间和使用情况？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="built_in">du</span> -sh /path/to/dir</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="4-网络管理"><a href="#4-网络管理" class="headerlink" title="4. 网络管理"></a><strong>4. 网络管理</strong></h2><h3 id="核心知识点：-3"><a href="#核心知识点：-3" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul><li>查看 IP 地址：<code>ifconfig</code> &#x2F; <code>ip addr</code></li><li>测试连通性：<code>ping</code></li><li>路由追踪：<code>traceroute</code> &#x2F; <code>tracepath</code></li><li>查看端口和连接：<code>netstat</code> &#x2F; <code>ss</code></li><li>下载文件或请求 URL：<code>wget</code> &#x2F; <code>curl</code></li><li>远程文件传输：<code>scp</code> &#x2F; <code>rsync</code></li></ul><h3 id="面试常问问题：-3"><a href="#面试常问问题：-3" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol><li><p><strong>如何查看网卡信息？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure></li><li><p><strong>如何调试网络连通性？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 8.8.8.8</span><br><span class="line">traceroute www.baidu.com</span><br></pre></td></tr></table></figure></li><li><p><strong>如何查看 8080 端口占用？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tulpn | grep 8080</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="5-用户与组管理"><a href="#5-用户与组管理" class="headerlink" title="5. 用户与组管理"></a><strong>5. 用户与组管理</strong></h2><h3 id="核心知识点：-4"><a href="#核心知识点：-4" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul><li>添加用户：<code>useradd</code></li><li>删除用户：<code>userdel</code></li><li>修改用户：<code>usermod -aG group user</code></li><li>修改密码：<code>passwd user</code></li><li>查看组信息：<code>groups user</code></li><li>提权命令：<code>sudo command</code></li></ul><h3 id="面试常问问题：-4"><a href="#面试常问问题：-4" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol><li><p><strong>如何给用户加入某个组？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG dev user</span><br></pre></td></tr></table></figure></li><li><p><strong>如何限制用户权限？</strong></p><ul><li>使用 <code>chmod</code> 设置文件权限</li><li>使用 <code>sudoers</code> 配置命令权限</li></ul></li></ol><hr><h2 id="6-Shell-脚本基础"><a href="#6-Shell-脚本基础" class="headerlink" title="6. Shell 脚本基础"></a><strong>6. Shell 脚本基础</strong></h2><h3 id="核心知识点：-5"><a href="#核心知识点：-5" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul><li>变量、条件判断、循环、函数</li><li>管道、重定向、标准输入输出</li><li>常用脚本示例：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *.<span class="built_in">log</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;处理文件: <span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="面试常问问题：-5"><a href="#面试常问问题：-5" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol><li><strong>如何判断文件是否存在？</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;/path/to/file&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件存在&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ol><li><strong>如何统计目录下文件数量？</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count=$(<span class="built_in">ls</span> -l | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$count</span></span><br></pre></td></tr></table></figure><hr><h2 id="7-定时任务（Crontab）"><a href="#7-定时任务（Crontab）" class="headerlink" title="7. 定时任务（Crontab）"></a><strong>7. 定时任务（Crontab）</strong></h2><h3 id="核心知识点：-6"><a href="#核心知识点：-6" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul><li>查看：<code>crontab -l</code></li><li>编辑：<code>crontab -e</code></li><li>时间格式：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">command</span></span><br><span class="line">分 时 日 月 星期</span><br></pre></td></tr></table></figure><ul><li>示例：每天凌晨 2 点备份</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 * * * /home/user/backup.sh</span><br></pre></td></tr></table></figure><hr><h2 id="8-系统日志"><a href="#8-系统日志" class="headerlink" title="8. 系统日志"></a><strong>8. 系统日志</strong></h2><h3 id="核心知识点：-7"><a href="#核心知识点：-7" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul><li>常用日志路径：<table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td><code>/var/log/messages</code></td><td>系统事件</td></tr><tr><td><code>/var/log/syslog</code></td><td>系统服务日志</td></tr><tr><td><code>/var/log/auth.log</code></td><td>登录&#x2F;认证日志</td></tr><tr><td><code>/var/log/kern.log</code></td><td>内核日志</td></tr><tr><td><code>journalctl</code></td><td>systemd 日志</td></tr></tbody></table></li><li>查看日志：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/syslog</span><br><span class="line">journalctl -xe</span><br></pre></td></tr></table></figure><hr><h2 id="9-系统管理"><a href="#9-系统管理" class="headerlink" title="9. 系统管理"></a><strong>9. 系统管理</strong></h2><h3 id="核心知识点：-8"><a href="#核心知识点：-8" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul><li>系统信息：<code>uname -a</code></li><li>内存查看：<code>free -h</code></li><li>CPU&#x2F;资源统计：<code>top</code> &#x2F; <code>vmstat</code></li><li>服务管理：<code>systemctl start/stop/restart/status service</code></li><li>系统启动流程：BIOS → Bootloader → Kernel → init&#x2F;systemd → 多用户模式</li></ul><h3 id="面试常问问题：-6"><a href="#面试常问问题：-6" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol><li><strong>如何查看系统运行时间？</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shelluptime</span><br></pre></td></tr></table></figure><ol><li><strong>如何管理系统服务？</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br><span class="line">systemctl enable nginx</span><br><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><hr><h2 id="10-综合示例（面试题）"><a href="#10-综合示例（面试题）" class="headerlink" title="10. 综合示例（面试题）"></a><strong>10. 综合示例（面试题）</strong></h2><ol><li><strong>如何查找占用 CPU 前 5 的进程？</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux --sort=-%cpu | head -n 6</span><br></pre></td></tr></table></figure><p>   2.<strong>如何查找 1 小时内修改过的文件？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/dir -type f -mmin -60</span><br></pre></td></tr></table></figure><p>   3.<strong>如何将错误日志和输出日志写入同一个文件？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt; all.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>   4.<strong>如何给用户添加 sudo 权限？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG sudo username</span><br></pre></td></tr></table></figure><hr><h1 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h1><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><h2 id="1-DML-Data-Manipulation-Language-—-数据操作"><a href="#1-DML-Data-Manipulation-Language-—-数据操作" class="headerlink" title="1. DML (Data Manipulation Language) — 数据操作"></a>1. DML (Data Manipulation Language) — 数据操作</h2><p>用于操作数据库中的数据。</p><h3 id="1-1-SELECT-查询"><a href="#1-1-SELECT-查询" class="headerlink" title="1.1 SELECT 查询"></a>1.1 SELECT 查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查询指定列，并对结果排序、分页</span><br><span class="line">SELECT column1, column2</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE condition         -- 过滤条件</span><br><span class="line">ORDER BY column DESC    -- 按列排序，可 ASC 或 DESC</span><br><span class="line">LIMIT offset, count;    -- 分页查询，offset: 偏移量, count: 返回行数</span><br></pre></td></tr></table></figure><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*), SUM(column), AVG(column), MAX(column), MIN(column)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column, COUNT(*)</span><br><span class="line">FROM table_name</span><br><span class="line">GROUP BY column       -- 按 column 分组</span><br><span class="line">HAVING COUNT(*) &gt; 1; -- 分组过滤</span><br></pre></td></tr></table></figure><h4 id="联接查询-JOIN"><a href="#联接查询-JOIN" class="headerlink" title="联接查询 (JOIN)"></a>联接查询 (JOIN)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-- 内连接，只返回两个表中匹配的行</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">INNER JOIN table_b b ON a.id = b.a_id;</span><br><span class="line"></span><br><span class="line">-- 左连接，返回左表所有行及匹配右表的行</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">LEFT JOIN table_b b ON a.id = b.a_id;</span><br><span class="line"></span><br><span class="line">-- 右连接，返回右表所有行及匹配左表的行</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">RIGHT JOIN table_b b ON a.id = b.a_id;</span><br><span class="line"></span><br><span class="line">-- 全连接 (MySQL 不直接支持，用 UNION ALL 模拟)</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">LEFT JOIN table_b b ON a.id = b.a_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">RIGHT JOIN table_b b ON a.id = b.a_id</span><br><span class="line">WHERE a.id IS NULL;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-INSERT-插入"><a href="#1-2-INSERT-插入" class="headerlink" title="1.2 INSERT 插入"></a>1.2 INSERT 插入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 指定列插入</span><br><span class="line">INSERT INTO table_name (column1, column2)</span><br><span class="line">VALUES (value1, value2);</span><br><span class="line"></span><br><span class="line">-- 插入所有列</span><br><span class="line">INSERT INTO table_name</span><br><span class="line">VALUES (value1, value2, ...);</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-UPDATE-更新"><a href="#1-3-UPDATE-更新" class="headerlink" title="1.3 UPDATE 更新"></a>1.3 UPDATE 更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET column1 = value1,</span><br><span class="line">    column2 = value2</span><br><span class="line">WHERE condition;  -- 必须加 WHERE，否则会更新所有行</span><br></pre></td></tr></table></figure><hr><h3 id="1-4-DELETE-删除"><a href="#1-4-DELETE-删除" class="headerlink" title="1.4 DELETE 删除"></a>1.4 DELETE 删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE condition; -- 不加 WHERE 会删除所有行，比 TRUNCATE TABLE 慢</span><br></pre></td></tr></table></figure><hr><h2 id="2-DDL-Data-Definition-Language-—-数据定义"><a href="#2-DDL-Data-Definition-Language-—-数据定义" class="headerlink" title="2. DDL (Data Definition Language) — 数据定义"></a>2. DDL (Data Definition Language) — 数据定义</h2><p>用于创建、修改和删除数据库对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE database_name;</span><br><span class="line"></span><br><span class="line">-- 创建表</span><br><span class="line">CREATE TABLE table_name (</span><br><span class="line">    column1 datatype constraints,</span><br><span class="line">    column2 datatype constraints,</span><br><span class="line">    PRIMARY KEY (column_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 修改表结构</span><br><span class="line">ALTER TABLE table_name ADD column_name datatype;</span><br><span class="line">ALTER TABLE table_name DROP COLUMN column_name;</span><br><span class="line">ALTER TABLE table_name MODIFY COLUMN column_name datatype;</span><br><span class="line"></span><br><span class="line">-- 删除表</span><br><span class="line">DROP TABLE table_name;</span><br><span class="line"></span><br><span class="line">-- 索引操作</span><br><span class="line">CREATE INDEX index_name ON table_name (column_name);</span><br><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><hr><h2 id="3-DCL-Data-Control-Language-—-数据权限控制"><a href="#3-DCL-Data-Control-Language-—-数据权限控制" class="headerlink" title="3. DCL (Data Control Language) — 数据权限控制"></a>3. DCL (Data Control Language) — 数据权限控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 授权</span><br><span class="line">GRANT privileges ON database.table TO &#x27;user&#x27;@&#x27;host&#x27;;</span><br><span class="line"></span><br><span class="line">-- 撤销权限</span><br><span class="line">REVOKE privileges ON database.table FROM &#x27;user&#x27;@&#x27;host&#x27;;</span><br></pre></td></tr></table></figure><hr><h2 id="4-TCL-Transaction-Control-Language-—-事务控制"><a href="#4-TCL-Transaction-Control-Language-—-事务控制" class="headerlink" title="4. TCL (Transaction Control Language) — 事务控制"></a>4. TCL (Transaction Control Language) — 事务控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION; -- 或 BEGIN;</span><br><span class="line"></span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 回滚事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 设置保存点</span><br><span class="line">SAVEPOINT savepoint_name;</span><br></pre></td></tr></table></figure><hr><h2 id="5-EXPLAIN-查询分析-—-SQL-优化核心工具"><a href="#5-EXPLAIN-查询分析-—-SQL-优化核心工具" class="headerlink" title="5. EXPLAIN 查询分析 — SQL 优化核心工具"></a>5. EXPLAIN 查询分析 — SQL 优化核心工具</h2><p>用于分析 SELECT（或 DML）语句的执行计划，判断是否使用索引，以及优化查询性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM table_name WHERE condition;</span><br></pre></td></tr></table></figure><h3 id="5-1-EXPLAIN-核心字段解析"><a href="#5-1-EXPLAIN-核心字段解析" class="headerlink" title="5.1 EXPLAIN 核心字段解析"></a>5.1 EXPLAIN 核心字段解析</h3><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>查询序列号，越大优先级越高；相同 id 按顺序执行。</td></tr><tr><td>select_type</td><td>查询类型：SIMPLE, PRIMARY, SUBQUERY, DEPENDENT SUBQUERY, UNION, DERIVED 等。</td></tr><tr><td>table</td><td>正在访问的表名。</td></tr><tr><td>partitions</td><td>匹配的分区信息（如果有分区表）。</td></tr><tr><td>type</td><td>连接类型&#x2F;访问方式，性能从好到差：system → const → eq_ref → ref → range → index → ALL。</td></tr><tr><td>possible_keys</td><td>查询可能使用的索引。</td></tr><tr><td>key</td><td>实际使用的索引，NULL 表示未使用索引。</td></tr><tr><td>key_len</td><td>使用的索引长度（字节），越短越好。</td></tr><tr><td>ref</td><td>表示索引列与哪个列或常量进行比较。</td></tr><tr><td>rows</td><td>MySQL 估计要扫描的行数，越少越好。</td></tr><tr><td>filtered</td><td>WHERE 条件过滤行的百分比，越高越好。</td></tr><tr><td>Extra</td><td>额外信息，重要优化指标：- <code>Using filesort</code>：需要额外排序。- <code>Using temporary</code>：需要临时表处理。- <code>Using index</code>：使用覆盖索引，查询效率高。- <code>Using where</code>：使用 WHERE 条件过滤。- <code>Using index condition</code>：索引条件下推（ICP）。- <code>Using join buffer</code>：连接查询未用索引，使用缓存优化。</td></tr></tbody></table><hr><h3 id="5-2-type-类型说明（访问方式）"><a href="#5-2-type-类型说明（访问方式）" class="headerlink" title="5.2 type 类型说明（访问方式）"></a>5.2 type 类型说明（访问方式）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">system  : 表中只有一行记录，性能极高</span><br><span class="line">const   : 通过主键或唯一索引查找，最多一行</span><br><span class="line">eq_ref   : 对前表每行组合读取一行，用于主键或唯一索引连接</span><br><span class="line">ref      : 非唯一索引等值查找，可能多行</span><br><span class="line">range    : 范围查找，使用索引</span><br><span class="line">index    : 全索引扫描，优于全表扫描</span><br><span class="line">ALL      : 全表扫描，性能最差</span><br></pre></td></tr></table></figure><hr><h3 id="5-3-优化建议"><a href="#5-3-优化建议" class="headerlink" title="5.3 优化建议"></a>5.3 优化建议</h3><ol><li>尽量使用索引，避免 <code>ALL</code> 类型。</li><li>ORDER BY &#x2F; GROUP BY 尽量使用索引列，避免 <code>Using filesort</code> 或 <code>Using temporary</code>。</li><li>覆盖索引（<code>Using index</code>）能显著提高性能。</li><li>对复杂查询，使用 EXPLAIN 分析并调整索引或 SQL 结构。</li><li>对 JOIN 查询，保证连接字段有索引。</li></ol><hr><h2 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务 (Transaction)"></a>事务 (Transaction)</h2><p>事务是一组操作的集合，这些操作要么全部成功，要么全部失败。它具有四大特性 (ACID)。</p><ul><li><strong>ACID 特性：</strong><ol><li><strong>原子性 (Atomicity)</strong>: 事务是最小的执行单位，不可再分割。事务中的所有操作要么全部成功提交，要么全部失败回滚到事务开始前的状态。</li><li><strong>一致性 (Consistency)</strong>: 事务执行前后，数据库的完整性约束 (如主键唯一性、外键约束、检查约束、自定义业务规则 ) 没有被破坏，数据从一个一致性状态转换到另一个一致性状态。</li><li><strong>隔离性 (Isolation)</strong>: 并发执行的事务之间是隔离的，一个事务的执行不应影响其他事务的执行，反之亦然。事务的中间状态对其他事务是不可见的。</li><li><strong>持久性 (Durability)</strong>: 一旦事务提交，它对数据库中数据的改变就是永久性的，即使系统崩溃也不会丢失。</li></ol></li><li><strong>并发事务带来的问题：</strong><ol><li><strong>脏读 (Dirty Read)</strong>: 一个事务读取了另一个未提交事务的数据。如果这个未提交事务最终回滚，那么之前读取的数据就是“脏数据”。</li><li><strong>不可重复读 (Non-Repeatable Read)</strong>：一个事务在两次相同的查询中，读取到了不同的数据。通常是因为另一个已提交事务对这些数据进行了 UPDATE 或 DELETE 操作。</li><li><strong>幻读 (Phantom Read)</strong>：一个事务在两次相同的查询中，读取到了不同数量的行。通常是因为另一个已提交事务对数据进行了 INSERT 操作，导致第二次查询出现了之前没有的行。</li><li><strong>丢失更新 (Lost Update)</strong>：当两个事务都读取同一数据并进行修改时，其中一个事务的修改覆盖了另一个事务的修改，导致数据丢失。</li></ol></li><li><strong>事务隔离级别 (从低到高)：</strong><ol><li><strong>READ UNCOMMITTED (读未提交)：</strong><ul><li>最低的隔离级别。</li><li>允许脏读、不可重复读和幻读。</li><li>性能最高，但数据一致性最差。</li></ul></li><li><strong>READ COMMITTED (读已提交)：</strong><ul><li>解决了脏读问题。一个事务只能看到其他事务已经提交的数据。</li><li>仍然存在不可重复读和幻读问题。</li><li>多数数据库 (如 Oracle, SQL Server) 的默认隔离级别。</li></ul></li><li><strong>REPEATABLE READ (可重复读)：</strong><ul><li>MySQL (InnoDB 存储引擎) 的默认隔离级别。</li><li>解决了脏读和不可重复读问题。在同一个事务中，多次读取同一数据会得到相同的结果 (通过 MVCC - 多版本并发控制)。</li><li>仍然可能存在幻读问题 (但在 InnoDB 默认隔离级别下，通过间隙锁解决了大部分幻读问题)。</li></ul></li><li><strong>SERIALIZABLE (串行化):</strong><ul><li>最高的隔离级别。</li><li>完全解决了脏读、不可重复读和幻读问题。</li><li>强制事务串行执行，避免所有并发问题。</li><li>性能最低，因为它牺牲了并发性。</li></ul></li></ol></li></ul><hr><h1 id="索引-Index"><a href="#索引-Index" class="headerlink" title="索引 (Index)"></a>索引 (Index)</h1><p>索引是帮助 MySQL 高效获取数据的数据结构。它类似于书籍的目录，可以快速定位所需数据，而无需扫描整个表。</p><hr><h2 id="1-索引的优缺点"><a href="#1-索引的优缺点" class="headerlink" title="1. 索引的优缺点"></a>1. 索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>加快数据检索速度</strong>：通过索引可以直接定位到数据，避免全表扫描。</li><li><strong>减少 I&#x2F;O 次数</strong>：索引结构比数据表小，减少磁盘访问。</li><li><strong>优化分组和排序</strong>：在 <code>GROUP BY</code> 和 <code>ORDER BY</code> 中，可减少 CPU 消耗。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>维护成本</strong>：数据增加、更新或删除时，索引也需要更新。</li><li><strong>占用存储空间</strong>：索引本身也需要占用磁盘。</li><li><strong>写入性能影响</strong>：虽然查询快，但对 <code>INSERT/UPDATE/DELETE</code> 有一定性能开销。</li></ul><hr><h2 id="2-索引底层实现-—-B-树"><a href="#2-索引底层实现-—-B-树" class="headerlink" title="2. 索引底层实现 — B+ 树"></a>2. 索引底层实现 — B+ 树</h2><h3 id="B-树特点"><a href="#B-树特点" class="headerlink" title="B+ 树特点"></a>B+ 树特点</h3><ul><li><strong>数据存储</strong>：所有数据都存储在叶子节点，非叶子节点仅存储键值用于导航。</li><li><strong>叶子节点链表</strong>：方便范围查询和顺序遍历。</li><li><strong>树层高低</strong>：非叶子节点不存储数据，一个节点可存储更多索引键，降低树高度，减少磁盘 I&#x2F;O。</li><li><strong>适合磁盘存储</strong>：节点大小匹配磁盘块大小，最大限度减少磁盘寻道次数。</li></ul><hr><h2 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3. 索引分类"></a>3. 索引分类</h2><h3 id="3-1-主键索引-Primary-Key-Index"><a href="#3-1-主键索引-Primary-Key-Index" class="headerlink" title="3.1 主键索引 (Primary Key Index)"></a>3.1 主键索引 (Primary Key Index)</h3><ul><li>特殊的唯一索引，一个表只能有一个主键。</li><li>不允许 <code>NULL</code> 值。</li><li>通常是 <strong>聚集索引</strong> (InnoDB 存储引擎)。</li></ul><h3 id="3-2-唯一索引-Unique-Index"><a href="#3-2-唯一索引-Unique-Index" class="headerlink" title="3.2 唯一索引 (Unique Index)"></a>3.2 唯一索引 (Unique Index)</h3><ul><li>列值必须唯一，但允许多个 <code>NULL</code> 值。</li><li>SQL 示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX idx_name ON table_name (column_name);</span><br></pre></td></tr></table></figure><h3 id="3-3-普通索引-Normal-Index-Non-Unique-Index"><a href="#3-3-普通索引-Normal-Index-Non-Unique-Index" class="headerlink" title="3.3 普通索引 (Normal Index &#x2F; Non-Unique Index)"></a>3.3 普通索引 (Normal Index &#x2F; Non-Unique Index)</h3><ul><li>最基本索引，没有唯一性限制。</li><li>SQL 示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON table_name (column_name);</span><br></pre></td></tr></table></figure><h3 id="3-4-全文索引-Fulltext-Index"><a href="#3-4-全文索引-Fulltext-Index" class="headerlink" title="3.4 全文索引 (Fulltext Index)"></a>3.4 全文索引 (Fulltext Index)</h3><ul><li>用于大文本字段的模糊搜索。</li><li>仅支持 MyISAM 和 InnoDB。</li><li>SQL 示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX idx_name ON table_name (column_name);</span><br></pre></td></tr></table></figure><h3 id="3-5-复合索引-Composite-Multi-Column-Index"><a href="#3-5-复合索引-Composite-Multi-Column-Index" class="headerlink" title="3.5 复合索引 (Composite &#x2F; Multi-Column Index)"></a>3.5 复合索引 (Composite &#x2F; Multi-Column Index)</h3><ul><li>在多列上创建的索引。</li><li><strong>最左前缀原则</strong>：<ul><li>查询条件使用复合索引的第一列，则整个索引可用。</li><li>仅使用非首列，则索引可能无法完全使用。</li></ul></li><li>SQL 示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON table_name (column1, column2, column3);</span><br></pre></td></tr></table></figure><hr><h2 id="4-聚集索引与非聚集索引"><a href="#4-聚集索引与非聚集索引" class="headerlink" title="4. 聚集索引与非聚集索引"></a>4. 聚集索引与非聚集索引</h2><h3 id="4-1-聚集索引-Clustered-Index"><a href="#4-1-聚集索引-Clustered-Index" class="headerlink" title="4.1 聚集索引 (Clustered Index)"></a>4.1 聚集索引 (Clustered Index)</h3><ul><li><strong>叶子节点存储完整数据行</strong>。</li><li>一个表只能有一个聚集索引（通常是主键）。</li><li>数据物理顺序与索引逻辑顺序一致。</li><li>查询效率高，无需回表。</li><li>写入影响：插入、更新、删除需要维护物理顺序。</li><li><strong>InnoDB 实现</strong>：<ul><li>主键索引即聚集索引。</li><li>若未定义主键，选择唯一非空索引作为聚集索引；若无，则创建隐藏 6 字节 <code>row_id</code> 作为聚集索引。</li></ul></li></ul><h3 id="4-2-非聚集索引-Non-Clustered-Index"><a href="#4-2-非聚集索引-Non-Clustered-Index" class="headerlink" title="4.2 非聚集索引 (Non-Clustered Index)"></a>4.2 非聚集索引 (Non-Clustered Index)</h3><ul><li><strong>叶子节点存储主键或指向数据行的指针</strong>。</li><li>表可有多个非聚集索引。</li><li>数据物理顺序与索引逻辑顺序无关。</li><li>查询需回表：若查询列不在索引中，需要通过索引找到主键，再通过聚集索引获取完整数据。</li><li><strong>InnoDB 实现</strong>：所有非主键索引都是非聚集索引。</li></ul><hr><h2 id="5-索引优化策略"><a href="#5-索引优化策略" class="headerlink" title="5. 索引优化策略"></a>5. 索引优化策略</h2><h3 id="5-1-创建索引的列选择"><a href="#5-1-创建索引的列选择" class="headerlink" title="5.1 创建索引的列选择"></a>5.1 创建索引的列选择</h3><ul><li><strong>常用列</strong>：<code>WHERE</code>、<code>JOIN</code>、<code>ORDER BY</code> 中频繁使用的列。</li><li><strong>高区分度列</strong>：唯一值多的列更适合建立索引。</li><li><strong>避免</strong>：<ul><li>小表或频繁更新表上的索引。</li><li>重复值多的列上建索引。</li></ul></li></ul><h3 id="5-2-遵循最左前缀原则"><a href="#5-2-遵循最左前缀原则" class="headerlink" title="5.2 遵循最左前缀原则"></a>5.2 遵循最左前缀原则</h3><ul><li>对复合索引 <code>(a, b, c)</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHERE a = 1                -&gt; 索引可用</span><br><span class="line">WHERE a = 1 AND b = 2      -&gt; 索引可用</span><br><span class="line">WHERE b = 2                 -&gt; 索引无法完全利用</span><br><span class="line">WHERE c = 3                 -&gt; 索引无法完全利用</span><br></pre></td></tr></table></figure><h3 id="5-3-避免索引失效"><a href="#5-3-避免索引失效" class="headerlink" title="5.3 避免索引失效"></a>5.3 避免索引失效</h3><ul><li><strong>函数或表达式</strong>：如 <code>WHERE YEAR(date_column) = 2023</code></li><li><strong>隐式类型转换</strong>：索引列类型不同于查询值类型</li><li><strong>OR 条件</strong>：除非两边都有索引，且优化器决定合并索引</li><li><strong>左模糊匹配</strong>：<code>LIKE &#39;%keyword&#39;</code></li><li><strong>不等&#x2F;非 IN</strong>：<code>!=</code> 或 <code>NOT IN</code></li></ul><h3 id="5-4-覆盖索引-Covering-Index"><a href="#5-4-覆盖索引-Covering-Index" class="headerlink" title="5.4 覆盖索引 (Covering Index)"></a>5.4 覆盖索引 (Covering Index)</h3><ul><li>查询所需列都在索引中，无需回表：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_in_index</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE indexed_column = value;</span><br></pre></td></tr></table></figure><h3 id="5-5-防止回表"><a href="#5-5-防止回表" class="headerlink" title="5.5 防止回表"></a>5.5 防止回表</h3><ul><li>尽量让 SELECT 列被索引覆盖，或只查询主键。</li></ul><h3 id="5-6-定期维护索引"><a href="#5-6-定期维护索引" class="headerlink" title="5.6 定期维护索引"></a>5.6 定期维护索引</h3><ul><li>重建索引或优化碎片化索引，保持性能稳定。</li></ul><hr><hr><h2 id="一、B-树的结构特点"><a href="#一、B-树的结构特点" class="headerlink" title="一、B+树的结构特点"></a>一、B+树的结构特点</h2><ol><li><strong>多路平衡查找树</strong>：MySQL（InnoDB）使用的是 <strong>B+树索引</strong>，不同于二叉树，一个节点能存储大量 key。</li><li><strong>非叶子节点</strong>：只存储 <strong>索引键值 + 子节点指针</strong>，不存放真实数据。</li><li><strong>叶子节点</strong>：存放 <strong>完整的数据行（聚簇索引）</strong> 或 <strong>主键值（辅助索引）</strong>，并且通过 <strong>双向链表</strong> 相连，便于范围查询。</li><li><strong>有序性</strong>：索引键在节点内是有序存储的，适合二分查找。</li></ol><hr><h2 id="二、定位过程（精确查找某条记录）"><a href="#二、定位过程（精确查找某条记录）" class="headerlink" title="二、定位过程（精确查找某条记录）"></a>二、定位过程（精确查找某条记录）</h2><p>假设有一张表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY,   -- 聚簇索引</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>索引类型：</p><ul><li><strong>聚簇索引（Clustered Index）</strong>：叶子节点存储整行记录。</li><li><strong>辅助索引（Secondary Index）</strong>：叶子节点存储主键值，再回表查询整行。</li></ul><hr><h3 id="1-精确查找（主键查找）"><a href="#1-精确查找（主键查找）" class="headerlink" title="1. 精确查找（主键查找）"></a>1. 精确查找（主键查找）</h3><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE id = 25;</span><br></pre></td></tr></table></figure><p>定位步骤：</p><ol><li>从 <strong>根节点</strong> 开始，根据 <code>id</code> 值进行二分查找，找到对应的子节点指针。</li><li>进入 <strong>中间节点</strong>，重复二分查找，继续向下。</li><li>进入 <strong>叶子节点</strong>，找到键值 &#x3D; 25 的位置。</li><li>因为是 <strong>聚簇索引</strong>，叶子节点存放了完整行记录，直接返回。</li></ol><hr><h3 id="2-辅助索引查找（非主键查找）"><a href="#2-辅助索引查找（非主键查找）" class="headerlink" title="2. 辅助索引查找（非主键查找）"></a>2. 辅助索引查找（非主键查找）</h3><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE name = &#x27;Tom&#x27;;</span><br></pre></td></tr></table></figure><p>定位步骤：</p><ol><li>进入 <strong>辅助索引 B+树</strong>，从根 → 中间节点 → 叶子节点，找到 <code>name = &#39;Tom&#39;</code> 对应的记录。</li><li>叶子节点存放的不是整行数据，而是 <strong>主键值（id）</strong>。</li><li>根据主键值，再回到 <strong>聚簇索引 B+树</strong> 中，走一次查找过程，定位到整行数据。</li></ol><p>这就是所谓的 <strong>回表</strong>。</p><hr><h2 id="三、为什么能“精确定位”"><a href="#三、为什么能“精确定位”" class="headerlink" title="三、为什么能“精确定位”"></a>三、为什么能“精确定位”</h2><ol><li><strong>有序存储</strong> → 节点内可以二分查找，快速缩小范围。</li><li><strong>树高较低</strong> → InnoDB 一般 3<del>4 层就能存下百万级数据，每次查找只需磁盘 I&#x2F;O 3</del>4 次。</li><li><strong>聚簇索引</strong> → 直接在叶子节点找到完整行，避免额外跳转。</li><li><strong>辅助索引 + 主键索引</strong> → 通过两次 B+树查找，依然能精确定位。</li></ol><hr><h2 id="四、类比理解"><a href="#四、类比理解" class="headerlink" title="四、类比理解"></a>四、类比理解</h2><p>B+树就像一个“图书馆目录”：</p><ul><li><strong>根节点</strong> &#x3D; 图书馆的“目录索引页”</li><li><strong>中间节点</strong> &#x3D; 分区目录</li><li><strong>叶子节点</strong> &#x3D; 书架（放书或者书的编号）</li><li><strong>聚簇索引</strong> &#x3D; 直接找到书本</li><li><strong>辅助索引</strong> &#x3D; 先找到书的编号，再去另一个书架找书</li></ul><hr><p>👉 总结一句：<br> <strong>MySQL 通过 B+树的有序性和分层查找机制，从根节点到叶子节点逐级定位，最终在叶子节点找到目标记录（主键索引直接拿数据，辅助索引还需回表）。</strong></p><p>要不要我帮你画一张 <strong>B+树精确查找的图解流程</strong>，形象化展示“查找某条记录”的路径？</p><ul><li><h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><img src="https://i-blog.csdnimg.cn/blog_migrate/bfe55c106fb1ceb9316542c424cecf9f.png" alt="图片"></li></ul><hr><h1 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h1><p>MySQL 支持多种存储引擎，每种存储引擎在事务支持、锁机制、索引类型、适用场景等方面有所不同。</p><table><thead><tr><th>存储引擎</th><th>特性</th><th>锁机制</th><th>事务支持</th><th>索引类型</th><th>崩溃恢复</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>InnoDB (默认)</strong></td><td>- 支持事务（ACID）- 支持行级锁- 支持外键约束- 支持崩溃恢复- 默认聚集索引- MVCC（多版本并发控制）</td><td>行级锁</td><td>支持</td><td>聚集索引（叶子节点存储数据行）</td><td>支持 redo log &#x2F; undo log</td><td>事务性应用、高并发读写、数据完整性要求高的场景（如电商、金融）</td></tr><tr><td><strong>MyISAM</strong></td><td>- 不支持事务- 不支持外键- 非聚集索引- SELECT COUNT(*) 快</td><td>表级锁</td><td>不支持</td><td>非聚集索引（叶子节点存储数据地址）</td><td>不支持</td><td>只读或读多写少、对事务性要求不高，需要频繁 COUNT(*) 的应用（如日志、数据仓库）</td></tr><tr><td><strong>Memory (HEAP)</strong></td><td>- 数据存储在内存中，速度快- 重启数据丢失</td><td>表级锁</td><td>不支持</td><td>哈希索引（默认，可用 BTREE）</td><td>不支持</td><td>临时表、缓存、快速计算</td></tr><tr><td><strong>Archive</strong></td><td>- 高度压缩，节省空间- 支持高速插入和查询- 不支持更新和删除</td><td>表级锁</td><td>不支持</td><td>非聚集索引</td><td>不支持</td><td>存储历史数据、不常访问的数据仓库</td></tr><tr><td><strong>CSV</strong></td><td>- 数据以 CSV 文件格式存储- 易于与其他应用交换</td><td>表级锁</td><td>不支持</td><td>无索引或简单索引</td><td>不支持</td><td>数据导入导出、交换数据文件</td></tr></tbody></table><hr><h2 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h2><ol><li><strong>InnoDB 逐渐成为默认引擎</strong>：MySQL 5.5 之后，InnoDB 取代 MyISAM，成为事务型应用首选。</li><li><strong>索引和锁机制区别</strong>：<ul><li>行级锁：并发性能高，锁粒度小。</li><li>表级锁：并发性能低，适合读多写少场景。</li></ul></li><li><strong>崩溃恢复</strong>：<ul><li>InnoDB 通过 <strong>redo log</strong> 和 <strong>undo log</strong> 保证数据持久性和事务回滚。</li><li>MyISAM 和 Memory 不支持事务或崩溃恢复。</li></ul></li><li><strong>存储优化选择</strong>：<ul><li>高并发、事务性应用 → <strong>InnoDB</strong></li><li>只读或日志分析 → <strong>MyISAM</strong></li><li>临时计算&#x2F;缓存 → <strong>Memory</strong></li><li>历史归档数据 → <strong>Archive</strong></li><li>数据交换 → <strong>CSV</strong></li></ul></li></ol><hr><h2 id="MVCC（多版本并发控制）："><a href="#MVCC（多版本并发控制）：" class="headerlink" title="MVCC（多版本并发控制）："></a>MVCC（多版本并发控制）：</h2><p>好的，我们来深入探讨一下 <strong>MVCC (Multi-Version Concurrency Control)</strong>，并分析一些常见的面试题。</p><hr><h3 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a><strong>什么是 MVCC？</strong></h3><p><strong>MVCC</strong>，即<strong>多版本并发控制</strong>，是一种在数据库中用于解决并发访问问题的方法。它不是通过加锁的方式来控制并发，而是通过<strong>为每个事务生成一个数据快照</strong>，让读操作在快照上进行。</p><p>你可以把它想象成一个“时光机”。当一个事务开始时，数据库会为它“拍一张照片”，也就是生成一个数据快照。这个事务的所有读操作都只会看到这个快照里的数据，而不会受到其他并发事务修改的影响。这样，读操作就不需要等待写锁释放，从而实现了<strong>读写分离</strong>，大大提高了并发性能。</p><p>简而言之，MVCC 的核心思想是：</p><ul><li><strong>读不加锁</strong>：读取数据时，直接从数据的历史版本中读取，不需要等待其他事务的写锁。</li><li><strong>写不阻塞读</strong>：写操作修改数据时，会创建一个新的版本，而旧版本依然保留，供其他读事务使用。</li></ul><hr><h3 id="MVCC-的实现原理"><a href="#MVCC-的实现原理" class="headerlink" title="MVCC 的实现原理"></a><strong>MVCC 的实现原理</strong></h3><p>MVCC 的实现通常依赖于以下几个核心要素：</p><ol><li><p>隐藏列（Hidden Columns）：</p><p>每个表都会有几个隐藏的列，用于记录版本信息：</p><ul><li><strong>DB_TRX_ID</strong>：事务 ID，记录最近一次修改数据的事务 ID。</li><li><strong>DB_ROLL_PTR</strong>：回滚指针，指向这条记录的上一个版本。</li><li><strong>DB_ROW_ID</strong>：行 ID，是插入新行时分配的隐藏 ID，当主键是字符串时，可能用于辅助索引。</li></ul></li><li><p>Undo Log (回滚日志)：</p><p>Undo Log 记录了数据在被修改之前的值。每次修改数据时，都会将修改前的数据版本记录在 Undo Log 中，并通过回滚指针 DB_ROLL_PTR 将新版本与旧版本连接起来，形成一个版本链。这样，通过版本链，我们就可以追溯到这条数据的历史版本。</p></li><li><p>Read View (读视图)：</p><p>Read View 是 MVCC 的核心，它是一个在事务启动时生成的、用来判断某个数据版本对当前事务是否可见的数据快照。它主要包含以下几个关键信息：</p><ul><li><code>m_ids</code>：在生成 <code>Read View</code> 时，当前系统中<strong>所有活跃事务</strong>的 ID 列表。</li><li><code>min_trx_id</code>：在生成 <code>Read View</code> 时，<code>m_ids</code> 中最小的事务 ID。</li><li><code>max_trx_id</code>：在生成 <code>Read View</code> 时，系统将要分配给下一个事务的 ID。</li><li><code>creator_trx_id</code>：创建 <code>Read View</code> 的事务 ID。</li></ul><p>当一个事务想要读取一条数据时，会根据 <code>Read View</code> 的规则来判断这条数据的**<code>DB_TRX_ID</code>**是否可见。</p><ul><li>如果 <code>DB_TRX_ID</code> 小于 <code>min_trx_id</code>，说明这个修改操作在当前事务启动前就已经提交了，数据<strong>可见</strong>。</li><li>如果 <code>DB_TRX_ID</code> 大于等于 <code>max_trx_id</code>，说明这个修改操作是在当前事务启动后才发生的，数据<strong>不可见</strong>。</li><li>如果 <code>DB_TRX_ID</code> 在 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，那么需要判断 <code>DB_TRX_ID</code> 是否在 <code>m_ids</code> 列表中。如果在，说明这个修改操作是和当前事务同时启动的，数据<strong>不可见</strong>；如果不在，说明这个修改操作在当前事务启动前就已经提交了，数据<strong>可见</strong>。</li></ul><p>如果当前版本不可见，事务就会通过回滚指针 <code>DB_ROLL_PTR</code> 沿着版本链找到上一版本，直到找到一个<strong>可见</strong>的版本。</p></li></ol><hr><h3 id="面试题分析"><a href="#面试题分析" class="headerlink" title="面试题分析"></a><strong>面试题分析</strong></h3><h4 id="1-什么是-MVCC？它解决了什么问题？"><a href="#1-什么是-MVCC？它解决了什么问题？" class="headerlink" title="1. 什么是 MVCC？它解决了什么问题？"></a><strong>1. 什么是 MVCC？它解决了什么问题？</strong></h4><p><strong>回答要点：</strong></p><ul><li><strong>概念</strong>：多版本并发控制，通过维护数据历史版本实现并发。</li><li><strong>解决问题</strong>：在数据库隔离级别为**读已提交（RC）<strong>和</strong>可重复读（RR）**时，实现了读写不冲突。它解决了 <strong>读写锁冲突</strong> 和 <strong>脏读</strong> 问题，但无法完全解决幻读。</li><li><strong>核心思想</strong>：读操作读取数据快照，写操作创建新版本。</li></ul><h4 id="2-MVCC-是如何实现可重复读（Repeatable-Read）的？"><a href="#2-MVCC-是如何实现可重复读（Repeatable-Read）的？" class="headerlink" title="2. MVCC 是如何实现可重复读（Repeatable Read）的？"></a><strong>2. MVCC 是如何实现可重复读（Repeatable Read）的？</strong></h4><p><strong>回答要点：</strong></p><ul><li><strong>核心</strong>：<code>Read View</code> 的创建时机。</li><li><strong>可重复读</strong>：事务在第一次读操作时创建 <code>Read View</code>，并且在<strong>整个事务的生命周期内都使用这个 Read View</strong>。这意味着无论事务中执行多少次读，看到的都是同一个数据快照，所以能保证多次读取结果一致。</li><li><strong>读已提交</strong>：相比之下，读已提交的隔离级别是<strong>每次执行读操作时都重新生成一个 Read View</strong>。因此，如果其他事务在两次读操作之间提交了修改，第二次读就能看到新数据，导致不可重复读。</li></ul><h4 id="3-MVCC-能解决幻读吗？"><a href="#3-MVCC-能解决幻读吗？" class="headerlink" title="3. MVCC 能解决幻读吗？"></a><strong>3. MVCC 能解决幻读吗？</strong></h4><p><strong>回答要点：</strong></p><ul><li><strong>部分解决，但不能完全解决。</strong></li><li><strong>幻读（Phantom Read）</strong>：当一个事务在两次查询之间，另一个事务插入了新的数据，导致第一次查询不存在的数据，第二次查询却出现了。</li><li><strong>MVCC 的作用</strong>：MVCC 可以防止<strong>更新幻读</strong>（即一个事务在两次查询之间，另一个事务更新了数据），因为它总是读取事务启动时的快照。</li><li><strong>无法解决</strong>：MVCC 无法完全解决<strong>插入幻读</strong>。例如，事务 A 两次查询 <code>WHERE id &gt; 10</code>，但在两次查询之间，事务 B 插入了一条 <code>id=11</code> 的记录并提交。虽然事务 A 的 <code>Read View</code> 看不到这条新记录，但如果事务 A 执行 <code>UPDATE ... WHERE id &gt; 10</code> 时，它会发现这条新记录并对其加锁，从而更新成功。这会打破可重复读的承诺。</li><li><strong>InnoDB 的解决方案</strong>：InnoDB 数据库在 <code>可重复读</code> 隔离级别下，除了 MVCC，还会结合**间隙锁（Gap Lock）**来彻底解决幻读问题。</li></ul><h4 id="4-Undo-Log-和-Redo-Log-有什么区别？"><a href="#4-Undo-Log-和-Redo-Log-有什么区别？" class="headerlink" title="4. Undo Log 和 Redo Log 有什么区别？"></a><strong>4. Undo Log 和 Redo Log 有什么区别？</strong></h4><p><strong>回答要点：</strong></p><ul><li><strong>Undo Log (回滚日志)</strong>：<ul><li><strong>作用</strong>：用于<strong>回滚事务</strong>和实现 <strong>MVCC</strong>。</li><li><strong>记录内容</strong>：记录的是<strong>数据修改前</strong>的版本。</li><li><strong>生命周期</strong>：在事务提交后，如果数据有其他事务在使用（用于 MVCC），<code>Undo Log</code> 依然保留；如果没有，<code>Undo Log</code> 会被清除。</li></ul></li><li><strong>Redo Log (重做日志)</strong>：<ul><li><strong>作用</strong>：用于保证事务的<strong>持久性</strong>。</li><li><strong>记录内容</strong>：记录的是<strong>数据修改后</strong>的日志，比如“某某页的某某偏移量改成了某某值”。</li><li><strong>生命周期</strong>：在数据同步到磁盘后，<code>Redo Log</code> 就会被清除。</li><li><strong>作用点</strong>：<code>Redo Log</code> 作用于<strong>崩溃恢复</strong>。当数据库发生宕机时，可以根据 <code>Redo Log</code> 将已提交但尚未写入磁盘的数据重新写入，以保证数据不丢失。</li></ul></li></ul><h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><p>MySQL的日志系统是其数据库管理系统(DBMS)中至关重要的组成部分，扮演着监控、审计、故障恢复和数据复制等多种关键角色。用户提到的错误日志、查询日志、慢查询日志、事务日志和二进制日志构成了MySQL日志体系的核心。下面将对这些主要日志进行详细的梳理和解析。</p><h2 id="1-错误日志-Error-Log"><a href="#1-错误日志-Error-Log" class="headerlink" title="1. 错误日志(Error Log)"></a>1. 错误日志(Error Log)</h2><p>错误日志是MySQL中最基础的日志之一，它记录了mysqld服务器启动、运行和关闭过程中遇到的所有严重错误和警告。</p><ul><li>主要内容：<ul><li>服务器启动和关闭的详细信息。</li><li>运行过程中发生的错误，例如表损坏、无法访问特定文件等。</li><li>事件调度器运行出错时的信息。</li><li>在主从复制架构中，从服务器上启动和关闭复制线程，连接主服务器时发生的错误等。</li></ul></li><li>作用：错误日志是诊断和解决MySQL服务器问题的首要工具。当数据库无法启动或运行异常时，应首先检查此日志。</li><li>配置：默认情况下，错误日志是开启的。其文件名通常为<hostname>.err，位于数据目录(datadir)下。可以通过在my.cnf或my.ini配置文件中设置log_error变量来指定其路径。</li></ul><h2 id="2-查询日志-Query-Log-通用查询日志-General-Query-Log"><a href="#2-查询日志-Query-Log-通用查询日志-General-Query-Log" class="headerlink" title="2. 查询日志(Query Log)&#x2F;通用查询日志(General Query Log)"></a>2. 查询日志(Query Log)&#x2F;通用查询日志(General Query Log)</h2><p>通用查询日志记录了MySQL服务器接收到的每一个客户端连接和执行的每一条SQL语句。</p><ul><li>主要内容：<ul><li>客户端的连接信息，包括连接时间、用户名和主机。</li><li>客户端发送给服务器的所有SQL语句，无论其是否正确执行。</li></ul></li><li>作用：该日志对于数据库的审计和问题排查非常有用，可以精确复现用户的操作序列。然而，由于它会记录所有操作，对系统性能会产生显著影响，并会迅速占用大量磁盘空间。因此，不建议在生产环境中长期开启。</li><li>配置：默认关闭。可以通过设置general_log为ON来启用，并使用general_log_file指定日志文件路径。</li></ul><h2 id="3-慢查询日志-Slow-Query-Log"><a href="#3-慢查询日志-Slow-Query-Log" class="headerlink" title="3. 慢查询日志(Slow Query Log)"></a>3. 慢查询日志(Slow Query Log)</h2><p>慢查询日志用于记录执行时间超过指定阈值的SQL查询语句，是数据库性能优化的关键工具。</p><ul><li>主要内容：<ul><li>执行时间超过long_query_time阈值的SQL语句。</li><li>查询执行时的相关信息，如执行时间、锁定时间、扫描的行数、返回的行数以及执行该查询的用户和主机。</li></ul></li><li>作用：通过分析慢查询日志，开发者和数据库管理员(DBA)可以定位到效率低下的SQL语句，并针对性地进行优化，例如添加索引、改写查询等。</li><li>配置：默认关闭。需在配置文件中设置slow_query_log为ON开启。long_query_time参数用于设定慢查询的时间阈值(单位：秒)，slow_query_log_file用于指定日志文件位置。log_queries_not_using_indexes参数还可以记录未使用索引的查询。</li></ul><h2 id="4-事务日志-Transaction-Log"><a href="#4-事务日志-Transaction-Log" class="headerlink" title="4. 事务日志(Transaction Log)"></a>4. 事务日志(Transaction Log)</h2><p>用户提到的”事务日志”在InnoDB存储引擎中，主要由两种日志构成：重做日志(Redo Log)和回滚日志(Undo Log)。它们共同保证了事务的ACID特性(原子性、一致性、隔离性、持久性)。</p><ul><li>重做日志(Redo Log):<ul><li>作用：保证事务的持久性。它记录了数据被修改后的物理变化。当事务提交后，即使数据尚未完全写入数据文件，只要Redo Log已经持久化，在数据库发生崩溃时，也可以通过重放Redo Log来恢复已提交的事务，确保数据不丢失。这种技术被称为预写日志(Write-Ahead Logging, WAL)。</li><li>特点：Redo Log是以循环写的方式记录在连续的物理文件中，大小固定。</li></ul></li><li>回滚日志(Undo Log):<ul><li>作用：保证事务的原子性和实现多版本并发控制(MVCC)。Undo Log记录的是数据被修改前的状态。当事务需要回滚时，可以通过Undo Log将数据恢复到修改之前的版本。同时，在读已提交(Read Committed)和可重复读(Repeatable Read)隔离级别下，当一个事务需要读取被另一个未提交事务修改的行时，会通过Undo Log读取该行之前的版本，从而实现非锁定读。</li><li>特点：Undo Log逻辑上记录了每个修改操作的逆操作。</li></ul></li></ul><h2 id="5-二进制日志-Binary-Log-Binlog"><a href="#5-二进制日志-Binary-Log-Binlog" class="headerlink" title="5. 二进制日志(Binary Log&#x2F;Binlog)"></a>5. 二进制日志(Binary Log&#x2F;Binlog)</h2><p>二进制日志是MySQL中功能最强大、用途最广泛的日志之一。它以二进制格式记录了所有修改数据库数据的操作(DML)以及数据定义语言(DDL)的操作，但不包括SELECT和SHOW等不修改数据的查询。</p><ul><li>主要内容：记录了导致数据发生更改的所有事件。根据格式不同，可以记录为SQL语句(STATEMENT格式)、行的变更(ROW格式)或两者的混合(MIXED格式)。</li><li>主要作用：<ul><li>数据恢复(Point-in-Time Recovery)：通过备份的数据文件和之后的二进制日志，可以将数据库恢复到过去的任意一个时间点。</li><li>主从复制(Replication)：在主从架构中，主服务器将二进制日志传送给从服务器，从服务器重放这些日志中的事件，从而实现与主服务器的数据同步。</li></ul></li><li>配置：默认情况下可能关闭，需要通过配置文件中的log_bin选项来启用。启用后，会生成一个索引文件(默认为<hostname>-bin.index)和一系列的二进制日志文件。</li></ul><h2 id="扩展：中继日志-Relay-Log"><a href="#扩展：中继日志-Relay-Log" class="headerlink" title="扩展：中继日志(Relay Log)"></a>扩展：中继日志(Relay Log)</h2><p>在主从复制环境中，还有一个重要的日志类型——中继日志。</p><ul><li>作用：从服务器的I&#x2F;O线程从主服务器获取二进制日志，并将其写入本地的中继日志中。然后，从服务器的SQL线程读取中继日志中的事件，并在从服务器上执行，以实现数据同步。</li><li>特点：中继日志的格式与二进制日志完全相同。它的存在使得从服务器的I&#x2F;O和SQL执行可以解耦，即使在网络不稳定的情况下，只要I&#x2F;O线程将日志拉到本地，SQL线程就可以持续执行。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>日志类型</th><th>主要作用</th><th>生产环境建议</th></tr></thead><tbody><tr><td>错误日志</td><td>记录服务器启停和运行错误</td><td>始终开启</td></tr><tr><td>查询日志</td><td>记录所有连接和SQL语句，用于审计</td><td>默认关闭，仅在调试时短期开启</td></tr><tr><td>慢查询日志</td><td>记录执行缓慢的SQL，用于性能优化</td><td>建议开启</td></tr><tr><td>事务日志</td><td></td><td></td></tr><tr><td>- Redo Log</td><td>保证事务持久性，用于崩溃恢复</td><td>InnoDB引擎核心组件，始终开启</td></tr><tr><td>- Undo Log</td><td>保证事务原子性，支持MVCC</td><td>InnoDB引擎核心组件，始终开启</td></tr><tr><td>二进制日志</td><td>数据恢复、主从复制</td><td>强烈建议开启，尤其是需要数据恢复和复制的场景</td></tr><tr><td>中继日志</td><td>主从复制中，从库用于暂存主库的二进制日志</td><td>在从服务器上自动创建和管理</td></tr></tbody></table><h2 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h2><h2 id="第一部分：数据库锁系统"><a href="#第一部分：数据库锁系统" class="headerlink" title="第一部分：数据库锁系统"></a>第一部分：数据库锁系统</h2><h3 id="1-锁的分类体系"><a href="#1-锁的分类体系" class="headerlink" title="1. 锁的分类体系"></a>1. 锁的分类体系</h3><h4 id="1-1-按锁粒度的层次分类"><a href="#1-1-按锁粒度的层次分类" class="headerlink" title="1.1 按锁粒度的层次分类"></a>1.1 按锁粒度的层次分类</h4><p><strong>表级锁（Table-Level Lock）</strong> 表级锁是最粗粒度的锁机制，一次锁定整个表的所有数据。MyISAM存储引擎主要使用表级锁，其内部维护一个全局的表锁列表。当线程需要访问表时，首先检查表锁状态，如果表已被其他线程以不兼容模式锁定，则当前线程进入等待队列。表级锁的优势在于锁管理开销极小，只需要维护少量的锁对象；缺点是并发度极低，即使访问不同行的操作也会相互阻塞。</p><p><strong>页级锁（Page-Level Lock）</strong> 页级锁锁定数据页，是表级锁和行级锁的折中方案。BDB存储引擎使用页级锁，每个数据页通常包含多条记录。页级锁的实现需要在页头维护锁信息，包括锁模式、持有者信息等。这种锁粒度在空间局部性较好的应用中表现优秀，因为相关的数据通常存储在相邻的页面中。</p><p><strong>行级锁（Row-Level Lock）</strong> 行级锁是最细粒度的锁机制，InnoDB存储引擎的核心特性。行锁的实现依赖于索引结构，实际上锁定的是索引记录而不是数据行本身。当查询没有使用索引时，InnoDB会扫描整个表并对所有记录加锁，退化为类似表锁的行为。行级锁提供最高的并发度，但也带来最大的管理开销。</p><h4 id="1-2-按锁模式的功能分类"><a href="#1-2-按锁模式的功能分类" class="headerlink" title="1.2 按锁模式的功能分类"></a>1.2 按锁模式的功能分类</h4><p><strong>共享锁（Shared Lock, S锁）</strong> 共享锁允许多个事务同时读取同一资源，但阻止任何事务修改该资源。在InnoDB中，共享锁通过在锁对象的type_mode字段中设置LOCK_S标志位来标识。多个共享锁可以并存，这是通过锁兼容性矩阵来判断的。共享锁的获取相对简单，只需要检查是否存在冲突的排他锁。</p><p><strong>排他锁（Exclusive Lock, X锁）</strong> 排他锁提供独占访问，同一时间只能有一个事务持有资源的排他锁。排他锁与任何其他锁都不兼容，包括共享锁和其他排他锁。在InnoDB实现中，排他锁的获取需要等待所有现有的锁释放，这通过等待队列机制来实现。</p><p><strong>意向锁（Intention Lock）</strong> 意向锁是一种表级锁，用于表明事务在表的某些行上持有或即将请求某种类型的锁。意向共享锁（IS）表示事务意图在某些行上获取共享锁，意向排他锁（IX）表示事务意图在某些行上获取排他锁。意向锁的引入大大简化了表级操作的锁冲突检测，避免了遍历所有行锁的开销。</p><h4 id="1-3-按锁算法的实现分类"><a href="#1-3-按锁算法的实现分类" class="headerlink" title="1.3 按锁算法的实现分类"></a>1.3 按锁算法的实现分类</h4><p><strong>记录锁（Record Lock）</strong> 记录锁锁定索引中的一条具体记录，是最基本的行级锁形式。在InnoDB的实现中，记录锁通过在B+树的叶子节点记录上设置锁标记来实现。锁对象中的heap_no字段精确标识被锁定的记录在页面中的位置。记录锁只能防止其他事务修改或删除该记录，但不能防止在该记录前后插入新记录。</p><p><strong>间隙锁（Gap Lock）</strong> 间隙锁锁定索引记录之间的间隙，防止其他事务在该间隙中插入新记录。间隙锁的范围是开区间，不包含边界记录本身。InnoDB通过比较索引键值来确定间隙的边界，对于复合索引，间隙的比较需要考虑所有键值列的组合。间隙锁之间不冲突，多个事务可以同时持有相同间隙的间隙锁。</p><p><strong>临键锁（Next-Key Lock）</strong> 临键锁是记录锁和间隙锁的组合，锁定一个记录以及该记录前面的间隙。这是InnoDB在可重复读隔离级别下的默认锁算法。临键锁有效解决了幻读问题，因为它不仅锁定已存在的记录，还锁定了可能插入新记录的位置。临键锁的范围是左开右闭区间。</p><h3 id="2-InnoDB锁系统的深层实现"><a href="#2-InnoDB锁系统的深层实现" class="headerlink" title="2. InnoDB锁系统的深层实现"></a>2. InnoDB锁系统的深层实现</h3><h4 id="2-1-锁对象的数据结构设计"><a href="#2-1-锁对象的数据结构设计" class="headerlink" title="2.1 锁对象的数据结构设计"></a>2.1 锁对象的数据结构设计</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="type">trx_t</span>* trx;           <span class="comment">// 拥有该锁的事务</span></span><br><span class="line">    UT_LIST_NODE_T(<span class="type">lock_t</span>) trx_locks; <span class="comment">// 事务锁链表节点</span></span><br><span class="line">    <span class="type">dict_table_t</span>* tab_lock; <span class="comment">// 表锁信息</span></span><br><span class="line">    <span class="type">dict_index_t</span>* index;    <span class="comment">// 索引信息</span></span><br><span class="line">    <span class="type">hash_node_t</span> hash;       <span class="comment">// 哈希表节点</span></span><br><span class="line">    ulint type_mode;        <span class="comment">// 锁类型和模式</span></span><br><span class="line">    ulint n_bits;          <span class="comment">// 位图大小</span></span><br><span class="line">    ulint n_granted_locks; <span class="comment">// 已授予的锁数量</span></span><br><span class="line">    ulint n_waiting_locks; <span class="comment">// 等待的锁数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>锁哈希表的设计：</strong> InnoDB使用一个全局的锁哈希表来管理所有的锁对象，哈希函数基于space_id和page_no计算。每个哈希桶包含一个锁对象链表，相同页面的所有锁对象都链接在同一个桶中。这种设计支持快速的锁查找和冲突检测，时间复杂度接近O(1)。</p><p><strong>锁位图的精巧设计：</strong> 对于页面级别的锁管理，InnoDB使用位图来标识页面中哪些记录被锁定。每个记录对应位图中的一位，设置为1表示该记录被锁定。这种压缩表示法大大节省了内存空间，特别是在锁定大量记录时。位图操作使用高效的位运算指令，支持快速的锁状态查询和更新。</p><h4 id="2-2-死锁检测的高级算法"><a href="#2-2-死锁检测的高级算法" class="headerlink" title="2.2 死锁检测的高级算法"></a>2.2 死锁检测的高级算法</h4><p><strong>增量式死锁检测：</strong> InnoDB不是每次都重新构建整个等待图，而是采用增量式检测。当新的等待关系建立时，算法只检查从新等待者开始的路径是否形成环。这种优化大大减少了检测的计算开销，特别是在高并发场景下效果显著。</p><p><strong>死锁检测的优先级调度：</strong> 死锁检测器运行在独立的后台线程中，具有较高的调度优先级。检测频率根据系统负载动态调整：在高并发时增加检测频率，在低负载时降低频率以节省CPU资源。检测器还会维护统计信息，包括死锁发生频率、平均解决时间等，用于系统调优。</p><p><strong>复杂死锁场景的处理：</strong> 实际生产环境中可能出现涉及多个资源类型的复杂死锁，比如同时涉及行锁、表锁、和外键约束锁的死锁。InnoDB的死锁检测器需要构建一个多层次的等待图，包含不同类型的资源节点和等待边。解决这类死锁时，需要考虑不同锁类型的回滚代价。</p><h4 id="2-3-MVCC与锁的深度集成"><a href="#2-3-MVCC与锁的深度集成" class="headerlink" title="2.3 MVCC与锁的深度集成"></a>2.3 MVCC与锁的深度集成</h4><p><strong>ReadView的内部结构：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReadView</span> &#123;</span></span><br><span class="line">    <span class="type">trx_id_t</span> low_limit_id;    <span class="comment">// 生成ReadView时的下一个事务ID</span></span><br><span class="line">    <span class="type">trx_id_t</span> up_limit_id;     <span class="comment">// 生成ReadView时最小的活跃事务ID</span></span><br><span class="line">    <span class="type">trx_id_t</span> creator_trx_id;  <span class="comment">// 创建ReadView的事务ID</span></span><br><span class="line">    <span class="type">trx_ids_t</span> m_ids;          <span class="comment">// 生成ReadView时的活跃事务ID列表</span></span><br><span class="line">    m_low_limit_no;           <span class="comment">// 最大的事务编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>版本可见性的判断算法：</strong> 当事务读取记录时，需要判断记录的某个版本是否对当前事务可见。判断逻辑基于记录的DB_TRX_ID字段和ReadView的信息：如果DB_TRX_ID小于up_limit_id，则该版本对所有事务可见；如果DB_TRX_ID大于等于low_limit_id，则该版本对当前事务不可见；如果DB_TRX_ID在两者之间，则需要检查是否在活跃事务列表中。</p><p><strong>undo log的链式结构：</strong> 每个事务的undo log形成一个链式结构，记录了该事务的所有修改操作。undo log不仅用于事务回滚，还用于MVCC的版本构建。当需要构建某个历史版本时，InnoDB会从当前版本开始，沿着undo log链向前回溯，逐步应用逆向操作直到达到目标版本。</p><h3 id="3-数据库锁的性能优化策略"><a href="#3-数据库锁的性能优化策略" class="headerlink" title="3. 数据库锁的性能优化策略"></a>3. 数据库锁的性能优化策略</h3><h4 id="3-1-锁等待的自适应策略"><a href="#3-1-锁等待的自适应策略" class="headerlink" title="3.1 锁等待的自适应策略"></a>3.1 锁等待的自适应策略</h4><p><strong>等待时间的动态调整：</strong> InnoDB实现了自适应的锁等待策略，根据系统负载和锁竞争情况动态调整等待超时时间。在低负载时延长等待时间以减少不必要的回滚，在高负载时缩短等待时间以快速释放资源。这种策略通过维护系统级的统计信息来实现，包括平均锁持有时间、锁竞争频率等。</p><p><strong>等待队列的优先级管理：</strong> 对于同一资源的多个等待者，InnoDB可以根据事务的重要性、等待时间、资源消耗等因素进行优先级排序。高优先级的事务可以优先获得锁，这对于关键业务操作特别重要。优先级的计算考虑多个维度，包括事务的年龄、修改的数据量、是否为只读事务等。</p><h4 id="3-2-索引设计对锁性能的影响"><a href="#3-2-索引设计对锁性能的影响" class="headerlink" title="3.2 索引设计对锁性能的影响"></a>3.2 索引设计对锁性能的影响</h4><p><strong>覆盖索引与锁范围优化：</strong> 当查询能够通过覆盖索引获取所有需要的数据时，InnoDB只需要在二级索引上加锁，而不需要回表访问聚簇索引。这大大减少了锁的数量和范围，提高了并发性能。覆盖索引的设计需要仔细分析查询模式，将经常一起访问的列组合成复合索引。</p><p><strong>索引前缀长度对锁粒度的影响：</strong> 对于字符串类型的索引，前缀长度的选择直接影响锁的粒度。较短的前缀可能导致多个不同的值映射到相同的索引前缀，从而扩大锁的范围；较长的前缀提供更精确的锁定，但增加了索引的存储开销。最优前缀长度需要在锁粒度和存储效率之间平衡。</p><h4 id="3-3-事务设计对锁性能的优化"><a href="#3-3-事务设计对锁性能的优化" class="headerlink" title="3.3 事务设计对锁性能的优化"></a>3.3 事务设计对锁性能的优化</h4><p><strong>事务边界的精细控制：</strong> 事务边界的设计直接影响锁的持有时间。长事务会长时间持有锁，阻塞其他事务的执行。优化策略包括：将大事务拆分为多个小事务，减少每个事务的锁持有时间；将只读操作和写操作分离，只读操作使用快照读避免加锁；在事务中优先执行可能失败的操作，减少无效锁持有。</p><p><strong>批量操作的锁优化：</strong> 对于批量插入、更新、删除操作，可以采用特殊的锁策略。比如批量插入时可以使用INSERT … ON DUPLICATE KEY UPDATE语法，减少锁冲突；批量更新时可以按照索引顺序进行，避免死锁；批量删除时可以分批进行，避免长时间持有大量锁。</p><h2 id="行锁（Row-Lock）"><a href="#行锁（Row-Lock）" class="headerlink" title="行锁（Row Lock）"></a>行锁（Row Lock）</h2><h2 id="InnoDB的行锁实现"><a href="#InnoDB的行锁实现" class="headerlink" title="InnoDB的行锁实现"></a>InnoDB的行锁实现</h2><p>InnoDB是MySQL中支持行锁的主要存储引擎：<br>实现原理：</p><ol><li>当事务需要锁定某行时，InnoDB会在该行对应的索引记录上加锁</li><li>如果没有索引，会锁定整个表（实际是锁定所有行）</li><li>锁信息存储在内存中的哈希表结构中</li></ol><h2 id="表锁（Table-Lock）"><a href="#表锁（Table-Lock）" class="headerlink" title="表锁（Table Lock）"></a>表锁（Table Lock）</h2><h2 id="MyISAM的表锁实现"><a href="#MyISAM的表锁实现" class="headerlink" title="MyISAM的表锁实现"></a>MyISAM的表锁实现</h2><p>MyISAM只支持表级锁</p><ol><li>维护一个全局的表锁队列</li><li>写锁具有更高优先级</li><li>锁信息存储在服务器层面</li></ol><h1 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><hr><h3 id="八个基本数据类型（Primitive-Data-Types）"><a href="#八个基本数据类型（Primitive-Data-Types）" class="headerlink" title="八个基本数据类型（Primitive Data Types）"></a><strong>八个基本数据类型（Primitive Data Types）</strong></h3><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a><strong>1. 整型</strong></h4><p>整型用于存储不带小数的整数。Java 提供了四种整型，它们的区别在于所占内存空间的大小，从而影响可存储的数值范围。</p><ul><li><strong>byte</strong><ul><li>大小：1 字节（8 位）</li><li>范围：−128 到 127</li><li>用途：主要用于节省内存，尤其是在处理大量数据时，例如在文件或网络传输中。</li></ul></li><li><strong>short</strong><ul><li>大小：2 字节（16 位）</li><li>范围：−32768 到 32767</li><li>用途：同样用于节省内存，比 <code>byte</code> 的范围更大。</li></ul></li><li><strong>int</strong><ul><li>大小：4 字节（32 位）</li><li>范围：约 −2.1×109 到 2.1×109</li><li>用途：这是<strong>最常用</strong>的整型，通常用来表示普通的整数。</li></ul></li><li><strong>long</strong><ul><li>大小：8 字节（64 位）</li><li>范围：约 −9.2×1018 到 9.2×1018</li><li>用途：当 <code>int</code> 类型的范围不足以存储一个大数时使用，例如处理时间戳、文件大小等。在数值后面需要加上 <code>L</code> 或 <code>l</code> 来表示，例如 <code>long myLong = 100L;</code>。</li></ul></li></ul><h4 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2. 浮点型"></a><strong>2. 浮点型</strong></h4><p>浮点型用于存储带有小数点的数值。</p><ul><li><strong>float</strong><ul><li>大小：4 字节（32 位）</li><li>用途：单精度浮点数，有效位数为 6-7 位。在数值后面需要加上 <code>F</code> 或 <code>f</code> 来表示，例如 <code>float myFloat = 3.14f;</code>。</li></ul></li><li><strong>double</strong><ul><li>大小：8 字节（64 位）</li><li>用途：双精度浮点数，有效位数为 15-16 位。这是<strong>最常用</strong>的浮点型，Java 默认的浮点数类型就是 <code>double</code>。</li></ul></li></ul><blockquote><p><strong>注意</strong>：浮点数存在精度问题，不适合用于精确的金融计算。如果需要精确计算，应使用 <code>java.math.BigDecimal</code> 类。</p></blockquote><h4 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3. 字符型"></a><strong>3. 字符型</strong></h4><ul><li><strong>char</strong><ul><li>大小：2 字节（16 位）</li><li>用途：存储单个字符。在 Java 中，<code>char</code> 采用 Unicode 编码，可以表示包括中文在内的所有字符。它可以用单引号 <code>&#39;</code> 括起来，例如 <code>char myChar = &#39;A&#39;;</code>。</li></ul></li></ul><h4 id="4-布尔型"><a href="#4-布尔型" class="headerlink" title="4. 布尔型"></a><strong>4. 布尔型</strong></h4><ul><li><strong>boolean</strong><ul><li>大小：在内存中通常被视为 1 位，但在数组中会占用 1 字节。</li><li>用途：用于存储 <code>true</code> 或 <code>false</code>，表示逻辑值。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/image-20250915211633091.png" alt="image-20250915211633091"></p><h3 id="自动拆装箱的本质"><a href="#自动拆装箱的本质" class="headerlink" title="自动拆装箱的本质"></a>自动拆装箱的本质</h3><hr><p><strong>自动拆装箱</strong>是 Java 编译器在编译时期，根据代码的语法，<strong>自动</strong>将基本数据类型和其对应的包装类型之间进行转换的一种机制。这在 Java 5 之后被引入，大大简化了代码，让开发者可以像操作基本类型一样操作包装类型。</p><ul><li><strong>装箱（Boxing）</strong>：将基本数据类型（如 <code>int</code>）转换为对应的包装类型（<code>Integer</code>）。</li><li><strong>拆箱（Unboxing）</strong>：将包装类型（<code>Integer</code>）转换为对应的基本数据类型（<code>int</code>）。</li></ul><h3 id="自动拆装箱的底层原理"><a href="#自动拆装箱的底层原理" class="headerlink" title="自动拆装箱的底层原理"></a>自动拆装箱的底层原理</h3><hr><p>这并非 JVM 的特性，而是<strong>编译器</strong>的“障眼法”。当你在 Java 代码中使用自动拆装箱时，编译器会在你看不见的地方，自动插入对应的 <code>valueOf()</code> 和 <code>xxxValue()</code> 方法。</p><h4 id="1-自动装箱的原理"><a href="#1-自动装箱的原理" class="headerlink" title="1. 自动装箱的原理"></a>1. 自动装箱的原理</h4><p>当你写下 <code>Integer a = 100;</code> 这样的代码时，编译器会将其自动转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这就是自动装箱的本质。它调用了包装类的静态方法 <strong>valueOf()</strong>。</p><p><strong>Integer.valueOf() 的特殊之处</strong>：</p><p>为了节省内存并提高性能，<code>Integer</code> 类内部维护了一个 <strong>缓存</strong>。这个缓存的范围通常是 <strong>-128 到 127</strong>。</p><p>当 <code>valueOf()</code> 方法传入的值在这个范围内时，它会直接从缓存中返回对应的 <code>Integer</code> 对象，而不是创建一个新的对象。</p><p>所以，当你执行以下代码时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);</span><br></pre></td></tr></table></figure><p>结果是 <code>true</code>，因为 <code>a</code> 和 <code>b</code> 都指向了缓存中的同一个对象。</p><p>但如果值超出这个范围：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(c == d);</span><br></pre></td></tr></table></figure><p>结果就是 <code>false</code>，因为每次都会创建新的 <code>Integer</code> 对象。这个缓存优化机制也存在于 <code>Byte</code>, <code>Short</code>, <code>Long</code> 和 <code>Character</code> 类型中。</p><h4 id="2-自动拆箱的原理"><a href="#2-自动拆箱的原理" class="headerlink" title="2. 自动拆箱的原理"></a>2. 自动拆箱的原理</h4><p>当你写下 <code>int i = a;</code> 这样的代码（其中 <code>a</code> 是一个 <code>Integer</code> 对象）时，编译器会将其自动转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.intValue();</span><br></pre></td></tr></table></figure><p>这就是自动拆箱的本质。它调用了包装类的实例方法 <strong>xxxValue()</strong>（如 <code>intValue()</code>, <code>doubleValue()</code> 等）。</p><hr><h3 id="注意事项与潜在问题"><a href="#注意事项与潜在问题" class="headerlink" title="注意事项与潜在问题"></a>注意事项与潜在问题</h3><p>虽然自动拆装箱让代码更简洁，但如果不了解其原理，可能会引发一些问题：</p><ul><li><p><strong>NullPointerException</strong>：如果一个包装类型为 <code>null</code>，在进行自动拆箱时，会调用 <code>null</code> 对象的 <code>intValue()</code> 方法，从而抛出 <code>NullPointerException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; <span class="comment">// 这里会抛出 NullPointerException</span></span><br></pre></td></tr></table></figure></li><li><p><strong>性能问题</strong>：在循环中频繁地进行自动装箱和拆箱，会不断地创建和销毁对象，这会增加垃圾回收（GC）的负担，影响程序性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 糟糕的写法</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++) &#123;</span><br><span class="line">    sum += k; <span class="comment">// 每次循环都会进行一次拆箱和一次装箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该使用基本数据类型来避免这种开销：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更好的写法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++) &#123;</span><br><span class="line">    sum += k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="什么是静态变量？"><a href="#什么是静态变量？" class="headerlink" title="什么是静态变量？"></a>什么是静态变量？</h3><p>在 Java 中，静态变量（Static Variable），也称为类变量（Class Variable），是使用 <strong>static 关键字</strong> 修饰的变量。它属于 <strong>类</strong>，而不是类的任何一个 <strong>实例对象</strong>。</p><p>这意味着，不管你创建了多少个类的对象，静态变量在内存中都只有<strong>一份</strong>，并且这唯一的一份数据被该类的所有对象共享。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">company</span> <span class="operator">=</span> <span class="string">&quot;Google&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>name</code> 是一个<strong>实例变量</strong>。每个 <code>User</code> 对象都有自己独立的 <code>name</code> 属性，<code>user1</code> 的 <code>name</code> 和 <code>user2</code> 的 <code>name</code> 互不影响。</li><li><code>company</code> 是一个<strong>静态变量</strong>。无论你创建多少个 <code>User</code> 对象，它们共享同一个 <code>company</code> 变量。如果你修改了 <code>company</code> 的值，所有 <code>User</code> 对象的 <code>company</code> 属性都会跟着改变。</li></ul><hr><h3 id="静态变量的内存分配与生命周期"><a href="#静态变量的内存分配与生命周期" class="headerlink" title="静态变量的内存分配与生命周期"></a>静态变量的内存分配与生命周期</h3><ul><li><strong>内存分配</strong>：静态变量在类加载时，被分配到 <strong>方法区（Method Area）</strong> 的 <strong>静态区</strong> 中。这与实例变量不同，实例变量是在创建对象时，随着对象一起分配在 <strong>堆（Heap）</strong> 中。</li><li><strong>生命周期</strong>：静态变量的生命周期与类的生命周期相同。当类被加载时，静态变量被创建；当类被卸载时，静态变量才会被销毁。</li></ul><p>因为它的生命周期贯穿整个程序运行过程，所以也常常被称为“全局变量”。</p><hr><h3 id="如何访问静态变量？"><a href="#如何访问静态变量？" class="headerlink" title="如何访问静态变量？"></a>如何访问静态变量？</h3><p>访问静态变量有两种方式，但推荐使用第一种，因为它更符合静态变量“属于类”的特性。</p><ol><li><p>通过类名访问（推荐）</p><p>这是最常见、最规范的访问方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(User.company); <span class="comment">// 输出: Google</span></span><br></pre></td></tr></table></figure></li><li><p>通过对象实例访问（不推荐）</p><p>虽然可以通过对象实例来访问静态变量，但编译器会发出警告，因为它可能会造成混淆，让人误以为静态变量是实例特有的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">System.out.println(user1.company); <span class="comment">// 输出: Google</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="静态变量的应用场景"><a href="#静态变量的应用场景" class="headerlink" title="静态变量的应用场景"></a>静态变量的应用场景</h3><p>静态变量因其“全局唯一”的特性，非常适合以下场景：</p><ol><li><p><strong>计数器</strong>：需要统计某个类被创建了多少次，可以使用一个静态变量作为计数器。每次创建对象时，就在构造函数中对该静态变量进行自增操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>共享配置</strong>：当某些数据是所有对象共有的，比如公司名称、项目名称、数据库连接池等，可以将它们定义为静态变量，方便所有对象共享和访问。</p></li><li><p><strong>常量</strong>：定义程序中不会改变的常量，通常结合 <code>final</code> 关键字一起使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVER_URL</span> <span class="operator">=</span> <span class="string">&quot;http://api.example.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>这样定义的常量可以在整个程序中被安全地访问。</p></li></ol><hr><h3 id="静态变量的缺点与注意事项"><a href="#静态变量的缺点与注意事项" class="headerlink" title="静态变量的缺点与注意事项"></a>静态变量的缺点与注意事项</h3><ul><li><strong>线程安全问题</strong>：由于静态变量是所有线程共享的，当多个线程同时修改它时，可能会发生数据不一致的问题。因此，在使用静态变量时，需要特别注意<strong>线程安全</strong>，可以考虑使用同步锁或原子类（如 <code>AtomicInteger</code>）来保证并发安全。</li><li><strong>过度使用问题</strong>：滥用静态变量可能会导致程序耦合度过高，不利于单元测试和代码维护。因为静态变量无法通过依赖注入进行替换，测试时难以模拟或隔离其状态。</li></ul><p><code>new</code> 关键字在 Java 中是用来<strong>创建对象实例</strong>的。当你在代码中使用 <code>new</code> 关键字时，它会执行以下三个关键步骤：</p><h3 id="1-分配内存"><a href="#1-分配内存" class="headerlink" title="1. 分配内存"></a>1. 分配内存</h3><p><code>new</code> 关键字会计算新创建对象所需的内存大小，并在 <strong>堆（Heap）</strong> 上为这个对象分配一块内存空间。这块内存包含了所有实例变量，以及指向该类信息的指针（例如，该类的<strong>方法区</strong>中的类元信息）。</p><h3 id="2-初始化实例变量"><a href="#2-初始化实例变量" class="headerlink" title="2. 初始化实例变量"></a>2. 初始化实例变量</h3><p>内存分配完成后，Java 会对实例变量进行初始化。</p><ul><li>如果在定义时给变量赋了初始值，那么它们会按照代码中的值进行初始化。</li><li>如果没有明确赋值，那么它们会被赋予默认值：<code>int</code> 为 0，<code>boolean</code> 为 <code>false</code>，引用类型为 <code>null</code> 等。</li></ul><h3 id="3-调用构造方法"><a href="#3-调用构造方法" class="headerlink" title="3. 调用构造方法"></a>3. 调用构造方法</h3><p>初始化实例变量之后，<code>new</code> 关键字会调用类的<strong>构造方法</strong>。构造方法的主要作用是完成对象的最终初始化工作，例如为实例变量赋上更具体的值。</p><hr><h3 id="new-关键字与构造方法的关系"><a href="#new-关键字与构造方法的关系" class="headerlink" title="new 关键字与构造方法的关系"></a><code>new</code> 关键字与构造方法的关系</h3><p>很多人会把 <code>new</code> 关键字和构造方法混为一谈，但它们是两个不同的概念。</p><ul><li><strong>new 关键字</strong> 是一个<strong>操作符</strong>，负责<strong>创建对象</strong>并<strong>分配内存</strong>。</li><li><strong>构造方法</strong> 是一个<strong>特殊方法</strong>，负责<strong>初始化对象</strong>。</li></ul><p>你可以把它们想象成这样：</p><ul><li><code>new</code> 就像是工厂的流水线，负责制造一个空壳产品（对象）。</li><li>构造方法就像是流水线上的工人，负责给这个产品填充内容（初始化）。</li></ul><p><code>new</code> 关键字的作用是<strong>实例化</strong>，而构造方法的作用是<strong>初始化</strong>。只有通过 <code>new</code> 关键字，你才能调用构造方法来创建一个新的对象。</p><h3 id="new-关键字的局限性"><a href="#new-关键字的局限性" class="headerlink" title="new 关键字的局限性"></a><code>new</code> 关键字的局限性</h3><p>虽然 <code>new</code> 是最常见的对象创建方式，但它也有一些局限性：</p><ul><li><strong>强耦合</strong>：直接使用 <code>new</code> 会在代码中创建对具体类的依赖，不利于代码解耦和单元测试。</li><li><strong>无法灵活创建</strong>：你无法通过 <code>new</code> 关键字来动态地决定创建哪个类的实例，也无法在创建对象时进行一些额外的逻辑处理。</li></ul><p>因此，在很多设计模式和框架中，会使用其他方式来代替 <code>new</code>，比如：</p><ul><li><strong>反射</strong>：通过 <code>Class.forName().newInstance()</code> 来创建对象。</li><li><strong>工厂模式</strong>：通过工厂方法或抽象工厂来创建对象。</li><li><strong>依赖注入（DI）框架</strong>：如 Spring 框架，通过配置文件或注解自动创建和管理对象。</li></ul><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ul><li><pre><code class="language-java"> /**  * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。  */ public final native Class&lt;?&gt; getClass() /**  * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。  */ public native int hashCode() /**  * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。  */ public boolean equals(Object obj) /**  * native 方法，用于创建并返回当前对象的一份拷贝。  */ protected native Object clone() throws CloneNotSupportedException /**  * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。  */ public String toString() /**  * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。  */ public final native void notify() /**  * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。  */ public final native void notifyAll() /**  * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。  */ public final native void wait(long timeout) throws InterruptedException /**  * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。  */ public final void wait(long timeout, int nanos) throws InterruptedException /**  * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念  */ public final void wait() throws InterruptedException /**  * 实例被垃圾回收器回收的时候触发的操作  */ protected void finalize() throws Throwable &#123; &#125; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    ------</span><br><span class="line"></span><br><span class="line">    ## `Object` 类的所有方法</span><br><span class="line"></span><br><span class="line">    #### 1. `public final native Class&lt;?&gt; getClass()`</span><br><span class="line"></span><br><span class="line">    返回当前正在运行的对象的 **Class** 对象。这个方法是 **final** 的，这意味着你不能重写它。它通常用于反射（Reflection），让你在运行时获取对象的类型信息。</span><br><span class="line"></span><br><span class="line">    #### 2. `public native int hashCode()`</span><br><span class="line"></span><br><span class="line">    返回对象的 **哈希码** 值。这个哈希值通常用于基于哈希的集合，如 `HashMap`、`HashSet` 和 `HashTable`。**hashCode() 和 equals() 必须保持一致**：如果两个对象 `equals()` 返回 `true`，那么它们的 `hashCode()` 也必须相等。</span><br><span class="line"></span><br><span class="line">    #### 3. `public boolean equals(Object obj)`</span><br><span class="line"></span><br><span class="line">    比较两个对象是否相等。**Object** 类的默认实现是比较两个对象的**内存地址**。通常情况下，为了比较对象的内容，你需要根据业务逻辑**重写**这个方法。</span><br><span class="line"></span><br><span class="line">    #### 4. `protected native Object clone() throws CloneNotSupportedException`</span><br><span class="line"></span><br><span class="line">    创建并返回当前对象的**浅拷贝**。要使用 `clone()` 方法，你的类必须实现**`Cloneable`**接口，否则会抛出 `CloneNotSupportedException` 异常。</span><br><span class="line"></span><br><span class="line">    #### 5. `public String toString()`</span><br><span class="line"></span><br><span class="line">    返回对象的字符串表示。默认返回 `“类名@对象的哈希码的无符号十六进制表示”`。为了提供有意义的字符串描述，通常需要**重写**这个方法。</span><br><span class="line"></span><br><span class="line">    #### 6. `public final native void notify()`</span><br><span class="line"></span><br><span class="line">    唤醒在此对象监视器（monitor）上等待的**一个**线程。这个方法必须在 `synchronized` 代码块中调用，否则会抛出 `IllegalMonitorStateException`。</span><br><span class="line"></span><br><span class="line">    #### 7. `public final native void notifyAll()`</span><br><span class="line"></span><br><span class="line">    唤醒在此对象监视器上等待的**所有**线程。与 `notify()` 一样，它也必须在 `synchronized` 代码块中调用。</span><br><span class="line"></span><br><span class="line">    #### 8. `public final native void wait(long timeout) throws InterruptedException`</span><br><span class="line"></span><br><span class="line">    让当前线程进入等待状态，并释放它所持有的锁，直到其他线程调用 `notify()` 或 `notifyAll()`，或者等待时间超时。</span><br><span class="line"></span><br><span class="line">    #### 9. `public final void wait() throws InterruptedException`</span><br><span class="line"></span><br><span class="line">    与 `wait(long timeout)` 类似，但它会**无限期**地等待，直到被唤醒。</span><br><span class="line"></span><br><span class="line">    #### 10. `public final void wait(long timeout, int nanos) throws InterruptedException`</span><br><span class="line"></span><br><span class="line">    更精确的 `wait()` 方法，允许以毫秒和纳秒为单位指定等待时间。</span><br><span class="line"></span><br><span class="line">    #### 11. `protected void finalize() throws Throwable`</span><br><span class="line"></span><br><span class="line">    当垃圾回收器确定没有对该对象的引用时，垃圾回收器会在该对象上调用此方法。这个方法用于在对象被销毁前执行一些清理工作。**不推荐**使用 `finalize()`，因为它不保证何时执行，甚至可能不执行，并且会影响垃圾回收性能。现代 Java 中应使用 `try-with-resources` 或其他资源管理方式。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">## **String 类型**</span><br><span class="line"></span><br><span class="line">### 1. 字节和字符的区别？</span><br><span class="line"></span><br><span class="line">字节是存储容量的基本单位；字符是数字、字母、汉字以及其他语言的各种符号；1 字节 = 8 个二进制单位，一个字符由一个字节或多个字节的二进制单位组成。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 2. String 为什么要设计为不可变类？</span><br><span class="line"></span><br><span class="line">在 Java 中将 String 设计成不可变的是综合考虑到各种因素的结果。主要的原因主要有以下三点：</span><br><span class="line"></span><br><span class="line">- **字符串常量池的需要**：字符串常量池是 Java 堆内存中一个特殊的存储区域, 当创建一个 String 对象时，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象；</span><br><span class="line">- **允许 String 对象缓存 HashCode**：Java 中 String 对象的哈希码被频繁地使用, 比如在 HashMap 等容器中。字符串不变性保证了 hash 码的唯一性，因此可以放心地进行缓存。这也是一种性能优化手段，意味着不必每次都去计算新的哈希码；</span><br><span class="line">- **String 被许多的 Java 类(库)用来当做参数**，例如：网络连接地址 URL、文件路径 path、还有反射机制所需要的 String 参数等, 假若 String 不是固定不变的，将会引起各种安全隐患。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 3. String、StringBuilder、StringBuffer 的区别？</span><br><span class="line"></span><br><span class="line">string类不能被继承，因为被final修饰</span><br><span class="line"></span><br><span class="line">- **String**：用于字符串操作，属于不可变类；【补充：String 不是基本数据类型，是引用类型，底层用 char 数组实现的】</span><br><span class="line">- **StringBuilder**：与 StringBuffer 类似，都是字符串缓冲区，但线程不安全；</span><br><span class="line">- **StringBuffer**：也用于字符串操作，不同之处是 StringBuffer 属于可变类，对方法加了同步锁，线程安全</span><br><span class="line"></span><br><span class="line">StringBuffer的补充说明：StringBuffer 中并不是所有方法都使用了 Synchronized 修饰来实现同步：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Override public StringBuffer insert(int dstOffset, CharSequence s) &#123; // Note, synchronization achieved via invocations of other StringBuffer methods // after narrowing of s to specific type // Ditto for toStringCache clearing super.insert(dstOffset, s); return this; &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>执行效率：StringBuilder &gt; StringBuffer &gt; String</p><hr><h3 id="4-String-字符串修改实现的原理？"><a href="#4-String-字符串修改实现的原理？" class="headerlink" title="4. String 字符串修改实现的原理？"></a>4. String 字符串修改实现的原理？</h3><p>当用 String 类型来对字符串进行修改时，其实现方法是首先创建一个 StringBuffer，其次调用 StringBuffer 的 <code>append()</code> 方法，最后调用 StringBuffer 的 <code>toString()</code> 方法把结果返回。</p><hr><h3 id="5-String-str-“i”-与-String-str-new-String-“i”-一样吗？"><a href="#5-String-str-“i”-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="5. String str &#x3D; “i” 与 String str &#x3D; new String(“i”) 一样吗？"></a>5. String str &#x3D; “i” 与 String str &#x3D; new String(“i”) 一样吗？</h3><p>不一样，因为内存的分配方式不一样。<code>String str = &quot;i&quot;</code> 的方式，Java 虚拟机会将其分配到常量池中；而 <code>String str = new String(&quot;i&quot;)</code> 则会被分到堆内存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(str1 == str2);</span><br><span class="line">        System.out.println(str1 == str3);</span><br><span class="line">        System.out.println(str3 == str4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(str3.equals(str4)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在执行 <code>String str1 = &quot;abc&quot;</code> 的时候，JVM 会首先检查字符串常量池中是否已经存在该字符串对象，如果已经存在，那么就不会再创建了，直接返回该字符串在字符串常量池中的内存地址；如果该字符串还不存在字符串常量池中，那么就会在字符串常量池中创建该字符串对象，然后再返回。所以在执行 <code>String str2 = &quot;abc&quot;</code> 的时候，因为字符串常量池中已经存在“abc”字符串对象了，就不会在字符串常量池中再次创建了，所以栈内存中 str1 和 str2 的内存地址都是指向 “abc” 在字符串常量池中的位置，所以 <code>str1 = str2</code> 的运行结果为 true。</p><p>而在执行 <code>String str3 = new String(&quot;abc&quot;)</code> 的时候，JVM 会首先检查字符串常量池中是否已经存在“abc”字符串，如果已经存在，则不会在字符串常量池中再创建了；如果不存在，则就会在字符串常量池中创建 “abc” 字符串对象，然后再到堆内存中再创建一份字符串对象，把字符串常量池中的 “abc” 字符串内容拷贝到内存中的字符串对象中，然后返回堆内存中该字符串的内存地址，即栈内存中存储的地址是堆内存中对象的内存地址。<code>String str4 = new String(&quot;abc&quot;)</code> 是在堆内存中又创建了一个对象，所以 <code>str3 == str4</code> 运行的结果是 false。str1、str2、str3、str4 在内存中的存储状况如下图所示：</p><hr><h3 id="6-String-类的常用方法都有那些？"><a href="#6-String-类的常用方法都有那些？" class="headerlink" title="6. String 类的常用方法都有那些？"></a>6. String 类的常用方法都有那些？</h3><ul><li><code>indexOf()</code>：返回指定字符的索引。</li><li><code>charAt()</code>：返回指定索引处的字符。</li><li><code>replace()</code>：字符串替换。</li><li><code>trim()</code>：去除字符串两端空白。</li><li><code>split()</code>：分割字符串，返回一个分割后的字符串数组。</li><li><code>getBytes()</code>：返回字符串的 byte 类型数组。</li><li><code>length()</code>：返回字符串长度。</li><li><code>toLowerCase()</code>：将字符串转成小写字母。</li><li><code>toUpperCase()</code>：将字符串转成大写字符。</li><li><code>substring()</code>：截取字符串。</li><li><code>equals()</code>：字符串比较。</li></ul><hr><h3 id="7-final-修饰-StringBuffer-后还可以-append-吗？"><a href="#7-final-修饰-StringBuffer-后还可以-append-吗？" class="headerlink" title="7. final 修饰 StringBuffer 后还可以 append 吗？"></a>7. final 修饰 StringBuffer 后还可以 append 吗？</h3><p>可以。<code>final</code> 修饰的是一个引用变量，那么这个引用始终只能指向这个对象，但是这个对象内部的属性是可以变化的。</p><p>官方文档解释：<code>once a final variable has been assigned, it always contains the same value. If a final variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object.</code></p><p><code>String</code> 是一个非常特殊的类型，它<strong>不是基本数据类型</strong>，而是一个<strong>引用数据类型（Reference Data Type）</strong>。</p><h4 id="String-的核心特性"><a href="#String-的核心特性" class="headerlink" title="String 的核心特性"></a><strong>String 的核心特性</strong></h4><ol><li><strong>不可变性（Immutability）</strong><ul><li><code>String</code> 对象一旦被创建，它的值就不能被改变。</li><li>当你对 <code>String</code> 进行修改操作时，比如拼接字符串，实际上是<strong>创建了一个新的 String 对象</strong>，而原始对象没有改变。</li><li>这种不可变性使得 <code>String</code> 对象是线程安全的，可以在多线程环境中被安全地共享。</li></ul></li><li><strong>String 的创建</strong><ul><li><strong>字面量方式</strong>：<code>String s = &quot;hello&quot;;</code><ul><li>这种方式创建的字符串会被存储在**字符串常量池（String Pool）**中。</li><li>当创建第二个值为 <code>&quot;hello&quot;</code> 的字符串时，JVM 会直接从常量池中返回已存在的对象引用，而不会创建新的对象。这是一种重要的内存优化。</li></ul></li><li><strong>new 关键字方式</strong>：<code>String s = new String(&quot;hello&quot;);</code><ul><li>这种方式会创建一个新的 <code>String</code> 对象在堆（Heap）中。即使常量池中已经存在 <code>&quot;hello&quot;</code>，也会在堆中再创建一个新的对象。</li></ul></li></ul></li></ol><h4 id="String-的常用方法"><a href="#String-的常用方法" class="headerlink" title="String 的常用方法"></a><strong>String 的常用方法</strong></h4><ul><li><strong>拼接</strong>：<ul><li>使用 <code>+</code> 运算符：<code>String s3 = s1 + s2;</code></li><li>使用 <code>concat()</code> 方法：<code>s1.concat(s2);</code></li><li>推荐使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 进行大量字符串拼接，因为它们是可变的，效率更高。</li></ul></li><li><strong>比较</strong>：<ul><li><code>equals()</code>：比较字符串的内容，返回 <code>boolean</code> 类型。</li><li><code>equalsIgnoreCase()</code>：忽略大小写比较字符串内容。</li><li><code>==</code>：比较的是<strong>对象的引用地址</strong>，只有当两个引用指向同一个对象时才为 <code>true</code>。</li></ul></li><li><strong>查找</strong>：<ul><li><code>indexOf(char)</code>：查找字符第一次出现的索引。</li><li><code>contains(String)</code>：判断是否包含某个子字符串。</li></ul></li><li><strong>修改</strong>：<ul><li><code>replace(oldChar, newChar)</code>：替换字符串中的字符。</li><li><code>substring(beginIndex, endIndex)</code>：截取子字符串。</li></ul></li></ul><h4 id="为什么不用-char-数组代替-String？"><a href="#为什么不用-char-数组代替-String？" class="headerlink" title="为什么不用 char 数组代替 String？"></a><strong>为什么不用 char 数组代替 String？</strong></h4><p>虽然 <code>String</code> 内部也是用 <code>char</code> 数组实现的，但 <code>String</code> 的不可变性提供了很多优势：</p><ul><li><strong>安全性</strong>：作为方法参数时，可以防止方法内部修改原始字符串。</li><li><strong>线程安全</strong>：可以在多线程环境下共享。</li><li><strong>哈希码缓存</strong>：<code>String</code> 的哈希码会被缓存，在作为 <code>HashMap</code> 的键时，性能更好。</li></ul><hr><h3 id="基本类型与-String-的转换"><a href="#基本类型与-String-的转换" class="headerlink" title="基本类型与 String 的转换"></a><strong>基本类型与 String 的转换</strong></h3><ul><li><strong>基本类型转 String</strong>：<ul><li><code>String.valueOf(int i)</code></li><li><code>Integer.toString(int i)</code></li><li><code>&quot;&quot; + i</code></li></ul></li><li><strong>String 转基本类型</strong>：<ul><li><code>Integer.parseInt(&quot;123&quot;)</code></li><li><code>Double.parseDouble(&quot;3.14&quot;)</code></li><li><code>Float.parseFloat(&quot;1.23&quot;)</code></li><li>等等。</li></ul></li></ul><blockquote><p><strong>注意</strong>：<code>String</code> 转基本类型时，如果字符串格式不正确，会抛出 <code>NumberFormatException</code>。</p></blockquote><p><code>&amp;</code> 和 <code>&amp;&amp;</code> 在 Java 中都是逻辑与运算符，但它们之间有一个至关重要的区别：<strong>短路特性</strong>。</p><hr><h3 id="（逻辑与-按位与）"><a href="#（逻辑与-按位与）" class="headerlink" title="&amp;（逻辑与 &#x2F; 按位与）"></a><code>&amp;</code>（逻辑与 &#x2F; 按位与）</h3><p><code>&amp;</code> 运算符有两种不同的用途，取决于它的操作数类型。</p><p><strong>1. 逻辑与（当操作数为 boolean 类型时）</strong></p><p>当 <code>&amp;</code> 的两边是布尔表达式时，它执行<strong>非短路逻辑与</strong>。这意味着无论第一个表达式的结果是 <code>true</code> 还是 <code>false</code>，它都会<strong>继续计算</strong>第二个表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> &amp; (++a &gt; <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="comment">// 即使第一个表达式是 true，第二个表达式 (++a &gt; 10) 也会被执行。</span></span><br><span class="line">    <span class="comment">// a 的值会变为 11。</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a); <span class="comment">// 输出 11</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>++a</code> 总是会被执行，<code>a</code> 的值最终会增加。</p><p><strong>2. 按位与（当操作数为整数类型时）</strong></p><p>当 <code>&amp;</code> 的两边是整数类型（如 <code>int</code>, <code>long</code> 等）时，它执行<strong>按位与运算</strong>。它将两个数的二进制位进行比较，如果对应的位都是 <code>1</code>，则结果位是 <code>1</code>，否则是 <code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 二进制 0101</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">// 二进制 0011</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x &amp; y; <span class="comment">// 二进制 0001</span></span><br><span class="line">System.out.println(result); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><h3 id="（短路逻辑与）"><a href="#（短路逻辑与）" class="headerlink" title="&amp;&amp;（短路逻辑与）"></a><code>&amp;&amp;</code>（短路逻辑与）</h3><p><code>&amp;&amp;</code> 运算符只用于布尔类型的操作，它执行<strong>短路逻辑与</strong>。</p><p>**短路（Short-circuiting）**是 <code>&amp;&amp;</code> 最重要的特性。如果第一个表达式的结果是 <code>false</code>，那么整个表达式的结果必定是 <code>false</code>，因此 <code>&amp;&amp;</code> 会立即停止计算，<strong>不再执行</strong>第二个表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span> &amp;&amp; (++a &gt; <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="comment">// 第一个表达式是 false，整个条件已确定为 false。</span></span><br><span class="line">    <span class="comment">// 第二个表达式 (++a &gt; 10) 不会被执行。</span></span><br><span class="line">    <span class="comment">// a 的值保持不变。</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a); <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>++a</code> 永远不会被执行，因为它位于短路操作的右侧。</p><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th><code>&amp;</code></th><th><code>&amp;&amp;</code></th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>逻辑与、按位与</td><td>仅为逻辑与</td></tr><tr><td><strong>短路</strong></td><td>不短路</td><td>短路</td></tr><tr><td><strong>计算</strong></td><td>始终计算第二个表达式</td><td>当第一个表达式为 <code>false</code> 时，不计算第二个表达式</td></tr><tr><td><strong>适用类型</strong></td><td><code>boolean</code> 和整数类型</td><td>仅 <code>boolean</code></td></tr><tr><td><strong>性能</strong></td><td>可能比 <code>&amp;&amp;</code> 慢（如果第一个表达式为 <code>false</code>）</td><td>通常比 <code>&amp;</code> 快（当第一个表达式为 <code>false</code> 时）</td></tr></tbody></table><p>在日常开发中，<strong>优先使用 &amp;&amp;</strong>。因为它能提高代码效率，并在避免 <code>NullPointerException</code> 等问题时非常有用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 &amp;&amp; 避免空指针异常</span></span><br><span class="line"><span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 list 为 null，第二个表达式不会被执行，程序不会报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>&amp;</code> 通常只在需要<strong>两个表达式都必须执行</strong>的特定场景下使用，或者用于按位运算。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="C:\Users\19501\Desktop\types-of-exceptions-in-java.png" alt="types-of-exceptions-in-java"></p><h3 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a><a href="#exception-%E5%92%8C-error-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Exception 和 Error 有什么区别？</a></h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong>Exception</strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong>Error</strong>：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h3 id="⭐️Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#⭐️Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="⭐️Checked Exception 和 Unchecked Exception 有什么区别？"></a><a href="#%E2%AD%90%EF%B8%8Fchecked-exception-%E5%92%8C-unchecked-exception-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">⭐️Checked Exception 和 Unchecked Exception 有什么区别？</a></h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。 </p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul><hr><h3 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a><a href="#throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">Throwable 类常用方法有哪些？</a></h3><ul><li><code>String getMessage()</code>: 返回异常发生时的详细信息</li><li><code>String toString()</code>: 返回异常发生时的简要描述</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h3 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a><a href="#try-catch-finally-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">try-catch-finally 如何使用？</a></h3><hr><p><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</p><p><code>catch</code>块：用于处理 try 捕获到的异常。</p><p><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p><h3 id="5-Error-和-Exception-的区别？"><a href="#5-Error-和-Exception-的区别？" class="headerlink" title="5. Error 和 Exception 的区别？"></a>5. Error 和 Exception 的区别？</h3><p>Error 类和 Exception 类的父类都是 Throwable 类。主要区别如下：</p><ul><li><strong>Error 类</strong>：一般是指与虚拟机相关的问题，如：系统崩溃、虚拟机错误、内存空间不足、方法调用栈溢出等。这类错误将会导致应用程序中断，仅靠程序本身无法恢复和预防；</li><li><strong>Exception 类</strong>：分为运行时异常和受检查的异常。</li></ul><hr><h3 id="6-运行时异常与受检异常有何异同？"><a href="#6-运行时异常与受检异常有何异同？" class="headerlink" title="6. 运行时异常与受检异常有何异同？"></a>6. 运行时异常与受检异常有何异同？</h3><ul><li><strong>运行时异常</strong>：如：空指针异常、指定的类找不到、数组越界、方法传递参数错误、数据类型转换错误。可以编译通过，但是一运行就停止了，程序不会自己处理；</li><li><strong>受检查异常</strong>：要么用 <code>try ... catch...</code> 捕获，要么用 <code>throws</code> 声明抛出，交给父类处理。</li></ul><hr><h3 id="7-throw-和-throws-的区别？"><a href="#7-throw-和-throws-的区别？" class="headerlink" title="7. throw 和 throws 的区别？"></a>7. throw 和 throws 的区别？</h3><ul><li><strong>throw</strong>：在方法体内部，表示抛出异常，由方法体内部的语句处理；<code>throw</code> 是具体向外抛出异常的动作，所以它抛出一个异常实例；</li><li><strong>throws</strong>：在方法声明后面，表示如果抛出异常，由该方法的调用者来处理；表示出现异常的可能性，并不一定会发生这种异常。</li></ul><hr><h3 id="8-常见的异常类有哪些？"><a href="#8-常见的异常类有哪些？" class="headerlink" title="8. 常见的异常类有哪些？"></a>8. 常见的异常类有哪些？</h3><ul><li><strong>NullPointerException</strong>：当应用程序试图访问空对象时，则抛出该异常。</li><li><strong>SQLException</strong>：提供关于数据库访问错误或其他错误信息的异常。</li><li><strong>IndexOutOfBoundsException</strong>：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li><li><strong>FileNotFoundException</strong>：当试图打开指定路径名表示的文件失败时，抛出此异常。</li><li><strong>IOException</strong>：当发生某种 I&#x2F;O 异常时，抛出此异常。此类是失败或中断的 I&#x2F;O 操作生成的异常的通用类。</li><li><strong>ClassCastException</strong>：当试图将对象强制转换为不是实例的子类时，抛出该异常。</li><li><strong>IllegalArgumentException</strong>：抛出的异常表明向方法传递了一个不合法或不正确的参数。</li></ul><hr><h3 id="9-主线程可以捕获到子线程的异常吗？"><a href="#9-主线程可以捕获到子线程的异常吗？" class="headerlink" title="9. 主线程可以捕获到子线程的异常吗？"></a>9. 主线程可以捕获到子线程的异常吗？</h3><p>线程设计的理念：“线程的问题应该线程它自己本身来解决，而不要委托到外部”。</p><p>正常情况下，如果不做特殊的处理，在主线程中是不能够捕获到子线程中的异常的。如果想要在主线程中捕获子线程的异常，我们可以用如下的方式进行处理，使用 <code>Thread</code> 的静态方法 <code>Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandle());</code>通常情况下，主线程<strong>不能直接</strong>捕获到子线程中抛出的异常。这是因为线程是独立的执行流，每个线程都有自己的调用栈。当子线程中发生异常时，如果该异常没有被子线程内部的 <code>try-catch</code> 块捕获，它会沿着子线程的调用栈向上冒泡，最终导致子线程终止。这个异常不会传递到主线程的调用栈中，因此主线程无法感知或捕获它。</p><p>这个设计理念被称为“线程的问题应该由线程自己本身来解决，而不是委托到外部”。</p><hr><h3 id="捕获子线程异常的方法"><a href="#捕获子线程异常的方法" class="headerlink" title="捕获子线程异常的方法"></a>捕获子线程异常的方法</h3><p>虽然主线程无法直接捕获子线程异常，但 Java 提供了两种机制来处理这种情况，允许你在主线程或其他线程中对子线程的异常进行处理：</p><h4 id="1-使用-try-catch-在子线程内部处理"><a href="#1-使用-try-catch-在子线程内部处理" class="headerlink" title="1. 使用 try-catch 在子线程内部处理"></a>1. 使用 <code>try-catch</code> 在子线程内部处理</h4><p>这是最直接也最推荐的方式。在子线程的 <code>run()</code> 方法中，用 <code>try-catch</code> 块将可能抛出异常的代码包围起来。这样，异常就会在子线程内部被捕获并处理，你可以选择记录日志、发送通知，或者执行其他恢复操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能会抛出异常的代码</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception from child thread&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 在子线程中捕获并处理异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;子线程捕获到异常: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-设置未捕获异常处理器-UncaughtExceptionHandler"><a href="#2-设置未捕获异常处理器-UncaughtExceptionHandler" class="headerlink" title="2. 设置未捕获异常处理器 (UncaughtExceptionHandler)"></a>2. 设置未捕获异常处理器 (<code>UncaughtExceptionHandler</code>)</h4><p>当你无法在子线程内部处理所有异常时，可以使用 <code>UncaughtExceptionHandler</code>。这是一个在线程因未捕获异常而突然终止时被调用的回调接口。你可以为每个线程或所有线程设置一个默认的处理器。</p><p><strong>A. 为单个线程设置处理器</strong></p><p>你可以为特定的 <code>Thread</code> 实例设置一个 <code>UncaughtExceptionHandler</code>。当该线程发生未捕获异常时，JVM 会调用你提供的处理器的 <code>uncaughtException()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception from child thread!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;在主线程中捕获到子线程 [&quot;</span> + t.getName() + <span class="string">&quot;] 的异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p><strong>B. 为所有线程设置默认处理器</strong></p><p>如果你想为所有线程（包括线程池中的线程）设置一个通用的异常处理逻辑，可以使用 <code>Thread.setDefaultUncaughtExceptionHandler()</code>。这个处理器会在没有任何特定处理器的线程上被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主线程中设置全局默认处理器</span></span><br><span class="line">Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;全局处理器捕获到线程 [&quot;</span> + t.getName() + <span class="string">&quot;] 的异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程中抛出未处理的异常</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Global uncaught exception&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>主线程</strong>不能直接捕获<strong>子线程</strong>的异常，因为它们是独立的执行流。</li><li>要处理子线程的异常，最简单的方法是<strong>在子线程内部使用 try-catch 块</strong>。</li><li>如果需要在主线程中感知和处理子线程的异常，可以使用 <code>Thread</code> 提供的**<code>UncaughtExceptionHandler</code>**机制。你可以为特定线程或所有线程设置一个处理器，当线程因未捕获异常而终止时，这个处理器会被调用。</li></ul><hr><h2 id="创建对象："><a href="#创建对象：" class="headerlink" title="创建对象："></a>创建对象：</h2><p>好的，Java 中创建对象的方式有多种，除了最常见的 <code>new</code> 关键字，还有其他几种重要的技术。下面我们来详细解析这四种创建对象的方法。</p><hr><h3 id="1-使用-new-关键字"><a href="#1-使用-new-关键字" class="headerlink" title="1. 使用 new 关键字"></a>1. 使用 <code>new</code> 关键字</h3><p>这是最常见、最直接的创建对象方式。当你使用 <code>new</code> 关键字时，它会调用类的<strong>构造器</strong>来初始化对象。</p><p><strong>原理：</strong></p><ol><li><strong>分配内存：</strong> JVM 在堆（Heap）上为新对象分配所需的内存空间。</li><li><strong>默认初始化：</strong> 成员变量会被赋予默认值（例如，<code>int</code> 为 <code>0</code>，<code>boolean</code> 为 <code>false</code>，引用类型为 <code>null</code>）。</li><li><strong>调用构造器：</strong> JVM 调用指定的构造器来执行初始化代码。构造器中的代码会覆盖之前的默认值。</li><li><strong>返回引用：</strong> 对象创建完成后，<code>new</code> 表达式会返回该对象在内存中的引用。</li></ol><p><strong>优点：</strong></p><ul><li>简单直观，代码可读性好。</li><li>可以调用任何可访问的构造器（包括有参和无参）。</li></ul><p><strong>缺点：</strong></p><ul><li>每次调用 <code>new</code> 都会创建一个新对象，开销较大。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 new 关键字创建对象</span></span><br><span class="line"><span class="type">MyObject</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line"><span class="type">MyObject</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="2-使用-Class-类的-newInstance-方法（反射）"><a href="#2-使用-Class-类的-newInstance-方法（反射）" class="headerlink" title="2. 使用 Class 类的 newInstance() 方法（反射）"></a>2. 使用 <code>Class</code> 类的 <code>newInstance()</code> 方法（反射）</h3><p><code>Class.forName().newInstance()</code> 是通过<strong>反射</strong>来创建对象的方式。</p><p><strong>原理：</strong></p><ol><li><strong>加载类：</strong> <code>Class.forName()</code> 方法根据类的全限定名（如 <code>&quot;com.example.MyObject&quot;</code>）加载类，并返回对应的 <code>Class</code> 对象。</li><li><strong>创建实例：</strong> <code>newInstance()</code> 方法会调用该类的<strong>无参构造器</strong>来创建对象。</li></ol><p><strong>注意：</strong></p><ul><li><code>newInstance()</code> 要求类必须有一个无参的构造器，且该构造器必须是可见的（<code>public</code>）。</li><li>Java 9 之后，<code>Class.newInstance()</code> 被标记为<strong>过时（deprecated）</strong>。</li><li>在现代 Java 中，更推荐使用 <code>Constructor</code> 类的 <code>newInstance()</code> 方法，因为它能够调用<strong>有参</strong>构造器，并且可以处理构造器抛出的异常。</li></ul><p><strong>优点：</strong></p><ul><li>可以在运行时动态地创建对象，非常灵活。</li><li>适用于工厂模式、依赖注入（如 Spring）等场景。</li></ul><p><strong>缺点：</strong></p><ul><li>性能比 <code>new</code> 关键字差，因为涉及反射机制。</li><li>如果类没有无参构造器或构造器不可访问，会抛出异常。</li><li>没有编译时检查，错误只能在运行时发现。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Class.forName().newInstance() 创建对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyObject&quot;</span>);</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">obj</span> <span class="operator">=</span> (MyObject) clazz.newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-使用-clone-方法"><a href="#3-使用-clone-方法" class="headerlink" title="3. 使用 clone() 方法"></a>3. 使用 <code>clone()</code> 方法</h3><p><code>clone()</code> 方法通过<strong>复制</strong>现有对象来创建新对象，而不是重新构造。它属于 <code>Object</code> 类的一个 <code>protected</code> 方法。</p><p><strong>原理：</strong></p><ol><li><strong>实现接口：</strong> 要使用 <code>clone()</code> 方法，你的类必须实现 <code>Cloneable</code> 接口。这个接口是一个<strong>标记接口</strong>，本身没有任何方法，但它告诉 JVM 这个类可以被克隆。</li><li><strong>重写方法：</strong> 你需要重写 <code>Object</code> 类的 <code>clone()</code> 方法，并将其访问修饰符改为 <code>public</code>。</li><li><strong>执行克隆：</strong> <code>clone()</code> 方法会创建一个新对象，并将现有对象的字段值<strong>逐一复制</strong>到新对象中。这是一种<strong>浅拷贝（shallow copy）</strong>。如果你的对象包含引用类型的成员，那么新对象和旧对象将共享同一个引用。</li></ol><p><strong>优点：</strong></p><ul><li>克隆一个对象比使用 <code>new</code> 关键字创建对象更快，因为它跳过了构造器的初始化过程。</li><li>在需要大量创建相同或相似对象时，是一种有效的性能优化手段。</li></ul><p><strong>缺点：</strong></p><ul><li><code>clone()</code> 方法默认是浅拷贝，如果需要深拷贝（deep copy），需要手动实现。</li><li><code>Cloneable</code> 接口和 <code>clone()</code> 方法的设计有些“反直觉”，容易出现问题。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类需要实现 Cloneable 接口并重写 clone() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 clone() 方法创建对象</span></span><br><span class="line"><span class="type">MyObject</span> <span class="variable">original</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyObject) original.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-反序列化（Deserialization）"><a href="#4-反序列化（Deserialization）" class="headerlink" title="4. 反序列化（Deserialization）"></a>4. 反序列化（Deserialization）</h3><p>反序列化是指将字节流<strong>恢复成</strong> Java 对象的过程。</p><p><strong>原理：</strong></p><ol><li><strong>序列化：</strong> 首先，一个对象必须是**可序列化（<code>Serializable</code>）**的，即它实现了 <code>Serializable</code> 接口。</li><li><strong>写入流：</strong> 序列化就是将对象的状态（成员变量的值）写入一个字节流中（例如，写入文件或网络）。</li><li><strong>反序列化：</strong> 反序列化则是从字节流中读取数据，并重建（re-create）原始对象。这个过程<strong>不会调用构造器</strong>。</li></ol><p><strong>优点：</strong></p><ul><li>可以将对象持久化到磁盘或在网络中传输，这对于分布式系统和缓存非常重要。</li><li>可以跨进程甚至跨机器传输对象。</li></ul><p><strong>缺点：</strong></p><ul><li>只有实现了 <code>Serializable</code> 接口的类才能进行序列化和反序列化。</li><li>如果对象的版本不兼容，反序列化可能会失败。</li><li>存在安全风险，因为它能够绕过构造器，如果设计不当可能导致不一致的状态。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象必须实现 Serializable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>))) &#123;</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> <span class="title class_">MyObject</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">obj</span> <span class="operator">=</span> (MyObject) ois.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>这四种创建对象的方式各有优劣和适用场景：</p><ul><li><strong>new</strong>：最常用，用于<strong>常规</strong>的对象创建。</li><li><strong>反射</strong>：用于<strong>运行时动态</strong>创建对象，常用于框架开发。</li><li><strong>clone()</strong>：用于<strong>快速复制</strong>现有对象，以提高性能。</li><li><strong>反序列化</strong>：用于将对象<strong>持久化</strong>或在<strong>网络传输</strong>中重建。</li></ul><p>理解这些创建对象的方式，可以让你在不同的编程场景中做出更明智的选择。</p><p>深拷贝和浅拷贝是 Java 对象复制时需要理解的两个重要概念。它们主要通过 <code>clone()</code> 方法或序列化来实现。</p><h3 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h3><p><strong>浅拷贝</strong>只复制对象本身，以及其基本数据类型的字段。对于引用类型的字段，它<strong>只复制引用地址</strong>，新旧对象会共享同一块内存中的引用数据。</p><h4 id="实现方式：clone-方法"><a href="#实现方式：clone-方法" class="headerlink" title="实现方式：clone() 方法"></a>实现方式：<code>clone()</code> 方法</h4><p>Java 中的浅拷贝通常通过实现 <code>Cloneable</code> 接口并重写 <code>Object</code> 类的 <code>clone()</code> 方法来实现。</p><p><strong>步骤：</strong></p><ol><li>让你的类实现 <code>java.lang.Cloneable</code> 接口。这是一个标记接口，告诉 JVM 这个类的实例可以被克隆。</li><li>重写 <code>Object</code> 类的 <code>clone()</code> 方法，并将其可见性改为 <code>public</code>。</li><li>在重写的方法中调用 <code>super.clone()</code>。</li></ol><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address; <span class="comment">// 引用类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 这是浅拷贝的实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShallowCopyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">originalStudent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Zhangsan&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用浅拷贝</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStudent</span> <span class="operator">=</span> (Student) originalStudent.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 浅拷贝前 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改克隆对象的引用类型字段</span></span><br><span class="line">        clonedStudent.address.city = <span class="string">&quot;Shanghai&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 浅拷贝后 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city); <span class="comment">// 原始对象的地址也变了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- 浅拷贝前 ---</span><br><span class="line">原始学生地址: Beijing</span><br><span class="line">克隆学生地址: Beijing</span><br><span class="line"></span><br><span class="line">--- 浅拷贝后 ---</span><br><span class="line">原始学生地址: Shanghai</span><br><span class="line">克隆学生地址: Shanghai</span><br></pre></td></tr></table></figure><p>可以看到，修改克隆对象的地址，原始对象的地址也随之改变，这正是浅拷贝的特点。</p><hr><h3 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h3><p><strong>深拷贝</strong>会创建一个完全独立的新对象，不仅复制基本数据类型，还会<strong>递归地复制</strong>所有引用类型字段指向的对象。新旧对象之间互不影响。</p><h4 id="实现方式一：手动实现递归复制"><a href="#实现方式一：手动实现递归复制" class="headerlink" title="实现方式一：手动实现递归复制"></a>实现方式一：手动实现递归复制</h4><p>在重写的 <code>clone()</code> 方法中，对引用类型的字段进行<strong>单独的克隆</strong>。</p><p>示例：</p><p>修改上面的 Student 类，实现深拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Address 类也必须重写 clone()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 先进行浅拷贝</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStudent</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">// 然后对引用类型的字段进行深层拷贝</span></span><br><span class="line">        clonedStudent.address = (Address) <span class="built_in">this</span>.address.clone();</span><br><span class="line">        <span class="keyword">return</span> clonedStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCopyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">originalStudent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Zhangsan&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用深拷贝</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStudent</span> <span class="operator">=</span> (Student) originalStudent.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 深拷贝前 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改克隆对象的引用类型字段</span></span><br><span class="line">        clonedStudent.address.city = <span class="string">&quot;Shanghai&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 深拷贝后 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city); <span class="comment">// 原始对象没有改变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- 深拷贝前 ---</span><br><span class="line">原始学生地址: Beijing</span><br><span class="line">克隆学生地址: Beijing</span><br><span class="line"></span><br><span class="line">--- 深拷贝后 ---</span><br><span class="line">原始学生地址: Beijing</span><br><span class="line">克隆学生地址: Shanghai</span><br></pre></td></tr></table></figure><p>这次，修改克隆对象的地址，原始对象没有受到影响。</p><h4 id="实现方式二：序列化与反序列化"><a href="#实现方式二：序列化与反序列化" class="headerlink" title="实现方式二：序列化与反序列化"></a>实现方式二：序列化与反序列化</h4><p>这是一种更简单、通用的深拷贝方法，特别适用于对象结构复杂的情况。</p><p><strong>步骤：</strong></p><ol><li>让所有相关类（包括引用类型）都实现 <code>java.io.Serializable</code> 接口。</li><li>将对象写入一个字节流中（序列化）。</li><li>再从字节流中读出新的对象（反序列化）。</li></ol><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializationDeepCopyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">originalStudent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Zhangsan&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化和反序列化实现深拷贝</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(originalStudent);</span><br><span class="line">        oos.close();</span><br><span class="line">        </span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStudent</span> <span class="operator">=</span> (Student) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 深拷贝前 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改克隆对象的引用类型字段</span></span><br><span class="line">        clonedStudent.address.city = <span class="string">&quot;Shanghai&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 深拷贝后 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法代码虽然多，但对于复杂的对象图来说，它比手动递归实现要简单得多，因为它会自动处理所有嵌套对象的拷贝。</p><h2 id="接口和抽象类："><a href="#接口和抽象类：" class="headerlink" title="接口和抽象类："></a>接口和抽象类：</h2><p>在软件开发中，<strong>抽象类（abstract class）和接口（interface）都是用于实现多态</strong>的重要概念，它们允许你定义一个通用的契约，然后让具体的类去实现这个契约。虽然它们的目的相似，但在用途、设计和实现上存在一些关键区别。</p><hr><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一个不能被实例化的类，它通常包含<strong>抽象方法</strong>（没有具体实现的方法）和<strong>具体方法</strong>（有具体实现的方法）。</p><p><strong>主要特点：</strong></p><ul><li><strong>语法：</strong> 使用 <code>abstract</code> 关键字来声明类和抽象方法。</li><li><strong>方法：</strong> 可以同时包含抽象方法和具体方法。抽象方法必须在子类中被实现，具体方法则可以选择性地被重写。</li><li><strong>成员变量：</strong> 可以包含成员变量，包括 <code>private</code>、<code>protected</code> 和 <code>public</code> 等修饰符。</li><li><strong>继承：</strong> 一个子类<strong>只能继承一个</strong>抽象类。如果子类不是抽象类，它必须实现所有父抽象类中的抽象方法。</li><li><strong>构造器：</strong> 抽象类可以有构造器，但不能直接用 <code>new</code> 关键字来创建实例。它的构造器主要用于在子类中通过 <code>super</code> 关键字调用，以初始化父类的成员。</li><li><strong>目的：</strong> 通常用于定义一类事物共同的<strong>属性和行为</strong>。它代表一种“is-a”（是一种）的关系，比如“猫是一种动物”，<code>Cat</code> 类继承 <code>Animal</code> 抽象类。</li></ul><p>使用场景：</p><p>当你需要定义一个模板，其中一些方法是通用的（已实现），而另一些方法是需要子类根据自身特点去实现的，抽象类是理想选择。例如，一个 Shape 抽象类可以定义一个通用的 draw() 抽象方法，但每个具体的形状（Circle，Rectangle）都有自己独特的绘制方式。同时，它还可以有一个具体的 getColor() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 示例</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法，所有子类都可以直接使用或重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zzz...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof woof&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一个完全抽象的“类”，它定义了一组<strong>契约或规范</strong>，其中只包含抽象方法和常量。自 Java 8 之后，接口也可以包含默认方法（default method）和静态方法。</p><p><strong>主要特点：</strong></p><ul><li><strong>语法：</strong> 使用 <code>interface</code> 关键字声明。</li><li><strong>方法：</strong> 在 Java 8 之前，接口中的方法默认都是 <code>public abstract</code> 的，可以省略这两个关键字。自 Java 8 之后，可以有 <code>default</code> 和 <code>static</code> 方法。自 Java 9 之后，还可以有 <code>private</code> 方法。</li><li><strong>成员变量：</strong> 接口中的成员变量默认是 <code>public static final</code> 的，也即常量。</li><li><strong>实现：</strong> 一个类可以<strong>实现（implements）多个</strong>接口，从而克服了单继承的限制。</li><li><strong>目的：</strong> 主要用于定义一个<strong>能力或行为</strong>。它代表一种“can-do”（能做）的关系，比如一个 <code>Car</code> 类可以实现 <code>Driveable</code> 接口，一个 <code>Bird</code> 类可以实现 <code>Flyable</code> 接口。它是一种对行为的抽象。</li></ul><p>使用场景：</p><p>当你需要定义一种能力，而这种能力可以被不同类别的对象共享时，接口非常有用。例如，Flyable 接口可以被 Airplane、Bird 或 Superman 等完全不相关的类实现，因为它们都具有“飞行”的能力。</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，默认 public abstract</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java 8 之后允许的默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">glide</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Gliding through the air...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Flapping wings to fly.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="核心区别总结"><a href="#核心区别总结" class="headerlink" title="核心区别总结"></a>核心区别总结</h3><table><thead><tr><th>特性</th><th>抽象类（Abstract Class）</th><th>接口（Interface）</th></tr></thead><tbody><tr><td><strong>继承&#x2F;实现</strong></td><td><code>extends</code>，单继承</td><td><code>implements</code>，多实现</td></tr><tr><td><strong>方法</strong></td><td>可包含抽象方法和具体方法</td><td>仅包含抽象方法（Java 8+ 可有 <code>default</code>、<code>static</code> 方法）</td></tr><tr><td><strong>成员变量</strong></td><td>各种类型变量，包括常量和非常量</td><td>只能是 <code>public static final</code> 常量</td></tr><tr><td><strong>构造器</strong></td><td>可以有</td><td>不能有</td></tr><tr><td><strong>可访问性</strong></td><td>成员可以是 <code>private</code>, <code>protected</code> 或 <code>public</code></td><td>方法默认是 <code>public</code>，变量默认是 <code>public static final</code></td></tr><tr><td><strong>目的</strong></td><td>定义一类事物的<strong>共同特征和行为</strong>，代表“is-a”关系</td><td>定义一种<strong>能力或行为</strong>，代表“can-do”关系</td></tr></tbody></table><p>10、抽象类和接口有什么区别？</p><p>（1）抽象类中可以定义构造函数，接口不能定义构造函数； </p><p>（2）抽象类中可以有抽象方法和具体⽅方法，而接口中只能有抽象方法（public abstract）； </p><p>（3）抽象类中的成员权限可以是 public、默认、protected（抽象类中抽象方法就是为了重写，所以不能被 private 修饰），而接口中的成员只可以是 public（方法默认：public abstrat、成员变量默认：public static final）；</p><p> （4）抽象类中可以包含静态方法，而接口中不不可以包含静态方法；</p><p> JDK 8 中的改变：</p><p>1、在 JDK1.8中，允许在接⼝口中包含带有具体实现的⽅方法，使用 default 修饰，这类⽅方法就是默认方法。 2、抽象类中可以包含静态方法，在 JDK1.8 之前接口中不不能包含静态方法，JDK1.8 以后可以包含。之前不能包含是因为，接口不可以实现方法，只可以定义方法，所以不能使用静态方法（因为静态方法必须实现）。现在可以包 含了，只能直接用接口调用静态⽅方法。JDK1.8 仍然不可以包含静态代码块。 </p><h3 id="面试官可能会问的深入问题"><a href="#面试官可能会问的深入问题" class="headerlink" title="面试官可能会问的深入问题"></a>面试官可能会问的深入问题</h3><ul><li><strong>为什么 Java 要同时保留抽象类和接口？</strong><ul><li>抽象类侧重于<strong>代码复用</strong>，通过具体方法减少子类的重复代码，并强制子类实现某些特定行为。</li><li>接口侧重于<strong>功能扩展和解耦</strong>，允许不相关的类拥有相同的行为，实现更灵活的设计，同时避免多继承带来的复杂性。</li></ul></li><li><strong>什么时候用抽象类，什么时候用接口？</strong><ul><li>如果你想在类层次结构中<strong>共享代码</strong>，并且这种关系是一种**“is-a”关系**，使用抽象类。</li><li>如果你想为不相关的类<strong>定义通用的行为</strong>，并且希望一个类能拥有多种能力，使用接口。</li></ul></li><li><strong>Java 8 的默认方法对接口和抽象类的区别有什么影响？</strong><ul><li>默认方法的引入模糊了两者的一些界限，接口现在也可以提供方法的默认实现，使得接口的能力更强。</li><li>但是，本质区别仍然存在：<strong>抽象类可以有状态（非 final 成员变量），而接口不能。</strong> 抽象类可以共享状态和具体实现，接口则更关注行为的契约。</li></ul></li></ul><p>简单来说，抽象类是<strong>模板</strong>，提供了骨架和部分实现；接口是<strong>契约</strong>，只规定了行为。理解了这一点，就能很好地应对这类面试题。</p><hr><p>好的，我帮你系统整理 <strong>代理模式（Proxy Pattern）</strong> 的概念、分类和特点，并附带易懂示例。</p><hr><h1 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h1><p>代理模式是一种 <strong>结构型设计模式</strong>，其核心思想是：<strong>为其他对象提供一种代理以控制对这个对象的访问</strong>。<br> 代理对象（Proxy）充当真实对象（Real Subject）的替身，客户端通过代理访问真实对象，而代理可以在访问前后进行增强操作（如权限校验、延迟加载、日志记录等）。</p><hr><h2 id="1-代理模式的组成"><a href="#1-代理模式的组成" class="headerlink" title="1. 代理模式的组成"></a>1. 代理模式的组成</h2><ol><li><strong>Subject（抽象主题）</strong><ul><li>定义真实对象和代理对象的公共接口，客户端通过这个接口访问对象。</li></ul></li><li><strong>RealSubject（真实主题）</strong><ul><li>真正的业务逻辑对象，实现 Subject 接口。</li></ul></li><li><strong>Proxy（代理类）</strong><ul><li>通过实现 Subject 接口，内部持有 RealSubject 的引用。</li><li>可在调用真实对象方法前后添加额外功能。</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">interface Subject &#123;</span><br><span class="line">    void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 真实对象</span><br><span class="line">class RealSubject implements Subject &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        System.out.println(&quot;真实对象处理请求&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代理对象</span><br><span class="line">class ProxySubject implements Subject &#123;</span><br><span class="line">    private RealSubject real;</span><br><span class="line"></span><br><span class="line">    public ProxySubject(RealSubject real) &#123;</span><br><span class="line">        this.real = real;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        System.out.println(&quot;代理前处理&quot;);</span><br><span class="line">        real.request(); // 调用真实对象</span><br><span class="line">        System.out.println(&quot;代理后处理&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RealSubject real = new RealSubject();</span><br><span class="line">        ProxySubject proxy = new ProxySubject(real);</span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-代理模式的几种类型及特点"><a href="#2-代理模式的几种类型及特点" class="headerlink" title="2. 代理模式的几种类型及特点"></a>2. 代理模式的几种类型及特点</h2><table><thead><tr><th>类型</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>静态代理（Static Proxy）</strong></td><td>- 代理类在编译时就确定- 代理类与真实对象实现相同接口- 优点：简单易懂，编译时检查安全- 缺点：每一个真实对象都需要对应代理类，代理类数量多，扩展性差</td><td>权限控制、日志记录等固定功能的增强</td></tr><tr><td><strong>动态代理（Dynamic Proxy）</strong></td><td>- 运行时创建代理类- Java 提供 <strong>JDK 动态代理</strong>（接口）和 <strong>CGLIB 动态代理</strong>（继承子类）- 优点：减少代理类数量，增强可扩展性- 缺点：运行时生成字节码，性能稍低</td><td>AOP、事务管理、日志记录、RPC 调用</td></tr><tr><td><strong>强制代理（Force Proxy）</strong></td><td>- 真实对象只能通过代理访问- 客户端无法直接访问真实对象</td><td>需要严格控制访问权限的场景</td></tr><tr><td><strong>远程代理（Remote Proxy）</strong></td><td>- 为远程对象提供本地代理，隐藏网络通信细节</td><td>RPC 调用、分布式系统</td></tr><tr><td><strong>虚拟代理（Virtual Proxy）</strong></td><td>- 延迟创建或加载真实对象- 代理对象在需要时才创建真实对象</td><td>大对象延迟加载、懒加载场景</td></tr><tr><td><strong>保护代理（Protection Proxy）</strong></td><td>- 控制真实对象的访问权限- 根据不同用户权限返回不同结果</td><td>权限控制、安全管理</td></tr><tr><td><strong>缓存代理（Cache Proxy）</strong></td><td>- 对结果进行缓存，减少真实对象重复计算</td><td>频繁查询、计算量大的场景</td></tr></tbody></table><hr><h3 id="3-代理模式的优缺点"><a href="#3-代理模式的优缺点" class="headerlink" title="3. 代理模式的优缺点"></a>3. 代理模式的优缺点</h3><p><strong>优点</strong>：</p><ol><li>客户端与真实对象解耦，通过代理可以灵活增强功能。</li><li>可以控制访问、延迟加载、记录日志等。</li><li>增强对象功能而不修改原始类。</li></ol><p><strong>缺点</strong>：</p><ol><li>增加系统复杂性，代理类可能增加额外层次。</li><li>对性能有一定影响（尤其是动态代理或远程代理）。</li></ol><hr><h3 id="如何实现动态代理？"><a href="#如何实现动态代理？" class="headerlink" title="如何实现动态代理？"></a>如何实现动态代理？</h3><p>动态代理的核心思想是在<strong>运行时</strong>创建一个代理对象，用于在不修改原始类代码的情况下，为对象添加额外的功能（如日志记录、性能监控、事务管理等）。Java 提供了两种主要的动态代理实现方式：<strong>JDK 动态代理</strong>和 <strong>CGLIB 动态代理</strong>。</p><p>这里我们重点解析 JDK 动态代理的实现，它依赖于接口。</p><hr><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>JDK 动态代理的实现主要依赖于以下三个核心组件：</p><ol><li><strong>接口 (Interface)</strong>：代理对象和被代理对象必须实现同一个或一组接口。这是 JDK 动态代理的基础，它强制代理对象和被代理对象具有相同的公共行为。</li><li><strong>InvocationHandler</strong>：这是动态代理的<strong>核心处理逻辑</strong>。你需要在其中实现 <code>invoke</code> 方法，这个方法包含了代理对象被调用时要执行的所有逻辑。</li><li><strong>Proxy</strong>：这是一个工具类，用于动态生成代理对象。你不能直接创建代理对象，而是通过 <code>Proxy</code> 类的静态方法来完成。</li></ol><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>动态代理的整个过程可以分为以下几步：</p><ol><li><strong>定义接口</strong>：首先，你需要定义一个接口，声明被代理对象和代理对象共同拥有的方法。</li><li><strong>创建被代理对象（目标对象）</strong>：创建一个类，实现上一步定义的接口，这就是我们真正要代理的对象。</li><li><strong>编写 InvocationHandler</strong>：创建一个处理类，它实现 <code>InvocationHandler</code> 接口，并重写 <code>invoke</code> 方法。在这个方法中，你将：<ul><li>接收被代理对象的实例。</li><li>在调用原始方法<strong>之前</strong>执行一些预处理逻辑。</li><li>通过 <code>method.invoke(目标对象, args)</code> 调用被代理对象的原始方法。</li><li>在调用原始方法<strong>之后</strong>执行一些后处理逻辑。</li></ul></li><li><strong>使用 Proxy 类生成代理对象</strong>：调用 <code>Proxy</code> 类的静态方法 <code>newProxyInstance()</code> 来创建代理对象。这个方法需要三个参数：<ul><li><strong>ClassLoader loader</strong>：用于加载代理类的类加载器。通常使用被代理对象的类加载器。</li><li><strong>Class&lt;?&gt;[] interfaces</strong>：一个接口数组，代理对象需要实现的接口。</li><li><strong>InvocationHandler handler</strong>：实现了 <code>InvocationHandler</code> 的对象，它包含了代理的逻辑。</li></ul></li></ol><hr><h4 id="invoke-方法的参数解析"><a href="#invoke-方法的参数解析" class="headerlink" title="invoke() 方法的参数解析"></a><code>invoke()</code> 方法的参数解析</h4><p><code>InvocationHandler</code> 接口的 <code>invoke()</code> 方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure><ul><li><strong>proxy</strong>：这个参数是<strong>代理对象本身</strong>的引用。在 <code>invoke</code> 方法内部，你应该避免直接调用 <code>proxy</code> 的方法，否则可能导致无限递归调用。</li><li><strong>method</strong>：代表正在被调用的方法，它是 <code>java.lang.reflect.Method</code> 类型的对象。你可以通过它获取方法名、参数类型、返回值类型等信息。</li><li><strong>args</strong>：一个 <code>Object</code> 数组，包含了调用原始方法时传递的所有参数。</li></ul><p>通过以上步骤，JVM 会在运行时动态生成一个实现了指定接口、并继承自 <code>Proxy</code> 类的字节码，将其加载到内存中，并最终返回一个代理对象实例。所有对代理对象方法的调用都会被自动转发到 <code>InvocationHandler</code> 的 <code>invoke</code> 方法中，从而实现了对原始方法的增强和控制。</p><p>Proxy 类的作用是动态创建一个代理对象的类。它提供了许多的方法，但是我们用得最多的就是 <code>newProxyInstance</code> 这个方法：</p><p><code>public static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler handler) throws IllegalArgumentException</code></p><ul><li><code>loader</code>：一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载；</li><li><code>interfaces</code>：一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了。</li><li><code>handler</code>：一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上。</li></ul><p>通过 <code>Proxy.newProxyInstance</code> 创建的代理对象是在 Jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行时动态生成的一个对象。</p><h2 id="成员类："><a href="#成员类：" class="headerlink" title="成员类："></a>成员类：</h2><p>我已经为您将之前关于<strong>成员类分类</strong>的详细解析和表格总结进行了合并，以提供一个更全面、更易于理解的回答。</p><hr><p>在 Java 中，一个类可以定义在另一个类的内部，这种类被称为<strong>成员类（Member Class）</strong>，也被称为<strong>嵌套类（Nested Class）</strong>。根据其定义方式和特性，成员类主要分为以下四种类型：</p><h3 id="1-静态成员类（Static-Member-Class）"><a href="#1-静态成员类（Static-Member-Class）" class="headerlink" title="1. 静态成员类（Static Member Class）"></a>1. 静态成员类（Static Member Class）</h3><p><strong>静态成员类</strong>是使用 <code>static</code> 关键字修饰的内部类。它与外部类的实例没有关联，可以像访问静态变量一样，直接通过外部类名来创建它的实例。</p><ul><li><strong>特点</strong>:<ul><li>无法直接访问外部类的非静态成员，但可以访问外部类的静态成员。</li></ul></li><li><strong>适用场景</strong>:<ul><li>当一个类与外部类逻辑上紧密相关，但又不需要访问外部类的实例成员时，使用静态成员类。它常用于作为外部类的辅助工具类，比如在一个 <code>LinkedList</code> 类中定义一个 <code>Node</code> 静态成员类来表示链表节点。</li></ul></li></ul><h3 id="2-内部类（Inner-Class）"><a href="#2-内部类（Inner-Class）" class="headerlink" title="2. 内部类（Inner Class）"></a>2. 内部类（Inner Class）</h3><p><strong>内部类</strong>是没有被 <code>static</code> 关键字修饰的嵌套类。它与外部类的实例紧密相连，必须依附于一个外部类的实例才能被创建。</p><ul><li><strong>特点</strong>:<ul><li>可以直接访问外部类的<strong>所有成员</strong>，包括私有成员。这是内部类最强大的特性。</li></ul></li><li><strong>适用场景</strong>:<ul><li>当一个类的实例需要直接访问外部类的私有状态时，使用内部类。它常用于实现某些特定功能的回调接口。</li></ul></li></ul><h3 id="3-局部内部类（Local-Inner-Class）"><a href="#3-局部内部类（Local-Inner-Class）" class="headerlink" title="3. 局部内部类（Local Inner Class）"></a>3. 局部内部类（Local Inner Class）</h3><p><strong>局部内部类</strong>是定义在方法或代码块内部的类。它只能在定义它的方法或代码块内部被访问和实例化。</p><ul><li><strong>特点</strong>:<ul><li>无法使用访问修饰符（如 <code>public</code>）。</li><li>可以访问外部类的所有成员，但只能访问其所在方法中的 <strong>final 或事实上的 final</strong> 局部变量。</li></ul></li><li><strong>适用场景</strong>:<ul><li>当某个方法中需要一个只用一次的复杂对象或工具类时，可以使用局部内部类，以避免在类级别创建不必要的成员。</li></ul></li></ul><h3 id="4-匿名内部类（Anonymous-Inner-Class）"><a href="#4-匿名内部类（Anonymous-Inner-Class）" class="headerlink" title="4. 匿名内部类（Anonymous Inner Class）"></a>4. 匿名内部类（Anonymous Inner Class）</h3><p><strong>匿名内部类</strong>是一种没有名字的局部内部类，通常用于创建一个只使用一次的类的实例。</p><ul><li><strong>特点</strong>:<ul><li>没有名字，因此无法被复用。</li><li>必须在<strong>创建实例</strong>的同时定义类的实现。</li><li>无法定义构造器。</li><li>可以实现一个接口或继承一个类。</li></ul></li><li><strong>适用场景</strong>:<ul><li>最常用于实现事件监听器或创建线程，尤其是在需要简洁地实现某个接口的单个方法时。</li></ul></li></ul><hr><h3 id="匿名内部类中的局部变量为什么只能用-final？"><a href="#匿名内部类中的局部变量为什么只能用-final？" class="headerlink" title="匿名内部类中的局部变量为什么只能用 final？"></a>匿名内部类中的局部变量为什么只能用 <code>final</code>？</h3><p>这个限制的根本原因在于<strong>生命周期（Lifecycle）</strong>。</p><ol><li><strong>局部变量的生命周期</strong>：局部变量（如方法中的参数或变量）是在方法被调用时创建的，存储在**栈（Stack）**上。当方法执行完毕，这些变量就会被销毁。</li><li><strong>匿名内部类的生命周期</strong>：匿名内部类的实例通常会作为一个对象被传递或保存，它的生命周期可能<strong>比创建它的方法更长</strong>。例如，你可能会将一个实现了事件监听器的匿名内部类实例作为参数传递给一个 UI 组件，当方法返回后，这个监听器对象可能仍然存在并等待事件触发。</li></ol><p><strong>问题出现：</strong></p><p>如果匿名内部类可以访问和修改一个非 <code>final</code> 的局部变量，那么当创建它的方法执行完毕、局部变量被销毁后，匿名内部类的实例仍然存在。当它试图访问这个已经不存在的变量时，就会引发一个**悬空引用（Dangling Reference）**的错误。</p><p>为了解决这个问题，Java 编译器采取了以下策略：</p><ul><li><strong>将局部变量复制一份</strong>：当匿名内部类访问一个局部变量时，编译器会为它在<strong>堆（Heap）上创建一个副本</strong>。这个副本会和匿名内部类实例一起存储，从而确保匿名内部类在任何时候都能访问到这个值。</li><li><strong>强制 final 保证一致性</strong>：如果允许修改原始的局部变量，而匿名内部类使用的是它的副本，那么就会导致原始变量和副本之间的数据不一致。为了避免这种混乱，Java 强制要求被匿名内部类访问的局部变量必须是 <code>final</code> 的，以确保其值不可变。<code>final</code> 关键字保证了原始变量和副本的值始终相同。</li></ul><h3 id="Java-8-之后的改变：“事实上的-final”（Effectively-Final）"><a href="#Java-8-之后的改变：“事实上的-final”（Effectively-Final）" class="headerlink" title="Java 8 之后的改变：“事实上的 final”（Effectively Final）"></a>Java 8 之后的改变：“事实上的 <code>final</code>”（Effectively Final）</h3><p>在 Java 8 之后，为了简化代码，这个规则有了一些放松。你不再需要显式地使用 <code>final</code> 关键字。只要一个局部变量在定义后<strong>没有被重新赋值</strong>，它就会被编译器自动视为“<strong>事实上的 final</strong>”。</p><p>这使得代码看起来更简洁，但<strong>本质上的限制并没有改变</strong>：匿名内部类仍然只能访问那些值在方法执行期间不会改变的局部变量。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>; <span class="comment">// 事实上的 final</span></span><br><span class="line">    <span class="comment">// name = &quot;Bob&quot;; // 如果在这里重新赋值，则会编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 匿名内部类访问局部变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>name</code> 变量没有被 <code>final</code> 修饰，但在它被匿名内部类访问后没有被修改，所以编译器会将其视为事实上的 <code>final</code>，代码可以正常编译和运行。但如果你尝试在 <code>doSomething</code> 方法的 <code>new Thread</code> 之后修改 <code>name</code>，编译器就会报错。</p><hr><h3 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h3><table><thead><tr><th>类型</th><th>关键字</th><th>定义位置</th><th>访问外部类成员</th><th>创建方式</th></tr></thead><tbody><tr><td><strong>静态成员类</strong></td><td><code>static</code></td><td>在外部类内部</td><td>只能访问外部类的 <strong>静态成员</strong></td><td><code>new Outer.StaticInner();</code></td></tr><tr><td><strong>内部类</strong></td><td>无</td><td>在外部类内部</td><td>可访问外部类的<strong>所有成员</strong></td><td><code>new Outer().new Inner();</code></td></tr><tr><td><strong>局部内部类</strong></td><td>无</td><td>在方法或代码块内部</td><td>可访问外部成员和 <strong>final 局部变量</strong></td><td>只能在定义它的方法内部创建</td></tr><tr><td><strong>匿名内部类</strong></td><td>无</td><td>在方法或代码块内部</td><td>同局部内部类</td><td><code>new Interface/Class() &#123; ... &#125;;</code></td></tr></tbody></table><p>匿名内部类、函数式接口和 Lambda 表达式是 Java 语言在不断演进过程中，为了简化代码和支持函数式编程而引入的重要特性。它们经常在面试中被一起考察，因为它们之间存在演变和替代的关系。</p><hr><h3 id="1-匿名内部类-Anonymous-Inner-Class"><a href="#1-匿名内部类-Anonymous-Inner-Class" class="headerlink" title="1. 匿名内部类 (Anonymous Inner Class)"></a>1. 匿名内部类 (Anonymous Inner Class)</h3><p><strong>匿名内部类</strong>是一种没有名字的局部内部类，通常用于创建一个只使用一次的类的实例。</p><ul><li><strong>核心特点</strong>:<ul><li><strong>没有名字</strong>: 无法被复用。</li><li><strong>创建时定义</strong>: 必须在创建实例的同时定义类的实现。</li><li><strong>只能实现一个</strong>: 它可以实现一个接口或继承一个类，但不能两者都做。</li></ul></li><li><strong>用途</strong>:<ul><li>主要用于简化代码，特别是当一个类只被使用一次，且其实现非常简单时。</li><li>常见的应用场景是事件监听器（<code>ActionListener</code>）、线程（<code>Runnable</code>）等。</li></ul></li></ul><p>示例:</p><p>创建一个线程，实现 Runnable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from an anonymous inner class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><hr><h3 id="2-函数式接口-Functional-Interface"><a href="#2-函数式接口-Functional-Interface" class="headerlink" title="2. 函数式接口 (Functional Interface)"></a>2. 函数式接口 (Functional Interface)</h3><p><strong>函数式接口</strong>是指<strong>只包含一个抽象方法</strong>的接口。它可以包含其他默认方法（<code>default</code>）、静态方法（<code>static</code>）和来自 <code>Object</code> 类的方法（如 <code>equals</code>）。</p><ul><li><strong>核心特点</strong>:<ul><li><strong>一个抽象方法</strong>: 这是函数式接口的唯一强制要求。</li><li><strong>@FunctionalInterface 注解</strong>: 这是一个可选的注解，但强烈推荐使用。它会帮助编译器检查该接口是否满足函数式接口的定义，如果违反了规则，就会报错。</li></ul></li></ul><p><strong>用途</strong>:</p><ul><li>它为 Lambda 表达式提供了一个<strong>目标类型</strong>。Lambda 表达式的本质就是函数式接口的一个匿名实现。</li><li><code>java.util.function</code> 包中定义了大量的函数式接口，如 <code>Predicate</code>、<code>Consumer</code>、<code>Function</code> 和 <code>Supplier</code>，它们是 Java 8 Stream API 的基础。</li></ul><p>示例:</p><p>一个自定义的函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-Lambda-表达式-Lambda-Expression"><a href="#3-Lambda-表达式-Lambda-Expression" class="headerlink" title="3. Lambda 表达式 (Lambda Expression)"></a>3. Lambda 表达式 (Lambda Expression)</h3><p><strong>Lambda 表达式</strong>是 Java 8 引入的一个新特性，它提供了一种简洁的方式来表示<strong>函数式接口的实现</strong>。Lambda 表达式可以被看作是匿名内部类的<strong>简化版本</strong>，用于实现只有一个抽象方法的接口。</p><ul><li><strong>语法</strong>: <code>(参数列表) -&gt; &#123; 方法体 &#125;</code></li><li><strong>核心特点</strong>:<ul><li><strong>简洁</strong>: 极大地减少了代码量，省去了匿名内部类的许多样板代码。</li><li><strong>函数式编程</strong>: 使得 Java 能够更方便地支持函数式编程范式，如将函数作为参数传递。</li><li><strong>类型推断</strong>: 编译器可以根据上下文自动推断参数类型。</li></ul></li></ul><p>示例:</p><p>使用 Lambda 表达式实现上面的 Runnable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello from a Lambda expression!&quot;</span>));</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><hr><h3 id="常见的面试问题"><a href="#常见的面试问题" class="headerlink" title="常见的面试问题"></a>常见的面试问题</h3><h4 id="1-匿名内部类、Lambda-表达式和函数式接口之间的关系是什么？"><a href="#1-匿名内部类、Lambda-表达式和函数式接口之间的关系是什么？" class="headerlink" title="1. 匿名内部类、Lambda 表达式和函数式接口之间的关系是什么？"></a>1. 匿名内部类、Lambda 表达式和函数式接口之间的关系是什么？</h4><ul><li><strong>演变关系</strong>: 匿名内部类是 Java 早期用于实现接口或抽象类的单一方法的笨重方式。函数式接口的出现，为 Lambda 表达式提供了一个<strong>目标类型</strong>。Lambda 表达式就是对只有一个抽象方法的匿名内部类的一种<strong>语法糖</strong>，它极大地简化了代码。</li><li><strong>本质</strong>: Lambda 表达式是函数式接口的一个<strong>匿名实现</strong>。</li></ul><h4 id="2-为什么-Lambda-表达式只能实现函数式接口？"><a href="#2-为什么-Lambda-表达式只能实现函数式接口？" class="headerlink" title="2. 为什么 Lambda 表达式只能实现函数式接口？"></a>2. 为什么 Lambda 表达式只能实现函数式接口？</h4><p>Lambda 表达式的语法（<code>(参数) -&gt; &#123;方法体&#125;</code>）本身就只适用于实现<strong>一个方法</strong>。如果一个接口有两个抽象方法，编译器无法确定 Lambda 表达式的 <code>()</code> 和 <code>&#123;&#125;</code> 对应的是哪个方法，因此会报错。</p><h4 id="3-Lambda-表达式和匿名内部类在使用-this-关键字时有什么区别？"><a href="#3-Lambda-表达式和匿名内部类在使用-this-关键字时有什么区别？" class="headerlink" title="3. Lambda 表达式和匿名内部类在使用 this 关键字时有什么区别？"></a>3. Lambda 表达式和匿名内部类在使用 <code>this</code> 关键字时有什么区别？</h4><ul><li><strong>匿名内部类</strong>: 匿名内部类有自己的作用域。它内部的 <code>this</code> 关键字指向的是<strong>匿名内部类自身的实例</strong>。</li><li><strong>Lambda 表达式</strong>: Lambda 表达式没有自己的作用域。它内部的 <code>this</code> 关键字指向的是<strong>其定义所在类的实例</strong>。</li></ul><p><strong>示例</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private String name = &quot;Outer&quot;;</span><br><span class="line"></span><br><span class="line">    public void testLambda() &#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(this.name); // 这里的 this 指向 OuterClass 实例</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void testAnonymous() &#123;</span><br><span class="line">        Runnable r = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // System.out.println(this.name); // 编译错误，匿名内部类没有 name 字段</span><br><span class="line">                System.out.println(OuterClass.this.name); // 必须用 OuterClass.this</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Lambda-表达式捕获的局部变量为什么必须是-final-的？"><a href="#4-Lambda-表达式捕获的局部变量为什么必须是-final-的？" class="headerlink" title="4. Lambda 表达式捕获的局部变量为什么必须是 final 的？"></a>4. Lambda 表达式捕获的局部变量为什么必须是 <code>final</code> 的？</h4><p>和匿名内部类一样，Lambda 表达式会<strong>捕获</strong>其外部作用域的局部变量。这些变量在 Lambda 表达式的生命周期中是不可变的，因为它们被复制到了堆中。在 Java 8 之前，你需要显式地用 <code>final</code> 修饰；自 Java 8 之后，只要变量没有被重新赋值，它就是**“事实上的 <code>final</code>”**，可以省略 <code>final</code> 关键字。</p><h2 id="Lambda表达式："><a href="#Lambda表达式：" class="headerlink" title="Lambda表达式："></a>Lambda表达式：</h2><p>Lambda 表达式是 Java 8 引入的语法糖，它让你可以用更简洁的方式实现<strong>函数式接口</strong>。它的底层实现机制比你想象的要复杂，但核心思想是利用了新的字节码指令和方法。</p><hr><h3 id="Lambda-表达式的底层实现"><a href="#Lambda-表达式的底层实现" class="headerlink" title="Lambda 表达式的底层实现"></a>Lambda 表达式的底层实现</h3><p>Lambda 表达式的底层实现依赖于两个关键技术：</p><ol><li><strong>invokedynamic 指令</strong></li><li><strong>方法句柄（Method Handle）</strong></li></ol><p>在 Java 7 之前，JVM 中只有四种调用方法的指令：<code>invokevirtual</code>、<code>invokeinterface</code>、<code>invokespecial</code> 和 <code>invokestatic</code>。这些指令都是<strong>静态</strong>绑定的，意味着在编译时就确定了调用的目标方法。</p><p>然而，Lambda 表达式的调用是<strong>动态</strong>的。编译器在处理 Lambda 表达式时，并不知道它会具体调用哪个方法。因此，Java 7 引入了 <strong>invokedynamic</strong> 指令，它允许在运行时动态地解析和绑定方法调用。</p><hr><h4 id="编译时：生成-invokedynamic-指令"><a href="#编译时：生成-invokedynamic-指令" class="headerlink" title="编译时：生成 invokedynamic 指令"></a>编译时：生成 <code>invokedynamic</code> 指令</h4><p>当你编写一个 Lambda 表达式时，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>Java 编译器在编译时并不会直接生成一个匿名内部类。相反，它会做以下事情：</p><ol><li><strong>将 Lambda 表达式体转换为一个私有方法</strong>：编译器会把 <code>System.out.println(&quot;Hello&quot;)</code> 这段代码提取出来，生成一个<strong>新的私有方法</strong>，通常是 <code>private static</code> 或 <code>private</code> 类型，并带有特殊的命名规则（比如 <code>lambda$main$0</code>）。这个新方法包含了 Lambda 表达式的实际逻辑。</li><li><strong>生成 invokedynamic 指令</strong>：在 Lambda 表达式出现的地方，编译器会生成一条 <code>invokedynamic</code> 指令。这条指令不会直接调用上一步生成的私有方法。相反，它指向一个<strong>引导方法（Bootstrap Method）</strong>。</li></ol><p><code>invokedynamic</code> 指令的结构大致如下：</p><p><code>invokedynamic #0:run:()Ljava/lang/Runnable;</code></p><ul><li><code>#0</code> 是一个常量池索引，指向引导方法（通常是 <code>java.lang.invoke.LambdaMetafactory.metafactory</code>）。</li><li><code>run</code> 是函数式接口中抽象方法的名称。</li><li><code>()Ljava/lang/Runnable;</code> 是函数式接口的签名。</li></ul><h4 id="运行时：动态绑定"><a href="#运行时：动态绑定" class="headerlink" title="运行时：动态绑定"></a>运行时：动态绑定</h4><p>当 JVM 执行到 <code>invokedynamic</code> 指令时，它会执行以下步骤：</p><ol><li><strong>调用引导方法</strong>：JVM 会调用 <code>LambdaMetafactory.metafactory</code> 引导方法。这个方法是 Lambda 表达式的**“工厂”<strong>，它负责生成一个</strong>方法句柄（Method Handle）**。</li><li><strong>生成方法句柄</strong>：方法句柄是一个轻量级的、类似于 <code>java.lang.reflect.Method</code> 的引用，但它更高效，可以直接调用。它指向编译时生成的那个私有方法（即 Lambda 表达式的实际逻辑）。</li><li><strong>生成调用点对象</strong>：<code>LambdaMetafactory.metafactory</code> 返回一个**<code>CallSite</code>**对象，这个对象持有一个指向方法句柄的引用。这个 <code>CallSite</code> 会被缓存起来。</li><li><strong>执行方法调用</strong>：<code>invokedynamic</code> 指令会直接跳转到 <code>CallSite</code> 对象中的方法句柄，然后执行实际的 Lambda 表达式代码。</li></ol><h3 id="Lambda-表达式与匿名内部类的区别"><a href="#Lambda-表达式与匿名内部类的区别" class="headerlink" title="Lambda 表达式与匿名内部类的区别"></a>Lambda 表达式与匿名内部类的区别</h3><p>理解底层实现后，两者在性能和设计上有一些关键区别：</p><table><thead><tr><th>特性</th><th>Lambda 表达式</th><th>匿名内部类</th></tr></thead><tbody><tr><td><strong>生成方式</strong></td><td>动态生成私有方法和 <code>invokedynamic</code> 指令</td><td>编译时生成独立的 <code>.class</code> 文件</td></tr><tr><td><strong>性能</strong></td><td>通常更快。<strong>invokedynamic 优化了性能</strong>，避免了每次都创建新对象和执行 <code>invokespecial</code> 指令。</td><td>每次使用都会创建一个新的对象实例，并生成一个额外的类文件。</td></tr><tr><td><strong>作用域</strong></td><td>没有自己的作用域，<code>this</code> 关键字指向外部类的实例。</td><td>有自己的作用域，<code>this</code> 关键字指向匿名内部类实例本身。</td></tr><tr><td><strong>内存开销</strong></td><td><strong>更小</strong>。由于采用了方法句柄，避免了为每个 Lambda 表达式创建独立的匿名类对象。</td><td>会产生额外的 <code>.class</code> 文件和对象实例，内存开销更大。</td></tr></tbody></table><p>总结来说，Lambda 表达式的底层实现是一种<strong>延迟创建</strong>和<strong>动态绑定</strong>的机制。编译器在编译时只留下一个调用指令，将真正的实现工作推迟到运行时。这种设计使得 Lambda 表达式在保持代码简洁的同时，也带来了更高的性能。</p><h2 id="switch语句支持的数据类型："><a href="#switch语句支持的数据类型：" class="headerlink" title="switch语句支持的数据类型："></a>switch语句支持的数据类型：</h2><p><code>switch</code> 语句是 Java 中一个非常实用的控制流语句，它能够根据变量的值来选择不同的执行路径。从 Java 7 开始，<code>switch</code> 语句支持的数据类型有了显著的扩展。</p><p><code>switch</code> 语句作用的数据类型包括：</p><hr><h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a><strong>1. 基本数据类型</strong></h3><ul><li><strong>byte</strong></li><li><strong>short</strong></li><li><strong>char</strong></li><li><strong>int</strong></li></ul><p><strong>注意：</strong></p><ul><li><code>switch</code> 语句不支持 <code>long</code>、<code>float</code>、<code>double</code> 或 <code>boolean</code> 类型。</li><li>如果你的变量是 <code>long</code> 类型，你需要将其强制转换为 <code>int</code> 类型才能在 <code>switch</code> 中使用，但这可能导致数据丢失，通常不推荐。</li></ul><hr><h3 id="2-包装类"><a href="#2-包装类" class="headerlink" title="2. 包装类"></a><strong>2. 包装类</strong></h3><ul><li><strong>Byte</strong></li><li><strong>Short</strong></li><li><strong>Character</strong></li><li><strong>Integer</strong></li></ul><p>这是因为 Java 编译器在编译时会进行<strong>自动拆箱（autounboxing）</strong>，将包装类对象自动转换为对应的基本数据类型。</p><hr><h3 id="3-枚举类型-enum"><a href="#3-枚举类型-enum" class="headerlink" title="3. 枚举类型 (enum)"></a><strong>3. 枚举类型 (enum)</strong></h3><ul><li><strong>从 Java 5 开始</strong>，<code>switch</code> 语句开始支持枚举类型。</li><li>使用枚举可以使代码更具可读性和安全性，因为编译器会检查所有 <code>case</code> 标签是否对应了枚举中的有效常量。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Day</span> <span class="variable">day</span> <span class="operator">=</span> Day.MONDAY;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s Monday.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s Sunday.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s a weekday.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-String-类型"><a href="#4-String-类型" class="headerlink" title="4. String 类型"></a><strong>4. String 类型</strong></h3><ul><li><strong>从 Java 7 开始</strong>，<code>switch</code> 语句开始支持 <code>String</code> 类型。</li><li>这个特性极大地简化了基于字符串的条件判断代码，避免了大量的 <code>if-else if-else</code> 链。</li><li>在底层，编译器通过 <code>String</code> 对象的 <code>hashCode()</code> 和 <code>equals()</code> 方法来执行 <code>switch</code> 逻辑。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;You chose an apple.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;orange&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;You chose an orange.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown fruit.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><table><thead><tr><th>支持类型</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td><code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code></td><td>所有版本</td><td><code>switch</code> 的基础类型。</td></tr><tr><td><code>Byte</code>, <code>Short</code>, <code>Character</code>, <code>Integer</code></td><td>所有版本</td><td>自动拆箱机制使其可用。</td></tr><tr><td><code>enum</code></td><td>Java 5+</td><td>增强代码的可读性和安全性。</td></tr><tr><td><code>String</code></td><td>Java 7+</td><td>极大地简化了字符串判断逻辑。</td></tr></tbody></table><p>记住，无论使用哪种类型，<code>case</code> 标签后面的值都必须是<strong>编译时常量</strong>。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="1-内置锁：synchronized-关键字"><a href="#1-内置锁：synchronized-关键字" class="headerlink" title="1. 内置锁：synchronized 关键字"></a>1. 内置锁：<code>synchronized</code> 关键字</h3><p><code>synchronized</code>是Java语言层面的同步机制，使用起来相对简单。它可以修饰方法或代码块，由JVM负责加锁和释放锁，开发者不需要手动管理。</p><ul><li><strong>同步方法：</strong> 当你用<code>synchronized</code>修饰一个非静态方法时，锁对象是这个方法的实例对象（<code>this</code>）。当一个线程进入这个同步方法时，它会获得该实例的锁，其他线程就无法进入这个实例的任何同步方法，直到它释放锁。</li><li><strong>同步静态方法：</strong> 当<code>synchronized</code>修饰一个静态方法时，锁对象是该类的<code>Class</code>对象。这意味着所有线程在访问这个类的任何同步静态方法时都会争抢同一把锁，无论有多少个实例。</li><li><strong>同步代码块：</strong> <code>synchronized (object)</code>。这是最灵活的使用方式，你可以指定任何对象作为锁。通过缩小同步范围，可以减少锁的持有时间，从而提高程序的并发性能。</li></ul><p><strong>synchronized的特点：</strong></p><ul><li><strong>可重入性（Reentrant）：</strong> 一个线程可以重复获取它已经持有的锁，避免死锁。</li><li><strong>非公平性（Unfair）：</strong> 默认情况下，线程获取锁的顺序是不确定的，先来的不一定先得到。</li><li><strong>锁的升级：</strong> 为了优化性能，<code>synchronized</code>锁的实现经历了从<strong>偏向锁</strong>、<strong>轻量级锁</strong>到<strong>重量级锁</strong>的升级过程。这使得在竞争不激烈的情况下，加锁的开销非常小。</li><li><strong>内存可见性（Visibility）：</strong> <code>synchronized</code>可以保证当一个线程释放锁时，它对共享变量所做的修改会立即刷新到主内存，而当另一个线程获取锁时，它会从主内存中读取最新的变量值。这是由Java内存模型（JMM）的<code>happens-before</code>规则保证的。</li></ul><h3 id="底层实现机制"><a href="#底层实现机制" class="headerlink" title="底层实现机制"></a>底层实现机制</h3><p>synchronized本质上是基于JVM的**内置锁（Intrinsic Lock）**实现的。每个Java对象都天生具备一个监视器锁（Monitor），这是JVM级别的原生支持。</p><p><strong>监视器的工作原理：</strong></p><ul><li>当线程进入synchronized代码块时，会执行monitorenter指令获取对象的监视器</li><li>当线程退出时，执行monitorexit指令释放监视器</li><li>如果获取失败，线程会被阻塞在操作系统级别</li></ul><h3 id="锁升级的演进过程"><a href="#锁升级的演进过程" class="headerlink" title="锁升级的演进过程"></a>锁升级的演进过程</h3><p>synchronized的性能优化经历了一个复杂的演进过程，从最初的重量级锁逐步优化：</p><p><strong>偏向锁阶段：</strong><br>当只有一个线程反复进入同步块时，JVM会将锁偏向于这个线程。此时的开销极低，几乎等同于无锁操作。对象头中会记录偏向的线程ID，后续该线程进入时直接通过简单的比较就能获取锁。</p><p><strong>轻量级锁阶段：</strong><br>当有其他线程开始竞争时，偏向锁会升级为轻量级锁。JVM在当前线程的栈帧中创建锁记录（Lock Record），通过CAS操作尝试将对象头的Mark Word替换为指向锁记录的指针。这个过程避免了操作系统层面的阻塞。</p><p><strong>重量级锁阶段：</strong><br>当CAS操作失败次数过多或者有多个线程同时竞争时，锁会膨胀为重量级锁。此时会创建Monitor对象，利用操作系统的互斥量（Mutex）来实现同步，涉及用户态和内核态的切换。</p><p>好的，我帮你把 <strong>JVM 锁升级过程</strong> 优化排版，整理成条理清晰、易于理解的版本，并加上一些注释说明，让整个流程更直观。</p><hr><h1 id="JVM-锁的升级过程"><a href="#JVM-锁的升级过程" class="headerlink" title="JVM 锁的升级过程"></a>JVM 锁的升级过程</h1><p>JVM 的对象锁在多线程访问时会经历 <strong>偏向锁 → 轻量级锁 → 重量级锁</strong> 的升级过程。下面详细说明每一步。</p><hr><h2 id="1-普通对象（无锁状态）"><a href="#1-普通对象（无锁状态）" class="headerlink" title="1. 普通对象（无锁状态）"></a>1. 普通对象（无锁状态）</h2><ul><li>对象未被任何线程持有锁时：<ul><li>Mark Word 中记录 <strong>对象的 HashCode</strong>。</li><li>锁标志位：<code>01</code>（表示无锁）。</li><li>是否偏向锁位：<code>0</code>。</li></ul></li></ul><blockquote><p>此时对象只是普通对象，没有同步锁。</p></blockquote><hr><h2 id="2-偏向锁初始化（第一次加锁）"><a href="#2-偏向锁初始化（第一次加锁）" class="headerlink" title="2. 偏向锁初始化（第一次加锁）"></a>2. 偏向锁初始化（第一次加锁）</h2><ul><li>线程 <strong>A</strong> 获取锁：<ul><li>锁标志位仍为 <code>01</code>（无锁标志）。</li><li>偏向锁标志位改为 <code>1</code>，表示对象进入 <strong>偏向锁状态</strong>。</li><li>Mark Word 的前 23 bit 保存 <strong>线程 A 的线程 ID</strong>。</li></ul></li></ul><blockquote><p>偏向锁用于优化单线程访问锁的性能，减少同步开销。</p></blockquote><hr><h2 id="3-偏向锁重入（线程-A-再次获取锁）"><a href="#3-偏向锁重入（线程-A-再次获取锁）" class="headerlink" title="3. 偏向锁重入（线程 A 再次获取锁）"></a>3. 偏向锁重入（线程 A 再次获取锁）</h2><ul><li>线程 <strong>A</strong> 再次尝试获取锁：<ul><li>JVM 检查对象标志位：<ul><li>锁标志位 <code>01</code></li><li>偏向锁位 <code>1</code></li><li>Mark Word 中线程 ID &#x3D; A 的 ID</li></ul></li><li>由于线程 A 已持有偏向锁，直接进入同步代码，无需 CAS 操作。</li></ul></li></ul><blockquote><p>偏向锁允许线程重复获取锁，性能开销极低。</p></blockquote><hr><h2 id="4-偏向锁竞争（线程-B-尝试获取锁）"><a href="#4-偏向锁竞争（线程-B-尝试获取锁）" class="headerlink" title="4. 偏向锁竞争（线程 B 尝试获取锁）"></a>4. 偏向锁竞争（线程 B 尝试获取锁）</h2><ul><li>线程 <strong>B</strong> 尝试获取锁：<ul><li>JVM 检查对象偏向锁：<ul><li>锁标志位 <code>01</code></li><li>偏向锁位 <code>1</code></li><li>Mark Word 中线程 ID ≠ B</li></ul></li><li>线程 B <strong>尝试通过 CAS 抢锁</strong>：<ul><li>成功：偏向锁切换到线程 B，Mark Word 更新为 B 的线程 ID</li><li>失败：表示竞争存在，进入下一步升级轻量级锁</li></ul></li></ul></li></ul><blockquote><p>偏向锁竞争失败时，说明锁开始有多线程访问，需要升级锁状态。</p></blockquote><hr><h2 id="5-轻量级锁（Lightweight-Lock）"><a href="#5-轻量级锁（Lightweight-Lock）" class="headerlink" title="5. 轻量级锁（Lightweight Lock）"></a>5. 轻量级锁（Lightweight Lock）</h2><ul><li>JVM 为当前线程在 <strong>栈帧</strong>中分配一块空间，称为 <strong>锁记录区（Lock Record）</strong>：<ul><li>保存指向对象 Mark Word 的指针</li></ul></li><li>对象 Mark Word 保存指向锁记录区的指针</li><li>CAS 操作同时更新两处指针：<ul><li>成功：线程获得轻量级锁，执行同步代码，锁标志位改为 <code>00</code>（轻量级锁状态）</li><li>失败：竞争激烈，进入自旋阶段</li></ul></li></ul><blockquote><p>轻量级锁适合 <strong>多线程少量竞争</strong> 场景，性能较好。</p></blockquote><hr><h2 id="6-自旋锁（Spin-Lock）"><a href="#6-自旋锁（Spin-Lock）" class="headerlink" title="6. 自旋锁（Spin Lock）"></a>6. 自旋锁（Spin Lock）</h2><ul><li>线程尝试获取轻量级锁失败：<ul><li>JVM <strong>自旋重试</strong>（循环尝试抢锁）</li><li>自旋次数由 JVM 决定（JDK 1.7 默认启用）</li><li>成功：执行同步代码</li><li>失败：锁升级为重量级锁</li></ul></li></ul><blockquote><p>自旋锁适合锁竞争短暂的情况，避免线程阻塞带来的开销。</p></blockquote><hr><h2 id="7-重量级锁（Heavyweight-Lock）"><a href="#7-重量级锁（Heavyweight-Lock）" class="headerlink" title="7. 重量级锁（Heavyweight Lock）"></a>7. 重量级锁（Heavyweight Lock）</h2><ul><li>自旋失败后，锁升级为 <strong>重量级锁</strong>：<ul><li>锁标志位改为 <code>10</code></li><li>线程未抢到锁的会被阻塞（挂起）</li><li>系统线程调度负责唤醒等待线程</li></ul></li></ul><blockquote><p>重量级锁性能开销较大，使用操作系统互斥机制。<br> 只有当轻量级锁和自旋锁都无法满足需求时才会升级。</p></blockquote><hr><h2 id="🔑-总结锁升级过程"><a href="#🔑-总结锁升级过程" class="headerlink" title="🔑 总结锁升级过程"></a>🔑 总结锁升级过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">无锁状态（01 + 偏向位0）</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">偏向锁（01 + 偏向位1 + 线程ID）</span><br><span class="line">       │</span><br><span class="line">       ▼   线程竞争</span><br><span class="line">轻量级锁（00 + 指向栈帧锁记录区）</span><br><span class="line">       │</span><br><span class="line">       ▼   CAS 失败 / 高竞争</span><br><span class="line">自旋锁（不断自旋尝试抢锁）</span><br><span class="line">       │</span><br><span class="line">       ▼   自旋失败</span><br><span class="line">重量级锁（10 + 阻塞等待）</span><br></pre></td></tr></table></figure><blockquote><p>JVM 通过 <strong>锁膨胀机制</strong>（Lock Inflation）逐步升级锁，尽量在多线程争用情况下保证性能。</p></blockquote><h3 id="自动化的特点"><a href="#自动化的特点" class="headerlink" title="自动化的特点"></a>自动化的特点</h3><p>synchronized的最大特点是<strong>完全自动化</strong>。程序员无需关心锁的获取和释放时机，JVM会自动处理所有细节。即使在异常情况下，JVM也能保证锁的正确释放，这大大降低了死锁和资源泄露的风险。</p><h3 id="2-显式锁：java-util-concurrent-locks-Lock"><a href="#2-显式锁：java-util-concurrent-locks-Lock" class="headerlink" title="2. 显式锁：java.util.concurrent.locks.Lock"></a>2. 显式锁：<code>java.util.concurrent.locks.Lock</code></h3><p>从JDK 1.5开始，<code>java.util.concurrent.locks</code>包提供了更灵活、更强大的锁机制，其核心是<code>Lock</code>接口。最常用的实现类是**<code>ReentrantLock</code>**。</p><p>使用<code>Lock</code>需要手动进行加锁和解锁操作，通常是在<code>try...finally</code>块中进行，以确保锁在任何情况下都能被释放，防止死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 访问共享资源的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Lock相比synchronized的优势：</strong></p><ul><li><strong>中断锁（Interruptibly）：</strong> <code>Lock</code>提供了<code>lockInterruptibly()</code>方法，允许在等待锁的过程中响应中断。而<code>synchronized</code>的线程如果陷入等待锁的状态，是无法被中断的。</li><li><strong>尝试获取锁（tryLock）：</strong> <code>Lock</code>提供了<code>tryLock()</code>和<code>tryLock(long timeout, TimeUnit unit)</code>方法，可以尝试获取锁，如果失败则立即返回或在指定时间内放弃，避免无限等待。</li><li><strong>公平锁与非公平锁：</strong> <code>ReentrantLock</code>可以创建公平锁（Fair Lock）。公平锁会按照线程请求锁的顺序来分配锁，虽然这可能会带来一些性能开销。而<code>synchronized</code>只能是非公平锁。</li><li><strong>绑定多个条件（Condition）：</strong> <code>Lock</code>配合<code>Condition</code>接口，可以实现更灵活的线程等待和唤醒机制，类似<code>Object</code>的<code>wait()</code>和<code>notify()</code>，但功能更强大，一个锁可以有多个等待队列。</li><li><strong>读写锁（ReadWriteLock）：</strong> <code>ReadWriteLock</code>是<code>Lock</code>的另一个重要实现，它维护了一对锁：一个用于读操作，一个用于写操作。在读多写少的场景下，多个线程可以同时获取读锁，大大提高了并发性能，只有写操作才需要获取独占的写锁。<code>ReentrantReadWriteLock</code>是其具体实现。</li></ul><h3 id="Lock接口的设计理念"><a href="#Lock接口的设计理念" class="headerlink" title="Lock接口的设计理念"></a>Lock接口的设计理念</h3><h3 id="显式锁机制"><a href="#显式锁机制" class="headerlink" title="显式锁机制"></a>显式锁机制</h3><p>Lock接口代表了Java并发包中<strong>显式锁</strong>的设计思想。与synchronized的隐式锁不同，Lock要求程序员明确控制锁的生命周期，这带来了更大的灵活性，同时也增加了使用的复杂性。</p><h3 id="AQS框架的核心思想"><a href="#AQS框架的核心思想" class="headerlink" title="AQS框架的核心思想"></a>AQS框架的核心思想</h3><p>Lock接口的实现基于AbstractQueuedSynchronizer（AQS）框架，这是Doug Lea设计的一个并发框架的杰作。</p><p><strong>同步状态的抽象：</strong><br>AQS使用一个int值来表示同步状态，不同的锁实现可以赋予这个状态不同的含义。比如ReentrantLock用它表示重入次数，Semaphore用它表示许可证数量。</p><p><strong>队列化的等待机制：</strong><br>当线程无法获取锁时，AQS会将其包装成节点加入到一个FIFO队列中。这个队列使用双向链表实现，每个节点都包含了线程引用和等待状态信息。</p><p><strong>自旋与阻塞的平衡：</strong><br>AQS巧妙地结合了自旋和阻塞两种等待策略。线程在入队后会先进行有限次数的自旋尝试，只有在确定无法获取锁时才会调用LockSupport.park()进入阻塞状态。</p><h3 id="3-volatile-关键字"><a href="#3-volatile-关键字" class="headerlink" title="3. volatile 关键字"></a>3. <code>volatile</code> 关键字</h3><p><code>volatile</code>关键字并不是一个锁，它是一种轻量级的同步机制，主要用于保证共享变量的<strong>可见性</strong>和<strong>有序性</strong>。</p><ul><li><strong>可见性（Visibility）：</strong> 当一个变量被<code>volatile</code>修饰后，一个线程对它的修改会立即被其他线程可见。这是通过在写操作后添加内存屏障，强制将修改后的值刷新到主内存，并在读操作前添加内存屏障，强制从主内存中读取最新值来实现的。</li><li><strong>有序性（Ordering）：</strong> <code>volatile</code>可以禁止指令重排序，确保代码的执行顺序不会被打乱。</li><li><strong>无法保证原子性（Atomicity）：</strong> <code>volatile</code>无法保证复合操作（如<code>i++</code>）的原子性，因为<code>i++</code>实际上是读、加、写三个操作的组合，这三个操作并非一次完成。如果要保证原子性，需要使用<code>synchronized</code>、<code>Lock</code>或<code>java.util.concurrent.atomic</code>包下的原子类。</li></ul><p><strong>总结一下：</strong></p><table><thead><tr><th>特性</th><th><code>synchronized</code></th><th><code>Lock</code> (如<code>ReentrantLock</code>)</th><th><code>volatile</code></th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>独占锁，保证原子性、可见性、有序性</td><td>独占锁，功能更强大，保证原子性、可见性、有序性</td><td>轻量级同步，只保证可见性和有序性</td></tr><tr><td><strong>使用方式</strong></td><td>关键字，自动加锁和解锁</td><td>接口，需要手动加锁和解锁，必须在<code>finally</code>块中释放</td><td>关键字，修饰变量</td></tr><tr><td><strong>灵活性</strong></td><td>较差，功能固定</td><td>强，提供了更多高级功能，如可中断、超时、公平锁等</td><td>较差，只针对变量</td></tr><tr><td><strong>性能</strong></td><td>JVM优化后性能较高，开销相对较小</td><td>高性能，在竞争激烈时通常优于<code>synchronized</code></td><td>非常高，几乎没有开销</td></tr><tr><td><strong>适用场景</strong></td><td>简单的同步需求，大部分情况都适用</td><td>高级同步需求，需要灵活控制锁的获取和释放</td><td>变量的写操作不依赖于当前值，需要保证变量的可见性。</td></tr></tbody></table><h3 id="4-乐观锁-Optimistic-Locking"><a href="#4-乐观锁-Optimistic-Locking" class="headerlink" title="4. 乐观锁 (Optimistic Locking)"></a>4. 乐观锁 (Optimistic Locking)</h3><p>与之前讨论的<strong>悲观锁</strong>（<code>synchronized</code>和<code>Lock</code>）不同，乐观锁并非一个具体的Java关键字或类，而是一种<strong>并发控制的思想和策略</strong>。悲观锁认为“总会有其他线程来修改数据”，所以在访问共享资源前，先对资源加锁，确保独占访问。而乐观锁则认为“数据冲突发生的概率很小”，所以它<strong>不加锁</strong>，而是假设所有线程都能正常执行，只有在数据更新提交时，才去检查在此期间数据是否被其他线程修改过。</p><p>如果检查到数据没有被修改，则更新成功。如果发现数据已经被修改，则更新失败。处理失败的方式通常有两种：</p><ol><li><strong>重试：</strong> 循环尝试，直到更新成功为止。</li><li><strong>放弃：</strong> 抛出异常或直接返回失败，由调用方处理。</li></ol><p><strong>乐观锁的实现方式：</strong></p><p>乐观锁的核心在于如何“检查数据是否被修改”。在Java中，常见的实现方式有两种：</p><ul><li><p>版本号（Version Number）：</p><p>在数据表中增加一个version字段。每次读取数据时，也把version字段读出来。当要进行数据更新时，带上之前读取的version值，在更新语句中加入WHERE version &#x3D; &lt;当前版本号&gt;的条件。如果更新成功，同时把version值加1。</p><ul><li><p><strong>SQL示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE products <span class="type">SET</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">100</span>, version = version + <span class="number">1</span></span><br><span class="line"><span class="type">WHERE</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">123</span> <span class="type">AND</span> <span class="variable">version</span> <span class="operator">=</span> &lt;之前读取的版本号&gt;;</span><br></pre></td></tr></table></figure></li><li><p><strong>原理：</strong> 如果在更新时，其他线程已经修改了这条数据，那么<code>version</code>值已经改变，上述<code>UPDATE</code>语句的<code>WHERE</code>条件将不成立，导致更新失败，影响行数为0。此时，你可以选择重试或放弃。</p></li></ul></li><li><p>CAS (Compare-And-Swap) 算法：</p><p>这是乐观锁在硬件层面的支持，也是Java中实现乐观锁的核心机制。CAS是一种原子操作，它包含三个操作数：</p><ul><li><strong>V (Value)：</strong> 内存地址中存放的旧值。</li><li><strong>A (Expected)：</strong> 预期的旧值。</li><li><strong>B (New)：</strong> 想要写入的新值。</li></ul><p>CAS的操作逻辑是：</p><p>如果内存地址V中的值等于预期值A，那么就将V的值更新为新值B。否则，什么都不做。整个操作是原子性的，由CPU指令直接完成。</p><p>Java中<code>java.util.concurrent.atomic</code>包下的所有原子类，如<code>AtomicInteger</code>、<code>AtomicLong</code>等，都是基于CAS实现的。</p><p><strong>AtomicInteger示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="comment">// 假设多个线程同时执行以下操作</span></span><br><span class="line">count.incrementAndGet(); <span class="comment">// 内部就是CAS操作</span></span><br></pre></td></tr></table></figure><p><code>incrementAndGet()</code>方法的内部实现类似于一个自旋重试的循环：</p><ol><li>获取当前值<code>current</code>。</li><li>计算新值<code>next = current + 1</code>。</li><li>使用CAS尝试将<code>current</code>更新为<code>next</code>。</li><li>如果更新失败（说明<code>current</code>已经被其他线程修改），则重新回到第一步，再次获取最新值并尝试更新。</li></ol></li></ul><p><strong>悲观锁与乐观锁的比较：</strong></p><table><thead><tr><th>特性</th><th>悲观锁 (<code>synchronized</code>, <code>Lock</code>)</th><th>乐观锁 (CAS, 版本号)</th></tr></thead><tbody><tr><td><strong>加锁方式</strong></td><td>独占资源时先加锁，阻止其他线程访问</td><td>不加锁，只在提交时进行冲突检测</td></tr><tr><td><strong>冲突处理</strong></td><td>线程排队等待锁，串行执行</td><td>线程失败后重试或放弃，并发执行</td></tr><tr><td><strong>适用场景</strong></td><td><strong>写操作多、竞争激烈</strong>的场景。数据冲突概率高。</td><td><strong>读操作多、写操作少</strong>的场景。数据冲突概率低。</td></tr><tr><td><strong>性能</strong></td><td>在高竞争环境下，线程切换和上下文开销大，性能下降。</td><td>在低竞争环境下，无锁开销，性能极高。在高竞争环境下，大量重试可能导致CPU开销增加。</td></tr></tbody></table><p><strong>总结：</strong></p><p>在Java中，<strong>悲观锁</strong>和<strong>乐观锁</strong>是两种截然不同的并发控制策略。悲观锁（<code>synchronized</code>, <code>Lock</code>）适合<strong>写多读少</strong>的场景，能够保证数据的一致性，但会牺牲一定的性能。而乐观锁（<strong>CAS</strong>、<strong>版本号</strong>）则适合<strong>读多写少</strong>的场景，通过无锁的并发操作提高了性能，但在高竞争下可能导致频繁重试，反而降低效率。理解这两种锁的思想，可以帮助你根据具体的业务场景选择最合适的并发控制方案。</p><p>好的，我们来继续完善Java中关于锁的介绍，增加<strong>死锁</strong>及其解决方案的内容。</p><hr><h3 id="5-死锁-Deadlock"><a href="#5-死锁-Deadlock" class="headerlink" title="5. 死锁 (Deadlock)"></a>5. 死锁 (Deadlock)</h3><p><strong>死锁</strong>是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法继续执行。</p><p><strong>死锁的产生</strong>是一个非常经典的多线程问题，通常发生在线程需要同时持有多个锁的场景中。一个简单的死锁场景是：线程A持有锁1，想获取锁2；而线程B持有锁2，想获取锁1。此时两个线程都无法继续执行，从而进入死锁状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h4><p>死锁的发生需要同时满足以下四个条件，缺一不可：</p><ol><li><strong>互斥条件（Mutual Exclusion）：</strong> 至少有一个资源是独占的，即一次只能被一个线程使用。这是锁本身的基本特性。</li><li><strong>请求与保持条件（Hold and Wait）：</strong> 一个线程因请求资源而阻塞时，它对自己已获得的资源保持不放。</li><li><strong>不剥夺条件（No Preemption）：</strong> 线程已获得的资源在未使用完之前，不能被强行剥夺，只能由该线程自己释放。</li><li><strong>循环等待条件（Circular Wait）：</strong> 存在一个线程等待链，其中每个线程都持有下一个线程所需的资源。例如：线程A等待线程B，线程B等待线程C，线程C又等待线程A。</li></ol><h4 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h4><p>解决死锁的根本思想是<strong>破坏上述四个必要条件之一或多个</strong>。通常，我们无法破坏互斥条件（因为资源就是独占的），因此主要从其他三个条件入手。</p><ol><li><strong>破坏“请求与保持”条件：</strong><ul><li><strong>一次性获取所有锁：</strong> 线程在开始执行时，就一次性获取所有需要的锁。如果获取不成功，则释放所有已获得的锁，然后等待一段时间后再次尝试。</li><li><strong>优点：</strong> 简单有效。</li><li><strong>缺点：</strong> 可能会降低并发性，因为线程在很早就持有了锁，即使这些锁在后面才被使用。</li></ul></li><li><strong>破坏“不剥夺”条件：</strong><ul><li><strong>使用可中断的锁：</strong> 使用<code>Lock</code>接口提供的<code>tryLock()</code>方法。当一个线程尝试获取锁失败时，它可以选择放弃并释放已持有的锁，而不是一直等待。<code>Lock.tryLock(long time, TimeUnit unit)</code>方法可以在指定时间内尝试获取锁，超时后会放弃。</li><li><strong>优点：</strong> 提高了灵活性，线程可以响应中断或超时，避免无限等待。</li><li><strong>缺点：</strong> 实现起来相对复杂，需要开发者手动处理获取锁失败的情况。</li></ul></li><li><strong>破坏“循环等待”条件：</strong><ul><li><strong>按顺序获取锁：</strong> 对所有的锁进行排序，并强制所有线程都按照相同的顺序获取锁。</li><li><strong>示例：</strong> 如果线程A和线程B都需要<code>lock1</code>和<code>lock2</code>，那么它们都必须先获取<code>lock1</code>，再获取<code>lock2</code>。这样就杜绝了线程A持有<code>lock1</code>等待<code>lock2</code>，同时线程B持有<code>lock2</code>等待<code>lock1</code>的循环。</li><li><strong>优点：</strong> 这是最常用、最有效的死锁解决方案，实现起来也相对简单。</li><li><strong>缺点：</strong> 有时很难对所有锁进行全局排序，特别是在代码模块化程度较高、依赖关系复杂的情况下。</li></ul></li></ol><p><strong>总结：</strong></p><p>在实际开发中，预防死锁的最佳实践通常是<strong>破坏循环等待条件</strong>，即<strong>统一锁的获取顺序</strong>。这是最简单且最有效的方案。如果业务场景需要更灵活的控制，可以考虑使用<code>Lock</code>接口，利用<code>tryLock()</code>方法来破坏“不剥夺”条件，实现更复杂的死锁处理逻辑。</p><p>好的，我们来详细介绍<strong>银行家算法 (Banker’s Algorithm)</strong>。</p><hr><h3 id="银行家算法概述"><a href="#银行家算法概述" class="headerlink" title="银行家算法概述"></a>银行家算法概述</h3><p>银行家算法是一种著名的<strong>死锁避免算法</strong>，由荷兰计算机科学家Dijkstra在1965年提出。它的核心思想是：在每次分配资源之前，先进行一次<strong>安全性检查</strong>。如果分配后系统仍然处于<strong>安全状态</strong>，则分配资源；否则，不予分配，线程需要等待。</p><ul><li>优点：比死锁预防更灵活，能提高资源利用率。</li><li>缺点：算法复杂，需要预知进程的最大资源需求，并且系统开销大。</li></ul><p>之所以叫“银行家算法”，是因为它的工作原理类似于银行管理贷款。银行家在发放贷款时，会先确保这笔贷款发放后，自己还有足够的资金来满足所有客户可能提出的最大取款需求，从而避免因无法支付而破产的风险。</p><p>简单来说，银行家算法通过以下两个步骤来避免死锁：</p><ol><li><strong>安全状态的定义：</strong> 系统能够找到一个<strong>安全序列</strong>，使得所有线程都能按照这个序列执行完毕。</li><li><strong>资源分配策略：</strong> 当一个线程请求资源时，算法会先假设分配成功，然后检查系统是否仍处于安全状态。如果安全，就真的分配；如果不安全，就拒绝分配。</li></ol><hr><h3 id="银行家算法中的几个重要数据结构"><a href="#银行家算法中的几个重要数据结构" class="headerlink" title="银行家算法中的几个重要数据结构"></a>银行家算法中的几个重要数据结构</h3><p>为了实现算法，需要维护以下几个关键数据结构，假设系统中有<code>n</code>个线程和<code>m</code>种资源：</p><ul><li><strong>Available (可用资源矩阵)：</strong> 一个长度为<code>m</code>的向量。<code>Available[j]</code>表示第<code>j</code>种资源目前可用的数量。</li><li><strong>Max (最大需求矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Max[i, j]</code>表示线程<code>i</code>最多需要第<code>j</code>种资源多少个。</li><li><strong>Allocation (已分配资源矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Allocation[i, j]</code>表示线程<code>i</code>目前已拥有第<code>j</code>种资源多少个。</li><li><strong>Need (需求矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Need[i, j]</code>表示线程<code>i</code>还需要第<code>j</code>种资源多少个才能完成任务。<ul><li><code>Need[i, j] = Max[i, j] - Allocation[i, j]</code></li></ul></li></ul><hr><h3 id="银行家算法的核心：安全状态的判断"><a href="#银行家算法的核心：安全状态的判断" class="headerlink" title="银行家算法的核心：安全状态的判断"></a>银行家算法的核心：安全状态的判断</h3><p>判断系统是否处于安全状态是银行家算法的核心。一个系统处于<strong>安全状态</strong>，当且仅当存在一个<strong>安全序列</strong><code>&lt;P1, P2, ..., Pn&gt;</code>。这个序列满足：对于序列中每一个线程<code>Pi</code>，它所需要的资源都能由系统中当前可用的资源，以及前面所有已完成的线程释放的资源来满足。</p><p><strong>安全性检查算法的步骤：</strong></p><ol><li><strong>初始化：</strong><ul><li>创建一个<code>Work</code>向量，初始化为<code>Available</code>（即当前可用资源）。</li><li>创建一个<code>Finish</code>向量，初始化为<code>false</code>，表示所有线程都未完成。</li></ul></li><li><strong>寻找安全线程：</strong><ul><li>从所有线程中找到一个线程<code>i</code>，满足以下两个条件：<ul><li><code>Finish[i]</code>为<code>false</code>。</li><li><code>Need[i]</code>向量中的每一个值都小于或等于<code>Work</code>向量中对应的值。</li><li>换句话说，线程<code>i</code>所需要的资源小于或等于当前可用的资源。</li></ul></li></ul></li><li><strong>释放资源：</strong><ul><li>如果找到了这样的线程<code>i</code>，则认为它可以顺利执行完毕。</li><li>模拟该线程执行完毕并释放资源，更新<code>Work</code>向量：<code>Work = Work + Allocation[i]</code>。</li><li>将<code>Finish[i]</code>设置为<code>true</code>。</li></ul></li><li><strong>循环检查：</strong><ul><li>重复步骤2和步骤3，直到找不到满足条件的线程。</li></ul></li><li><strong>判断结果：</strong><ul><li>如果最终所有线程的<code>Finish</code>都为<code>true</code>，则说明找到了一个安全序列，系统处于<strong>安全状态</strong>。</li><li>如果还有线程的<code>Finish</code>为<code>false</code>，则说明系统处于<strong>不安全状态</strong>，可能存在死锁。</li></ul></li></ol><hr><h3 id="银行家算法的流程：资源分配"><a href="#银行家算法的流程：资源分配" class="headerlink" title="银行家算法的流程：资源分配"></a>银行家算法的流程：资源分配</h3><p>当一个线程<code>P</code>请求资源时，银行家算法会执行以下步骤：</p><ol><li><strong>请求检查：</strong> 检查线程<code>P</code>请求的资源数量是否小于或等于其<code>Need</code>向量中的需求量。如果不是，说明线程<code>P</code>的请求不合理，拒绝分配。</li><li><strong>可用性检查：</strong> 检查线程<code>P</code>请求的资源数量是否小于或等于当前<code>Available</code>中的资源数量。如果不是，说明资源不足，线程<code>P</code>需要等待。</li><li><strong>预分配并进行安全性检查：</strong><ul><li>假设资源可以分配，<strong>临时</strong>进行以下操作：<ul><li><code>Available = Available - Request</code></li><li><code>Allocation[P] = Allocation[P] + Request</code></li><li><code>Need[P] = Need[P] - Request</code></li></ul></li><li>调用上面的<strong>安全性检查算法</strong>，判断系统是否处于安全状态。</li></ul></li><li><strong>正式分配或拒绝：</strong><ul><li>如果安全性检查的结果是<strong>安全</strong>，则正式分配资源，并保留步骤3中的修改。</li><li>如果安全性检查的结果是<strong>不安全</strong>，则回滚步骤3中的所有临时修改，拒绝分配资源，线程<code>P</code>需要等待。</li></ul></li></ol><h3 id="银行家算法的优缺点"><a href="#银行家算法的优缺点" class="headerlink" title="银行家算法的优缺点"></a>银行家算法的优缺点</h3><ul><li><strong>优点：</strong><ul><li>可以有效地避免死锁的发生，保证系统的安全性。</li><li>通过提前检查，可以最大化地利用资源，提高系统的并发性。</li></ul></li><li><strong>缺点：</strong><ul><li><strong>计算开销大：</strong> 每次分配资源都需要运行安全性检查算法，增加了系统的开销。</li><li><strong>过于保守：</strong> 安全状态不等于无死锁，不安全状态也不等于一定发生死锁。算法为了确保安全，可能会拒绝一些本可以成功分配的请求，从而降低了系统的吞吐量。</li><li><strong>条件苛刻：</strong> 算法要求线程在开始前就声明其所需的最大资源量，这在实际应用中很难做到。</li><li><strong>资源数量固定：</strong> 算法假设系统中资源的数量是固定的，不能动态增减。</li></ul></li></ul><p>因此，银行家算法虽然在理论上非常完美，但在实际操作系统中很少被直接完整地实现。然而，它的核心思想——<strong>通过安全性检查来避免死锁</strong>——仍然是许多并发控制策略的重要理论基础。                                     </p><h3 id="实际应用中的死锁处理"><a href="#实际应用中的死锁处理" class="headerlink" title="实际应用中的死锁处理"></a>实际应用中的死锁处理</h3><p>在实际的并发编程和数据库系统中，最常见的死锁处理方式是：</p><ul><li><p>死锁预防(通过编程规范)：</p><ul><li>加锁顺序一致：规定所有线程在获取多个锁时，必须按照相同的顺序。这是最有效的预防死锁的编程实践。</li><li>使用超时锁：尝试获取锁时设置一个超时时间，如果超时未获取到锁，则放弃本次操作并释放已持有的锁，然后重试。这破坏了”请求与保持”条件。例如Java的ReentrantLocktryLock(timeout)。</li><li>避免嵌套锁：尽量减少持有多个锁的情况。</li></ul></li><li><p>死锁检测与恢复(数据库系统)：</p><ul><li>大多数关系型数据库(如MySQL InnoDB)都实现了死锁检测机制。当检测到死锁时，数据库会自动选择一个成本较低的事务(“牺牲品”)进行回滚，从而解除死锁。客户端应用会收到相应的错误码(例如MySQL中的Deadlock found when trying to get lock; try restarting transaction)。应用程序通常需要捕获这个错误并重试事务。理解死锁的四个必要条件是关键，因为解决死锁的根本方法就是破坏其中一个或多个条件。</li></ul></li></ul><h2 id="锁扩展："><a href="#锁扩展：" class="headerlink" title="锁扩展："></a>锁扩展：</h2><h3 id="18-谈谈-synchronized-和-ReentrantLock-的区别？"><a href="#18-谈谈-synchronized-和-ReentrantLock-的区别？" class="headerlink" title="18. 谈谈 synchronized 和 ReentrantLock 的区别？"></a>18. 谈谈 synchronized 和 ReentrantLock 的区别？</h3><ol><li><code>synchronized</code> 是和 <code>for</code>、<code>while</code> 一样的关键字，<code>ReentrantLock</code> 是类，这是二者的本质区别。既然 <code>ReentrantLock</code> 是类，那么它就提供了比 <code>synchronized</code> 更多更灵活的特性：等待可中断、可实现公平锁、可实现选择性通知（锁可以绑定多个条件）、性能已不是选择标准。</li><li><code>synchronized</code> 依赖于 JVM 而 <code>ReenTrantLock</code> 依赖于 API。<code>synchronized</code> 是依赖于 JVM 实现的，JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReenTrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock</code> 方法配合 <code>try/finally</code> 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li></ol><hr><h3 id="19-synchronized-和-volatile-的区别是什么？"><a href="#19-synchronized-和-volatile-的区别是什么？" class="headerlink" title="19. synchronized 和 volatile 的区别是什么？"></a>19. synchronized 和 volatile 的区别是什么？</h3><ol><li><code>volatile</code> 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；<code>synchronized</code> 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li><code>volatile</code> 仅能使用在变量级别；<code>synchronized</code> 则可以使用在变量、方法、和类级别的。</li><li><code>volatile</code> 仅能实现变量的修改可见性，不能保证原子性；而 <code>synchronized</code> 则可以保证变量的修改可见性和原子性。</li><li><code>volatile</code> 不会造成线程的阻塞；<code>synchronized</code> 可能会造成线程的阻塞。</li><li><code>volatile</code> 标记的变量不会被编译器优化；<code>synchronized</code> 标记的变量可以被编译器优化。</li></ol><hr><h3 id="20-谈一下你对-volatile-关键字的理解？"><a href="#20-谈一下你对-volatile-关键字的理解？" class="headerlink" title="20. 谈一下你对 volatile 关键字的理解？"></a>20. 谈一下你对 volatile 关键字的理解？</h3><p><code>volatile</code> 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，这样做是为了减少流水线阻塞，提高 CPU 的执行效率。这就需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知道对不对了，所以有 <code>happens-before</code> 规则，其中有条就是 <code>volatile</code> 变量规则：对一个变量的写操作先行发生于后面面对这个变量的读操作、有序性实现的是通过插入内存屏障来保证的。</p><p>被 <code>volatile</code> 修饰的共享变量，就具有了以下两点特性：</p><ol><li>保证了不同线程对该变量操作的内存可见性;</li><li>禁止指令重排序。</li></ol><p>备注：这个题如果扩展了答，可以从 Java 的内存模型入手，下一篇 Java 虚拟机高频面试题中会讲到，这里不做过多赘述。</p><hr><h3 id="21-说下对-ReentrantReadWriteLock-的理解？"><a href="#21-说下对-ReentrantReadWriteLock-的理解？" class="headerlink" title="21. 说下对 ReentrantReadWriteLock 的理解？"></a>21. 说下对 ReentrantReadWriteLock 的理解？</h3><p><code>ReentrantReadWriteLock</code> 允许多个读线程同时访问，但是不允许写线程和读线程、写线程和写线程同时访问。读写锁内部维护了两个锁：一个是用于读操作的 <code>ReadLock</code>，一个是用于写操作的 <code>WriteLock</code>。读写锁 <code>ReentrantReadWriteLock</code> 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p><p><code>ReentrantReadWriteLock</code> 基于 <code>AQS</code> 实现，它的自定义同步器（继承 <code>AQS</code>）需要在同步状态 <code>state</code> 上维护多个读线程和一个写线程，该状态的设计成为实现读写锁的关键。<code>ReentrantReadWriteLock</code> 很好的利用了高低位。来实现一个整型控制两种状态的功能，读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写。</p><p><strong>ReentrantReadWriteLock 的特点</strong>：</p><ol><li>写锁可以降级为读锁，但是读锁不能升级为写锁；</li><li>不管是 <code>ReadLock</code> 还是 <code>WriteLock</code> 都支持 <code>Interrupt</code>，语义与 <code>ReentrantLock</code> 一致；</li><li><code>WriteLock</code> 支持 <code>Condition</code> 并且与 <code>ReentrantLock</code> 语义一致，而 <code>ReadLock</code> 则不能使用 <code>Condition</code>，否则抛出 <code>UnsupportedOperationException</code> 异常；</li><li>默认构造方法为非公平模式 ，开发者也可以通过指定 <code>fair</code> 为 <code>true</code> 设置为公平模式 。</li></ol><p><strong>升级&#x2F;降级</strong></p><ol><li>读锁里面加写锁，会导致死锁；</li><li>写锁里面是可以加读锁的，这就是锁的降级。</li></ol><h2 id="多线程与线程池"><a href="#多线程与线程池" class="headerlink" title="多线程与线程池"></a>多线程与线程池</h2><p>在 Java 中，多线程是实现并发编程的关键技术，它允许程序同时执行多个任务。线程池则是管理和复用线程的重要机制，能有效提升系统性能和资源利用率。</p><h3 id="⭐️什么是线程和进程"><a href="#⭐️什么是线程和进程" class="headerlink" title="⭐️什么是线程和进程?"></a><a href="#%E2%AD%90%EF%B8%8F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B">⭐️什么是线程和进程?</a></h3><h4 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a><a href="#%E4%BD%95%E4%B8%BA%E8%BF%9B%E7%A8%8B">何为进程?</a></h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><h4 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a><a href="#%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B">何为线程?</a></h4><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><hr><p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><p><strong>总结：</strong> 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><hr><h4 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84">程序计数器为什么是私有的?</a></h4><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h4 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84">虚拟机栈和本地方法栈为什么是私有的?</a></h4><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h4 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a><a href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA">一句话简单了解堆和方法区</a></h4><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><hr><h3 id="Java-THREAD-类详解"><a href="#Java-THREAD-类详解" class="headerlink" title="Java THREAD 类详解"></a>Java THREAD 类详解</h3><p>在 Java 中，<strong>Thread</strong> 类是多线程编程的核心。它代表了一个线程，并提供了丰富的 API 来创建、控制和管理线程的生命周期。理解 <code>Thread</code> 类及其方法对于编写高效、并发的 Java 应用程序至关重要。</p><hr><h3 id="1-THREAD-类的基本概念"><a href="#1-THREAD-类的基本概念" class="headerlink" title="1. THREAD 类的基本概念"></a>1. THREAD 类的基本概念</h3><p><code>Thread</code> 类位于 <code>java.lang</code> 包中。每个 <code>Thread</code> 类的实例都代表一个独立的线程，这个线程能够并行执行代码。有两种主要方式可以创建一个线程：</p><ol><li><strong>继承 Thread 类</strong>：创建一个新的类并继承 <code>Thread</code>，然后重写其 <strong>run()</strong> 方法来定义线程的执行逻辑。</li><li><strong>实现 Runnable 接口</strong>：创建一个实现了 <code>Runnable</code> 接口的类，并将其实例作为参数传递给 <code>Thread</code> 构造器。这种方式更灵活，因为它允许你的类继承其他类。</li></ol><hr><h3 id="2-THREAD-类的主要方法详解"><a href="#2-THREAD-类的主要方法详解" class="headerlink" title="2. THREAD 类的主要方法详解"></a>2. THREAD 类的主要方法详解</h3><p>下面详细介绍 <code>Thread</code> 类中的常用和重要方法，并按其功能进行分类。</p><h4 id="线程生命周期控制"><a href="#线程生命周期控制" class="headerlink" title="线程生命周期控制"></a><strong>线程生命周期控制</strong></h4><p>这些方法用于启动、中断和协调线程的执行。</p><ul><li><strong>start()</strong>: <strong>启动</strong>线程。此方法会创建一个新的线程，并使它进入<strong>可运行 (Runnable)</strong> 状态。一旦操作系统调度这个线程，它的 <strong>run()</strong> 方法就会被调用。</li><li><strong>run()</strong>: 线程的<strong>执行体</strong>。当你调用 <code>start()</code> 方法时，JVM 会自动调用这个方法。如果你直接调用 <code>run()</code>，它只会被当作一个普通方法在当前线程中执行，而不会创建新线程。</li><li><strong>interrupt()</strong>: 向线程发送一个<strong>中断信号</strong>。此方法并不会立即停止线程。它只是设置一个<strong>中断标志</strong>。线程需要自己检查这个标志并决定如何响应。对于在 <code>sleep()</code>, <code>join()</code>, 或 <code>wait()</code> 等方法中阻塞的线程，这个方法会抛出 <code>InterruptedException</code>。</li><li><strong>join()</strong>: <strong>等待</strong>线程终止。调用此方法的线程（通常是主线程）会<strong>阻塞</strong>，直到被调用 <code>join()</code> 的线程执行结束。<ul><li><strong>join()</strong>: 永远等待，直到线程终止。</li><li><strong>join(long millis)</strong>: 最多等待指定的毫秒数。</li></ul></li></ul><h4 id="线程属性和状态查询"><a href="#线程属性和状态查询" class="headerlink" title="线程属性和状态查询"></a><strong>线程属性和状态查询</strong></h4><p>这些方法用于获取线程的当前状态或设置其属性。</p><ul><li><strong>getName()</strong>: 返回线程的名称。线程可以有一个自定义的名称，如果没有指定，则会有一个默认的名称，如 “Thread-0”。</li><li><strong>setName(String name)</strong>: 设置线程的名称。</li><li><strong>getState()</strong>: 返回线程的当前<strong>状态</strong>。返回值是一个枚举类型 <code>Thread.State</code>，包括 <code>NEW</code>, <code>RUNNABLE</code>, <code>BLOCKED</code>, <code>WAITING</code>, <code>TIMED_WAITING</code>, <code>TERMINATED</code>。</li><li><strong>isAlive()</strong>: 判断线程是否<strong>存活</strong>。如果线程已经启动但尚未终止，则返回 <code>true</code>。</li><li><strong>isDaemon()</strong>: 判断线程是否为<strong>守护线程</strong>。守护线程在所有非守护线程终止时会自动终止。例如，JVM 的垃圾回收线程就是一个守护线程。</li><li><strong>setDaemon(boolean on)</strong>: 将线程设置为守护线程或非守护线程。这个方法必须在线程启动前调用。</li><li><strong>getPriority()</strong>: 返回线程的<strong>优先级</strong>。优先级是一个整数，范围从 <code>MIN_PRIORITY</code> (1) 到 <code>MAX_PRIORITY</code> (10)。</li><li><strong>setPriority(int newPriority)</strong>: 设置线程的优先级。</li></ul><h4 id="静态方法-影响当前线程"><a href="#静态方法-影响当前线程" class="headerlink" title="静态方法 (影响当前线程)"></a><strong>静态方法 (影响当前线程)</strong></h4><p>这些方法直接作用于正在执行的线程。</p><ul><li><strong>Thread.currentThread()</strong>: 返回对<strong>当前正在执行</strong>的线程对象的引用。这是获取当前线程信息最常用的方法。</li><li><strong>Thread.sleep(long millis)</strong>: 使<strong>当前线程</strong>暂停执行指定的毫秒数。它会释放 CPU 资源，但不会释放锁。</li><li><strong>Thread.yield()</strong>: 提示调度器，<strong>当前线程</strong>愿意放弃当前的 CPU 使用权，让其他线程有机会运行。这是一个<strong>提示</strong>，不能保证一定生效。</li><li><strong>Thread.interrupted()</strong>: 测试<strong>当前线程</strong>是否被中断。此方法会<strong>清除</strong>中断标志。如果线程在调用时中断标志为 <code>true</code>，则返回 <code>true</code>，然后将中断标志重置为 <code>false</code>。</li></ul><hr><h3 id="3-THREAD-类方法使用示例"><a href="#3-THREAD-类方法使用示例" class="headerlink" title="3. THREAD 类方法使用示例"></a>3. THREAD 类方法使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethodsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建并启动线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行。状态：&quot;</span> + Thread.currentThread().getState());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 模拟耗时操作，并演示 sleep()</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 休眠 2 秒...&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 检查中断标志</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被中断了！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 捕获到 InterruptedException，线程被中断。&quot;</span>);</span><br><span class="line">                <span class="comment">// 捕获异常后重新设置中断标志</span></span><br><span class="line">                Thread.currentThread().interrupt(); </span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行结束。&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;WorkerThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程优先级和守护状态（必须在启动前）</span></span><br><span class="line">        worker.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        worker.setDaemon(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并打印线程信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程创建后，名称：&quot;</span> + worker.getName() + <span class="string">&quot;，优先级：&quot;</span> + worker.getPriority());</span><br><span class="line">        System.out.println(<span class="string">&quot;线程创建后，状态：&quot;</span> + worker.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        worker.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 使用 join() 等待 worker 线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待 WorkerThread 结束...&quot;</span>);</span><br><span class="line">        <span class="comment">// worker.join(1000); // 只等待 1 秒</span></span><br><span class="line">        worker.join(); <span class="comment">// 无限等待</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行。WorkerThread 的最终状态：&quot;</span> + worker.getState());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 再次检查是否存活</span></span><br><span class="line">        System.out.println(<span class="string">&quot;WorkerThread 是否存活：&quot;</span> + worker.isAlive());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 演示 interrupt()</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">interruptibleThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程在这里阻塞</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;interruptibleThread 被中断，捕获到异常。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        interruptibleThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="comment">// 确保线程进入休眠</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程中断 interruptibleThread...&quot;</span>);</span><br><span class="line">        interruptibleThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，这是一个关于 Java 线程控制的非常重要的知识点。我将详细解释<strong>守护线程（Daemon Thread）</strong>，以及 <code>join()</code> 和 <code>yield()</code> 这两个线程控制方法。</p><hr><h3 id="一、守护线程-Daemon-Thread"><a href="#一、守护线程-Daemon-Thread" class="headerlink" title="一、守护线程 (Daemon Thread)"></a>一、守护线程 (Daemon Thread)</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul><li><strong>守护线程</strong>：是一种特殊的线程，它为其他线程（非守护线程）提供服务。</li><li><strong>特点</strong>：如果 JVM 中<strong>只剩下守护线程</strong>，那么 JVM 会自动退出。换句话说，守护线程的生命周期不依赖于自己，而是依赖于其他非守护线程。</li></ul><h4 id="2-与普通线程的区别"><a href="#2-与普通线程的区别" class="headerlink" title="2. 与普通线程的区别"></a>2. 与普通线程的区别</h4><ul><li><strong>普通线程（User Thread）</strong>：又称用户线程。如果 JVM 中还有一个用户线程在运行，JVM 就不会退出。</li><li><strong>守护线程</strong>：当所有用户线程都执行完毕后，JVM 会忽略仍在运行的守护线程，并直接终止。</li></ul><h4 id="3-常见用途"><a href="#3-常见用途" class="headerlink" title="3. 常见用途"></a>3. 常见用途</h4><ul><li>守护线程常用于执行一些后台任务，例如：<ul><li><strong>垃圾回收器 (Garbage Collector)</strong>：JVM 的垃圾回收线程就是典型的守护线程。它负责回收内存，但不会阻止 JVM 的退出。</li><li><strong>JIT (Just-In-Time) 编译器</strong>：同样是后台服务线程。</li><li><strong>日志记录</strong>：一些日志框架的异步日志线程可以设置为守护线程。</li></ul></li></ul><h4 id="4-如何创建和判断"><a href="#4-如何创建和判断" class="headerlink" title="4. 如何创建和判断"></a>4. 如何创建和判断</h4><ul><li><strong>创建</strong>：在线程启动前，调用 <code>setDaemon(true)</code> 方法。<ul><li><strong>注意</strong>：必须在 <code>start()</code> 方法调用之前设置，否则会抛出 <code>IllegalThreadStateException</code>。</li></ul></li><li><strong>判断</strong>：<code>isDaemon()</code> 方法可以判断一个线程是否为守护线程。</li></ul><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonThreadExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个用户线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">userThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;用户线程正在运行...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户线程执行完毕。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个守护线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;守护线程正在运行...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置为守护线程，必须在 start() 之前</span></span><br><span class="line">        daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        userThread.start();</span><br><span class="line">        daemonThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 观察结果：当用户线程执行完毕后，守护线程也会立即终止。</span></span><br><span class="line">        <span class="comment">// 如果把 setDaemon(true) 移除，守护线程会一直运行，导致程序不退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、join-方法"><a href="#二、join-方法" class="headerlink" title="二、join() 方法"></a>二、<code>join()</code> 方法</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul><li><code>join()</code> 方法的作用是<strong>等待调用该方法的线程执行完毕</strong>。</li><li><strong>比喻</strong>：主线程 A 调用了线程 B 的 <code>B.join()</code> 方法，那么主线程 A 会<strong>进入等待状态</strong>，直到线程 B 执行结束，主线程 A 才会继续执行。</li></ul><h4 id="2-主要用途"><a href="#2-主要用途" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h4><ul><li>确保线程间的执行顺序。当一个线程的执行依赖于另一个线程的执行结果时，<code>join()</code> 方法非常有用。</li></ul><h4 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1执行完毕。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2执行完毕。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待 thread1 和 thread2 执行完毕</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待线程1执行完毕...&quot;</span>);</span><br><span class="line">        thread1.join(); <span class="comment">// 主线程阻塞在这里，直到 thread1 结束</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待线程2执行完毕...&quot;</span>);</span><br><span class="line">        thread2.join(); <span class="comment">// 主线程阻塞在这里，直到 thread2 结束</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程都执行完毕，主线程继续执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、yield-方法"><a href="#三、yield-方法" class="headerlink" title="三、yield() 方法"></a>三、<code>yield()</code> 方法</h3><h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul><li><code>yield()</code> 方法的作用是<strong>让出当前 CPU 的执行权</strong>。</li><li><strong>比喻</strong>：一个线程调用了 <code>yield()</code>，它告诉调度器：“我愿意暂时放弃 CPU，你可以让其他同等优先级的线程先执行。”</li></ul><h4 id="2-主要用途-1"><a href="#2-主要用途-1" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h4><ul><li><strong>提示</strong>：<code>yield()</code> 只是一个<strong>提示</strong>，调度器<strong>不一定会采纳</strong>。它可能让出 CPU 给其他线程，也可能立即重新获得 CPU 的执行权。</li><li><strong>与其他方法的区别</strong>：<ul><li><code>sleep()</code>：让线程进入<strong>休眠状态</strong>，<strong>强制</strong>让出 CPU。</li><li><code>wait()</code>：让线程进入<strong>等待状态</strong>，<strong>必须</strong>通过 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒。</li></ul></li><li><strong>yield() 不会释放锁</strong>。</li></ul><h4 id="3-代码示例-1"><a href="#3-代码示例-1" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YieldExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在运行：&quot;</span> + i);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 放弃CPU执行权。&quot;</span>);</span><br><span class="line">                    Thread.<span class="keyword">yield</span>(); <span class="comment">// 让出 CPU</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>观察结果</strong>：在输出到 “放弃CPU执行权” 后，你可能会看到另一个线程的输出先出现。但这并不绝对，因为 <code>yield()</code> 只是一个建议。</p><p>在Java多线程编程中，<code>yield()</code>、<code>join()</code>、<code>setDaemon()</code> 这些方法都有严格的<strong>设置时机</strong>，如果使用不当，可能会导致异常或行为不符合预期。</p><p>让我们来详细解释一下每个方法的设置时机。</p><hr><h3 id="1-setDaemon-boolean-on-方法"><a href="#1-setDaemon-boolean-on-方法" class="headerlink" title="1. setDaemon(boolean on) 方法"></a>1. <code>setDaemon(boolean on)</code> 方法</h3><ul><li><p><strong>作用</strong>：将一个线程设置为守护线程或用户线程。</p></li><li><p><strong>设置时机</strong>：<strong>必须在线程启动前调用</strong>，即在 <code>thread.start()</code> 方法之前。</p></li><li><p><strong>为什么？</strong>：</p><ul><li>线程一旦启动，其类型（用户线程或守护线程）就已经确定，并且不能在运行时改变。</li><li>如果在 <code>start()</code> 方法之后调用 <code>setDaemon(true)</code>，会抛出 <code>IllegalThreadStateException</code> 运行时异常。</li></ul></li><li><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 守护线程的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例：先启动再设置</span></span><br><span class="line"><span class="comment">// daemonThread.start();</span></span><br><span class="line"><span class="comment">// daemonThread.setDaemon(true); // 这里会抛出 IllegalThreadStateException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例：先设置再启动</span></span><br><span class="line">daemonThread.setDaemon(<span class="literal">true</span>); </span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-join-方法"><a href="#2-join-方法" class="headerlink" title="2. join() 方法"></a>2. <code>join()</code> 方法</h3><ul><li><p><strong>作用</strong>：让当前线程等待另一个线程执行完毕。</p></li><li><p><strong>设置时机</strong>：<strong>必须在被等待的线程启动后调用</strong>。</p></li><li><p><strong>为什么？</strong>：</p><ul><li><code>join()</code> 的目的是让一个线程等待另一个线程。如果被等待的线程还没有启动，那么等待它结束是没有意义的。</li><li>尽管在启动前调用不会抛出异常，但它也不会有任何效果，因为目标线程根本没有开始运行。</li></ul></li><li><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 工作线程的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例：在工作线程启动前调用 join()</span></span><br><span class="line"><span class="comment">// workerThread.join(); // 无效，因为 workerThread 还没有运行</span></span><br><span class="line"><span class="comment">// workerThread.start(); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例：在工作线程启动后调用 join()</span></span><br><span class="line">workerThread.start();</span><br><span class="line">workerThread.join(); <span class="comment">// 主线程将等待 workerThread 运行完毕</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-yield-方法"><a href="#3-yield-方法" class="headerlink" title="3. yield() 方法"></a>3. <code>yield()</code> 方法</h3><ul><li><p><strong>作用</strong>：向线程调度器发出提示，当前线程愿意放弃 CPU 执行权。</p></li><li><p><strong>设置时机</strong>：<strong>可以在线程生命周期的任何阶段调用</strong>，但通常在线程的 <code>run()</code> 方法中调用。</p></li><li><p><strong>为什么？</strong>：</p><ul><li><code>yield()</code> 是一个<strong>动态的行为</strong>，它发生在线程正在执行其任务的过程中。</li><li>它的目的是在任务执行过程中，在某个点上主动让出 CPU，让其他线程有机会运行。</li></ul></li><li><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我正在运行...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">// 在任务执行到一半时，让出 CPU</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>方法</th><th>作用</th><th>设置时机</th><th>备注</th></tr></thead><tbody><tr><td><strong>setDaemon()</strong></td><td>设定线程类型（守护&#x2F;用户）</td><td><strong>thread.start() 之前</strong></td><td>启动后设置会抛出异常</td></tr><tr><td><strong>join()</strong></td><td>等待线程执行结束</td><td><strong>thread.start() 之后</strong></td><td>在启动前调用是无效的</td></tr><tr><td><strong>yield()</strong></td><td>提示线程调度器让出 CPU</td><td><strong>线程运行期间的任何时刻</strong></td><td>只是一个建议，不保证生效</td></tr></tbody></table><h3 id="1-深度解析"><a href="#1-深度解析" class="headerlink" title="1. 深度解析"></a>1. 深度解析</h3><h4 id="1-Thread-sleep-long-millis"><a href="#1-Thread-sleep-long-millis" class="headerlink" title="1. Thread.sleep(long millis)"></a>1. <code>Thread.sleep(long millis)</code></h4><p><strong>功能:</strong> <code>sleep()</code> 方法是 <code>Thread</code> 类的静态方法，作用是让<strong>当前正在执行的线程</strong>暂停指定的时间。</p><p><strong>核心机制:</strong></p><ul><li><code>sleep()</code> 方法会使线程进入<strong>阻塞状态（Timed Waiting）</strong>。</li><li>它<strong>不会释放</strong>任何持有的<strong>锁（monitor）</strong>。</li><li>当指定的时间过后，线程会回到<strong>可运行状态（Runnable）</strong>，等待 CPU 调度。</li><li>如果线程在休眠期间被其他线程调用 <code>interrupt()</code> 方法，<code>sleep()</code> 会立即抛出 <code>InterruptedException</code>。</li><li><code>sleep()</code> 的实现依赖于操作系统的调度器，实际暂停的时间可能比指定的时间长。</li></ul><p><strong>源码解析 (伪代码):</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查中断标志</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用本地方法，通知操作系统挂起当前线程</span></span><br><span class="line">    VM.nativeSleep(millis);</span><br><span class="line">    <span class="comment">// 唤醒后再次检查中断标志</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>VM.nativeSleep</strong> 是一个本地方法，它将线程挂起的任务交给操作系统内核来完成。</p><h4 id="2-Thread-yield"><a href="#2-Thread-yield" class="headerlink" title="2. Thread.yield()"></a>2. <code>Thread.yield()</code></h4><p><strong>功能:</strong> <code>yield()</code> 方法是 <code>Thread</code> 类的静态方法，作用是让<strong>当前正在执行的线程</strong>放弃其 CPU 时间片，回到<strong>可运行状态（Runnable）</strong>。</p><p><strong>核心机制:</strong></p><ul><li><code>yield()</code> 的目的是给其他线程一个执行的机会，但它<strong>不保证</strong>其他线程会立即运行。</li><li>它<strong>不会</strong>使线程进入阻塞或等待状态，线程只是从“正在运行”的状态切换到“可运行”队列的末尾。</li><li>调度器可能会选择立即重新调度刚才调用 <code>yield()</code> 的线程。</li><li>它<strong>不会</strong>释放任何锁。</li><li><code>yield()</code> 主要用于<strong>调试</strong>或<strong>优化</strong>，通常不应用于核心业务逻辑。因为它依赖于调度器的实现，其行为不可预测。</li></ul><p><strong>源码解析 (伪代码):</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用本地方法，向操作系统调度器发出“让步”信号</span></span><br><span class="line">    nativeYield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nativeYield</strong> 同样是一个本地方法，它向操作系统调度器发出一个提示，表示当前线程愿意让出 CPU。</p><h4 id="3-obj-wait"><a href="#3-obj-wait" class="headerlink" title="3. obj.wait()"></a>3. <code>obj.wait()</code></h4><p><strong>功能:</strong> <code>wait()</code> 方法是 <code>Object</code> 类的方法，作用是让<strong>当前线程</strong>进入<strong>等待状态（Waiting）</strong>，并<strong>释放</strong>它所持有的对象的锁。</p><p><strong>核心机制:</strong></p><ul><li><code>wait()</code> 必须在**同步块（synchronized block）**内部调用，否则会抛出 <code>IllegalMonitorStateException</code>。</li><li>当线程调用 <code>wait()</code> 后，它会<strong>释放</strong>该同步块所关联的对象的锁，进入等待队列。</li><li>线程需要等待其他线程调用<strong>同一对象的</strong> <code>notify()</code> 或 <code>notifyAll()</code> 方法才能被唤醒。</li><li>被唤醒后，线程需要<strong>重新竞争</strong>对象的锁，才能继续执行。</li></ul><p><strong>源码解析 (伪代码):</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    wait(<span class="number">0</span>); <span class="comment">// 内部调用带超时参数的 wait 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 必须持有对象的锁</span></span><br><span class="line">    <span class="keyword">if</span> (!Thread.holdsLock(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知虚拟机，当前线程进入等待状态，并释放锁</span></span><br><span class="line">    VM.nativeWait(<span class="built_in">this</span>, timeout);</span><br><span class="line">    <span class="comment">// 线程被唤醒后，重新竞争锁</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wait()</code> 是线程间<strong>通信和协作</strong>的关键，通常与 <code>notify()</code> 或 <code>notifyAll()</code> 配合使用，实现生产者-消费者等设计模式。</p><h4 id="4-Thread-join"><a href="#4-Thread-join" class="headerlink" title="4. Thread.join()"></a>4. <code>Thread.join()</code></h4><p><strong>功能:</strong> <code>join()</code> 方法是 <code>Thread</code> 类的方法，作用是让<strong>当前线程</strong>（例如主线程）<strong>等待</strong>调用 <code>join()</code> 的线程（例如子线程）执行完毕。</p><p><strong>核心机制:</strong></p><ul><li><code>join()</code> 的本质是调用 <code>wait()</code> 方法。它在内部使用一个<strong>隐式的锁</strong>来同步。</li><li>当一个线程调用 <code>t.join()</code> 时，当前线程（调用者）会<strong>阻塞</strong>，直到线程 <code>t</code> 终止。</li><li>如果线程 <code>t</code> 终止（无论是正常结束还是异常终止），JVM 会调用 <code>t.notifyAll()</code> 来唤醒所有在 <code>t.join()</code> 上等待的线程。</li></ul><p><strong>源码解析 (简化版):</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 必须在同步方法中，使用this作为锁</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果线程已经结束，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="comment">// 进入等待</span></span><br><span class="line">        wait(millis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>join()</code> 的实现巧妙地利用了 <code>wait()</code> 和 <code>notifyAll()</code> 的机制。当一个线程的 <code>run()</code> 方法执行完毕时，JVM 会自动调用其 <code>notifyAll()</code> 方法，从而唤醒所有等待它的线程。</p><hr><h3 id="2-区别与使用场景总结"><a href="#2-区别与使用场景总结" class="headerlink" title="2. 区别与使用场景总结"></a>2. 区别与使用场景总结</h3><table><thead><tr><th>特性&#x2F;方法</th><th><code>Thread.sleep()</code></th><th><code>Thread.yield()</code></th><th><code>obj.wait()</code></th><th><code>Thread.join()</code></th></tr></thead><tbody><tr><td><strong>类&#x2F;接口</strong></td><td><code>java.lang.Thread</code> (静态)</td><td><code>java.lang.Thread</code> (静态)</td><td><code>java.lang.Object</code></td><td><code>java.lang.Thread</code></td></tr><tr><td><strong>是否释放锁</strong></td><td><strong>不释放</strong></td><td><strong>不释放</strong></td><td><strong>释放</strong></td><td><strong>不释放</strong> (但其内部实现会释放)</td></tr><tr><td><strong>状态转换</strong></td><td><code>RUNNING</code> -&gt; <code>TIMED_WAITING</code></td><td><code>RUNNING</code> -&gt; <code>RUNNABLE</code></td><td><code>RUNNING</code> -&gt; <code>WAITING</code></td><td><code>RUNNING</code> -&gt; <code>WAITING</code>&#x2F;<code>TIMED_WAITING</code></td></tr><tr><td><strong>唤醒方式</strong></td><td>时间到了自动唤醒 或 <code>interrupt()</code></td><td>依赖于操作系统调度器，立即或稍后被重新调度</td><td>必须由其他线程调用 <code>notify()</code>&#x2F;<code>notifyAll()</code></td><td>目标线程执行结束时自动唤醒 或 <code>interrupt()</code></td></tr><tr><td><strong>使用场景</strong></td><td>模拟耗时操作，或让出 CPU 资源（但不释放锁）</td><td>提示调度器给其他线程机会，通常用于调试或低优先级的任务</td><td>线程间的<strong>协作和通信</strong>，实现生产者-消费者模式</td><td><strong>等待</strong>一个线程执行结束，实现线程间的<strong>顺序执行</strong></td></tr><tr><td><strong>是否需要同步块</strong></td><td>否</td><td>否</td><td><strong>是</strong> (必须在 <code>synchronized</code> 块内)</td><td>否 (但其内部实现依赖于同步机制)</td></tr></tbody></table><h3 id="3-使用场景示例"><a href="#3-使用场景示例" class="headerlink" title="3. 使用场景示例"></a>3. 使用场景示例</h3><ul><li><p><strong>sleep()</strong>: 你需要一个定时任务，比如每隔一秒钟打印一次日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 暂停一秒</span></span><br><span class="line">    System.out.println(<span class="string">&quot;等待了 &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; 秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>yield()</strong>: 你有一个 CPU 密集型任务，希望在每次循环中给其他线程一个运行的机会，以避免饥饿。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 执行一些计算</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        Thread.<span class="keyword">yield</span>(); <span class="comment">// 让出 CPU</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>wait()</strong>: 你有一个共享队列，当队列为空时，消费者线程需要等待，当生产者放入新元素时，消费者被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (sharedQueue) &#123;</span><br><span class="line">    <span class="keyword">while</span> (sharedQueue.isEmpty()) &#123;</span><br><span class="line">        sharedQueue.wait(); <span class="comment">// 队列为空，等待并释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费元素...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>join()</strong>: 你需要确保子线程的数据处理完成后，主线程才能继续使用这个数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">dataProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="comment">/* 处理数据 */</span> &#125;);</span><br><span class="line">dataProcessor.start();</span><br><span class="line">dataProcessor.join(); <span class="comment">// 主线程等待数据处理完成</span></span><br><span class="line">System.out.println(<span class="string">&quot;数据处理完成，主线程可以继续了。&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>理解这些方法的细微差别是编写健壮、高效并发代码的基础。特别是 <code>wait()</code> 和 <code>sleep()</code>，它们最大的区别在于是否释放锁，这直接影响着线程间的同步和协作方式。</p><h3 id="线程（Thread）的概念与生命周期"><a href="#线程（Thread）的概念与生命周期" class="headerlink" title="线程（Thread）的概念与生命周期"></a>线程（Thread）的概念与生命周期</h3><p>线程是操作系统调度的最小单位，是进程中的一个执行路径。一个进程可以包含多个线程，这些线程共享进程的内存空间。</p><p>线程的生命周期通常包含以下六种状态（定义在 java.lang.Thread.State 枚举中）：</p><ul><li><p>NEW（新建）：线程被创建但尚未启动。当使用 new Thread() 创建一个线程实例后，它就处于此状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello from a new thread!&quot;</span>));</span><br><span class="line"><span class="comment">// 此时 myThread 处于 NEW 状态，尚未执行 start()</span></span><br></pre></td></tr></table></figure></li><li><p>RUNNABLE（可运行）：线程已调用 start() 方法，正在 JVM 中运行（可能正在执行，也可能在等待 CPU 调度）。一个 RUNNABLE 状态的线程可能正在运行，也可能并没有运行，它仅仅是具备了运行的资格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myThread.start();</span><br><span class="line"><span class="comment">// 此时 myThread 进入 RUNNABLE 状态，等待 CPU 调度执行 run() 方法</span></span><br></pre></td></tr></table></figure></li><li><p>BLOCKED (阻塞)：线程正在等待获取一个监视器锁(例如，进入 synchronized 块或方法)。当一个线程试图访问被其他线程锁定的资源时，它会进入此状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 线程已经持有 lock 对象的锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// ... 线程 A 正在执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程 B 尝试获取 lock 对象的锁，但被线程 A 占用，会进入 BLOCKED 状态</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>WAITING (等待)：线程无限制地等待另一个线程执行特定操作。例如，调用 Object.wait(), Thread.join() (无参数) 或 LockSupport.park().这些方法会使线程放弃 CPU 使用权，并进入无限制等待，直到被其他线程 notify(), notifyAll() 或 unpark() 唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">sharedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 线程 A:</span></span><br><span class="line"><span class="keyword">synchronized</span> (sharedObject) &#123;</span><br><span class="line">    sharedObject.wait(); <span class="comment">// 线程 A 进入 WAITING 状态，并释放 sharedObject 的锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程 B:</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line">threadA.start();</span><br><span class="line">threadA.join(); <span class="comment">// 线程 B 等待 threadA 执行完毕，进入 WAITING 状态</span></span><br></pre></td></tr></table></figure></li><li><p>TIMED_WAITING (有时限等待)：线程在指定的时间内等待另一个线程执行特定操作，或者休眠。例如，调用 Thread.sleep(long millis)、Object.wait(long timeout)、Thread.join(long millis)、LockSupport.parkNanos() 或 LockSupport.parkUntil()。一旦超时间到达，线程会自动从等待状态唤醒，并尝试重新进入 RUNNABLE 状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 线程进入 TIMED_WAITING 状态 1 秒</span></span><br></pre></td></tr></table></figure></li><li><p>TERMINATED (终止): 线程已执行完毕其 run() 方法, 或者因未捕获的异常退出。线程一旦进入此状态, 就不能再被重新启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程的 run() 方法执行完毕</span></span><br><span class="line"><span class="comment">// 线程在执行过程中抛出未捕获的异常</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="什么是线程上下文切换"><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换?"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">什么是线程上下文切换?</a></h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h3 id="Thread-sleep-方法和-Object-wait-方法对比"><a href="#Thread-sleep-方法和-Object-wait-方法对比" class="headerlink" title="Thread#sleep() 方法和 Object#wait() 方法对比"></a><a href="#thread-sleep-%E6%96%B9%E6%B3%95%E5%92%8C-object-wait-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94">Thread#sleep() 方法和 Object#wait() 方法对比</a></h3><hr><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p><p><strong>区别</strong>：</p><ul><li><strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong> 。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？下一个问题就会聊到。</li></ul><hr><h3 id="为什么-wait-方法不定义在-Thread-中？"><a href="#为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%9C%A8-thread-%E4%B8%AD">为什么 wait() 方法不定义在 Thread 中？</a></h3><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p><p>类似的问题：<strong>为什么 sleep() 方法定义在 Thread 中？</strong></p><p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p><hr><h3 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a><a href="#%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-thread-%E7%B1%BB%E7%9A%84-run-%E6%96%B9%E6%B3%95%E5%90%97">可以直接调用 Thread 类的 run 方法吗？</a></h3><p>这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结：调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类:"></a>继承 Thread 类:</h4><ul><li>通过创建 Thread 类的子类, 并重写其 run() 方法, 在该方法中定义线程执行的任务。</li><li>创建 Thread 子类的实例, 并调用其 start() 方法来启动线程。调用 start() 方法会使线程进入 RUNNABLE 状态, 并由 JVM 调度执行 run() 方法; 直接调用 run() 方法则只是在当前线程中执行普通方法, 不会启动新线程。</li><li>优点: 实现简单直观, 代码结构清晰。</li><li>缺点: Java 是单继承的, 如果你的类已经继承了其他类, 就不能再继承 Thread 类。这限制了类的灵活性。此外, 任务 (run() 方法中的逻辑 ) 与线程本身 (Thread 对象) 紧密耦合, 不利于任务的复用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyThread.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + threadName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running via extending Thread.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread: &quot;</span> + threadName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">                <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + threadName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> + threadName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadCreationDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCreationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread started.&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;MyThread-1&quot;</span>);</span><br><span class="line">        thread1.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;MyThread-2&quot;</span>);</span><br><span class="line">        thread2.start(); <span class="comment">// 启动另一个新线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished starting other threads.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现-Runnable-接口："><a href="#实现-Runnable-接口：" class="headerlink" title="实现 Runnable 接口："></a>实现 <strong>Runnable</strong> 接口：</h4><ul><li>定义一个类实现 <strong>Runnable</strong> 接口，并实现其抽象方法 public void run()。run() 方法中包含线程执行的具体任务。</li><li>创建 <strong>Runnable</strong> 实现类的实例，然后将其作为参数传入 Thread 类的构造器 (new Thread(Runnable target))，再调用 Thread 实例的 start() 方法。</li><li>优点：<ul><li>推荐方式：避免了 Java 单继承的限制，你的类可以同时继承其他类来实现 <strong>Runnable</strong> 接口。</li><li>任务与线程解耦：Runnable 对象只负责定义任务，而 Thread 对象负责执行任务。这意味着同一个 <strong>Runnable</strong> 对象可以被多个 Thread 实例共享执行，从而更好地实现资源的共享和任务的复用。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyRunnable.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + taskName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running via implementing Runnable.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task: &quot;</span> + taskName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task &quot;</span> + taskName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task &quot;</span> + taskName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadCreationDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCreationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread started.&quot;</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;Runnable-Task-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable1);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;Runnable-Task-2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable2, <span class="string">&quot;Custom-Thread-Name&quot;</span>); <span class="comment">// 可以给线程命名</span></span><br><span class="line">        thread4.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished starting runnable threads.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><p><code>Callable</code> 是 Java 并发编程中一个非常重要的接口，它与 <code>Runnable</code> 类似，都用于定义一个可在线程中执行的任务。但 <code>Callable</code> 提供了更强大的功能，主要体现在两个方面：</p><ol><li><strong>可以返回结果：</strong> <code>Callable</code> 的 <code>call()</code> 方法可以返回一个泛型类型的结果。</li><li><strong>可以抛出异常：</strong> <code>Callable</code> 的 <code>call()</code> 方法可以声明抛出任何 <code>Exception</code>。</li></ol><p>这与 <code>Runnable</code> 接口形成了鲜明对比，<code>Runnable</code> 的 <code>run()</code> 方法没有返回值，也不能抛出受检异常（checked exception）。</p><ul><li><h3 id="Callable-的基本结构"><a href="#Callable-的基本结构" class="headerlink" title="Callable 的基本结构"></a><code>Callable</code> 的基本结构</h3></li></ul><p><code>Callable</code> 接口是一个泛型接口，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算并返回结果，或在无法做到时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 如果无法计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;V&gt;</code>：泛型参数，代表 <code>call()</code> 方法将要返回的结果类型。</p></li><li><p><code>V call()</code>：<code>call()</code> 方法的签名，它返回一个 <code>V</code> 类型的结果，并且可以抛出异常。</p></li><li><h3 id="如何使用-Callable"><a href="#如何使用-Callable" class="headerlink" title="如何使用 Callable"></a>如何使用 <code>Callable</code></h3></li></ul><p><code>Callable</code> 接口本身并不能直接作为 <code>Thread</code> 的构造参数。它需要配合 <code>ExecutorService</code> 线程池和 <code>Future</code> 接口一起使用。</p><p><strong>典型使用流程：</strong></p><ol><li><p><strong>创建 Callable 任务：</strong> 实现 <code>Callable</code> 接口，并在 <code>call()</code> 方法中编写具体的业务逻辑，返回一个结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务执行完毕，返回结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建 ExecutorService 线程池：</strong> 使用 <code>Executors</code> 工厂类创建线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>提交 Callable 任务：</strong> 使用 <code>ExecutorService</code> 的 <code>submit()</code> 方法提交任务。<code>submit()</code> 方法会返回一个 <code>Future</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">MyCallableTask</span>();</span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br></pre></td></tr></table></figure></li><li><p><strong>获取任务结果：</strong> 通过 <code>Future</code> 对象的 <code>get()</code> 方法来获取 <code>Callable</code> 任务的执行结果。</p><ul><li><code>future.get()</code> 是一个<strong>阻塞</strong>方法，它会一直等待，直到任务执行完毕并返回结果。</li><li>如果任务执行过程中抛出了异常，<code>get()</code> 方法也会将这个异常包装在 <code>ExecutionException</code> 中重新抛出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 阻塞等待结果</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 线程被中断</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 任务执行过程中抛出的异常</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><h3 id="Callable-与-Runnable-的区别"><a href="#Callable-与-Runnable-的区别" class="headerlink" title="Callable 与 Runnable 的区别"></a><code>Callable</code> 与 <code>Runnable</code> 的区别</h3></li></ul><table><thead><tr><th>特性</th><th><code>Callable</code></th><th><code>Runnable</code></th></tr></thead><tbody><tr><td><strong>返回值</strong></td><td><code>call()</code> 方法有返回值（泛型 <code>V</code>）</td><td><code>run()</code> 方法没有返回值（<code>void</code>）</td></tr><tr><td><strong>异常处理</strong></td><td><code>call()</code> 方法可以抛出受检异常</td><td><code>run()</code> 方法不能直接抛出受检异常</td></tr><tr><td><strong>执行方式</strong></td><td>必须配合 <code>ExecutorService.submit()</code> 执行</td><td>可以直接作为 <code>Thread</code> 构造函数的参数，也可以通过 <code>ExecutorService.execute()</code> 或 <code>submit()</code> 执行</td></tr><tr><td><strong>功能</strong></td><td>适用于需要返回计算结果或可能抛出异常的异步任务</td><td>适用于简单的异步任务，不需要返回结果</td></tr></tbody></table><hr><ul><li><h3 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a><code>Future</code> 接口</h3></li></ul><p><code>Future</code> 接口是 <code>Callable</code> 的重要伴侣，它代表一个<strong>异步计算的结果</strong>。它提供了检查任务是否完成、等待任务完成以及获取任务结果的方法。</p><p><code>Future</code> 接口的主要方法：</p><ul><li><p><code>V get()</code>: 阻塞式地等待任务完成，并返回结果。</p></li><li><p><code>V get(long timeout, TimeUnit unit)</code>: 在指定时间内等待任务完成，超时则抛出 <code>TimeoutException</code>。</p></li><li><p><code>boolean isDone()</code>: 检查任务是否已经完成。</p></li><li><p><code>boolean cancel(boolean mayInterruptIfRunning)</code>: 尝试取消任务。</p></li><li><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3></li></ul><p><code>Callable</code> 是 Java 并发编程中一个更高级的任务抽象，它解决了 <code>Runnable</code> 接口无法返回结果和处理受检异常的痛点。通过与 <code>ExecutorService</code> 和 <code>Future</code> 接口的组合使用，<code>Callable</code> 使得异步编程变得更加简单和灵活，非常适合那些需要耗时计算并返回结果的场景，比如网络请求、数据处理等。</p><h4 id="线程池-Thread-Pool"><a href="#线程池-Thread-Pool" class="headerlink" title="线程池 (Thread Pool)"></a>线程池 (Thread Pool)</h4><p>线程池是一种基于池化思想的线程管理机制，用于管理和复用线程，而不是在每次需要执行任务时都创建新线程。</p><ul><li><p><strong>为什么使用线程池？</strong></p><ul><li>降低资源消耗:通过重复利用已创建的线程，降低线程创建和销毁的开销。</li><li>提高响应速度:当任务到达时，任务可以直接执行，无需等待线程创建。</li><li>提高线程的可管理性:线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配、调优和监控。</li><li>提供更多功能:如定时执行、周期执行、单线程化等。</li></ul></li><li><p><strong>线程池的核心参数 (ThreadPoolExecutor 构造方法)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">    TimeUnit unit,</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><ul><li><p>corePoolSize: 核心线程数。线程池中始终保持的线程数量，即使它们处于空闲状态，除非设置了 allowCoreThreadTimeOut(true)。</p></li><li><p>maximumPoolSize: 最大线程数。线程池中允许存在的最大线程数量。当工作队列已满且核心线程都在忙碌时，线程池会创建新的非核心线程，直到达到这个数量。</p></li><li><p>keepAliveTime: 当线程池中的线程数量超过 corePoolSize 时，这些空闲的非核心线程在终止之前等待新任务的最长时间。</p></li><li><p>unit: keepAliveTime 参数的时间单位。</p></li><li><p>workQueue: 任务队列 (阻塞队列)。用于存放等待执行的任务。</p><ul><li>ArrayBlockingQueue: 基于数组的有界阻塞队列，需要指定容量。</li><li>LinkedBlockingQueue: 基于链表的阻塞队列，容量可以指定，也可以是无界的（默认）。如果使用无界队列，maximumPoolSize 参数将失效。</li><li>SynchronousQueue: 一个不存储元素的阻塞队列。每个插入操作必须等待一个对应的移除操作，反之亦然。</li><li>PriorityBlockingQueue: 支持优先级的无界阻塞队列，按照自然顺序或自定义比较器排序。</li></ul></li><li><p>threadFactory: 线程工厂。用于创建新线程，可以自定义线程的命名、优先级等。</p></li><li><p>handler: 拒绝策略 (当线程池和工作队列都已满时，新的任务到来时的处理方式)。</p><ul><li><p>ThreadPoolExecutor.AbortPolicy (默认): 直接抛出 RejectedExecutionException 异常。</p></li><li><p>ThreadPoolExecutor.CallerRunsPolicy: 由调用线程 (提交任务的线程) 执行任务。</p></li><li><p>ThreadPoolExecutor.DiscardOldestPolicy: 丢弃队列中最老的任务，然后尝试提交当前任务。</p></li><li><p>ThreadPoolExecutor.DiscardPolicy: 直接丢弃当前新提交的任务。</p></li><li><p>因为<code>CallerRunsPolicy</code>这个拒绝策略，导致耗时的任务用了主线程执行，导致线程池阻塞，进而导致后续任务无法及时执行，严重的情况下很可能导致 OOM。</p><p>我们从问题的本质入手，调用者采用<code>CallerRunsPolicy</code>是希望所有的任务都能够被执行，暂时无法处理的任务又被保存在阻塞队列<code>BlockingQueue</code>中。这样的话，在内存允许的情况下，我们可以增加阻塞队列<code>BlockingQueue</code>的大小并调整堆内存以容纳更多的任务，确保任务能够被准确执行。</p><p>为了充分利用 CPU，我们还可以调整线程池的<code>maximumPoolSize</code> （最大线程数）参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</p></li></ul></li></ul></li><li><p><strong>线程池的执行流程</strong></p><ol><li>当一个任务提交到线程池时，如果当前运行的线程数小于 corePoolSize，即使有空闲线程，也会创建并启动一个新线程来执行任务。</li><li>如果当前运行的线程数大于或等于 corePoolSize，但任务队列 workQueue 未满，任务会被添加到 workQueue 中等待执行。</li><li>如果 workQueue 已满，但当前运行的线程数小于 maximumPoolSize，线程池会创建新的非核心线程来执行任务。</li><li>如果当前运行的线程数等于 maximumPoolSize 且 workQueue 已满，线程池会根据拒绝策略来处理新提交的任务。</li></ol></li><li><p><strong>Java 内置的四种常用线程池 (通过 Executors 工厂类创建)</strong></p><ul><li>FixedThreadPool (固定大小线程池)<ul><li>Executors.newFixedThreadPool(int nThreads)</li><li>corePoolSize &#x3D; maximumPoolSize &#x3D; nThreads</li><li>使用无界 LinkedBlockingQueue。</li><li>特点：可控制并发的线程数，超出的任务会在队列中等待。</li><li>问题：当任务提交速度远大于处理速度时，队列会不断增长，可能导致 OOM。</li></ul></li><li>SingleThreadExecutor (单线程线程池)<ul><li>Executors.newSingleThreadExecutor()</li><li>corePoolSize &#x3D; maximumPoolSize &#x3D; 1</li><li>使用无界 LinkedBlockingQueue。</li><li>特点：保证所有任务都在一个线程中按顺序执行。</li><li>问题：同 FixedThreadPool，队列无限增长可能导致 OOM。</li></ul></li><li>CachedThreadPool（可缓存线程池）<ul><li>Executors.newCachedThreadPool()</li><li>corePoolSize &#x3D; 0, maximumPoolSize &#x3D; Integer.MAX_VALUE</li><li>使用 SynchronousQueue。</li><li>keepAliveTime &#x3D; 60s</li><li>特点：当任务到来时，有空闲线程则复用，无空闲线程则创建新线程。适用于大量短时任务。</li><li>问题：maximumPoolSize 过大，当任务并发量极高时，可能创建大量线程，导致系统资源耗尽 (OOM)。</li></ul></li><li>ScheduledThreadPool（定时任务线程池）<ul><li>Executors.newScheduledThreadPool(int corePoolSize)</li><li>特点：支持定时及周期性任务执行。</li><li>内部使用 DelayedWorkQueue，一个无界队列，可以按时间进行排序。</li></ul></li></ul></li><li><p><strong>阿里巴巴开发手册建议：不推荐使用 Executors 创建线程池，而是手动通过 ThreadPoolExecutor 的构造方法创建，以明确线程池的运行规则，避免资源耗尽的风险。</strong></p></li></ul><p>好的，这是一个非常核心且重要的 Java 并发编程话题。我将从线程池的<strong>创建、生命周期和启动流程</strong>三个方面进行详细且深入的解析。</p><hr><h3 id="一、线程池的创建-ThreadPoolExecutor"><a href="#一、线程池的创建-ThreadPoolExecutor" class="headerlink" title="一、线程池的创建 (ThreadPoolExecutor)"></a>一、线程池的创建 (ThreadPoolExecutor)</h3><p>Java 中，线程池的核心是 <code>java.util.concurrent.ThreadPoolExecutor</code> 类。创建线程池最推荐的方式是直接使用它的构造函数，而不是使用 <code>Executors</code> 工厂类，因为这能让你更清楚地了解线程池的运行参数。</p><p><code>ThreadPoolExecutor</code> 的构造函数有多个参数，理解它们是掌握线程池的关键：</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(</span><br><span class="line">    int corePoolSize,      // 核心线程数</span><br><span class="line">    int maximumPoolSize,   // 最大线程数</span><br><span class="line">    long keepAliveTime,    // 线程空闲存活时间</span><br><span class="line">    TimeUnit unit,         // 时间单位</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列</span><br><span class="line">    ThreadFactory threadFactory,   // 线程工厂</span><br><span class="line">    RejectedExecutionHandler handler // 拒绝策略</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="各参数详解："><a href="#各参数详解：" class="headerlink" title="各参数详解："></a>各参数详解：</h4><ol><li><strong>corePoolSize (核心线程数)</strong>：<ul><li><strong>作用</strong>：线程池中<strong>常驻</strong>的线程数量。即使这些线程处于空闲状态，它们也不会被销毁。</li><li><strong>用途</strong>：当有新任务提交时，如果核心线程数未达到 <code>corePoolSize</code>，线程池会创建新线程来处理任务，直到核心线程数达到上限。</li></ul></li><li><strong>maximumPoolSize (最大线程数)</strong>：<ul><li><strong>作用</strong>：线程池中允许存在的<strong>最大</strong>线程数量。</li><li><strong>用途</strong>：当任务队列已满，且核心线程数已满时，线程池会创建新的线程（非核心线程）来处理任务，直到总线程数达到 <code>maximumPoolSize</code>。</li></ul></li><li><strong>keepAliveTime (线程空闲存活时间)</strong>：<ul><li><strong>作用</strong>：非核心线程的空闲存活时间。</li><li><strong>用途</strong>：当线程池中的线程数量超过 <code>corePoolSize</code> 时，如果一个非核心线程空闲时间超过 <code>keepAliveTime</code>，它就会被回收。</li></ul></li><li><strong>unit (时间单位)</strong>：<ul><li><strong>作用</strong>：<code>keepAliveTime</code> 的时间单位，如秒、分钟、毫秒。</li></ul></li><li><strong>workQueue (任务队列)</strong>：<ul><li><strong>作用</strong>：用于<strong>存放等待执行的任务</strong>。当核心线程都在忙碌时，新提交的任务会进入这个队列。</li><li><strong>常见类型</strong>：<ul><li><code>ArrayBlockingQueue</code>：基于数组，有界的阻塞队列。</li><li><code>LinkedBlockingQueue</code>：基于链表，通常是无界的，也可以指定容量。</li><li><code>SynchronousQueue</code>：不存储任务，每个任务提交都会立即被一个线程执行。</li></ul></li></ul></li><li><strong>ThreadFactory (线程工厂)</strong>：<ul><li><strong>作用</strong>：用于创建线程。可以自定义工厂来为线程命名、设置守护状态等。</li></ul></li><li><strong>RejectedExecutionHandler (拒绝策略)</strong>：<ul><li><strong>作用</strong>：当任务队列已满，且线程数达到 <code>maximumPoolSize</code> 时，线程池会根据拒绝策略来处理新提交的任务。</li><li><strong>常见策略</strong>：<ul><li><code>AbortPolicy</code> (默认)：直接抛出 <code>RejectedExecutionException</code> 异常。</li><li><code>CallerRunsPolicy</code>：由提交任务的线程（caller）自己来执行任务。</li><li><code>DiscardOldestPolicy</code>：丢弃任务队列中最老的任务，然后尝试将当前任务加入队列。</li><li><code>DiscardPolicy</code>：直接丢弃当前任务，不抛出异常。</li></ul></li></ul></li></ol><h3 id="二、线程池的生命周期"><a href="#二、线程池的生命周期" class="headerlink" title="二、线程池的生命周期"></a>二、线程池的生命周期</h3><p>线程池有五种状态，这些状态通过内部的 <code>ctl</code> 变量控制，它包含线程池的运行状态和线程数。</p><ol><li><strong>RUNNING (运行中)</strong>：<ul><li><strong>状态</strong>：接受新任务，并处理阻塞队列中的任务。</li><li><strong>转换</strong>：创建线程池时处于此状态。</li></ul></li><li><strong>SHUTDOWN (关闭)</strong>：<ul><li><strong>状态</strong>：不接受新任务，但会处理阻塞队列中的已有任务。</li><li><strong>转换</strong>：调用 <code>shutdown()</code> 方法后进入此状态。</li></ul></li><li><strong>STOP (停止)</strong>：<ul><li><strong>状态</strong>：不接受新任务，也不处理阻塞队列中的已有任务，会中断所有正在执行的任务。</li><li><strong>转换</strong>：调用 <code>shutdownNow()</code> 方法后进入此状态。</li></ul></li><li><strong>TIDYING (整理)</strong>：<ul><li><strong>状态</strong>：所有任务都已终止，线程数为 0。</li><li><strong>转换</strong>：当线程池处于 <code>SHUTDOWN</code> 或 <code>STOP</code> 状态，且所有任务都已完成、线程都已销毁时，进入此状态。</li></ul></li><li><strong>TERMINATED (终止)</strong>：<ul><li><strong>状态</strong>：彻底终止，可以安全地进行回收。</li><li><strong>转换</strong>：<code>TIDYING</code> 状态下，<code>terminated()</code> 方法执行完毕后进入此状态。</li></ul></li></ol><h3 id="三、线程池的启动流程-任务提交过程"><a href="#三、线程池的启动流程-任务提交过程" class="headerlink" title="三、线程池的启动流程 (任务提交过程)"></a>三、线程池的启动流程 (任务提交过程)</h3><p>当调用 <code>executor.execute(Runnable task)</code> 方法提交一个新任务时，线程池会按照以下严格的流程来决定如何处理任务：</p><ol><li><strong>核心线程检查</strong>：<ul><li>如果当前线程池中的线程数量<strong>小于</strong> <code>corePoolSize</code>，则创建并启动一个新线程来执行任务。即使有空闲的线程，也会创建新线程直到达到核心线程数。</li></ul></li><li><strong>任务队列检查</strong>：<ul><li>如果当前线程池中的线程数量<strong>等于或大于</strong> <code>corePoolSize</code>，则将任务放入任务队列 <code>workQueue</code> 中等待。</li></ul></li><li><strong>最大线程数检查</strong>：<ul><li>如果任务队列已满，线程池会再次检查当前线程数。</li><li>如果当前线程数量<strong>小于</strong> <code>maximumPoolSize</code>，则创建并启动一个新线程（非核心线程）来执行任务。</li></ul></li><li><strong>拒绝策略</strong>：<ul><li>如果任务队列已满，且当前线程数已达到 <code>maximumPoolSize</code>，则根据线程池的<strong>拒绝策略</strong>来处理这个新任务。</li></ul></li></ol><p><strong>总结</strong>：线程池的运行是一个复杂的、多阶段的过程。它优先使用核心线程，然后将任务放入队列，最后才考虑创建非核心线程。这个流程设计旨在最大限度地利用现有线程，减少线程创建和销毁的开销，从而提高性能和资源利用率。</p><h2 id="ThreadLocal："><a href="#ThreadLocal：" class="headerlink" title="ThreadLocal："></a>ThreadLocal：</h2><p>好的，我们来详细聊聊 <code>ThreadLocal</code>。</p><h3 id="ThreadLocal-是什么？"><a href="#ThreadLocal-是什么？" class="headerlink" title="ThreadLocal 是什么？"></a><code>ThreadLocal</code> 是什么？</h3><p><code>ThreadLocal</code>（线程本地变量）并不是用来解决线程间共享数据问题的，它的核心作用是<strong>为每个使用该变量的线程都提供一个独立的、隔离的副本</strong>。</p><p>你可以把 <code>ThreadLocal</code> 想象成一个“线程专属的储物柜”。每个线程都可以往这个储物柜里存东西（通过 <code>set()</code> 方法），取东西（通过 <code>get()</code> 方法），但它只能看到自己储物柜里的东西，无法访问其他线程的。</p><p><code>ThreadLocal</code> 内部其实是通过一个 <code>ThreadLocalMap</code> 来实现的。这个 Map 的键是 <code>ThreadLocal</code> 对象本身，值就是你存入的那个变量。每个线程都有一个属于自己的 <code>ThreadLocalMap</code>。</p><hr><h3 id="为什么需要-ThreadLocal？"><a href="#为什么需要-ThreadLocal？" class="headerlink" title="为什么需要 ThreadLocal？"></a>为什么需要 <code>ThreadLocal</code>？</h3><p>我们通常在开发中会遇到两种数据共享问题：</p><ol><li><strong>多个线程共享一个变量</strong>：这种情况下，需要通过 <code>synchronized</code>、<code>volatile</code> 或 <code>Lock</code> 来保证线程安全。</li><li><strong>每个线程需要一个独立的变量</strong>：这是 <code>ThreadLocal</code> 的主要应用场景。</li></ol><p>如果不用 <code>ThreadLocal</code>，我们可能需要自己手动维护一个 <code>Map&lt;Thread, Object&gt;</code>，每次存取数据时都以当前线程作为键。这样不仅麻烦，还容易出错。<code>ThreadLocal</code> 帮我们封装了这些细节，让使用变得非常简单。</p><hr><h3 id="ThreadLocal-的常见应用场景"><a href="#ThreadLocal-的常见应用场景" class="headerlink" title="ThreadLocal 的常见应用场景"></a><code>ThreadLocal</code> 的常见应用场景</h3><p><code>ThreadLocal</code> 最常见的应用场景是在 Web 开发中，用于<strong>存储与当前请求相关的上下文信息</strong>。</p><p>例如，一个 HTTP 请求从进入服务器到返回响应，可能由多个方法或组件来处理，但它们都属于同一个线程。如果需要传递一些请求相关的状态（比如用户身份、事务 ID、数据库连接），我们有很多种做法：</p><ul><li><strong>参数传递</strong>：将这些信息作为参数层层传递。这会导致方法签名变得臃肿，并且增加了代码的耦合性。</li><li><strong>静态变量</strong>：如果用静态变量，多个请求同时到达时会互相覆盖，导致线程不安全。</li><li><strong>ThreadLocal</strong>：这是最优雅的解决方案。你可以把这些信息存入 <code>ThreadLocal</code>，然后在任何需要的地方直接通过 <code>get()</code> 方法获取，无需在方法间显式传递。</li></ul><p><strong>典型的例子：</strong></p><ul><li><strong>Spring 的事务管理</strong>：Spring 框架在处理事务时，会使用 <code>ThreadLocal</code> 来保存每个线程的数据库连接，确保在同一个事务中的所有操作都使用同一个连接。</li><li><strong>上下文信息</strong>：例如，在请求处理链中，将用户登录信息、语言偏好等数据存入 <code>ThreadLocal</code>，下游的业务逻辑可以随时获取。</li></ul><hr><h3 id="ThreadLocal-可能带来的问题"><a href="#ThreadLocal-可能带来的问题" class="headerlink" title="ThreadLocal 可能带来的问题"></a><code>ThreadLocal</code> 可能带来的问题</h3><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><strong>内存泄漏</strong></h4><p><code>ThreadLocal</code> 可能会导致<strong>内存泄漏</strong>。这是一个非常重要的问题。</p><p><code>ThreadLocalMap</code> 使用的是<strong>弱引用（Weak Reference）</strong> 作为键。这意味着，当 <code>ThreadLocal</code> 对象没有其他强引用时，即使它还在 <code>ThreadLocalMap</code> 中，垃圾回收器也会回收它。</p><p>但是，<code>ThreadLocalMap</code> 的值（也就是你存入的对象）是<strong>强引用</strong>。如果线程一直存活，但你不再使用 <code>ThreadLocal</code> 对象，<code>ThreadLocalMap</code> 中的键就会变成 <code>null</code>，但值还在。这样，值对象就无法被回收，导致内存泄漏。</p><p>如何避免？</p><p>解决这个问题的关键在于：在 ThreadLocal 使用完毕后，务必调用 remove() 方法。</p><p>在 Web 应用中，请求处理结束后，线程会被放回线程池。如果 <code>ThreadLocal</code> 没有被清除，那么下一次其他请求再拿到这个线程时，它会读取到上一个请求残留的数据，导致业务逻辑出错。因此，<strong>正确使用模式</strong>通常是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;My Data&quot;</span>);</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 确保在任何情况下都执行清理操作</span></span><br><span class="line">    threadLocal.remove(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code> 使用弱引用作为键，但使用强引用作为值，这样做主要是为了优化内存管理并处理由 <code>ThreadLocal</code> 引起的潜在内存泄漏问题。这种设计虽然能解决一些问题，但也引入了新的挑战。</p><h3 id="为什么键是弱引用？"><a href="#为什么键是弱引用？" class="headerlink" title="为什么键是弱引用？"></a>为什么键是弱引用？</h3><p><code>ThreadLocalMap</code> 的键是 <code>ThreadLocal</code> 对象的弱引用。当一个 <code>ThreadLocal</code> 对象没有其他地方（比如一个变量）引用它时，它就会被垃圾回收器回收。</p><ul><li><strong>避免键的内存泄漏：</strong> 如果键是强引用，即使 <code>ThreadLocal</code> 对象在程序中不再被使用，只要线程还活着，这个 <code>ThreadLocalMap</code> 实例就会一直持有对它的强引用，导致 <code>ThreadLocal</code> 对象本身无法被回收，从而引起内存泄漏。通过使用弱引用，当 <code>ThreadLocal</code> 变量超出作用域后，即使线程依然存活，<code>ThreadLocalMap</code> 中的键也会被自动回收。</li></ul><h3 id="为什么值是强引用？"><a href="#为什么值是强引用？" class="headerlink" title="为什么值是强引用？"></a>为什么值是强引用？</h3><p>与键不同，<code>ThreadLocalMap</code> 的值（也就是你通过 <code>set</code> 方法存入的对象）是强引用。</p><ul><li><strong>确保值的可用性：</strong> 如果值也是弱引用，那么当 <code>ThreadLocal</code> 变量超出作用域后，值也可能随时被垃圾回收器回收。这样一来，当你再次通过 <code>get</code> 方法访问时，就会得到 <code>null</code>，这与 <code>ThreadLocal</code> 的使用初衷相悖。<code>ThreadLocal</code> 的目的是为每个线程提供独立的、可以持续访问的变量副本。</li></ul><h3 id="这种设计带来的内存泄漏问题"><a href="#这种设计带来的内存泄漏问题" class="headerlink" title="这种设计带来的内存泄漏问题"></a>这种设计带来的内存泄漏问题</h3><p>虽然键的弱引用设计解决了 <code>ThreadLocal</code> 对象的内存泄漏，但如果开发者没有正确地处理，仍然会导致值的内存泄漏。</p><p>考虑以下场景：</p><ol><li>你在一个线程中创建了一个 <code>ThreadLocal</code> 对象，并设置了一个值。</li><li><code>ThreadLocalMap</code> 中会有一个键值对，键是 <code>ThreadLocal</code> 对象的弱引用，值是你设置的对象。</li><li><code>ThreadLocal</code> 对象在外部不再被强引用，被垃圾回收器回收。</li><li>此时 <code>ThreadLocalMap</code> 中的键变为 <code>null</code>，但值依然存在，因为它是一个强引用。</li></ol><p>如果线程一直存活（比如在线程池中），而你没有手动调用 <code>ThreadLocal.remove()</code>，那么这个值为 <code>null</code> 的键值对就会一直占用内存，导致内存泄漏。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了解决这个问题，Java 社区推荐的<strong>最佳实践</strong>是：<strong>无论何时使用完 ThreadLocal 变量，都应该显式地调用 ThreadLocal.remove() 方法。</strong></p><p><code>ThreadLocal.remove()</code> 会从 <code>ThreadLocalMap</code> 中移除对应的键值对，从而释放内存，避免内存泄漏。这个操作通常应该放在 <code>finally</code> 块中，以确保即使发生异常，也能执行清理工作。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;MyObject&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(<span class="keyword">new</span> <span class="title class_">MyObject</span>());</span><br><span class="line">    <span class="comment">// 业务逻辑...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>总而言之，<code>ThreadLocalMap</code> 的设计是一种<strong>平衡</strong>。它利用弱引用来自动处理 <code>ThreadLocal</code> 对象的回收，从而减轻了开发者的负担。但与此同时，它把值的清理责任留给了开发者，要求我们通过 <code>remove()</code> 方法来显式地释放内存，从而避免因长期存活的线程而导致的值的内存泄漏。</p><h4 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a><strong>继承问题</strong></h4><p><code>ThreadLocal</code> 的值不会自动传递给子线程。如果你需要父线程创建子线程时，让子线程也能访问父线程的 <code>ThreadLocal</code> 值，你需要使用 <code>InheritableThreadLocal</code>。不过，<code>InheritableThreadLocal</code> 同样需要注意内存泄漏问题，并且在线程池环境下使用时可能会有意外行为，需要格外小心。</p><h2 id="Collection-集合框架"><a href="#Collection-集合框架" class="headerlink" title="Collection (集合框架):"></a>Collection (集合框架):</h2><ul><li>核心接口: Collection (父接口), List, Set, Map。</li><li>Iterable 接口: Collection 接口继承了 Iterable 接口,使得所有集合都可以通过增强for 循环(foreach)进行遍历。</li></ul><h4 id="A-List-接口及其实现类"><a href="#A-List-接口及其实现类" class="headerlink" title="A. List 接口及其实现类"></a>A. List 接口及其实现类</h4><p>List 是一种有序集合,可以包含重复元素。</p><h5 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h5><ul><li><p>底层实现:基于动态数组(Object[] elementData)实现。</p></li><li><p>特点:</p><ul><li>有序:元素有插入顺序,可以通过索引访问(get(index))。</li><li>可重复:允许存储重复元素。</li><li>随机访问效率高:通过索引访问元素(get(index))速度非常快,时间复杂度为O(1)。这是因为数组在内存中是连续存储的,可以通过基地址和偏移量直接计算出元素的内存地址。</li><li>插入和删除效率低:<ul><li>在数组末尾添加或删除元素效率较高(平均O(1))。</li><li>在数组中间插入或删除元素时,需要使用System.arraycopy()移动被影响位置之后的所有元素,时间复杂度为 O(n)。</li></ul></li><li>线程不安全:在多线程环境下,如果一个线程正在修改 ArrayList,而另一个线程正在读取或修改它,可能会导致数据不一致或 ConcurrentModificationException(在使用迭代器时)。</li></ul></li><li><p>扩容机制:</p><ul><li>初始容量:默认情况下,当你创建一个无参的ArrayList时,它的底层数组是空的(DEFAULTCAPACITY_EMPTY_ELEMENTDATA, 即 new Object[0])。首次添加元素时,内部数组会被初始化为默认容量 DEFAULT_CAPACITY (JDK8为10)。如果你在创建时指定了容量(new ArrayList&lt;&gt;(capacity)),则初始容量就是你指定的。</li><li>扩容时机:当ArrayList 的当前元素个数(size)等于底层数组的容量(elementData.length)时,就会触发扩容。</li><li>扩容方式:扩容逻辑位于grow()方法中。<ul><li>计算新的容量:newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),即新容量是旧容量的1.5倍。</li><li>如果计算出的新容量仍然小于需要的最小容量(minCapacity,即当前元素个数 size + 1),则直接将 minCapacity 作为新容量。</li><li>如果新容量超出了MAX_ARRAY_SIZE(通常是 Integer.MAX_VALUE-8),则会尝试使用 Integer.MAX_VALUE,如果仍不足则抛出 OutOfMemoryError。</li><li>创建一个新数组,并将旧数组中的元素复制到新数组中(Arrays.copyOf()内部调用 System.arraycopy())。</li></ul></li></ul></li><li><p>为什么这么扩容(1.5倍):</p><ul><li>平衡空间与时间:<ul><li>相比于每次只增加1个元素,1.5倍的扩容策略减少了扩容的次数,从而减少了频繁进行数组复制带来的性能开销(数组复制是O(n)操作)。</li><li>相比于2倍扩容,1.5倍的策略在空间利用率上更优,避免了过度分配和浪费过多内存。</li></ul></li><li>这是一个在时间和空间之间权衡的选择,旨在提供一个相对高效且内存友好的动态数组实现。</li></ul></li><li><p>可能出现的问题:</p><ul><li>ConcurrentModificationException: 在多线程环境中,如果一个线程正在遍历 ArrayList(通过迭代器或增强 for循环),而另一个线程同时对其进行结构性修改(添加、删除元素等),就会抛出此异常。这是因为ArrayList 的迭代器是快速失败(fail-fast)的,它会检查 modCount(修改次数)是否与迭代器创建时一致。不一致则抛出异常。</li><li>内存开销:如果预估容量不准确,频繁扩容会导致多次数组复制,增加 CPU和内存开销。</li><li>内存浪费:如果初始容量设置过大,而实际使用的元素很少,会导致内存浪费。</li></ul></li><li><p>常用方法:</p><ul><li>add(E e): 在列表末尾添加元素。</li><li>add(int index, E e): 在指定位置插入元素。</li><li>remove(int index) &#x2F; remove(Object o): 删除指定位置或指定元素的第一个匹配项。</li><li>get(int index):获取指定位置的元素。</li><li>set(int index, E e): 替换指定位置的元素。</li><li>size(): 返回列表中元素的个数。</li><li>indexOf(Object o) &#x2F; lastIndexOf(Object o):返回元素第一次&#x2F;最后一次出现的索引。</li><li>contains(Object o): 判断是否包含某个元素。</li><li>clear(): 清空列表。</li></ul></li><li><p>遍历方式:</p><ol><li><p>传统 for 循环:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增强 for 循环(foreach):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (E element: list) &#123; <span class="comment">//内部使用迭代器</span></span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代器(Iterator):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">    <span class="comment">// 如果需要删除元素,必须使用 it.remove(),否则会抛出</span></span><br><span class="line">    <span class="comment">// ConcurrentModificationException</span></span><br><span class="line">    <span class="comment">// it.remove();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Java 8 Stream API:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">list.stream().forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><code>RandomAccess</code> 是 Java 集合框架中的一个<strong>标记接口</strong>，它本身不包含任何方法。它的主要作用是告诉 Java 虚拟机（JVM）和开发者，实现了这个接口的 <code>List</code> 集合<strong>支持快速随机访问</strong>，即通过索引访问元素时，性能是恒定的，通常为 O(1)。</p><hr><h3 id="ArrayList-实现-RandomAccess-的作用"><a href="#ArrayList-实现-RandomAccess-的作用" class="headerlink" title="ArrayList 实现 RandomAccess 的作用"></a><code>ArrayList</code> 实现 <code>RandomAccess</code> 的作用</h3><p><code>ArrayList</code> 的底层是<strong>数组</strong>。通过索引访问数组元素（如 <code>list.get(i)</code>）是一个非常高效的操作，因为它直接通过内存地址偏移量来查找，耗时是固定的。</p><p><code>RandomAccess</code> 接口的作用就是为这种特性提供一个<strong>标记</strong>。在某些算法或方法中（比如 <code>Collections.binarySearch()</code>），程序会先检查一个 <code>List</code> 是否实现了 <code>RandomAccess</code>。</p><ul><li>如果实现了，就说明它是 <code>ArrayList</code> 这类基于数组的列表，此时会选择<strong>基于索引的 for 循环</strong>进行遍历，因为这种方式最快。</li><li>如果没实现，就说明它是 <code>LinkedList</code> 这类基于链表的列表，此时会选择<strong>迭代器</strong>进行遍历，以避免低效的随机访问。</li></ul><p>因此，<code>RandomAccess</code> 就像一个性能提示标签，帮助 JVM 和算法选择最合适的遍历或查找策略，从而优化性能。</p><hr><h3 id="为什么-LinkedList-没有实现-RandomAccess？"><a href="#为什么-LinkedList-没有实现-RandomAccess？" class="headerlink" title="为什么 LinkedList 没有实现 RandomAccess？"></a>为什么 <code>LinkedList</code> 没有实现 <code>RandomAccess</code>？</h3><p><code>LinkedList</code> 的底层是<strong>双向链表</strong>。要通过索引访问链表中的一个元素（如 <code>list.get(i)</code>），需要从头节点或尾节点开始，逐个遍历到目标位置。这个操作的耗时与索引值 <code>i</code> 成正比，时间复杂度为 O(n)。</p><p>因为 <code>LinkedList</code> 不支持快速随机访问，所以它没有实现 <code>RandomAccess</code> 接口。如果用 for 循环来遍历 <code>LinkedList</code>，每次 <code>get(i)</code> 调用都会导致一次从头到尾的遍历，效率极低。相反，使用迭代器则能确保每次只移动到下一个元素，效率更高。</p><table><thead><tr><th>类型</th><th>底层数据结构</th><th>随机访问性能 (<code>get(i)</code>)</th><th>遍历方式</th><th>是否实现 <code>RandomAccess</code></th></tr></thead><tbody><tr><td><strong>ArrayList</strong></td><td>数组</td><td>O(1)</td><td><strong>for 循环</strong></td><td>是</td></tr><tr><td><strong>LinkedList</strong></td><td>双向链表</td><td>O(n)</td><td><strong>迭代器</strong></td><td>否</td></tr></tbody></table><p>总而言之，<code>RandomAccess</code> 接口是一个重要的设计模式，它利用多态性来指导程序为不同的 <code>List</code> 实现选择最优的算法，从而在不修改代码逻辑的前提下提升了性能。</p><h5 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h5><ul><li><p>底层实现:基于双向链表(Doubly Linked List)实现。每个节点都包含数据,以及指向前一个节点和后一个节点的引用。</p></li><li><p>特点:</p><ul><li>有序:元素有插入顺序。</li><li>可重复:允许存储重复元素。</li><li>插入和删除效率高:在链表的任何位置插入或删除元素,只需修改前后节点的引用,时间复杂度为O(1)。</li><li>随机访问效率低:get(index)操作需要从头节点或尾节点开始遍历链表直到目标索引,时间复杂度为O(n)。</li><li>内存开销大:每个节点除了存储数据本身,还需要额外的内存空间存储两个指针(prev 和 next),因此相比 ArrayList,在存储相同数量元素时, LinkedList 占用更多内存。</li><li>线程不安全:与ArrayList 类似,在多线程环境下不安全,可能抛出 ConcurrentModificationException。</li></ul></li><li><p>扩容机制:</p><ul><li>LinkedList 基于链表实现,没有固定容量的概念,也无需进行扩容。每次添加元素就是创建一个新节点并连接到链表中。因此不存在 ArrayList 那样的数组复制开销。</li></ul></li><li><p>可能出现的问题:</p><ul><li>ConcurrentModification Exception:同样在多线程环境下使用迭代器进行修改时可能发生。</li><li>内存碎片&#x2F;开销:频繁的节点创建和销毁,以及每个节点额外的指针开销,可能导致一定的内存碎片和更高的内存占用。</li></ul></li><li><p>常用方法:</p><ul><li>add(E e) &#x2F; addFirst(E e) &#x2F; addLast(E e): 添加元素。</li><li>remove() &#x2F; removeFirst() &#x2F; removeLast():删除元素。</li><li>get(int index) &#x2F; getFirst() &#x2F; getLast(): 获取元素(get(int index)效率低)。</li><li>peek() &#x2F; peekFirst() &#x2F; peekLast(): 获取但不移除头部&#x2F;尾部元素。</li><li>offer(E e) &#x2F; offerFirst(E e) &#x2F; offerLast (E e): 添加元素到队列&#x2F;双端队列(通常不抛异常)。</li><li>poll() &#x2F; pollFirst() &#x2F; pollLast(): 获取并移除头部&#x2F;尾部元素(为空返回null)。</li><li>push(E e) &#x2F; pop():实现栈的入栈和出栈操作。</li><li>size(), isEmpty(), contains(Object o), clear().</li></ul></li><li><p>遍历方式:</p><ol><li><p>传统 for 循环: <code>for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125;</code>(不推荐,效率低)</p></li><li><p>增强 for 循环(foreach): <code>for (E element: list) &#123; System.out.println(element); &#125;</code>(推荐)</p></li><li><p>迭代器(Iterator):</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Java 8 Stream API: <code>list.forEach(System.out::println);</code></p></li></ol></li></ul><h5 id="3-Vector"><a href="#3-Vector" class="headerlink" title="3. Vector"></a>3. Vector</h5><ul><li>底层实现:基于动态数组实现,与ArrayList 类似。</li><li>特点:<ul><li>线程安全:所有公共方法都使用了synchronized 关键字进行同步,因此是线程安全的。</li><li>效率低:因为所有操作都被同步,在单线程或并发读多写少的场景下,性能比 ArrayList 差。</li><li>扩容机制: Vector 的扩容策略与 ArrayList 类似,但默认是翻倍扩容(即新容量是旧容量的2倍)。可以通过构造函数指定扩容增量。</li></ul></li><li>可能出现的问题:<ul><li>性能瓶颈:全局锁导致并发性能差。</li></ul></li><li>使用场景:已经被 java.util.concurrent 包中的并发集合(如 CopyOnWriteArrayList)取代,基本不再推荐使用。</li></ul><h5 id="4-Stack"><a href="#4-Stack" class="headerlink" title="4. Stack"></a>4. Stack</h5><ul><li>底层实现:继承自Vector,因此也是基于数组实现,并具有Vector 的线程安全性。</li><li>特点:实现了后进先出(LIFO)的栈结构。</li><li>常用方法:<ul><li>push(E item):元素入栈。</li><li>pop():元素出栈。</li><li>peek(): 查看栈顶元素但不移除。</li><li>empty(): 判断栈是否为空。</li><li>search(Object o): 查找元素并返回离栈顶的距离。</li></ul></li><li>使用场景:不推荐使用,因为Stack 继承了Vector,而 Vector 本身有很多不适合栈操作的方法。通常使用 Deque 接口的实现类(如ArrayDeque 或 LinkedList)来代替栈,它们更灵活高效。</li></ul><h4 id="小结-List"><a href="#小结-List" class="headerlink" title="小结 List:"></a>小结 List:</h4><ul><li>ArrayList: 随机访问多,插入删除少(尤其末尾操作)的场景。</li><li>LinkedList: 插入删除多,随机访问少的场景;或需要作为队列&#x2F;栈使用的场景。</li><li>Vector &#x2F; Stack:不推荐在现代Java开发中使用,除非有特殊历史兼容需求。</li></ul><h4 id="B-Set-接口及其实现类"><a href="#B-Set-接口及其实现类" class="headerlink" title="B. Set 接口及其实现类"></a>B. Set 接口及其实现类</h4><p>Set 是一种无序集合,不允许重复元素。</p><h5 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h5><ul><li><p>底层实现:基于HashMap 实现。HashSet 内部使用一个 HashMap 实例来存储元素,HashSet 的元素作为HashMap的键(Key),而HashMap 的值(Value)则是一个固定的、无关紧要的 PRESENT 静态 Object 对象。</p></li><li><p>特点:</p><ul><li>无序:不保证元素的存储顺序和迭代顺序。</li><li>不可重复:元素唯一。通过元素的hashCode() 和 equals() 方法来判断元素的唯一性。当添加元素时,首先计算元素的hashCode(),然后根据哈希值找到对应的“桶”,再在该桶中遍历,如果存在 equals()为true 的元素,则不添加。</li><li>允许 null元素:允许且只能存储一个 null 元素。</li><li>查询、添加、删除的平均时间复杂度为(1) (在不发生哈希冲突或冲突较少的情况下)。最坏情况下(所有元素哈希冲突到同一个桶),会退化为 O(n)。</li><li>线程不安全:与HashMap 类似,非同步。</li></ul></li><li><p>扩容机制:</p><ul><li>由于底层是HashMap,其扩容机制与 HashMap 完全相同。</li><li>初始容量:默认初始容量为16。</li><li>负载因子:默认负载因子为0.75。</li><li>扩容时机:当HashSet 中存储的元素数量达到容量*负载因子时,就会进行扩容,新容量是旧容量的2倍。</li><li>扩容过程:创建一个新的两倍大小的底层数组,然后遍历旧数组中的所有元素,重新计算它们的哈希值,并将它们放入新数组的正确位置。</li></ul></li><li><p>可能出现的问题:</p><ul><li>性能下降: 如果自定义类作为元素存储在 HashSet 中，但没有正确重写 hashCode() 和 equals() 方法，可能会导致元素重复，或者哈希冲突严重，从而导致性能急剧下降。</li><li>ConcurrentModicationException: 同步性问题，在多线程环境下使用迭代器修改集合时会抛出。</li></ul></li><li><p>常用方法:</p><ul><li>add(E e): 添加元素。</li><li>remove(Object o): 删除元素。</li><li>contains(Object o): 判断是否包含元素。</li><li>size(): 返回集合中元素的个数。</li><li>isEmpty(), clear().</li></ul></li><li><p>遍历方式:</p><ol><li><p>增强 for 循环 (foreach): <code>for (E element : set) &#123; System.out.println(element); &#125;</code></p></li><li><p>迭代器 (Iterator):</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = set.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Java 8 Stream API: <code>set.forEach(System.out::println);</code></p></li></ol></li></ul><h5 id="2-LinkedHashSet"><a href="#2-LinkedHashSet" class="headerlink" title="2. LinkedHashSet"></a>2. LinkedHashSet</h5><ul><li>底层实现: 继承自 HashSet，内部使用 LinkedHashMap 实现。</li><li>特点:<ul><li>除了具备 HashSet 的所有特性外，最大的特点是保持元素的插入顺序（或者访问顺序，如果配置为 LRU 缓存）。这意味着遍历 LinkedHashSet时，元素的顺序与它们被添加到集合中的顺序一致。</li><li>维护了一个双向链表，用于维护元素的插入顺序。</li></ul></li><li>扩容机制: 与 HashSet 和 HashMap 相同。</li><li>使用场景: 需要去重，同时又需要保持元素插入顺序的场景。</li></ul><h5 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3. TreeSet"></a>3. TreeSet</h5><ul><li>底层实现: 基于 TreeMap 实现。TreeSet 内部使用一个 TreeMap 实例来存储元素，TreeSet 的元素作为 TreeMap 的键，而值则是一个固定的 Object。</li><li>特点:<ul><li>有序: 元素会根据其自然排序（元素必须实现 Comparable 接口）或者在创建 TreeSet 时提供的 Comparator 进行排序。</li><li>不可重复: 元素唯一，唯一性通过比较结果判断（compareTo() 或 compare() 方法返回 0）。</li><li>不允许 null 元素: 不允许存储 null 元素（因为 null 无法进行比较）。</li><li>查询、添加、删除的时间复杂度为 O(log n)，因为底层是红黑树。</li><li>线程不安全: 非同步。</li></ul></li><li>扩容机制:<ul><li>由于底层是红黑树，没有传统意义上的扩容机制。每次添加元素就是增加一个节点，并根据红黑树的平衡规则进行调整（旋转和变色）来保持树的平衡。</li></ul></li><li>可能出现的问题:<ul><li>性能: 相比 HashSet，性能略低，因为涉及比较和树的平衡操作。</li><li>元素必须可比较: 如果存储的元素没有实现 Comparable 接口，或者创建 TreeSet 时没有提供 Comparator，则会抛出 ClassCastException。</li><li>ConcurrentModicationException: 同步性问题。</li></ul></li><li>常用方法:<ul><li>与 HashSet 类似，但额外提供了与排序相关的方法，如 rst(), last(), headSet(), tailSet(), subSet() 等。</li></ul></li></ul><h4 id="小结-Set"><a href="#小结-Set" class="headerlink" title="小结 Set:"></a>小结 Set:</h4><ul><li>HashSet: 最常用，需要快速查找、去重，不关心元素顺序的场景。</li><li>LinkedHashSet: 需要去重，同时又需要保持元素插入顺序的场景。</li><li>TreeSet: 需要去重，并且希望元素自动按照自然顺序或自定义顺序排序的场景。</li></ul><h4 id="C-Map-接口及其实现类"><a href="#C-Map-接口及其实现类" class="headerlink" title="C. Map 接口及其实现类"></a>C. Map 接口及其实现类</h4><p>Map 存储键值对，键是唯一的，值可以重复。</p><h5 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h5><ul><li><p>底层实现: 基于哈希表实现，JDK 8 及以后是数组 + 链表 + 红黑树。</p><ul><li>数组: Node</li><li>链表: 用于解决哈希冲突，将哈希到同一个索引位置的键值对以链表形式连接。</li><li>红黑树: 当链表长度达到一定阈值（JDK 8 默认为 8）时，为了提高查找效率，该链表会转换为红黑树。当红黑树节点数少于一定阈值（JDK 8 默认为 6）时，会退化为链表。</li></ul></li><li><p>特点:</p><ul><li>无序: 不保证键值对的存储和迭代顺序。</li><li>键唯一，值可重复: 键通过 hashCode() 和 equals() 方法确定唯一性。</li><li>允许 null 键和 null 值: 只能有一个 null 键（存储在索引 0 的位置），可以有多个 null 值。</li><li>查询、添加、删除的平均时间复杂度为 O(1)，最坏情况下为 O(n)（链表）或 O(logn)（红黑树，JDK 8 及以后）。</li></ul></li><li><p>扩容机制:</p><ul><li><p>初始容量 (initialCapacity): 默认值为 16。最好在创建 HashMap 时预估并指定一个合适的初始容量，以减少扩容次数。</p></li><li><p>负载因子 (loadFactor): 默认值为 0.75。表示哈希表在进行扩容前的填充比例。</p></li><li><p>扩容时机: 当 HashMap 中存储的元素数量 (size) 达到 容量 * 负载因子 (即 threshold) 时，就会触发扩容。</p></li><li><p>扩容方式: resize() 方法。</p><ol><li>创建一个新的两倍大小的底层数组。</li><li>遍历旧数组中的所有键值对。</li><li>重新计算每个键的哈希值，并根据新的容量大小，将其放入新数组的正确位置。这个过程被称为再哈希 (rehash)。</li></ol><ul><li>JDK 8 优化: 在链表转换时，避免了每个节点单独重新计算哈希值，而是根据原索引和新容量的关系，直接判断节点在新数组中的位置，提高了效率。</li></ul></li></ul></li><li><p>为什么这么扩容 (2 倍):</p><ul><li>位运算优化: 容量始终保持 2 的幂次方，可以利用位运算 (h &amp; (length - 1)) 来替代取模运算 h % length，提高哈希值到索引的映射效率。</li><li>减少哈希冲突: 扩容为 2 倍可以有效分散哈希冲突，使得更多的键能够映射到不同的桶，从而降低链表&#x2F;红黑树的长度，保持 O(1) 的平均性能。</li></ul></li><li><p>为什么负载因子是 0.75:</p><ul><li>这是一个在“空间利用率”和“查询效率”之间的权衡。</li><li>如果负载因子过小，会频繁扩容，浪费空间。</li><li>如果负载因子过大，哈希冲突会增加，链表&#x2F;红黑树变长，导致查询效率下降。</li><li>0.75 这个值是经过实践验证，在大多数情况下能够提供较好性能的平衡点。</li></ul></li><li><p>可能出现的问题:</p><ul><li>性能下降: 如果自定义类作为键存储在 HashMap 中，但没有正确重写 hashCode() 和 equals() 方法，会导致元素重复，或者哈希冲突严重，从而导致性能急剧下降。</li><li>多线程问题: 在多线程环境下，对 HashMap 进行修改操作可能导致数据丢失、死循环（JDK 7 及以前），或 ConcurrentModicationException。这是其最大的问题。</li><li>内存开销: 频繁扩容会带来数组复制的开销。</li></ul></li><li><p>常用方法:</p><ul><li>put(K key, V value): 关联键值对。</li><li>get(Object key):</li></ul></li><li><p>遍历方式:</p><ol><li><p>遍历键集 (keySet()):</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (K key : map.keySet()) &#123;</span><br><span class="line">    V value = map.get(key);</span><br><span class="line">    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>遍历键值对集 (entrySet()) - 推荐，效率最高:</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Value: &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>遍历值集 (values()):</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (V value : map.values()) &#123;</span><br><span class="line">    System.out.println(&quot;Value: &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>迭代器 (Iterator):</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = it.next();</span><br><span class="line">    System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Value: &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Java 8 Stream API:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br></pre></td></tr></table></figure></li></ol></li></ul><h5 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2. LinkedHashMap"></a>2. LinkedHashMap</h5><ul><li>底层实现: 继承自 HashMap，额外维护了一个双向链表，用于维护插入顺序或访问顺序。</li><li>特点:<ul><li>除了具备 HashMap 的所有特性外，最大的特点是保持键值对的插入顺序（或访问顺序）。这意味着遍历 LinkedHashMap 时，元素的顺序与它们被添加到 Map 中的顺序一致。</li><li>可以用于实现 LRU (Least Recently Used) 缓存策略，通过覆盖 removeEldestEntry 方法并设置访问顺序为 true。</li></ul></li><li>扩容机制: 与 HashMap 相同。</li><li>使用场景: 需要快速查找，同时又需要保持插入顺序的场景。</li></ul><h5 id="3-TreeMap"><a href="#3-TreeMap" class="headerlink" title="3. TreeMap"></a>3. TreeMap</h5><ul><li>底层实现: 基于红黑树（Red-Black Tree）实现。</li><li>特点:<ul><li>有序: 键会根据其自然排序（键的类型必须实现 Comparable 接口）或者在创建 TreeMap 时提供的 Comparator 进行排序。</li><li>键唯一，值可重复: 唯一性判断依赖于键的比较结果（compareTo() 或 compare() 方法返回 0）。</li><li>不允许 null 键: 不允许存储 null 键（因为 null 无法进行比较），但允许 null 值。</li><li>查询、添加、删除的时间复杂度为 O(log n)，因为底层是红黑树。</li><li>线程不安全: 非同步。</li></ul></li><li>扩容机制:<ul><li>由于底层是红黑树，没有传统意义上的扩容机制。每次添加键值对就是增加一个节点，并根据红黑树的平衡规则进行调整（旋转和变色）来保持树的平衡。</li></ul></li><li>可能出现的问题:<ul><li>性能: 相比 HashMap，性能略低，因为涉及比较和树的平衡操作。</li><li>键必须可比较: 如果键没有实现 Comparable 接口，或者创建 TreeMap 时没有提供 Comparator，则会抛出 ClassCastException。</li><li>ConcurrentModicationException: 同步性问题。</li></ul></li><li>常用方法:<ul><li>与 HashMap 类似，但额外提供了与排序相关的方法，如 rstKey(), lastKey(), ceilingEntry(), oorEntry() 等。</li></ul></li></ul><h5 id="4-Hashtable"><a href="#4-Hashtable" class="headerlink" title="4. Hashtable"></a>4. Hashtable</h5><ul><li>底层实现: 基于哈希表实现，与 HashMap 类似，但所有方法都使用了 synchronized 关键字。</li><li>特点:<ul><li>线程安全: 所有公共方法都进行了同步处理。</li><li>效率低: 全局锁导致并发性能差。</li><li>不允许 null 键和 null 值。</li><li>初始容量和扩容机制: 默认初始容量 11，负载因子 0.75。扩容时新容量是旧容量的 2 倍 + 1。</li></ul></li><li>使用场景: 已被 ConcurrentHashMap 取代，基本不再推荐使用。</li></ul><h5 id="5-ConcurrentHashMap-JUC-包中的并发集合"><a href="#5-ConcurrentHashMap-JUC-包中的并发集合" class="headerlink" title="5. ConcurrentHashMap (JUC 包中的并发集合)"></a>5. ConcurrentHashMap (JUC 包中的并发集合)</h5><ul><li><p>底层实现:</p><ul><li>JDK 7 及以前: 采用分段锁 (Segment) 的方式，将 HashMap 内部数据分成多个段（Segment），每个段是一个独立的 ReentrantLock。锁住某个段时，不影响其他段的操作。</li><li>JDK 8 及以后: 放弃了分段锁，改为使用 CAS (Compare-And-Swap) 操作和 synchronized 关键字（只在链表&#x2F;红黑树头节点发生竞争时才使用，锁住的范围更小）来保证线程安全。</li></ul></li><li><p>特点:</p><ul><li>线程安全: 高并发环境下性能优异。</li><li>不允许 null 键和 null 值。</li><li>读操作基本无锁。</li></ul></li><li><p>扩容机制: 与 HashMap 类似，JDK 8 中，每个 Node 数组的扩容是独立的，通过 transfer 方法实现。</p></li><li><p>使用场景: 高并发场景下替代 HashMap 和 Hashtable 的首选。</p></li><li><p><code>java.util.concurrent</code> (JUC) 包是 Java 并发编程的高级工具包，它提供了比传统 <code>synchronized</code> 关键字和 <code>wait/notify</code> 机制更强大、更灵活的并发控制手段。</p></li></ul><p>好的 ✅ 我来帮你把前面两个回答 <strong>整合成一个完整、系统、逐层递进的 ConcurrentHashMap 解析文档</strong>，内容覆盖 <strong>实现原理 + 扩容机制 + 高频面试题 + 答题模板</strong>，你可以直接拿去当复习资料或面试答题脚本。</p><hr><h1 id="🧩-ConcurrentHashMap-超详细解析（JDK8为主，含对比）"><a href="#🧩-ConcurrentHashMap-超详细解析（JDK8为主，含对比）" class="headerlink" title="🧩 ConcurrentHashMap 超详细解析（JDK8为主，含对比）"></a>🧩 ConcurrentHashMap 超详细解析（JDK8为主，含对比）</h1><hr><h2 id="一、背景与设计动机"><a href="#一、背景与设计动机" class="headerlink" title="一、背景与设计动机"></a>一、背景与设计动机</h2><p>在并发场景下：</p><ul><li><code>HashMap</code> 线程不安全，可能出现死循环、数据丢失。</li><li><code>Hashtable</code> 与 <code>Collections.synchronizedMap</code> 使用 <strong>全表锁</strong>，吞吐量极差。</li></ul><p><strong>ConcurrentHashMap（CHM）</strong>：</p><ul><li><strong>线程安全</strong>：保证多线程同时访问时数据一致性。</li><li><strong>高性能</strong>：通过 <strong>分桶锁 + CAS + volatile</strong> 提升并发度。</li><li><strong>弱一致性迭代器</strong>：遍历过程中允许修改，不会抛 <code>ConcurrentModificationException</code>。</li></ul><hr><h2 id="二、实现演变（JDK7-vs-JDK8）"><a href="#二、实现演变（JDK7-vs-JDK8）" class="headerlink" title="二、实现演变（JDK7 vs JDK8）"></a>二、实现演变（JDK7 vs JDK8）</h2><h3 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h3><ul><li>数据结构：<code>Segment[]</code> + <code>HashEntry[]</code>。</li><li>Segment：类似小型 HashMap，每个 Segment 有独立的 ReentrantLock。</li><li>并发度：由 Segment 数量决定（默认 16）。</li></ul><p>缺点：</p><ul><li>锁粒度仍然较大；</li><li>扩容需要锁定整个 Segment。</li></ul><hr><h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><ul><li>数据结构：<code>Node[]</code> + 链表&#x2F;红黑树。</li><li>锁机制：<strong>CAS + synchronized（桶锁）</strong>，比 Segment 更细。</li><li>改进点：<ol><li>无 Segment，更细粒度控制。</li><li>链表冲突过长时转化为 <strong>红黑树</strong>（树化）。</li><li>扩容为 <strong>渐进式 + 多线程协助</strong>。</li><li>使用 <strong>ForwardingNode</strong> 路由迁移。</li></ol></li></ul><hr><h2 id="三、核心数据结构"><a href="#三、核心数据结构" class="headerlink" title="三、核心数据结构"></a>三、核心数据结构</h2><h3 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    volatile V val;</span><br><span class="line">    volatile Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>val</code> 和 <code>next</code> 是 <code>volatile</code>，保证可见性。</li></ul><h3 id="TreeNode（红黑树节点）"><a href="#TreeNode（红黑树节点）" class="headerlink" title="TreeNode（红黑树节点）"></a>TreeNode（红黑树节点）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent, left, right, prev;</span><br><span class="line">    boolean red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当链表长度 &gt; 8 且容量 ≥ 64 时转化为红黑树。</li></ul><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><ul><li>扩容时的占位符，用于标记桶已迁移，引导线程访问新表。</li></ul><hr><h2 id="四、核心操作流程"><a href="#四、核心操作流程" class="headerlink" title="四、核心操作流程"></a>四、核心操作流程</h2><h3 id="1-get-——-无锁读"><a href="#1-get-——-无锁读" class="headerlink" title="1. get() —— 无锁读"></a>1. get() —— 无锁读</h3><ul><li>直接计算 hash 定位桶。</li><li>如果是链表 → 遍历；</li><li>如果是红黑树 → 按树查找；</li><li>如果是 ForwardingNode → 去新表查。</li></ul><p><strong>特点</strong>：无锁，只依赖 volatile 保证可见性。</p><hr><h3 id="2-put-——-写时加锁"><a href="#2-put-——-写时加锁" class="headerlink" title="2. put() —— 写时加锁"></a>2. put() —— 写时加锁</h3><ol><li>计算索引位置；</li><li>桶为空 → CAS 插入；</li><li>桶非空：<ul><li>ForwardingNode → 协助扩容；</li><li>链表&#x2F;树 → synchronized 锁住桶头，再插入；</li></ul></li><li>插入后：<ul><li>如果链表长度 &gt; 8 且容量 ≥ 64 → 树化；</li><li>如果总数超过阈值 → 触发扩容。</li></ul></li></ol><hr><h3 id="3-扩容机制（Transfer）"><a href="#3-扩容机制（Transfer）" class="headerlink" title="3. 扩容机制（Transfer）"></a>3. 扩容机制（Transfer）</h3><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><ul><li>size 超过 <code>threshold = capacity * loadFactor</code>（默认 0.75）。</li></ul><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li><strong>新建数组</strong>：容量翻倍。</li><li><strong>迁移桶</strong>：<ul><li>遍历旧桶，将节点分为 <strong>低位链（loHead）</strong> 和 <strong>高位链（hiHead）</strong>。</li><li><code>hash &amp; oldCap == 0</code> → 留在原位置；</li><li>否则 → 放到 <code>i+oldCap</code>。</li></ul></li><li><strong>标记迁移完成</strong>：<ul><li>旧桶置为 ForwardingNode。</li><li>之后读&#x2F;写遇到它时，会路由到新表。</li></ul></li><li><strong>多线程协助</strong>：<ul><li>其他线程写入时若发现正在扩容 → 调用 <code>helpTransfer()</code> → 一起分桶迁移。</li></ul></li><li><strong>渐进式扩容</strong>：<ul><li>一次只迁移一个桶，避免阻塞。</li></ul></li></ol><hr><h2 id="五、并发控制机制"><a href="#五、并发控制机制" class="headerlink" title="五、并发控制机制"></a>五、并发控制机制</h2><ol><li><strong>CAS</strong>：初始化 table、插入第一个节点时。</li><li><strong>volatile</strong>：保证 val 和 next 的可见性。</li><li><strong>synchronized</strong>：写操作时锁定单个桶。</li><li><strong>ForwardingNode</strong>：保证扩容过程数据一致性。</li></ol><hr><h2 id="六、性能特性"><a href="#六、性能特性" class="headerlink" title="六、性能特性"></a>六、性能特性</h2><ul><li>读操作几乎无锁 → 高性能。</li><li>写操作局部锁定 → 粒度小，冲突概率低。</li><li>扩容支持并行迁移 → 避免长时间卡顿。</li><li>树化避免链表退化 O(n)。</li></ul><hr><h2 id="七、常见高频面试题"><a href="#七、常见高频面试题" class="headerlink" title="七、常见高频面试题"></a>七、常见高频面试题</h2><h3 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h3><ol><li><strong>ConcurrentHashMap 和 HashMap 的区别？</strong><ul><li>HashMap：线程不安全；</li><li>ConcurrentHashMap：线程安全，CAS+桶锁；</li><li>数据结构都支持链表+红黑树。</li></ul></li><li><strong>JDK7 和 JDK8 的区别？</strong><ul><li>JDK7：Segment 分段锁；</li><li>JDK8：CAS + synchronized，锁粒度更细。</li></ul></li><li><strong>为什么 synchronized 而不是 ReentrantLock？</strong><ul><li>JDK8 之后对 synchronized 优化（偏向锁、轻量级锁）；</li><li>实现简洁，不需手动释放锁。</li></ul></li></ol><hr><h3 id="进阶题"><a href="#进阶题" class="headerlink" title="进阶题"></a>进阶题</h3><ol><li><strong>为什么 get 无需加锁？</strong><ul><li>Node 的 val、next 是 volatile，可见性足够；</li><li>get 只读，不会修改结构。</li></ul></li><li><strong>为什么需要红黑树？</strong><ul><li>避免哈希冲突严重时链表退化为 O(n)。</li><li>树化后查询 O(log n)。</li></ul></li><li><strong>红黑树什么时候转化&#x2F;退化？</strong><ul><li>链表长度 &gt; 8 且容量 ≥ 64 → 树化；</li><li>树节点数 &lt; 6 → 退化为链表。</li></ul></li></ol><hr><h3 id="扩容相关题"><a href="#扩容相关题" class="headerlink" title="扩容相关题"></a>扩容相关题</h3><ol><li><strong>ConcurrentHashMap 扩容过程？为什么说是渐进式？</strong><ul><li>桶级迁移，每次只迁移一个桶；</li><li>旧桶置为 ForwardingNode；</li><li>多线程可协助迁移；</li><li>不会一次性迁移整个表 → 避免卡顿。</li></ul></li><li><strong>扩容时，get 如何保证正确性？</strong><ul><li>遇到 ForwardingNode → 跳转新表继续查；</li><li>保证读到的是最新数据。</li></ul></li><li><strong>为什么不允许 key 或 value 为 null？</strong><ul><li>无法区分「null 表示没有值」还是「值本身就是 null」，容易歧义。</li></ul></li><li><strong>为什么迭代器是弱一致性的？</strong></li></ol><ul><li>遍历时允许并发修改；</li><li>不抛异常，但可能漏数据或读到旧值。</li></ul><ol><li><strong>size() 如何实现？为什么不精确？</strong></li></ol><ul><li>分段计数，多次尝试累加；</li><li>并发下不保证强一致性，只保证大致准确。</li></ul><hr><h3 id="高阶题"><a href="#高阶题" class="headerlink" title="高阶题"></a>高阶题</h3><ol><li><strong>为什么扩容时使用 ForwardingNode？</strong></li></ol><ul><li>防止重复迁移；</li><li>读写遇到它能路由到新表。</li></ul><ol><li><strong>ConcurrentHashMap 会死锁吗？</strong></li></ol><ul><li>不会。每次只锁单个桶，不存在跨桶死锁。</li></ul><ol><li><strong>ConcurrentHashMap 与 CopyOnWriteMap 区别？</strong></li></ol><ul><li>CHM：适合读多写多，分桶锁+CAS；</li><li>COW：适合读多写少，写时复制，读完全无锁。</li></ul><hr><h2 id="八、答题模板（面试框架）"><a href="#八、答题模板（面试框架）" class="headerlink" title="八、答题模板（面试框架）"></a>八、答题模板（面试框架）</h2><p>当被问到「ConcurrentHashMap」时，可以这样答：</p><ol><li><strong>整体实现</strong>：<ul><li>JDK7：Segment 分段锁；</li><li>JDK8：Node 数组 + CAS + synchronized（桶锁）。</li></ul></li><li><strong>核心思想</strong>：<ul><li>读操作无锁；</li><li>写操作锁单个桶；</li><li>扩容渐进式+多线程协助；</li><li>冲突过长时树化。</li></ul></li><li><strong>扩容机制</strong>：<ul><li>懒扩容，阈值触发；</li><li>ForwardingNode 标记已迁移桶；</li><li>多线程 helpTransfer；</li><li>渐进式迁移，避免阻塞。</li></ul></li><li><strong>常见问题</strong>：<ul><li>不允许 null key&#x2F;value；</li><li>弱一致性迭代器；</li><li>size() 不精确。</li></ul></li></ol><hr><p>📌 <strong>一句话总结口诀</strong>：<br> 👉 <strong>JDK7 Segment 分段锁，JDK8 CAS+桶锁；读无锁，写锁桶，扩容多线程协助；链表转树，弱一致迭代。</strong></p><hr><h1 id="🧩-一、并发工具类（协作类）"><a href="#🧩-一、并发工具类（协作类）" class="headerlink" title="🧩 一、并发工具类（协作类）"></a>🧩 一、并发工具类（协作类）</h1><p>这些工具类都在 <code>java.util.concurrent</code> 包里，用来解决线程间的 <strong>协调&#x2F;同步&#x2F;通信问题</strong>。</p><hr><h2 id="1-CountDownLatch（倒计时器）"><a href="#1-CountDownLatch（倒计时器）" class="headerlink" title="1. CountDownLatch（倒计时器）"></a>1. CountDownLatch（倒计时器）</h2><h3 id="📝-定义"><a href="#📝-定义" class="headerlink" title="📝 定义"></a>📝 定义</h3><ul><li>一个或多个线程等待 <strong>其他线程完成操作</strong> 后再继续。</li><li>内部维护一个 <code>state</code>（计数），初始值设定好，每调用一次 <code>countDown()</code>，<code>state--</code>。</li><li>当 <code>state=0</code> 时，<code>await()</code> 的线程全部唤醒。</li></ul><h3 id="⚙️-底层实现"><a href="#⚙️-底层实现" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul><li>基于 <strong>AQS（AbstractQueuedSynchronizer）</strong> 的共享锁实现。</li><li><code>await()</code> 会阻塞线程，直到 <code>state==0</code>；</li><li><code>countDown()</code> 是非阻塞的，只是原子性地减 1。</li></ul><h3 id="📌-使用场景"><a href="#📌-使用场景" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul><li>主线程等待多个子线程完成（<strong>一等多</strong>）。</li><li>例如：并行加载多个配置文件，等都加载完再合并处理。</li></ul><h3 id="🎯-面试考点"><a href="#🎯-面试考点" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul><li><strong>能否重用？</strong> → <strong>不能</strong>，计数归零后不能重置。</li><li>和 <code>CyclicBarrier</code> 的区别？→ <code>CountDownLatch</code> 是「一等多」，<code>CyclicBarrier</code> 是「多等多」。</li></ul><hr><h2 id="2-CyclicBarrier（循环屏障）"><a href="#2-CyclicBarrier（循环屏障）" class="headerlink" title="2. CyclicBarrier（循环屏障）"></a>2. CyclicBarrier（循环屏障）</h2><h3 id="📝-定义-1"><a href="#📝-定义-1" class="headerlink" title="📝 定义"></a>📝 定义</h3><ul><li>一组线程互相等待，直到所有线程都到达屏障点，再统一出发。</li><li>支持 <strong>循环使用</strong>（计数归零后可重置）。</li></ul><h3 id="⚙️-底层实现-1"><a href="#⚙️-底层实现-1" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul><li>基于 <strong>ReentrantLock + Condition</strong>。</li><li>每个线程调用 <code>await()</code> → 计数 -1 → 当计数 &#x3D; 0 → 唤醒所有线程。</li><li>还可以指定一个 <strong>barrierAction</strong>（所有线程到达后执行的回调）。</li></ul><h3 id="📌-使用场景-1"><a href="#📌-使用场景-1" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul><li>多线程分阶段计算，再统一合并结果。</li><li>例如：并行计算矩阵的每一行，所有线程到齐后汇总。</li></ul><h3 id="🎯-面试考点-1"><a href="#🎯-面试考点-1" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul><li>与 <code>CountDownLatch</code> 的区别？→ 可循环，且是「多等多」。</li><li><code>BrokenBarrierException</code> 什么时候抛？→ 线程中断或超时导致 barrier 破坏。</li></ul><hr><h2 id="3-Semaphore（信号量）"><a href="#3-Semaphore（信号量）" class="headerlink" title="3. Semaphore（信号量）"></a>3. Semaphore（信号量）</h2><h3 id="📝-定义-2"><a href="#📝-定义-2" class="headerlink" title="📝 定义"></a>📝 定义</h3><ul><li>控制同时访问某资源的线程数，像 <strong>限流器&#x2F;许可证</strong>。</li></ul><h3 id="⚙️-底层实现-2"><a href="#⚙️-底层实现-2" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul><li>基于 <strong>AQS</strong> 的共享锁实现。</li><li>内部维护一个 <code>permits</code>（许可证数）。</li><li><code>acquire()</code> 获取许可证（permits–，不足则阻塞）；</li><li><code>release()</code> 归还许可证（permits++）。</li></ul><h3 id="📌-使用场景-2"><a href="#📌-使用场景-2" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul><li>控制并发数：数据库连接池、接口限流。</li><li>例子：停车场有 3 个车位 → 最多只能停 3 辆车。</li></ul><h3 id="🎯-面试考点-2"><a href="#🎯-面试考点-2" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul><li>公平模式 vs 非公平模式？<ul><li>公平：FIFO 获取许可证。</li><li>非公平：可能插队，吞吐量更高。</li></ul></li><li>和 <code>Lock</code> 的区别？→ <code>Semaphore</code> 控制的是 <strong>并发数量</strong>，而 <code>Lock</code> 是 <strong>互斥（只能 1 个线程）</strong>。</li></ul><hr><h2 id="4-Exchanger（交换器）"><a href="#4-Exchanger（交换器）" class="headerlink" title="4. Exchanger（交换器）"></a>4. Exchanger（交换器）</h2><h3 id="📝-定义-3"><a href="#📝-定义-3" class="headerlink" title="📝 定义"></a>📝 定义</h3><ul><li>让 <strong>两个线程</strong> 在同步点交换数据。</li></ul><h3 id="⚙️-底层实现-3"><a href="#⚙️-底层实现-3" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul><li>基于 <strong>自旋 + CAS</strong>。</li><li>一个线程调用 <code>exchange()</code> 会等待，直到另一个线程也调用 <code>exchange()</code>，然后两者交换数据。</li></ul><h3 id="📌-使用场景-3"><a href="#📌-使用场景-3" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul><li>双线程协作：生产者和消费者之间成对交换数据块。</li><li>比如：一个线程生成数据，另一个线程写入磁盘。</li></ul><h3 id="🎯-面试考点-3"><a href="#🎯-面试考点-3" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul><li>如果只有一个线程调用 <code>exchange()</code> 会怎样？→ 会阻塞，直到另一方到来。</li><li>与队列（BlockingQueue）的区别？→ <code>Exchanger</code> 是 <strong>一对一交换</strong>，而队列可以一对多。</li></ul><hr><h1 id="🧩-二、原子类（Atomic-系列）"><a href="#🧩-二、原子类（Atomic-系列）" class="headerlink" title="🧩 二、原子类（Atomic 系列）"></a>🧩 二、原子类（Atomic 系列）</h1><p>这些类在 <code>java.util.concurrent.atomic</code> 包下，提供了 <strong>无锁化的线程安全操作</strong>。</p><hr><h2 id="1-基础原子类"><a href="#1-基础原子类" class="headerlink" title="1. 基础原子类"></a>1. 基础原子类</h2><h3 id="AtomicInteger-AtomicLong-AtomicBoolean"><a href="#AtomicInteger-AtomicLong-AtomicBoolean" class="headerlink" title="AtomicInteger &#x2F; AtomicLong &#x2F; AtomicBoolean"></a>AtomicInteger &#x2F; AtomicLong &#x2F; AtomicBoolean</h3><ul><li>作用：对单个 <code>int</code>&#x2F;<code>long</code>&#x2F;<code>boolean</code> 变量的原子操作。</li><li>典型方法：<ul><li><code>getAndIncrement()</code> → 自增（原子性 i++）。</li><li><code>compareAndSet(expect, update)</code> → CAS 更新。</li></ul></li></ul><h3 id="⚙️-底层实现-4"><a href="#⚙️-底层实现-4" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul><li>基于 <strong>CAS（Compare-And-Swap） + volatile</strong>。</li><li>内部调用 <strong>Unsafe 类</strong> 的 <code>compareAndSwapInt</code> 等方法。</li></ul><h3 id="📌-使用场景-4"><a href="#📌-使用场景-4" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul><li>高并发计数器：网站访问量统计、ID 生成器。</li></ul><h3 id="🎯-面试考点-4"><a href="#🎯-面试考点-4" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul><li>CAS 的缺点？<ol><li>ABA 问题（可用 <code>AtomicStampedReference</code> 解决）。</li><li>自旋开销大。</li><li>只能保证单变量原子性，不能保证复合操作。</li></ol></li></ul><hr><h2 id="2-数组原子类"><a href="#2-数组原子类" class="headerlink" title="2. 数组原子类"></a>2. 数组原子类</h2><h3 id="AtomicIntegerArray-AtomicLongArray-AtomicReferenceArray"><a href="#AtomicIntegerArray-AtomicLongArray-AtomicReferenceArray" class="headerlink" title="AtomicIntegerArray &#x2F; AtomicLongArray &#x2F; AtomicReferenceArray"></a>AtomicIntegerArray &#x2F; AtomicLongArray &#x2F; AtomicReferenceArray</h3><ul><li>保证数组中的每个元素的原子操作。</li><li>例如：统计分片数据时，避免锁整个数组。</li></ul><hr><h2 id="3-引用原子类"><a href="#3-引用原子类" class="headerlink" title="3. 引用原子类"></a>3. 引用原子类</h2><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><ul><li>保证对象引用的原子更新。</li></ul><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><ul><li>解决 <strong>ABA 问题</strong>，给引用加一个版本号（stamp）。</li></ul><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><ul><li>给引用加一个 <strong>boolean 标记</strong>。</li></ul><hr><h2 id="4-累加器类"><a href="#4-累加器类" class="headerlink" title="4. 累加器类"></a>4. 累加器类</h2><h3 id="LongAdder-DoubleAdder"><a href="#LongAdder-DoubleAdder" class="headerlink" title="LongAdder &#x2F; DoubleAdder"></a>LongAdder &#x2F; DoubleAdder</h3><ul><li>对 <code>AtomicLong</code> 的优化：高并发下热点分离。</li><li>内部维护一个 <strong>base 值 + 分片 cell 数组</strong>。</li><li>多线程写时分散到不同的 cell，最后求和。</li></ul><h3 id="📌-使用场景-5"><a href="#📌-使用场景-5" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul><li>高并发计数，如 QPS 统计、热点计数。</li></ul><h3 id="🎯-面试考点-5"><a href="#🎯-面试考点-5" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul><li>为什么 <code>LongAdder</code> 比 <code>AtomicLong</code> 性能好？<ul><li>AtomicLong 所有线程 CAS 同一个值，形成热点；</li><li>LongAdder 分散冲突到多个 cell，降低竞争。</li></ul></li></ul><hr><h1 id="🧠-三、工具类-原子类对比总结"><a href="#🧠-三、工具类-原子类对比总结" class="headerlink" title="🧠 三、工具类 &amp; 原子类对比总结"></a>🧠 三、工具类 &amp; 原子类对比总结</h1><table><thead><tr><th>工具类 &#x2F; 原子类</th><th>功能</th><th>实现原理</th><th>典型场景</th></tr></thead><tbody><tr><td>CountDownLatch</td><td>一等多</td><td>AQS 共享锁</td><td>主线程等子线程完成</td></tr><tr><td>CyclicBarrier</td><td>多等多，可循环</td><td>ReentrantLock + Condition</td><td>分阶段同步，多线程汇总计算</td></tr><tr><td>Semaphore</td><td>控制并发数（许可证）</td><td>AQS 共享锁</td><td>限流、连接池、资源池</td></tr><tr><td>Exchanger</td><td>两线程数据交换</td><td>CAS + 自旋</td><td>双线程协作，数据块交换</td></tr><tr><td>AtomicInteger&#x2F;Long</td><td>单变量原子操作</td><td>CAS + volatile</td><td>高并发计数器，ID 生成</td></tr><tr><td>AtomicReference</td><td>原子更新引用</td><td>CAS</td><td>无锁更新对象引用</td></tr><tr><td>AtomicStampedReference</td><td>带版本号引用，防止 ABA</td><td>CAS</td><td>解决 ABA 问题</td></tr><tr><td>LongAdder&#x2F;DoubleAdder</td><td>高并发累加优化</td><td>分片 + CAS</td><td>高并发计数，性能优于 AtomicLong</td></tr></tbody></table><hr><h1 id="🎯-四、面试答题模板（可套用）"><a href="#🎯-四、面试答题模板（可套用）" class="headerlink" title="🎯 四、面试答题模板（可套用）"></a>🎯 四、面试答题模板（可套用）</h1><p>如果面试官问 <strong>“你了解 JUC 的并发工具类吗？”</strong> 可以这样答：</p><ol><li><strong>总体分类</strong><ul><li>JUC 里提供了 <strong>协作类工具（CountDownLatch、CyclicBarrier、Semaphore、Exchanger）</strong> 和 <strong>原子类（AtomicInteger、LongAdder 等）</strong>。</li></ul></li><li><strong>逐个解释</strong><ul><li><code>CountDownLatch</code>：一等多，主线程等子线程。</li><li><code>CyclicBarrier</code>：多等多，可循环。</li><li><code>Semaphore</code>：控制并发数，限流。</li><li><code>Exchanger</code>：两线程交换数据。</li><li><code>AtomicInteger/Long</code>：单变量原子操作，基于 CAS。</li><li><code>LongAdder</code>：高并发下比 AtomicLong 更高效。</li></ul></li><li><strong>原理补充</strong><ul><li>工具类大多基于 <strong>AQS</strong> 实现；</li><li>原子类基于 <strong>CAS + volatile</strong>；</li><li>LongAdder 用 <strong>分段累加</strong> 优化热点。</li></ul></li><li><strong>总结</strong><br> 👉 <strong>工具类解决线程协作，原子类解决无锁更新，都是 JUC 的核心。</strong></li></ol><hr><h4 id="小结-Map"><a href="#小结-Map" class="headerlink" title="小结 Map:"></a>小结 Map:</h4><ul><li>HashMap: 最常用，需要快速查找，不关心键值对顺序，且在单线程或由外部同步机制保证线程安全的场景。</li><li>LinkedHashMap: 需要快速查找，同时需要保持插入顺序或访问顺序的场景（如实现 LRU 缓存）。</li><li>TreeMap: 需要根据键的自然顺序或自定义顺序排序的场景。</li><li>ConcurrentHashMap: 高并发场景下对 Map 进行读写操作的首选。</li><li>Hashtable: 已被淘汰，不推荐使用。</li></ul><h4 id="集合部分总结："><a href="#集合部分总结：" class="headerlink" title="集合部分总结："></a>集合部分总结：</h4><p>遍历 Java 集合有多种方式，每种方式都有其优缺点。选择哪种方式取决于你正在使用的集合类型和具体需求。以下是对几种常见遍历方式的优劣分析和推荐。</p><hr><h3 id="1-迭代器-Iterator"><a href="#1-迭代器-Iterator" class="headerlink" title="1. 迭代器 (Iterator)"></a>1. 迭代器 (Iterator)</h3><p>这是最通用的遍历方式，适用于所有实现了 <code>Iterable</code> 接口的集合。</p><ul><li><strong>优点</strong>：<ul><li><strong>通用性强</strong>：它适用于所有集合，包括 <code>List</code>、<code>Set</code> 和 <code>Queue</code>。</li><li><strong>安全</strong>：在使用 <code>Iterator</code> 遍历时，可以安全地调用 <code>iterator.remove()</code> 方法移除元素，不会引发 <code>ConcurrentModificationException</code>。</li><li><strong>性能优越</strong>：对于 <code>LinkedList</code> 这类链式存储的集合，迭代器的遍历效率最高。</li></ul></li><li><strong>缺点</strong>：<ul><li>语法相对繁琐，需要手动调用 <code>hasNext()</code> 和 <code>next()</code>。</li></ul></li><li><strong>推荐</strong>：<ul><li>当需要<strong>在遍历过程中删除元素</strong>时，必须使用迭代器。</li><li>作为<strong>通用</strong>且安全的遍历首选。</li></ul></li></ul><h3 id="2-增强-for-循环-For-Each-Loop"><a href="#2-增强-for-循环-For-Each-Loop" class="headerlink" title="2. 增强 for 循环 (For-Each Loop)"></a>2. 增强 for 循环 (For-Each Loop)</h3><p>增强 for 循环是基于迭代器的一种语法糖，它使遍历代码更简洁易读。</p><ul><li><strong>优点</strong>：<ul><li><strong>代码简洁</strong>：语法简单直观，可读性强。</li><li><strong>不易出错</strong>：无需手动管理索引或迭代器。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>不支持删除</strong>：在遍历过程中直接调用集合的 <code>remove()</code> 方法会抛出 <code>ConcurrentModificationException</code>。</li><li><strong>性能</strong>：对于 <code>LinkedList</code> 来说，它的底层仍然是迭代器，性能很好。但对于 <code>ArrayList</code>，它的性能不如传统的 <code>for</code> 循环，因为每次迭代都需要调用 <code>next()</code> 方法。</li></ul></li><li><strong>推荐</strong>：<ul><li>当你只需要<strong>读取集合中的元素</strong>，且代码简洁性比性能更重要时。</li></ul></li></ul><hr><h3 id="3-传统-for-循环-Indexed-For-Loop"><a href="#3-传统-for-循环-Indexed-For-Loop" class="headerlink" title="3. 传统 for 循环 (Indexed For Loop)"></a>3. 传统 for 循环 (Indexed For Loop)</h3><p>这种方式只适用于支持通过索引访问的集合，如 <code>ArrayList</code> 和 <code>Vector</code>。</p><ul><li><strong>优点</strong>：<ul><li><strong>性能最高</strong>：对于 <code>ArrayList</code>，它通过索引直接访问元素，效率极高，性能优于迭代器。</li><li><strong>灵活</strong>：可以按需向前或向后遍历，也可以跳过元素。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>不通用</strong>：不适用于 <code>Set</code> 或 <code>Map</code> 等不按索引存储的集合。</li><li><strong>效率低下</strong>：对于 <code>LinkedList</code>，每次 <code>get(i)</code> 调用都会从头开始遍历，导致性能极差，时间复杂度为 O(n²)。</li></ul></li><li><strong>推荐</strong>：<ul><li>当遍历 <strong>ArrayList</strong> 并需要<strong>高性能</strong>时。</li></ul></li></ul><hr><h3 id="4-Lambda-表达式与-Stream-API"><a href="#4-Lambda-表达式与-Stream-API" class="headerlink" title="4. Lambda 表达式与 Stream API"></a>4. Lambda 表达式与 Stream API</h3><p>Java 8 引入的 Stream API 提供了非常强大的函数式编程能力，可以用于遍历和处理集合。</p><ul><li><strong>优点</strong>：<ul><li><strong>简洁优雅</strong>：代码非常简洁，表达力强。</li><li><strong>功能强大</strong>：支持过滤、映射、排序等各种操作，能以声明式的方式处理数据。</li><li><strong>支持并行</strong>：可以通过 <code>parallelStream()</code> 开启并行处理，利用多核优势。</li></ul></li><li><strong>缺点</strong>：<ul><li>性能开销：通常比传统的 <code>for</code> 循环略高，特别是在处理小规模数据时。</li></ul></li><li><strong>推荐</strong>：<ul><li>当你需要对集合进行<strong>复杂的操作</strong>（如过滤、转换、聚合）时。</li><li>需要利用<strong>并行处理</strong>来提高性能时。</li></ul></li></ul><hr><h3 id="总结与最佳实践"><a href="#总结与最佳实践" class="headerlink" title="总结与最佳实践"></a>总结与最佳实践</h3><table><thead><tr><th>方式</th><th>适用集合</th><th>优劣</th><th>推荐场景</th></tr></thead><tbody><tr><td><strong>迭代器</strong></td><td>所有集合</td><td>通用、安全（可删除），对 <code>LinkedList</code> 性能好。</td><td>需要在遍历中删除元素，或作为通用选择。</td></tr><tr><td><strong>增强 for</strong></td><td>所有集合</td><td>语法简洁，可读性高。不能在遍历中删除。</td><td>仅需读取元素，且追求代码简洁。</td></tr><tr><td><strong>传统 for</strong></td><td><code>ArrayList</code> 等</td><td><code>ArrayList</code> 性能最高，灵活。对 <code>LinkedList</code> 性能极差。</td><td><code>ArrayList</code> 的高性能遍历，或需要控制索引。</td></tr><tr><td><strong>Stream API</strong></td><td>所有集合</td><td>功能强大，代码优雅，支持并行。</td><td>复杂数据处理、并行计算。</td></tr></tbody></table><p><strong>简单概括</strong>：</p><ul><li><strong>读取</strong> <code>ArrayList</code>：首选<strong>传统 for 循环</strong>。</li><li><strong>读取</strong> <code>LinkedList</code>、<code>Set</code>：首选<strong>增强 for 循环</strong>。</li><li><strong>删除</strong>元素：必须使用<strong>迭代器</strong>。</li><li><strong>复杂操作</strong>：使用 <strong>Stream API</strong>。</li></ul><p>通常来说，在 Java 中反向遍历并删除元素时，使用传统的 <strong>for 循环</strong>并从列表的末尾开始向前遍历是最安全和高效的方法。</p><h3 id="为什么推荐反向遍历？"><a href="#为什么推荐反向遍历？" class="headerlink" title="为什么推荐反向遍历？"></a>为什么推荐反向遍历？</h3><p>当你使用正向遍历（从索引 0 开始）并删除元素时，会遇到一个常见问题：</p><ul><li>当你删除一个元素后，它后面的所有元素的索引都会向前移动一位。</li><li>这会导致在下一次循环迭代时，你可能会跳过紧跟在被删除元素后面的那个元素，因为它现在占据了被删除元素原来的位置，而你的循环索引已经增到了下一个位置。</li></ul><p><strong>反向遍历</strong>完美地解决了这个问题。当你从列表末尾开始向前遍历时，删除一个元素<strong>不会影响</strong>你尚未遍历到的任何元素的索引，因为你正在处理的元素及其索引都位于列表的“后半部分”。</p><hr><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="1-传统的-for-循环（推荐）"><a href="#1-传统的-for-循环（推荐）" class="headerlink" title="1. 传统的 for 循环（推荐）"></a>1. 传统的 <code>for</code> 循环（推荐）</h4><p>这是反向遍历并删除最直接、最安全、最高效的方式，尤其适用于 <code>ArrayList</code>。</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class ReverseRemoveExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;a&quot;);</span><br><span class="line">        list.add(&quot;b&quot;);</span><br><span class="line">        list.add(&quot;c&quot;);</span><br><span class="line">        list.add(&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">        // 从后往前遍历，并删除元素</span><br><span class="line">        for (int i = list.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            // 假设我们要删除所有元素</span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;删除后的列表: &quot; + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-迭代器（Iterator）"><a href="#2-迭代器（Iterator）" class="headerlink" title="2. 迭代器（Iterator）"></a>2. 迭代器（Iterator）</h4><p>虽然迭代器通常用于正向遍历，但你也可以使用它来从后向前遍历并删除。不过，这种方式的实现相对复杂，并且对于 <code>LinkedList</code> 之外的集合性能并不好。对于 <code>ArrayList</code>，它仍然需要从末尾开始遍历，性能不如传统 <code>for</code> 循环。</p><p><strong>注意</strong>：<code>ListIterator</code> 提供了双向遍历功能，但其 <code>previous()</code> 方法在 <code>Iterator</code> 接口中并不存在。因此，在通用性上，传统 <code>for</code> 循环依然是首选。</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 这是一个使用 ListIterator 的例子，只适用于 List</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.ListIterator;</span><br><span class="line"></span><br><span class="line">public class ListIteratorExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        list.add(&quot;a&quot;);</span><br><span class="line">        list.add(&quot;b&quot;);</span><br><span class="line">        list.add(&quot;c&quot;);</span><br><span class="line">        list.add(&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">        // 从列表末尾获取 ListIterator</span><br><span class="line">        ListIterator&lt;String&gt; it = list.listIterator(list.size());</span><br><span class="line">        </span><br><span class="line">        while (it.hasPrevious()) &#123;</span><br><span class="line">            String element = it.previous();</span><br><span class="line">            // 假设我们删除元素 &quot;b&quot; 和 &quot;c&quot;</span><br><span class="line">            if (element.equals(&quot;b&quot;) || element.equals(&quot;c&quot;)) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;删除后的列表: &quot; + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>推荐</strong>：对于 <code>ArrayList</code> 或任何基于数组的列表，使用<strong>传统的 for 循环反向遍历</strong>是最简单、最安全、最高效的删除方式。</li><li><strong>避免</strong>：避免在正向遍历时直接使用 <code>remove()</code> 方法，因为它可能导致跳过元素或引发 <code>ConcurrentModificationException</code>。</li><li><strong>通用性</strong>：如果你需要编写一个通用的删除方法，考虑到所有 <code>List</code> 实现，那么 <code>ListIterator</code> 是一个选择，但它的双向遍历特性仅限于 <code>List</code> 接口。</li></ul><h2 id="多线程下的hashmap死循环问题："><a href="#多线程下的hashmap死循环问题：" class="headerlink" title="多线程下的hashmap死循环问题："></a>多线程下的hashmap死循环问题：</h2><p>当多个线程同时对一个 <strong>HashMap</strong> 进行操作时，尤其是在涉及扩容（resizing）的情况下，可能会导致死循环。这个问题主要出现在 Java 7 及以前的版本，由于其底层数据结构和扩容机制的设计缺陷。</p><hr><h3 id="HashMap-的死循环问题"><a href="#HashMap-的死循环问题" class="headerlink" title="HashMap 的死循环问题"></a>HashMap 的死循环问题</h3><p>在 Java 7 中，<code>HashMap</code> 采用<strong>数组 + 链表</strong>的方式存储数据。当链表上的元素数量过多时，为了提高性能，<code>HashMap</code> 会进行扩容。扩容的步骤大致如下：</p><ol><li>创建一个新的、更大的数组。</li><li>遍历旧数组中的所有元素。</li><li>将每个元素重新计算哈希值，并放入新数组的正确位置。</li></ol><p>问题就出在第三步：<strong>将链表上的元素从旧数组转移到新数组时，如果多个线程同时进行此操作，就可能导致链表中的节点顺序颠倒，形成闭环。</strong></p><h4 id="扩容时的死循环过程"><a href="#扩容时的死循环过程" class="headerlink" title="扩容时的死循环过程"></a>扩容时的死循环过程</h4><p>假设有两个线程 <strong>Thread1</strong> 和 <strong>Thread2</strong> 同时对一个 <code>HashMap</code> 进行扩容。</p><ol><li><strong>初始状态</strong>：<code>HashMap</code> 扩容前，一个桶位上有一个链表，比如 <code>NodeA</code> -&gt; <code>NodeB</code>。</li><li><strong>Thread1 执行到一半</strong>：<code>Thread1</code> 遍历到 <code>NodeA</code>，准备将其移动到新数组。此时 <code>Thread1</code> 被挂起。<code>NodeA</code> 的 <code>next</code> 引用仍然指向 <code>NodeB</code>。</li><li><strong>Thread2 开始执行</strong>：<code>Thread2</code> 完整地完成了扩容过程。它将链表 <code>NodeA</code> -&gt; <code>NodeB</code> 转移到了新数组。但由于是单线程操作，转移后链表顺序保持不变，仍是 <code>NodeA</code> -&gt; <code>NodeB</code>。</li><li><strong>Thread1 恢复执行</strong>：<code>Thread1</code> 恢复执行，但它不知道 <code>Thread2</code> 已经完成了扩容。它仍然使用旧的 <code>next</code> 引用信息。<ul><li><code>Thread1</code> 取出 <code>NodeA</code>，将其放入新数组。</li><li><code>Thread1</code> 接着处理 <code>NodeB</code>（因为在 <code>Thread1</code> 的视角，<code>NodeA</code> 的 <code>next</code> 还是 <code>NodeB</code>）。它将 <code>NodeB</code> 放入新数组。此时，<strong>由于哈希冲突，NodeB 被放在了 NodeA 的前面，导致链表变成了 NodeB -&gt; NodeA。</strong></li><li><code>NodeA</code> 的 <code>next</code> 引用（在 <code>Thread1</code> 的视角）仍然指向 <code>NodeB</code>。现在，<code>NodeB</code> 的 <code>next</code> 指向 <code>NodeA</code>，而 <code>NodeA</code> 的 <code>next</code> 指向 <code>NodeB</code>，<strong>形成了一个闭环</strong>。</li></ul></li></ol><p>当后续线程在这个闭环链表上进行查找时，就会陷入无限循环，导致 CPU 100% 占用。</p><hr><h3 id="如何解决这个问题？"><a href="#如何解决这个问题？" class="headerlink" title="如何解决这个问题？"></a>如何解决这个问题？</h3><p>Java 提供了多种线程安全的替代方案来解决 <code>HashMap</code> 的多线程问题：</p><ol><li><strong>Collections.synchronizedMap()</strong>：<ul><li>这个方法可以创建一个线程安全的 <code>Map</code> 包装器。</li><li>它通过在每个方法调用上加锁来实现线程安全。</li><li><strong>优点</strong>：简单易用。</li><li><strong>缺点</strong>：每次访问都需要加锁，并发性能较差。</li></ul></li><li><strong>Hashtable</strong>：<ul><li>一个早期的线程安全 <code>Map</code> 实现，所有公共方法都用 <code>synchronized</code> 修饰。</li><li><strong>优点</strong>：线程安全。</li><li><strong>缺点</strong>：性能差，几乎所有操作都锁住整个表，已被 <code>ConcurrentHashMap</code> 取代。</li></ul></li><li><strong>ConcurrentHashMap</strong>：<ul><li>这是 <strong>Java 推荐的线程安全 Map 实现</strong>。</li><li>在 Java 7 中，它使用了<strong>分段锁（Segment Lock）</strong>，将数据分成多个段，每个段独立加锁。</li><li>在 Java 8 中，它进一步优化，采用**CAS（Compare-And-Swap）**和 <strong>synchronized</strong> 关键字，锁的粒度更细，只锁住当前操作的桶，从而大大提高了并发性能。</li></ul></li></ol><p>因此，在多线程环境下，<strong>永远不要使用 HashMap</strong>。你应该根据需求，选择 <code>ConcurrentHashMap</code> 或 <code>Collections.synchronizedMap()</code> 来保证线程安全。</p><h2 id="集合扩展："><a href="#集合扩展：" class="headerlink" title="集合扩展："></a>集合扩展：</h2><h3 id="12-HashMap-的-get-方法能否判断某个元素是否在-map-中？"><a href="#12-HashMap-的-get-方法能否判断某个元素是否在-map-中？" class="headerlink" title="12. HashMap 的 get 方法能否判断某个元素是否在 map 中？"></a>12. HashMap 的 get 方法能否判断某个元素是否在 map 中？</h3><p><code>HashMap</code> 的 <code>get</code> 函数的返回值不能判断一个 <code>key</code> 是否包含在 <code>map</code> 中，因为 <code>get</code> 返回 <code>null</code> 有可能是不包含该 <code>key</code>，也有可能该 <code>key</code> 对应的 <code>value</code> 为 <code>null</code>。因为 <code>HashMap</code> 中允许 <code>key</code> 为 <code>null</code>，也允许 <code>value</code> 为 <code>null</code>。</p><hr><h3 id="13-HashMap-与-HashTable-的区别是什么？"><a href="#13-HashMap-与-HashTable-的区别是什么？" class="headerlink" title="13. HashMap 与 HashTable 的区别是什么？"></a>13. HashMap 与 HashTable 的区别是什么？</h3><ol><li><code>HashTable</code> 基于 <code>Dictionary</code> 类，而 <code>HashMap</code> 是基于 <code>AbstractMap</code>。<code>Dictionary</code> 是任何可将键映射到相应值的类的抽象父类，而 <code>AbstractMap</code> 是基于 <code>Map</code> 接口的实现，它以最大限度地减少实现此接口所需的工作。</li><li><code>HashMap</code> 的 <code>key</code> 和 <code>value</code> 都允许为 <code>null</code>，而 <code>Hashtable</code> 的 <code>key</code> 和 <code>value</code> 都不允许为 <code>null</code>。<code>HashMap</code> 遇到 <code>key</code> 为 <code>null</code> 的时候，调用 <code>putForNullKey</code> 方法进行处理，而对 <code>value</code> 没有处理；<code>Hashtable</code> 遇到 <code>null</code>，直接返回 <code>NullPointerException</code>。</li><li><code>Hashtable</code> 是线程安全的，而 <code>HashMap</code> 不是线程安全的，但是我们也可以通过 <code>Collections.synchronizedMap(hashMap)</code>，使其实现同步。</li></ol><p>HashTable 的补充：</p><p>HashTable 和 HashMap 的实现原理几乎一样，差别无非是：</p><ol><li><code>HashTable</code> 不允许 <code>key</code> 和 <code>value</code> 为 <code>null</code>；</li><li><code>HashTable</code> 是线程安全的。但是 <code>HashTable</code> 线程安全的策略实现代价却太大了，简单粗暴，<code>get/put</code> 所有相关操作都是 <code>synchronized</code> 的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。</li></ol><hr><h3 id="14-HashMap-与-ConcurrentHashMap-的区别是什么"><a href="#14-HashMap-与-ConcurrentHashMap-的区别是什么" class="headerlink" title="14. HashMap 与 ConcurrentHashMap 的区别是什么?"></a>14. HashMap 与 ConcurrentHashMap 的区别是什么?</h3><p><code>HashMap</code> 不是线程安全的，而 <code>ConcurrentHashMap</code> 是线程安全的。</p><p><code>ConcurrentHashMap</code> 采用锁分段技术，将整个Hash桶进行了分段segment，也就是将这个大的数组分成了几个小的片段 <code>segment</code>，而且每个小的片段 <code>segment</code> 上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段 <code>segment</code>，然后再在这个片段上面进行插入，而且这里还需要获取 <code>segment</code> 锁，这样做明显减小了锁的粒度。</p><hr><h3 id="15-HashTable-和-ConcurrentHashMap-的区别？"><a href="#15-HashTable-和-ConcurrentHashMap-的区别？" class="headerlink" title="15. HashTable 和 ConcurrentHashMap 的区别？"></a>15. HashTable 和 ConcurrentHashMap 的区别？</h3><p><code>HashTable</code> 和 <code>ConcurrentHashMap</code> 相比，效率低。 <code>Hashtable</code> 之所以效率低主要是使用了 <code>synchronized</code> 关键字对 <code>put</code> 等操作进行加锁，而 <code>synchronized</code> 关键字加锁是对整张 Hash 表的，即每次锁住整张表让线程独占，致使效率低下，而 <code>ConcurrentHashMap</code> 在对象中保存了一个 <code>Segment</code> 数组，即将整个 Hash 表划分为多个分段；而每个<code>Segment</code>元素，即每个分段则类似于一个<code>Hashtable</code>；这样，在执行 <code>put</code> 操作时首先根据 hash 算法定位到元素属于哪个 <code>Segment</code>，然后对该 <code>Segment</code> 加锁即可，因此，<code>ConcurrentHashMap</code> 在多线程并发编程中可是实现多线程 <code>put</code>操作。</p><hr><h3 id="16-ConcurrentHashMap-的实现原理是什么？"><a href="#16-ConcurrentHashMap-的实现原理是什么？" class="headerlink" title="16. ConcurrentHashMap 的实现原理是什么？"></a>16. ConcurrentHashMap 的实现原理是什么？</h3><p><strong>数据结构</strong></p><ul><li><strong>JDK 7</strong>：中 <code>ConcurrentHashMap</code> 采用了<strong>数组 + Segment + 分段锁</strong>的方式实现。</li><li><strong>JDK 8</strong>：中 <code>ConcurrentHashMap</code> 参考了 JDK 8 <code>HashMap</code> 的实现，采用了<strong>数组 + 链表 + 红黑树</strong>的实现方式来设计，内部大量采用 <code>CAS</code> 操作。</li></ul><p>ConcurrentHashMap 采用了非常精妙的”分段锁”策略，ConcurrentHashMap 的主干是个 Segment 数组。</p><p>final Segment[] segments;</p><p>Segment 继承了 ReentrantLock，所以它就是一种可重入锁（ReentrantLock）。在 ConcurrentHashMap，一个 Segment 就是一个子哈希表，Segment 里维护了一个 HashEntry 数组，并发环境下，对于不同 Segment 的数据进行操作是不用考虑锁竞争的。就按默认的 ConcurrentLevel 为 16 来讲，理论上就允许 16 个线程并发执行。所以，对于同一个 Segment 的操作才需考虑线程同步，不同的 Segment 则无需考虑。Segment 类似于 HashMap，一个 Segment 维护着一个HashEntry 数组：</p><p>transient volatile HashEntry[] table;</p><p>HashEntry 是目前我们提到的最小的逻辑处理单元了。一个 ConcurrentHashMap 维护一个 Segment 数组，一个 Segment 维护一个 HashEntry 数组。因此，ConcurrentHashMap 定位一个元素的过程需要进行两次 Hash 操作。第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。</p><hr><h3 id="17-HashSet-的实现原理？"><a href="#17-HashSet-的实现原理？" class="headerlink" title="17. HashSet 的实现原理？"></a>17. HashSet 的实现原理？</h3><p><code>HashSet</code> 的实现是依赖于 <code>HashMap</code> 的，<code>HashSet</code> 的值都是存储在 <code>HashMap</code> 中的。在 <code>HashSet</code> 的构造法中会初始化一个 <code>HashMap</code> 对象，<code>HashSet</code> 不允许值重复。因此，<code>HashSet</code> 的值是作为 <code>HashMap</code> 的 <code>key</code> 存储在 <code>HashMap</code> 中的，当存储的值已经存在时返回 <code>false</code>。</p><hr><h3 id="18-HashSet-怎么保证元素不重复的？"><a href="#18-HashSet-怎么保证元素不重复的？" class="headerlink" title="18. HashSet 怎么保证元素不重复的？"></a>18. HashSet 怎么保证元素不重复的？</h3><p><code>public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125;</code></p><p>元素值作为的是 <code>map</code> 的 <code>key</code>，<code>map</code> 的 <code>value</code> 则是 <code>PRESENT</code> 变量，这个变量只作为放入 <code>map</code> 时的<code>一个占位符而存在，所以没什么实际用处。其实，这时候答案已经出来了：</code>HashMap<code>的</code>key<code>是不能重复的，而这里</code>HashSet<code>的元素又是作为了</code>map<code>的</code>key&#96;，当然也不能重复了。</p><hr><h3 id="19-LinkedHashMap-的实现原理"><a href="#19-LinkedHashMap-的实现原理" class="headerlink" title="19. LinkedHashMap 的实现原理?"></a>19. LinkedHashMap 的实现原理?</h3><p><code>LinkedHashMap</code> 也是基于 <code>HashMap</code> 实现的，不同的是它定义了一个 <code>Entry</code> <code>header</code>，这个 <code>header</code> 不是放在 <code>Table</code> 里，它是额外独立出来的。<code>LinkedHashMap</code> 通过继承 <code>hashMap</code> 中的 <code>Entry</code>，并添加两个属性 <code>Entry before, after</code> 和 <code>header</code> 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。</p><p><code>LinkedHashMap</code> 定义了排序模式 <code>accessOrder</code>，该属性为 <code>boolean</code> 型变量，对于访问顺序，为 <code>true</code>；对于插入顺序，则为 <code>false</code>。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p><hr><h3 id="20-Iterator-怎么使用？有什么特点？"><a href="#20-Iterator-怎么使用？有什么特点？" class="headerlink" title="20. Iterator 怎么使用？有什么特点？"></a>20. Iterator 怎么使用？有什么特点？</h3><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。Java 中的 <code>Iterator</code> 功能比较简单，并且只能单向移动：</p><ol><li>使用方法 <code>iterator()</code> 要求容器返回一个 <code>Iterator</code>。第一次调用 <code>Iterator</code> 的 <code>next()</code> 方法时，它返回序列的第一个元素。注意：<code>iterator()</code> 方法是 <code>java.lang.Iterable</code> 接口，被 <code>Collection</code> 继承。</li><li>使用 <code>next()</code> 获得序列中的下一个元素。</li><li>使用 <code>hasNext()</code> 检查序列中是否还有元素。</li><li>使用 <code>remove()</code> 将迭代器新返回的元素删除。</li></ol><hr><h3 id="21-Iterator-和-ListIterator-有什么区别？"><a href="#21-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="21. Iterator 和 ListIterator 有什么区别？"></a>21. Iterator 和 ListIterator 有什么区别？</h3><p><code>Iterator</code> 可用来遍历 <code>Set</code> 和 <code>List</code> 集合，但是 <code>ListIterator</code> 只能用来遍历 <code>List</code>。<code>Iterator</code> 对集合只能是前向遍历，<code>ListIterator</code> 既可以前向也可以后向。<code>ListIterator</code> 实现了 <code>Iterator</code> 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</p><hr><h3 id="22-Iterator-和-Enumeration-接口的区别？"><a href="#22-Iterator-和-Enumeration-接口的区别？" class="headerlink" title="22. Iterator 和 Enumeration 接口的区别？"></a>22. Iterator 和 Enumeration 接口的区别？</h3><p>与 <code>Enumeration</code> 相比，<code>Iterator</code> 更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。否则会抛出 <code>ConcurrentModificationException</code> 异常。这其实就是 <code>fail-fast</code> 机制。具体区别有三点：</p><ol><li><code>Iterator</code> 的方法名比 <code>Enumeration</code> 更科学；</li><li><code>Iterator</code> 有 <code>fail-fast</code> 机制，比 <code>Enumeration</code> 更安全；</li><li><code>Iterator</code> 能够删除元素，<code>Enumeration</code> 并不能删除元素。</li></ol><hr><h3 id="23-fail-fast-与-fail-safe-有什么区别？"><a href="#23-fail-fast-与-fail-safe-有什么区别？" class="headerlink" title="23. fail-fast 与 fail-safe 有什么区别？"></a>23. fail-fast 与 fail-safe 有什么区别？</h3><p><code>Iterator</code> 的 <code>fail-fast</code> 属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。<code>java.util</code> 包中的所有集合类都被设计为 <code>fail-fast</code> 的，而 <code>java.util.concurrent</code> 中的集合类都为 <code>fail-safe</code> 的。当检测到正在遍历的集合的结构被改变时，<code>fail-fast</code> 迭代器抛出 <code>ConcurrentModificationException</code>，而 <code>fail-safe</code> 迭代器从不抛出 <code>ConcurrentModificationException</code>。</p><hr><h3 id="24-Collection-和-Collections-有什么区别？"><a href="#24-Collection-和-Collections-有什么区别？" class="headerlink" title="24. Collection 和 Collections 有什么区别？"></a>24. Collection 和 Collections 有什么区别？</h3><ul><li><code>Collection</code>：是最基本的集合接口，一个 <code>Collection</code> 代表一组 <code>Object</code>，即 <code>Collection</code> 的元素。它的直接继承接口有 <code>List</code>，<code>Set</code> 和 <code>Queue</code>。</li><li><code>Collections</code>：不属于 Java 的集合框架的，它是集合类的一个工具类&#x2F;帮助类。此类不能被实例化， 服务于 Java 的 <code>Collection</code> 框架。它包含有关集合操作的静态多态方法，实现对各种集合的搜索、排序、线程安全等操作。</li></ul><h2 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO 流"></a>Java IO 流</h2><p>Java IO (Input&#x2F;Output) 流是用于处理计算机与外部设备之间数据传输的抽象概念。它将数据抽象为流 (Stream)，通过流可以实现数据的输入和输出。</p><h3 id="IO-流的分类"><a href="#IO-流的分类" class="headerlink" title="IO 流的分类"></a>IO 流的分类</h3><p>Java IO 流根据不同的标准有多种分类方式：</p><ul><li>按数据类型分：<ul><li>字节流：处理字节数据，所有文件类型（文本、图片、音视频等）都可以用字节流处理。<ul><li>抽象基类：InputStream（输入流）、OutputStream（输出流）。</li><li>常用实现：FileInputStream&#x2F;FileOutputStream（文件操作），BufferedInputStream&#x2F;BufferedOutputStream（带缓冲），ObjectInputStream&#x2F;ObjectOutputStream（对象序列化），ByteArrayInputStream&#x2F;ByteArrayOutputStream（内存操作），DataInputStream&#x2F;DataOutputStream（基本数据类型操作）。</li></ul></li><li>字符流：处理字符数据，专门用于处理文本文件。<ul><li>抽象基类：Reader（输入流）、Writer（输出流）。</li><li>常用实现：FileReader&#x2F;FileWriter（文件操作），BufferedReader&#x2F;BufferedWriter（带缓冲），InputStreamReader&#x2F;OutputStreamWriter（字节流与字符流的转换）。</li></ul></li></ul></li><li>按流向分：<ul><li>输入流：从数据源读取数据到程序中。</li><li>输出流：从程序中写入数据到目的地。</li></ul></li><li>按功能分：<ul><li>节点流（或源头流）：直接与数据源（如文件、内存、网络连接）连接的流。例如FileInputStream、FileReader。</li><li>处理流（或包装流）：对已存在的节点流进行包装，增加新的功能或提升性能。例如BufferedInputStream、BufferedReader。</li></ul></li></ul><p><img src="C:\Users\19501\AppData\Local\Temp\1755834271160.png" alt="1755834271160"></p><p><img src="C:\Users\19501\AppData\Local\Temp\1755834290356.png" alt="1755834290356"></p><h3 id="常用-IO-操作"><a href="#常用-IO-操作" class="headerlink" title="常用 IO 操作"></a>常用 IO 操作</h3><ul><li><p>文件读写（字节流）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    fos.write(<span class="string">&quot;Hello, World!&quot;</span>.getBytes());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">while</span> ((data = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件读写（字符流）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output_char.txt&quot;</span>)) &#123;</span><br><span class="line">    fw.write(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;output_char.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">while</span> ((data = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>缓冲流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用缓冲字节流复制文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.txt&quot;</span>));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;destination.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个可序列化的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 序列化版本UID</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">transient</span> String password; <span class="comment">// transient 关键字修饰的字段不参与序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User(name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, password=&quot;</span> + password + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    oos.writeObject(user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;user.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">deserializedUser</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">    System.out.println(deserializedUser); <span class="comment">// password 字段将为 null</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="NIO-New-Input-Output"><a href="#NIO-New-Input-Output" class="headerlink" title="NIO (New Input&#x2F;Output)"></a>NIO (New Input&#x2F;Output)</h3><p>Java NIO (New I&#x2F;O) 是在 JDK 1.4 中引入的一套新的 I&#x2F;O API，它提供了非阻塞 I&#x2F;O 的能力，并引入了“通道 (Channel)”和“缓冲区 (Buffer)”的概念，与传统的基于流 (Stream) 的 I&#x2F;O 相比，NIO 更加高效。</p><p><strong>核心组件：</strong></p><ul><li>Channel (通道): 类似于传统 IO 中的流，但可以双向读写。数据总是通过通道读入缓冲区或从缓冲区写入通道。<ul><li>常用实现: FileChannel (文件), SocketChannel (TCP 客户端), ServerSocketChannel (TCP 服务器), DatagramChannel (UDP)。</li></ul></li><li>Buffer (缓冲区): 用于存储数据 (字节数组)，与通道进行交互。所有数据读写都是通过缓冲区完成的。缓冲区有多种类型，如 ByteBuffer、CharBuffer、IntBuffer 等。<ul><li>核心属性：<ul><li>capacity: 缓冲区可容纳的最大数据量。一旦创建，容量不可变。</li><li>limit: 缓冲区中可读或可写的上限。</li><li>position: 下一个读或写的位置。</li><li>mark: 标记当前 position，可以通过 reset() 恢复到 mark 的位置。</li></ul></li><li>主要方法：<ul><li>put(): 向缓冲区写入数据。</li><li>get(): 从缓冲区读取数据。</li><li>flip(): 将缓冲区从写模式切换到读模式。limit 会设置为当前的 position, position 会重置为 0。</li><li>clear(): 清空缓冲区，为新的写入做准备。position 设为 0, limit 设为 capacity。</li><li>compact(): 压缩缓冲区，将未读的数据移到缓冲区开头，position 设为未读数据数量，limit 设为 capacity。</li><li>rewind(): 将 position 设为 0，可以重复读取缓冲区中的数据。</li></ul></li></ul></li><li>Selector (选择器): 用于监听多个通道上的事件 (如连接就绪、读就绪、写就绪等)。一个单线程可以管理多个通道，从而实现非阻塞 I&#x2F;O。</li></ul><p><strong>NIO 与传统 IO 的区别：</strong></p><ul><li>I&#x2F;O 模式:传统 IO 是阻塞式 I&#x2F;O, NIO 是非阻塞式 I&#x2F;O。</li><li>流与缓冲区:传统 IO 基于流(单向), NIO 基于通道和缓冲区(双向)。</li><li>同步与异步:传统 IO 是同步阻塞的, NIO 是同步非阻塞的(在多路复用模型下)。</li></ul><p><strong>NIO 文件复制示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">     <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;destination_nio.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> fos.getChannel()) &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (inChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buffer.flip(); <span class="comment">// 切换到读模式</span></span><br><span class="line">        outChannel.write(buffer); <span class="comment">// 从缓冲区写入通道</span></span><br><span class="line">        buffer.clear(); <span class="comment">// 清空缓冲区, 为下次写入做准备</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AIO-Asynchronous-Input-Output"><a href="#AIO-Asynchronous-Input-Output" class="headerlink" title="AIO (Asynchronous Input&#x2F;Output)"></a>AIO (Asynchronous Input&#x2F;Output)</h3><p>Java AIO (Asynchronous I&#x2F;O) 是在 JDK 7 中引入的，也称为 NIO 2.0。它提供了真正的异步非阻塞 I&#x2F;O，通过回调机制来处理 I&#x2F;O 操作的结果。与 NIO 的同步非阻塞不同，AIO 在 I&#x2F;O 操作完成后会主动通知应用程序。</p><ul><li><p><strong>核心概念:</strong></p><ul><li>AsynchronousFileChannel:异步文件通道。</li><li>AsynchronousSocketChannel:异步 Socket 通道。</li><li>AsynchronousServerSocketChannel:异步 Server Socket 通道。</li><li>CompletionHandler:回调处理器接口，定义了 completed() (操作成功) 和 failed() (操作失败) 方法。</li><li>Future:也可以通过返回 Future 对象来获取异步操作的结果。</li></ul></li><li><p>**工作原理:**当发起一个 I&#x2F;O 操作时，不再需要等待操作完成，而是立即返回。I&#x2F;O 操作由操作系统在后台完成，完成后通过回调函数通知应用程序。</p></li><li><p><strong>AIO 优势:</strong></p><ul><li>真正的异步非阻塞:应用程序不需要等待 I&#x2F;O 操作，可以将 CPU 资源用于其他任务。</li><li>提高并发性:特别适合高并发、长连接的网络应用。</li></ul></li><li><p><strong>AIO 劣势:</strong></p><ul><li>复杂性:编程模型相对于 NIO 更复杂，需要处理回调逻辑。</li><li>适用场景:对于连接数较多且连接时间长的应用，如聊天服务器，AIO 表现优异。对于短连接、高并发的场景，NIO（基于 Selector）可能表现更好。</li></ul></li><li><p><strong>AIO 读文件示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">file</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;async_read.txt&quot;</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(file, StandardOpenOption.READ)) &#123;</span><br><span class="line">    fileChannel.read(buffer, <span class="number">0</span>, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Read &quot;</span> + result + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">            attachment.flip();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[attachment.remaining()];</span><br><span class="line">            attachment.get(data);</span><br><span class="line">            System.out.println(<span class="string">&quot;Content: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Read failed: &quot;</span> + exc.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 为了让主线程不立即退出，等待异步操作完成</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-Java-IO-流的分类？请说出几个你熟悉的实现类。"><a href="#1-Java-IO-流的分类？请说出几个你熟悉的实现类。" class="headerlink" title="1. Java IO 流的分类？请说出几个你熟悉的实现类。"></a>1. Java IO 流的分类？请说出几个你熟悉的实现类。</h3><p>Java IO 流根据不同的标准可以进行分类：</p><ul><li><strong>按数据流向</strong>：<ul><li><strong>输入流（InputStream &#x2F; Reader）</strong>：从外部源（如文件、网络）读取数据到程序中。</li><li><strong>输出流（OutputStream &#x2F; Writer）</strong>：将数据从程序写入到外部目标。</li></ul></li><li><strong>按数据类型</strong>：<ul><li><strong>字节流（InputStream &#x2F; OutputStream）</strong>：以 8 位字节为单位处理数据，适用于所有类型的文件，包括图片、视频、音频等二进制文件。<ul><li><strong>实现类</strong>：<code>FileInputStream</code>, <code>FileOutputStream</code>, <code>BufferedInputStream</code>, <code>BufferedOutputStream</code>。</li></ul></li><li><strong>字符流（Reader &#x2F; Writer）</strong>：以 16 位字符为单位处理数据，适用于文本文件，能处理各种字符编码。<ul><li><strong>实现类</strong>：<code>FileReader</code>, <code>FileWriter</code>, <code>BufferedReader</code>, <code>BufferedWriter</code>。</li></ul></li></ul></li></ul><h3 id="2-字节流和字符流有什么区别？"><a href="#2-字节流和字符流有什么区别？" class="headerlink" title="2. 字节流和字符流有什么区别？"></a>2. 字节流和字符流有什么区别？</h3><p>字节流和字符流的主要区别在于处理数据的单位和适用场景：</p><ul><li><strong>数据单位</strong>：字节流以 8 位字节为单位进行读写，而字符流以 16 位字符为单位。</li><li><strong>编码转换</strong>：字符流是字节流的封装，它在内部处理了字节和字符之间的编码转换。当处理文本文件时，字符流可以根据指定的字符集（如 UTF-8）自动进行编码和解码，避免了乱码问题。字节流不进行编码转换，直接处理原始字节。</li><li><strong>最小存储单元</strong>：尽管字符流以字符为单位，但文件或网络传输的最小存储单元依然是字节。字符流在底层仍依赖于字节流来完成数据的传输。</li><li><strong>适用场景</strong>：<ul><li><strong>字节流</strong>：适用于所有文件类型，尤其是处理<strong>非文本文件</strong>（如图片、视频、音频等），因为这些文件不需要进行字符编码转换。</li><li><strong>字符流</strong>：专门用于处理<strong>文本文件</strong>，可以避免手动处理字符编码的复杂性。</li></ul></li></ul><h3 id="3-BIO、NIO-和-AIO-有什么区别？"><a href="#3-BIO、NIO-和-AIO-有什么区别？" class="headerlink" title="3. BIO、NIO 和 AIO 有什么区别？"></a>3. BIO、NIO 和 AIO 有什么区别？</h3><p>这是 Java IO 发展历程中的三种不同模型，主要区别在于处理 IO 操作的方式（阻塞&#x2F;非阻塞、同步&#x2F;异步）和并发能力。</p><ul><li><strong>BIO (Blocking I&#x2F;O)</strong><ul><li><strong>特点</strong>：<strong>同步阻塞</strong>。当一个线程发起 IO 操作（如 <code>read</code> 或 <code>accept</code>），它会一直阻塞，直到数据读写完成或连接建立。</li><li><strong>模型</strong>：采用“一对一”的连接模型，即一个客户端连接对应一个处理线程。</li><li><strong>优点</strong>：编程模型简单直观，适用于连接数较少、并发量不高的场景。</li><li><strong>缺点</strong>：在高并发场景下，每个连接都需要一个线程，会消耗大量系统资源，导致性能瓶颈。</li></ul></li><li><strong>NIO (Non-blocking I&#x2F;O)</strong><ul><li><strong>特点</strong>：<strong>同步非阻塞</strong>。一个线程可以同时处理多个连接。当线程发起 IO 操作时，如果数据没有准备好，它不会阻塞，而是立即返回，去做其他事情，稍后再次检查。</li><li><strong>模型</strong>：采用<strong>多路复用</strong>模型。通过一个 <code>Selector</code>（选择器），一个或少数几个线程可以监听多个 <code>Channel</code>（通道）上的 IO 事件（如连接就绪、数据可读），从而高效地处理大量并发连接。</li><li><strong>优点</strong>：解决了 BIO 的高并发问题，大大提高了系统的吞吐量，适用于高并发的网络应用。</li><li><strong>缺点</strong>：编程模型相对复杂。尽管 IO 操作是非阻塞的，但数据读写本身仍然是同步的，即线程在进行读写时仍需等待。</li></ul></li><li><strong>AIO (Asynchronous I&#x2F;O)</strong><ul><li><strong>特点</strong>：<strong>异步非阻塞</strong>。应用程序发起 IO 操作后，会立即返回，而不会等待数据读写。操作系统会在后台完成 IO 操作，并在完成后通过<strong>回调</strong>或事件通知应用程序。</li><li><strong>模型</strong>：基于<strong>事件和回调</strong>机制。</li><li><strong>优点</strong>：进一步提高了并发性能，彻底释放了线程资源，适用于连接数巨大且连接时间长的应用。</li><li><strong>缺点</strong>：目前在实际应用中，特别是在网络编程方面，使用不如 NIO 广泛，因为其复杂性和对操作系统的依赖性较高。</li></ul></li></ul><h2 id="Java-反射-Reflection"><a href="#Java-反射-Reflection" class="headerlink" title="Java 反射 (Reflection)"></a>Java 反射 (Reflection)</h2><p>Java 反射机制是指在程序运行时，能够动态地获取类的信息（包括类的属性、方法、构造器等），并能够动态地操作类或对象（如创建对象、调用方法、修改属性）。</p><ul><li><p><strong>核心类与接口：</strong></p><ul><li>Class 类：代表类的字节码文件，是反射的入口。</li><li>Constructor 类：代表类的构造器。</li><li>Method 类：代表类的方法。</li><li>Field 类：代表类的成员变量（属性）。</li><li>AccessibleObject：Field, Method, Constructor 的共同父类，提供了 setAccessible(true) 方法，用于抑制 Java 语言访问检查，从而访问私有成员。</li></ul></li><li><p><strong>获取 Class 对象的三种方式：</strong></p><ol><li><p>Class.forName(“全限定类名”)：最常用，动态加载类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>类名.class：已知具体类名时使用，编译时加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = String.class;</span><br></pre></td></tr></table></figure></li><li><p>对象.getClass()：通过对象实例获取，运行时获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Class&lt;?&gt; clazz = s.getClass();</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>反射的应用：</strong></p><ul><li><p>动态创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance(); <span class="comment">// 调用无参构造器</span></span><br><span class="line"><span class="comment">// 或者调用指定构造器</span></span><br><span class="line">Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person2</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure></li><li><p>动态调用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">setNameMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">setNameMethod.invoke(person, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// 调用 setName 方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getNameMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) getNameMethod.invoke(person); <span class="comment">// 调用 getName 方法</span></span><br></pre></td></tr></table></figure></li><li><p>动态操作属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance();</span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">// 获取私有属性</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>); <span class="comment">// 允许访问私有属性</span></span><br><span class="line">nameField.set(person, <span class="string">&quot;Charlie&quot;</span>); <span class="comment">// 设置属性值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) nameField.get(person); <span class="comment">// 获取属性值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>反射的优缺点：</strong></p><ul><li>优点：<ul><li>灵活性和动态性:在运行时动态获取类信息和操作对象,大大增强了程序的灵活性,是许多框架(如Spring、ORM框架)和工具(如JSON解析库)的基础。</li><li>解耦:允许代码在编译时不知道具体的类,只在运行时加载和使用,实现高度解耦。</li></ul></li><li>缺点:<ul><li>性能开销:反射操作比直接调用有更高的性能开销,因为涉及到动态解析和查找。</li><li>安全性问题:setAccessible(true)可以绕过Java的访问控制,可能破坏封装性。</li><li>可维护性差:反射代码通常比直接调用更复杂,更难调试和维护。</li><li>编译时检查缺失:反射操作在编译时无法检查类型错误,只能在运行时发现。</li></ul></li></ul></li></ul><h2 id="JVM内存结构与垃圾收集器"><a href="#JVM内存结构与垃圾收集器" class="headerlink" title="JVM内存结构与垃圾收集器"></a>JVM内存结构与垃圾收集器</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><h3 id="JVM-简单介绍"><a href="#JVM-简单介绍" class="headerlink" title="JVM 简单介绍"></a>JVM 简单介绍</h3><p>Java 虚拟机（JVM）是 Java 语言跨平台能力的核心。它是一个抽象的计算机，负责将 Java 字节码 (<code>.class</code> 文件) 转换成特定平台的机器指令。下面通过表格的形式，简单介绍 JVM 的主要组成部分、功能和工作流程。</p><hr><table><thead><tr><th>模块名称</th><th>核心功能</th><th>主要组成部分</th><th>简要说明</th></tr></thead><tbody><tr><td><strong>类加载子系统</strong></td><td>加载、链接、初始化 <code>.class</code> 文件</td><td>类加载器 (ClassLoader)</td><td>负责从文件系统、网络等来源加载 <code>.class</code> 文件到内存，并进行验证、准备和解析。</td></tr><tr><td><strong>运行时数据区</strong></td><td>存放程序运行时的各种数据</td><td><strong>方法区</strong><br><strong>堆</strong><br><strong>虚拟机栈</strong><br><strong>本地方法栈</strong><br><strong>程序计数器</strong></td><td>线程共享：<br>- <strong>方法区</strong>: 存储已加载的类信息、常量、静态变量等。<br>- <strong>堆</strong>: 存储所有对象实例和数组。<br><br>线程私有：<br>- <strong>虚拟机栈</strong>: 存储方法调用的局部变量、操作数栈等。<br>- <strong>本地方法栈</strong>: 存储 Native 方法的调用信息。<br>- <strong>程序计数器</strong>: 记录当前线程正在执行的字节码指令地址。</td></tr><tr><td><strong>执行引擎</strong></td><td>执行字节码指令</td><td><strong>解释器</strong><br><strong>即时编译器 (JIT)</strong><br><strong>垃圾收集器 (GC)</strong></td><td>负责将字节码翻译成机器指令并执行。<br>- <strong>解释器</strong>: 逐行解释执行字节码。<br>- <strong>JIT</strong>: 将热点代码编译成高效的本地机器码。<br>- <strong>GC</strong>: 自动回收堆中不再使用的对象内存。</td></tr><tr><td><strong>本地方法接口</strong></td><td>调用 Native 方法</td><td>JNI (Java Native Interface)</td><td>允许 Java 代码与其他语言（如 C&#x2F;C++）编写的代码进行交互。</td></tr><tr><td><strong>本地方法库</strong></td><td>支持 Native 方法</td><td>一系列本地方法库</td><td>提供了执行引擎调用本地方法所需的库文件。</td></tr></tbody></table><p>JVM(Java Virtual Machine)在执行Java程序时,会将内存划分为几个不同的区域,这些区域有各自的用途和生命周期。</p><ul><li><p><strong>程序计数器 (Program Counter Register)</strong></p><ul><li>功能:一块较小的内存空间,用于存储当前线程所执行的字节码的行号指示器。</li><li>特点:<ul><li>每个线程私有,生命周期与线程一致。</li><li>JVM规范中唯一没有规定任何OutOfMemoryError情况的区域。</li><li>在多线程切换时,程序计数器记录了当前线程的执行位置,使得线程切换回来后能够知道从哪里继续执行。</li></ul></li></ul></li><li><p><strong>Java虚拟机栈 (Java Virtual Machine Stacks)</strong></p><ul><li>功能:每个线程私有的内存区域,用于存储栈帧(Stack Frame)。每个方法被执行时都会创建一个栈帧,用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li><li>特点:<ul><li>生命周期与线程一致。</li><li>局部变量表:存储方法参数和方法内部定义的局部变量。</li><li>操作数栈:用于存放方法执行时的操作数和中间结果。</li><li>动态链接:指向运行时常量池中该栈帧所属方法的引用。</li><li>方法出口:记录方法执行完后回到哪里。</li><li>可能抛出StackOverflowError(栈深度超过虚拟机允许的深度)或OutOfMemoryError(栈扩展时无法申请到足够的内存)。</li></ul></li></ul></li><li><p><strong>本地方法栈 (Native Method Stacks)</strong></p><ul><li>功能:与虚拟机栈类似,但是为JVM执行Native方法(即用C&#x2F;C++等语言实现的方法)服务。</li><li>特点：<ul><li>每个线程私有。</li><li>可能抛出 StackOverflowError 或 OutOfMemoryError。</li></ul></li></ul></li><li><p><strong>Java 堆 (Java Heap)</strong></p><ul><li><p>功能:JVM 管理的最大一块内存区域，被所有线程共享，用于存放对象实例和数组。</p></li><li><p>特点：</p><ul><li><p>是垃圾收集器管理的主要区域 (GC 堆)。</p></li><li><p>是 Java 应用程序对象存放的“老家”。</p></li><li><p>根据垃圾回收的特性，可以分为新生代 (Young Generation) 和老年代 (Old Generation)。</p></li><li><p>新生代:通常分为 Eden 空间和两个 Survivor 空间 (From 和 To)。新创建的对象优先在 Eden 区分配，经过 Minor GC 后存活的对象进入 Survivor 区，多次 GC 后仍存活的对象进入老年代。</p></li><li><p>老年代:存放生命周期较长的对象。</p></li><li><p>在 JVM 内存模型中，新生代被划分为三个区域，默认的比例通常是 <strong>8:1:1</strong>。</p><ul><li><strong>Eden 区</strong>：占比 <strong>80%</strong>。这是新创建对象的主要分配区域。</li><li><strong>Survivor S0 区</strong>：占比 <strong>10%</strong>。</li><li><strong>Survivor S1 区</strong>：占比 <strong>10%</strong>。</li></ul><hr><h3 id="为什么要这样划分？"><a href="#为什么要这样划分？" class="headerlink" title="为什么要这样划分？"></a><strong>为什么要这样划分？</strong></h3><p>这种划分是为了配合 Minor GC 的垃圾回收流程，从而提高垃圾回收的效率。</p><h4 id="新生代的垃圾回收流程"><a href="#新生代的垃圾回收流程" class="headerlink" title="新生代的垃圾回收流程"></a><strong>新生代的垃圾回收流程</strong></h4><ol><li><strong>对象创建</strong>：新创建的对象首先在 <strong>Eden 区</strong> 分配。</li><li><strong>Minor GC</strong>：当 <strong>Eden 区</strong> 满了之后，会触发一次 Minor GC（也叫 Young GC）。</li><li><strong>存活对象转移</strong>：<ul><li>在 Eden 区和其中一个 Survivor 区（比如 S0）中，所有存活的对象会被复制到另一个空的 Survivor 区（比如 S1）。</li><li>同时，对象的年龄（age）会加一。</li></ul></li><li><strong>清空 Eden 和 S0</strong>：垃圾回收后，Eden 区和 S0 区都会被清空。</li><li><strong>角色互换</strong>：下一次 Minor GC 时，Eden 区和 S1 区中存活的对象会被复制到 S0 区。S0 和 S1 两个 Survivor 区会不断地进行角色互换。</li><li><strong>晋升老年代</strong>：<ul><li>当对象的年龄达到一个设定的阈值（默认为 15），或者 Survivor 区中同一年龄段的对象大小超过了一定比例，这些对象就会被移动到<strong>老年代</strong>。</li><li>这种设计也被称为<strong>复制算法（Copying Algorithm）</strong>，它在新生代存活对象较少的情况下，效率非常高。</li></ul></li></ol><hr><h3 id="为什么是-8-1-1？"><a href="#为什么是-8-1-1？" class="headerlink" title="为什么是 8:1:1？"></a><strong>为什么是 8:1:1？</strong></h3><p>这个比例是一个经验值，基于大多数 Java 应用的特点：</p><ul><li><strong>大多数对象都是朝生夕灭的</strong>。因此，将 Eden 区设置得更大，可以容纳更多的新对象，减少 Minor GC 的频率。</li><li>两个 Survivor 区只需要用来暂存存活的对象，因此不需要太大。10% 的空间通常足以容纳一次 Minor GC 后存活的对象。</li></ul><p>当然，这个比例不是固定的。在某些特殊情况下，如果新生代存活对象较多，导致 Survivor 区无法容纳所有存活对象，JVM 会发生<strong>空间分配担保</strong>，将这些对象直接晋升到老年代。</p><p>你可以通过 JVM 参数来调整这个比例，例如： <code>java -Xmn100m -XX:SurvivorRatio=8</code></p><p>这个命令设置新生代总大小为 100MB，Eden 区和 Survivor 区的比例为 8:1:1。</p></li><li><p>可能抛出 OutOfMemoryError。</p></li></ul></li></ul></li><li><p><strong>方法区 (Method Area)</strong></p><ul><li>功能:被所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>特点：<ul><li>在 JDK 1.7 及之前，方法区被称为“永久代 (Permanent Generation)”，它属于堆内存的一部分。</li><li>在 JDK 1.8 及之后，永久代被移除，方法区的实现改为“元空间 (Metaspace)”，并且元空间不使用 JVM 内存，而是直接使用本地内存 (Native Memory)。</li><li>可能抛出 OutOfMemoryError。</li></ul></li></ul></li><li><p><strong>运行时常量池 (Runtime Constant Pool)</strong></p><ul><li>功能:方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</li><li>特点：<ul><li>动态性:Java 语言并不要求常量池在编译期就全部确定，运行时也可以将新的常量放入池中 (如 String.intern())。</li><li>可能抛出 OutOfMemoryError。</li></ul></li></ul></li></ul><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>程序计数器（Program Counter Register）：是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。程序的分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的命令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储，我们程这块内存区域为“线程私有”的内存。</p><p>此区域是唯一一个虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><hr><h3 id="2-Java-虚拟机栈"><a href="#2-Java-虚拟机栈" class="headerlink" title="2. Java 虚拟机栈"></a>2. Java 虚拟机栈</h3><p>Java 虚拟机栈（Java Virtual Machine Stacks）：描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个帧栈（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。它的线程也是私有的，生命周期与线程相同。</p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和 returnAddress 类型（指向了一条字节码指令的地址）。</p><p>Java 虚拟机栈的局部变量表的空间单位是槽（Slot），其中 64 位长度的 double 和 long 类型会占用两个 Slot。局部变量表所需内存空间在编译期完成分配，当进入一个方法时，该方法需要在帧中分配多大的局部变量是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>Java虚拟机栈有两种异常状况：如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出 <code>StackOverflowError</code> 异常；如果扩展时无法申请到足够的内存，就会抛出 <code>OutOfMemoryError</code> 异常。</p><hr><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>本地方法栈（Native Method Stack）：与虚拟机栈所发的作用是非常相似的，它们之间的区别只不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p><p>Java 虚拟机规范没有对本地方法栈中方法使用的语言、使用的方式和数据结构做出强制规定，因此具体的虚拟机可以自由地实现它。比如：Sun HotSpot 虚拟机直接把Java虚拟机栈和本地方法栈合二为一。</p><p>与Java虚拟机栈一样，本地方法栈也会抛出<code>StackOverflowError</code>和 <code>OutOfMemoryError</code> 异常。</p><hr><h3 id="4-Java-堆"><a href="#4-Java-堆" class="headerlink" title="4. Java 堆"></a>4. Java 堆</h3><p>Java堆（Java Heap）：是被所有线程所共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是：存放对象实例，几乎所有的对象实例都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC”堆（Garbage Collected Heap）。从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代。从内存分配角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）。不过无论如何划分，都与存放的内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p><p>Java 虚拟机规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，可以是固定大小的，也可以是可扩展的。如果在堆中没有完成实例分配。并且堆也无法扩展时，将会抛出 <code>OutOfMemoryError</code> 异常。</p><hr><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>方法区（Method Area）：与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），其目的应该就是与 Java 堆区分开来。</p><p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</p><p>根据Java虚拟机规范规定，当方法区无法满足内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p><p><strong>运行时常量池</strong>：运行时常量池（Runtime Constant Pool）：是方法区的一部分。<code>Class</code> 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一些信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>Java 虚拟机对 Class 文件每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行。</p><p><strong>直接内存</strong>：直接内存（Direct Memory）：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也频繁地使用，而且也可能导致 <code>OutOfMemoryError</code> 异常。</p><p>本地直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存大小以及处理器寻址空间的限制。如果各个内存区域总和大于物理内存限制，从而导致动态扩展时出现 <code>OutOfMemoryError</code> 异常。</p><hr><h3 id="3-堆和栈的区别是什么？"><a href="#3-堆和栈的区别是什么？" class="headerlink" title="3. 堆和栈的区别是什么？"></a>3. 堆和栈的区别是什么？</h3><p>堆和栈（虚拟机栈）是完全不同的两块内存区域，一个是线程独享的，一个是线程共享的。二者之间最大的区别就是存储的内容不同：堆中主要存放对象实例。栈（局部变量表）中主要存放各种基本数据类型、对象的引用。</p><p>从作用来说，栈是运行时的单位，而堆是存储的单位。栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。在 Java 中一个线程就会相应有一个线程栈与之对应，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。</p><hr><h3 id="4-堆中存什么？栈中存什么？"><a href="#4-堆中存什么？栈中存什么？" class="headerlink" title="4. 堆中存什么？栈中存什么？"></a>4. 堆中存什么？栈中存什么？</h3><p>堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个 4btye 的引用（堆栈分离的好处）。</p><p>为什么不把基本类型放堆中呢？</p><p>因为基本数据类型占用的空间一般是1~8个字节，需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况，长度固定，因此栈中存储就够了。如果把它存在堆中是没有什么意义的。基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，它们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java 中参数传递时的问题。</p><hr><h3 id="5-为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"><a href="#5-为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？" class="headerlink" title="5. 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"></a>5. 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</h3><ol><li>从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</li><li>堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li><li>栈因为运行时的需要，比如：保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</li></ol><hr><h3 id="6-Java-中的参数传递时传值呢？还是传引用？"><a href="#6-Java-中的参数传递时传值呢？还是传引用？" class="headerlink" title="6. Java 中的参数传递时传值呢？还是传引用？"></a>6. Java 中的参数传递时传值呢？还是传引用？</h3><p>要说明这个问题，先要明确两点：</p><ol><li>不要试图与 C 进行类比，Java 中没有指针的概念。</li><li>程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。</li></ol><p>Java 在方法调用传递参数时，因为没有指针，所以它都是进行传值调用。但是传引用的错觉是如何造成的呢？在运行栈中，基本类型和引用的处理是一样的，都是传值。所以，如果是传引用的方法调用，也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。但是当进入被调用方法时，被传递的这个引用的值，被程序解释到堆中的对象，这个时候才对应到真正的对象。如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是堆中的数据。所以这个修改是可以保持的了。</p><p>对象，从某种意义上说，是由基本类型组成的。可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树（即非叶子节点），基本类型则为树的叶子节点。程序参数传递时，被传递的值本身都是不能进行修改的，但是，如果这个值是一个非叶子节点（即一个对象引用），则可以修改这个节点下面的所有内容。</p><hr><h3 id="7-Java-对象的大小是怎么计算的？"><a href="#7-Java-对象的大小是怎么计算的？" class="headerlink" title="7. Java 对象的大小是怎么计算的？"></a>7. Java 对象的大小是怎么计算的？</h3><p>基本数据类型的大小是固定的。对于非基本类型的 Java 对象，其大小就值得商榷。在 Java 中，一个空 <code>Object</code> 对象的大小是 8 byte，这个大小只是保存堆中一个没有任何属性的对象的<code>大小。看下面语句： </code>Object ob &#x3D; new Object();<code> 这样在程序中完成了一个 Java 对象的生命，但是它所占的空间为：</code>4 byte + 8 byte<code>。</code>4 byte<code>是上面部分所说的 Java 栈中保存引用的所需要的空间。而那</code>8 byte<code>则是 Java 堆中对象的信息。因为所有的 Java 非基本类型的对象都需要默认继承</code>Object<code>对象，因此不论什么样的 Java 对象，其大小都必须是大于</code>8 byte<code>。有了 </code>Object&#96; 对象的大小，我们就可以计算其他对象的大小了。</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class MaNong &#123;</span><br><span class="line">    int count;</span><br><span class="line">    boolean flag;</span><br><span class="line">    Object obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MaNong</code> 的大小为：空对象大小(8 byte) + <code>int</code> 大小(4 byte) + <code>Boolean</code> 大小(1 byte) + 空 <code>Object</code> 引用的<code>大小（4 byte）</code> &#x3D; 17byte。但是因为 Java 在对对象内存分配时都是以 8 的整数倍来分，因此大于 17 byte 的最接近 8 的整数倍的是 24，因此此对象的大小为 24 byte。</p><p>这里需要注意一下基本类型的包装类型的大小。因为这种包装类型已经成为对象了，因此需要把它们作为对象来看待。包装类型的大小至少是12 byte（声明一个空 <code>Object</code> 至少需要的空间），而且 12 byte 没有包含任何有效信息，同时，因为 Java 对象大小是 8 的整数倍，因此一个基本类型包装类的大小至少是 16 byte。这个内存占用是很恐怖的，它是使用基本类型的 N 倍（N &gt; 2），有些类型的内存占用更是夸张（随便想下就知道了）。因此，可能的话应尽量少使用包装类。在 JDK5 以后，因为加入了自动类型装换，因此，Java 虚拟机会在存储方面进行相应的优化。</p><hr><h3 id="8-对象的访问定位的两种方式？"><a href="#8-对象的访问定位的两种方式？" class="headerlink" title="8. 对象的访问定位的两种方式？"></a>8. 对象的访问定位的两种方式？</h3><p>Java 程序通过栈上的引用数据来操作堆上的具体对象。目前主流的对象访问方式有：句柄 和 直接指针。</p><ol><li><p>使用句柄</p><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p></li><li><p>直接指针</p><p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何防止访问类型数据的相关信息，reference 中存储的直接就是对象的地址。</p></li><li><p><strong>各自的优点</strong></p></li><li><p>使用句柄来访问的最大好处是引用中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而引用本身不需要修改；</p></li><li><p>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p></li></ol><h3 id="JVM-调优参数"><a href="#JVM-调优参数" class="headerlink" title="JVM 调优参数"></a>JVM 调优参数</h3><ul><li><strong>堆内存大小设置:</strong><ul><li>-Xms<size>:设置 JVM 堆的初始内存大小。</li><li>-Xmx<size>:设置 JVM 堆的最大内存大小。</li><li>最佳实践:通常建议 -Xms 和 -Xmx 设置为相同值，以避免 JVM 在运行时动态调整堆大小带来的额外开销和 GC 停顿。例如 -Xms4g -Xmx4g。</li></ul></li><li><strong>新生代大小设置:</strong><ul><li>-Xmn<size>:设置新生代内存大小。</li><li>-XX:NewRatio&#x3D;<ratio>:设置老年代与新生代的比例，例如 -XX:NewRatio&#x3D;2 表示老年代:新生代 &#x3D; 2:1。</li><li>考量:<ul><li>新生代过小:频繁 Minor GC, 导致对象过早进入老年代。</li><li>新生代过大:Minor GC 间隔长, 但每次 GC 耗时可能长。</li></ul></li></ul></li><li><strong>元空间大小设置 (JDK 1.8+):</strong><ul><li>-XX:MetaspaceSize&#x3D;<size>:设置元空间的初始大小。</li><li>-XX:MaxMetaspaceSize&#x3D;<size>:设置元空间的最大大小。</li><li>考量:如果应用加载大量类或使用动态代码生成, 可能需要调大。</li></ul></li><li><strong>选择垃圾收集器:</strong><ul><li>-XX:+UseG1GC:启用 G1 垃圾收集器。这是 JDK 9+ 的默认收集器。</li><li>-XX:MaxGCPauseMillis&#x3D;<ms>:设置 G1 收集器可接受的最大停顿时间(G1 会尽量接近这个目标, 但不保证完全达到)。例如 -XX:MaxGCPauseMillis&#x3D;200。</li></ul></li></ul><h3 id="10-垃圾回收是从哪里开始的呢？"><a href="#10-垃圾回收是从哪里开始的呢？" class="headerlink" title="10. 垃圾回收是从哪里开始的呢？"></a>10. 垃圾回收是从哪里开始的呢？</h3><p>垃圾回收从查找哪些对象是正在被当前系统使用的开始。上面分析的堆和栈的区别，其中栈是真正进行程序执行的地方，所以要获取哪些对象正在被使用，则需要从 Java 栈开始。同时，一个栈是与一个线程对应的，因此，如果有多个线程的话，则必须对这些线程对应的所有的栈进行检查。</p><p>同时，除了栈外，还有系统运行时的寄存器等，也是存储程序运行数据的。这样，以栈或寄存器中的引用为起点，我们可以找到堆中的对象，又从这些对象找到对堆中其他对象的引用，这种引用逐步扩展，最终以 <code>null</code> 引用或者基本类型结束，这样就形成了一棵以 Java 栈中引用所对应的对象为根节点的一棵对象树。如果栈中有多个引用，则最终会形成多棵对象树。在这些对象树上的对象，都是当前系统运行所需要的对象，不能被垃圾回收。而其他剩余对象，则可以视为无法被引用到的对象，可以被当做垃圾进行回收。</p><hr><h3 id="11-被标记为垃圾的对象一定会被回收吗？"><a href="#11-被标记为垃圾的对象一定会被回收吗？" class="headerlink" title="11. 被标记为垃圾的对象一定会被回收吗？"></a>11. 被标记为垃圾的对象一定会被回收吗？</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。</p><ul><li><strong>第一次标记</strong>：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记；</li><li><strong>第二次标记</strong>：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize()</code> 方法。在 <code>finalize()</code> 方法中没有重新与引用链建立关联关系的，将被进行第二次标记。第二次标记成功的对象将真的会被回收，如果对象在 <code>finalize()</code> 方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。</li></ul><hr><h3 id="12-谈谈对-Java-中引用的了解？"><a href="#12-谈谈对-Java-中引用的了解？" class="headerlink" title="12. 谈谈对 Java 中引用的了解？"></a>12. 谈谈对 Java 中引用的了解？</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在Java语言中，将引用又分为强引用、软引用、弱引用、虚引用 4 种，这四种引用强度依次逐渐减弱。</p><ol><li><p>强引用</p><p>在程序代码中普遍存在的，类似 Object obj &#x3D; new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p></li><li><p>软引用</p><p>用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内</p></li><li><p>弱引用</p><p>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p></li><li><p>虚引用</p><p>也叫幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。</p></li></ol><hr><h3 id="13-谈谈对内存泄漏的理解？"><a href="#13-谈谈对内存泄漏的理解？" class="headerlink" title="13. 谈谈对内存泄漏的理解？"></a>13. 谈谈对内存泄漏的理解？</h3><p>内存泄露的基本概念</p><p>在 Java 中，内存泄漏就是存在一些不会再被使用却没有被回收的对象，这些对象有下面两个特点：</p><ol><li><p>这些对象是可达的，即在有向图中，存在通路可以与其相连；</p></li><li><p>这些对象是无用的，即程序以后不会再使用这些对象。</p><p>如果对象满足这两个条件，这些对象就可以判定为 Java 中的内存泄漏，这些对象不会被 GC 所回收，然而它却占用内存。</p></li></ol><hr><h3 id="14-内存泄露的根本原因是什么？"><a href="#14-内存泄露的根本原因是什么？" class="headerlink" title="14. 内存泄露的根本原因是什么？"></a>14. 内存泄露的根本原因是什么？</h3><p>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是 Java 中内存泄漏的发生场景。</p><hr><h3 id="15-举几个可能发生内存泄漏的情况？"><a href="#15-举几个可能发生内存泄漏的情况？" class="headerlink" title="15. 举几个可能发生内存泄漏的情况？"></a>15. 举几个可能发生内存泄漏的情况？</h3><ol><li>静态集合类引起的内存泄漏；</li><li>当集合里面的对象属性被修改后，再调用 <code>remove()</code> 方法时不起作用；</li><li>监听器：释放对象的时候没有删除监听器；</li><li>各种连接：比如数据库连接（<code>dataSourse.getConnection()</code>），网络连接(<code>socket</code>) 和 IO 连接，除非其显式的调用了其 <code>close()</code> 方法将其连接关闭，否则是不会自动被 GC 回收的；</li><li>内部类：内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放；</li><li>单例模式：单例对象在初始化后将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏。</li></ol><hr><h3 id="16-尽量避免内存泄漏的方法？"><a href="#16-尽量避免内存泄漏的方法？" class="headerlink" title="16. 尽量避免内存泄漏的方法？"></a>16. 尽量避免内存泄漏的方法？</h3><ol><li>尽量不要使用 <code>static</code> 成员变量，减少生命周期；</li><li>及时关闭资源；</li><li>不用的对象，可以手动设置为 <code>null</code>。</li></ol><h3 id="垃圾收集器-Garbage-Collector"><a href="#垃圾收集器-Garbage-Collector" class="headerlink" title="垃圾收集器 (Garbage Collector)"></a>垃圾收集器 (Garbage Collector)</h3><p>垃圾收集器是 JVM 的一个重要组成部分, 负责自动管理 Java 堆内存中的对象的生命周期, 回收不再使用的对象所占用的内存。</p><h4 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法:"></a><strong>垃圾判断算法:</strong></h4><ul><li>引用计数算法:当一个对象被引用一次, 计数器加1;引用失效, 计数器减1。当计数器为0时, 对象被判定为可回收。<ul><li>缺点:难以解决对象之间的循环引用问题。Java 虚拟机不采用此算法。</li></ul></li><li>可达性分析算法 (Root Tracing):通过一系列称为 “GC Roots” 的对象作为起始点, 从这些节点向下搜索, 搜索所走过的路径称为引用链 (Reference Chain)。当一个对象到 GC Roots 没有任何引用链相连时, 则证明此对象是不可用的。<ul><li>可作为 GC Roots 的对象:<ul><li>虚拟机栈 (栈帧中的局部变量表) 中引用的对象。</li><li>本地方法栈 (Native 方法) 中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>被同步锁持有的对象。</li><li>JVM 内部的引用 (如基本数据类型对应的 Class 对象)。</li></ul></li></ul></li></ul><h4 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器:"></a><strong>常见垃圾收集器:</strong></h4><ul><li><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器:"></a>Serial 收集器:</h5><ul><li>特点:单线程, 工作时需要停止所有用户线程 (“Stop The World”, STW)。简单高效, 适用于单核 CPU 或内存较小的客户端应用。</li><li>新生代使用:复制算法。</li><li>老年代使用:标记-整理算法。</li></ul></li><li><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器:"></a>ParNew 收集器:</h5><ul><li>特点:Serial 收集器的多线程版本, 用于新生代。并行收集时也需要 STW。</li><li>新生代使用:复制算法。</li><li>常与 CMS 收集器配合使用。</li></ul></li><li><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器:"></a>Parallel Scavenge 收集器:</h5><ul><li>特点：关注吞吐量（Throughput &#x3D; 用户代码执行时间 &#x2F; (用户代码执行时间 + GC 时间)），可以设置最大吞吐量或最大 GC 停顿时间。</li><li>新生代使用：复制算法。</li><li>老年代使用：与 Parallel Old 配合使用，使用标记-整理算法。</li></ul></li><li><h5 id="CMS-Concurrent-Mark-Sweep-收集器："><a href="#CMS-Concurrent-Mark-Sweep-收集器：" class="headerlink" title="CMS (Concurrent Mark Sweep) 收集器："></a>CMS (Concurrent Mark Sweep) 收集器：</h5><ul><li>特点：以获取最短回收停顿时间为目标，并发收集（与用户线程一起执行）。适用于对响应时间要求高的应用（如 Web 服务器）。</li><li>工作步骤：<ol><li>初始标记 (Initial Mark)：STW，标记 GC Roots 能直接关联到的对象，速度快。</li><li>并发标记 (Concurrent Mark)：与用户线程并发执行，进行 GC Roots Tracing 过程，耗时最长。</li><li>重新标记 (Remark)：STW，修正并发标记期间因用户程序继续运行而导致标记产生变动的对象，比初始标记耗时长，但远比并发标记短。</li><li>并发清除 (Concurrent Sweep)：与用户线程并发执行，清除已标记为垃圾的对象。</li></ol></li><li>缺点：<ul><li>对 CPU 资源敏感：并发阶段会占用一部分 CPU。</li><li>无法处理浮动垃圾：并发清除阶段产生的垃圾（新生成的对象）只能下次 GC 再处理。</li><li>可能产生大量空间碎片：采用“标记-清除”算法，不进行整理，可能导致大对象无法分配空间而提前触发 Full GC。</li></ul></li></ul></li><li><h5 id="G1-Garbage-First-收集器："><a href="#G1-Garbage-First-收集器：" class="headerlink" title="G1 (Garbage-First) 收集器："></a>G1 (Garbage-First) 收集器：</h5><ul><li>特点：JDK 9+ 的默认垃圾收集器。面向服务端应用，分区（将 Java 堆划分为多个独立区域 Region)，可预测的停顿时间模型。</li><li>工作原理：<ul><li>将堆内存划分为多个大小相等的 Region。</li><li>G1 跟踪每个 Region 的垃圾回收价值 (Garbage-First)，优先回收垃圾最多的 Region。</li><li>年轻化和老年代不再是物理隔离，而是逻辑上的概念，Region 可以动态地成为 Eden、Survivor 或 Old 区域。</li><li>并发与并行兼容：并发标记，但回收阶段并行。</li><li>基本无碎片：采用复制和标记-整理算法结合。</li></ul></li><li>工作步骤：<ol><li>初始标记 (Initial Mark)：STW，标记 GC Roots 能直接关联的对象。</li><li>并发标记 (Concurrent Mark)：与用户线程并发，遍历对象图。</li><li>最终标记 (Final Mark)：STW，处理并发标记阶段结束后仍然存活的对象。</li><li>筛选回收 (Evacuation)：STW，对各个 Region 的回收价值进行排序，根据预期停顿时间来回收 Region，采用复制算法将存活对象复制到新的 Region。</li></ol></li><li>优势：在保持高吞吐量的同时，降低了 GC 停顿时间，适合大内存、多核处理器场景。</li></ul></li><li><h5 id="zGC-Z-Garbage-Collector-和-Shenandoah-收集器："><a href="#zGC-Z-Garbage-Collector-和-Shenandoah-收集器：" class="headerlink" title="zGC (Z Garbage Collector) 和 Shenandoah 收集器："></a>zGC (Z Garbage Collector) 和 Shenandoah 收集器：</h5><ul><li>特点：低延迟、并发 GC 收集器，旨在实现毫秒级的 GC 停顿。</li><li>ZGC: JDK 11 引入，支持 TB 级别的堆内存，停顿时间与堆大小无关。</li><li>Shenandoah: JDK 12 引入，与 G1 类似，但能进一步降低停顿时间。</li><li>应用场景：对延迟要求极高的应用</li></ul></li></ul><h2 id="类加载机制-Class-Loading-Mechanism"><a href="#类加载机制-Class-Loading-Mechanism" class="headerlink" title="类加载机制 (Class Loading Mechanism)"></a>类加载机制 (Class Loading Mechanism)</h2><ul><li><p><strong>作用</strong>: 将 .class 文件中的字节码加载到 JVM 内存中，并转换为运行时数据结构。  </p></li><li><p><strong>生命周期</strong>: 加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载。  </p></li><li><p><strong>主要阶段</strong>:  </p><ul><li><strong>加载 (Loading)</strong>:  <ul><li>通过类的全限定名获取该类的二进制字节流。  </li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  </li><li>在内存中生成一个代表该类的 java.lang.Class 对象。</li></ul></li><li><strong>验证 (Verification)</strong>: 确保 Class 文件的字节流符合 JVM 规范，没有安全问题。  </li><li><strong>准备 (Preparation)</strong>: 为类的静态变量（static fields）分配内存并初始化为默认值（如 int 变量为 0，引用类型为 null）。  </li><li><strong>解析 (Resolution)</strong>: 将常量池中的符号引用替换为直接引用。  </li><li><strong>初始化 (Initialization)</strong>: 执行类的构造器 <code>&lt;clinit&gt;()</code> 方法，真正开始执行类中定义的 Java 程序代码（为静态变量赋予初始值，执行静态代码块）。</li></ul></li><li><p>类加载是 Java 虚拟机（JVM）将 <code>Class</code> 文件中的二进制数据读取到内存中，并将其转换为可用的 <code>java.lang.Class</code> 对象的过程。这个过程是所有 Java 程序运行的基础。</p><p>类加载的整个生命周期包括以下 7 个阶段：</p><ol><li><strong>加载（Loading）</strong></li><li><strong>验证（Verification）</strong></li><li><strong>准备（Preparation）</strong></li><li><strong>解析（Resolution）</strong></li><li><strong>初始化（Initialization）</strong></li><li>使用（Using）</li><li>卸载（Unloading）</li></ol><p>其中，前五个阶段是类加载的核心过程，后面两个阶段是类生命周期的延伸。下面我们详细解析前五个核心阶段。</p><hr><h3 id="1-加载（Loading）"><a href="#1-加载（Loading）" class="headerlink" title="1. 加载（Loading）"></a>1. 加载（Loading）</h3><p>这是类加载过程的第一个阶段，主要任务是查找并导入 <code>Class</code> 文件中的二进制数据。这个阶段主要完成三件事：</p><ul><li><strong>通过类的全限定名获取定义此类的二进制字节流</strong>：JVM 可以从文件系统、网络、压缩包（JAR&#x2F;WAR&#x2F;EAR）甚至数据库中获取字节流。</li><li><strong>将字节流中的静态存储结构转换为方法区的运行时数据结构</strong>：JVM 会将二进制数据按照虚拟机规范的要求，转化为方法区中可用的数据结构。</li><li><strong>在内存中生成一个代表该类的 java.lang.Class 对象</strong>：这个对象是访问方法区中该类各种数据（如方法、字段）的入口，也是反射机制的基石。</li></ul><hr><h3 id="2-验证（Verification）"><a href="#2-验证（Verification）" class="headerlink" title="2. 验证（Verification）"></a>2. 验证（Verification）</h3><p>验证阶段的目的是确保 <code>Class</code> 文件的字节流符合 JVM 规范，并且不会危害到虚拟机的安全。这个阶段非常重要，因为 <code>Class</code> 文件不一定是由 Java 源码编译而来，它可以是任何来源。验证通常包括以下几个检查：</p><ul><li><strong>文件格式验证</strong>：检查字节流是否符合 <code>Class</code> 文件格式的规范，例如魔数（<code>0xCAFEBABE</code>）、版本号等。</li><li><strong>元数据验证</strong>：对类的元数据进行语义分析，确保其符合 Java 语言规范，例如是否继承了不允许继承的 <code>final</code> 类、字段和方法签名是否合理等。</li><li><strong>字节码验证</strong>：这是验证阶段最复杂的一步，通过数据流和控制流分析，确保程序语义是合法的、符合逻辑的。例如，保证类型转换是有效的、方法调用的参数是正确的。</li><li><strong>符号引用验证</strong>：在解析阶段发生，确保解析出来的类、字段、方法是真实存在的，并且具有足够的访问权限。</li></ul><hr><h3 id="3-准备（Preparation）"><a href="#3-准备（Preparation）" class="headerlink" title="3. 准备（Preparation）"></a>3. 准备（Preparation）</h3><p>准备阶段是为类的<strong>静态变量</strong>分配内存并设置<strong>初始值</strong>的阶段。</p><ul><li><strong>只为静态变量分配内存</strong>：在这个阶段，JVM 只为 <code>static</code> 变量（类变量）分配内存，而不包括实例变量。实例变量会在对象实例化时随着对象一起分配在堆中。</li><li><strong>设置初始值</strong>：这里的初始值通常是该数据类型的<strong>零值</strong>（例如 <code>int</code> 的初始值为 <code>0</code>，<code>boolean</code> 为 <code>false</code>，<code>String</code> 为 <code>null</code>）。</li></ul><p><strong>注意</strong>：如果静态变量被 <code>final</code> 修饰，并且是基本数据类型或字符串字面量，那么在准备阶段就会直接赋值为它在代码中定义的值。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备阶段：value 的初始值为 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备阶段：finalValue 的初始值直接为 123</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalValue</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="4-解析（Resolution）"><a href="#4-解析（Resolution）" class="headerlink" title="4. 解析（Resolution）"></a>4. 解析（Resolution）</h3><p>解析阶段是将常量池中的<strong>符号引用</strong>转换为<strong>直接引用</strong>的过程。</p><ul><li><strong>符号引用</strong>：一组符号来描述所引用的目标，可以是任何形式的字面量，只要能定位到目标即可。它不依赖于内存布局。</li><li><strong>直接引用</strong>：直接指向目标的指针、相对偏移量或是一个可以间接定位到目标的句柄。它与内存布局相关。</li></ul><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符七类符号引用进行。这个阶段是动态的，通常会在程序运行时，当符号引用被首次使用时才进行。</p><hr><h3 id="5-初始化（Initialization）"><a href="#5-初始化（Initialization）" class="headerlink" title="5. 初始化（Initialization）"></a>5. 初始化（Initialization）</h3><p>初始化是类加载过程的最后一步，在这个阶段，<strong>真正执行</strong>类中定义的 Java 代码。</p><ul><li><strong>执行 <clinit>() 方法</strong>：初始化阶段会执行类构造器 <code>&lt;clinit&gt;()</code> 方法，这个方法由编译器自动生成，它用于收集类中所有静态变量的赋值动作和静态代码块（<code>static &#123;&#125;</code>）中的语句。</li><li><strong>线程安全</strong>：JVM 会确保 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确地加锁和同步，保证一个类的 <code>&lt;clinit&gt;()</code> 方法只会被执行一次。</li><li><strong>触发时机</strong>：只有在以下几种情况中，一个类才会被“主动”初始化：<ul><li>创建类的实例（<code>new</code>）。</li><li>访问类的静态变量（除了在编译时被 <code>final</code> 化的常量）。</li><li>调用类的静态方法。</li><li>使用 <code>java.lang.reflect</code> 包的方法进行反射调用。</li><li>初始化一个子类时，其父类尚未初始化。</li><li>虚拟机启动时，被指定为启动类的类（如包含 <code>main()</code> 方法的类）。</li></ul></li></ul><p>理解这五个阶段对于深入掌握 JVM 的工作原理至关重要。</p></li><li><p><strong>类加载器 (Class Loaders)</strong>:  </p><ul><li><p>类加载器的分类：</p><p>（1）Bootstrap class loader （使用C++编写的）</p><p>​    简称：启动类加载器</p><p>​    <strong>加载路径</strong>：JAVA_HOME&#x2F;jre&#x2F;lib</p><p>​    显示形式：null</p><p>（2）Platform class loader（由Java编写的）</p><p>​    简称：扩展类加载器</p><p>​    <strong>加载路径</strong>：JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</p><p>​    显示形式：ExtClassLoader</p><p>（3）System class loader（由Java编写的）</p><p>​    简称：应用程序类加载器</p><p>​    <strong>加载路径</strong>：类路径（src目录）</p><p>​    显示形式：AppClassLoader   &#x2F;&#x2F;sun.misc.Launcher$AppClassLoader@18b4aac2</p><p>（4）自定义类加载器（由Java编写的）</p><p>​    简称：自定义类加载器</p><p>​    加载路径：自定义</p><h4 id="1-启动类加载器-Bootstrap-ClassLoader"><a href="#1-启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="1. 启动类加载器 (Bootstrap ClassLoader)"></a><strong>1. 启动类加载器 (Bootstrap ClassLoader)</strong></h4><ul><li><strong>作用</strong>：它负责加载 Java 核心库，比如 <code>rt.jar</code>（包含 <code>java.lang.*</code>, <code>java.util.*</code> 等核心类）。</li><li><strong>实现</strong>：它不是用 Java 写的，而是由 C++ 实现的，是 JVM 自身的一部分。因此，你无法在 Java 代码中直接获取到它的对象，调用 <code>getClassLoader()</code> 得到的会是 <code>null</code>。</li><li><strong>父加载器</strong>：它没有父加载器。它是类加载器层次结构的顶端。</li></ul><h4 id="2-扩展类加载器-Extension-ClassLoader"><a href="#2-扩展类加载器-Extension-ClassLoader" class="headerlink" title="2. 扩展类加载器 (Extension ClassLoader)"></a><strong>2. 扩展类加载器 (Extension ClassLoader)</strong></h4><ul><li><strong>作用</strong>：它负责加载 JVM 扩展目录中的所有 jar 包，通常是 <code>JRE/lib/ext</code> 目录下的库。</li><li><strong>实现</strong>：它是由 Java 语言实现的。</li><li><strong>父加载器</strong>：它的父加载器是<strong>启动类加载器</strong>。</li></ul><h4 id="3-应用程序类加载器-Application-ClassLoader"><a href="#3-应用程序类加载器-Application-ClassLoader" class="headerlink" title="3. 应用程序类加载器 (Application ClassLoader)"></a><strong>3. 应用程序类加载器 (Application ClassLoader)</strong></h4><ul><li><strong>作用</strong>：它负责加载我们自己编写的 Java 程序中的类，也就是你项目中 <code>classpath</code> 路径下的所有类。</li><li><strong>实现</strong>：它也是由 Java 语言实现的。</li><li><strong>父加载器</strong>：它的父加载器是<strong>扩展类加载器</strong>。</li></ul><hr><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h3><p>除了上面三个，你也可以根据自己的需求创建<strong>自定义类加载器</strong>。</p><ul><li><strong>作用</strong>：当你需要加载一些特定来源的类时（比如从网络下载的类、对字节码进行加密或解密），自定义类加载器就很有用。例如，Web 服务器（如 Tomcat）就是通过自定义类加载器来隔离不同 Web 应用的类。</li><li><strong>如何实现</strong>：通常，你需要继承 <code>java.lang.ClassLoader</code> 类，并重写 <code>findClass()</code> 方法。在 <code>findClass()</code> 方法中，你需要自己定义如何获取类的字节码（比如从文件系统、网络或数据库），然后调用 <code>defineClass()</code> 方法将字节码转换为 <code>Class</code> 对象。</li></ul></li></ul></li></ul><h3 id="33-有哪些类加载器？分别有什么作用？"><a href="#33-有哪些类加载器？分别有什么作用？" class="headerlink" title="33. 有哪些类加载器？分别有什么作用？"></a>33. 有哪些类加载器？分别有什么作用？</h3><ol><li><strong>启动类加载器 (Bootstrap ClassLoader)</strong>：这个类加载器是由 C++ 语言实现的，是虚拟机自身的一部分。负责将存在 <code>\lib</code> 目录中的，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中的类库加载到虚拟机内存中。启动内加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 <code>null</code> 即可；</li><li><strong>其他类加载器</strong>：由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。如扩展类加载器和应用程序类加载器：<ul><li><strong>扩展类加载器 (Extension ClassLoader)</strong>：这个类加载器由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现，它负责加载<code>\lib\ext</code>目录中的，或者被 <code>java.ext.dirs</code> 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li><li><strong>应用程序类加载器 (Application ClassLoader)</strong>：这个类加载器由 <code>sun.misc.Launcher$AppClassLoder</code> 实现。由于个类加载器是 <code>ClassLoader</code> 中的 <code>getSystemClassLoader()</code> 方法的返回值，所以一般也称之为系统类加载器。它负责加载用户路径（ClassPath）所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li></ol><ul><li><p><strong>双亲委派模型 (Parents Delegation Model)</strong>:  </p><ul><li><strong>原理</strong>: 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。  </li><li><strong>优点</strong>: 避免类的重复加载，保证 Java 核心库的类型安全。</li></ul></li></ul><h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><p>为什么需要四个类加载器，而不是一个？</p><p>这是一个很好的问题。为什么 Java 要设计多个类加载器，而不是用一个大一统的加载器呢？这背后主要有三个核心原因：<strong>隔离性</strong>、<strong>安全性</strong>和<strong>可扩展性</strong>。</p><hr><h3 id="1-隔离性（Isolation）"><a href="#1-隔离性（Isolation）" class="headerlink" title="1. 隔离性（Isolation）"></a>1. 隔离性（Isolation）</h3><p>多类加载器的最大优势就是实现了<strong>类隔离</strong>。</p><p>想象一下，你有一个 Web 服务器，上面部署了两个不同的 Web 应用（比如一个博客系统和一个论坛）。这两个应用可能依赖同一个第三方库的不同版本（例如，博客用的是 Spring 框架的 5.x 版本，而论坛用的是 4.x 版本）。</p><p>如果只有一个类加载器，它会把所有 <code>classpath</code> 上的类都加载到同一个内存空间。这样一来，两个不同版本的 Spring 框架就会产生冲突，JVM 根本无法区分它们，程序就会报错。</p><p>而有了自定义类加载器，服务器就可以为每个 Web 应用创建一个独立的类加载器。每个加载器负责加载自己应用目录下的类，这样两个应用即使使用了同一个库的不同版本，也能在内存中和谐共存，互不干扰。</p><hr><h3 id="2-安全性（Security）"><a href="#2-安全性（Security）" class="headerlink" title="2. 安全性（Security）"></a>2. 安全性（Security）</h3><p>Java 的核心库（如 <code>java.lang</code>, <code>java.util</code> 等）对 JVM 的稳定和安全至关重要。</p><p><strong>双亲委派模型</strong>正是为了保护这些核心库不被恶意代码或普通用户代码所篡改。</p><p>例如，如果你尝试自己写一个 <code>java.lang.String</code> 类并把它放在应用的 <code>classpath</code> 下，双亲委派机制会确保这个类不会被加载。因为当加载请求到达应用程序类加载器时，它会先委派给它的父加载器——扩展类加载器，然后再委派给最顶层的<strong>启动类加载器</strong>。启动类加载器会优先加载 JDK 自带的 <code>java.lang.String</code>，从而你的恶意代码就永远没有机会被执行。</p><hr><h3 id="3-可扩展性（Extensibility）"><a href="#3-可扩展性（Extensibility）" class="headerlink" title="3. 可扩展性（Extensibility）"></a>3. 可扩展性（Extensibility）</h3><p>Java 是一种非常灵活的语言，需要适应各种复杂的运行时环境。</p><p>如果只有一个类加载器，所有的类都必须来自文件系统。但在现实世界中，类可能来自各种地方：</p><ul><li>从网络上下载的字节码。</li><li>通过数据库存储和加载。</li><li>对字节码进行加密和解密。</li></ul><p>自定义类加载器让 Java 能够<strong>动态地加载</strong>和<strong>处理非标准来源的类</strong>。例如，热部署技术（在不重启应用的情况下更新代码）就是通过自定义类加载器实现的。它会创建一个新的加载器来加载新版本的类，而旧的加载器和它的类则可以被垃圾回收。</p><hr><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>所以，一个大一统的类加载器虽然简单，但它无法解决复杂的<strong>类版本冲突</strong>、<strong>核心库安全</strong>和<strong>动态加载</strong>等问题。通过分层设计和双亲委派模型，Java 的类加载器体系变得既安全又灵活，能够满足从简单的桌面应用到复杂的企业级服务器等各种场景的需求。</p><h2 id="常见的-OOM-OutOfMemoryError-和-StackOverflowError"><a href="#常见的-OOM-OutOfMemoryError-和-StackOverflowError" class="headerlink" title="常见的 OOM (OutOfMemoryError) 和 StackOverflowError"></a>常见的 OOM (OutOfMemoryError) 和 StackOverflowError</h2><ul><li><strong>Java heap space</strong>: 堆内存不足，最常见。通常通过调整 JVM 启动参数 <code>-Xms</code> (初始堆大小) 和 <code>-Xmx</code> (最大堆大小) 来解决。  </li><li><strong>StackOverflowError</strong>: 虚拟机栈溢出。通常是递归调用过深导致栈帧不断入栈。  </li><li><strong>PermGen space &#x2F; Metaspace</strong>: 方法区溢出。通常是加载的类过多，或者存在大量字符串常量。通过 <code>-XX:MaxPermSize</code> (JDK 1.7) 或 <code>-XX:MaxMetaspaceSize</code> (JDK 1.8) 调整。  </li><li><strong>Direct buffer memory</strong>: 直接内存溢出。通常是使用了 NIO 或 Netty 等直接操作堆外内存的库。  </li><li><strong>unable to create new native thread</strong>: 无法创建新线程。通常是系统线程数达到上限或内存不足以分配新线程的栈空间。</li></ul><h2 id="OOM常见场景："><a href="#OOM常见场景：" class="headerlink" title="OOM常见场景："></a>OOM常见场景：</h2><hr><h3 id="1-java-lang-OutOfMemoryError-Java-heap-space"><a href="#1-java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="1. java.lang.OutOfMemoryError: Java heap space"></a><strong>1. java.lang.OutOfMemoryError: Java heap space</strong></h3><p>这是最常见、也最广为人知的内存溢出错误。它表示 <strong>Java 堆（Heap）</strong> 中没有足够的空间来分配新的对象。</p><p><strong>常见场景：</strong></p><ul><li><strong>内存泄漏（Memory Leak）</strong>：这是最主要的原因。你的程序中创建了对象，但本应被垃圾回收器（GC）回收的对象却因为某些原因（比如被一个长生命周期的对象引用着）而无法被回收。例如：<ul><li>一个静态的 <code>Map</code> 或 <code>List</code> 集合，不断地往里面添加对象，但从不删除。</li><li>监听器或回调函数没有正确移除，导致被监听的对象无法被回收。</li><li>数据库连接或文件流没有正确关闭，长时间占用资源。</li></ul></li><li><strong>内存使用不当</strong>：一次性加载大量数据到内存中。例如，从数据库查询数百万条记录，并把它们全部加载到一个 <code>List</code> 中；或者处理一个超大的图片或文件，导致瞬间占用大量内存。</li><li><strong>配置问题</strong>：JVM 的堆内存设置得太小，无法满足程序的正常运行需求。这在部署应用时很常见，可以通过调整 <code>-Xmx</code> 参数来解决。</li></ul><hr><h3 id="2-java-lang-StackOverflowError"><a href="#2-java-lang-StackOverflowError" class="headerlink" title="2. java.lang.StackOverflowError"></a><strong>2. java.lang.StackOverflowError</strong></h3><p>这个错误表示 <strong>虚拟机栈（Stack）</strong> 溢出。每个线程都有一个独立的栈，用于存储方法调用的栈帧。当栈的深度超过了 JVM 允许的最大深度时，就会抛出此错误。</p><p><strong>常见场景：</strong></p><ul><li><p><strong>无限递归（Infinite Recursion）</strong>：这是最典型的场景。一个方法不断地调用自身，且没有正确的退出条件。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursiveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 没有退出条件</span></span><br><span class="line">    recursiveMethod(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子是两个方法互相调用，形成循环：A 调用 B，B 又调用 A。</p></li><li><p><strong>递归调用层级过深</strong>：即使递归有正确的退出条件，如果数据量过大，导致递归调用层级非常深，也可能导致栈溢出。例如，处理一个深度非常大的树形结构。</p></li></ul><hr><h3 id="3-java-lang-OutOfMemoryError-PermGen-space-或-Metaspace"><a href="#3-java-lang-OutOfMemoryError-PermGen-space-或-Metaspace" class="headerlink" title="3. java.lang.OutOfMemoryError: PermGen space 或 Metaspace"></a><strong>3. java.lang.OutOfMemoryError: PermGen space 或 Metaspace</strong></h3><p>这个错误发生在 <strong>方法区</strong> 溢出。方法区用于存储类的元数据信息，如类的结构、字段、方法、常量池等。</p><ul><li><strong>JDK 1.7 及之前</strong>：方法区在堆中，被称为<strong>永久代（PermGen）</strong>。溢出错误为 <code>PermGen space</code>。</li><li><strong>JDK 1.8 及之后</strong>：永久代被移除，方法区改为使用<strong>元空间（Metaspace）</strong>，并且默认使用本地内存。溢出错误为 <code>Metaspace</code>。</li></ul><p><strong>常见场景：</strong></p><ul><li><strong>动态生成大量类</strong>：在运行时生成大量新的类。这在一些使用字节码增强技术的框架（如 CGLib）或动态代理的场景中很常见。</li><li><strong>热部署</strong>：在像 Tomcat 这样的 Web 服务器中进行频繁的热部署操作，如果没有正确清理旧的类加载器，会导致旧的类元数据无法被回收，从而逐渐耗尽方法区内存。</li><li><strong>常量池溢出</strong>：在 JDK 1.7 之前，字符串常量池也在永久代中。如果程序创建了大量不同的字符串（例如在循环中不断生成新的字符串），也可能导致永久代溢出。</li></ul><hr><h3 id="4-java-lang-OutOfMemoryError-Direct-buffer-memory"><a href="#4-java-lang-OutOfMemoryError-Direct-buffer-memory" class="headerlink" title="4. java.lang.OutOfMemoryError: Direct buffer memory"></a><strong>4. java.lang.OutOfMemoryError: Direct buffer memory</strong></h3><p>这个错误与 <strong>直接内存（Direct Memory）</strong> 相关，它不是 Java 堆的一部分，而是通过 <code>ByteBuffer.allocateDirect()</code> 在堆外分配的内存。</p><p><strong>常见场景：</strong></p><ul><li><strong>NIO 和网络编程</strong>：在使用 Java NIO、Netty、或者其他依赖堆外内存的库时，如果频繁地分配直接内存但没有及时释放，就可能导致此错误。</li><li><strong>内存泄漏</strong>：直接内存的回收不像堆内存那样由 GC 自动管理。如果程序中没有调用 <code>ByteBuffer</code> 的 <code>cleaner()</code> 方法，或者在没有关闭资源的情况下直接内存泄漏，就会耗尽系统的直接内存。</li></ul><hr><h3 id="5-java-lang-OutOfMemoryError-unable-to-create-new-native-thread"><a href="#5-java-lang-OutOfMemoryError-unable-to-create-new-native-thread" class="headerlink" title="5. java.lang.OutOfMemoryError: unable to create new native thread"></a><strong>5. java.lang.OutOfMemoryError: unable to create new native thread</strong></h3><p>这个错误通常不是因为 Java 堆内存不足，而是因为<strong>系统资源耗尽</strong>。</p><p><strong>常见场景：</strong></p><ul><li><strong>线程创建过多</strong>：程序中创建了大量的线程，导致系统无法为新的线程分配内存空间。每个线程除了 Java 堆中的栈空间外，还需要分配一些本地内存。</li><li><strong>系统限制</strong>：操作系统对单个进程创建的线程数有限制。如果达到了这个上限，JVM 就会抛出此错误。在 Linux 系统中，你可以通过 <code>ulimit -u</code> 命令查看这个限制。</li><li><strong>内存不足</strong>：系统内存（包括堆外内存）已经所剩无几，JVM 无法为新的线程栈分配足够的内存。</li></ul><h3 id="面试题：-1"><a href="#面试题：-1" class="headerlink" title="面试题："></a>面试题：</h3><h3 id="1-简述-Java-堆内存溢出（Java-heap-space）的原因及解决方案。"><a href="#1-简述-Java-堆内存溢出（Java-heap-space）的原因及解决方案。" class="headerlink" title="1. 简述 Java 堆内存溢出（Java heap space）的原因及解决方案。"></a>1. 简述 Java 堆内存溢出（Java heap space）的原因及解决方案。</h3><p><strong>原因：</strong> 最主要的原因是<strong>内存泄漏</strong>，即 GC 无法回收本应被回收的对象。其他常见原因包括：</p><ul><li><strong>内存使用不当</strong>：一次性加载大量数据到内存中，如从数据库查询海量数据。</li><li><strong>配置不当</strong>：JVM 启动参数 <code>-Xmx</code> 设置过小，无法满足应用需求。</li></ul><p><strong>解决方案：</strong></p><ul><li><strong>分析和定位问题</strong>：使用 <code>jmap</code>、<code>jstat</code>、<code>jstack</code> 等 JDK 自带工具或者 <code>Eclipse MAT</code> 等可视化工具分析内存快照（<code>heap dump</code>），找到占用内存最多的对象，并分析是否存在内存泄漏。</li><li><strong>代码层面优化</strong>：<ul><li>检查并解决内存泄漏问题，比如移除不再需要的静态集合引用。</li><li>优化大批量数据处理逻辑，采用分批、分页处理或流式处理，避免一次性加载所有数据。</li><li>及时释放不再使用的资源，如关闭数据库连接、文件流等。</li></ul></li><li><strong>JVM 参数调整</strong>：如果确认没有内存泄漏，只是应用确实需要更多内存，可以适当增大 <code>-Xmx</code> 和 <code>-Xms</code> 参数。</li></ul><hr><h3 id="2-什么是-StackOverflowError？它和-OOM-有什么区别？"><a href="#2-什么是-StackOverflowError？它和-OOM-有什么区别？" class="headerlink" title="2. 什么是 StackOverflowError？它和 OOM 有什么区别？"></a>2. 什么是 StackOverflowError？它和 OOM 有什么区别？</h3><p><strong>StackOverflowError</strong> 表示<strong>虚拟机栈</strong>溢出，通常是由于<strong>无限递归</strong>或<strong>递归调用层级过深</strong>导致栈帧不断入栈而耗尽了栈空间。</p><p><strong>与 OOM 的区别：</strong></p><ul><li><strong>发生位置不同</strong>：<code>StackOverflowError</code> 发生在<strong>虚拟机栈</strong>，而 <code>OutOfMemoryError</code> 发生在<strong>堆</strong>或<strong>方法区</strong>等其他内存区域。</li><li><strong>原因不同</strong>：<code>StackOverflowError</code> 通常是由于<strong>代码逻辑问题</strong>（如无限递归）导致，与程序处理的数据量大小关系不大（除非递归深度过深）。而 <code>OOM</code> 往往与<strong>程序处理的数据量</strong>、<strong>JVM 内存配置</strong>或<strong>内存泄漏</strong>有关。</li><li><strong>解决方式不同</strong>：解决 <code>StackOverflowError</code> 主要需要<strong>修改代码</strong>，比如增加递归的退出条件或采用非递归（迭代）方式重构。而解决 <code>OOM</code> 则需要<strong>定位内存泄漏</strong>、<strong>优化代码</strong>或<strong>调整 JVM 内存参数</strong>。</li></ul><hr><h3 id="3-JDK-8-中-PermGen-space-溢出错误为什么变成了-Metaspace？"><a href="#3-JDK-8-中-PermGen-space-溢出错误为什么变成了-Metaspace？" class="headerlink" title="3. JDK 8 中 PermGen space 溢出错误为什么变成了 Metaspace？"></a>3. JDK 8 中 PermGen space 溢出错误为什么变成了 Metaspace？</h3><ul><li><strong>JDK 1.7 及之前</strong>：方法区被实现为<strong>永久代（PermGen）</strong>，它属于<strong>堆内存的一部分</strong>。因此，它的空间大小受限于 JVM 堆内存的设置，容易发生 <code>PermGen space</code> 溢出。</li><li><strong>JDK 1.8 及之后</strong>：<strong>永久代被移除</strong>，方法区改为<strong>元空间（Metaspace）</strong>。元空间<strong>不在 JVM 堆中</strong>，而是直接使用<strong>本地内存</strong>（Native Memory）。</li></ul><p><strong>变化的好处：</strong></p><ul><li><strong>减少 OOM 可能性</strong>：元空间使用本地内存，其大小只受限于系统可用内存，默认情况下比永久代大得多，从而降低了因方法区过小而引发 OOM 的风险。</li><li><strong>避免 GC 负担</strong>：永久代需要由 GC 进行垃圾回收，而元空间则通过 <code>class loader</code> 引用来管理，当对应的 <code>class loader</code> 被回收时，其加载的类元数据也会被回收。</li><li><strong>更灵活</strong>：元空间的大小可以通过参数 <code>-XX:MaxMetaspaceSize</code> 来设置上限，如果该参数不设置，元空间会根据需要自动扩容。</li></ul><hr><h3 id="4-除了-Java-堆，还有哪些内存区域可能发生-OOM？如何解决？"><a href="#4-除了-Java-堆，还有哪些内存区域可能发生-OOM？如何解决？" class="headerlink" title="4. 除了 Java 堆，还有哪些内存区域可能发生 OOM？如何解决？"></a>4. 除了 Java 堆，还有哪些内存区域可能发生 OOM？如何解决？</h3><ul><li><strong>直接内存（Direct buffer memory）</strong>：<ul><li><strong>原因</strong>：通常是使用 NIO 或 Netty 等框架时，频繁分配堆外内存但没有及时释放。</li><li><strong>解决</strong>：检查代码中堆外内存的使用，确保在不再需要时通过 <code>Buffer.cleaner()</code> 或资源关闭操作来显式释放内存。</li></ul></li><li><strong>无法创建新线程（unable to create new native thread）</strong>：<ul><li><strong>原因</strong>：<ol><li>程序创建了<strong>过多线程</strong>，耗尽了操作系统对单个进程的线程数限制。</li><li>系统<strong>内存不足</strong>，无法为新线程分配栈空间。</li></ol></li><li><strong>解决</strong>：<ol><li><strong>代码优化</strong>：检查业务逻辑，看是否可以减少线程创建数量，或者使用线程池来复用线程。</li><li><strong>系统配置</strong>：<ul><li>在 Linux 系统中，使用 <code>ulimit -u</code> 增加线程数限制。</li><li>检查系统内存，确保有足够的内存空间。</li></ul></li><li><strong>JVM 参数调整</strong>：如果线程确实需要，可以适当减小线程栈的大小（<code>-Xss</code>）来允许创建更多线程，但需要注意防止 StackOverflowError。</li></ol></li></ul></li></ul><h1 id="Java框架核心知识详解"><a href="#Java框架核心知识详解" class="headerlink" title="Java框架核心知识详解"></a>Java框架核心知识详解</h1><h2 id="一、Spring框架深入解析"><a href="#一、Spring框架深入解析" class="headerlink" title="一、Spring框架深入解析"></a>一、Spring框架深入解析</h2><h3 id="1-1-Spring核心概念与原理"><a href="#1-1-Spring核心概念与原理" class="headerlink" title="1.1 Spring核心概念与原理"></a>1.1 Spring核心概念与原理</h3><p>Spring框架是一个分层的企业级应用开发框架，其核心是控制反转（IoC）和面向切面编程（AOP）。</p><h4 id="IoC容器原理深入分析"><a href="#IoC容器原理深入分析" class="headerlink" title="IoC容器原理深入分析"></a>IoC容器原理深入分析</h4><p><strong>IoC（控制反转）的本质：</strong> 传统开发中，对象的创建和依赖关系由程序代码直接控制，而IoC将这个控制权交给了外部容器。Spring通过依赖注入（DI）来实现IoC。</p><p><strong>IoC容器的实现机制：</strong></p><ol><li><strong>BeanFactory</strong>: 基础容器，提供基本的IoC功能</li><li><strong>ApplicationContext</strong>: 高级容器，继承BeanFactory，提供更多企业级功能</li></ol><p>好的，我们把 <strong>Spring IoC容器的实现机制</strong> 展开讲清楚，从 <strong>BeanFactory</strong> 到 <strong>ApplicationContext</strong> 的层次演进，以及它们在底层是如何运作的。</p><hr><h1 id="IoC-容器实现机制"><a href="#IoC-容器实现机制" class="headerlink" title="IoC 容器实现机制"></a>IoC 容器实现机制</h1><h2 id="1-BeanFactory-——-基础-IoC-容器"><a href="#1-BeanFactory-——-基础-IoC-容器" class="headerlink" title="1. BeanFactory —— 基础 IoC 容器"></a>1. BeanFactory —— 基础 IoC 容器</h2><p><code>BeanFactory</code> 是 Spring IoC 的最底层容器接口，定义了 <strong>获取 Bean 的基本规则</strong>。</p><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><ul><li><strong>懒加载（Lazy loading）</strong><ul><li>只有在调用 <code>getBean()</code> 时，才会去实例化 Bean。</li><li>避免启动时消耗过多资源。</li></ul></li><li><strong>最小依赖</strong><ul><li>只提供 IoC 的基础功能：<ul><li>Bean 的定义（BeanDefinition）管理</li><li>Bean 的生命周期（创建、依赖注入、销毁）</li><li>Bean 的作用域（singleton &#x2F; prototype）</li></ul></li></ul></li><li><strong>轻量级</strong><ul><li>更适合资源受限环境，比如 IoT、移动设备，或 Spring 的底层框架内部。</li></ul></li></ul><h3 id="核心实现机制"><a href="#核心实现机制" class="headerlink" title="核心实现机制"></a>核心实现机制</h3><ol><li><strong>读取 BeanDefinition</strong><ul><li>配置文件(XML)、注解(@Component)、Java Config( @Bean ) → 转换成 <strong>BeanDefinition</strong> 对象。</li><li>BeanDefinition 是 Bean 的抽象描述，包括：<ul><li>Bean 的 class 类型</li><li>是否单例 &#x2F; 原型</li><li>是否懒加载</li><li>构造参数 &#x2F; 依赖属性</li></ul></li></ul></li><li><strong>存储 BeanDefinition</strong><ul><li>存入 <strong>BeanDefinitionRegistry</strong>（通常是 Map 结构）。</li></ul></li><li><strong>按需实例化 Bean</strong><ul><li>调用 <code>getBean(name)</code> → 根据 BeanDefinition 反射创建实例。</li><li>进行依赖注入（构造器注入 &#x2F; setter 注入）。</li></ul></li><li><strong>Bean 生命周期管理</strong><ul><li>初始化前回调（BeanPostProcessor → <code>postProcessBeforeInitialization</code>）</li><li>调用初始化方法（<code>InitializingBean</code> 或 <code>@PostConstruct</code>）</li><li>初始化后回调（BeanPostProcessor → <code>postProcessAfterInitialization</code>）</li><li>销毁前回调（<code>DisposableBean</code> 或 <code>@PreDestroy</code>）</li></ul></li></ol><hr><h2 id="2-ApplicationContext-——-高级-IoC-容器"><a href="#2-ApplicationContext-——-高级-IoC-容器" class="headerlink" title="2. ApplicationContext —— 高级 IoC 容器"></a>2. ApplicationContext —— 高级 IoC 容器</h2><p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口，扩展了很多 <strong>企业级特性</strong>，是我们在项目中最常用的容器。</p><h3 id="核心特性（对比-BeanFactory）"><a href="#核心特性（对比-BeanFactory）" class="headerlink" title="核心特性（对比 BeanFactory）"></a>核心特性（对比 BeanFactory）</h3><ol><li><strong>预实例化（Eager loading）</strong><ul><li>默认在容器启动时，就会实例化所有单例 Bean。</li><li>启动时性能开销更大，但运行时性能更好。</li></ul></li><li><strong>国际化（I18N）支持</strong><ul><li>通过 <code>MessageSource</code> 接口，支持不同语言的消息解析。</li></ul></li><li><strong>事件机制（ApplicationEvent）</strong><ul><li>内置事件发布 &#x2F; 监听机制（观察者模式）。</li><li>开发者可以自定义事件，实现应用内解耦。</li></ul></li><li><strong>资源加载</strong><ul><li>统一的 <code>Resource</code> 抽象，可以加载文件、URL、classpath 下的资源。</li></ul></li><li><strong>与 AOP、事务管理集成</strong><ul><li>自动识别 BeanPostProcessor、BeanFactoryPostProcessor，用于扩展 Bean 生命周期逻辑（例如事务代理、AOP 动态代理）。</li></ul></li><li><strong>Profile 环境支持</strong><ul><li>支持多环境配置（开发、测试、生产），通过 <code>@Profile</code> 注解切换。</li></ul></li></ol><hr><h2 id="3-BeanFactory-vs-ApplicationContext-总结"><a href="#3-BeanFactory-vs-ApplicationContext-总结" class="headerlink" title="3. BeanFactory vs ApplicationContext 总结"></a>3. BeanFactory vs ApplicationContext 总结</h2><table><thead><tr><th>特性</th><th><strong>BeanFactory</strong></th><th><strong>ApplicationContext</strong></th></tr></thead><tbody><tr><td><strong>Bean 加载时机</strong></td><td>懒加载（按需创建）</td><td>预实例化（启动时创建单例 Bean）</td></tr><tr><td><strong>国际化支持</strong></td><td>❌</td><td>✅</td></tr><tr><td><strong>事件机制</strong></td><td>❌</td><td>✅</td></tr><tr><td><strong>AOP &#x2F; 事务</strong></td><td>手动注册 BeanPostProcessor</td><td>自动识别并应用</td></tr><tr><td><strong>资源加载</strong></td><td>基础 API</td><td>更强大的 Resource 抽象</td></tr><tr><td><strong>适用场景</strong></td><td>轻量应用、底层容器</td><td>企业级应用，大部分 Spring 项目</td></tr></tbody></table><hr><h2 id="4-常见-ApplicationContext-实现类"><a href="#4-常见-ApplicationContext-实现类" class="headerlink" title="4. 常见 ApplicationContext 实现类"></a>4. 常见 ApplicationContext 实现类</h2><ul><li><strong>ClassPathXmlApplicationContext</strong><ul><li>从 classpath 下的 XML 加载配置。</li></ul></li><li><strong>FileSystemXmlApplicationContext</strong><ul><li>从文件系统路径下加载 XML 配置。</li></ul></li><li><strong>AnnotationConfigApplicationContext</strong><ul><li>基于注解和 Java Config 的容器。</li></ul></li><li><strong>WebApplicationContext</strong><ul><li>专门为 Web 应用准备的 IoC 容器，整合 ServletContext。</li></ul></li></ul><hr><p>👉 可以这样理解：</p><ul><li><code>BeanFactory</code> 就是 IoC 的“发动机”，提供最基本的动力。</li><li><code>ApplicationContext</code> 就是加了“变速箱、车载娱乐系统、空调、智能导航”的完整汽车，更适合实际企业应用。</li></ul><p><strong>Bean的生命周期详解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例化 → 属性赋值 → 初始化前处理 → 初始化 → 初始化后处理 → 使用 → 销毁前处理 → 销毁</span><br></pre></td></tr></table></figure><p><strong>详细生命周期步骤：</strong></p><ol><li>Bean元数据解析（XML、注解、Java配置）</li><li>调用Bean构造函数实例化</li><li>依赖注入（setter方法、构造函数、字段注入）</li><li>如果实现了BeanNameAware，调用setBeanName()</li><li>如果实现了BeanFactoryAware，调用setBeanFactory()</li><li>如果实现了ApplicationContextAware，调用setApplicationContext()</li><li>如果有BeanPostProcessor，调用postProcessBeforeInitialization()</li><li>如果实现了InitializingBean，调用afterPropertiesSet()</li><li>如果配置了init-method，调用自定义初始化方法</li><li>如果有BeanPostProcessor，调用postProcessAfterInitialization()</li><li>Bean可以被使用</li><li>容器关闭时，如果实现了DisposableBean，调用destroy()</li><li>如果配置了destroy-method，调用自定义销毁方法</li></ol><h4 id="DI的三种注入方式对比"><a href="#DI的三种注入方式对比" class="headerlink" title="DI的三种注入方式对比"></a>DI的三种注入方式对比</h4><ul><li><strong>构造器注入（Constructor Injection）</strong><ul><li><strong>优点</strong>：强制依赖、依赖清晰、不可变性</li><li><strong>缺点</strong>：当依赖项过多时构造函数臃肿</li><li><strong>最佳实践</strong>：官方推荐，特别是当依赖是必需的、不可选的时候</li></ul></li><li><strong>Setter注入（Setter Injection）</strong><ul><li><strong>优点</strong>：可选依赖，灵活性高</li><li><strong>缺点</strong>：对象可能处于不完整状态，无法使用final修饰</li><li><strong>最佳实践</strong>：用于注入可选的依赖项</li></ul></li><li><strong>字段注入（Field Injection）</strong><ul><li><strong>优点</strong>：代码简洁</li><li><strong>缺点</strong>：不推荐使用，隐藏依赖、测试困难、无法使用final修饰</li></ul></li></ul><h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><p>在传统的 Java 应用中，Bean 的生命周期很简单：使用 <code>new</code> 关键字进行实例化，然后 Bean 就能被使用，不再使用时，由 Java 自动进行垃圾回收。</p><p>相比之下，Spring 管理 Bean 的生命周期就复杂多了，正确理解 Bean 的生命周期非常重要，因为 Spring 对 Bean 的管理可扩展性非常强。以下是一个 Bean 的构造过程：</p><ol><li><strong>Spring 启动</strong>：查找并加载需要被 Spring 管理的 Bean，进行 Bean 的实例化。</li><li><strong>属性注入</strong>：对 Bean 的引用和值注入到 Bean 的属性中。</li><li><strong>BeanNameAware 接口</strong>：如果 Bean 实现了 <code>BeanNameAware</code> 接口，Spring 将 Bean 的 Id 传递给 <code>setBeanName()</code> 方法。</li><li><strong>BeanFactoryAware 接口</strong>：如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，Spring 将调用 <code>setBeanFactory()</code> 方法，将 <code>BeanFactory</code> 容器实例传入。</li><li><strong>ApplicationContextAware 接口</strong>：如果 Bean 实现了 <code>ApplicationContextAware</code> 接口，Spring 将调用 Bean 的 <code>setApplicationContext()</code> 方法，将 Bean 所在的应用上下文引用传入。</li><li><strong>BeanPostProcessor (前)</strong>：如果 Bean 实现了 <code>BeanPostProcessor</code> 接口，Spring 将调用它们的 <code>postProcessBeforeInitialization()</code> 方法。</li><li><strong>InitializingBean 接口与 init-method</strong>：<ul><li>如果 Bean 实现了 <code>InitializingBean</code> 接口，Spring 将调用它们的 <code>afterPropertiesSet()</code> 方法。</li><li>如果 Bean 使用 <code>init-method</code> 声明了初始化方法，该方法也会被调用。</li></ul></li><li><strong>BeanPostProcessor (后)</strong>：如果 Bean 实现了 <code>BeanPostProcessor</code> 接口，Spring 将调用它们的 <code>postProcessAfterInitialization()</code> 方法。</li><li><strong>Bean 准备就绪</strong>：此时，Bean 已经准备就绪，可以被应用程序使用。它们将一直驻留在应用上下文中，直到应用上下文被销毁。</li><li><strong>销毁</strong>：<ul><li>如果 Bean 实现了 <code>DisposableBean</code> 接口，Spring 将调用它的 <code>destory()</code> 接口方法。</li><li>如果 Bean 使用 <code>destory-method</code> 声明了销毁方法，该方法也会被调用。</li></ul></li></ol><hr><h3 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h3><ol><li><strong>singleton</strong>：唯一的 Bean 实例，Spring 中的 Bean 默认都是单例的。</li><li><strong>prototype</strong>：每次请求都会创建一个新的 Bean 实例。</li><li><strong>request</strong>：每一次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong>：每一次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP session 内有效。</li><li><strong>global-session</strong>：全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring 5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ol><hr><h3 id="Spring-中的单例-Bean-的线程安全问题"><a href="#Spring-中的单例-Bean-的线程安全问题" class="headerlink" title="Spring 中的单例 Bean 的线程安全问题"></a>Spring 中的单例 Bean 的线程安全问题</h3><p>大多数时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为：当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。常见的有两种解决办法：</p><ol><li>在 Bean 对象中尽量避免定义可变的成员变量（不太现实）。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><hr><h3 id="对-Spring-中的事务的理解"><a href="#对-Spring-中的事务的理解" class="headerlink" title="对 Spring 中的事务的理解"></a>对 Spring 中的事务的理解</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p><strong>事务特性</strong></p><ul><li><strong>原子性</strong>：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。</li><li><strong>一致性</strong>：执行事务前后，数据保持一致。</li><li><strong>隔离性</strong>：并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的。</li><li><strong>持久性</strong>：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><p><strong>Spring 事务管理接口</strong></p><ol><li><code>PlatformTransactionManager</code>：（平台）事务管理器。</li><li><code>TransactionDefinition</code>：事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）。</li><li><code>TransactionStatus</code>：事务运行状态。</li></ol><p>所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。</p><hr><h3 id="Spring-中的事务隔离级别"><a href="#Spring-中的事务隔离级别" class="headerlink" title="Spring 中的事务隔离级别"></a>Spring 中的事务隔离级别</h3><p><code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</p><ul><li><strong>TransactionDefinition.ISOLATION_DEFAULT</strong>：使用后端数据库默认的隔离级别。MySQL 默认采用 <code>REPEATABLE_READ</code> 隔离级别，Oracle 默认采用 <code>READ_COMMITTED</code> 隔离级别。</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</strong>：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED</strong>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ</strong>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE</strong>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><hr><h3 id="Spring-中的事物传播行为"><a href="#Spring-中的事物传播行为" class="headerlink" title="Spring 中的事物传播行为"></a>Spring 中的事物传播行为</h3><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在 <code>TransactionDefinition</code> 定义中包括了如下几个表示传播行为的常量：</p><p><strong>支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRED</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li><strong>TransactionDefinition.PROPAGATION_SUPPORTS</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><strong>TransactionDefinition.PROPAGATION_MANDATORY</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW</strong>：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</strong>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NEVER</strong>：以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_NESTED</strong>：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 <code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</li></ul><hr><h3 id="Spring-常用注入方式"><a href="#Spring-常用注入方式" class="headerlink" title="Spring 常用注入方式"></a>Spring 常用注入方式</h3><ol><li><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</li><li><strong>Setter 方法注入</strong>：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂方法实例化 bean 之后，调用该 bean 的 Setter 方法，即实现了基于 Setter 的依赖注入。</li><li><strong>基于注解的注入</strong>：最好的解决方案是使用构造器参数实现强制依赖，Setter 方法实现可选依赖。</li></ol><hr><h3 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h3><ol><li><strong>工厂设计模式</strong>：Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong>：Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong>：Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong>：Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 <code>Template</code> 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong>：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式</strong>：Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong>：Spring AOP 的增强或通知（Advice）使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。</li></ol><hr><h3 id="ApplicationContext-通常的实现有哪些？"><a href="#ApplicationContext-通常的实现有哪些？" class="headerlink" title="ApplicationContext 通常的实现有哪些？"></a>ApplicationContext 通常的实现有哪些？</h3><ol><li><strong>FileSystemXmlApplicationContext</strong>：此容器从一个 XML 文件中加载 beans 的定义，XML Bean 配置文件&#96;的全路径名必须提供给它的构造函数。</li><li><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个 XML 文件中加载 beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。</li><li><strong>WebXmlApplicationContext</strong>：此容器加载一个 XML 文件，此文件定义了一个 Web 应用的所有 bean。</li></ol><h4 id="AOP原理深入分析"><a href="#AOP原理深入分析" class="headerlink" title="AOP原理深入分析"></a>AOP原理深入分析</h4><p><strong>AOP实现机制：</strong> Spring AOP基于代理模式实现，支持两种代理方式：</p><ol><li><strong>JDK动态代理</strong>: 针对实现了接口的类</li><li><strong>CGLIB代理</strong>: 针对没有实现接口的类</li></ol><p>我们来系统性地讲解一下 <strong>Spring AOP 的实现机制</strong>，包括：</p><ol><li>JDK 动态代理</li><li>CGLIB 动态代理</li><li>静态代理（对比说明）</li></ol><hr><h2 id="🌟-一、Spring-AOP-实现机制概述"><a href="#🌟-一、Spring-AOP-实现机制概述" class="headerlink" title="🌟 一、Spring AOP 实现机制概述"></a>🌟 一、Spring AOP 实现机制概述</h2><p>Spring AOP（面向切面编程）是基于 <strong>代理模式</strong> 实现的，它通过在目标方法执行前后织入逻辑（增强），实现横切关注点（如日志、安全、事务等）的分离。</p><blockquote><p>Spring AOP 仅支持方法级别的代理（即对方法进行增强），不支持字段、构造器等底层字节码增强（这要用 AspectJ）。</p></blockquote><hr><h2 id="🧩-二、Spring-AOP-的两种动态代理方式"><a href="#🧩-二、Spring-AOP-的两种动态代理方式" class="headerlink" title="🧩 二、Spring AOP 的两种动态代理方式"></a>🧩 二、Spring AOP 的两种动态代理方式</h2><h3 id="1️⃣-JDK-动态代理（基于接口）"><a href="#1️⃣-JDK-动态代理（基于接口）" class="headerlink" title="1️⃣ JDK 动态代理（基于接口）"></a>1️⃣ JDK 动态代理（基于接口）</h3><h4 id="✅-原理："><a href="#✅-原理：" class="headerlink" title="✅ 原理："></a>✅ 原理：</h4><ul><li>基于 Java 的 <code>java.lang.reflect.Proxy</code> 类实现。</li><li>必须要有接口，Spring 会为接口生成代理类。</li><li>代理类在运行时实现接口，并将调用委托给 InvocationHandler。</li></ul><h4 id="📦-示例："><a href="#📦-示例：" class="headerlink" title="📦 示例："></a>📦 示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring AOP 为 <code>UserService</code> 创建代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">    userService.getClass().getClassLoader(),</span><br><span class="line">    userService.getClass().getInterfaces(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="🎯-特点："><a href="#🎯-特点：" class="headerlink" title="🎯 特点："></a>🎯 特点：</h4><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>是否依赖接口</td><td>✅ 是</td></tr><tr><td>性能</td><td>较高（比 CGLIB 略快）</td></tr><tr><td>生成的代理类</td><td>实现接口</td></tr></tbody></table><hr><h3 id="2️⃣-CGLIB-动态代理（基于子类）"><a href="#2️⃣-CGLIB-动态代理（基于子类）" class="headerlink" title="2️⃣ CGLIB 动态代理（基于子类）"></a>2️⃣ CGLIB 动态代理（基于子类）</h3><h4 id="✅-原理：-1"><a href="#✅-原理：-1" class="headerlink" title="✅ 原理："></a>✅ 原理：</h4><ul><li>使用 CGLIB 库在运行时 <strong>生成目标类的子类</strong>，并重写其方法来实现增强。</li><li>适用于 <strong>没有接口</strong> 的类，或者想对类本身增强而非接口。</li></ul><h4 id="🧪-示例："><a href="#🧪-示例：" class="headerlink" title="🧪 示例："></a>🧪 示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 通过 CGLIB 生成子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">enhancer.setSuperclass(UserService.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) enhancer.create();</span><br></pre></td></tr></table></figure><h4 id="🎯-特点：-1"><a href="#🎯-特点：-1" class="headerlink" title="🎯 特点："></a>🎯 特点：</h4><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>是否依赖接口</td><td>❌ 否</td></tr><tr><td>是否可代理 final 类&#x2F;方法</td><td>❌ 否（final 无法被继承&#x2F;重写）</td></tr><tr><td>生成的代理类</td><td>子类</td></tr></tbody></table><hr><h2 id="🏗-三、静态代理（对比动态代理）"><a href="#🏗-三、静态代理（对比动态代理）" class="headerlink" title="🏗 三、静态代理（对比动态代理）"></a>🏗 三、静态代理（对比动态代理）</h2><h3 id="✅-原理：-2"><a href="#✅-原理：-2" class="headerlink" title="✅ 原理："></a>✅ 原理：</h3><ul><li>自己写一个代理类，<strong>实现相同接口</strong>，将方法调用委托给目标对象，并在调用前后手动添加增强逻辑。</li></ul><h4 id="🧪-示例：-1"><a href="#🧪-示例：-1" class="headerlink" title="🧪 示例："></a>🧪 示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">        target.addUser();</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🎯-特点：-2"><a href="#🎯-特点：-2" class="headerlink" title="🎯 特点："></a>🎯 特点：</h4><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>是否自动生成</td><td>❌ 需手动编码</td></tr><tr><td>灵活性</td><td>差（每个类都要写一个代理类）</td></tr><tr><td>是否支持 AOP</td><td>❌ 无法动态织入多个切面</td></tr></tbody></table><hr><h2 id="🔚-四、三者对比总结"><a href="#🔚-四、三者对比总结" class="headerlink" title="🔚 四、三者对比总结"></a>🔚 四、三者对比总结</h2><table><thead><tr><th>特性</th><th>静态代理</th><th>JDK 动态代理</th><th>CGLIB 动态代理</th></tr></thead><tbody><tr><td>是否依赖接口</td><td>✅ 是</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>是否自动生成代理类</td><td>❌ 手动编写</td><td>✅ 运行时生成</td><td>✅ 运行时生成</td></tr><tr><td>是否可代理类</td><td>❌ 否（接口为主）</td><td>❌ 否（接口为主）</td><td>✅ 是（类的子类）</td></tr><tr><td>性能</td><td>一般</td><td>较高</td><td>略慢（但可接受）</td></tr><tr><td>是否支持 final 方法</td><td>✅</td><td>✅</td><td>❌ 否</td></tr></tbody></table><hr><h2 id="✅-Spring-如何选择代理方式？"><a href="#✅-Spring-如何选择代理方式？" class="headerlink" title="✅ Spring 如何选择代理方式？"></a>✅ Spring 如何选择代理方式？</h2><ul><li>默认使用 JDK 动态代理（如果目标类实现了接口）。</li><li>如果目标类没有接口，Spring 自动切换为 CGLIB。</li><li>可以强制使用 CGLIB：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br></pre></td></tr></table></figure><h5 id="AOP核心概念："><a href="#AOP核心概念：" class="headerlink" title="AOP核心概念："></a><strong>AOP核心概念：</strong></h5><ul><li><strong>切面（Aspect）</strong>: 横切关注点的模块化</li><li><strong>连接点（Joinpoint）</strong>: 程序执行中的特定点</li><li><strong>切点（Pointcut）</strong>: 连接点的集合</li><li><strong>通知（Advice）</strong>: 切面在特定连接点执行的代码</li><li><strong>目标对象（Target）</strong>: 被代理的对象</li><li><strong>代理对象（Proxy）</strong>: AOP框架创建的对象</li></ul><h5 id="AOP通知类型："><a href="#AOP通知类型：" class="headerlink" title="AOP通知类型："></a>AOP通知类型：</h5><p><strong>1. 前置通知（Before advice）</strong>：在某个连接点（JoinPoint）之前执行的通知，但它不能阻止连接点之前的执行。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:before&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p><p><strong>2. 后置通知（After advice）</strong>：当某个连接点退出时执行的通知，无论是正常返回还是异常退出。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:after&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p><p><strong>3. 返回后通知（After return advice）</strong>：在某个连接点正常完成后执行的通知，不包括抛出异常的情况。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:after-returning&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p><p><strong>4. 环绕通知（Around advice）</strong>：包围一个连接点的通知，类似于 Web 中 Servlet 规范中的 <code>Filter</code> 的 <code>doFilter</code> 方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:around&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p><p><strong>5. 抛出异常后通知（After throwing advice）</strong>：在方法抛出异常退出时执行的通知。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:after-throwing&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p><p><strong>JDK动态代理 vs. CGLIB动态代理</strong></p><ul><li><strong>JDK动态代理</strong>：<ul><li>基于接口实现</li><li>使用Proxy.newProxyInstance()创建代理</li><li>只能代理实现了接口的类</li></ul></li><li><strong>CGLIB动态代理</strong>：<ul><li>基于继承实现</li><li>使用Enhancer类创建代理</li><li>可以代理普通类</li><li>不能代理final类和方法</li></ul></li></ul><h3 id="1-2-Spring核心注解详解"><a href="#1-2-Spring核心注解详解" class="headerlink" title="1.2 Spring核心注解详解"></a>1.2 Spring核心注解详解</h3><h4 id="基础配置注解"><a href="#基础配置注解" class="headerlink" title="基础配置注解"></a>基础配置注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">// 表示这是一个配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span>  <span class="comment">// 组件扫描</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>  <span class="comment">// 启用自动配置</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span>  <span class="comment">// SpringBoot主类注解，包含上述三个</span></span><br><span class="line"><span class="meta">@Import(OtherConfig.class)</span>  <span class="comment">// 导入其他配置类</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span>  <span class="comment">// 加载属性文件</span></span><br></pre></td></tr></table></figure><h4 id="Bean定义注解"><a href="#Bean定义注解" class="headerlink" title="Bean定义注解"></a>Bean定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">// 通用组件</span></span><br><span class="line"><span class="meta">@Service</span>    <span class="comment">// 业务层组件</span></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 数据访问层组件</span></span><br><span class="line"><span class="meta">@Controller</span> <span class="comment">// 控制层组件</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// RESTful控制器，相当于@Controller + @ResponseBody</span></span><br><span class="line"><span class="meta">@Bean</span>       <span class="comment">// 方法级别，定义Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton/prototype/request/session&quot;)</span>  <span class="comment">// Bean作用域</span></span><br><span class="line"><span class="meta">@Lazy</span>       <span class="comment">// 延迟初始化</span></span><br><span class="line"><span class="meta">@Primary</span>    <span class="comment">// 优先注入</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;beanName&quot;)</span>  <span class="comment">// 指定注入的Bean名称</span></span><br></pre></td></tr></table></figure><h4 id="依赖注入注解"><a href="#依赖注入注解" class="headerlink" title="依赖注入注解"></a>依赖注入注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>  <span class="comment">// 自动装配，可用于构造函数、方法、字段</span></span><br><span class="line"><span class="meta">@Resource</span>   <span class="comment">// JSR-250标准，按名称注入</span></span><br><span class="line"><span class="meta">@Inject</span>     <span class="comment">// JSR-330标准</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;property.name&#125;&quot;)</span>  <span class="comment">// 注入配置值</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span>  <span class="comment">// 绑定配置属性</span></span><br></pre></td></tr></table></figure><h4 id="生命周期注解"><a href="#生命周期注解" class="headerlink" title="生命周期注解"></a>生命周期注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span>  <span class="comment">// 初始化方法</span></span><br><span class="line"><span class="meta">@PreDestroy</span>     <span class="comment">// 销毁方法</span></span><br></pre></td></tr></table></figure><h4 id="AOP相关注解"><a href="#AOP相关注解" class="headerlink" title="AOP相关注解"></a>AOP相关注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>         <span class="comment">// 声明切面</span></span><br><span class="line"><span class="meta">@Pointcut</span>       <span class="comment">// 定义切点</span></span><br><span class="line"><span class="meta">@Before</span>         <span class="comment">// 前置通知</span></span><br><span class="line"><span class="meta">@After</span>          <span class="comment">// 后置通知</span></span><br><span class="line"><span class="meta">@AfterReturning</span> <span class="comment">// 返回后通知</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>  <span class="comment">// 异常通知</span></span><br><span class="line"><span class="meta">@Around</span>         <span class="comment">// 环绕通知</span></span><br></pre></td></tr></table></figure><h3 id="1-3-Spring常见使用场景"><a href="#1-3-Spring常见使用场景" class="headerlink" title="1.3 Spring常见使用场景"></a>1.3 Spring常见使用场景</h3><h4 id="场景1：服务层事务管理"><a href="#场景1：服务层事务管理" class="headerlink" title="场景1：服务层事务管理"></a>场景1：服务层事务管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景2：缓存管理"><a href="#场景2：缓存管理" class="headerlink" title="场景2：缓存管理"></a>场景2：缓存管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;products&quot;, key = &quot;#product.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productRepository.save(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-Spring常见面试问题"><a href="#1-4-Spring常见面试问题" class="headerlink" title="1.4 Spring常见面试问题"></a>1.4 Spring常见面试问题</h3><p><strong>Q1: Spring IoC容器的初始化过程是怎样的？</strong></p><p>A: Spring IoC容器初始化分为三个阶段：</p><ol><li><strong>Resource定位</strong>: 定位配置文件</li><li><strong>BeanDefinition载入</strong>: 将配置信息转换为Spring内部数据结构</li><li><strong>BeanDefinition注册</strong>: 将BeanDefinition注册到IoC容器的HashMap中</li></ol><p>具体流程：</p><ul><li>创建ApplicationContext</li><li>加载配置元数据（XML、注解、Java配置）</li><li>解析配置，创建BeanDefinition</li><li>注册BeanDefinition到BeanDefinitionRegistry</li><li>实例化非懒加载的单例Bean</li></ul><p><strong>Q2: Spring中的循环依赖是如何解决的？</strong></p><p>A: Spring通过三级缓存解决循环依赖：</p><ol><li><strong>singletonObjects</strong>: 一级缓存，存放完整的Bean实例</li><li><strong>earlySingletonObjects</strong>: 二级缓存，存放早期的Bean实例</li><li><strong>singletonFactories</strong>: 三级缓存，存放Bean工厂</li></ol><p>解决过程：</p><ul><li>A依赖B，B依赖A</li><li>创建A时，将A的工厂放入三级缓存</li><li>A需要注入B，开始创建B</li><li>B需要注入A，从缓存中获取A的早期实例</li><li>B创建完成，A继续创建完成</li></ul><p><strong>Q3: Spring AOP的实现原理？</strong></p><p>A: Spring AOP基于代理模式实现：</p><ol><li><strong>JDK动态代理</strong>: 目标类实现接口时使用，基于反射机制</li><li><strong>CGLIB代理</strong>: 目标类没有接口时使用，基于字节码技术</li></ol><p>代理创建过程：</p><ul><li>Spring在Bean初始化后，检查是否需要AOP</li><li>如果需要，创建代理对象替换原始Bean</li><li>代理对象拦截方法调用，执行切面逻辑</li></ul><h2 id="二、Spring-Boot深入解析"><a href="#二、Spring-Boot深入解析" class="headerlink" title="二、Spring Boot深入解析"></a>二、Spring Boot深入解析</h2><h3 id="2-1-Spring-Boot核心原理"><a href="#2-1-Spring-Boot核心原理" class="headerlink" title="2.1 Spring Boot核心原理"></a>2.1 Spring Boot核心原理</h3><p><strong>自动配置原理：</strong> Spring Boot通过@EnableAutoConfiguration注解启用自动配置机制。</p><p>核心类分析：</p><ol><li><strong>SpringBootApplication</strong>: 组合注解，包含@Configuration、@EnableAutoConfiguration、@ComponentScan</li><li><strong>AutoConfigurationImportSelector</strong>: 负责导入自动配置类</li><li><strong>spring.factories</strong>: META-INF&#x2F;spring.factories文件定义自动配置类</li></ol><p><strong>自动配置流程：</strong></p><ol><li>SpringBoot启动时扫描所有jar包下的META-INF&#x2F;spring.factories文件</li><li>加载文件中定义的自动配置类</li><li>根据条件注解(@ConditionalOnClass等)判断是否生效</li><li>生效的配置类会创建相应的Bean</li></ol><h3 id="2-2-Spring-Boot启动流程详解"><a href="#2-2-Spring-Boot启动流程详解" class="headerlink" title="2.2 Spring Boot启动流程详解"></a>2.2 Spring Boot启动流程详解</h3><p><strong>SpringApplication.run()方法执行流程：</strong></p><ol><li><strong>准备阶段</strong>：<ul><li>创建SpringApplication实例</li><li>确定应用类型（SERVLET、REACTIVE、NONE）</li><li>加载ApplicationContextInitializer</li><li>加载ApplicationListener</li></ul></li><li><strong>启动阶段</strong>：<ul><li>启动计时器</li><li>配置Headless模式</li><li>获取并启动监听器</li><li>准备环境（Environment）</li><li>打印Banner</li></ul></li><li><strong>容器创建阶段</strong>：<ul><li>创建ApplicationContext</li><li>准备ApplicationContext</li><li>刷新ApplicationContext</li><li>刷新后处理</li></ul></li><li><strong>完成阶段</strong>：<ul><li>停止计时器</li><li>发布启动完成事件</li><li>调用Runners</li></ul></li></ol><h3 id="2-3-Spring-Boot核心注解"><a href="#2-3-Spring-Boot核心注解" class="headerlink" title="2.3 Spring Boot核心注解"></a>2.3 Spring Boot核心注解</h3><h4 id="启动类注解"><a href="#启动类注解" class="headerlink" title="启动类注解"></a>启动类注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 等价于以下三个注解的组合</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span>  <span class="comment">// Spring Boot配置类</span></span><br><span class="line"><span class="meta">@EnableScheduling</span>        <span class="comment">// 启用定时任务</span></span><br><span class="line"><span class="meta">@EnableAsync</span>            <span class="comment">// 启用异步处理</span></span><br><span class="line"><span class="meta">@EnableCaching</span>          <span class="comment">// 启用缓存</span></span><br></pre></td></tr></table></figure><h4 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(DataSource.class)</span>      <span class="comment">// 类路径下存在指定类</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span> <span class="comment">// 容器中不存在指定Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;app.enabled&quot;, havingValue = &quot;true&quot;)</span> <span class="comment">// 属性匹配</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>               <span class="comment">// Web应用环境</span></span><br><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span>            <span class="comment">// 非Web应用环境</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span>                           <span class="comment">// 激活的profile</span></span><br></pre></td></tr></table></figure><h4 id="配置属性注解"><a href="#配置属性注解" class="headerlink" title="配置属性注解"></a>配置属性注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Spring-Boot实际应用场景"><a href="#2-4-Spring-Boot实际应用场景" class="headerlink" title="2.4 Spring Boot实际应用场景"></a>2.4 Spring Boot实际应用场景</h3><h4 id="场景1：微服务架构"><a href="#场景1：微服务架构" class="headerlink" title="场景1：微服务架构"></a>场景1：微服务架构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;order-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/orders/&#123;userId&#125;&quot;)</span></span><br><span class="line">    List&lt;Order&gt; <span class="title function_">getOrdersByUserId</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景2：数据访问层整合"><a href="#场景2：数据访问层整合" class="headerlink" title="场景2：数据访问层整合"></a>场景2：数据访问层整合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource.primary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProperties <span class="title function_">primaryDataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource.secondary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProperties <span class="title function_">secondaryDataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-Spring-Boot面试问题"><a href="#2-5-Spring-Boot面试问题" class="headerlink" title="2.5 Spring Boot面试问题"></a>2.5 Spring Boot面试问题</h3><p><strong>Q1: Spring Boot的启动原理是什么？</strong></p><p>A: Spring Boot启动原理核心在于自动配置：</p><ol><li><strong>@SpringBootApplication</strong>组合了三个注解，其中@EnableAutoConfiguration是关键</li><li><strong>AutoConfigurationImportSelector</strong>会扫描所有引入的jar包，查找其META-INF&#x2F;spring.factories文件中org.springframework.boot.autoconfigure.EnableAutoConfiguration键所对应的配置类全限定名列表</li><li>根据条件注解判断哪些自动配置类生效</li><li>生效的配置类会向容器中注册相应的Bean</li></ol><p><strong>Q2: Spring Boot如何实现自动配置？</strong></p><p>A: 自动配置通过以下机制实现：</p><ol><li><strong>条件注解</strong>: @ConditionalOnClass、@ConditionalOnBean等判断配置是否生效</li><li><strong>配置文件</strong>: spring.factories定义自动配置类列表</li><li><strong>配置属性</strong>: @ConfigurationProperties绑定配置文件中的属性</li><li><strong>默认配置</strong>: 提供合理的默认值，用户可覆盖</li></ol><p><strong>Q3: Spring Boot Starter的工作原理？</strong></p><p>A: Starter是Spring Boot自动配置的载体：</p><ol><li><strong>依赖管理</strong>: 通过Maven&#x2F;Gradle引入相关依赖</li><li><strong>自动配置</strong>: 包含AutoConfiguration类</li><li><strong>属性绑定</strong>: 提供ConfigurationProperties类</li><li><strong>条件装配</strong>: 使用条件注解控制Bean的创建</li></ol><h2 id="三、Spring-MVC深入解析"><a href="#三、Spring-MVC深入解析" class="headerlink" title="三、Spring MVC深入解析"></a>三、Spring MVC深入解析</h2><h3 id="3-1-Spring-MVC核心组件"><a href="#3-1-Spring-MVC核心组件" class="headerlink" title="3.1 Spring MVC核心组件"></a>3.1 Spring MVC核心组件</h3><p><strong>DispatcherServlet处理流程：</strong></p><ol><li><strong>接收请求</strong>: DispatcherServlet接收HTTP请求</li><li><strong>查找Handler</strong>: HandlerMapping查找处理请求的Handler</li><li><strong>获取HandlerAdapter</strong>: 获取能够执行Handler的HandlerAdapter</li><li><strong>执行Handler</strong>: HandlerAdapter执行Handler（Controller方法）</li><li><strong>处理结果</strong>: 返回ModelAndView</li><li><strong>视图解析</strong>: ViewResolver解析视图名称</li><li><strong>渲染视图</strong>: View渲染模型数据</li><li><strong>返回响应</strong>: 响应结果返回给客户端</li></ol><p><strong>核心组件详解：</strong></p><ul><li><strong>DispatcherServlet</strong>: 前端控制器，统一处理请求</li><li><strong>HandlerMapping</strong>: 处理器映射器，URL与Handler的映射</li><li><strong>HandlerAdapter</strong>: 处理器适配器，执行Handler</li><li><strong>Handler</strong>: 处理器，即Controller</li><li><strong>ViewResolver</strong>: 视图解析器</li><li><strong>View</strong>: 视图</li></ul><h3 id="3-2-Spring-MVC核心注解"><a href="#3-2-Spring-MVC核心注解" class="headerlink" title="3.2 Spring MVC核心注解"></a>3.2 Spring MVC核心注解</h3><h4 id="控制器注解"><a href="#控制器注解" class="headerlink" title="控制器注解"></a>控制器注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>             <span class="comment">// 标记控制器类</span></span><br><span class="line"><span class="meta">@RestController</span>        <span class="comment">// RESTful控制器</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span> <span class="comment">// 请求映射</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span>   <span class="comment">// GET请求映射</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span>  <span class="comment">// POST请求映射</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/users/&#123;id&#125;&quot;)</span>    <span class="comment">// PUT请求映射</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;id&#125;&quot;)</span> <span class="comment">// DELETE请求映射</span></span><br><span class="line"><span class="meta">@PatchMapping(&quot;/users/&#123;id&#125;&quot;)</span>  <span class="comment">// PATCH请求映射</span></span><br></pre></td></tr></table></figure><h4 id="参数绑定注解"><a href="#参数绑定注解" class="headerlink" title="参数绑定注解"></a>参数绑定注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam(&quot;name&quot;)</span>           <span class="comment">// 请求参数</span></span><br><span class="line"><span class="meta">@PathVariable(&quot;id&quot;)</span>            <span class="comment">// 路径变量</span></span><br><span class="line"><span class="meta">@RequestBody</span>                   <span class="comment">// 请求体</span></span><br><span class="line"><span class="meta">@RequestHeader(&quot;Content-Type&quot;)</span> <span class="comment">// 请求头</span></span><br><span class="line"><span class="meta">@CookieValue(&quot;sessionId&quot;)</span>      <span class="comment">// Cookie值</span></span><br><span class="line"><span class="meta">@ModelAttribute</span>               <span class="comment">// 模型属性</span></span><br><span class="line"><span class="meta">@SessionAttribute</span>            <span class="comment">// Session属性</span></span><br><span class="line"><span class="meta">@RequestPart</span>                 <span class="comment">// 文件上传</span></span><br></pre></td></tr></table></figure><h4 id="响应处理注解"><a href="#响应处理注解" class="headerlink" title="响应处理注解"></a>响应处理注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>              <span class="comment">// 响应体</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.CREATED)</span> <span class="comment">// 响应状态码</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>         <span class="comment">// 异常处理</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>        <span class="comment">// 全局控制器增强</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span>    <span class="comment">// RESTful全局异常处理</span></span><br></pre></td></tr></table></figure><h3 id="3-3-Spring-MVC实际应用场景"><a href="#3-3-Spring-MVC实际应用场景" class="headerlink" title="3.3 Spring MVC实际应用场景"></a>3.3 Spring MVC实际应用场景</h3><h4 id="场景1：RESTful-API开发"><a href="#场景1：RESTful-API开发" class="headerlink" title="场景1：RESTful API开发"></a>场景1：RESTful API开发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;PageResult&lt;User&gt;&gt; <span class="title function_">getUsers</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class="type">int</span> page,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(required = false)</span> String keyword)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        PageResult&lt;User&gt; result = userService.findUsers(page, size, keyword);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserCreateRequest request)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.createUser(request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).body(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">updateUser</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@PathVariable</span> Long id,</span></span><br><span class="line"><span class="params">            <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserUpdateRequest request)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.updateUser(id, request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        userService.deleteUser(id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景2：全局异常处理"><a href="#场景2：全局异常处理" class="headerlink" title="场景2：全局异常处理"></a>场景2：全局异常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(ValidationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleValidationException</span><span class="params">(ValidationException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorResponse.builder()</span><br><span class="line">                .code(<span class="string">&quot;VALIDATION_ERROR&quot;</span>)</span><br><span class="line">                .message(e.getMessage())</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(EntityNotFoundException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleEntityNotFoundException</span><span class="params">(EntityNotFoundException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorResponse.builder()</span><br><span class="line">                .code(<span class="string">&quot;ENTITY_NOT_FOUND&quot;</span>)</span><br><span class="line">                .message(e.getMessage())</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleGenericException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error occurred&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ErrorResponse.builder()</span><br><span class="line">                .code(<span class="string">&quot;INTERNAL_ERROR&quot;</span>)</span><br><span class="line">                .message(<span class="string">&quot;An unexpected error occurred&quot;</span>)</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景3：文件上传处理"><a href="#场景3：文件上传处理" class="headerlink" title="场景3：文件上传处理"></a>场景3：文件上传处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/files&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;FileUploadResponse&gt; <span class="title function_">uploadFile</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile file,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(required = false)</span> String description)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件类型验证</span></span><br><span class="line">        <span class="keyword">if</span> (!isValidFileType(file.getContentType())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidFileTypeException</span>(<span class="string">&quot;Invalid file type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件大小验证</span></span><br><span class="line">        <span class="keyword">if</span> (file.getSize() &gt; MAX_FILE_SIZE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileSizeExceededException</span>(<span class="string">&quot;File size exceeds limit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> fileService.saveFile(file, description);</span><br><span class="line">        </span><br><span class="line">        <span class="type">FileUploadResponse</span> <span class="variable">response</span> <span class="operator">=</span> FileUploadResponse.builder()</span><br><span class="line">                .fileName(fileName)</span><br><span class="line">                .originalName(file.getOriginalFilename())</span><br><span class="line">                .size(file.getSize())</span><br><span class="line">                .contentType(file.getContentType())</span><br><span class="line">                .uploadTime(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-Spring-MVC面试问题"><a href="#3-4-Spring-MVC面试问题" class="headerlink" title="3.4 Spring MVC面试问题"></a>3.4 Spring MVC面试问题</h3><p><strong>Q1: Spring MVC的执行流程是怎样的？</strong></p><p>A: Spring MVC的执行流程如下：</p><ol><li>用户发送请求到DispatcherServlet</li><li>DispatcherServlet调用HandlerMapping查找Handler</li><li>HandlerMapping返回HandlerExecutionChain（包含Handler和拦截器）</li><li>DispatcherServlet调用HandlerAdapter执行Handler</li><li>Handler执行完成后返回ModelAndView</li><li>DispatcherServlet调用ViewResolver解析视图名称</li><li>ViewResolver返回View对象</li><li>DispatcherServlet调用View的render方法渲染视图</li><li>响应结果返回给用户</li></ol><p><strong>Q2: Spring MVC中的拦截器是如何工作的？</strong></p><p>A: 拦截器基于AOP思想，在Handler执行前后进行处理：</p><ol><li><strong>HandlerInterceptor接口</strong>提供三个方法：<ul><li>preHandle(): 前置处理，返回false则中断请求</li><li>postHandle(): 后置处理，Handler执行后调用</li><li>afterCompletion(): 完成处理，视图渲染后调用</li></ul></li><li><strong>执行顺序</strong>：<ul><li>多个拦截器按配置顺序执行preHandle()</li><li>按相反顺序执行postHandle()和afterCompletion()</li></ul></li></ol><p><strong>Q3: @RequestBody和@ResponseBody的工作原理？</strong></p><p>A: 这两个注解基于HttpMessageConverter工作：</p><ol><li><strong>@RequestBody</strong>:<ul><li>使用HttpMessageConverter将HTTP请求体转换为Java对象</li><li>常用的转换器：MappingJackson2HttpMessageConverter处理JSON</li></ul></li><li><strong>@ResponseBody</strong>:<ul><li>使用HttpMessageConverter将Java对象转换为HTTP响应体</li><li>根据Accept头选择合适的转换器</li></ul></li></ol><h2 id="四、MyBatis深入解析"><a href="#四、MyBatis深入解析" class="headerlink" title="四、MyBatis深入解析"></a>四、MyBatis深入解析</h2><h3 id="4-1-MyBatis核心原理"><a href="#4-1-MyBatis核心原理" class="headerlink" title="4.1 MyBatis核心原理"></a>4.1 MyBatis核心原理</h3><p><strong>MyBatis架构分析：</strong> MyBatis采用分层架构设计：</p><ol><li><strong>API接口层</strong>: 提供给外部使用的接口API</li><li><strong>数据处理层</strong>: 参数映射、SQL解析、结果映射</li><li><strong>基础支撑层</strong>: 连接管理、事务管理、配置加载、缓存处理</li></ol><p><strong>MyBatis核心组件：</strong></p><ul><li><strong>SqlSessionFactory</strong>: 会话工厂，负责创建SqlSession</li><li><strong>SqlSession</strong>: 会话，执行SQL的核心接口</li><li><strong>Executor</strong>: 执行器，实际执行SQL</li><li><strong>StatementHandler</strong>: 语句处理器，处理SQL语句</li><li><strong>ParameterHandler</strong>: 参数处理器，处理SQL参数</li><li><strong>ResultSetHandler</strong>: 结果集处理器，处理查询结果</li><li><strong>MappedStatement</strong>: 映射语句，封装SQL配置信息</li></ul><h3 id="4-2-MyBatis执行流程详解"><a href="#4-2-MyBatis执行流程详解" class="headerlink" title="4.2 MyBatis执行流程详解"></a>4.2 MyBatis执行流程详解</h3><p><strong>SQL执行流程：</strong></p><ol><li><strong>解析配置</strong>: 解析mybatis-config.xml和Mapper XML文件</li><li><strong>创建会话</strong>: 通过SqlSessionFactory创建SqlSession</li><li><strong>获取Mapper</strong>: 通过动态代理创建Mapper接口实例</li><li><strong>执行SQL</strong>: 调用Mapper方法，转换为MappedStatement执行</li><li><strong>参数处理</strong>: ParameterHandler处理输入参数</li><li><strong>执行查询</strong>: StatementHandler执行SQL语句</li><li><strong>结果映射</strong>: ResultSetHandler处理结果集</li><li><strong>返回结果</strong>: 将结果返回给调用方</li></ol><p><strong>动态代理原理：</strong> MyBatis使用JDK动态代理为Mapper接口创建代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperProxy实现InvocationHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据方法签名找到对应的MappedStatement</span></span><br><span class="line">        <span class="comment">// 执行SQL并返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-MyBatis核心注解"><a href="#4-3-MyBatis核心注解" class="headerlink" title="4.3 MyBatis核心注解"></a>4.3 MyBatis核心注解</h3><h4 id="基础映射注解"><a href="#基础映射注解" class="headerlink" title="基础映射注解"></a>基础映射注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">findById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert(&quot;INSERT INTO users(name, email) VALUES(#&#123;name&#125;, #&#123;email&#125;)&quot;)</span></span><br><span class="line"><span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update(&quot;UPDATE users SET name = #&#123;name&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete(&quot;DELETE FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure><h4 id="高级映射注解"><a href="#高级映射注解" class="headerlink" title="高级映射注解"></a>高级映射注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果映射</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;user_id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;user_name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT user_id, user_name, create_time FROM users&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对一映射</span></span><br><span class="line"><span class="meta">@One(select = &quot;findUserById&quot;)</span></span><br><span class="line"><span class="meta">@Result(column = &quot;user_id&quot;, property = &quot;user&quot;)</span></span><br><span class="line">Order <span class="title function_">findOrderById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对多映射</span></span><br><span class="line"><span class="meta">@Many(select = &quot;findOrdersByUserId&quot;)</span></span><br><span class="line"><span class="meta">@Result(column = &quot;id&quot;, property = &quot;orders&quot;)</span></span><br><span class="line">User <span class="title function_">findUserWithOrders</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure><h4 id="动态SQL注解"><a href="#动态SQL注解" class="headerlink" title="动态SQL注解"></a>动态SQL注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;findUsers&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsers</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUsers</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (params.get(<span class="string">&quot;name&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;name LIKE CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (params.get(<span class="string">&quot;email&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;email = #&#123;email&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-MyBatis缓存机制"><a href="#4-4-MyBatis缓存机制" class="headerlink" title="4.4 MyBatis缓存机制"></a>4.4 MyBatis缓存机制</h3><p><strong>一级缓存（默认开启）：</strong></p><ul><li>作用域：SqlSession级别</li><li>生命周期：与SqlSession相同</li><li>存储：HashMap结构，key为CacheKey</li></ul><p><strong>二级缓存（需要配置）：</strong></p><ul><li>作用域：Mapper级别</li><li>生命周期：与应用程序相同</li><li>配置：@CacheNamespace注解或<cache>标签</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace(</span></span><br><span class="line"><span class="meta">    eviction = LRU.class,</span></span><br><span class="line"><span class="meta">    flushInterval = 60000,</span></span><br><span class="line"><span class="meta">    size = 1024,</span></span><br><span class="line"><span class="meta">    readWrite = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">// mapper methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-MyBatis实际应用场景"><a href="#4-5-MyBatis实际应用场景" class="headerlink" title="4.5 MyBatis实际应用场景"></a>4.5 MyBatis实际应用场景</h3><h4 id="场景1：复杂查询场景"><a href="#场景1：复杂查询场景" class="headerlink" title="场景1：复杂查询场景"></a>场景1：复杂查询场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分页查询订单</span></span><br><span class="line">    <span class="meta">@Select(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        SELECT o.*, u.name as user_name, u.email as user_email</span></span><br><span class="line"><span class="meta">        FROM orders o</span></span><br><span class="line"><span class="meta">        LEFT JOIN users u ON o.user_id = u.id</span></span><br><span class="line"><span class="meta">        WHERE o.status = #&#123;status&#125;</span></span><br><span class="line"><span class="meta">        AND o.create_time BETWEEN #&#123;startTime&#125; AND #&#123;endTime&#125;</span></span><br><span class="line"><span class="meta">        ORDER BY o.create_time DESC</span></span><br><span class="line"><span class="meta">        LIMIT #&#123;offset&#125;, #&#123;limit&#125;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;user_id&quot;, property = &quot;userId&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;user_name&quot;, property = &quot;user.name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;user_email&quot;, property = &quot;user.email&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    List&lt;OrderVO&gt; <span class="title function_">findOrdersWithUser</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;status&quot;)</span> String status,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;startTime&quot;)</span> LocalDateTime startTime,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;endTime&quot;)</span> LocalDateTime endTime,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计查询</span></span><br><span class="line">    <span class="meta">@Select(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        SELECT </span></span><br><span class="line"><span class="meta">            COUNT(*) as total_count,</span></span><br><span class="line"><span class="meta">            SUM(amount) as total_amount,</span></span><br><span class="line"><span class="meta">            AVG(amount) as avg_amount</span></span><br><span class="line"><span class="meta">        FROM orders </span></span><br><span class="line"><span class="meta">        WHERE status = #&#123;status&#125;</span></span><br><span class="line"><span class="meta">        AND create_time &gt;= #&#123;startTime&#125;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    OrderStatistics <span class="title function_">getOrderStatistics</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;status&quot;)</span> String status,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;startTime&quot;)</span> LocalDateTime startTime</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景2：批量操作场景"><a href="#场景2：批量操作场景" class="headerlink" title="场景2：批量操作场景"></a>场景2：批量操作场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BatchMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 批量插入</span></span><br><span class="line">    <span class="meta">@Insert(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        &lt;script&gt;</span></span><br><span class="line"><span class="meta">        INSERT INTO users (name, email, create_time) VALUES</span></span><br><span class="line"><span class="meta">        &lt;foreach collection=&quot;users&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="meta">            (#&#123;user.name&#125;, #&#123;user.email&#125;, #&#123;user.createTime&#125;)</span></span><br><span class="line"><span class="meta">        &lt;/foreach&gt;</span></span><br><span class="line"><span class="meta">        &lt;/script&gt;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">batchInsertUsers</span><span class="params">(<span class="meta">@Param(&quot;users&quot;)</span> List&lt;User&gt; users)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 批量更新</span></span><br><span class="line">    <span class="meta">@Update(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        &lt;script&gt;</span></span><br><span class="line"><span class="meta">        &lt;foreach collection=&quot;users&quot; item=&quot;user&quot; separator=&quot;;&quot;&gt;</span></span><br><span class="line"><span class="meta">            UPDATE users SET </span></span><br><span class="line"><span class="meta">                name = #&#123;user.name&#125;,</span></span><br><span class="line"><span class="meta">                email = #&#123;user.email&#125;,</span></span><br><span class="line"><span class="meta">                update_time = NOW()</span></span><br><span class="line"><span class="meta">            WHERE id = #&#123;user.id&#125;</span></span><br><span class="line"><span class="meta">        &lt;/foreach&gt;</span></span><br><span class="line"><span class="meta">        &lt;/script&gt;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">batchUpdateUsers</span><span class="params">(<span class="meta">@Param(&quot;users&quot;)</span> List&lt;User&gt; users)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景3：动态SQL场景"><a href="#场景3：动态SQL场景" class="headerlink" title="场景3：动态SQL场景"></a>场景3：动态SQL场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;searchUsers&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">searchUsers</span><span class="params">(UserSearchCriteria criteria)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">searchUsers</span><span class="params">(UserSearchCriteria criteria)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;u.*, p.name as profile_name&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;users u&quot;</span>);</span><br><span class="line">            LEFT_OUTER_JOIN(<span class="string">&quot;user_profiles p ON u.id = p.user_id&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(criteria.getName())) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.name LIKE CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(criteria.getEmail())) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.email = #&#123;email&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getMinAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.age &gt;= #&#123;minAge&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getMaxAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.age &lt;= #&#123;maxAge&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getCreateTimeStart() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.create_time &gt;= #&#123;createTimeStart&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getCreateTimeEnd() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.create_time &lt;= #&#123;createTimeEnd&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(criteria.getStatuses())) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.status IN (&quot;</span> + </span><br><span class="line">                    criteria.getStatuses().stream()</span><br><span class="line">                        .map(s -&gt; <span class="string">&quot;&#x27;&quot;</span> + s + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">                        .collect(Collectors.joining(<span class="string">&quot;,&quot;</span>)) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 排序</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(criteria.getSortField())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;desc&quot;</span>.equalsIgnoreCase(criteria.getSortDirection())) &#123;</span><br><span class="line">                    ORDER_BY(<span class="string">&quot;u.&quot;</span> + criteria.getSortField() + <span class="string">&quot; DESC&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ORDER_BY(<span class="string">&quot;u.&quot;</span> + criteria.getSortField() + <span class="string">&quot; ASC&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ORDER_BY(<span class="string">&quot;u.create_time DESC&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-MyBatis性能优化"><a href="#4-6-MyBatis性能优化" class="headerlink" title="4.6 MyBatis性能优化"></a>4.6 MyBatis性能优化</h3><h4 id="优化策略1：合理使用缓存"><a href="#优化策略1：合理使用缓存" class="headerlink" title="优化策略1：合理使用缓存"></a>优化策略1：合理使用缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启二级缓存，设置合理的缓存策略</span></span><br><span class="line"><span class="meta">@CacheNamespace(</span></span><br><span class="line"><span class="meta">    eviction = LRU.class,        // 缓存回收策略</span></span><br><span class="line"><span class="meta">    flushInterval = 300000,      // 缓存刷新间隔（5分钟）</span></span><br><span class="line"><span class="meta">    size = 1024,                 // 缓存大小</span></span><br><span class="line"><span class="meta">    readWrite = true,            // 读写缓存</span></span><br><span class="line"><span class="meta">    blocking = false             // 非阻塞缓存</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于频繁查询且变化不大的数据使用缓存</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM products WHERE category_id = #&#123;categoryId&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useCache = true)</span></span><br><span class="line">    List&lt;Product&gt; <span class="title function_">findByCategory</span><span class="params">(<span class="meta">@Param(&quot;categoryId&quot;)</span> Long categoryId)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于实时性要求高的数据禁用缓存</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM products WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useCache = false)</span></span><br><span class="line">    Product <span class="title function_">findRealTimeById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化策略2：批量操作"><a href="#优化策略2：批量操作" class="headerlink" title="优化策略2：批量操作"></a>优化策略2：批量操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用批量插入替代循环插入</span></span><br><span class="line"><span class="meta">@Insert(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    &lt;script&gt;</span></span><br><span class="line"><span class="meta">    INSERT INTO order_items (order_id, product_id, quantity, price) VALUES</span></span><br><span class="line"><span class="meta">    &lt;foreach collection=&quot;items&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="meta">        (#&#123;item.orderId&#125;, #&#123;item.productId&#125;, #&#123;item.quantity&#125;, #&#123;item.price&#125;)</span></span><br><span class="line"><span class="meta">    &lt;/foreach&gt;</span></span><br><span class="line"><span class="meta">    &lt;/script&gt;</span></span><br><span class="line"><span class="meta">&quot;&quot;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">batchInsertOrderItems</span><span class="params">(<span class="meta">@Param(&quot;items&quot;)</span> List&lt;OrderItem&gt; items)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量更新优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdateProducts</span><span class="params">(List&lt;Product&gt; products)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH)) &#123;</span><br><span class="line">        <span class="type">ProductMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ProductMapper.class);</span><br><span class="line">        <span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">            mapper.updateProduct(product);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化策略3：延迟加载"><a href="#优化策略3：延迟加载" class="headerlink" title="优化策略3：延迟加载"></a>优化策略3：延迟加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResultMap(&quot;userResultMap&quot;)</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">findUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在ResultMap中配置延迟加载</span></span><br><span class="line">&lt;resultMap id=<span class="string">&quot;userResultMap&quot;</span> type=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span>/&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;name&quot;</span> property=<span class="string">&quot;name&quot;</span>/&gt;</span><br><span class="line">    &lt;collection property=<span class="string">&quot;orders&quot;</span> </span><br><span class="line">                select=<span class="string">&quot;findOrdersByUserId&quot;</span> </span><br><span class="line">                column=<span class="string">&quot;id&quot;</span> </span><br><span class="line">                fetchType=<span class="string">&quot;lazy&quot;</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><h3 id="4-7-MyBatis常见问题与解决方案"><a href="#4-7-MyBatis常见问题与解决方案" class="headerlink" title="4.7 MyBatis常见问题与解决方案"></a>4.7 MyBatis常见问题与解决方案</h3><h4 id="问题1：N-1查询问题"><a href="#问题1：N-1查询问题" class="headerlink" title="问题1：N+1查询问题"></a>问题1：N+1查询问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题：会产生N+1次查询</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findAllUsers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM orders WHERE user_id = #&#123;userId&#125;&quot;)</span></span><br><span class="line">List&lt;Order&gt; <span class="title function_">findOrdersByUserId</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案1：使用联表查询</span></span><br><span class="line"><span class="meta">@Select(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    SELECT u.*, o.id as order_id, o.amount, o.status as order_status</span></span><br><span class="line"><span class="meta">    FROM users u</span></span><br><span class="line"><span class="meta">    LEFT JOIN orders o ON u.id = o.user_id</span></span><br><span class="line"><span class="meta">&quot;&quot;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;order_id&quot;, property = &quot;orders.id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;amount&quot;, property = &quot;orders.amount&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;order_status&quot;, property = &quot;orders.status&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersWithOrders</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案2：使用批量查询</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUsersWithOrdersOptimized</span><span class="params">(List&lt;Long&gt; userIds)</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.findUsersByIds(userIds);</span><br><span class="line">    <span class="keyword">if</span> (!users.isEmpty()) &#123;</span><br><span class="line">        List&lt;Long&gt; ids = users.stream().map(User::getId).collect(Collectors.toList());</span><br><span class="line">        List&lt;Order&gt; orders = orderMapper.findOrdersByUserIds(ids);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手动组装数据</span></span><br><span class="line">        Map&lt;Long, List&lt;Order&gt;&gt; orderMap = orders.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Order::getUserId));</span><br><span class="line">        </span><br><span class="line">        users.forEach(user -&gt; user.setOrders(orderMap.get(user.getId())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题2：大数据量查询内存溢出"><a href="#问题2：大数据量查询内存溢出" class="headerlink" title="问题2：大数据量查询内存溢出"></a>问题2：大数据量查询内存溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题：一次性加载大量数据导致内存溢出</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM large_table&quot;)</span></span><br><span class="line">List&lt;LargeData&gt; <span class="title function_">findAllData</span><span class="params">()</span>; <span class="comment">// 可能导致OOM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案1：分页查询</span></span><br><span class="line"><span class="keyword">public</span> List&lt;LargeData&gt; <span class="title function_">findAllDataWithPaging</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;LargeData&gt; allData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;LargeData&gt; pageData;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        pageData = mapper.findDataWithLimit(offset, pageSize);</span><br><span class="line">        allData.addAll(pageData);</span><br><span class="line">        offset += pageSize;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pageData.size() == pageSize);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> allData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案2：使用游标查询</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM large_table WHERE process_status = &#x27;PENDING&#x27;&quot;)</span></span><br><span class="line"><span class="meta">@Options(resultSetType = ResultSetType.FORWARD_ONLY, fetchSize = 1000)</span></span><br><span class="line">Cursor&lt;LargeData&gt; <span class="title function_">findPendingDataCursor</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processLargeData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (Cursor&lt;LargeData&gt; cursor = mapper.findPendingDataCursor()) &#123;</span><br><span class="line">        cursor.forEach(<span class="built_in">this</span>::processData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题3：SQL注入防护"><a href="#问题3：SQL注入防护" class="headerlink" title="问题3：SQL注入防护"></a>问题3：SQL注入防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险：直接拼接SQL，容易SQL注入</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = &#x27;$&#123;name&#125;&#x27;&quot;)</span> <span class="comment">// 错误示例</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByNameUnsafe</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全：使用参数绑定</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = #&#123;name&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByNameSafe</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态排序的安全处理</span></span><br><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;findUsersWithSort&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersWithSort</span><span class="params">(<span class="meta">@Param(&quot;sortField&quot;)</span> String sortField, </span></span><br><span class="line"><span class="params">                            <span class="meta">@Param(&quot;sortDirection&quot;)</span> String sortDirection)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; ALLOWED_SORT_FIELDS = </span><br><span class="line">        Set.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;create_time&quot;</span>, <span class="string">&quot;update_time&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUsersWithSort</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sortField</span> <span class="operator">=</span> (String) params.get(<span class="string">&quot;sortField&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sortDirection</span> <span class="operator">=</span> (String) params.get(<span class="string">&quot;sortDirection&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 白名单验证</span></span><br><span class="line">        <span class="keyword">if</span> (!ALLOWED_SORT_FIELDS.contains(sortField)) &#123;</span><br><span class="line">            sortField = <span class="string">&quot;id&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;DESC&quot;</span>.equalsIgnoreCase(sortDirection)) &#123;</span><br><span class="line">            sortDirection = <span class="string">&quot;ASC&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SELECT * FROM users ORDER BY &quot;</span> + sortField + <span class="string">&quot; &quot;</span> + sortDirection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-MyBatis面试高频问题"><a href="#4-8-MyBatis面试高频问题" class="headerlink" title="4.8 MyBatis面试高频问题"></a>4.8 MyBatis面试高频问题</h3><p><strong>Q1: MyBatis的执行流程是怎样的？</strong></p><p>A: MyBatis的执行流程包括以下步骤：</p><ol><li><strong>配置解析</strong>: 解析mybatis-config.xml配置文件和Mapper XML文件，创建Configuration对象</li><li><strong>SqlSessionFactory创建</strong>: 根据Configuration创建SqlSessionFactory</li><li><strong>SqlSession创建</strong>: 通过SqlSessionFactory.openSession()创建SqlSession</li><li><strong>Mapper获取</strong>: 通过SqlSession.getMapper()获取Mapper接口的代理对象</li><li><strong>方法调用</strong>: 调用Mapper接口方法，通过动态代理转换为SQL执行</li><li><strong>SQL执行</strong>: 通过Executor执行SQL，包括参数处理、语句执行、结果映射</li><li><strong>结果返回</strong>: 将执行结果返回给调用方</li></ol><p><strong>Q2: MyBatis的一级缓存和二级缓存有什么区别？</strong></p><p>A: 两级缓存的主要区别：</p><p><strong>一级缓存（默认开启）：</strong></p><ul><li>作用域：SqlSession级别</li><li>生命周期：与SqlSession相同，SqlSession关闭时缓存清空</li><li>存储结构：HashMap，key为CacheKey（由SQL、参数、分页等组成）</li><li>失效条件：执行update、insert、delete操作或手动清空</li></ul><p><strong>二级缓存（需要配置）：</strong></p><ul><li>作用域：Mapper级别，多个SqlSession可以共享</li><li>生命周期：与应用程序相同</li><li>存储结构：可配置（HashMap、LRU、FIFO等）</li><li>配置方式：@CacheNamespace注解或<cache>标签</li><li>注意事项：需要序列化，可能存在脏读问题</li></ul><p><strong>Q3: MyBatis如何防止SQL注入？</strong></p><p>A: MyBatis通过以下方式防止SQL注入：</p><ol><li><strong>参数绑定</strong>: 使用#{}而不是${}<ul><li>#{}：预编译处理，参数作为占位符传递</li><li>${}：字符串替换，直接拼接到SQL中（危险）</li></ul></li><li><strong>类型检查</strong>: MyBatis会对参数类型进行检查</li><li><strong>白名单验证</strong>: 对于动态排序等场景，使用白名单验证</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全的写法</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = #&#123;name&#125; AND age &gt; #&#123;age&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsers</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险的写法（避免使用）</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = &#x27;$&#123;name&#125;&#x27;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersUnsafe</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br></pre></td></tr></table></figure><p><strong>Q4: MyBatis中#{}和${}的区别？</strong></p><p>A: 两者的主要区别：</p><p><strong>#{}（推荐使用）：</strong></p><ul><li>预编译处理，生成PreparedStatement</li><li>参数会被处理为占位符?</li><li>可以防止SQL注入</li><li>会进行类型转换</li><li>适用于参数值传递</li></ul><p><strong>${}（谨慎使用）：</strong></p><ul><li>字符串替换，直接拼接到SQL中</li><li>不会进行预编译</li><li>存在SQL注入风险</li><li>不会进行类型转换</li><li>适用于动态表名、列名等场景</li></ul><p><strong>Q5: MyBatis的动态SQL是如何实现的？</strong></p><p>A: MyBatis的动态SQL通过以下标签实现：</p><ol><li><strong>if标签</strong>: 条件判断</li><li><strong>choose&#x2F;when&#x2F;otherwise</strong>: 类似switch-case</li><li><strong>where标签</strong>: 智能处理WHERE条件</li><li><strong>set标签</strong>: 智能处理SET语句</li><li><strong>foreach标签</strong>: 循环处理</li><li><strong>trim标签</strong>: 去除多余的字符</li></ol><p>实现原理：</p><ul><li>使用OGNL表达式进行条件判断</li><li>在SQL解析阶段根据参数值动态生成SQL</li><li>通过SqlNode树结构表示动态SQL</li><li>在执行时遍历SqlNode树生成最终SQL</li></ul><h2 id="五、框架整合与最佳实践"><a href="#五、框架整合与最佳实践" class="headerlink" title="五、框架整合与最佳实践"></a>五、框架整合与最佳实践</h2><h3 id="5-1-Spring-Boot-MyBatis整合"><a href="#5-1-Spring-Boot-MyBatis整合" class="headerlink" title="5.1 Spring Boot + MyBatis整合"></a>5.1 Spring Boot + MyBatis整合</h3><h4 id="完整配置示例"><a href="#完整配置示例" class="headerlink" title="完整配置示例"></a>完整配置示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主启动类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据源配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource.primary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProperties <span class="title function_">primaryDataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">primaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> primaryDataSourceProperties()</span><br><span class="line">                .initializeDataSourceBuilder()</span><br><span class="line">                .type(HikariDataSource.class)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        factory.setDataSource(dataSource);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// MyBatis配置</span></span><br><span class="line">        org.apache.ibatis.session.<span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">org</span>.apache.ibatis.session.Configuration();</span><br><span class="line">        config.setMapUnderscoreToCamelCase(<span class="literal">true</span>);</span><br><span class="line">        config.setLogImpl(Slf4jImpl.class);</span><br><span class="line">        config.setCacheEnabled(<span class="literal">true</span>);</span><br><span class="line">        config.setLazyLoadingEnabled(<span class="literal">true</span>);</span><br><span class="line">        config.setAggressiveLazyLoading(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        factory.setConfiguration(config);</span><br><span class="line">        <span class="keyword">return</span> factory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务管理配置"><a href="#事务管理配置" class="headerlink" title="事务管理配置"></a>事务管理配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderItemMapper orderItemMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductMapper productMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">createOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setUserId(request.getUserId());</span><br><span class="line">        order.setStatus(<span class="string">&quot;PENDING&quot;</span>);</span><br><span class="line">        order.setCreateTime(LocalDateTime.now());</span><br><span class="line">        orderMapper.insert(order);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建订单项</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">totalAmount</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">        List&lt;OrderItem&gt; orderItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (CreateOrderItemRequest itemRequest : request.getItems()) &#123;</span><br><span class="line">            <span class="comment">// 检查库存</span></span><br><span class="line">            <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productMapper.findById(itemRequest.getProductId());</span><br><span class="line">            <span class="keyword">if</span> (product == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ProductNotFoundException</span>(<span class="string">&quot;Product not found: &quot;</span> + itemRequest.getProductId());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (product.getStock() &lt; itemRequest.getQuantity()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientStockException</span>(<span class="string">&quot;Insufficient stock for product: &quot;</span> + product.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 减库存</span></span><br><span class="line">            productMapper.decreaseStock(itemRequest.getProductId(), itemRequest.getQuantity());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建订单项</span></span><br><span class="line">            <span class="type">OrderItem</span> <span class="variable">orderItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderItem</span>();</span><br><span class="line">            orderItem.setOrderId(order.getId());</span><br><span class="line">            orderItem.setProductId(itemRequest.getProductId());</span><br><span class="line">            orderItem.setQuantity(itemRequest.getQuantity());</span><br><span class="line">            orderItem.setPrice(product.getPrice());</span><br><span class="line">            orderItems.add(orderItem);</span><br><span class="line">            </span><br><span class="line">            totalAmount = totalAmount.add(</span><br><span class="line">                product.getPrice().multiply(BigDecimal.valueOf(itemRequest.getQuantity()))</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 批量插入订单项</span></span><br><span class="line">        <span class="keyword">if</span> (!orderItems.isEmpty()) &#123;</span><br><span class="line">            orderItemMapper.batchInsert(orderItems);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 更新订单总金额</span></span><br><span class="line">        order.setTotalAmount(totalAmount);</span><br><span class="line">        orderMapper.updateAmount(order.getId(), totalAmount);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> OrderDetailVO <span class="title function_">getOrderDetail</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">        <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderNotFoundException</span>(<span class="string">&quot;Order not found: &quot;</span> + orderId);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;OrderItem&gt; orderItems = orderItemMapper.findByOrderId(orderId);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> OrderDetailVO.builder()</span><br><span class="line">                .order(order)</span><br><span class="line">                .items(orderItems)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-统一异常处理"><a href="#5-2-统一异常处理" class="headerlink" title="5.2 统一异常处理"></a>5.2 统一异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(ValidationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleValidationException</span><span class="params">(ValidationException e)</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Validation error: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;VALIDATION_ERROR&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleMethodArgumentNotValid</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        List&lt;String&gt; errors = e.getBindingResult()</span><br><span class="line">                .getFieldErrors()</span><br><span class="line">                .stream()</span><br><span class="line">                .map(error -&gt; error.getField() + <span class="string">&quot;: &quot;</span> + error.getDefaultMessage())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;VALIDATION_ERROR&quot;</span>, String.join(<span class="string">&quot;, &quot;</span>, errors));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(DataIntegrityViolationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CONFLICT)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleDataIntegrityViolation</span><span class="params">(DataIntegrityViolationException e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Data integrity violation&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;DATA_CONFLICT&quot;</span>, <span class="string">&quot;Data conflict occurred&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(OptimisticLockingFailureException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CONFLICT)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleOptimisticLockingFailure</span><span class="params">(OptimisticLockingFailureException e)</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Optimistic locking failure: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;OPTIMISTIC_LOCK_ERROR&quot;</span>, <span class="string">&quot;Resource has been modified by another user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleGenericException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error occurred&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;INTERNAL_ERROR&quot;</span>, <span class="string">&quot;An unexpected error occurred&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-接口文档与验证"><a href="#5-3-接口文档与验证" class="headerlink" title="5.3 接口文档与验证"></a>5.3 接口文档与验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统一响应格式</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiResponse</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> success;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Long timestamp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResponse&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.&lt;T&gt;builder()</span><br><span class="line">                .success(<span class="literal">true</span>)</span><br><span class="line">                .code(<span class="string">&quot;SUCCESS&quot;</span>)</span><br><span class="line">                .data(data)</span><br><span class="line">                .timestamp(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResponse&lt;T&gt; <span class="title function_">error</span><span class="params">(String code, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.&lt;T&gt;builder()</span><br><span class="line">                .success(<span class="literal">false</span>)</span><br><span class="line">                .code(code)</span><br><span class="line">                .message(message)</span><br><span class="line">                .timestamp(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求参数验证</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Valid</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateUserRequest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 2, max = 20, message = &quot;用户名长度必须在2-20个字符之间&quot;)</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^[a-zA-Z0-9_\\u4e00-\\u9fa5]+$&quot;, message = &quot;用户名只能包含字母、数字、下划线和中文&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;邮箱不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 8, max = 20, message = &quot;密码长度必须在8-20个字符之间&quot;)</span></span><br><span class="line">    <span class="meta">@Pattern(</span></span><br><span class="line"><span class="meta">        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]+$&quot;,</span></span><br><span class="line"><span class="meta">        message = &quot;密码必须包含大小写字母、数字和特殊字符&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull(message = &quot;年龄不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 1, message = &quot;年龄必须大于0&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 150, message = &quot;年龄不能超过150&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;角色不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="meta">@NotBlank(message = &quot;角色名称不能为空&quot;)</span> String&gt; roles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-性能监控与优化"><a href="#5-4-性能监控与优化" class="headerlink" title="5.4 性能监控与优化"></a>5.4 性能监控与优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能监控切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerformanceMonitorAspect</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(org.springframework.web.bind.annotation.RequestMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.GetMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.PostMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.PutMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.DeleteMapping)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">monitorPerformance</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().toShortString();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">long</span> <span class="variable">executionTime</span> <span class="operator">=</span> endTime - startTime;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (executionTime &gt; <span class="number">1000</span>) &#123; <span class="comment">// 超过1秒记录警告</span></span><br><span class="line">                log.warn(<span class="string">&quot;Slow API detected: &#123;&#125; took &#123;&#125;ms&quot;</span>, methodName, executionTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;API performance: &#123;&#125; took &#123;&#125;ms&quot;</span>, methodName, executionTime);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            log.error(<span class="string">&quot;API error: &#123;&#125; took &#123;&#125;ms, error: &#123;&#125;&quot;</span>, </span><br><span class="line">                     methodName, endTime - startTime, e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库连接池监控</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceHealthIndicator</span> <span class="keyword">implements</span> <span class="title class_">HealthIndicator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Health <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> HikariDataSource) &#123;</span><br><span class="line">                <span class="type">HikariDataSource</span> <span class="variable">hikariDataSource</span> <span class="operator">=</span> (HikariDataSource) dataSource;</span><br><span class="line">                <span class="type">HikariPoolMXBean</span> <span class="variable">poolBean</span> <span class="operator">=</span> hikariDataSource.getHikariPoolMXBean();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> Health.up()</span><br><span class="line">                        .withDetail(<span class="string">&quot;database&quot;</span>, <span class="string">&quot;MySQL&quot;</span>)</span><br><span class="line">                        .withDetail(<span class="string">&quot;activeConnections&quot;</span>, poolBean.getActiveConnections())</span><br><span class="line">                        .withDetail(<span class="string">&quot;idleConnections&quot;</span>, poolBean.getIdleConnections())</span><br><span class="line">                        .withDetail(<span class="string">&quot;totalConnections&quot;</span>, poolBean.getTotalConnections())</span><br><span class="line">                        .withDetail(<span class="string">&quot;threadsAwaitingConnection&quot;</span>, poolBean.getThreadsAwaitingConnection())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection()) &#123;</span><br><span class="line">                <span class="keyword">return</span> Health.up()</span><br><span class="line">                        .withDetail(<span class="string">&quot;database&quot;</span>, connection.getMetaData().getDatabaseProductName())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down()</span><br><span class="line">                    .withDetail(<span class="string">&quot;error&quot;</span>, e.getMessage())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-高频面试综合题"><a href="#5-5-高频面试综合题" class="headerlink" title="5.5 高频面试综合题"></a>5.5 高频面试综合题</h3><p><strong>Q1: 在微服务架构中，如何设计一个高并发的订单系统？</strong></p><p>A: 设计高并发订单系统需要考虑以下几个方面：</p><p><strong>1. 架构设计：</strong></p><ul><li>使用分布式架构，订单服务、库存服务、支付服务分离</li><li>引入消息队列处理异步任务</li><li>使用Redis做缓存和分布式锁</li><li>数据库读写分离，分库分表</li></ul><p><strong>2. 并发控制：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">createOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;order:lock:&quot;</span> + request.getUserId();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分布式锁防止重复下单</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">locked</span> <span class="operator">=</span> redisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(lockKey, <span class="string">&quot;1&quot;</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderCreationException</span>(<span class="string">&quot;Order creation in progress&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 订单创建逻辑</span></span><br><span class="line">            <span class="keyword">return</span> processOrder(request);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redisTemplate.delete(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 性能优化：</strong></p><ul><li>使用批量操作减少数据库交互</li><li>合理使用缓存策略</li><li>异步处理非核心业务逻辑</li><li>数据库连接池优化</li></ul><p><strong>Q2: 如何处理分布式事务？</strong></p><p>A: 分布式事务处理方案：</p><p><strong>1. 2PC&#x2F;3PC协议：</strong></p><ul><li>强一致性，但性能较差</li><li>适用于对一致性要求极高的场景</li></ul><p><strong>2. TCC模式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TccTransaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTccService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryCreateOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// Try阶段：预留资源</span></span><br><span class="line">        orderService.reserveOrder(request);</span><br><span class="line">        stockService.reserveStock(request.getItems());</span><br><span class="line">        paymentService.reservePayment(request.getPaymentInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirmCreateOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// Confirm阶段：确认操作</span></span><br><span class="line">        orderService.confirmOrder(request);</span><br><span class="line">        stockService.confirmStock(request.getItems());</span><br><span class="line">        paymentService.confirmPayment(request.getPaymentInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancelCreateOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// Cancel阶段：回滚操作</span></span><br><span class="line">        orderService.cancelOrder(request);</span><br><span class="line">        stockService.cancelStock(request.getItems());</span><br><span class="line">        paymentService.cancelPayment(request.getPaymentInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 消息队列最终一致性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEventService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleOrderCreated</span><span class="params">(OrderCreatedEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 异步处理订单相关业务</span></span><br><span class="line">        notificationService.sendOrderNotification(event.getOrder());</span><br><span class="line">        inventoryService.updateInventory(event.getOrderItems());</span><br><span class="line">        pointsService.addPoints(event.getUserId(), event.getAmount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Q3: Spring Boot应用如何优化启动速度？</strong></p><p>A: Spring Boot启动优化策略：</p><p><strong>1. 依赖优化：</strong></p><ul><li>移除不必要的依赖</li><li>使用spring-boot-starter-web替代完整的spring-web</li><li>避免引入大量自动配置类</li></ul><p><strong>2. 配置优化：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">lazy-initialization:</span> <span class="literal">true</span>  <span class="comment"># 启用懒加载</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">none</span>           <span class="comment"># 禁用DDL自动生成</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">false</span>            <span class="comment"># 禁用SQL日志</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span>           <span class="comment"># 生产环境禁用热重启</span></span><br></pre></td></tr></table></figure><p><strong>3. JVM优化：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockExperimentalVMOptions </span><br><span class="line">     -XX:+UseZGC </span><br><span class="line">     -XX:+UseTransparentHugePages</span><br><span class="line">     -XX:MaxMetaspaceSize=256m</span><br><span class="line">     -Xms512m -Xmx1024m</span><br><span class="line">     -jar application.jar</span><br></pre></td></tr></table></figure><p><strong>4. 代码优化：</strong></p><ul><li>使用@Lazy注解延迟Bean初始化</li><li>避免在@PostConstruct中执行耗时操作</li><li>合理使用@ConditionalOn*注解</li></ul><p>好的，这是一份详细的解释，我们来逐个分析这些 Java 虚拟机（JVM）参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -XX:+UseTransparentHugePages -XX:MaxMetaspaceSize=256m -Xms512m -Xmx1024m -jar application.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>java</code>: 这是启动 Java 程序的命令。</li></ul><hr><h3 id="内存管理和垃圾回收"><a href="#内存管理和垃圾回收" class="headerlink" title="内存管理和垃圾回收"></a>内存管理和垃圾回收</h3><p>这部分参数主要用于优化 JVM 的内存使用和垃圾回收机制，以获得更好的性能。</p><ul><li><code>-XX:+UnlockExperimentalVMOptions</code>: 这个参数是用来<strong>解锁实验性（experimental）的 JVM 选项</strong>。ZGC 曾经是实验性功能，所以需要这个参数才能使用。</li><li><code>-XX:+UseZGC</code>: 这条命令是启用 <strong>Z 垃圾回收器（Z Garbage Collector）</strong>。ZGC 是一种为<strong>超大堆内存</strong>（从几GB到几十TB）设计的、<strong>低延迟</strong>的垃圾回收器。它的主要目标是在垃圾回收时，尽量减少应用程序的停顿时间，这对于需要极低延迟的应用程序非常重要。</li><li><code>-XX:+UseTransparentHugePages</code>: 这个参数开启了<strong>透明大页（Transparent Huge Pages）的支持。在操作系统层面，通常内存是以 4KB 的小页来管理的。而大页（通常是 2MB 或 1GB）可以减少 CPU 在内存管理上的开销，从而提升性能，尤其对于内存占用较大</strong>的应用效果更明显。</li><li><code>-XX:MaxMetaspaceSize=256m</code>: 这个参数设置了<strong>元空间（Metaspace）的最大大小为 256MB</strong>。元空间是 JVM 存储类的元数据（如类的名称、方法、字段等信息）的地方。在 Java 8 之后，它取代了之前的“永久代”（PermGen）。</li><li><code>-Xms512m</code>: 这条命令设定了 <strong>JVM 堆的初始内存为 512MB</strong>。堆是用来存放 Java 对象的地方。<code>-Xms</code> 决定了 JVM 启动时会申请的最小内存。</li><li><code>-Xmx1024m</code>: 这条命令设定了 <strong>JVM 堆的最大内存为 1024MB（即 1GB）</strong>。这是 JVM 运行时可以使用的最大内存。当堆内存用尽时，JVM 会触发垃圾回收，如果依然不足，就会抛出 <code>OutOfMemoryError</code>。</li></ul><hr><p>好的，我们来更详细地聊聊 JVM 堆内存的结构，特别是分代设计和具体的划分比例。</p><hr><h3 id="堆内存的传统分代结构"><a href="#堆内存的传统分代结构" class="headerlink" title="堆内存的传统分代结构"></a>堆内存的传统分代结构</h3><p>在绝大多数的垃圾回收器中（例如 CMS、G1 之前的串行和并行 GC），堆内存被分为以下几个代（Generation）：</p><h4 id="1-年轻代（Young-Generation）"><a href="#1-年轻代（Young-Generation）" class="headerlink" title="1. 年轻代（Young Generation）"></a>1. 年轻代（Young Generation）</h4><p><strong>年轻代是新对象的诞生地。</strong> 绝大多数对象，比如局部变量创建的临时对象，都会在年轻代被创建。年轻代被设计成较小且垃圾回收频率高的区域。</p><ul><li><strong>Eden 区</strong>：这是年轻代的主要部分，新创建的对象首先被分配到这里。</li><li><strong>Survivor 区（幸存者区）</strong>：有两个大小相等的 Survivor 区，通常命名为 <strong>S0</strong> 和 <strong>S1</strong>。它们的作用是保存每次垃圾回收后，还存活的对象。</li></ul><p><strong>划分比例</strong></p><p>在默认情况下，年轻代内部的划分比例通常是：</p><ul><li><strong>Eden 区 : S0 区 : S1 区 &#x3D; 8 : 1 : 1</strong></li></ul><p>这个比例可以通过 JVM 参数进行调整，比如使用 <code>-XX:SurvivorRatio=8</code>。这意味着 Eden 区的大小是单个 Survivor 区的 8 倍。</p><h4 id="2-老年代（Old-Generation）"><a href="#2-老年代（Old-Generation）" class="headerlink" title="2. 老年代（Old Generation）"></a>2. 老年代（Old Generation）</h4><p><strong>老年代用于存放生命周期较长的对象。</strong> 当一个对象在年轻代经过多次垃圾回收（通常是 15 次，这个次数也可以通过 <code>-XX:MaxTenuringThreshold</code> 参数调整）后仍然存活，或者年轻代放不下的大对象，就会被“晋升”到老年代。</p><p>老年代的垃圾回收频率远低于年轻代，但每次回收的开销更大。</p><p><strong>划分比例</strong></p><p>堆内存中，年轻代和老年代的默认划分比例通常是：</p><ul><li><strong>年轻代 : 老年代 &#x3D; 1 : 2</strong></li></ul><p>例如，如果你设置 <code>-Xms1200m -Xmx1200m</code>，那么年轻代大约是 400MB，老年代大约是 800MB。这个比例可以通过 <code>-XX:NewRatio</code> 参数来调整。例如，<code>-XX:NewRatio=2</code> 表示老年代与年轻代的大小比值为 2:1。</p><hr><h3 id="垃圾回收过程（以-Minor-GC-为例）"><a href="#垃圾回收过程（以-Minor-GC-为例）" class="headerlink" title="垃圾回收过程（以 Minor GC 为例）"></a>垃圾回收过程（以 Minor GC 为例）</h3><p>理解了这些区域，我们再来看看垃圾回收是怎么进行的：</p><ol><li>当 <strong>Eden 区</strong>满了，会触发一次 <strong>Minor GC</strong>。</li><li>Minor GC 会检查 Eden 区和其中一个 Survivor 区（比如 S0）。</li><li>它会将所有还<strong>存活的对象</strong>复制到另一个空的 Survivor 区（比如 S1）。</li><li>同时，那些<strong>不再被引用的对象</strong>则会被清理。</li><li>所有被复制到 S1 区的对象，它们的年龄（<code>age</code>）会加一。</li><li>下一次 Minor GC 发生时，同样会扫描 Eden 区和 S1 区，将存活对象复制到 S0 区，清空 Eden 和 S1 区，并增加对象的年龄。</li><li>当对象的年龄达到某个阈值时，它就会被<strong>晋升</strong>到老年代。</li></ol><h3 id="现代垃圾回收器（如-G1-和-ZGC）"><a href="#现代垃圾回收器（如-G1-和-ZGC）" class="headerlink" title="现代垃圾回收器（如 G1 和 ZGC）"></a>现代垃圾回收器（如 G1 和 ZGC）</h3><p>值得注意的是，像 <strong>G1 垃圾回收器</strong>已经打破了这种严格的分代比例。它将堆划分为一个个大小相等的<strong>区域（Region）</strong>，每个区域都可以是 Eden、Survivor 或者老年代。G1 能够更智能地选择要回收的区域，从而在保证低停顿的同时，提高吞吐量。</p><p>而 <strong>ZGC</strong> 则更进一步，如我之前所说，它<strong>完全没有年轻代、老年代的概念</strong>，而是通过着色指针和读屏障技术，在不中断应用程序的情况下并发地进行垃圾回收，实现了更低的停顿。</p><p>因此，当你使用 ZGC 时，传统的分代比例就不适用了。不过，了解传统的分代结构对于理解 Java 内存管理的基础依然非常重要。</p><p>以下是针对Spring Cloud Alibaba及其他分布式技术的深度补充，包含实现原理和核心组件的详细说明：</p><hr><h2 id="六、Spring-Cloud与分布式技术详解"><a href="#六、Spring-Cloud与分布式技术详解" class="headerlink" title="六、Spring Cloud与分布式技术详解"></a>六、Spring Cloud与分布式技术详解</h2><h3 id="6-1-Spring-Cloud-Alibaba核心组件"><a href="#6-1-Spring-Cloud-Alibaba核心组件" class="headerlink" title="6.1 Spring Cloud Alibaba核心组件"></a>6.1 Spring Cloud Alibaba核心组件</h3><h4 id="Nacos深度解析"><a href="#Nacos深度解析" class="headerlink" title="Nacos深度解析"></a>Nacos深度解析</h4><p><strong>服务发现原理</strong>：</p><ol><li><p><strong>注册流程</strong>：</p><ul><li>服务启动时向Nacos Server发送注册请求（HTTP&#x2F;GRPC）</li><li>注册信息包含元数据、健康检查方式（TCP&#x2F;HTTP&#x2F;MySQL）</li><li>客户端本地缓存服务列表（故障转移）</li></ul></li><li><p><strong>健康检查机制</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nacos健康检查配置示例</span></span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        health-check-enabled: <span class="literal">true</span></span><br><span class="line">        health-check-interval: 10s</span><br><span class="line">        health-check-timeout: 5s</span><br></pre></td></tr></table></figure></li></ol><p><strong>配置中心实现</strong>：</p><ul><li><strong>长轮询机制</strong>（Push+Pull混合模式）：<ul><li>客户端发起长轮询请求（默认30秒超时）</li><li>服务端配置变更时立即响应</li><li>客户端收到变更后拉取最新配置</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态配置刷新示例</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.config.item&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Sentinel核心原理"><a href="#Sentinel核心原理" class="headerlink" title="Sentinel核心原理"></a>Sentinel核心原理</h4><p><strong>流量控制规则</strong>：</p><ul><li><strong>滑动窗口算法</strong>：<ul><li>统计周期（1秒）分为多个格子（如20个50ms）</li><li>实时淘汰过期格子数据</li><li>QPS计算基于当前窗口总请求数</li></ul></li></ul><p><strong>熔断降级策略</strong>：</p><table><thead><tr><th>策略类型</th><th>计算公式</th><th>适用场景</th></tr></thead><tbody><tr><td>慢调用比例</td><td>响应时间 &gt; RT阈值 &amp;&amp; 比例 &gt; 阈值</td><td>接口性能波动</td></tr><tr><td>异常比例</td><td>异常数 &#x2F; 请求数 &gt; 阈值</td><td>依赖服务不稳定</td></tr><tr><td>异常数</td><td>异常数 &gt; 阈值（时间窗口内）</td><td>关键业务熔断</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sentinel规则持久化到Nacos示例</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRules</span><span class="params">()</span> &#123;</span><br><span class="line">    FlowRuleManager.register2Property(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NacosDataSourceWrapper</span>(</span><br><span class="line">            <span class="string">&quot;nacos-server:8848&quot;</span>, <span class="string">&quot;sentinel-flow-rules&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> List&lt;FlowRule&gt; <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> JSON.parseArray(source, FlowRule.class);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RocketMQ集成"><a href="#RocketMQ集成" class="headerlink" title="RocketMQ集成"></a>RocketMQ集成</h4><p><strong>消息轨迹追踪</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RocketMQTemplate <span class="title function_">rocketMQTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RocketMQTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RocketMQTemplate</span>();</span><br><span class="line">    template.setProducer(<span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;producer_group&quot;</span>) &#123;&#123;</span><br><span class="line">        setVipChannelEnabled(<span class="literal">false</span>);</span><br><span class="line">        setTraceDispatcher(<span class="keyword">new</span> <span class="title class_">AsyncTraceDispatcher</span>(<span class="string">&quot;trace_topic&quot;</span>));</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者轨迹追踪</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">    topic = &quot;order_topic&quot;, </span></span><br><span class="line"><span class="meta">    consumerGroup = &quot;order_consumer&quot;,</span></span><br><span class="line"><span class="meta">    enableMsgTrace = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-分布式事务增强（Seata原理）"><a href="#6-2-分布式事务增强（Seata原理）" class="headerlink" title="6.2 分布式事务增强（Seata原理）"></a>6.2 分布式事务增强（Seata原理）</h3><h4 id="AT模式工作流程"><a href="#AT模式工作流程" class="headerlink" title="AT模式工作流程"></a>AT模式工作流程</h4><ol><li><strong>一阶段</strong>：<ul><li>解析SQL生成前后镜像</li><li>注册分支事务到TC（Transaction Coordinator）</li><li>本地事务提交前记录undo_log</li></ul></li><li><strong>二阶段</strong>：<ul><li>成功：异步删除undo_log</li><li>失败：根据undo_log补偿（反向SQL）</li></ul></li></ol><p><strong>undo_log表示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="TCC模式最佳实践"><a href="#TCC模式最佳实践" class="headerlink" title="TCC模式最佳实践"></a>TCC模式最佳实践</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 账户服务TCC接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountTccService</span> &#123;</span><br><span class="line">    <span class="meta">@TwoPhaseBusinessAction(</span></span><br><span class="line"><span class="meta">        name = &quot;deduct&quot;,</span></span><br><span class="line"><span class="meta">        commitMethod = &quot;confirmDeduct&quot;,</span></span><br><span class="line"><span class="meta">        rollbackMethod = &quot;cancelDeduct&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">prepareDeduct</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@BusinessActionContextParameter(paramName = &quot;userId&quot;)</span> String userId,</span></span><br><span class="line"><span class="params">        <span class="meta">@BusinessActionContextParameter(paramName = &quot;amount&quot;)</span> BigDecimal amount</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">confirmDeduct</span><span class="params">(BusinessActionContext context)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancelDeduct</span><span class="params">(BusinessActionContext context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务调用方</span></span><br><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 冻结库存</span></span><br><span class="line">    inventoryTccService.prepare(<span class="literal">null</span>, order.getProductId(), order.getCount());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 预扣款</span></span><br><span class="line">    accountTccService.prepareDeduct(order.getUserId(), order.getAmount());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 创建订单</span></span><br><span class="line">    orderMapper.insert(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-分布式缓存深度优化"><a href="#6-3-分布式缓存深度优化" class="headerlink" title="6.3 分布式缓存深度优化"></a>6.3 分布式缓存深度优化</h3><h4 id="Redis多级缓存架构"><a href="#Redis多级缓存架构" class="headerlink" title="Redis多级缓存架构"></a>Redis多级缓存架构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地缓存+Caffeine+Redis实现</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CaffeineRedisCacheManager</span>(</span><br><span class="line">        Caffeine.newBuilder()</span><br><span class="line">            .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">            .maximumSize(<span class="number">1000</span>),</span><br><span class="line">        RedisCacheWriter.nonLockingRedisCacheWriter(factory),</span><br><span class="line">        RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            .entryTtl(Duration.ofHours(<span class="number">1</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 热点Key探测</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getWithHotspotProtection</span><span class="params">(String key, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 本地缓存查询</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> localCache.getIfPresent(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) <span class="keyword">return</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. Redis集群查询（带随机过期时间）</span></span><br><span class="line">    value = redisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        localCache.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 分布式锁防击穿</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span> + key;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (redisLock.tryLock(lockKey, <span class="number">3</span>, <span class="number">30</span>)) &#123;</span><br><span class="line">            <span class="comment">// 4. 数据库查询</span></span><br><span class="line">            value = databaseLoader.load(key);</span><br><span class="line">            redisTemplate.opsForValue().set(</span><br><span class="line">                key, value, </span><br><span class="line">                ThreadLocalRandom.current().nextInt(<span class="number">30</span>) + <span class="number">30</span>, </span><br><span class="line">                TimeUnit.MINUTES</span><br><span class="line">            );</span><br><span class="line">            localCache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-消息队列高级特性"><a href="#6-4-消息队列高级特性" class="headerlink" title="6.4 消息队列高级特性"></a>6.4 消息队列高级特性</h3><h4 id="RocketMQ事务消息"><a href="#RocketMQ事务消息" class="headerlink" title="RocketMQ事务消息"></a>RocketMQ事务消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务消息生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTransactionMessage</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="type">TransactionSendResult</span> <span class="variable">result</span> <span class="operator">=</span> rocketMQTemplate.sendMessageInTransaction(</span><br><span class="line">        <span class="string">&quot;order-tx-group&quot;</span>,</span><br><span class="line">        MessageBuilder.withPayload(order)</span><br><span class="line">            .setHeader(RocketMQHeaders.TRANSACTION_ID, order.getId())</span><br><span class="line">            .build(),</span><br><span class="line">        order</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地事务执行器</span></span><br><span class="line"><span class="meta">@RocketMQTransactionListener(txProducerGroup = &quot;order-tx-group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">RocketMQLocalTransactionListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> (Order) arg;</span><br><span class="line">            orderService.createOrder(order); <span class="comment">// 本地事务</span></span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> msg.getHeaders().get(<span class="string">&quot;TRANSACTION_ID&quot;</span>).toString();</span><br><span class="line">        <span class="keyword">return</span> orderService.exists(orderId) ? </span><br><span class="line">            RocketMQLocalTransactionState.COMMIT : </span><br><span class="line">            RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kafka精确一次语义"><a href="#Kafka精确一次语义" class="headerlink" title="Kafka精确一次语义"></a>Kafka精确一次语义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ProducerFactory&lt;String, String&gt; <span class="title function_">producerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    configs.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, <span class="literal">true</span>);</span><br><span class="line">    configs.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, <span class="string">&quot;tx-producer-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultKafkaProducerFactory</span>&lt;&gt;(configs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ConsumerFactory&lt;String, String&gt; <span class="title function_">consumerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    configs.put(ConsumerConfig.ISOLATION_LEVEL_CONFIG, <span class="string">&quot;read_committed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultKafkaConsumerFactory</span>&lt;&gt;(configs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务性消费</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &quot;order-topic&quot;)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(ConsumerRecord&lt;String, String&gt; record)</span> &#123;</span><br><span class="line">    <span class="type">OrderEvent</span> <span class="variable">event</span> <span class="operator">=</span> parseEvent(record.value());</span><br><span class="line">    orderService.process(event); <span class="comment">// 数据库操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="七、云原生支持（新增）"><a href="#七、云原生支持（新增）" class="headerlink" title="七、云原生支持（新增）"></a>七、云原生支持（新增）</h2><h3 id="7-1-Kubernetes集成方案"><a href="#7-1-Kubernetes集成方案" class="headerlink" title="7.1 Kubernetes集成方案"></a>7.1 Kubernetes集成方案</h3><h4 id="服务发现适配"><a href="#服务发现适配" class="headerlink" title="服务发现适配"></a>服务发现适配</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Nacos与K8s Service集成</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">kubernetes:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">all-namespaces:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">$&#123;NACOS_HOST:nacos-headless&#125;:$&#123;NACOS_PORT:8848&#125;</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">$&#123;POD_NAMESPACE:default&#125;</span></span><br></pre></td></tr></table></figure><h4 id="配置管理方案"><a href="#配置管理方案" class="headerlink" title="配置管理方案"></a>配置管理方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多配置源加载（K8s ConfigMap + Nacos）</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;configFromNacos&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nacosConfig;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;configFromK8s&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String k8sConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Service-Mesh整合"><a href="#7-2-Service-Mesh整合" class="headerlink" title="7.2 Service Mesh整合"></a>7.2 Service Mesh整合</h3><h4 id="Istio流量治理"><a href="#Istio流量治理" class="headerlink" title="Istio流量治理"></a>Istio流量治理</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 金丝雀发布策略</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">order-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">order-service</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">            <span class="attr">host:</span> <span class="string">order-service</span></span><br><span class="line">            <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">          <span class="attr">weight:</span> <span class="number">90</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">            <span class="attr">host:</span> <span class="string">order-service</span></span><br><span class="line">            <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">          <span class="attr">weight:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><hr><h2 id="八、性能优化深度实践"><a href="#八、性能优化深度实践" class="headerlink" title="八、性能优化深度实践"></a>八、性能优化深度实践</h2><h3 id="8-1-全链路压测方案"><a href="#8-1-全链路压测方案" class="headerlink" title="8.1 全链路压测方案"></a>8.1 全链路压测方案</h3><h4 id="影子库表配置"><a href="#影子库表配置" class="headerlink" title="影子库表配置"></a>影子库表配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ShardingSphere影子库配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">ds-real,ds-shadow</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="attr">shadow:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">data-sources:</span></span><br><span class="line">          <span class="attr">shadow-data-source:</span></span><br><span class="line">            <span class="attr">source-data-source-name:</span> <span class="string">ds-real</span></span><br><span class="line">            <span class="attr">shadow-data-source-name:</span> <span class="string">ds-shadow</span></span><br><span class="line">        <span class="attr">tables:</span></span><br><span class="line">          <span class="attr">t_order:</span></span><br><span class="line">            <span class="attr">shadow-algorithm-names:</span> [<span class="string">simple-hint-algorithm</span>]</span><br></pre></td></tr></table></figure><h4 id="流量染色标记"><a href="#流量染色标记" class="headerlink" title="流量染色标记"></a>流量染色标记</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ThreadLocal传递压测标记</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PressureTestContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; FLAG = ThreadLocal.withInitial(() -&gt; <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">markPressureTest</span><span class="params">()</span> &#123;</span><br><span class="line">        FLAG.set(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPressureTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FLAG.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyBatis拦截器自动路由</span></span><br><span class="line"><span class="meta">@Intercepts(@Signature(type=Executor.class, method=&quot;update&quot;, args=&#123;MappedStatement.class,Object.class&#125;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShadowDbInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (PressureTestContext.isPressureTest()) &#123;</span><br><span class="line">            RoutingContext.setShadowDataSource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h4 id="1-Spring-Cloud-体系"><a href="#1-Spring-Cloud-体系" class="headerlink" title="1. Spring Cloud 体系"></a><strong>1. Spring Cloud 体系</strong></h4><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h5><p>Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的<strong>规范和解决方案的集合</strong>。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。</p><h5 id="Netflix-OSS-常用组件（部分进入维护模式）"><a href="#Netflix-OSS-常用组件（部分进入维护模式）" class="headerlink" title="Netflix OSS 常用组件（部分进入维护模式）"></a><strong>Netflix OSS 常用组件（部分进入维护模式）</strong></h5><ul><li><strong>服务注册与发现 (Service Discovery): Eureka</strong><ul><li><strong>作用</strong>: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。</li><li><strong>使用</strong>: 服务端添加 <code>spring-cloud-starter-netflix-eureka-server</code> 依赖，并使用 <code>@EnableEurekaServer</code> 注解。客户端添加 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖，并配置 Eureka Server 地址。</li></ul></li><li><strong>服务调用与负载均衡 (RPC &amp; Load Balancing): OpenFeign + Ribbon</strong><ul><li><strong>作用</strong>: Feign 让远程服务调用变得像调用本地方法一样简单。开发者只需定义一个接口，并使用 <code>@FeignClient</code> 注解，即可完成对远程服务的调用。Ribbon（现已被 Spring Cloud LoadBalancer 替代）则提供了客户端负载均衡能力，当从 Eureka 获取到多个服务实例地址时，Ribbon 会根据配置的策略（如轮询、随机）选择一个实例进行调用。</li><li><strong>使用</strong>: 添加 <code>spring-cloud-starter-openfeign</code> 依赖，在启动类上加 <code>@EnableFeignClients</code>，创建接口并使用 <code>@FeignClient(&quot;service-name&quot;)</code> 注解。</li></ul></li><li><strong>熔断与降级 (Circuit Breaker): Hystrix</strong><ul><li><strong>作用</strong>: 当某个下游服务出现故障或响应缓慢时，为了防止故障在系统中蔓延（即“服务雪崩”），熔断器会快速失败，暂时切断对该服务的调用。同时，可以执行一个预定义的降级逻辑（Fallback），例如返回一个缓存的、默认的或友好的提示信息。</li><li><strong>状态</strong>: Hystrix 已进入维护模式，官方推荐使用 Resilience4j 或其他替代方案。</li></ul></li><li><strong>API 网关 (API Gateway): Zuul</strong><ul><li><strong>作用</strong>: 作为系统的统一入口，API 网关负责请求路由、协议转换、权限校验、流量控制、日志监控等。所有外部请求都先经过网关，再由网关分发到后端的各个微服务。</li><li><strong>状态</strong>: Zuul 1.x 已进入维护模式，官方推荐使用 Spring Cloud Gateway。</li></ul></li></ul><hr><h5 id="Spring-Cloud-Alibaba-详解"><a href="#Spring-Cloud-Alibaba-详解" class="headerlink" title="Spring Cloud Alibaba 详解"></a><strong>Spring Cloud Alibaba 详解</strong></h5><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案，是 Spring Cloud 体系的重要实现。它集成了阿里巴巴开源的优秀组件，为开发者提供了更符合国内技术生态的选择。</p><ul><li><strong>服务注册与发现 &amp; 分布式配置中心: Nacos</strong><ul><li><strong>作用</strong>: Nacos (Naming and Configuration Service) 是一个功能丰富的平台，完美整合了<strong>服务注册发现</strong>和<strong>配置管理</strong>两大核心功能。<ul><li><strong>服务发现</strong>: 与 Eureka 类似，提供服务注册、发现和健康检查。但 Nacos 支持基于 DNS 和 RPC 的服务发现，并提供更实时的健康检查机制。</li><li><strong>配置管理</strong>: 可以作为分布式配置中心，对所有微服务的配置进行集中化管理。支持配置的热更新，即修改配置后无需重启服务即可生效。还支持配置的版本管理、灰度发布等高级功能。</li></ul></li><li><strong>使用</strong>:<ol><li>引入 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 和 <code>spring-cloud-starter-alibaba-nacos-config</code> 依赖。</li><li>在 <code>bootstrap.properties</code> (或 <code>.yml</code>) 文件中配置 Nacos 服务器地址和应用名。</li><li>使用 <code>@Value</code> 或 <code>@ConfigurationProperties</code> 注解即可动态获取和刷新配置。</li></ol></li></ul></li><li><strong>熔断、降级与流量控制: Sentinel</strong><ul><li><strong>作用</strong>: Sentinel 是面向分布式服务架构的“流量的守护者”，以流量为切入点，从<strong>流量控制、熔断降级、系统负载保护</strong>等多个维度保护服务的稳定性。相较于 Hystrix，Sentinel 功能更强大，提供了可视化的监控和配置平台，并且支持热点参数限流等精细化控制。</li><li><strong>核心概念</strong>:<ul><li><strong>资源 (Resource)</strong>: Sentinel 中一切皆资源，可以是一个方法、一段代码或一个服务 URL。</li><li><strong>规则 (Rule)</strong>: 定义如何保护资源，包括流控规则、降级规则、系统保护规则等。</li></ul></li><li><strong>使用</strong>:<ol><li>引入 <code>spring-cloud-starter-alibaba-sentinel</code> 依赖。</li><li>配置 Sentinel 控制台地址。</li><li>通过 <code>@SentinelResource</code> 注解来定义资源，并指定 Fallback (降级逻辑) 和 BlockHandler (流控&#x2F;熔断逻辑)。</li></ol></li></ul></li><li><strong>分布式事务解决方案: Seata</strong><ul><li><strong>作用</strong>: Seata 是一个开源的分布式事务解决方案，提供了高性能且易于使用的分布式事务服务。它支持多种事务模式，包括 AT（自动补偿）、TCC、Saga 和 XA 模式，旨在解决微服务架构下的数据一致性问题。</li><li><strong>使用</strong>: 引入 <code>spring-cloud-starter-alibaba-seata</code> 依赖，配置 Seata Server 地址，并使用 <code>@GlobalTransactional</code> 注解开启全局事务。</li></ul></li></ul><hr><h4 id="2-分布式ID：雪花算法（Snowflake）"><a href="#2-分布式ID：雪花算法（Snowflake）" class="headerlink" title="2. 分布式ID：雪花算法（Snowflake）"></a><strong>2. 分布式ID：雪花算法（Snowflake）</strong></h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>Snowflake 是 Twitter 开源的一种分布式 ID 生成算法，它能生成一个 64 位的 <code>long</code> 型数字作为全局唯一 ID。这个 64 位的 ID 由四部分构成：</p><ul><li><strong>1位符号位</strong>: 最高位，固定为0，表示正数，无实际意义。</li><li><strong>41位时间戳 (Timestamp)</strong>: 精确到毫秒级，是 <code>(当前时间戳 - 起始时间戳)</code> 的差值。41位可以表示 (241−1) 毫秒，大约可以使用 69 年。</li><li><strong>10位工作机器ID (Worker ID)</strong>: 这 10 位可以被灵活划分，例如前 5 位代表数据中心 ID (Datacenter ID)，后 5 位代表机器 ID (Machine ID)。这样总共可以支持 210&#x3D;1024 台机器。</li><li><strong>12位序列号 (Sequence)</strong>: 表示在同一毫秒内，同一台机器上生成的 ID 序列号。12位意味着每台机器每毫秒可以生成 212&#x3D;4096 个不同的 ID。</li></ul><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h5><ul><li><strong>全局唯一</strong>: 通过时间戳、机器 ID 和序列号的组合，可以保证在分布式环境下的 ID 唯一性。</li><li><strong>趋势递增</strong>: 由于时间戳在高位，所以生成的 ID 整体上是按时间趋势递增的，这对于数据库索引（特别是 B+树）非常友好，可以减少页分裂，提高插入性能。</li><li><strong>高性能</strong>: ID 在本地生成，不依赖任何外部服务（如数据库或 Redis），生成效率极高。</li><li><strong>高可用</strong>: 算法本身不依赖网络，部署简单，具有很高的可用性。</li></ul><h5 id="面试题：“雪花算法有时钟回拨问题，如何解决？”"><a href="#面试题：“雪花算法有时钟回拨问题，如何解决？”" class="headerlink" title="面试题：“雪花算法有时钟回拨问题，如何解决？”"></a><strong>面试题：“雪花算法有时钟回拨问题，如何解决？”</strong></h5><p>回答要点:</p><p>时钟回拨是指服务器时间被同步到一个过去的时间点。如果算法不做处理，可能会生成重复的 ID。解决方案通常是：在生成 ID 时，记录上一次生成 ID 时所使用的时间戳。当发现当前时间戳小于上次记录的时间戳时，就意味着发生了时钟回拨。</p><ul><li><strong>方案一（拒绝服务）</strong>: 直接抛出异常，拒绝生成 ID，等待时钟恢复正常。这种方案简单，但会暂时影响可用性，适合对 ID 连续性要求不高的场景。</li><li><strong>方案二（等待追赶）</strong>: 如果回拨幅度很小（比如几毫秒），程序可以 <code>while(currentTime &lt; lastTimestamp)</code> 这样自旋等待，直到当前时间追赶上上次的时间戳。这会造成短暂的线程阻塞。</li><li><strong>方案三（使用备用位）</strong>: 一些改进版的雪花算法会预留几位作为扩展位，当发生时钟回拨时，在这几位上做自增，从而在短时间回拨内仍能生成不同的 ID。（这种方案实现较为复杂）</li><li><strong>业界实践（美团 Leaf）</strong>: 在发生时钟回拨时，切换到另一种备用 ID 生成策略（如号段模式），或者直接报错。</li></ul><hr><h4 id="3-RBAC（基于角色的访问控制）"><a href="#3-RBAC（基于角色的访问控制）" class="headerlink" title="3. RBAC（基于角色的访问控制）"></a><strong>3. RBAC（基于角色的访问控制）</strong></h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>RBAC (Role-Based Access Control) 是一种主流且灵活的权限管理模型。它的核心思想是在 <strong>用户 (User)</strong> 和 <strong>权限 (Permission)</strong> 之间引入一个中间层——<strong>角色 (Role)</strong>。权限不再直接授予用户，而是授予角色；然后将角色分配给用户。这样，用户与权限实现了解耦，当需要修改大量用户的权限时，只需修改他们共同拥有的角色的权限即可，极大地简化了权限管理和维护。</p><h5 id="核心三要素"><a href="#核心三要素" class="headerlink" title="核心三要素"></a><strong>核心三要素</strong></h5><ul><li><strong>用户 (User)</strong>: 系统操作的主体。</li><li><strong>角色 (Role)</strong>: 权限的集合，代表了一组特定的职责或身份，如“管理员”、“文章编辑”、“普通会员”。</li><li><strong>权限 (Permission)</strong>: 对系统中特定资源进行特定操作的许可。通常用一个字符串表示，如 <code>user:create</code>、<code>order:delete</code>、<code>article:publish</code>。</li></ul><h5 id="面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”"><a href="#面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”" class="headerlink" title="面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”"></a><strong>面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”</strong></h5><p>回答要点:</p><p>一个基础的 RBAC 模型至少需要五张表：</p><ul><li><strong>用户表 (t_user)</strong>: 存储用户信息。<ul><li><code>user_id</code> (主键), <code>username</code>, <code>password</code>, …</li></ul></li><li><strong>角色表 (t_role)</strong>: 存储角色信息。<ul><li><code>role_id</code> (主键), <code>role_name</code> (角色名, 如”管理员”), <code>role_key</code> (角色标识, 如”admin”), …</li></ul></li><li><strong>权限表 (t_permission)</strong>: 存储具体的权限点信息。<ul><li><code>permission_id</code> (主键), <code>permission_name</code> (权限名称, 如“新增用户”), <code>permission_code</code> (权限标识, 如 <code>user:add</code>), <code>parent_id</code> (用于菜单层级), …</li></ul></li><li><strong>用户-角色关联表 (t_user_role)</strong>: 存储用户和角色的多对多关系。<ul><li><code>user_id</code> (外键), <code>role_id</code> (外键)。(主键是 <code>user_id</code> 和 <code>role_id</code> 的联合主键)</li></ul></li><li><strong>角色-权限关联表 (t_role_permission)</strong>: 存储角色和权限的多对多关系。<ul><li><code>role_id</code> (外键), <code>permission_id</code> (外键)。(主键是 <code>role_id</code> 和 <code>permission_id</code> 的联合主键)</li></ul></li></ul><hr><h4 id="4-Redis-进阶详解"><a href="#4-Redis-进阶详解" class="headerlink" title="4. Redis 进阶详解"></a><strong>4. Redis 进阶详解</strong></h4><h5 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h5><ul><li><strong>基于内存</strong>: Redis 是一个内存数据结构存储系统，所有数据都存放在内存中，因此读写速度极快。</li><li><strong>单线程模型</strong>: Redis 的核心网络模型处理客户端请求是单线程的。这避免了多线程环境下的上下文切换和锁竞争带来的开销。（注意：Redis 6.0 之后引入了多线程来处理 I&#x2F;O，但执行命令的核心仍然是单线程）。</li><li><strong>IO多路复用</strong>: 单线程能实现高性能的关键在于它使用了 IO 多路复用技术（如 Linux 下的 epoll）。该技术允许单个线程同时监听多个网络连接上的 IO 事件，当某个连接准备好读或写时，才去处理它，极大地提高了并发处理能力。</li><li><strong>丰富的数据类型</strong>: 支持 String, Hash, List, Set, Sorted Set, Bitmap, HyperLogLog, GEO 等多种数据结构。</li></ul><h5 id="缓存三大问题与解决方案"><a href="#缓存三大问题与解决方案" class="headerlink" title="缓存三大问题与解决方案"></a><strong>缓存三大问题与解决方案</strong></h5><ul><li><strong>缓存穿透</strong>:<ul><li><strong>问题</strong>: 客户端查询一个数据库和缓存中<strong>都</strong>不存在的数据。这导致每次请求都会绕过缓存，直接打到数据库上，当有大量此类请求时，会给数据库带来巨大压力。</li><li><strong>解决</strong>:<ol><li><strong>缓存空对象</strong>: 当从数据库查询不到数据时，也在缓存中存入一个特殊的空值（如 <code>null</code> 或特定字符串），并设置一个较短的过期时间。</li><li><strong>布隆过滤器 (Bloom Filter)</strong>: 在访问缓存之前，先通过布隆过滤器判断 key 是否<strong>可能</strong>存在。布隆过滤器可以高效地判断一个元素<strong>一定不存在</strong>，从而在第一层就拦截掉大量无效请求。</li></ol></li></ul></li><li><strong>缓存击穿</strong>:<ul><li><strong>问题</strong>: 某个<strong>热点 Key</strong> 在某一时刻突然失效，而此时恰好有大量的并发请求访问这个 Key，这些请求会同时穿透缓存，直接打到数据库上，可能导致数据库瞬间崩溃。</li><li><strong>解决</strong>:<ol><li><strong>设置热点 Key 永不过期</strong>: 对于一些访问极其频繁且数据相对固定的热点数据，可以考虑不设置过期时间，通过后台任务定时更新。</li><li><strong>使用分布式锁</strong>: 在查询数据库之前，先获取一个该 Key 对应的分布式锁。只有第一个获取到锁的线程才能去查询数据库并回写缓存，其他线程则等待或直接返回。</li></ol></li></ul></li><li><strong>缓存雪崩</strong>:<ul><li><strong>问题</strong>: 大量的缓存 Key 在<strong>同一时间集中失效</strong>（例如，在应用启动时缓存了大量数据，并设置了相同的过期时间），导致所有请求都瞬间涌向数据库，造成数据库压力剧增甚至宕机。</li><li><strong>解决</strong>:<ol><li><strong>过期时间加随机值</strong>: 在设置缓存的过期时间时，在一个基础时间上增加一个随机数，使得 Key 的失效时间点尽可能分散。</li><li><strong>多级缓存</strong>: 建立多级缓存体系，如 Nginx 缓存 + Redis 缓存 + JVM 本地缓存（Caffeine&#x2F;Guava Cache）。</li><li><strong>熔断降级</strong>: 使用 Hystrix 或 Sentinel 等组件，当检测到数据库压力过大时，进行熔断或降级处理，暂时不访问数据库，返回一个默认值或提示信息。</li></ol></li></ul></li></ul><hr><h4 id="5-消息队列（MQ）"><a href="#5-消息队列（MQ）" class="headerlink" title="5. 消息队列（MQ）"></a><strong>5. 消息队列（MQ）</strong></h4><h5 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a><strong>核心作用</strong></h5><ul><li><strong>异步 (Asynchronous)</strong>: 将耗时的操作（如发送邮件、生成报表）作为消息放入 MQ，主流程可以立即返回，无需等待这些操作完成，从而提高系统的响应速度和吞吐量。</li><li><strong>解耦 (Decoupling)</strong>: 生产者和消费者之间通过 MQ 进行通信，无需直接相互依赖。任何一方的修改、宕机或升级都不会影响到另一方，增强了系统的灵活性和可维护性。</li><li><strong>削峰 (Peak Shaving)</strong>: 在秒杀、大促等高并发场景下，将瞬时涌入的大量请求暂存在 MQ 中，下游的消费者系统可以按照自己的处理能力，平稳地从 MQ 中拉取并处理请求，避免了流量洪峰直接冲垮下游服务。</li></ul><h5 id="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"><a href="#面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”" class="headerlink" title="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"></a><strong>面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”</strong></h5><p><strong>回答要点</strong>:</p><ul><li><strong>消息丢失 (Message Loss)</strong>:<ul><li><strong>问题</strong>: 消息从生产者发出后，由于网络或 MQ 服务故障，未能成功到达消费者。</li><li><strong>解决</strong>:<ol><li><strong>生产者端</strong>: 开启生产者的 <code>confirm</code> 或 <code>ack</code> 机制，确保消息被 MQ 成功接收。如果发送失败，可以进行重试。</li><li><strong>MQ 服务端</strong>: 对消息进行持久化，防止 MQ 宕机导致消息丢失（如 RabbitMQ 的持久化队列和消息，Kafka 的磁盘存储）。</li><li><strong>消费者端</strong>: 消费者在处理完业务逻辑后，再向 MQ 发送确认应答（<code>ack</code>）。如果处理过程中消费者宕机，MQ 没有收到 <code>ack</code>，会将该消息重新投递给其他消费者。</li></ol></li></ul></li><li><strong>重复消费 (Duplicate Consumption)</strong>:<ul><li><strong>问题</strong>: 由于网络抖动、消费者 <code>ack</code> 超时等原因，MQ 可能会重复投递同一条消息。</li><li><strong>解决</strong>: 核心是保证消费逻辑的<strong>幂等性 (Idempotence)</strong>。即多次执行同一个操作，结果都是相同的。实现方式有：<ol><li>在数据库中为业务操作创建一个<strong>唯一键</strong>，每次操作前先检查该唯一键是否存在。</li><li>使用一个全局唯一的<strong>业务 ID</strong>（如订单号），在处理消息前，先查询这个 ID 是否已经被处理过（例如，存入 Redis Set 或数据库）。</li></ol></li></ul></li><li><strong>消息堆积 (Message Backlog)</strong>:<ul><li><strong>问题</strong>: 生产者的生产速度远大于消费者的消费速度，导致大量消息在 MQ 中积压，占用资源并可能导致消息超时丢失。</li><li><strong>解决</strong>:<ol><li><strong>水平扩展消费者</strong>: 增加消费者实例的数量，并行处理消息。这是最常用的方法。</li><li><strong>优化消费逻辑</strong>: 检查消费者代码，看是否有可以优化的慢操作（如 I&#x2F;O 密集型操作）。</li><li><strong>消息分片&#x2F;分区</strong>: 对 Topic 进行分区（Partitioning），让不同的消费者组处理不同的分区，提高并发度。</li><li><strong>增加预警监控</strong>: 对消息堆积数量设置阈值，达到阈值时及时告警，人工介入。</li></ol></li></ul></li></ul><hr><h4 id="6-分布式锁详解"><a href="#6-分布式锁详解" class="headerlink" title="6. 分布式锁详解"></a><strong>6. 分布式锁详解</strong></h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在分布式系统环境下，多个进程或服务器上的多个线程需要访问同一个共享资源时，为了保证数据的一致性和操作的原子性，需要一种机制来确保在同一时刻，只有一个客户端能够持有锁并访问该资源。</p><h5 id="实现方案对比"><a href="#实现方案对比" class="headerlink" title="实现方案对比"></a><strong>实现方案对比</strong></h5><table><thead><tr><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>基于数据库</strong></td><td>实现简单，直接利用数据库（如唯一索引、悲观锁 <code>for update</code>）。</td><td>性能开销大，有锁库锁表的风险，不可重入，不是阻塞锁，数据库单点故障问题。</td><td>并发度不高的简单场景。</td></tr><tr><td><strong>基于 ZooKeeper</strong></td><td>可靠性高，天然支持阻塞锁和可重入，解决死锁问题（临时节点），无锁过期问题，支持公平锁。</td><td>性能不如 Redis，实现复杂，依赖 ZK 集群。</td><td>对可靠性要求极高，且能容忍一定性能损耗的场景，如分布式协调。</td></tr><tr><td><strong>基于 Redis</strong></td><td>性能极高，实现相对简单，有成熟的框架 (Redisson) 可用。</td><td>可靠性相对 ZK 稍差，需要处理锁过期和业务未执行完的问题，非公平锁。</td><td>互联网高并发、对性能要求高的绝大多数场景。</td></tr></tbody></table><h5 id="基于-Redis-的实现进阶"><a href="#基于-Redis-的实现进阶" class="headerlink" title="基于 Redis 的实现进阶"></a><strong>基于 Redis 的实现进阶</strong></h5><ul><li><p>加锁的正确姿势:</p><p>使用 SET key value NX EX time 命令。</p><ul><li><p><code>SET key value</code>: 设置键值。<code>value</code> 通常是一个唯一的随机字符串（如 UUID），用于标识锁的持有者。</p></li><li><p><code>NX</code>: (if Not eXists)，确保只有在 key 不存在时才能设置成功，实现了“加锁”的原子性。</p></li><li><p>EX time: 设置一个自动过期时间（秒），防止因客户端宕机而导致死锁。</p><p>这三个参数必须在一个命令中执行，保证原子性。</p></li></ul></li><li><p><strong>解锁的正确姿势：Lua 脚本</strong></p><ul><li><p><strong>为什么需要 Lua</strong>: 解锁操作包含“判断”和“删除”两步：1. <code>GET</code> 锁的 <code>value</code>，判断是否与自己加锁时设置的随机字符串相等。2. 如果相等，则 <code>DEL</code> 锁。如果不用 Lua 脚本，在执行完第一步后，若该线程阻塞，此时锁恰好过期，另一个线程获取了锁，那么当原线程恢复执行第二步时，就会<strong>误删掉新线程的锁</strong>。</p></li><li><p><strong>Lua 脚本示例</strong>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本接收两个参数：KEYS[1] 是锁的 key，ARGV[1] 是加锁时设置的唯一值</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><p>Lua 脚本可以确保多个命令在 Redis 服务端被原子性地执行，杜绝了上述问题。</p></li><li><p><strong>Redis 乐观锁：WATCH 命令</strong></p><ul><li><p><strong>作用</strong>: <code>WATCH</code> 命令可以监视一个或多个 key，如果在事务 <code>EXEC</code> 执行之前，任何一个被监视的 key 被其他命令修改了，那么整个事务将被取消，<code>EXEC</code> 返回 <code>nil</code>。</p></li><li><p><strong>原理</strong>: 这是一种<strong>检查后设置 (Check-And-Set, CAS)</strong> 的实现。它不是真正的加锁，而是在更新数据时检查数据是否被修改过。</p></li><li><p><strong>使用场景</strong>: 适用于<strong>读多写少</strong>的并发场景，可以减少锁的开销。例如，更新商品库存。</p><ol><li><p><code>WATCH stock_key</code> &#x2F;&#x2F; 监视库存</p></li><li><p><code>current_stock = GET stock_key</code> &#x2F;&#x2F; 获取当前库存</p></li><li><p>(在客户端代码中判断 <code>current_stock</code> 是否足够)</p></li><li><p><code>MULTI</code> &#x2F;&#x2F; 开启事务</p></li><li><p><code>SET stock_key new_stock</code> &#x2F;&#x2F; 准备更新库存</p></li><li><p>EXEC &#x2F;&#x2F; 执行事务</p><p>如果从 WATCH 到 EXEC 之间 stock_key 被其他客户端修改，EXEC 将失败，此时客户端需要重试整个操作。</p></li></ol></li></ul></li></ul><h5 id="面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”"><a href="#面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”" class="headerlink" title="面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”"></a><strong>面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”</strong></h5><p>回答要点:</p><p>这是分布式锁的一个经典问题，被称为锁的超时续期问题。</p><ul><li><strong>问题根源</strong>: 我们给锁设置了一个过期时间，比如 30 秒，但业务执行了 35 秒。在第 30 秒时锁会自动释放，其他线程就能获取到锁，导致并发问题。</li><li><strong>解决方案：“看门狗”(Watchdog)机制</strong>。<ul><li><strong>原理</strong>: 比如 Java 中的 Redisson 框架就内置了看门狗。当一个线程获取锁成功后，Redisson 会启动一个后台线程（看门狗），定期（例如每 10 秒）检查该线程是否还持有锁。如果持有，并且业务仍在执行，看门狗就会自动为这个锁<strong>延长过期时间</strong>（续期），比如再续 30 秒。这个过程会一直持续，直到业务执行完毕，线程主动释放锁，看门狗才会停止。</li><li><strong>总结</strong>: 看门狗机制通过后台线程自动续期，确保了在业务执行完成之前，锁不会因为超时而提前释放，从而保证了锁的可靠性。</li></ul></li></ul><hr><h4 id="7-分布式事务详解"><a href="#7-分布式事务详解" class="headerlink" title="7. 分布式事务详解"></a><strong>7. 分布式事务详解</strong></h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在微服务架构中，一个业务操作可能需要调用多个独立的服务来共同完成（例如，电商下单操作需要调用订单服务、库存服务、积分服务）。分布式事务旨在保证这些跨服务的数据库操作能够遵循 ACID 原则，要么全部成功，要么全部回滚，以确保数据的<strong>最终一致性</strong>。</p><h5 id="解决方案深入分析"><a href="#解决方案深入分析" class="headerlink" title="解决方案深入分析"></a><strong>解决方案深入分析</strong></h5><ul><li><strong>XA (2PC&#x2F;3PC)</strong>: 两阶段&#x2F;三阶段提交协议。<ul><li><strong>角色</strong>: 事务管理器 (Transaction Manager, TM) 和 资源管理器 (Resource Manager, RM)。</li><li><strong>流程 (2PC)</strong>:<ol><li><strong>准备阶段 (Prepare)</strong>: TM 通知所有 RM 准备提交，RM 执行本地事务并锁定资源，但不提交，然后向 TM 报告准备就绪。</li><li><strong>提交&#x2F;回滚阶段 (Commit&#x2F;Rollback)</strong>: 如果所有 RM 都准备就绪，TM 通知所有 RM 提交；否则，通知所有 RM 回滚。</li></ol></li><li><strong>评价</strong>: 是一种<strong>强一致性</strong>的方案，但协议复杂，性能差，同步阻塞模型会长时间锁定资源，且协调器存在单点故障风险，在互联网高并发场景下<strong>很少使用</strong>。</li></ul></li><li><strong>TCC (Try-Confirm-Cancel)</strong>: 补偿型事务。<ul><li><strong>核心</strong>: 是一种<strong>业务层面</strong>的柔性事务方案，对代码侵入性强。</li><li><strong>流程</strong>:<ol><li><strong>Try</strong>: 对业务资源进行<strong>检查和预留</strong>。例如，扣减库存操作，Try 阶段是冻结库存。</li><li><strong>Confirm</strong>: 如果所有服务的 Try 阶段都成功，则执行所有服务的 <strong>Confirm</strong> 操作，真正完成业务。例如，将冻结的库存真实扣减。</li><li><strong>Cancel</strong>: 如果任何一个服务的 Try 阶段失败，则执行所有已成功服务的 <strong>Cancel</strong> 操作，释放预留的资源。例如，解冻之前被冻结的库存。</li></ol></li><li><strong>评价</strong>: 性能较好，数据一致性高于可靠消息方案。但开发成本极高，需要为每个操作都编写 Try, Confirm, Cancel 三个幂等的方法。</li></ul></li><li><strong>Saga 模式</strong>: 长事务解决方案。<ul><li><strong>核心</strong>: 将一个大的分布式事务拆分成多个<strong>本地事务</strong>，每个本地事务都有一个对应的<strong>补偿操作</strong>。</li><li><strong>流程</strong>:<ul><li><strong>正向执行</strong>: Saga 协调器按顺序调用 T1, T2, T3…Tn。</li><li><strong>反向补偿</strong>: 如果 Ti 失败，Saga 会按相反顺序调用前面已成功事务的补偿操作 C(i-1)…C2, C1，进行回滚。</li></ul></li><li><strong>与 TCC 对比</strong>:<ul><li>TCC 有资源<strong>预留</strong>阶段，锁资源时间长；Saga 没有预留，直接提交本地事务，锁资源时间短。</li><li>TCC 的补偿是<strong>逆向操作</strong> (Cancel)；Saga 的补偿是<strong>反向操作</strong>。</li></ul></li><li><strong>评价</strong>: 适合于业务流程长、需要保证最终一致性的场景。同样对代码有侵入性，需要设计好每个子事务的补偿逻辑。</li></ul></li><li><strong>基于可靠消息的最终一致性 (常用)</strong>:<ul><li><strong>核心</strong>: 这是微服务架构中<strong>最常用</strong>的柔性事务方案。</li><li><strong>原理</strong>: 服务 A 在执行完本地事务后，发送一条消息到 MQ。服务 B 订阅该消息，消费消息并执行自己的本地事务。</li><li><strong>关键问题</strong>: 如何保证<strong>本地事务执行</strong>和<strong>消息发送</strong>的原子性？<ul><li><strong>事务消息 (RocketMQ 支持)</strong>: 生产者先发送一条“半消息”到 MQ，MQ 收到后不投递。然后生产者执行本地事务。如果事务成功，则向 MQ 发送确认，MQ 投递该消息；如果事务失败，则通知 MQ 删除该半消息。</li><li><strong>本地消息表</strong>: 业务操作和“待发送消息”记录在同一本地事务中。一个后台任务定时扫描这张表，将消息发送到 MQ，发送成功后更新表状态。</li></ul></li><li><strong>评价</strong>: 实现了服务间的解耦，性能高，吞吐量大。但它不保证数据的强一致性，只保证<strong>最终一致性</strong>，存在一个短暂的数据不一致状态窗口。需要处理好消息的可靠投递和幂等消费问题。</li></ul></li></ul><h3 id="Lua-脚本详解-在-Redis-中的应用"><a href="#Lua-脚本详解-在-Redis-中的应用" class="headerlink" title="Lua 脚本详解 (在 Redis 中的应用)"></a><strong>Lua 脚本详解 (在 Redis 中的应用)</strong></h3><h4 id="1-Lua-是什么？"><a href="#1-Lua-是什么？" class="headerlink" title="1. Lua 是什么？"></a><strong>1. Lua 是什么？</strong></h4><p>Lua 是一种轻量级、可扩展的脚本语言，被设计用于嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。它以其简洁的语法、高效的执行性能和极小的内存占用而闻名。</p><p>在 Redis 的上下文中，Lua 脚本提供了一种在 Redis 服务器端执行复杂逻辑的强大能力。</p><h4 id="2-为什么-Redis-要支持-Lua-脚本？"><a href="#2-为什么-Redis-要支持-Lua-脚本？" class="headerlink" title="2. 为什么 Redis 要支持 Lua 脚本？"></a><strong>2. 为什么 Redis 要支持 Lua 脚本？</strong></h4><ul><li><strong>原子性 (Atomicity)</strong>: 这是在 Redis 中使用 Lua 最核心的原因。Redis 会将整个 Lua 脚本作为一个单独的命令来执行，<strong>在脚本执行期间，不会有其他客户端的命令被插入执行</strong>。这完美地解决了需要组合多个 Redis 命令才能完成一个业务逻辑时，可能出现的竞态条件问题。例如前面提到的“判断锁并删除锁”的操作，如果分两步执行，就不是原子的，而封装在 Lua 脚本中就是原子的。</li><li><strong>减少网络开销</strong>: 对于需要多次与 Redis 交互的复杂操作，可以将所有逻辑封装在一个 Lua 脚本中，一次性发送给 Redis 服务器。客户端只需发送一次请求，而不是多次，这显著减少了客户端与服务器之间的网络往返时间（RTT），提升了性能。</li><li><strong>代码复用</strong>: 编写好的 Lua 脚本可以被缓存（通过 <code>SCRIPT LOAD</code> 命令生成一个 SHA1 校验和），之后客户端可以通过这个简短的 SHA1 校验和（使用 <code>EVALSHA</code> 命令）来调用脚本，避免了每次都发送完整的脚本内容。</li></ul><h4 id="3-如何在-Redis-中使用-Lua-脚本？"><a href="#3-如何在-Redis-中使用-Lua-脚本？" class="headerlink" title="3. 如何在 Redis 中使用 Lua 脚本？"></a><strong>3. 如何在 Redis 中使用 Lua 脚本？</strong></h4><p>通过 EVAL 或 EVALSHA 命令来执行。</p><p>EVAL script numkeys key [key …] arg [arg …]</p><ul><li><code>script</code>: 要执行的 Lua 脚本字符串。</li><li><code>numkeys</code>: 后面跟的 <code>key</code> 参数的数量。这有助于 Redis 正确地将参数区分为键名（<code>KEYS</code>）和普通参数（<code>ARGV</code>），这对于 Redis Cluster 模式下的路由至关重要。</li><li><code>key [key ...]</code>：脚本中要操作的 Redis 键，在 Lua 脚本中可以通过全局变量 <code>KEYS</code> table（例如 <code>KEYS[1]</code>）来访问。</li><li><code>arg [arg ...]</code>：传递给脚本的额外参数，在 Lua 脚本中可以通过全局变量 <code>ARGV</code> table（例如 <code>ARGV[1]</code>）来访问。</li></ul><p><strong>示例：实现一个安全的库存扣减</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本逻辑：检查库存是否充足，如果充足则扣减并返回1，否则返回0</span></span><br><span class="line"><span class="comment">-- KEYS[1]: 库存的 key，例如 &quot;product:1001:stock&quot;</span></span><br><span class="line"><span class="comment">-- ARGV[1]: 本次要扣减的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">local</span> quantity = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> stock &gt;= quantity <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;decrby&#x27;</span>, KEYS[<span class="number">1</span>], quantity)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个脚本保证了“读取库存”和“扣减库存”两个操作的原子性，避免了在高并发下超卖的问题。</p><hr><h3 id="Token-认证机制详解"><a href="#Token-认证机制详解" class="headerlink" title="Token 认证机制详解"></a><strong>Token 认证机制详解</strong></h3><h4 id="1-Token-是什么？"><a href="#1-Token-是什么？" class="headerlink" title="1. Token 是什么？"></a><strong>1. Token 是什么？</strong></h4><p>Token（令牌）是在服务端生成的一串加密字符串，作为客户端进行请求的一个“凭证”。当用户第一次登录成功后，服务端会生成一个 Token 并返回给客户端。之后，客户端在每次请求需要身份认证的接口时，都需要在请求头（通常是 <code>Authorization</code> 字段）中携带这个 Token。服务端接收到请求后，会验证 Token 的有效性，如果验证通过，则处理该请求；否则，拒绝该请求。</p><p>一个典型的 Token 是 <strong>JWT (JSON Web Token)</strong>，它由三部分组成，用 <code>.</code> 分隔：</p><ul><li><strong>Header (头部)</strong>: 包含了令牌的类型（<code>typ</code>，即 JWT）和所使用的签名算法（<code>alg</code>，如 HMAC SHA256 或 RSA）。</li><li><strong>Payload (负载)</strong>: 包含了“声明 (claims)”，是存放实际需要传递的数据的地方。例如用户ID（<code>sub</code>）、签发时间（<code>iat</code>）、过期时间（<code>exp</code>）以及其他自定义的用户信息。<strong>注意：Payload 部分是 Base64 编码的，并非加密，因此不应存放敏感信息。</strong></li><li><strong>Signature (签名)</strong>: 对前两部分（Header 和 Payload）使用指定的算法和存储在服务端的密钥（secret）进行签名。这个签名的作用是<strong>防止数据被篡改</strong>。服务端收到 Token 后，会用同样的算法和密钥重新计算签名，并与 Token 中的签名进行比对，若一致，则说明 Token 未被篡改且是可信的。</li></ul><h4 id="2-Token-认证原理（工作流程）"><a href="#2-Token-认证原理（工作流程）" class="headerlink" title="2. Token 认证原理（工作流程）"></a><strong>2. Token 认证原理（工作流程）</strong></h4><ol><li><strong>登录</strong>: 用户使用用户名和密码发起登录请求。</li><li><strong>验证</strong>: 服务端验证用户的凭据是否正确。</li><li><strong>签发 Token</strong>: 验证成功后，服务端根据用户ID、角色等信息，结合密钥（secret），生成一个 Token。</li><li><strong>返回 Token</strong>: 服务端将生成的 Token 返回给客户端。</li><li><strong>存储 Token</strong>: 客户端（浏览器、App）将 Token 存储起来，通常放在 <code>localStorage</code>、<code>sessionStorage</code> 或 <code>HttpOnly</code> 的 Cookie 中。</li><li><strong>携带 Token 请求</strong>: 客户端在后续每次请求受保护的 API 时，都会在 HTTP 请求头的 <code>Authorization</code> 字段中附上 Token，格式通常为 <code>Bearer &lt;token&gt;</code>。</li><li><strong>验证 Token</strong>: 服务端收到请求后，从请求头中解析出 Token，然后：<ul><li>验证签名是否正确，确保 Token 未被篡改。</li><li>检查 Token 是否在有效期内（<code>exp</code> 声明）。</li><li>如果验证通过，则从 Payload 中获取用户信息，执行业务逻辑并返回结果。</li><li>如果验证失败，则返回 <code>401 Unauthorized</code> 错误。</li></ul></li></ol><h4 id="3-为什么使用-Token？（与-Session-的区别）"><a href="#3-为什么使用-Token？（与-Session-的区别）" class="headerlink" title="3. 为什么使用 Token？（与 Session 的区别）"></a><strong>3. 为什么使用 Token？（与 Session 的区别）</strong></h4><p>在 Web 开发早期，<code>Session-Cookie</code> 机制是主流。服务端在用户登录后创建一个 Session 对象存储在内存或 Redis 中，并生成一个 Session ID，通过 Cookie 返回给浏览器。浏览器后续请求会自动带上这个 Session ID，服务端根据 ID 找到对应的 Session 信息来识别用户。</p><p><strong>Token 机制相比 Session 机制，核心优势在于“无状态性 (Statelessness)”</strong>，这带来了以下好处：</p><table><thead><tr><th>特性对比</th><th>Session 机制</th><th>Token 机制</th><th>优势说明</th></tr></thead><tbody><tr><td><strong>状态存储</strong></td><td><strong>有状态 (Stateful)</strong>。Session 信息需存储在服务端。</td><td><strong>无状态 (Stateless)</strong>。用户信息包含在 Token 的 Payload 中，服务端无需存储。</td><td><strong>减轻服务端压力</strong>。服务端不需要为每个在线用户维护一个 Session 对象。</td></tr><tr><td><strong>可扩展性</strong></td><td><strong>差</strong>。在分布式或集群环境下，需要解决 Session 共享问题（如 Session Sticky、Session Replication、集中存储）。</td><td><strong>好</strong>。由于服务端不存储状态，任何一台服务器只要有相同的密钥，就能验证 Token，天然适合分布式和微服务架构。</td><td><strong>轻松实现水平扩展</strong>。增加服务器节点无需额外配置 Session 共享。</td></tr><tr><td><strong>跨域支持</strong></td><td><strong>有限</strong>。基于 Cookie 的 Session 机制在跨域（CORS）场景下处理起来比较麻烦。</td><td><strong>优秀</strong>。Token 可以通过 HTTP 请求头发送，不受同源策略限制，非常适合前后端分离和跨域 API 调用。</td><td><strong>适应现代架构</strong>。完美支持 SPA（单页应用）、移动 App 等多种客户端。</td></tr><tr><td><strong>安全性</strong></td><td>依赖 Cookie 机制，可能遭受 CSRF 攻击。</td><td>如果 Token 存储在 <code>localStorage</code>，可能遭受 XSS 攻击。需要综合考虑存储方式。</td><td>两者各有安全风险点，需配合其他安全策略。Token 机制不依赖 Cookie，更灵活。</td></tr><tr><td><strong>适用性</strong></td><td>适合传统的、一体化的 Web 应用。</td><td>适合现代的、分布式的、跨终端的（Web, Mobile, IoT）应用架构。</td><td>Token 更具通用性和前瞻性。</td></tr></tbody></table><h4 id="4-双令牌策略-Access-Token-Refresh-Token"><a href="#4-双令牌策略-Access-Token-Refresh-Token" class="headerlink" title="4. 双令牌策略 (Access Token + Refresh Token)"></a><strong>4. 双令牌策略 (Access Token + Refresh Token)</strong></h4><ul><li><strong>Q: 为什么不用单个 Token？</strong><ul><li><strong>如果 Token 有效期很长（如一个月）</strong>: 安全风险高。一旦 Token 在此期间被窃取，攻击者可以长时间冒充用户身份进行操作。</li><li><strong>如果 Token 有效期很短（如 15 分钟）</strong>: 用户体验差。用户需要频繁地重新登录，这是无法接受的。</li></ul></li><li><strong>A: 双令牌策略应运而生，完美平衡了安全性和用户体验。</strong><ul><li><strong>Access Token (访问令牌)</strong>: 它的有效期<strong>非常短</strong>（如 15 分钟到 1 小时）。它被用于访问受保护的资源，由于其生命周期短，即使被窃取，攻击者能造成的危害也有限。</li><li><strong>Refresh Token (刷新令牌)</strong>: 它的有效期<strong>很长</strong>（如 7 天或 30 天）。它的<strong>唯一作用</strong>是用来获取新的 Access Token。Refresh Token 本身不包含任何权限信息，不能用于直接访问 API。</li></ul></li><li><strong>双令牌工作流程（静默刷新）</strong><ol><li><strong>首次登录</strong>: 用户登录成功，服务端返回一个短期的 <code>Access Token</code> 和一个长期的 <code>Refresh Token</code>。客户端将两者都存储起来。</li><li><strong>正常访问</strong>: 客户端使用 <code>Access Token</code> 访问 API。服务端验证 <code>Access Token</code> 通过，返回数据。</li><li><strong>Access Token 过期</strong>: 客户端再次使用过期的 <code>Access Token</code> 访问 API，服务端返回 <code>401 Unauthorized</code> 错误，并可能带上一个特定错误码，告知客户端是“令牌过期”而非“无效令牌”。</li><li><strong>静默刷新</strong>: 客户端的请求拦截器捕获到这个 <code>401</code> 错误后，<strong>不会立即跳转到登录页</strong>。而是自动发起一个特殊的请求，携带那个长期的 <code>Refresh Token</code> 去访问一个专门的刷新接口（如 <code>/api/token/refresh</code>）。</li><li><strong>签发新令牌</strong>: 服务端验证 <code>Refresh Token</code> 的有效性（通常会将其存储在 Redis 或数据库中进行比对，以实现强制下线功能）。如果验证通过，就生成一个<strong>新的 Access Token</strong>（有时也会生成一个新的 <code>Refresh Token</code>，这被称为刷新令牌滚动策略）并返回给客户端。</li><li><strong>重试请求</strong>: 客户端收到新的 <code>Access Token</code> 后，用它替换掉本地旧的 <code>Access Token</code>，然后<strong>自动重新发送刚才因令牌过期而失败的那个请求</strong>。</li><li><strong>无感体验</strong>: 整个过程对用户是透明的，用户感觉不到令牌已经过期并被刷新，实现了“静默刷新”，体验非常流畅。</li><li><strong>Refresh Token 过期</strong>: 如果 <code>Refresh Token</code> 也过期了，那么刷新接口会返回错误，此时客户端才会真正清除用户凭证并引导用户重新登录。</li></ol></li></ul><h4 id="5-Token-相关场景与面试题"><a href="#5-Token-相关场景与面试题" class="headerlink" title="5. Token 相关场景与面试题"></a><strong>5. Token 相关场景与面试题</strong></h4><ul><li><strong>面试题 1：“Token 应该存储在哪里？localStorage、sessionStorage 还是 Cookie？”</strong><ul><li><p><strong>回答要点</strong>:</p><ul><li><strong>localStorage&#x2F;sessionStorage</strong>:<ul><li><strong>优点</strong>: 方便 JavaScript 直接读写，容量较大（5MB）。</li><li><strong>缺点</strong>: 容易受到 <strong>XSS (跨站脚本攻击)</strong>。如果网站存在 XSS 漏洞，攻击者可以执行 JS 代码直接窃取存储在其中的 Token。</li></ul></li><li><strong>Cookie (HttpOnly)</strong>:<ul><li><strong>优点</strong>: 设置为 <code>HttpOnly</code> 后，JavaScript 将无法读写该 Cookie，可以有效<strong>防御 XSS 攻击</strong>。浏览器会自动在同域请求中携带它。</li><li><strong>缺点</strong>: 容易受到 <strong>CSRF (跨站请求伪造)</strong> 攻击。攻击者可以诱导用户点击恶意链接，浏览器会自动带上用户的 Cookie 去请求你的网站，执行非用户本意的操作。需要配合 Anti-CSRF Token 等机制来防御。容量较小（4KB）。</li></ul></li><li><strong>最佳实践&#x2F;结论</strong>: 没有绝对完美的选择，需要权衡。<ul><li><strong>高安全性方案</strong>: 将 <code>Refresh Token</code> 存储在 <code>HttpOnly</code> 的 Cookie 中（防止 XSS），将 <code>Access Token</code> 存储在内存中（变量里，页面刷新丢失）或 <code>sessionStorage</code> 中。同时，后端接口必须实施 CSRF 防御策略。</li><li><strong>主流实践方案 (前后端分离)</strong>: 将 Token 存储在 <code>localStorage</code> 中，并在 <code>Authorization</code> 请求头中携带。同时，前端必须严格做好输入过滤和内容转义，尽最大努力防止 XSS 漏洞的出现。</li></ul></li></ul><p>好的，我们来详细探讨<strong>双令牌（Dual Token）的存储方案。这种方案是现代 Web 安全认证的常见模式，主要用于解决传统 JWT（JSON Web Token）方案中的一些安全问题，尤其是防止 XSS（跨站脚本攻击）和 CSRF（跨站请求伪造）攻击</strong>。</p><p>双令牌方案的核心思想是：将用户认证所需的权限信息分为两个独立的令牌，并采用不同的存储和传输方式，以达到更高的安全性。这两个令牌通常是：</p><ol><li><strong>访问令牌（Access Token）</strong></li><li><strong>刷新令牌（Refresh Token）</strong></li></ol><h3 id="1-访问令牌-Access-Token"><a href="#1-访问令牌-Access-Token" class="headerlink" title="1. 访问令牌 (Access Token)"></a>1. 访问令牌 (Access Token)</h3><p>访问令牌是用于<strong>访问受保护资源</strong>的凭证。它通常是一个<strong>有效期很短</strong>的 JWT。</p><ul><li><strong>作用</strong>：携带用户的身份信息和权限，用于后端 API 接口的认证。后端在收到请求时，会验证这个令牌的有效性（签名、有效期）。</li><li><strong>有效期</strong>：<strong>非常短</strong>，通常只有几分钟到几小时。这极大地降低了令牌被盗后造成的损失。</li><li><strong>存储方案</strong>：为了防止 XSS 攻击，访问令牌通常不应该存储在浏览器本地的 <code>localStorage</code> 或 <code>sessionStorage</code> 中，因为这些存储空间可以被恶意脚本访问。<ul><li><strong>推荐方案</strong>：存储在<strong>内存中</strong>。当用户关闭浏览器标签页时，令牌就会被清除。这意味着用户每次打开新标签页都需要重新获取令牌，但这是为了安全牺牲一些便利性。</li><li><strong>次优方案</strong>：存储在<strong>HTTP-only Cookie</strong> 中。这种 Cookie 只能由服务器设置，无法通过 JavaScript 脚本读取，有效防止了 XSS 攻击。但是，它仍然可能受到 CSRF 攻击的风险。</li></ul></li></ul><h3 id="2-刷新令牌-Refresh-Token"><a href="#2-刷新令牌-Refresh-Token" class="headerlink" title="2. 刷新令牌 (Refresh Token)"></a>2. 刷新令牌 (Refresh Token)</h3><p>刷新令牌是用于<strong>获取新的访问令牌</strong>的凭证。它通常是一个<strong>有效期很长</strong>的令牌，可以用于在访问令牌过期后，无感地重新获取一个新的。</p><ul><li><strong>作用</strong>：当访问令牌过期时，客户端携带刷新令牌向认证服务器请求一个新的访问令牌。</li><li><strong>有效期</strong>：<strong>很长</strong>，通常是几天、几周甚至几个月。</li><li><strong>存储方案</strong>：由于刷新令牌是获取访问令牌的关键，它的存储必须<strong>绝对安全</strong>。<ul><li><strong>推荐方案</strong>：存储在<strong>HTTP-only Cookie</strong> 中。HTTP-only 属性可以防止恶意脚本（XSS）读取该令牌。同时，由于刷新令牌只发送给认证服务器，并且不用于访问其他 API，可以采取一些额外的安全措施，如 CSRF 令牌或 SameSite Cookie 属性，来防止 CSRF 攻击。</li><li><strong>注意</strong>：刷新令牌<strong>绝对不应该</strong>存储在 <code>localStorage</code> 中。</li></ul></li></ul><h3 id="双令牌工作流程（结合存储方案）"><a href="#双令牌工作流程（结合存储方案）" class="headerlink" title="双令牌工作流程（结合存储方案）"></a>双令牌工作流程（结合存储方案）</h3><ol><li><strong>首次登录</strong>：<ul><li>用户通过用户名&#x2F;密码登录。</li><li>认证服务器验证通过后，生成一个<strong>访问令牌（Access Token）和一个刷新令牌（Refresh Token）</strong>。</li><li>服务器将刷新令牌设置到 <strong>HTTP-only Cookie</strong> 中，发送给浏览器。</li><li>服务器将访问令牌返回给前端，前端将其存储在<strong>内存中</strong>。</li></ul></li><li><strong>访问受保护资源</strong>：<ul><li>前端发起 API 请求时，从内存中取出访问令牌，并将其放在请求头（如 <code>Authorization: Bearer &lt;AccessToken&gt;</code>）中发送给后端。</li><li>后端 API 服务器验证访问令牌的有效性，如果有效则返回数据。</li></ul></li><li><strong>访问令牌过期</strong>：<ul><li>一段时间后，访问令牌过期。前端再次发起 API 请求时，后端会返回一个 401 Unauthorized 错误。</li><li>前端捕获到这个错误后，会发起一个<strong>刷新请求</strong>（通常是向一个专门的 <code>/refresh</code> 接口），这个请求会自动带上存储在 HTTP-only Cookie 中的刷新令牌。</li></ul></li><li><strong>刷新令牌工作</strong>：<ul><li>认证服务器收到刷新请求，验证刷新令牌的有效性。</li><li>如果刷新令牌有效，服务器会生成一个新的<strong>访问令牌</strong>和（可选）一个新的<strong>刷新令牌</strong>。</li><li>服务器将新的访问令牌返回给前端，前端更新内存中的令牌。</li><li>服务器将新的刷新令牌设置到 <strong>HTTP-only Cookie</strong> 中。</li><li>前端使用新的访问令牌重新发起之前的 API 请求。</li></ul></li></ol><h3 id="为什么这个方案更安全？"><a href="#为什么这个方案更安全？" class="headerlink" title="为什么这个方案更安全？"></a>为什么这个方案更安全？</h3><ol><li><strong>防止 XSS 攻击</strong>：最敏感的刷新令牌存储在 HTTP-only Cookie 中，脚本无法读取。而访问令牌虽然存储在内存中，但其有效期短，即使被盗，也很快会失效。</li><li><strong>防止 CSRF 攻击</strong>：刷新令牌通常只用于一个特定的 <code>/refresh</code> 接口，并且可以与 CSRF 令牌（或 SameSite Cookie）结合使用，进一步降低风险。同时，由于其他 API 接口不依赖于 Cookie 中的刷新令牌，而是依赖于请求头中的访问令牌，因此无法被 CSRF 攻击者利用。</li><li><strong>提升用户体验</strong>：尽管访问令牌有效期很短，但用户无需频繁登录，因为刷新令牌可以在后台无感地获取新令牌。</li></ol><p>总之，双令牌方案通过将令牌职责分离和采用不同的存储机制，在保证用户体验的同时，显著提升了系统的安全性，是现代 Web 应用中一种非常成熟和推荐的认证模式。</p></li></ul></li><li><strong>面试题 2：“用户点击“退出登录”时，Token 如何失效？”</strong><ul><li><strong>回答要点</strong>:<ul><li><h4 id="核心观点：无状态-JWT-的特性决定了“退出登录”的本质"><a href="#核心观点：无状态-JWT-的特性决定了“退出登录”的本质" class="headerlink" title="核心观点：无状态 JWT 的特性决定了“退出登录”的本质"></a>核心观点：无状态 JWT 的特性决定了“退出登录”的本质</h4><p>首先，要明确指出 JWT 的核心特点是<strong>无状态</strong>。这意味着服务器<strong>无法主动</strong>让一个已经签发出去的令牌失效，这与传统的 Session 机制（服务器可以主动销毁会话）有本质区别。因此，“退出登录”的实现方式也截然不同。</p><h4 id="1-客户端实现（常规退出登录）"><a href="#1-客户端实现（常规退出登录）" class="headerlink" title="1. 客户端实现（常规退出登录）"></a>1. 客户端实现（常规退出登录）</h4><ul><li><strong>实现方式</strong>：这是最简单、最常见的方案，适用于用户主动退出登录的情况。</li><li><strong>具体操作</strong>：<ul><li>前端代码在用户点击“退出登录”时，执行一个简单的操作：<strong>从本地存储（如 localStorage、sessionStorage、内存或 Cookie）中删除 Access Token</strong>。</li><li>一旦令牌被删除，前端后续的请求将无法携带有效的 <code>Authorization</code> 头，服务器会返回 401 错误，从而实现了“退出登录”的效果。</li></ul></li><li><strong>局限性</strong>：这种方法只是一个<strong>客户端行为</strong>。如果令牌被复制或被攻击者截获，它在过期之前仍然是有效的。</li></ul><h4 id="2-服务端实现（强制下线或即时失效）"><a href="#2-服务端实现（强制下线或即时失效）" class="headerlink" title="2. 服务端实现（强制下线或即时失效）"></a>2. 服务端实现（强制下线或即时失效）</h4><ul><li><strong>引入背景</strong>：当需要实现更严格的安全需求时，如“管理员踢人下线”、“用户修改密码后所有设备下线”或“令牌泄露后立即失效”，单纯的客户端清除是不够的。此时，我们必须打破无状态的特性，引入服务端的状态管理。</li><li><strong>方案一：黑名单机制 (Blacklist)</strong><ul><li><strong>工作原理</strong>：<ol><li>服务端维护一个高效、可快速查找的<strong>黑名单列表</strong>（通常使用 <strong>Redis 的 Set 数据结构</strong>，因为它具有 O(1) 的查找效率）。</li><li>在用户退出登录或需要强制下线时，将该 JWT 的唯一标识 <code>jti</code>（或整个令牌本身）添加到这个黑名单中。</li><li>为黑名单中的条目设置一个<strong>过期时间</strong>，该过期时间应与令牌本身的剩余有效期一致。</li><li>在每次验证 JWT 的过程中，除了校验签名和过期时间外，额外增加一步：<strong>检查该令牌的 jti 是否存在于黑名单中</strong>。如果存在，则认证失败。</li></ol></li></ul></li><li><strong>方案二：基于 Refresh Token 的管理</strong><ul><li><strong>工作原理</strong>：这种方案是基于<strong>双令牌模式</strong>设计的，更优雅地解决了问题。<ol><li>服务器在签发 <code>Access Token</code> 和 <code>Refresh Token</code> 时，会将 <code>Refresh Token</code> 存入数据库或 Redis 中。</li><li>当用户点击“退出登录”或需要强制下线时，服务器<strong>删除</strong>或<strong>标记失效</strong>存储在服务器端的 <code>Refresh Token</code>。</li><li>当用户的 <code>Access Token</code> 过期后，它将无法通过 <code>Refresh Token</code> 换取新的 <code>Access Token</code>，因为服务器端的 <code>Refresh Token</code> 已经失效。这样，用户就无法继续保持登录状态。</li></ol></li></ul></li></ul><h3 id="总结与对比"><a href="#总结与对比" class="headerlink" title="总结与对比"></a>总结与对比</h3><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>客户端清除</strong></td><td>实现简单，开销小。</td><td>安全性最低，无法强制下线。</td><td>用户主动退出登录。</td></tr><tr><td><strong>黑名单机制</strong></td><td>能够实现即时下线，安全可控。</td><td>增加了服务端开销（额外的 Redis 存储和查询）。</td><td>强制下线、修改密码、令牌泄露。</td></tr><tr><td><strong>Refresh Token 方案</strong></td><td>既实现了即时下线，又无需频繁查询黑名单，架构更优雅。</td><td>必须采用双令牌模式，实现相对复杂。</td><td>现代前后端分离应用，对安全性要求较高。</td></tr></tbody></table></li></ul></li></ul></li><li><strong>面试题 3：“请你设计一个支持 Web 端和 App 端统一登录的认证系统。”</strong><ul><li><strong>回答要点</strong>:<ul><li>这正是 Token 认证机制的典型应用场景。我会采用基于 <strong>OAuth 2.0&#x2F;OIDC</strong> 或自定义的**双令牌（Access&#x2F;Refresh Token）**方案。</li><li><strong>统一认证中心 (UAC)</strong>: 建立一个独立的认证服务，负责处理所有客户端（Web, iOS, Android）的登录、注册、Token 签发和刷新。</li><li><strong>API 网关</strong>: 所有业务请求都通过 API 网关。网关的核心职责之一就是<strong>统一鉴权</strong>。它会拦截所有请求，解析 <code>Authorization</code> 头中的 <code>Access Token</code>，调用认证中心或自行验证 Token 的有效性。验证通过后，可以将解析出的用户信息（如用户ID）附加到请求头中，再转发给后端的业务微服务。</li><li><strong>业务微服务</strong>: 业务微服务本身<strong>不再关心 Token 的验证细节</strong>，它们信任来自网关的请求，直接从请求头中获取用户信息进行业务处理，实现了业务与认证的解耦。</li><li><strong>流程</strong>:<ol><li>Web&#x2F;App 客户端引导用户到认证中心进行登录。</li><li>登录成功后，认证中心返回 <code>Access Token</code> 和 <code>Refresh Token</code>。</li><li>客户端保存令牌，后续访问业务 API 时，在请求头携带 <code>Access Token</code>。</li><li>API 网关拦截请求，验证 <code>Access Token</code>。</li><li><code>Access Token</code> 过期后，客户端使用 <code>Refresh Token</code> 向认证中心申请新令牌。</li></ol></li><li>这个架构具有高内聚、低耦合、可扩展性强、安全性高的优点。</li></ul></li></ul></li></ul><h1 id="Redis-详细技术解析"><a href="#Redis-详细技术解析" class="headerlink" title="Redis 详细技术解析"></a>Redis 详细技术解析</h1><h2 id="Redis-核心架构与原理"><a href="#Redis-核心架构与原理" class="headerlink" title="Redis 核心架构与原理"></a>Redis 核心架构与原理</h2><h3 id="内存模型与数据结构"><a href="#内存模型与数据结构" class="headerlink" title="内存模型与数据结构"></a>内存模型与数据结构</h3><p>Redis采用基于内存的存储架构，所有数据都保存在RAM中，这是其高性能的根本原因。Redis使用了多种底层数据结构来实现上层的抽象数据类型：</p><p><strong>SDS（Simple Dynamic String）</strong> Redis没有直接使用C语言的字符串，而是构建了SDS。SDS在字符串头部记录了长度信息，避免了strlen的O(n)复杂度，同时预分配空间减少内存重分配次数。</p><p><strong>跳跃表（Skip List）</strong> 有序集合的底层实现之一，是一种随机化的数据结构，通过多层链表实现O(log N)的查找复杂度。相比红黑树，跳跃表实现更简单，且支持范围查询。</p><p><strong>压缩列表（Ziplist）</strong> 当哈希、列表、有序集合元素较少时使用的紧凑存储结构，所有元素存储在一块连续内存中，节省内存但插入删除效率较低。</p><p><strong>字典（Dict）</strong> Redis的核心数据结构，使用开放寻址法解决哈希冲突，支持渐进式rehash。当负载因子过高时，会创建新的哈希表并逐步迁移数据。</p><h3 id="单线程模型与事件循环"><a href="#单线程模型与事件循环" class="headerlink" title="单线程模型与事件循环"></a>单线程模型与事件循环</h3><p>Redis 6.0之前采用单线程模型处理客户端请求，通过I&#x2F;O多路复用（epoll&#x2F;kqueue）实现高并发。单线程避免了线程切换开销和并发控制问题，但也限制了CPU利用率。</p><p><strong>事件循环机制</strong> Redis使用Reactor模式的事件循环，分为文件事件和时间事件：</p><ul><li>文件事件：处理客户端连接、读写请求</li><li>时间事件：处理定时任务，如过期键删除、持久化等</li></ul><p>Redis 6.0引入了多线程I&#x2F;O，但命令执行仍是单线程，多线程只用于网络I&#x2F;O操作的读写，这样既提高了网络处理能力，又保持了数据操作的原子性。</p><h2 id="数据类型详解与应用场景"><a href="#数据类型详解与应用场景" class="headerlink" title="数据类型详解与应用场景"></a>数据类型详解与应用场景</h2><h3 id="Redis-的数据结构详解"><a href="#Redis-的数据结构详解" class="headerlink" title="Redis 的数据结构详解"></a>Redis 的数据结构详解</h3><hr><p>这是 Redis 最有特色的地方，理解这些数据结构是掌握 Redis 的关键。</p><h4 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1. String (字符串)"></a>1. String (字符串)</h4><ul><li><strong>最基本的数据结构</strong>，可以存储任何类型的数据，比如字符串、数字或二进制数据。一个键最多可以存储 512MB 的值。</li><li><strong>常用命令</strong>:<ul><li><code>SET key value</code>: 设置键值对。</li><li><code>GET key</code>: 获取键对应的值。</li><li><code>INCR key</code>: 将键对应的值加 1，常用于计数器。</li><li><code>MSET key1 value1 key2 value2</code>: 同时设置多个键值对。</li><li><code>MGET key1 key2</code>: 同时获取多个键的值。</li></ul></li><li><strong>应用场景</strong>: 缓存、计数器、分布式锁等。</li></ul><h4 id="2-Hash-哈希"><a href="#2-Hash-哈希" class="headerlink" title="2. Hash (哈希)"></a>2. Hash (哈希)</h4><ul><li><strong>类似于一个键值对的集合</strong>。一个哈希键可以存储多个字段（field）和对应的值（value），非常适合存储对象。</li><li><strong>常用命令</strong>:<ul><li><code>HSET key field value</code>: 设置哈希键中一个字段的值。</li><li><code>HGET key field</code>: 获取哈希键中一个字段的值。</li><li><code>HGETALL key</code>: 获取哈希键中所有的字段和值。</li><li><code>HMSET key field1 value1 field2 value2</code>: 同时设置多个字段。</li><li><code>HDEL key field1 field2</code>: 删除一个或多个字段。</li></ul></li><li><strong>应用场景</strong>: 存储用户信息（如<code>user:100</code>作为键，<code>name</code>、<code>age</code>、<code>city</code>作为字段），商品信息等。</li></ul><h4 id="3-List-列表"><a href="#3-List-列表" class="headerlink" title="3. List (列表)"></a>3. List (列表)</h4><ul><li><strong>一个有序的、可以重复的字符串集合</strong>。可以从列表的头部或尾部添加或删除元素。</li><li><strong>常用命令</strong>:<ul><li><code>LPUSH key value1 value2</code>: 从列表的头部插入一个或多个值。</li><li><code>RPUSH key value1 value2</code>: 从列表的尾部插入一个或多个值。</li><li><code>LPOP key</code>: 从列表的头部移除并返回一个值。</li><li><code>RPOP key</code>: 从列表的尾部移除并返回一个值。</li><li><code>LRANGE key start stop</code>: 获取列表中指定范围的元素。</li></ul></li><li><strong>应用场景</strong>: 消息队列（队列、栈）、最新文章列表、历史记录等。</li></ul><h4 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4. Set (集合)"></a>4. Set (集合)</h4><ul><li><strong>一个无序的、不重复的字符串集合</strong>。集合提供了交集、并集和差集等操作。</li><li><strong>常用命令</strong>:<ul><li><code>SADD key member1 member2</code>: 向集合中添加一个或多个成员。</li><li><code>SMEMBERS key</code>: 获取集合中的所有成员。</li><li><code>SISMEMBER key member</code>: 判断一个成员是否在集合中。</li><li><code>SINTER key1 key2</code>: 求两个集合的交集。</li><li><code>SUNION key1 key2</code>: 求两个集合的并集。</li></ul></li><li><strong>应用场景</strong>: 社交网络中的共同好友、标签系统、去重等。</li></ul><h4 id="5-Sorted-Set-有序集合"><a href="#5-Sorted-Set-有序集合" class="headerlink" title="5. Sorted Set (有序集合)"></a>5. Sorted Set (有序集合)</h4><ul><li><strong>和集合类似，但每个成员都会关联一个分数（score）</strong>。通过这个分数，可以对集合中的成员进行排序。分数可以重复，但成员必须唯一。</li><li><strong>常用命令</strong>:<ul><li><code>ZADD key score1 member1 score2 member2</code>: 向有序集合中添加一个或多个带分数的成员。</li><li><code>ZRANGE key start stop</code>: 按分数从小到大排序，获取指定范围的成员。</li><li><code>ZREVRANGE key start stop</code>: 按分数从大到小排序，获取指定范围的成员。</li><li><code>ZSCORE key member</code>: 获取一个成员的分数。</li><li><code>ZINCRBY key increment member</code>: 给指定成员的分数增加指定值。</li></ul></li><li><strong>应用场景</strong>: 排行榜（游戏分数、热点新闻）、带权重的任务队列等。</li></ul><h3 id="Redis-的持久化机制"><a href="#Redis-的持久化机制" class="headerlink" title="Redis 的持久化机制"></a>Redis 的持久化机制</h3><hr><p>Redis 提供了两种持久化方式，可以将数据从内存保存到硬盘，确保数据不会因为服务重启而丢失。</p><h4 id="1-RDB-Redis-Database"><a href="#1-RDB-Redis-Database" class="headerlink" title="1. RDB (Redis Database)"></a>1. RDB (Redis Database)</h4><ul><li><strong>快照方式</strong>。它会在指定的时间间隔内，将内存中的数据快照写入到磁盘上一个二进制文件中（<code>dump.rdb</code>）。</li><li><strong>优点</strong>: RDB 文件是一个非常紧凑的二进制文件，非常适合备份和灾难恢复。</li><li><strong>缺点</strong>: 每次保存都会丢失从上次快照到现在之间的数据。</li></ul><h4 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2. AOF (Append Only File)"></a>2. AOF (Append Only File)</h4><ul><li><strong>日志方式</strong>。它会记录每一次对 Redis 数据库的写操作命令，并以追加（append）的方式写入到文件中。当 Redis 重启时，会重新执行 AOF 文件中的命令来恢复数据。</li><li><strong>优点</strong>: 数据丢失风险低，可以配置为每秒同步一次，或者每执行一个命令就同步一次。</li><li><strong>缺点</strong>: AOF 文件通常比 RDB 文件大，且恢复速度可能较慢。</li></ul><p>在实际应用中，通常会<strong>同时使用 RDB 和 AOF</strong>，以获得更高的可靠性。</p><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String是Redis最基础的数据类型，底层可以是SDS、整数或浮点数。</p><p><strong>常用命令</strong>：SET、GET、INCR、DECR、APPEND、GETRANGE <strong>应用场景</strong>：</p><ul><li>缓存：存储用户会话、配置信息</li><li>计数器：网站访问量、点赞数（INCR原子性保证）</li><li>分布式锁：SET key value NX EX seconds</li><li>限流：结合EXPIRE实现滑动窗口限流</li></ul><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash类型适合存储对象，避免了将对象序列化为JSON字符串的开销。</p><p><strong>底层实现</strong>：元素较少时使用ziplist，元素较多时使用hashtable <strong>应用场景</strong>：</p><ul><li>存储用户信息：HSET user:1001 name “张三” age 25</li><li>购物车：HSET cart:1001 product:123 2</li><li>配置管理：分类存储不同模块的配置</li></ul><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>List是双向链表实现，支持在两端进行O(1)的插入和删除操作。</p><p><strong>常用命令</strong>：LPUSH、RPUSH、LPOP、RPOP、LRANGE、BLPOP <strong>应用场景</strong>：</p><ul><li>消息队列：生产者LPUSH，消费者BRPOP实现阻塞队列</li><li>最新列表：朋友圈动态、商品评论</li><li>栈和队列：LPUSH+LPOP实现栈，LPUSH+RPOP实现队列</li></ul><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Set是无序集合，元素唯一，底层使用hashtable或intset实现。</p><p><strong>集合运算</strong>：SINTER（交集）、SUNION（并集）、SDIFF（差集） <strong>应用场景</strong>：</p><ul><li>去重：统计网站独立访客</li><li>社交关系：共同好友、推荐用户</li><li>标签系统：用户标签、文章分类</li><li>抽奖系统：SRANDMEMBER随机抽取</li></ul><h3 id="Sorted-Set类型"><a href="#Sorted-Set类型" class="headerlink" title="Sorted Set类型"></a>Sorted Set类型</h3><p>有序集合，每个元素关联一个分数，按分数排序。底层使用跳跃表和哈希表。</p><p><strong>应用场景</strong>：</p><ul><li>排行榜：游戏积分、热搜榜</li><li>延时队列：分数为执行时间戳</li><li>范围查询：按时间、按分数范围获取数据</li></ul><h2 id="持久化机制深度解析"><a href="#持久化机制深度解析" class="headerlink" title="持久化机制深度解析"></a>持久化机制深度解析</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB通过fork子进程，将内存数据快照写入磁盘。</p><p><strong>优点</strong>：</p><ul><li>文件紧凑，适合备份和灾难恢复</li><li>恢复速度快</li><li>对Redis性能影响小（子进程操作）</li></ul><p><strong>缺点</strong>：</p><ul><li>数据丢失风险：两次快照间的数据可能丢失</li><li>fork过程会阻塞主进程</li><li>大数据集fork耗时较长</li></ul><p><strong>触发条件</strong>：</p><ul><li>手动执行SAVE或BGSAVE命令</li><li>配置自动触发：save 900 1（900秒内至少1个键改变）</li><li>主从复制时自动生成RDB</li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF记录每个写命令，通过重放命令恢复数据。</p><p><strong>写入时机</strong>：</p><ul><li>always：每个写命令立即同步，安全但性能低</li><li>everysec：每秒同步一次，平衡安全性和性能</li><li>no：由操作系统决定同步时机，性能高但安全性低</li></ul><p><strong>AOF重写</strong>： AOF文件会越来越大，Redis提供重写机制优化：</p><ul><li>遍历内存数据，用最少命令重建AOF文件</li><li>重写期间的新命令写入AOF重写缓冲区</li><li>原子性替换旧AOF文件</li></ul><p><strong>混合持久化</strong>： Redis 4.0引入RDB+AOF混合模式，重写时以RDB格式写入基础数据，增量命令以AOF格式追加，兼顾了恢复速度和数据安全。</p><h2 id="缓存问题与解决方案"><a href="#缓存问题与解决方案" class="headerlink" title="缓存问题与解决方案"></a>缓存问题与解决方案</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在的数据，缓存无法生效，请求直达数据库。</p><p><strong>解决方案</strong>：</p><ol><li><strong>空值缓存</strong>：查询结果为空时也缓存，设置较短过期时间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">    redis.setex(key, <span class="number">60</span>, <span class="string">&quot;null&quot;</span>);  <span class="comment">// 缓存空值60秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>布隆过滤器</strong>：预先将所有可能存在的数据哈希到位数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BloomFilter&lt;String&gt; filter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()), <span class="number">1000000</span>, <span class="number">0.01</span>);</span><br><span class="line"><span class="comment">// 查询前先检查布隆过滤器</span></span><br><span class="line"><span class="keyword">if</span> (!filter.mightContain(key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 一定不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>参数校验</strong>：在API层面进行参数合法性校验</li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>热点数据过期瞬间，大量并发请求击穿缓存。</p><p><strong>解决方案</strong>：</p><ol><li><strong>互斥锁</strong>：只允许一个线程查询数据库并重建缓存</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span> + key;</span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(lockKey, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>)) &#123;  <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                data = database.query(key);  <span class="comment">// 查询数据库</span></span><br><span class="line">                redis.setex(key, <span class="number">3600</span>, data);  <span class="comment">// 重建缓存</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                redis.del(lockKey);  <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);  <span class="comment">// 等待其他线程重建缓存</span></span><br><span class="line">            <span class="keyword">return</span> getData(key);  <span class="comment">// 递归重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>热点数据永不过期</strong>：逻辑上设置过期时间，物理上不过期，异步更新</li><li><strong>预热机制</strong>：系统启动时预先加载热点数据</li><li><strong>二级缓存</strong>：L1缓存过期后，先返回L2缓存数据，异步更新L1</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量缓存同时过期或Redis宕机，请求涌向数据库。</p><p><strong>解决方案</strong>：</p><ol><li><strong>过期时间随机化</strong>：避免同时过期</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> baseExpire + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);  <span class="comment">// 基础时间+随机时间</span></span><br><span class="line">redis.setex(key, randomExpire, data);</span><br></pre></td></tr></table></figure><ol><li><strong>多级缓存架构</strong>：<ul><li>L1：本地缓存（如Caffeine）</li><li>L2：Redis分布式缓存</li><li>L3：数据库</li></ul></li><li><strong>限流降级</strong>：使用Sentinel、Hystrix等组件</li><li><strong>Redis高可用</strong>：主从复制、哨兵模式、集群部署</li></ol><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>系统启动时预先加载热点数据到缓存。</p><p><strong>实现方式</strong>：</p><ol><li><strong>定时任务预热</strong>：凌晨低峰期执行</li><li><strong>手动预热</strong>：管理后台触发预热任务</li><li><strong>实时预热</strong>：监控系统发现热点数据自动预热</li></ol><h2 id="数据一致性保证"><a href="#数据一致性保证" class="headerlink" title="数据一致性保证"></a>数据一致性保证</h2><h3 id="Cache-Aside模式（旁路缓存）"><a href="#Cache-Aside模式（旁路缓存）" class="headerlink" title="Cache Aside模式（旁路缓存）"></a>Cache Aside模式（旁路缓存）</h3><p>应用程序负责维护缓存和数据库的一致性。</p><p><strong>读操作</strong>：</p><ol><li>先读缓存，命中则返回</li><li>缓存不命中，查询数据库</li><li>将数据写入缓存并返回</li></ol><p><strong>写操作</strong>：</p><ol><li>先更新数据库</li><li>删除缓存（让下次读取时重新加载）</li></ol><p><strong>为什么是删除而不是更新缓存？</strong></p><ul><li>更新缓存可能存在并发问题</li><li>复杂查询的缓存更新成本高</li><li>删除缓存更简单可靠</li></ul><h3 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h3><p>解决读写并发导致的数据不一致问题。</p><p><strong>实现步骤</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Object data)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 删除缓存</span></span><br><span class="line">    redis.del(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 更新数据库</span></span><br><span class="line">    database.update(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 延时删除缓存（异步）</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);  <span class="comment">// 延时500ms</span></span><br><span class="line">            redis.del(key);     <span class="comment">// 再次删除缓存</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;延时删除缓存失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>延时时间设置</strong>：通常为主从同步时间 + 读数据库时间 + 几十毫秒</p><h3 id="基于消息队列的最终一致性"><a href="#基于消息队列的最终一致性" class="headerlink" title="基于消息队列的最终一致性"></a>基于消息队列的最终一致性</h3><p>使用消息队列异步处理缓存更新，保证最终一致性。</p><p><strong>实现流程</strong>：</p><ol><li>更新数据库，发送消息到队列</li><li>消息消费者删除相关缓存</li><li>消费失败时重试，保证最终一致性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送缓存删除消息</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    userDao.update(user);  <span class="comment">// 更新数据库</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送缓存删除消息（事务提交后发送）</span></span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TransactionSynchronizationAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCommit</span><span class="params">()</span> &#123;</span><br><span class="line">                cacheDeleteMQ.send(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式事务方案"><a href="#分布式事务方案" class="headerlink" title="分布式事务方案"></a>分布式事务方案</h3><p>对于强一致性要求高的场景，可以使用分布式事务。</p><p><strong>2PC（两阶段提交）</strong>：</p><ul><li>准备阶段：协调者询问参与者是否准备好</li><li>提交阶段：所有参与者都准备好则提交，否则回滚</li></ul><p><strong>TCC（Try-Confirm-Cancel）</strong>：</p><ul><li>Try：尝试执行，预留资源</li><li>Confirm：确认提交</li><li>Cancel：取消执行，释放资源</li></ul><h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><h3 id="基于SET命令的分布式锁"><a href="#基于SET命令的分布式锁" class="headerlink" title="基于SET命令的分布式锁"></a>基于SET命令的分布式锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDistributedLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String lockKey, String requestId, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">releaseLock</span><span class="params">(String lockKey, String requestId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, Collections.singletonList(lockKey),</span><br><span class="line">                                 Collections.singletonList(requestId));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>.equals(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:user:1001&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tryLock(lockKey, requestId, <span class="number">30000</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行业务逻辑</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        releaseLock(lockKey, requestId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h3><p>为了解决单点故障问题，Redis官方提出了Redlock算法。</p><p><strong>算法步骤</strong>：</p><ol><li>获取当前时间戳</li><li>依次向N个Redis实例申请锁</li><li>如果在大多数实例（N&#x2F;2+1）上获取锁成功，且总耗时小于锁超时时间，则认为获取锁成功</li><li>锁的有效时间 &#x3D; 初始有效时间 - 获取锁消耗的时间</li><li>释放锁时，向所有Redis实例发送释放命令</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Redlock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Jedis&gt; jedisInstances;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String resource, <span class="type">int</span> ttl)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">quorum</span> <span class="operator">=</span> jedisInstances.size() / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">successCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Jedis jedis : jedisInstances) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lockInstance(jedis, resource, ttl)) &#123;</span><br><span class="line">                successCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        <span class="keyword">if</span> (successCount &gt;= quorum &amp;&amp; elapsedTime &lt; ttl) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unlock(resource);  <span class="comment">// 释放已获取的锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁的问题与优化"><a href="#锁的问题与优化" class="headerlink" title="锁的问题与优化"></a>锁的问题与优化</h3><p><strong>锁超时问题</strong>： 业务执行时间超过锁超时时间，锁自动释放，可能导致并发问题。</p><p><strong>解决方案</strong>：</p><ol><li><strong>看门狗机制</strong>：定时续期锁的过期时间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatchDog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ScheduledExecutorService</span> <span class="variable">scheduler</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startWatchDog</span><span class="params">(String lockKey, String requestId)</span> &#123;</span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 续期锁</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) else return 0 end&quot;</span>;</span><br><span class="line">            jedis.eval(script, Arrays.asList(lockKey), </span><br><span class="line">                      Arrays.asList(requestId, <span class="string">&quot;30&quot;</span>));</span><br><span class="line">        &#125;, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>合理评估业务执行时间</strong>：设置足够的锁超时时间</li></ol><p><strong>锁竞争激烈问题</strong>： 大量线程竞争同一把锁，导致性能下降。</p><p><strong>解决方案</strong>：</p><ol><li><strong>分段锁</strong>：将资源分段，减少锁竞争</li><li><strong>队列锁</strong>：使用List实现公平锁</li><li><strong>自旋锁优化</strong>：适当的退避算法</li></ol><h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>假设会发生并发冲突，在操作数据前先获取锁。</p><p><strong>Redis实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Redis分布式锁实现悲观锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWithPessimisticLock</span><span class="params">(String userId, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:account:&quot;</span> + userId;</span><br><span class="line">    <span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (tryLock(lockKey, requestId, <span class="number">30000</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 查询账户余额</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> getBalance(userId);</span><br><span class="line">            <span class="keyword">if</span> (balance &gt;= amount) &#123;</span><br><span class="line">                <span class="comment">// 扣减余额</span></span><br><span class="line">                updateBalance(userId, balance - amount);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientBalanceException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            releaseLock(lockKey, requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LockAcquisitionException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>假设不会发生冲突，在更新时检查数据是否被修改。</p><p><strong>基于版本号的乐观锁</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateWithOptimisticLock</span><span class="params">(String userId, <span class="type">int</span> amount, <span class="type">int</span> expectedVersion)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用Lua脚本保证原子性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> </span><br><span class="line">        <span class="string">&quot;local current = redis.call(&#x27;hmget&#x27;, KEYS[1], &#x27;balance&#x27;, &#x27;version&#x27;) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;if current[2] == ARGV[2] then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  if tonumber(current[1]) &gt;= tonumber(ARGV[1]) then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    redis.call(&#x27;hmset&#x27;, KEYS[1], &#x27;balance&#x27;, current[1] - ARGV[1], &#x27;version&#x27;, current[2] + 1) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return 1 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return -1 &quot;</span> +  <span class="comment">// 余额不足</span></span><br><span class="line">        <span class="string">&quot;  end &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  return 0 &quot;</span> +     <span class="comment">// 版本号不匹配</span></span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;account:&quot;</span> + userId;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, Arrays.asList(key), </span><br><span class="line">                              Arrays.asList(String.valueOf(amount), String.valueOf(expectedVersion)));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> ((Long) result).intValue();</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 更新成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockException</span>(<span class="string">&quot;数据已被修改&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientBalanceException</span>(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于CAS的乐观锁</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWithCAS</span><span class="params">(String key, Function&lt;String, String&gt; updater)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">currentValue</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 计算新值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newValue</span> <span class="operator">=</span> updater.apply(currentValue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. CAS更新</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[2]) else return nil end&quot;</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> redis.eval(script, Arrays.asList(key), </span><br><span class="line">                                  Arrays.asList(currentValue, newValue));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 更新成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新失败，重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="悲观锁-vs-乐观锁选择"><a href="#悲观锁-vs-乐观锁选择" class="headerlink" title="悲观锁 vs 乐观锁选择"></a>悲观锁 vs 乐观锁选择</h3><p><strong>悲观锁适用场景</strong>：</p><ul><li>写操作频繁，冲突概率高</li><li>业务逻辑复杂，重试成本高</li><li>对数据一致性要求严格</li></ul><p><strong>乐观锁适用场景</strong>：</p><ul><li>读多写少，冲突概率低</li><li>业务逻辑简单，重试成本低</li><li>对性能要求高</li></ul><h2 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Master负责写操作，Slave负责读操作，通过复制实现数据同步。</p><p><strong>复制原理</strong>：</p><ol><li>Slave向Master发送PSYNC命令</li><li>Master执行BGSAVE生成RDB文件</li><li>Master将RDB文件发送给Slave</li><li>Slave载入RDB文件</li><li>Master将缓冲区的写命令发送给Slave</li><li>后续写命令实时同步</li></ol><p><strong>部分重同步</strong>： 网络断连后，Slave只需要同步断连期间的命令，而不是完整重同步。</p><h3 id="哨兵模式（Sentinel）"><a href="#哨兵模式（Sentinel）" class="headerlink" title="哨兵模式（Sentinel）"></a>哨兵模式（Sentinel）</h3><p>哨兵负责监控Master状态，在Master故障时自动进行故障转移。</p><p><strong>哨兵职责</strong>：</p><ul><li>监控：定期ping Master和Slave</li><li>通知：故障时通知管理员和客户端</li><li>故障转移：自动将Slave提升为新Master</li><li>配置管理：为客户端提供服务发现</li></ul><p><strong>故障转移流程</strong>：</p><ol><li>哨兵发现Master下线（主观下线）</li><li>多个哨兵确认Master下线（客观下线）</li><li>选举领导哨兵执行故障转移</li><li>选择合适的Slave作为新Master</li><li>修改其他Slave的配置指向新Master</li><li>通知客户端Master地址变更</li></ol><h3 id="集群模式（Cluster）"><a href="#集群模式（Cluster）" class="headerlink" title="集群模式（Cluster）"></a>集群模式（Cluster）</h3><p>Redis Cluster通过分片实现横向扩展和高可用。</p><p><strong>分片算法</strong>： 使用CRC16算法计算key的哈希值，然后对16384取模得到槽位号。</p><p><strong>节点通信</strong>： 使用Gossip协议在节点间交换状态信息，包括节点上线&#x2F;下线、槽位分配等。</p><p><strong>故障转移</strong>： 当Master节点故障时，其Slave自动提升为新Master，过程对客户端透明。</p><p><strong>数据迁移</strong>： 集群扩容时，需要将部分槽位从现有节点迁移到新节点。</p><h4 id="Redis-哈希槽（Hash-Slot）详解"><a href="#Redis-哈希槽（Hash-Slot）详解" class="headerlink" title="Redis 哈希槽（Hash Slot）详解"></a>Redis 哈希槽（Hash Slot）详解</h4><p>在 Redis Cluster 中，数据不是存储在单个节点上，而是被分散存储在多个节点上。为了实现这种分散存储，Redis 引入了 <strong>哈希槽（hash slot）</strong> 的概念。</p><h4 id="1-什么是哈希槽？"><a href="#1-什么是哈希槽？" class="headerlink" title="1. 什么是哈希槽？"></a>1. 什么是哈希槽？</h4><p>Redis Cluster 一共有 <strong>16384 个哈希槽（slot）</strong>，编号从 0 到 16383。集群中的每个键（key）都会通过一个固定的算法映射到这 16384 个哈希槽中的一个，然后这些哈希槽会被分配给集群中的不同节点。</p><h4 id="2-键如何映射到哈希槽？"><a href="#2-键如何映射到哈希槽？" class="headerlink" title="2. 键如何映射到哈希槽？"></a>2. 键如何映射到哈希槽？</h4><p>Redis 使用一个简单的算法来决定一个键属于哪个哈希槽：<br>$$<br>slot&#x3D;CRC16(key)(mod16384)<br>$$</p><ul><li><strong>CRC16(key)</strong>：对键名执行 CRC16 校验和计算。</li><li><strong>mod 16384</strong>：将 CRC16 校验和的结果对 16384 取模，得到的结果就是这个键所属的哈希槽编号。</li></ul><p>例如，如果你有一个键 <code>mykey</code>，Redis 会计算 <code>CRC16(&#39;mykey&#39;) % 16384</code>，得到一个 0 到 16383 之间的数字。</p><h4 id="3-哈希槽如何分配给节点？"><a href="#3-哈希槽如何分配给节点？" class="headerlink" title="3. 哈希槽如何分配给节点？"></a>3. 哈希槽如何分配给节点？</h4><p>集群中的每个节点负责管理一部分哈希槽。例如，一个三节点的集群可以这样分配哈希槽：</p><ul><li><strong>节点 A</strong>：负责哈希槽 0 到 5460。</li><li><strong>节点 B</strong>：负责哈希槽 5461 到 10922。</li><li><strong>节点 C</strong>：负责哈希槽 10923 到 16383。</li></ul><p>当一个客户端需要操作一个键时，它会首先计算这个键所属的哈希槽，然后根据哈希槽与节点的映射关系，找到负责该哈希槽的节点，并向其发送请求。</p><p>如果客户端请求的键不在当前连接的节点上，这个节点会返回一个 <code>MOVED</code> 重定向错误，告诉客户端正确的节点地址，客户端会根据这个地址重新发起请求。</p><h4 id="4-哈希槽的优势"><a href="#4-哈希槽的优势" class="headerlink" title="4. 哈希槽的优势"></a>4. 哈希槽的优势</h4><ul><li><strong>高可用性</strong>：当一个节点失效时，它所负责的哈希槽可以被其他节点接管，从而保证数据的可用性。</li><li><strong>弹性伸缩</strong>：<ul><li><strong>添加节点</strong>：当需要扩展集群时，可以添加新节点，并从现有节点上迁移一部分哈希槽到新节点上，这个过程是增量的，不需要停机。</li><li><strong>移除节点</strong>：当需要缩减集群时，可以将某个节点上的所有哈希槽迁移到其他节点，然后移除该节点。</li></ul></li></ul><h2 id="性能监控与优化"><a href="#性能监控与优化" class="headerlink" title="性能监控与优化"></a>性能监控与优化</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>Redis提供慢查询日志功能，记录执行时间超过阈值的命令。</p><p><strong>配置参数</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">slowlog-log-slower-than</span> <span class="number">10000</span>  <span class="comment"># 超过10毫秒记录</span></span><br><span class="line"><span class="string">slowlog-max-len</span> <span class="number">128</span>           <span class="comment"># 最多保存128条记录</span></span><br></pre></td></tr></table></figure><p><strong>查看慢查询</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLOWLOG GET 10  <span class="comment"># 获取最近10条慢查询</span></span><br></pre></td></tr></table></figure><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p>使用MEMORY命令分析内存使用情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MEMORY USAGE key         <span class="comment"># 查看key占用内存</span></span><br><span class="line">MEMORY STATS            <span class="comment"># 查看内存统计信息</span></span><br><span class="line">MEMORY DOCTOR           <span class="comment"># 内存使用建议</span></span><br></pre></td></tr></table></figure><h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><p><strong>避免大key</strong>：</p><ul><li>单个key的value不要超过10KB</li><li>集合类型元素数量控制在合理范围</li><li>使用SCAN代替KEYS命令</li></ul><p><strong>合理使用数据结构</strong>：</p><ul><li>小对象使用Hash而不是多个String</li><li>合理设置ziplist等压缩结构的阈值</li><li>使用位图(bitmap)存储布尔类型大数据集</li></ul><p><strong>网络优化</strong>：</p><ul><li>使用Pipeline批量操作</li><li>合理设置客户端连接池</li><li>启用TCP_NODELAY选项</li></ul><p><strong>持久化优化</strong>：</p><ul><li>根据业务需求选择RDB或AOF</li><li>合理配置自动保存条件</li><li>在从节点上进行持久化操作</li></ul><p>这些详细的技术点涵盖了Redis的核心概念、常见问题解决方案和实际应用场景，是Redis技术面试的重要考查内容。掌握这些知识点并能结合实际项目经验进行说明，将大大提高面试通过率。</p><h2 id="内存管理与淘汰机制"><a href="#内存管理与淘汰机制" class="headerlink" title="内存管理与淘汰机制"></a>内存管理与淘汰机制</h2><h3 id="内存淘汰策略详解"><a href="#内存淘汰策略详解" class="headerlink" title="内存淘汰策略详解"></a>内存淘汰策略详解</h3><p>当Redis内存使用达到maxmemory限制时，会根据配置的策略淘汰数据。</p><p><strong>8种淘汰策略</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对所有key</span></span><br><span class="line">noeviction          <span class="comment"># 不淘汰，写入返回错误</span></span><br><span class="line">allkeys-lru         <span class="comment"># 所有key中淘汰最近最少使用</span></span><br><span class="line">allkeys-lfu         <span class="comment"># 所有key中淘汰最少频率使用</span></span><br><span class="line">allkeys-random      <span class="comment"># 所有key中随机淘汰</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对设置了过期时间的key</span></span><br><span class="line">volatile-lru        <span class="comment"># 过期key中淘汰最近最少使用</span></span><br><span class="line">volatile-lfu        <span class="comment"># 过期key中淘汰最少频率使用</span></span><br><span class="line">volatile-random     <span class="comment"># 过期key中随机淘汰</span></span><br><span class="line">volatile-ttl        <span class="comment"># 过期key中淘汰即将过期的</span></span><br></pre></td></tr></table></figure><p><strong>LRU vs LFU 实现细节</strong>： Redis的LRU并非严格的LRU，而是近似LRU算法：</p><ul><li>每个key都有24位的时钟字段记录访问时间</li><li>淘汰时随机采样5个key（可配置），选择时钟值最小的</li></ul><p>LFU算法维护访问频率：</p><ul><li>高16位存储上次访问时间</li><li>低8位存储访问频率计数器</li><li>计数器采用概率性递增，避免频率无限增长</li></ul><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p><strong>产生原因</strong>：</p><ul><li>频繁的数据更新导致内存分配&#x2F;释放</li><li>Redis使用jemalloc内存分配器，存在内存对齐</li><li>删除大key后留下内存空洞</li></ul><p><strong>检测方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"><span class="comment"># 关注 mem_fragmentation_ratio 指标</span></span><br><span class="line"><span class="comment"># 比值 &gt; 1.5 表示碎片较多</span></span><br><span class="line"><span class="comment"># 比值 &lt; 1 表示使用了swap，性能严重下降</span></span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><ol><li><strong>内存整理</strong>（Redis 4.0+）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET activedefrag <span class="built_in">yes</span>        <span class="comment"># 开启自动整理</span></span><br><span class="line">CONFIG SET active-defrag-threshold-lower 10  <span class="comment"># 碎片率超过10%启动</span></span><br><span class="line">MEMORY PURGE                       <span class="comment"># 手动触发整理</span></span><br></pre></td></tr></table></figure><ol><li><strong>重启Redis</strong>：最彻底但影响服务可用性</li><li><strong>优化数据结构</strong>：减少小对象，使用Hash存储相关数据</li></ol><h2 id="过期策略与删除机制"><a href="#过期策略与删除机制" class="headerlink" title="过期策略与删除机制"></a>过期策略与删除机制</h2><h3 id="三种过期删除策略"><a href="#三种过期删除策略" class="headerlink" title="三种过期删除策略"></a>三种过期删除策略</h3><p><strong>定时删除</strong>：设置过期时间时创建定时器，到期立即删除</p><ul><li>优点：及时释放内存</li><li>缺点：消耗CPU资源创建和管理定时器</li></ul><p><strong>惰性删除</strong>：访问key时检查是否过期，过期则删除</p><ul><li>优点：CPU友好，只在必要时删除</li><li>缺点：内存不友好，过期key可能长期占用内存</li></ul><p><strong>定期删除</strong>：定期随机检查部分key，删除过期的</p><ul><li>Redis的实际策略，平衡CPU和内存使用</li></ul><h3 id="Redis过期删除实现"><a href="#Redis过期删除实现" class="headerlink" title="Redis过期删除实现"></a>Redis过期删除实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的过期删除逻辑</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">activeExpireCycle</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">current_db</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">timelimit_exit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">        redisDb *db = server.db + current_db % server.dbnum;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">iteration</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (iteration &lt; <span class="number">20</span>) &#123;  <span class="comment">// 最多检查20个key</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sampled</span> <span class="operator">=</span> <span class="number">0</span>, expired = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 随机选择key检查过期</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                dictEntry *de = dictGetRandomKey(db-&gt;expires);</span><br><span class="line">                <span class="keyword">if</span> (de == NULL) <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                sampled++;</span><br><span class="line">                <span class="keyword">if</span> (keyIsExpired(db, de)) &#123;</span><br><span class="line">                    deleteExpiredKey(db, de);</span><br><span class="line">                    expired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果过期比例超过25%，继续下轮检查</span></span><br><span class="line">            <span class="keyword">if</span> (expired &gt; <span class="number">5</span>) iteration++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current_db++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构底层实现深度解析"><a href="#数据结构底层实现深度解析" class="headerlink" title="数据结构底层实现深度解析"></a>数据结构底层实现深度解析</h2><h3 id="压缩列表（ZipList）演进"><a href="#压缩列表（ZipList）演进" class="headerlink" title="压缩列表（ZipList）演进"></a>压缩列表（ZipList）演进</h3><p>Redis 7.0用ListPack替代了ZipList，解决了级联更新问题。</p><p><strong>ZipList问题</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZipList结构导致的级联更新</span></span><br><span class="line"><span class="comment">// 当插入元素导致某个entry的长度改变时</span></span><br><span class="line"><span class="comment">// 可能引起后续所有entry的重新编码</span></span><br></pre></td></tr></table></figure><p><strong>ListPack优势</strong>：</p><ul><li>每个元素独立编码，避免级联更新</li><li>支持从尾部遍历，提高某些操作效率</li></ul><h3 id="字典扩容与rehash"><a href="#字典扩容与rehash" class="headerlink" title="字典扩容与rehash"></a>字典扩容与rehash</h3><p>Redis字典使用增量式rehash避免阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渐进式rehash实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">empty_visits</span> <span class="operator">=</span> n * <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 跳过空桶</span></span><br><span class="line">        <span class="keyword">while</span> (d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == NULL) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 迁移桶中所有元素</span></span><br><span class="line">        dictEntry *de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            dictEntry *nextde = de-&gt;next;</span><br><span class="line">            unsigned <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = NULL;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络模型与性能优化"><a href="#网络模型与性能优化" class="headerlink" title="网络模型与性能优化"></a>网络模型与性能优化</h2><h3 id="Redis-6-0-多线程I-O"><a href="#Redis-6-0-多线程I-O" class="headerlink" title="Redis 6.0 多线程I&#x2F;O"></a>Redis 6.0 多线程I&#x2F;O</h3><p>多线程只用于网络I&#x2F;O，命令执行仍是单线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程I/O处理流程</span></span><br><span class="line"><span class="keyword">void</span> *IOThreadMain(<span class="keyword">void</span> *myid) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待主线程分配任务</span></span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[id]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (io_threads_list[id] &amp;&amp; io_threads_pending[id] == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;io_threads_cond[id], &amp;io_threads_mutex[id]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理读写任务</span></span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line">        listRewind(io_threads_list[id], &amp;li);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *c = listNodeValue(ln);</span><br><span class="line">            <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                writeToClient(c, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_READ) &#123;</span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        io_threads_pending[id] = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;io_threads_mutex[id]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端连接管理"><a href="#客户端连接管理" class="headerlink" title="客户端连接管理"></a>客户端连接管理</h3><p><strong>连接池配置优化</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Jedis连接池配置</span></span><br><span class="line"><span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">config.setMaxTotal(<span class="number">200</span>);                    <span class="comment">// 最大连接数</span></span><br><span class="line">config.setMaxIdle(<span class="number">50</span>);                      <span class="comment">// 最大空闲连接</span></span><br><span class="line">config.setMinIdle(<span class="number">10</span>);                      <span class="comment">// 最小空闲连接</span></span><br><span class="line">config.setTestOnBorrow(<span class="literal">true</span>);               <span class="comment">// 获取连接时测试</span></span><br><span class="line">config.setTestOnReturn(<span class="literal">true</span>);               <span class="comment">// 归还连接时测试</span></span><br><span class="line">config.setTestWhileIdle(<span class="literal">true</span>);              <span class="comment">// 空闲时测试</span></span><br><span class="line">config.setTimeBetweenEvictionRunsMillis(<span class="number">30000</span>);  <span class="comment">// 检查间隔</span></span><br><span class="line">config.setNumTestsPerEvictionRun(<span class="number">10</span>);       <span class="comment">// 每次检查连接数</span></span><br><span class="line">config.setMinEvictableIdleTimeMillis(<span class="number">60000</span>);     <span class="comment">// 最小空闲时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config, <span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br></pre></td></tr></table></figure><p><strong>Pipeline优化</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pipeline批量操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchSet</span><span class="params">(Map&lt;String, String&gt; data)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource()) &#123;</span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : data.entrySet()) &#123;</span><br><span class="line">            pipeline.set(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Object&gt; results = pipeline.syncAndReturnAll();</span><br><span class="line">        <span class="comment">// 处理结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级数据类型与应用"><a href="#高级数据类型与应用" class="headerlink" title="高级数据类型与应用"></a>高级数据类型与应用</h2><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>用于基数统计，占用内存固定（12KB），误差率0.81%。</p><p><strong>实现原理</strong>：</p><ul><li>基于概率算法，通过观察随机数的最大前导零个数估算基数</li><li>使用调和平均数减少误差</li><li>适用于UV统计等场景</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网站UV统计</span></span><br><span class="line">PFADD uv:20230815 user1 user2 user3</span><br><span class="line">PFCOUNT uv:20230815                    <span class="comment"># 获取UV数量</span></span><br><span class="line">PFMERGE uv:week uv:20230815 uv:20230816  <span class="comment"># 合并多日数据</span></span><br></pre></td></tr></table></figure><h3 id="布隆过滤器（Redis-Module）"><a href="#布隆过滤器（Redis-Module）" class="headerlink" title="布隆过滤器（Redis Module）"></a>布隆过滤器（Redis Module）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis布隆过滤器模块</span></span><br><span class="line">BF.RESERVE myfilter 0.01 1000000       <span class="comment"># 创建过滤器，误报率0.01%，预期元素100万</span></span><br><span class="line">BF.ADD myfilter <span class="string">&quot;user123&quot;</span>              <span class="comment"># 添加元素</span></span><br><span class="line">BF.EXISTS myfilter <span class="string">&quot;user123&quot;</span>           <span class="comment"># 检查元素是否存在</span></span><br><span class="line">BF.MADD myfilter item1 item2 item3     <span class="comment"># 批量添加</span></span><br><span class="line">BF.MEXISTS myfilter item1 item2 item3  <span class="comment"># 批量检查</span></span><br></pre></td></tr></table></figure><h3 id="Geo地理位置"><a href="#Geo地理位置" class="headerlink" title="Geo地理位置"></a>Geo地理位置</h3><p>基于Sorted Set实现，使用GeoHash算法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加地理位置</span></span><br><span class="line">GEOADD cities 116.397128 39.916527 <span class="string">&quot;北京&quot;</span> 121.473701 31.230416 <span class="string">&quot;上海&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算距离</span></span><br><span class="line">GEODIST cities <span class="string">&quot;北京&quot;</span> <span class="string">&quot;上海&quot;</span> km</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范围查询</span></span><br><span class="line">GEORADIUS cities 116.397128 39.916527 1000 km WITHDIST WITHCOORD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据成员查询</span></span><br><span class="line">GEORADIUSBYMEMBER cities <span class="string">&quot;北京&quot;</span> 1000 km</span><br></pre></td></tr></table></figure><h2 id="安全性问题与防护"><a href="#安全性问题与防护" class="headerlink" title="安全性问题与防护"></a>安全性问题与防护</h2><h3 id="常见安全漏洞"><a href="#常见安全漏洞" class="headerlink" title="常见安全漏洞"></a>常见安全漏洞</h3><p><strong>命令注入</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误做法：直接拼接用户输入</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;user:&quot;</span> + userInput;  <span class="comment">// userInput可能包含恶意命令</span></span><br><span class="line">jedis.eval(<span class="string">&quot;return redis.call(&#x27;get&#x27;, &#x27;&quot;</span> + key + <span class="string">&quot;&#x27;)&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法：使用参数化查询</span></span><br><span class="line">jedis.eval(<span class="string">&quot;return redis.call(&#x27;get&#x27;, KEYS[1])&quot;</span>, <span class="number">1</span>, key);</span><br></pre></td></tr></table></figure><p><strong>未授权访问</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis.conf安全配置</span></span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1                        <span class="comment"># 绑定指定IP</span></span><br><span class="line">requirepass your_password              <span class="comment"># 设置密码</span></span><br><span class="line">protected-mode <span class="built_in">yes</span>                     <span class="comment"># 开启保护模式</span></span><br><span class="line">port 0                                <span class="comment"># 禁用默认端口</span></span><br><span class="line">port 6380                             <span class="comment"># 使用非标准端口</span></span><br></pre></td></tr></table></figure><p><strong>危险命令禁用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名危险命令</span></span><br><span class="line">rename-command FLUSHDB <span class="string">&quot;&quot;</span>             <span class="comment"># 禁用FLUSHDB</span></span><br><span class="line">rename-command FLUSHALL <span class="string">&quot;&quot;</span>            <span class="comment"># 禁用FLUSHALL</span></span><br><span class="line">rename-command SHUTDOWN <span class="string">&quot;REDIS_SHUTDOWN&quot;</span>  <span class="comment"># 重命名SHUTDOWN</span></span><br><span class="line">rename-command CONFIG <span class="string">&quot;REDIS_CONFIG&quot;</span>   <span class="comment"># 重命名CONFIG</span></span><br></pre></td></tr></table></figure><h3 id="ACL访问控制（Redis-6-0-）"><a href="#ACL访问控制（Redis-6-0-）" class="headerlink" title="ACL访问控制（Redis 6.0+）"></a>ACL访问控制（Redis 6.0+）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">ACL SETUSER alice on &gt;password123 ~cached:* +get +<span class="built_in">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看用户权限</span></span><br><span class="line">ACL LIST</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">ACL DELUSER alice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查权限</span></span><br><span class="line">AUTH alice password123</span><br></pre></td></tr></table></figure><h2 id="监控与运维"><a href="#监控与运维" class="headerlink" title="监控与运维"></a>监控与运维</h2><h3 id="关键监控指标"><a href="#关键监控指标" class="headerlink" title="关键监控指标"></a>关键监控指标</h3><p><strong>性能指标</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过INFO命令获取</span></span><br><span class="line">INFO stats</span><br><span class="line"><span class="comment"># 关注指标：</span></span><br><span class="line"><span class="comment"># - instantaneous_ops_per_sec: QPS</span></span><br><span class="line"><span class="comment"># - keyspace_hits/keyspace_misses: 命中率</span></span><br><span class="line"><span class="comment"># - used_cpu_sys/used_cpu_user: CPU使用率</span></span><br><span class="line"><span class="comment"># - connected_clients: 连接数</span></span><br><span class="line"><span class="comment"># - blocked_clients: 阻塞连接数</span></span><br></pre></td></tr></table></figure><p><strong>内存指标</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"><span class="comment"># 关注指标：</span></span><br><span class="line"><span class="comment"># - used_memory: 已使用内存</span></span><br><span class="line"><span class="comment"># - used_memory_rss: 物理内存占用</span></span><br><span class="line"><span class="comment"># - mem_fragmentation_ratio: 内存碎片率</span></span><br><span class="line"><span class="comment"># - used_memory_peak: 内存使用峰值</span></span><br></pre></td></tr></table></figure><p><strong>持久化指标</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO persistence</span><br><span class="line"><span class="comment"># 关注指标：</span></span><br><span class="line"><span class="comment"># - rdb_last_save_time: 最后RDB保存时间</span></span><br><span class="line"><span class="comment"># - aof_last_rewrite_time_sec: AOF重写耗时</span></span><br><span class="line"><span class="comment"># - aof_current_size: AOF文件大小</span></span><br></pre></td></tr></table></figure><h3 id="故障排查常用命令"><a href="#故障排查常用命令" class="headerlink" title="故障排查常用命令"></a>故障排查常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端连接信息</span></span><br><span class="line">CLIENT LIST</span><br><span class="line">CLIENT INFO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 慢查询分析</span></span><br><span class="line">SLOWLOG GET 10</span><br><span class="line">CONFIG GET slowlog-log-slower-than</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大key查找</span></span><br><span class="line">MEMORY USAGE keyname</span><br><span class="line">redis-cli --bigkeys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 热点key分析</span></span><br><span class="line">redis-cli --hotkeys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 延迟监控</span></span><br><span class="line">LATENCY HISTORY <span class="built_in">command</span></span><br><span class="line">CONFIG SET latency-monitor-threshold 100</span><br></pre></td></tr></table></figure><h2 id="特殊应用场景"><a href="#特殊应用场景" class="headerlink" title="特殊应用场景"></a>特殊应用场景</h2><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p><strong>固定窗口限流</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAllowed</span><span class="params">(String key, <span class="type">int</span> limit, <span class="type">int</span> window)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span> / window;</span><br><span class="line">        <span class="type">String</span> <span class="variable">windowKey</span> <span class="operator">=</span> key + <span class="string">&quot;:&quot;</span> + current;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> </span><br><span class="line">            <span class="string">&quot;local count = redis.call(&#x27;incr&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;if count == 1 then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;end &quot;</span> +</span><br><span class="line">            <span class="string">&quot;return count&quot;</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> (Long) jedis.eval(script, Arrays.asList(windowKey), </span><br><span class="line">                                      Arrays.asList(String.valueOf(window)));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count &lt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滑动窗口限流</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">slidingWindowLimit</span><span class="params">(String key, <span class="type">int</span> limit, <span class="type">int</span> window)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">windowStart</span> <span class="operator">=</span> now - window * <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> </span><br><span class="line">        <span class="string">&quot;redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;local count = redis.call(&#x27;zcard&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;if count &lt; tonumber(ARGV[2]) then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  redis.call(&#x27;zadd&#x27;, KEYS[1], ARGV[3], ARGV[3]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[4]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  return 1 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  return 0 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> (Long) jedis.eval(script, Arrays.asList(key),</span><br><span class="line">        Arrays.asList(String.valueOf(windowStart), String.valueOf(limit),</span><br><span class="line">                     String.valueOf(now), String.valueOf(window)));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSessionManager</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createSession</span><span class="params">(String sessionId, String userId, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;session:&quot;</span> + sessionId;</span><br><span class="line">        Map&lt;String, Object&gt; sessionData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        sessionData.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">        sessionData.put(<span class="string">&quot;createTime&quot;</span>, System.currentTimeMillis());</span><br><span class="line">        </span><br><span class="line">        redisTemplate.opsForHash().putAll(key, sessionData);</span><br><span class="line">        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSession</span><span class="params">(String sessionId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;session:&quot;</span> + sessionId;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">renewSession</span><span class="params">(String sessionId, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;session:&quot;</span> + sessionId;</span><br><span class="line">        <span class="keyword">if</span> (redisTemplate.hasKey(key)) &#123;</span><br><span class="line">            redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息队列实现"><a href="#消息队列实现" class="headerlink" title="消息队列实现"></a>消息队列实现</h3><p><strong>基于List的简单队列</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(String queue, String message)</span> &#123;</span><br><span class="line">        jedis.lpush(queue, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消费者（阻塞式）</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">consume</span><span class="params">(String queue, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = jedis.brpop(timeout, queue);</span><br><span class="line">        <span class="keyword">return</span> result != <span class="literal">null</span> ? result.get(<span class="number">1</span>) : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于Stream的消息队列</strong>（Redis 5.0+）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产消息</span></span><br><span class="line"><span class="string">XADD</span> <span class="string">mystream</span> <span class="string">*</span> <span class="string">field1</span> <span class="string">value1</span> <span class="string">field2</span> <span class="string">value2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建消费者组</span></span><br><span class="line"><span class="string">XGROUP</span> <span class="string">CREATE</span> <span class="string">mystream</span> <span class="string">mygroup</span> <span class="string">$</span> <span class="string">MKSTREAM</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费消息</span></span><br><span class="line"><span class="string">XREADGROUP</span> <span class="string">GROUP</span> <span class="string">mygroup</span> <span class="string">consumer1</span> <span class="string">COUNT</span> <span class="number">10</span> <span class="string">STREAMS</span> <span class="string">mystream</span> <span class="string">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认消息</span></span><br><span class="line"><span class="string">XACK</span> <span class="string">mystream</span> <span class="string">mygroup</span> <span class="string">message_id</span></span><br></pre></td></tr></table></figure><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDelayQueue</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDelayTask</span><span class="params">(String task, <span class="type">long</span> delayTime)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">executeTime</span> <span class="operator">=</span> System.currentTimeMillis() + delayTime;</span><br><span class="line">        jedis.zadd(<span class="string">&quot;delay_queue&quot;</span>, executeTime, task);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getReadyTasks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Set&lt;String&gt; tasks = jedis.zrangeByScore(<span class="string">&quot;delay_queue&quot;</span>, <span class="number">0</span>, now);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!tasks.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 原子性删除已获取的任务</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> </span><br><span class="line">                <span class="string">&quot;local tasks = redis.call(&#x27;zrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;if #tasks &gt; 0 then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;  redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return tasks&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            List&lt;String&gt; result = (List&lt;String&gt;) jedis.eval(script, </span><br><span class="line">                Arrays.asList(<span class="string">&quot;delay_queue&quot;</span>), Arrays.asList(String.valueOf(now)));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能调优技巧"><a href="#性能调优技巧" class="headerlink" title="性能调优技巧"></a>性能调优技巧</h2><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p><strong>使用Hash存储小对象</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐：为每个用户字段单独设置key</span></span><br><span class="line">jedis.set(<span class="string">&quot;user:1001:name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;user:1001:age&quot;</span>, <span class="string">&quot;25&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;user:1001:email&quot;</span>, <span class="string">&quot;zhang@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：使用Hash存储</span></span><br><span class="line">jedis.hset(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">jedis.hset(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;25&quot;</span>);</span><br><span class="line">jedis.hset(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;zhang@example.com&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>合理设置过期时间</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免同时过期导致雪崩</span></span><br><span class="line"><span class="type">int</span> <span class="variable">baseExpire</span> <span class="operator">=</span> <span class="number">3600</span>;  <span class="comment">// 1小时</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> baseExpire + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);  <span class="comment">// 增加0-5分钟随机时间</span></span><br><span class="line">jedis.setex(key, randomExpire, value);</span><br></pre></td></tr></table></figure><h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p><strong>批量操作优化</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Pipeline</span></span><br><span class="line"><span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    pipeline.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">pipeline.sync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用原生批量命令</span></span><br><span class="line">Map&lt;String, String&gt; batch = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ... 填充数据</span></span><br><span class="line">jedis.mset(flattenMap(batch));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p><strong>Lua脚本减少网络往返</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 原子性增加库存</span><br><span class="line"><span class="type">local</span> <span class="variable">current</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> current == <span class="literal">false</span> then</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  -- key不存在</span><br><span class="line"><span class="type">end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">current</span> <span class="operator">=</span> tonumber(current)</span><br><span class="line"><span class="keyword">if</span> current &gt;= tonumber(ARGV[<span class="number">1</span>]) then</span><br><span class="line">    redis.call(<span class="string">&#x27;decrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> current - tonumber(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">2</span>  -- 库存不足</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Linux </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/09/11/hello-world/"/>
      <url>/2025/09/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

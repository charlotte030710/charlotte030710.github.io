<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>框架常用注解</title>
      <link href="/2025/10/01/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2025/10/01/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="🧩-一、Spring-常用注解（IOC-AOP-核心）"><a href="#🧩-一、Spring-常用注解（IOC-AOP-核心）" class="headerlink" title="🧩 一、Spring 常用注解（IOC &#x2F; AOP 核心）"></a>🧩 一、Spring 常用注解（IOC &#x2F; AOP 核心）</h1><h3 id="💠-1-IOC-相关（控制反转）"><a href="#💠-1-IOC-相关（控制反转）" class="headerlink" title="💠 1. IOC 相关（控制反转）"></a>💠 1. IOC 相关（控制反转）</h3><table><thead><tr><th>注解</th><th>作用</th><th>场景</th></tr></thead><tbody><tr><td><code>@Component</code></td><td>标识一个普通组件，交给 Spring 容器管理</td><td>普通类</td></tr><tr><td><code>@Controller</code></td><td>表示控制层组件</td><td>Web 控制器</td></tr><tr><td><code>@Service</code></td><td>表示服务层组件</td><td>业务逻辑层</td></tr><tr><td><code>@Repository</code></td><td>表示 DAO 层组件</td><td>数据访问层</td></tr><tr><td><code>@Autowired</code></td><td>按类型自动注入</td><td>字段、构造器、setter</td></tr><tr><td><code>@Qualifier</code></td><td>与 <code>@Autowired</code> 联合使用，按名称注入</td><td>解决多个 Bean 同类型冲突</td></tr><tr><td><code>@Resource</code></td><td>JSR-250 标准注入，按名称优先</td><td>同上</td></tr><tr><td><code>@Value</code></td><td>注入配置文件中的属性值</td><td>常量、配置字段</td></tr><tr><td><code>@Primary</code></td><td>指定优先注入的 Bean</td><td>同类型 Bean 多个时</td></tr><tr><td><code>@Lazy</code></td><td>延迟加载 Bean</td><td>优化启动性能</td></tr></tbody></table><hr><h3 id="💠-2-AOP-相关（切面编程）"><a href="#💠-2-AOP-相关（切面编程）" class="headerlink" title="💠 2. AOP 相关（切面编程）"></a>💠 2. AOP 相关（切面编程）</h3><table><thead><tr><th>注解</th><th>作用</th><th>场景</th></tr></thead><tbody><tr><td><code>@Aspect</code></td><td>声明一个切面类</td><td>AOP 切面定义</td></tr><tr><td><code>@Before</code></td><td>方法执行前执行通知</td><td>前置通知</td></tr><tr><td><code>@After</code></td><td>方法执行后执行通知</td><td>后置通知（无论异常）</td></tr><tr><td><code>@AfterReturning</code></td><td>方法成功返回后执行</td><td>返回通知</td></tr><tr><td><code>@AfterThrowing</code></td><td>方法异常时执行</td><td>异常通知</td></tr><tr><td><code>@Around</code></td><td>包裹整个方法（可控制执行时机）</td><td>性能监控、事务控制</td></tr><tr><td><code>@Pointcut</code></td><td>定义切入点表达式</td><td>统一复用表达式</td></tr></tbody></table><hr><h3 id="💠-3-配置相关"><a href="#💠-3-配置相关" class="headerlink" title="💠 3. 配置相关"></a>💠 3. 配置相关</h3><table><thead><tr><th>注解</th><th>作用</th><th>场景</th></tr></thead><tbody><tr><td><code>@Configuration</code></td><td>声明配置类（代替 XML）</td><td>JavaConfig</td></tr><tr><td><code>@Bean</code></td><td>注册一个 Bean 到容器</td><td>配合 <code>@Configuration</code></td></tr><tr><td><code>@Import</code></td><td>导入额外配置类</td><td>组合配置</td></tr><tr><td><code>@PropertySource</code></td><td>加载外部 properties 文件</td><td>读取配置</td></tr><tr><td><code>@ComponentScan</code></td><td>扫描指定包</td><td>注册组件</td></tr><tr><td><code>@Conditional</code></td><td>条件加载 Bean</td><td>动态配置</td></tr></tbody></table><hr><h1 id="🌐-二、Spring-MVC-常用注解"><a href="#🌐-二、Spring-MVC-常用注解" class="headerlink" title="🌐 二、Spring MVC 常用注解"></a>🌐 二、Spring MVC 常用注解</h1><h3 id="💠-1-控制层映射"><a href="#💠-1-控制层映射" class="headerlink" title="💠 1. 控制层映射"></a>💠 1. 控制层映射</h3><table><thead><tr><th>注解</th><th>作用</th><th>场景</th></tr></thead><tbody><tr><td><code>@Controller</code></td><td>定义控制器类</td><td>Web 层</td></tr><tr><td><code>@RestController</code></td><td>等价于 <code>@Controller + @ResponseBody</code></td><td>REST 接口</td></tr><tr><td><code>@RequestMapping</code></td><td>定义请求路径、方法</td><td>类或方法级别</td></tr><tr><td><code>@GetMapping</code> &#x2F; <code>@PostMapping</code> &#x2F; <code>@PutMapping</code> &#x2F; <code>@DeleteMapping</code></td><td>简化版请求映射</td><td>REST 风格接口</td></tr><tr><td><code>@RequestParam</code></td><td>获取请求参数</td><td><code>?name=xxx</code></td></tr><tr><td><code>@PathVariable</code></td><td>获取路径参数</td><td><code>/user/&#123;id&#125;</code></td></tr><tr><td><code>@RequestBody</code></td><td>将 JSON 请求体映射为对象</td><td>POST JSON 请求</td></tr><tr><td><code>@ResponseBody</code></td><td>将返回值序列化为 JSON</td><td>REST 返回</td></tr><tr><td><code>@ModelAttribute</code></td><td>绑定模型数据或方法参数</td><td>表单提交</td></tr><tr><td><code>@SessionAttributes</code></td><td>将数据保存到 session</td><td>登录状态存储</td></tr></tbody></table><h3 id="💠-2-异常-返回处理"><a href="#💠-2-异常-返回处理" class="headerlink" title="💠 2. 异常 &amp; 返回处理"></a>💠 2. 异常 &amp; 返回处理</h3><table><thead><tr><th>注解</th><th>作用</th><th>场景</th></tr></thead><tbody><tr><td><code>@ControllerAdvice</code></td><td>全局异常处理类</td><td>全局控制器拦截</td></tr><tr><td><code>@ExceptionHandler</code></td><td>指定异常处理方法</td><td>捕获异常</td></tr><tr><td><code>@ResponseStatus</code></td><td>设置响应状态码</td><td>返回状态控制</td></tr><tr><td><code>@InitBinder</code></td><td>初始化数据绑定器</td><td>参数转换</td></tr></tbody></table><hr><h1 id="💾-三、MyBatis-常用注解"><a href="#💾-三、MyBatis-常用注解" class="headerlink" title="💾 三、MyBatis 常用注解"></a>💾 三、MyBatis 常用注解</h1><table><thead><tr><th>注解</th><th>作用</th><th>场景</th></tr></thead><tbody><tr><td><code>@Mapper</code></td><td>标识为 MyBatis 映射接口</td><td>DAO 层接口</td></tr><tr><td><code>@Select</code> &#x2F; <code>@Insert</code> &#x2F; <code>@Update</code> &#x2F; <code>@Delete</code></td><td>编写 SQL 语句</td><td>简单查询或更新</td></tr><tr><td><code>@Results</code> &#x2F; <code>@Result</code></td><td>字段映射</td><td>数据库字段与实体字段名不同</td></tr><tr><td><code>@Param</code></td><td>指定 SQL 参数名</td><td>多参数方法</td></tr><tr><td><code>@Options</code></td><td>设置主键回填、事务行为等</td><td>插入时主键自动生成</td></tr><tr><td><code>@MapKey</code></td><td>指定返回 Map 的 key</td><td>查询结果 Map 化</td></tr></tbody></table><hr><h1 id="🚀-四、Spring-Boot-常用注解"><a href="#🚀-四、Spring-Boot-常用注解" class="headerlink" title="🚀 四、Spring Boot 常用注解"></a>🚀 四、Spring Boot 常用注解</h1><table><thead><tr><th>注解</th><th>作用</th><th>场景</th></tr></thead><tbody><tr><td><code>@SpringBootApplication</code></td><td>核心入口（含 <code>@Configuration</code>, <code>@EnableAutoConfiguration</code>, <code>@ComponentScan</code>）</td><td>启动类</td></tr><tr><td><code>@EnableAutoConfiguration</code></td><td>启用自动配置</td><td>底层自动装配</td></tr><tr><td><code>@ConfigurationProperties</code></td><td>将配置文件映射为对象</td><td>封装配置类</td></tr><tr><td><code>@EnableConfigurationProperties</code></td><td>开启上面映射功能</td><td>配置类启用</td></tr><tr><td><code>@ConditionalOnProperty</code></td><td>当某配置满足时加载 Bean</td><td>条件化配置</td></tr><tr><td><code>@ConditionalOnMissingBean</code></td><td>Bean 不存在时加载</td><td>自动配置</td></tr><tr><td><code>@SpringBootTest</code></td><td>启动完整 Spring Boot 测试环境</td><td>单元测试</td></tr><tr><td><code>@TestConfiguration</code></td><td>测试专用配置</td><td>隔离测试 Bean</td></tr><tr><td><code>@RestControllerAdvice</code></td><td>全局异常 + REST 接口</td><td>统一异常返回 JSON</td></tr></tbody></table><hr><h1 id="🔐-五、Spring-Security-常用注解"><a href="#🔐-五、Spring-Security-常用注解" class="headerlink" title="🔐 五、Spring Security 常用注解"></a>🔐 五、Spring Security 常用注解</h1><table><thead><tr><th>注解</th><th>作用</th><th>场景</th></tr></thead><tbody><tr><td><code>@EnableWebSecurity</code></td><td>开启 Web 安全配置</td><td>Security 配置类</td></tr><tr><td><code>@Configuration</code></td><td>标识配置类</td><td></td></tr><tr><td><code>@PreAuthorize</code></td><td>方法执行前验证权限</td><td>细粒度控制（SpEL 表达式）</td></tr><tr><td><code>@PostAuthorize</code></td><td>方法执行后再验证权限</td><td>返回后检查</td></tr><tr><td><code>@Secured</code></td><td>指定角色访问权限</td><td>简单权限控制</td></tr><tr><td><code>@RolesAllowed</code></td><td>与 <code>@Secured</code> 类似（JSR-250）</td><td>指定角色</td></tr><tr><td><code>@WithMockUser</code></td><td>测试时模拟登录用户</td><td>单元测试</td></tr><tr><td><code>@AuthenticationPrincipal</code></td><td>获取当前登录用户</td><td>Controller 层</td></tr></tbody></table><hr><h1 id="☁️-六、Spring-Cloud-常用注解（微服务体系）"><a href="#☁️-六、Spring-Cloud-常用注解（微服务体系）" class="headerlink" title="☁️ 六、Spring Cloud 常用注解（微服务体系）"></a>☁️ 六、Spring Cloud 常用注解（微服务体系）</h1><h3 id="💠-1-服务注册与发现（Eureka-Nacos）"><a href="#💠-1-服务注册与发现（Eureka-Nacos）" class="headerlink" title="💠 1. 服务注册与发现（Eureka &#x2F; Nacos）"></a>💠 1. 服务注册与发现（Eureka &#x2F; Nacos）</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@EnableEurekaClient</code> &#x2F; <code>@EnableDiscoveryClient</code></td><td>启用服务注册与发现</td></tr><tr><td><code>@LoadBalanced</code></td><td>启用 Ribbon 负载均衡</td></tr><tr><td><code>@Value</code> &#x2F; <code>@RefreshScope</code></td><td>动态刷新配置（与 Config 一起）</td></tr></tbody></table><h3 id="💠-2-服务调用（OpenFeign）"><a href="#💠-2-服务调用（OpenFeign）" class="headerlink" title="💠 2. 服务调用（OpenFeign）"></a>💠 2. 服务调用（OpenFeign）</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@EnableFeignClients</code></td><td>开启 Feign 客户端</td></tr><tr><td><code>@FeignClient(name=&quot;service-name&quot;)</code></td><td>定义服务调用接口</td></tr><tr><td><code>@RequestMapping</code> &#x2F; <code>@GetMapping</code></td><td>映射远程接口路径</td></tr></tbody></table><h3 id="💠-3-服务网关（Gateway）"><a href="#💠-3-服务网关（Gateway）" class="headerlink" title="💠 3. 服务网关（Gateway）"></a>💠 3. 服务网关（Gateway）</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@EnableGateway</code> <em>(部分版本自带)</em></td><td>启用网关服务</td></tr><tr><td><code>@RequestRateLimiter</code></td><td>限流控制</td></tr><tr><td><code>@EnableDiscoveryClient</code></td><td>注册到注册中心</td></tr></tbody></table><h3 id="💠-4-熔断-限流（Hystrix-Sentinel）"><a href="#💠-4-熔断-限流（Hystrix-Sentinel）" class="headerlink" title="💠 4. 熔断 &amp; 限流（Hystrix &#x2F; Sentinel）"></a>💠 4. 熔断 &amp; 限流（Hystrix &#x2F; Sentinel）</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@EnableHystrix</code> &#x2F; <code>@EnableCircuitBreaker</code></td><td>开启熔断机制</td></tr><tr><td><code>@HystrixCommand(fallbackMethod=&quot;...&quot;)</code></td><td>定义降级逻辑</td></tr><tr><td><code>@SentinelResource(value=&quot;resourceName&quot;, blockHandler=&quot;blockHandler&quot;)</code></td><td>Sentinel 控制限流熔断</td></tr></tbody></table><hr><h1 id="📘-七、面试记忆小技巧"><a href="#📘-七、面试记忆小技巧" class="headerlink" title="📘 七、面试记忆小技巧"></a>📘 七、面试记忆小技巧</h1><table><thead><tr><th>模块</th><th>关键注解记忆点</th></tr></thead><tbody><tr><td><strong>Spring 核心</strong></td><td><code>@Component</code> 系列 + <code>@Autowired</code> + <code>@Configuration</code></td></tr><tr><td><strong>Spring MVC</strong></td><td><code>@RestController</code> + <code>@RequestMapping</code> + <code>@RequestBody</code></td></tr><tr><td><strong>MyBatis</strong></td><td><code>@Mapper</code> + <code>@Select</code> + <code>@Param</code></td></tr><tr><td><strong>Spring Boot</strong></td><td><code>@SpringBootApplication</code> + <code>@ConfigurationProperties</code></td></tr><tr><td><strong>Security</strong></td><td><code>@EnableWebSecurity</code> + <code>@PreAuthorize</code></td></tr><tr><td><strong>Spring Cloud</strong></td><td><code>@EnableDiscoveryClient</code> + <code>@FeignClient</code> + <code>@HystrixCommand</code></td></tr></tbody></table><hr><h1 id="🌱-一、Spring-核心注解运行机制（IOC-AOP）"><a href="#🌱-一、Spring-核心注解运行机制（IOC-AOP）" class="headerlink" title="🌱 一、Spring 核心注解运行机制（IOC &#x2F; AOP）"></a>🌱 一、Spring 核心注解运行机制（IOC &#x2F; AOP）</h1><h3 id="1️⃣-Component-系列注解（Bean-扫描注册流程）"><a href="#1️⃣-Component-系列注解（Bean-扫描注册流程）" class="headerlink" title="1️⃣ @Component 系列注解（Bean 扫描注册流程）"></a>1️⃣ <code>@Component</code> 系列注解（Bean 扫描注册流程）</h3><p><strong>流程图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Spring 启动</span><br><span class="line">  ↓</span><br><span class="line">AnnotationConfigApplicationContext.refresh()</span><br><span class="line">  ↓</span><br><span class="line">ConfigurationClassPostProcessor 解析配置类</span><br><span class="line">  ↓</span><br><span class="line">ComponentScanAnnotationParser 解析 @ComponentScan</span><br><span class="line">  ↓</span><br><span class="line">ClassPathBeanDefinitionScanner 扫描包路径</span><br><span class="line">  ↓</span><br><span class="line">发现带 @Component / @Service / @Repository 的类</span><br><span class="line">  ↓</span><br><span class="line">封装成 BeanDefinition</span><br><span class="line">  ↓</span><br><span class="line">注册到 BeanDefinitionRegistry</span><br><span class="line">  ↓</span><br><span class="line">实例化 Bean → 放入 BeanFactory 容器</span><br></pre></td></tr></table></figure><p><strong>关键类：</strong></p><ul><li><code>ClassPathBeanDefinitionScanner</code></li><li><code>ScannedGenericBeanDefinition</code></li><li><code>DefaultListableBeanFactory</code></li></ul><p><strong>时机：</strong></p><blockquote><p>BeanDefinition 阶段（容器刷新 refresh() 时）</p></blockquote><hr><h3 id="2️⃣-Autowired-注入流程"><a href="#2️⃣-Autowired-注入流程" class="headerlink" title="2️⃣ @Autowired 注入流程"></a>2️⃣ <code>@Autowired</code> 注入流程</h3><p><strong>流程图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">实例化 Bean</span><br><span class="line">  ↓</span><br><span class="line">执行 populateBean()</span><br><span class="line">  ↓</span><br><span class="line">AutowiredAnnotationBeanPostProcessor 处理 @Autowired</span><br><span class="line">  ↓</span><br><span class="line">反射获取依赖字段</span><br><span class="line">  ↓</span><br><span class="line">从 BeanFactory 中查找匹配类型 Bean</span><br><span class="line">  ↓</span><br><span class="line">通过 ReflectionUtils.setField() 注入字段值</span><br></pre></td></tr></table></figure><p><strong>关键类：</strong></p><ul><li><code>AutowiredAnnotationBeanPostProcessor</code></li><li><code>DefaultListableBeanFactory.resolveDependency()</code></li></ul><p><strong>时机：</strong></p><blockquote><p>Bean 初始化阶段（构造完成后，init 前）</p></blockquote><hr><h3 id="3️⃣-Configuration-Bean"><a href="#3️⃣-Configuration-Bean" class="headerlink" title="3️⃣ @Configuration + @Bean"></a>3️⃣ <code>@Configuration</code> + <code>@Bean</code></h3><p><strong>流程图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">启动阶段</span><br><span class="line">  ↓</span><br><span class="line">ConfigurationClassPostProcessor 扫描 @Configuration 类</span><br><span class="line">  ↓</span><br><span class="line">解析 @Bean 方法</span><br><span class="line">  ↓</span><br><span class="line">为配置类生成 CGLIB 代理</span><br><span class="line">  ↓</span><br><span class="line">调用 @Bean 方法时，从容器返回单例对象</span><br></pre></td></tr></table></figure><p><strong>关键类：</strong></p><ul><li><code>ConfigurationClassPostProcessor</code></li><li><code>Enhancer</code>（CGLIB）</li><li><code>BeanDefinitionRegistry</code></li></ul><p><strong>时机：</strong></p><blockquote><p>注册 BeanDefinition 阶段（启动时）</p></blockquote><hr><h3 id="4️⃣-AOP-注解（-Aspect-Around-等）"><a href="#4️⃣-AOP-注解（-Aspect-Around-等）" class="headerlink" title="4️⃣ AOP 注解（@Aspect, @Around 等）"></a>4️⃣ AOP 注解（<code>@Aspect</code>, <code>@Around</code> 等）</h3><p><strong>流程图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">启动时</span><br><span class="line">  ↓</span><br><span class="line">AnnotationAwareAspectJAutoProxyCreator 注册切面</span><br><span class="line">  ↓</span><br><span class="line">解析 @Aspect 类 → 提取切点表达式</span><br><span class="line">  ↓</span><br><span class="line">为目标类创建代理对象（JDK / CGLIB）</span><br><span class="line">  ↓</span><br><span class="line">方法调用时进入代理逻辑</span><br><span class="line">  ↓</span><br><span class="line">执行 Interceptor 链（Before → Around → After）</span><br></pre></td></tr></table></figure><p><strong>关键类：</strong></p><ul><li><code>AnnotationAwareAspectJAutoProxyCreator</code></li><li><code>AspectJExpressionPointcut</code></li><li><code>ProxyFactory</code></li></ul><p><strong>时机：</strong></p><blockquote><p>Bean 初始化结束后创建代理对象阶段</p></blockquote><hr><h1 id="🌐-二、Spring-MVC-注解运行机制"><a href="#🌐-二、Spring-MVC-注解运行机制" class="headerlink" title="🌐 二、Spring MVC 注解运行机制"></a>🌐 二、Spring MVC 注解运行机制</h1><h3 id="1️⃣-RequestMapping、-GetMapping"><a href="#1️⃣-RequestMapping、-GetMapping" class="headerlink" title="1️⃣ @RequestMapping、@GetMapping"></a>1️⃣ <code>@RequestMapping</code>、<code>@GetMapping</code></h3><p><strong>流程图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SpringMVC 启动</span><br><span class="line">  ↓</span><br><span class="line">DispatcherServlet 初始化</span><br><span class="line">  ↓</span><br><span class="line">RequestMappingHandlerMapping 扫描 @Controller 类</span><br><span class="line">  ↓</span><br><span class="line">解析每个方法的 @RequestMapping 路径</span><br><span class="line">  ↓</span><br><span class="line">建立 URL -&gt; HandlerMethod 映射表</span><br><span class="line">  ↓</span><br><span class="line">请求到达时通过 HandlerMapping 匹配</span><br><span class="line">  ↓</span><br><span class="line">调用 HandlerAdapter 执行目标方法</span><br></pre></td></tr></table></figure><p><strong>关键类：</strong></p><ul><li><code>RequestMappingHandlerMapping</code></li><li><code>HandlerMethod</code></li><li><code>DispatcherServlet</code></li></ul><p><strong>时机：</strong></p><blockquote><p>初始化阶段注册映射；请求阶段匹配调用。</p></blockquote><hr><h3 id="2️⃣-RequestBody-ResponseBody"><a href="#2️⃣-RequestBody-ResponseBody" class="headerlink" title="2️⃣ @RequestBody &#x2F; @ResponseBody"></a>2️⃣ <code>@RequestBody</code> &#x2F; <code>@ResponseBody</code></h3><p><strong>流程图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">请求进入 DispatcherServlet</span><br><span class="line">  ↓</span><br><span class="line">HandlerAdapter 调用目标方法</span><br><span class="line">  ↓</span><br><span class="line">检测参数是否有 @RequestBody</span><br><span class="line">  ↓</span><br><span class="line">使用 HttpMessageConverter 反序列化 JSON → Java 对象</span><br><span class="line">  ↓</span><br><span class="line">方法执行完成后检测 @ResponseBody</span><br><span class="line">  ↓</span><br><span class="line">再次通过 HttpMessageConverter 序列化返回对象 → JSON</span><br></pre></td></tr></table></figure><p><strong>关键类：</strong></p><ul><li><code>RequestResponseBodyMethodProcessor</code></li><li><code>MappingJackson2HttpMessageConverter</code></li></ul><p><strong>时机：</strong></p><blockquote><p>请求处理阶段（方法调用前后）</p></blockquote><hr><h1 id="💾-三、MyBatis-注解运行机制"><a href="#💾-三、MyBatis-注解运行机制" class="headerlink" title="💾 三、MyBatis 注解运行机制"></a>💾 三、MyBatis 注解运行机制</h1><p><strong>流程图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Spring 启动时</span><br><span class="line">  ↓</span><br><span class="line">MapperScannerConfigurer 扫描 @Mapper 接口</span><br><span class="line">  ↓</span><br><span class="line">为每个 Mapper 生成 MapperFactoryBean</span><br><span class="line">  ↓</span><br><span class="line">调用时由 MapperProxy 拦截</span><br><span class="line">  ↓</span><br><span class="line">从 MapperMethod 获取对应 SQL（注解或 XML）</span><br><span class="line">  ↓</span><br><span class="line">通过 SqlSessionTemplate 执行 SQL</span><br></pre></td></tr></table></figure><p><strong>关键类：</strong></p><ul><li><code>MapperScannerConfigurer</code></li><li><code>MapperProxy</code></li><li><code>SqlSessionTemplate</code></li></ul><p><strong>时机：</strong></p><blockquote><p>Mapper 代理对象创建阶段 + 调用时动态执行 SQL</p></blockquote><hr><h1 id="🚀-四、Spring-Boot-注解运行机制"><a href="#🚀-四、Spring-Boot-注解运行机制" class="headerlink" title="🚀 四、Spring Boot 注解运行机制"></a>🚀 四、Spring Boot 注解运行机制</h1><h3 id="1️⃣-SpringBootApplication-自动装配流程"><a href="#1️⃣-SpringBootApplication-自动装配流程" class="headerlink" title="1️⃣ @SpringBootApplication 自动装配流程"></a>1️⃣ <code>@SpringBootApplication</code> 自动装配流程</h3><p><strong>流程图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">启动类 @SpringBootApplication</span><br><span class="line">  ↓</span><br><span class="line">@SpringBootApplication = @EnableAutoConfiguration + @ComponentScan + @Configuration</span><br><span class="line">  ↓</span><br><span class="line">@EnableAutoConfiguration 导入 AutoConfigurationImportSelector</span><br><span class="line">  ↓</span><br><span class="line">从 META-INF/spring.factories 读取所有自动配置类</span><br><span class="line">  ↓</span><br><span class="line">判断条件注解（@ConditionalOnClass, @ConditionalOnMissingBean...）</span><br><span class="line">  ↓</span><br><span class="line">符合条件的自动配置类注册到容器</span><br><span class="line">  ↓</span><br><span class="line">完成 Bean 装配</span><br></pre></td></tr></table></figure><p><strong>关键类：</strong></p><ul><li><code>SpringApplication</code></li><li><code>AutoConfigurationImportSelector</code></li><li><code>SpringFactoriesLoader</code></li></ul><p><strong>时机：</strong></p><blockquote><p>启动阶段（容器刷新前）</p></blockquote><hr><h1 id="🔐-五、Spring-Security-注解运行机制"><a href="#🔐-五、Spring-Security-注解运行机制" class="headerlink" title="🔐 五、Spring Security 注解运行机制"></a>🔐 五、Spring Security 注解运行机制</h1><p><strong>流程图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@EnableWebSecurity</span><br><span class="line">  ↓</span><br><span class="line">注册 DelegatingFilterProxy → springSecurityFilterChain</span><br><span class="line">  ↓</span><br><span class="line">加载 WebSecurityConfigurerAdapter</span><br><span class="line">  ↓</span><br><span class="line">配置过滤器链（认证、授权）</span><br><span class="line">  ↓</span><br><span class="line">执行 Controller 方法前，MethodSecurityInterceptor 检查 @PreAuthorize / @Secured</span><br><span class="line">  ↓</span><br><span class="line">解析 SpEL 表达式校验当前用户权限</span><br></pre></td></tr></table></figure><p><strong>关键类：</strong></p><ul><li><code>MethodSecurityInterceptor</code></li><li><code>SecurityFilterChain</code></li><li><code>AccessDecisionManager</code></li></ul><p><strong>时机：</strong></p><blockquote><p>请求进入 Security Filter 阶段 &amp; 方法调用前</p></blockquote><hr><h1 id="☁️-六、Spring-Cloud-注解运行机制"><a href="#☁️-六、Spring-Cloud-注解运行机制" class="headerlink" title="☁️ 六、Spring Cloud 注解运行机制"></a>☁️ 六、Spring Cloud 注解运行机制</h1><h3 id="1️⃣-EnableDiscoveryClient"><a href="#1️⃣-EnableDiscoveryClient" class="headerlink" title="1️⃣ @EnableDiscoveryClient"></a>1️⃣ <code>@EnableDiscoveryClient</code></h3><p><strong>流程图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动阶段</span><br><span class="line">  ↓</span><br><span class="line">通过 ImportSelector 导入 DiscoveryClientAutoConfiguration</span><br><span class="line">  ↓</span><br><span class="line">初始化 DiscoveryClient (Eureka / Nacos)</span><br><span class="line">  ↓</span><br><span class="line">将当前服务信息注册到注册中心</span><br></pre></td></tr></table></figure><h3 id="2️⃣-FeignClient"><a href="#2️⃣-FeignClient" class="headerlink" title="2️⃣ @FeignClient"></a>2️⃣ <code>@FeignClient</code></h3><p><strong>流程图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableFeignClients 启动</span><br><span class="line">  ↓</span><br><span class="line">FeignClientsRegistrar 注册 FeignClientFactoryBean</span><br><span class="line">  ↓</span><br><span class="line">创建 Feign 动态代理对象</span><br><span class="line">  ↓</span><br><span class="line">方法调用 → FeignInvocationHandler 拦截</span><br><span class="line">  ↓</span><br><span class="line">构造 HTTP 请求 → Ribbon 负载均衡 → RestTemplate 调用远程接口</span><br></pre></td></tr></table></figure><p><strong>关键类：</strong></p><ul><li><code>FeignClientsRegistrar</code></li><li><code>FeignClientFactoryBean</code></li><li><code>FeignInvocationHandler</code></li></ul><hr><h2 id="🚨-七、所有框架调用时机总览表"><a href="#🚨-七、所有框架调用时机总览表" class="headerlink" title="🚨 七、所有框架调用时机总览表"></a>🚨 七、所有框架调用时机总览表</h2><table><thead><tr><th>阶段</th><th>注解类型</th><th>核心执行器</th><th>时机</th></tr></thead><tbody><tr><td>Bean 扫描注册</td><td><code>@Component</code> 系列</td><td><code>ClassPathBeanDefinitionScanner</code></td><td>容器启动</td></tr><tr><td>依赖注入</td><td><code>@Autowired</code></td><td><code>AutowiredAnnotationBeanPostProcessor</code></td><td>Bean 初始化阶段</td></tr><tr><td>配置解析</td><td><code>@Configuration</code>、<code>@Bean</code></td><td><code>ConfigurationClassPostProcessor</code></td><td>容器刷新前</td></tr><tr><td>AOP 创建代理</td><td><code>@Aspect</code></td><td><code>AnnotationAwareAspectJAutoProxyCreator</code></td><td>Bean 初始化后</td></tr><tr><td>MVC 映射注册</td><td><code>@Controller</code>、<code>@RequestMapping</code></td><td><code>RequestMappingHandlerMapping</code></td><td>Web 容器启动</td></tr><tr><td>JSON 转换</td><td><code>@RequestBody</code>、<code>@ResponseBody</code></td><td><code>HttpMessageConverter</code></td><td>请求调用时</td></tr><tr><td>MyBatis 代理</td><td><code>@Mapper</code></td><td><code>MapperProxy</code></td><td>运行时调用接口方法</td></tr><tr><td>自动装配</td><td><code>@EnableAutoConfiguration</code></td><td><code>AutoConfigurationImportSelector</code></td><td>启动阶段</td></tr><tr><td>权限控制</td><td><code>@PreAuthorize</code></td><td><code>MethodSecurityInterceptor</code></td><td>方法调用前</td></tr><tr><td>服务注册</td><td><code>@EnableDiscoveryClient</code></td><td><code>DiscoveryClientAutoConfiguration</code></td><td>启动阶段</td></tr><tr><td>远程调用</td><td><code>@FeignClient</code></td><td><code>FeignClientFactoryBean</code></td><td>调用接口时</td></tr></tbody></table><hr><h2 id="🧠-八、面试延伸逻辑（高频问法）"><a href="#🧠-八、面试延伸逻辑（高频问法）" class="headerlink" title="🧠 八、面试延伸逻辑（高频问法）"></a>🧠 八、面试延伸逻辑（高频问法）</h2><table><thead><tr><th>典型问题</th><th>核心回答逻辑</th></tr></thead><tbody><tr><td><strong><code>@Autowired</code> 注入是怎么实现的？</strong></td><td>通过 <code>AutowiredAnnotationBeanPostProcessor</code> 在 Bean 初始化阶段用反射注入依赖。</td></tr><tr><td><strong><code>@Configuration</code> 为什么会生成代理类？</strong></td><td>确保 <code>@Bean</code> 方法多次调用返回同一单例 Bean。</td></tr><tr><td><strong>Spring Boot 自动装配的原理？</strong></td><td><code>@EnableAutoConfiguration</code> → <code>AutoConfigurationImportSelector</code> → 读取 <code>spring.factories</code>。</td></tr><tr><td><strong>Spring AOP 如何织入？</strong></td><td>使用代理模式（JDK&#x2F;CGLIB），由 <code>AnnotationAwareAspectJAutoProxyCreator</code> 创建代理对象。</td></tr><tr><td><strong>Spring MVC 是如何找到 Controller 的？</strong></td><td><code>RequestMappingHandlerMapping</code> 扫描 <code>@Controller</code> 并建立 URL 映射表。</td></tr><tr><td><strong>Feign 是怎么实现远程调用的？</strong></td><td>通过动态代理生成接口实现类，调用时封装 HTTP 请求发往目标服务。</td></tr></tbody></table><hr><p>太好了 👏<br> 那我们就进入<strong>第二阶段：六大框架的深入机制讲解版</strong>，把每个框架的注解从“会用”提升到“懂原理、能讲源码逻辑”。</p><p>我会按顺序讲，每个模块包含：<br> 1️⃣ 常用注解<br> 2️⃣ 运行机制（源码&#x2F;原理）<br> 3️⃣ 实战&#x2F;场景<br> 4️⃣ 面试追问点（能拿高分的深答法）</p><hr><h1 id="🌱-一、Spring-核心注解-深入解析（IOC-AOP）"><a href="#🌱-一、Spring-核心注解-深入解析（IOC-AOP）" class="headerlink" title="🌱 一、Spring 核心注解 深入解析（IOC + AOP）"></a>🌱 一、Spring 核心注解 深入解析（IOC + AOP）</h1><p>Spring 是一切的根。只要理解它的 IOC 容器和 AOP 原理，后面所有框架的注解你都会秒懂。</p><hr><h2 id="1️⃣-IOC-核心注解机制"><a href="#1️⃣-IOC-核心注解机制" class="headerlink" title="1️⃣ IOC 核心注解机制"></a>1️⃣ IOC 核心注解机制</h2><p><strong>核心注解</strong>：<br> <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>, <code>@Configuration</code>, <code>@Bean</code>, <code>@Scope</code></p><hr><h3 id="🔍-1-原理"><a href="#🔍-1-原理" class="headerlink" title="🔍 1. 原理"></a>🔍 1. 原理</h3><h4 id="🧩-IOC（Inversion-of-Control）——控制反转"><a href="#🧩-IOC（Inversion-of-Control）——控制反转" class="headerlink" title="🧩 IOC（Inversion of Control）——控制反转"></a>🧩 IOC（Inversion of Control）——控制反转</h4><ul><li>核心思想：<strong>对象不由自己创建，而是交给容器管理</strong>。</li><li>Spring 容器本质是一个 <strong>BeanFactory &#x2F; ApplicationContext</strong>。</li><li>它启动时会执行：<ol><li>扫描包（<code>@ComponentScan</code>）</li><li>找到带 <code>@Component</code> 系的类</li><li>实例化成 Bean，放入 IOC 容器</li><li>执行依赖注入（DI）</li></ol></li></ul><h4 id="🧠-底层关键类："><a href="#🧠-底层关键类：" class="headerlink" title="🧠 底层关键类："></a>🧠 底层关键类：</h4><ul><li><code>ClassPathScanningCandidateComponentProvider</code>：扫描所有类</li><li><code>AnnotationConfigApplicationContext</code>：基于注解的容器入口</li><li><code>DefaultListableBeanFactory</code>：Bean 存储与生命周期管理</li></ul><hr><h3 id="⚙️-2-Component-与派生注解"><a href="#⚙️-2-Component-与派生注解" class="headerlink" title="⚙️ 2. @Component 与派生注解"></a>⚙️ 2. @Component 与派生注解</h3><p>Spring 在扫描时会判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clazz.isAnnotationPresent(Component.class) </span><br><span class="line">    || clazz.isAnnotationPresent(Controller.class) </span><br><span class="line">    || clazz.isAnnotationPresent(Service.class)</span><br><span class="line">    || clazz.isAnnotationPresent(Repository.class)) &#123;</span><br><span class="line">    <span class="comment">// 注册 BeanDefinition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 所以 <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code> 都是 <code>@Component</code> 的语义扩展，只是方便分层。</p><hr><h3 id="⚙️-3-Configuration-Bean-原理"><a href="#⚙️-3-Configuration-Bean-原理" class="headerlink" title="⚙️ 3. @Configuration + @Bean 原理"></a>⚙️ 3. @Configuration + @Bean 原理</h3><ul><li><code>@Configuration</code> 标识配置类，本质上是一个带 CGLIB 代理的 Bean。</li><li>代理的目的是防止多次实例化同一个 Bean。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层 Spring 会：</p><ol><li>解析 <code>@Configuration</code></li><li>生成 CGLIB 代理子类</li><li>拦截对 <code>@Bean</code> 方法的调用</li><li>若 Bean 已存在，不重新创建</li></ol><hr><h3 id="⚙️-4-依赖注入注解机制"><a href="#⚙️-4-依赖注入注解机制" class="headerlink" title="⚙️ 4. 依赖注入注解机制"></a>⚙️ 4. 依赖注入注解机制</h3><table><thead><tr><th>注解</th><th>机制</th></tr></thead><tbody><tr><td><strong>@Autowired</strong></td><td>反射注入。先按类型匹配，再按名称。</td></tr><tr><td><strong>@Qualifier</strong></td><td>指定注入 Bean 名称。</td></tr><tr><td><strong>@Resource</strong></td><td>JSR-250 标准，先按名称，再按类型。</td></tr><tr><td><strong>@Value</strong></td><td>从 <code>Environment</code> 中取值（支持 <code>$&#123;&#125;</code>）。</td></tr></tbody></table><p>底层类：</p><ul><li><code>AutowiredAnnotationBeanPostProcessor</code></li><li><code>CommonAnnotationBeanPostProcessor</code></li><li><code>ValueAnnotationBeanPostProcessor</code></li></ul><p>这些都是在 Bean 初始化阶段执行的 <strong>BeanPostProcessor</strong>。</p><hr><h2 id="2️⃣-AOP-核心注解机制"><a href="#2️⃣-AOP-核心注解机制" class="headerlink" title="2️⃣ AOP 核心注解机制"></a>2️⃣ AOP 核心注解机制</h2><p><strong>核心注解</strong>：<code>@Aspect</code>, <code>@Before</code>, <code>@After</code>, <code>@Around</code>, <code>@Pointcut</code></p><h3 id="🧩-1-原理：动态代理-通知织入"><a href="#🧩-1-原理：动态代理-通知织入" class="headerlink" title="🧩 1. 原理：动态代理 + 通知织入"></a>🧩 1. 原理：动态代理 + 通知织入</h3><p>Spring 启动时：</p><ol><li>扫描 <code>@Aspect</code> 类；</li><li>解析通知方法（<code>@Before</code>, <code>@Around</code>…）；</li><li>生成代理对象（JDK Proxy 或 CGLIB）；</li><li>方法执行时由代理拦截，执行通知逻辑。</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.demo.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>service</code> 方法时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK 动态代理 → 进入 AOP 代理类 → 执行 before() → 调用原方法 → after()</span><br></pre></td></tr></table></figure><p>底层关键类：</p><ul><li><code>AspectJExpressionPointcut</code></li><li><code>JdkDynamicAopProxy</code></li><li><code>CglibAopProxy</code></li></ul><hr><h2 id="🧠-面试深问点（可直接说出原理）"><a href="#🧠-面试深问点（可直接说出原理）" class="headerlink" title="🧠 面试深问点（可直接说出原理）"></a>🧠 面试深问点（可直接说出原理）</h2><table><thead><tr><th>问题</th><th>答案要点</th></tr></thead><tbody><tr><td>@Component 和 @Bean 区别？</td><td>@Component 自动扫描，@Bean 手动注册；前者类级别，后者方法级别。</td></tr><tr><td>@Configuration 为什么要代理？</td><td>为了保证 @Bean 返回的单例不会重复创建。</td></tr><tr><td>AOP 是如何实现的？</td><td>基于 JDK&#x2F;CGLIB 动态代理，通过 ProxyFactory 创建代理对象，执行通知链。</td></tr><tr><td>@Autowired 什么时候注入？</td><td>在 BeanPostProcessor 阶段的 <code>postProcessPropertyValues()</code> 里注入。</td></tr></tbody></table><hr><h1 id="🌐-二、SpringMVC-常用注解深度解析（请求分发-参数绑定-消息转换）"><a href="#🌐-二、SpringMVC-常用注解深度解析（请求分发-参数绑定-消息转换）" class="headerlink" title="🌐 二、SpringMVC 常用注解深度解析（请求分发 + 参数绑定 + 消息转换）"></a>🌐 二、SpringMVC 常用注解深度解析（请求分发 + 参数绑定 + 消息转换）</h1><p>SpringMVC 是 Spring 的 Web 层框架，它的注解体系围绕 <strong>请求映射、参数绑定、返回响应</strong> 三大核心展开。</p><hr><h2 id="1️⃣-SpringMVC-的整体架构与执行流程"><a href="#1️⃣-SpringMVC-的整体架构与执行流程" class="headerlink" title="1️⃣ SpringMVC 的整体架构与执行流程"></a>1️⃣ SpringMVC 的整体架构与执行流程</h2><blockquote><p>🌊 面试常问：<strong>“SpringMVC 请求是怎么从 URL 到 Controller 方法执行的？”</strong></p></blockquote><p>🧩 核心机制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DispatcherServlet（前端控制器）</span><br><span class="line">   ↓</span><br><span class="line">HandlerMapping（映射处理器）  ← 解析 @RequestMapping</span><br><span class="line">   ↓</span><br><span class="line">HandlerAdapter（适配器）      ← 解析 @RequestBody、@ModelAttribute 等参数</span><br><span class="line">   ↓</span><br><span class="line">Controller 方法执行</span><br><span class="line">   ↓</span><br><span class="line">ViewResolver（视图解析） / HttpMessageConverter（JSON 转换）</span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：SpringMVC 初始化时，会扫描所有带有 <code>@Controller</code>、<code>@RestController</code>、<code>@RequestMapping</code> 的类和方法，并建立映射表（HandlerMapping）。</p><hr><h2 id="2️⃣-控制层核心注解（Controller-体系）"><a href="#2️⃣-控制层核心注解（Controller-体系）" class="headerlink" title="2️⃣ 控制层核心注解（Controller 体系）"></a>2️⃣ 控制层核心注解（Controller 体系）</h2><table><thead><tr><th>注解</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>@Controller</strong></td><td>声明控制层组件</td><td>返回视图（如 JSP、Thymeleaf）</td></tr><tr><td><strong>@RestController</strong></td><td>&#x3D; @Controller + @ResponseBody</td><td>返回 JSON 数据</td></tr><tr><td><strong>@RequestMapping</strong></td><td>定义请求路径、方法、参数规则</td><td>可标注在类或方法上</td></tr><tr><td><strong>@GetMapping &#x2F; @PostMapping &#x2F; @PutMapping &#x2F; @DeleteMapping</strong></td><td>@RequestMapping 的快捷形式</td><td>仅限制 HTTP Method</td></tr><tr><td><strong>@ResponseBody</strong></td><td>将返回对象序列化为 JSON</td><td>由 HttpMessageConverter 实现</td></tr><tr><td><strong>@RequestBody</strong></td><td>将请求体 JSON 反序列化为对象</td><td>由 HttpMessageConverter 实现</td></tr></tbody></table><hr><h3 id="💡-实战示例"><a href="#💡-实战示例" class="headerlink" title="💡 实战示例"></a>💡 实战示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        userService.save(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔹 <code>/user/&#123;id&#125;</code> → <code>getUser()</code><br> 🔹 请求体 JSON → 通过 <code>@RequestBody</code> 自动映射到 <code>User</code> 对象</p><hr><h2 id="3️⃣-请求映射机制（HandlerMapping）"><a href="#3️⃣-请求映射机制（HandlerMapping）" class="headerlink" title="3️⃣ 请求映射机制（HandlerMapping）"></a>3️⃣ 请求映射机制（HandlerMapping）</h2><p>Spring 启动时会注册多个 HandlerMapping 实现类，其中最关键的是：</p><ul><li><code>RequestMappingHandlerMapping</code></li></ul><p>它负责扫描所有 Controller 类的方法并建立 URL 映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title function_">requestMappingHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层逻辑（源码简化版）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : controllerClass.getMethods()) &#123;</span><br><span class="line">    <span class="type">RequestMappingInfo</span> <span class="variable">info</span> <span class="operator">=</span> createRequestMappingInfo(method);</span><br><span class="line">    handlerMapping.registerMapping(info, controller, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🧠 所以：</p><ul><li>类上的 <code>@RequestMapping(&quot;/user&quot;)</code></li><li>方法上的 <code>@GetMapping(&quot;/&#123;id&#125;&quot;)</code></li></ul><p>会拼接成完整路径 <code>/user/&#123;id&#125;</code> 注册到映射表中。</p><hr><h2 id="4️⃣-参数绑定注解（HandlerMethodArgumentResolver）"><a href="#4️⃣-参数绑定注解（HandlerMethodArgumentResolver）" class="headerlink" title="4️⃣ 参数绑定注解（HandlerMethodArgumentResolver）"></a>4️⃣ 参数绑定注解（HandlerMethodArgumentResolver）</h2><p>SpringMVC 的参数解析是由 <code>HandlerMethodArgumentResolver</code> 实现的。<br> 它通过一系列解析器解析注解参数。</p><table><thead><tr><th>注解</th><th>对应解析器</th><th>作用</th></tr></thead><tbody><tr><td><strong>@RequestParam</strong></td><td><code>RequestParamMethodArgumentResolver</code></td><td>解析 URL 查询参数</td></tr><tr><td><strong>@PathVariable</strong></td><td><code>PathVariableMethodArgumentResolver</code></td><td>解析路径参数</td></tr><tr><td><strong>@RequestBody</strong></td><td><code>RequestResponseBodyMethodProcessor</code></td><td>JSON → 对象</td></tr><tr><td><strong>@RequestHeader</strong></td><td><code>RequestHeaderMethodArgumentResolver</code></td><td>获取请求头</td></tr><tr><td><strong>@CookieValue</strong></td><td><code>CookieValueMethodArgumentResolver</code></td><td>获取 Cookie 值</td></tr><tr><td><strong>@ModelAttribute</strong></td><td><code>ModelAttributeMethodProcessor</code></td><td>表单对象绑定</td></tr><tr><td><strong>@SessionAttributes</strong></td><td><code>SessionAttributesHandler</code></td><td>保留 Session 数据</td></tr></tbody></table><hr><h3 id="💡-参数绑定示例"><a href="#💡-参数绑定示例" class="headerlink" title="💡 参数绑定示例"></a>💡 参数绑定示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">query</span><span class="params">(<span class="meta">@RequestParam</span> String name, <span class="meta">@RequestParam(defaultValue=&quot;1&quot;)</span> <span class="type">int</span> page)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">detail</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@ModelAttribute</span> User user)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginDTO dto)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>🧠 底层逻辑：</p><ul><li>SpringMVC 调用每个 <code>HandlerMethodArgumentResolver</code>；</li><li>找到能处理对应注解的解析器；</li><li>把请求内容转换成参数。</li></ul><hr><h2 id="5️⃣-响应返回注解（HttpMessageConverter）"><a href="#5️⃣-响应返回注解（HttpMessageConverter）" class="headerlink" title="5️⃣ 响应返回注解（HttpMessageConverter）"></a>5️⃣ 响应返回注解（HttpMessageConverter）</h2><p>SpringMVC 的返回值也通过一系列 <strong>HandlerMethodReturnValueHandler</strong> 处理。</p><table><thead><tr><th>注解</th><th>对应机制</th></tr></thead><tbody><tr><td><strong>@ResponseBody</strong></td><td>调用 <code>HttpMessageConverter</code> 序列化返回对象为 JSON</td></tr><tr><td><strong>@RestController</strong></td><td>相当于全类级别 <code>@ResponseBody</code></td></tr><tr><td><strong>@ResponseStatus(HttpStatus.XXX)</strong></td><td>设置 HTTP 状态码</td></tr><tr><td><strong>@ControllerAdvice + @ExceptionHandler</strong></td><td>全局异常捕获和统一响应</td></tr></tbody></table><hr><h3 id="💡-JSON-转换过程原理"><a href="#💡-JSON-转换过程原理" class="headerlink" title="💡 JSON 转换过程原理"></a>💡 JSON 转换过程原理</h3><p>当方法标注了 <code>@ResponseBody</code>：</p><ol><li>SpringMVC 使用 <code>RequestResponseBodyMethodProcessor</code> 处理；</li><li>调用合适的 <code>HttpMessageConverter</code>；</li><li>常见实现：<ul><li><code>MappingJackson2HttpMessageConverter</code> → 使用 Jackson 转 JSON；</li><li><code>StringHttpMessageConverter</code> → 返回字符串。</li></ul></li></ol><p>反过来：</p><ul><li><code>@RequestBody</code> 也是通过同样的 <code>HttpMessageConverter</code> 将 JSON 转成 Java 对象。</li></ul><hr><h2 id="6️⃣-异常处理与全局控制"><a href="#6️⃣-异常处理与全局控制" class="headerlink" title="6️⃣ 异常处理与全局控制"></a>6️⃣ 异常处理与全局控制</h2><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><strong>@ExceptionHandler(Exception.class)</strong></td><td>捕获特定异常</td></tr><tr><td><strong>@ControllerAdvice</strong></td><td>全局异常&#x2F;数据绑定处理</td></tr><tr><td><strong>@InitBinder</strong></td><td>数据绑定格式化（如时间）</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handle</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(<span class="number">500</span>).body(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🧠-面试追问点与高分答法"><a href="#🧠-面试追问点与高分答法" class="headerlink" title="🧠 面试追问点与高分答法"></a>🧠 面试追问点与高分答法</h2><table><thead><tr><th>问题</th><th>深度答法</th></tr></thead><tbody><tr><td>SpringMVC 如何将 JSON 转换为对象？</td><td>通过 <code>@RequestBody</code> → <code>RequestResponseBodyMethodProcessor</code> → <code>HttpMessageConverter</code>（默认 Jackson）。</td></tr><tr><td>@Controller 与 @RestController 区别？</td><td>@RestController &#x3D; @Controller + @ResponseBody，用于 RESTful API 返回 JSON。</td></tr><tr><td>参数绑定是怎么实现的？</td><td>每个注解对应一个 <code>HandlerMethodArgumentResolver</code>，逐个匹配执行。</td></tr><tr><td>DispatcherServlet 做了什么？</td><td>它是前端控制器，负责请求分发、参数解析、调用 Controller、返回视图或 JSON。</td></tr><tr><td>@ControllerAdvice 有什么用？</td><td>统一异常处理、数据绑定、全局配置。</td></tr></tbody></table><hr><h1 id="💾-三、MyBatis-常用注解-底层映射原理（Mapper-动态代理机制）"><a href="#💾-三、MyBatis-常用注解-底层映射原理（Mapper-动态代理机制）" class="headerlink" title="💾 三、MyBatis 常用注解 + 底层映射原理（Mapper 动态代理机制）"></a>💾 三、MyBatis 常用注解 + 底层映射原理（Mapper 动态代理机制）</h1><p>MyBatis 是 Spring 体系中连接数据库的核心 ORM 框架。<br> 与 JPA 不同，它更轻量、可控，常通过 <strong>接口 + 注解 &#x2F; XML 映射</strong> 实现 SQL 操作。</p><hr><h2 id="一、MyBatis-常用注解总览"><a href="#一、MyBatis-常用注解总览" class="headerlink" title="一、MyBatis 常用注解总览"></a>一、MyBatis 常用注解总览</h2><table><thead><tr><th>注解</th><th>作用</th><th>使用位置</th><th>说明</th></tr></thead><tbody><tr><td><strong>@Mapper</strong></td><td>标记 Mapper 接口</td><td>接口</td><td>告诉 Spring 这是一个 MyBatis Mapper</td></tr><tr><td><strong>@MapperScan</strong></td><td>批量扫描 Mapper 包</td><td>启动类或配置类</td><td>替代逐个写 @Mapper</td></tr><tr><td><strong>@Select &#x2F; @Insert &#x2F; @Update &#x2F; @Delete</strong></td><td>声明 SQL 语句</td><td>方法</td><td>注解式 SQL</td></tr><tr><td><strong>@Results &#x2F; @Result</strong></td><td>字段与属性映射</td><td>方法</td><td>解决数据库字段与实体属性不一致</td></tr><tr><td><strong>@Param</strong></td><td>映射方法参数名</td><td>方法参数</td><td>SQL 中使用 #{参数名}</td></tr><tr><td><strong>@Options</strong></td><td>设置 SQL 执行选项</td><td>方法</td><td>例如自动主键回填</td></tr><tr><td><strong>@SelectProvider &#x2F; @UpdateProvider …</strong></td><td>动态 SQL 生成</td><td>方法</td><td>指定 SQL 由某类动态生成</td></tr></tbody></table><hr><h2 id="二、Mapper-注册机制与动态代理原理"><a href="#二、Mapper-注册机制与动态代理原理" class="headerlink" title="二、Mapper 注册机制与动态代理原理"></a>二、Mapper 注册机制与动态代理原理</h2><p>🧠 面试常问：“@Mapper 是如何让接口不写实现类还能执行 SQL 的？”</p><p>核心答案：<br> 👉 MyBatis 使用 <strong>动态代理（MapperProxy）</strong> 为接口创建实现类。</p><h3 id="💡-执行流程示意"><a href="#💡-执行流程示意" class="headerlink" title="💡 执行流程示意"></a>💡 执行流程示意</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口调用 → MapperProxy.invoke() → SqlSession → 执行 SQL → 映射结果 → 返回对象</span><br></pre></td></tr></table></figure><p>详细步骤：</p><p>1️⃣ Spring 启动时，<code>@MapperScan</code> 扫描包路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br></pre></td></tr></table></figure><p>2️⃣ Spring 会为每个接口创建 <strong>MapperFactoryBean</strong>，交给 IOC 容器管理。</p><p>3️⃣ 当注入 Mapper 时，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br></pre></td></tr></table></figure><p>其实注入的是一个由 MyBatis 创建的代理对象。</p><p>4️⃣ 代理对象的核心类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">        <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5️⃣ 最终执行 SQL：</p><ul><li>从注解或 XML 读取 SQL；</li><li>替换参数；</li><li>执行 JDBC；</li><li>使用 <code>ResultSetHandler</code> 将结果映射成对象。</li></ul><hr><h2 id="三、注解式-SQL-示例"><a href="#三、注解式-SQL-示例" class="headerlink" title="三、注解式 SQL 示例"></a>三、注解式 SQL 示例</h2><h3 id="1️⃣-基本-CRUD-注解"><a href="#1️⃣-基本-CRUD-注解" class="headerlink" title="1️⃣ 基本 CRUD 注解"></a>1️⃣ 基本 CRUD 注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO user(name, age) VALUES(#&#123;name&#125;, #&#123;age&#125;)&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE user SET name=#&#123;name&#125;, age=#&#123;age&#125; WHERE id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM user WHERE id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🧩 <strong>说明</strong>：</p><ul><li><code>#&#123;&#125;</code> 会被 MyBatis 解析为 <code>?</code> 占位符；</li><li><code>@Options(useGeneratedKeys=true)</code> 可自动回填主键；</li><li><code>@Param</code> 显式指定参数名，防止参数混乱。</li></ul><hr><h3 id="2️⃣-结果映射注解（解决字段名不匹配）"><a href="#2️⃣-结果映射注解（解决字段名不匹配）" class="headerlink" title="2️⃣ 结果映射注解（解决字段名不匹配）"></a>2️⃣ 结果映射注解（解决字段名不匹配）</h3><p>数据库字段 → Java 属性不一致时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT user_id, user_name FROM user WHERE user_id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;user_id&quot;, property=&quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;user_name&quot;, property=&quot;name&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">User <span class="title function_">getUser</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure><p>底层使用 <code>ResultSetHandler</code> 将列值与属性对应。</p><hr><h3 id="3️⃣-动态-SQL-注解"><a href="#3️⃣-动态-SQL-注解" class="headerlink" title="3️⃣ 动态 SQL 注解"></a>3️⃣ 动态 SQL 注解</h3><p>用于复杂 SQL（可条件拼接）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;buildSelect&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">selectByCondition</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure><p>SQL 动态生成类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">buildSelect</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;SELECT * FROM user WHERE 1=1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user.getName() != <span class="literal">null</span>) sql.append(<span class="string">&quot; AND name = #&#123;name&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user.getAge() != <span class="literal">null</span>) sql.append(<span class="string">&quot; AND age = #&#123;age&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sql.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、-Mapper-与-MapperScan-的关系"><a href="#四、-Mapper-与-MapperScan-的关系" class="headerlink" title="四、@Mapper 与 @MapperScan 的关系"></a>四、@Mapper 与 @MapperScan 的关系</h2><table><thead><tr><th>场景</th><th>用法</th></tr></thead><tbody><tr><td>少量 Mapper</td><td>每个接口加 @Mapper</td></tr><tr><td>多个 Mapper</td><td>在配置类加 @MapperScan(“com.example.mapper”)</td></tr></tbody></table><p>📦 Spring Boot 中通常只需：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="五、底层关键组件解析（源码角度）"><a href="#五、底层关键组件解析（源码角度）" class="headerlink" title="五、底层关键组件解析（源码角度）"></a>五、底层关键组件解析（源码角度）</h2><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td><strong>SqlSessionFactoryBean</strong></td><td>生成 SqlSession 工厂</td></tr><tr><td><strong>MapperFactoryBean</strong></td><td>每个 Mapper 的代理工厂</td></tr><tr><td><strong>MapperProxy</strong></td><td>动态代理核心</td></tr><tr><td><strong>Executor</strong></td><td>执行 SQL 的底层执行器</td></tr><tr><td><strong>ResultSetHandler</strong></td><td>结果集映射</td></tr><tr><td><strong>StatementHandler</strong></td><td>负责预编译和执行 SQL</td></tr></tbody></table><p>🧩 执行链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MapperProxy.invoke()</span><br><span class="line">    ↓</span><br><span class="line">MapperMethod.execute()</span><br><span class="line">    ↓</span><br><span class="line">SqlSession.select / insert / update</span><br><span class="line">    ↓</span><br><span class="line">Executor.query()</span><br><span class="line">    ↓</span><br><span class="line">StatementHandler.prepare()</span><br><span class="line">    ↓</span><br><span class="line">ResultSetHandler.handleResultSets()</span><br></pre></td></tr></table></figure><hr><h2 id="六、MyBatis-Spring-的整合机制"><a href="#六、MyBatis-Spring-的整合机制" class="headerlink" title="六、MyBatis + Spring 的整合机制"></a>六、MyBatis + Spring 的整合机制</h2><p>Spring Boot 整合时，核心是：</p><ul><li><code>MyBatisAutoConfiguration</code></li><li>自动注册 <code>SqlSessionFactory</code> 和 <code>MapperScannerConfigurer</code></li><li>自动扫描带 @Mapper 的接口</li></ul><p>配置简化到只需：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=...</span><br><span class="line">mybatis.mapper-locations=classpath:mappers<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure><hr><h2 id="七、面试追问点（高分回答）"><a href="#七、面试追问点（高分回答）" class="headerlink" title="七、面试追问点（高分回答）"></a>七、面试追问点（高分回答）</h2><table><thead><tr><th>问题</th><th>深度答法</th></tr></thead><tbody><tr><td>@Mapper 与 @MapperScan 区别？</td><td>@Mapper 作用于接口；@MapperScan 作用于包；底层都注册 MapperFactoryBean。</td></tr><tr><td>MyBatis 是如何执行 SQL 的？</td><td>MapperProxy 拦截方法 → SqlSession → Executor → StatementHandler → JDBC 执行。</td></tr><tr><td>注解与 XML 映射的区别？</td><td>注解轻量、便于维护小 SQL；XML 更灵活，支持动态标签、条件判断。</td></tr><tr><td>MyBatis 如何实现参数和结果映射？</td><td>参数：通过 ParameterHandler 替换占位符；结果：ResultSetHandler 根据 ResultMap 映射。</td></tr><tr><td>@SelectProvider 有什么用？</td><td>用于动态生成 SQL，支持复杂查询逻辑。</td></tr></tbody></table><h1 id="🌸-四、Spring-Boot-常用注解与底层机制（自动装配-条件加载）"><a href="#🌸-四、Spring-Boot-常用注解与底层机制（自动装配-条件加载）" class="headerlink" title="🌸 四、Spring Boot 常用注解与底层机制（自动装配 + 条件加载）"></a>🌸 四、Spring Boot 常用注解与底层机制（自动装配 + 条件加载）</h1><p>这一部分是面试高频 + 实战必懂的核心。<br> 重点是理解 <strong>Spring Boot 为什么能“自动装配”</strong>，以及这些注解在底层是怎么工作的。</p><hr><h2 id="一、Spring-Boot-核心注解全图"><a href="#一、Spring-Boot-核心注解全图" class="headerlink" title="一、Spring Boot 核心注解全图"></a>一、Spring Boot 核心注解全图</h2><table><thead><tr><th>注解</th><th>作用</th><th>核心原理</th></tr></thead><tbody><tr><td><code>@SpringBootApplication</code></td><td>核心入口注解（整合 3 个注解）</td><td>启动自动配置与组件扫描</td></tr><tr><td><code>@SpringBootConfiguration</code></td><td>标识配置类</td><td>继承自 <code>@Configuration</code></td></tr><tr><td><code>@EnableAutoConfiguration</code></td><td>自动装配核心</td><td>从 <code>META-INF/spring.factories</code> 加载配置类</td></tr><tr><td><code>@ComponentScan</code></td><td>包扫描</td><td>扫描项目包路径下的组件</td></tr><tr><td><code>@ConfigurationProperties</code></td><td>绑定配置文件属性</td><td>从 <code>application.yml</code> 绑定属性到 Bean</td></tr><tr><td><code>@Conditional</code> 系列</td><td>条件装配</td><td>控制 Bean 是否加载</td></tr><tr><td><code>@Import</code></td><td>导入配置类</td><td>支持多种导入方式（类、Selector、Registrar）</td></tr><tr><td><code>@Value</code></td><td>注入单个配置值</td><td>读取 Environment 中的配置</td></tr><tr><td><code>@RestController</code></td><td>&#x3D; <code>@Controller</code> + <code>@ResponseBody</code></td><td>快速创建 REST API</td></tr><tr><td><code>@SpringBootTest</code></td><td>测试启动</td><td>启动完整 SpringBoot 环境进行单元测试</td></tr></tbody></table><hr><h2 id="二、核心注解剖析"><a href="#二、核心注解剖析" class="headerlink" title="二、核心注解剖析"></a>二、核心注解剖析</h2><h3 id="⚙️-1️⃣-SpringBootApplication（入口注解）"><a href="#⚙️-1️⃣-SpringBootApplication（入口注解）" class="headerlink" title="⚙️ 1️⃣ @SpringBootApplication（入口注解）"></a>⚙️ 1️⃣ @SpringBootApplication（入口注解）</h3><p>这是 Spring Boot 应用的入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;&#125;</span><br></pre></td></tr></table></figure><p>👉 所以它本质上是：</p><ol><li>声明一个配置类</li><li>启动自动装配</li><li>开启组件扫描</li></ol><hr><h3 id="⚙️-2️⃣-EnableAutoConfiguration（自动装配核心）"><a href="#⚙️-2️⃣-EnableAutoConfiguration（自动装配核心）" class="headerlink" title="⚙️ 2️⃣ @EnableAutoConfiguration（自动装配核心）"></a>⚙️ 2️⃣ @EnableAutoConfiguration（自动装配核心）</h3><blockquote><p>这是 Spring Boot 最重要的注解！</p></blockquote><p>底层逻辑：</p><ol><li>通过 <code>SpringFactoriesLoader</code> 读取所有 <code>META-INF/spring.factories</code> 文件；</li><li>找到 key 为 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 的类；</li><li>把这些类加载进容器；</li><li>根据 <code>@Conditional</code> 系列判断是否生效。</li></ol><p>这些类通常是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DataSourceAutoConfiguration</span><br><span class="line">WebMvcAutoConfiguration</span><br><span class="line">RedisAutoConfiguration</span><br><span class="line">SecurityAutoConfiguration</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这些就是所谓的“自动装配类”。</p><hr><h4 id="🔍-自动装配核心源码逻辑"><a href="#🔍-自动装配核心源码逻辑" class="headerlink" title="🔍 自动装配核心源码逻辑"></a>🔍 自动装配核心源码逻辑</h4><p>在 <code>AutoConfigurationImportSelector</code> 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">        EnableAutoConfiguration.class, classLoader);</span><br></pre></td></tr></table></figure><p>每个自动配置类都像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DataSource.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以：<br> ✅ <strong>有 DataSource 类存在时才加载</strong><br> ✅ <strong>会自动从 application.yml 绑定属性</strong></p><hr><h3 id="⚙️-3️⃣-条件装配注解（Conditional-系列）"><a href="#⚙️-3️⃣-条件装配注解（Conditional-系列）" class="headerlink" title="⚙️ 3️⃣ 条件装配注解（Conditional 系列）"></a>⚙️ 3️⃣ 条件装配注解（Conditional 系列）</h3><table><thead><tr><th>注解</th><th>含义</th></tr></thead><tbody><tr><td><code>@ConditionalOnClass</code></td><td>类存在时加载</td></tr><tr><td><code>@ConditionalOnMissingBean</code></td><td>Bean 不存在时加载</td></tr><tr><td><code>@ConditionalOnProperty</code></td><td>指定配置项满足条件时加载</td></tr><tr><td><code>@ConditionalOnMissingClass</code></td><td>类不存在时加载</td></tr><tr><td><code>@ConditionalOnWebApplication</code></td><td>当前为 Web 环境时加载</td></tr><tr><td><code>@ConditionalOnExpression</code></td><td>满足 SpEL 表达式时加载</td></tr></tbody></table><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;app.feature.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeatureConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FeatureService <span class="title function_">featureService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FeatureService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 只有当配置文件里有 <code>app.feature.enabled=true</code> 时才加载。</p><hr><h3 id="⚙️-4️⃣-ConfigurationProperties（配置绑定）"><a href="#⚙️-4️⃣-ConfigurationProperties（配置绑定）" class="headerlink" title="⚙️ 4️⃣ @ConfigurationProperties（配置绑定）"></a>⚙️ 4️⃣ @ConfigurationProperties（配置绑定）</h3><p>自动绑定配置文件中的属性：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="string">@Component</span></span><br><span class="line"><span class="string">@ConfigurationProperties(prefix</span> <span class="string">=</span> <span class="string">&quot;server&quot;</span><span class="string">)</span></span><br><span class="line"><span class="string">public</span> <span class="string">class</span> <span class="string">ServerConfig</span> &#123;</span><br><span class="line">    <span class="string">private</span> <span class="string">int</span> <span class="string">port;</span></span><br><span class="line">    <span class="string">private</span> <span class="string">String</span> <span class="string">address;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层机制：</p><ul><li>通过 <code>Binder</code> 绑定 Environment 中的属性；</li><li>利用 <code>RelaxedDataBinder</code> 支持松散匹配；</li><li>可以用 <code>@EnableConfigurationProperties</code> 显式启用。</li></ul><hr><h3 id="⚙️-5️⃣-Import（手动扩展装配）"><a href="#⚙️-5️⃣-Import（手动扩展装配）" class="headerlink" title="⚙️ 5️⃣ @Import（手动扩展装配）"></a>⚙️ 5️⃣ @Import（手动扩展装配）</h3><p>四种导入方式：</p><table><thead><tr><th>类型</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>导入类</td><td><code>@Import(MyConfig.class)</code></td><td>导入配置类</td></tr><tr><td>导入 ImportSelector</td><td><code>@Import(MyImportSelector.class)</code></td><td>批量导入配置类</td></tr><tr><td>导入 ImportBeanDefinitionRegistrar</td><td><code>@Import(MyRegistrar.class)</code></td><td>动态注册 Bean</td></tr><tr><td>导入普通 Bean</td><td><code>@Import(&#123;A.class, B.class&#125;)</code></td><td>多类导入</td></tr></tbody></table><p>面试常问：</p><blockquote><p>“Spring Boot 自动装配用的是哪种方式？”<br> 答：<strong>ImportSelector（AutoConfigurationImportSelector）</strong></p></blockquote><hr><h2 id="三、Spring-Boot-启动流程（重点）"><a href="#三、Spring-Boot-启动流程（重点）" class="headerlink" title="三、Spring Boot 启动流程（重点）"></a>三、Spring Boot 启动流程（重点）</h2><p>当你执行 <code>SpringApplication.run()</code> 时，实际发生了：</p><p>1️⃣ 创建 <code>SpringApplication</code> 实例<br> 2️⃣ 推断应用类型（Web&#x2F;Reactive&#x2F;None）<br> 3️⃣ 加载 ApplicationContext<br> 4️⃣ 扫描主类所在包<br> 5️⃣ 加载自动配置类（EnableAutoConfiguration）<br> 6️⃣ 实例化 Bean + 依赖注入<br> 7️⃣ 启动内嵌服务器（Tomcat&#x2F;Jetty&#x2F;Undertow）</p><hr><h2 id="四、面试深问点（高分答法）"><a href="#四、面试深问点（高分答法）" class="headerlink" title="四、面试深问点（高分答法）"></a>四、面试深问点（高分答法）</h2><table><thead><tr><th>问题</th><th>高分答法</th></tr></thead><tbody><tr><td>Spring Boot 为什么能自动装配？</td><td>因为 @EnableAutoConfiguration 通过 SpringFactoriesLoader 从 META-INF&#x2F;spring.factories 加载自动配置类，并结合 @Conditional 系列按条件注册 Bean。</td></tr><tr><td>@SpringBootApplication 里面包含了什么？</td><td>它整合了 @Configuration、@EnableAutoConfiguration、@ComponentScan。</td></tr><tr><td>@ConfigurationProperties 和 @Value 区别？</td><td>前者用于批量属性绑定（对象映射），后者用于单值注入。</td></tr><tr><td>Spring Boot 启动流程？</td><td>run → 创建 ApplicationContext → 扫描组件 → 自动装配 → 启动容器（Tomcat）。</td></tr><tr><td>自动装配失效的原因有哪些？</td><td>类缺失、条件不满足（@Conditional）、配置关闭（spring.autoconfigure.exclude）。</td></tr></tbody></table><h1 id="🛡️-五、Spring-Security-常用注解与底层机制（认证与授权）"><a href="#🛡️-五、Spring-Security-常用注解与底层机制（认证与授权）" class="headerlink" title="🛡️ 五、Spring Security 常用注解与底层机制（认证与授权）"></a>🛡️ 五、Spring Security 常用注解与底层机制（认证与授权）</h1><p>Spring Security 是企业级安全框架，核心在于 <strong>认证（Authentication）</strong> 和 <strong>授权（Authorization）</strong>。<br> 注解只是暴露给开发者的快捷入口，底层依靠 <strong>过滤器链 + 访问决策管理器</strong> 实现安全控制。</p><hr><h2 id="一、核心注解总览"><a href="#一、核心注解总览" class="headerlink" title="一、核心注解总览"></a>一、核心注解总览</h2><table><thead><tr><th>注解</th><th>作用</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>@EnableWebSecurity</strong></td><td>启用 Spring Security</td><td>配置类上</td></tr><tr><td><strong>@Configuration</strong></td><td>配置类</td><td>配合@EnableWebSecurity</td></tr><tr><td><strong>@Secured</strong></td><td>方法级权限</td><td>限制角色访问，老版本</td></tr><tr><td><strong>@PreAuthorize</strong></td><td>方法前表达式授权</td><td>支持 SpEL 表达式，推荐</td></tr><tr><td><strong>@PostAuthorize</strong></td><td>方法后表达式授权</td><td>可基于返回值做授权判断</td></tr><tr><td><strong>@RolesAllowed</strong></td><td>JSR-250 标准</td><td>限制角色访问</td></tr><tr><td><strong>@WithMockUser</strong></td><td>测试模拟用户</td><td>单元测试</td></tr><tr><td><strong>@AuthenticationPrincipal</strong></td><td>获取当前认证用户</td><td>Controller 方法参数注入</td></tr></tbody></table><hr><h2 id="二、核心机制解析"><a href="#二、核心机制解析" class="headerlink" title="二、核心机制解析"></a>二、核心机制解析</h2><h3 id="1️⃣-FilterChainProxy（安全过滤器链）"><a href="#1️⃣-FilterChainProxy（安全过滤器链）" class="headerlink" title="1️⃣ FilterChainProxy（安全过滤器链）"></a>1️⃣ FilterChainProxy（安全过滤器链）</h3><p>Spring Security 基于 <strong>Servlet Filter</strong> 实现，核心流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求 → FilterChainProxy → SecurityFilters（多个） → DispatcherServlet</span><br></pre></td></tr></table></figure><ul><li>常用 Filter：<ul><li><code>UsernamePasswordAuthenticationFilter</code>：表单登录</li><li><code>BasicAuthenticationFilter</code>：HTTP Basic</li><li><code>ExceptionTranslationFilter</code>：异常处理</li><li><code>FilterSecurityInterceptor</code>：最终授权决策</li></ul></li></ul><p>💡 面试高频：</p><blockquote><p>“Spring Security 如何拦截请求？”<br> 答：通过 <code>FilterChainProxy</code>，按顺序执行过滤器链，每个 Filter 负责不同安全功能。</p></blockquote><hr><h3 id="2️⃣-EnableWebSecurity"><a href="#2️⃣-EnableWebSecurity" class="headerlink" title="2️⃣ @EnableWebSecurity"></a>2️⃣ @EnableWebSecurity</h3><ul><li>激活 Web 安全配置；</li><li>内部通过 <code>@Import(WebSecurityConfiguration.class)</code> 注入：<ul><li><code>FilterChainProxy</code></li><li><code>AuthenticationManager</code></li><li><code>AccessDecisionManager</code></li></ul></li></ul><hr><h3 id="3️⃣-方法级权限注解"><a href="#3️⃣-方法级权限注解" class="headerlink" title="3️⃣ 方法级权限注解"></a>3️⃣ 方法级权限注解</h3><h4 id="a-Secured"><a href="#a-Secured" class="headerlink" title="a. @Secured"></a>a. @Secured</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Secured(&quot;ROLE_ADMIN&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>仅支持角色（ROLE_ 前缀）</li><li>核心类：<code>SecuredAnnotationSecurityMetadataSource</code></li></ul><h4 id="b-PreAuthorize-PostAuthorize"><a href="#b-PreAuthorize-PostAuthorize" class="headerlink" title="b. @PreAuthorize &#x2F; @PostAuthorize"></a>b. @PreAuthorize &#x2F; @PostAuthorize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;) and #id == authentication.principal.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(Long id)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostAuthorize(&quot;returnObject.owner == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>支持 SpEL 表达式，可基于方法参数、返回值、认证对象授权</li><li>核心类：<ul><li><code>ExpressionBasedAnnotationAttributeFactory</code></li><li><code>PreInvocationAuthorizationAdviceVoter</code></li></ul></li></ul><h4 id="c-RolesAllowed"><a href="#c-RolesAllowed" class="headerlink" title="c. @RolesAllowed"></a>c. @RolesAllowed</h4><ul><li>JSR-250 标准，底层映射到 <code>Jsr250MethodSecurityMetadataSource</code></li></ul><hr><h3 id="4️⃣-获取当前用户注解"><a href="#4️⃣-获取当前用户注解" class="headerlink" title="4️⃣ 获取当前用户注解"></a>4️⃣ 获取当前用户注解</h3><h4 id="AuthenticationPrincipal"><a href="#AuthenticationPrincipal" class="headerlink" title="@AuthenticationPrincipal"></a>@AuthenticationPrincipal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/me&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">me</span><span class="params">(<span class="meta">@AuthenticationPrincipal</span> User user)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>注入当前认证对象</li><li>底层通过 <code>SecurityContextHolder.getContext().getAuthentication().getPrincipal()</code></li></ul><hr><h3 id="5️⃣-测试支持"><a href="#5️⃣-测试支持" class="headerlink" title="5️⃣ 测试支持"></a>5️⃣ 测试支持</h3><h4 id="WithMockUser"><a href="#WithMockUser" class="headerlink" title="@WithMockUser"></a>@WithMockUser</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithMockUser(username=&quot;admin&quot;, roles=&#123;&quot;ADMIN&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdminAccess</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>模拟登录用户，方便方法级安全测试</li></ul><hr><h3 id="6️⃣-身份认证流程（核心链条）"><a href="#6️⃣-身份认证流程（核心链条）" class="headerlink" title="6️⃣ 身份认证流程（核心链条）"></a>6️⃣ 身份认证流程（核心链条）</h3><ol><li>用户请求登录 <code>/login</code></li><li><code>UsernamePasswordAuthenticationFilter</code> 拦截请求</li><li>调用 <code>AuthenticationManager</code> → <code>ProviderManager</code></li><li>执行 <code>UserDetailsService.loadUserByUsername</code> 获取用户信息</li><li>验证密码 → 生成 <code>Authentication</code> → 存入 <code>SecurityContextHolder</code></li><li>后续请求通过过滤器链进行授权检查</li></ol><hr><h3 id="7️⃣-授权决策"><a href="#7️⃣-授权决策" class="headerlink" title="7️⃣ 授权决策"></a>7️⃣ 授权决策</h3><ul><li>核心类：<code>AccessDecisionManager</code></li><li>核心逻辑：<ol><li>获取请求 URL &#x2F; 方法的权限元信息（MetadataSource）</li><li>通过 <code>Voter</code> 投票机制判定允许或拒绝</li><li>常用 Voter：<ul><li><code>RoleVoter</code></li><li><code>AuthenticatedVoter</code></li><li><code>ExpressionVoter</code>（用于 @PreAuthorize &#x2F; @PostAuthorize）</li></ul></li></ol></li></ul><hr><h2 id="三、面试追问点（高分回答）"><a href="#三、面试追问点（高分回答）" class="headerlink" title="三、面试追问点（高分回答）"></a>三、面试追问点（高分回答）</h2><table><thead><tr><th>问题</th><th>高分答法</th></tr></thead><tbody><tr><td>Spring Security 如何拦截请求？</td><td>通过 <code>FilterChainProxy</code> 执行多个 Filter，每个 Filter 完成认证或授权逻辑。</td></tr><tr><td>@PreAuthorize 与 @Secured 区别？</td><td>@Secured 仅支持角色，@PreAuthorize 支持 SpEL 表达式，可基于方法参数&#x2F;返回值授权。</td></tr><tr><td>当前用户怎么获取？</td><td><code>SecurityContextHolder.getContext().getAuthentication().getPrincipal()</code> 或 <code>@AuthenticationPrincipal</code> 注入。</td></tr><tr><td>FilterChain 执行顺序？</td><td>登录认证 → 异常处理 → 授权 → 业务 Controller → 响应处理。</td></tr><tr><td>如何测试方法级安全？</td><td>使用 <code>@WithMockUser</code> 注解模拟用户身份。</td></tr></tbody></table><h1 id="☁️-六、Spring-Cloud-常用注解与底层机制（服务注册、发现、负载均衡、远程调用）"><a href="#☁️-六、Spring-Cloud-常用注解与底层机制（服务注册、发现、负载均衡、远程调用）" class="headerlink" title="☁️ 六、Spring Cloud 常用注解与底层机制（服务注册、发现、负载均衡、远程调用）"></a>☁️ 六、Spring Cloud 常用注解与底层机制（服务注册、发现、负载均衡、远程调用）</h1><p>Spring Cloud 是微服务架构核心框架，它提供了 <strong>服务治理、配置中心、服务调用、熔断降级</strong> 等功能。<br> 我们重点分析 <strong>常用注解 + 底层原理 + 面试追问点</strong>。</p><hr><h2 id="一、服务注册与发现（Eureka-Nacos）"><a href="#一、服务注册与发现（Eureka-Nacos）" class="headerlink" title="一、服务注册与发现（Eureka &#x2F; Nacos）"></a>一、服务注册与发现（Eureka &#x2F; Nacos）</h2><h3 id="1️⃣-核心注解"><a href="#1️⃣-核心注解" class="headerlink" title="1️⃣ 核心注解"></a>1️⃣ 核心注解</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@EnableEurekaClient</code></td><td>启用 Eureka 客户端，自动注册服务</td></tr><tr><td><code>@EnableDiscoveryClient</code></td><td>通用服务发现注解（Eureka、Consul、Nacos）</td></tr><tr><td><code>@LoadBalanced</code></td><td>配置 RestTemplate 或 WebClient 支持客户端负载均衡</td></tr><tr><td><code>@RefreshScope</code></td><td>配置热刷新，用于配置中心动态刷新</td></tr></tbody></table><hr><h3 id="2️⃣-服务注册流程（Eureka-示例）"><a href="#2️⃣-服务注册流程（Eureka-示例）" class="headerlink" title="2️⃣ 服务注册流程（Eureka 示例）"></a>2️⃣ 服务注册流程（Eureka 示例）</h3><ol><li>启动微服务 → <code>EurekaClient</code> 初始化</li><li>发送心跳 <code>POST /eureka/apps/&#123;serviceName&#125;</code></li><li>Eureka Server 接收并注册实例</li><li>其他微服务通过 <code>/eureka/apps</code> 获取服务列表</li><li>内部缓存一份服务列表，提高访问效率</li></ol><blockquote><p>🔥 面试点：Eureka 默认 <strong>心跳 30s</strong>，下线延迟 90s，可能存在短暂不可用。</p></blockquote><hr><h2 id="二、负载均衡（Ribbon-Spring-Cloud-LoadBalancer）"><a href="#二、负载均衡（Ribbon-Spring-Cloud-LoadBalancer）" class="headerlink" title="二、负载均衡（Ribbon &#x2F; Spring Cloud LoadBalancer）"></a>二、负载均衡（Ribbon &#x2F; Spring Cloud LoadBalancer）</h2><h3 id="1️⃣-核心注解-1"><a href="#1️⃣-核心注解-1" class="headerlink" title="1️⃣ 核心注解"></a>1️⃣ 核心注解</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@LoadBalanced</code></td><td>配置 RestTemplate 或 WebClient 支持 Ribbon 或 Spring Cloud LoadBalancer</td></tr><tr><td><code>@FeignClient</code></td><td>声明式远程调用，集成负载均衡和熔断</td></tr></tbody></table><hr><h3 id="2️⃣-客户端负载均衡原理"><a href="#2️⃣-客户端负载均衡原理" class="headerlink" title="2️⃣ 客户端负载均衡原理"></a>2️⃣ 客户端负载均衡原理</h3><ul><li><strong>Ribbon（老版）</strong>：<ul><li>从服务发现获取服务列表</li><li>使用负载策略（轮询、随机、权重）选择实例</li><li>发起请求</li></ul></li><li><strong>Spring Cloud LoadBalancer（新方案）</strong>：<ul><li>默认轮询算法</li><li>支持自定义策略</li><li>通过 <code>LoadBalancerClient</code> 或 <code>ReactiveLoadBalancer</code> 选择实例</li></ul></li></ul><hr><h2 id="三、声明式远程调用（Feign）"><a href="#三、声明式远程调用（Feign）" class="headerlink" title="三、声明式远程调用（Feign）"></a>三、声明式远程调用（Feign）</h2><h3 id="1️⃣-核心注解-2"><a href="#1️⃣-核心注解-2" class="headerlink" title="1️⃣ 核心注解"></a>1️⃣ 核心注解</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@EnableFeignClients</code></td><td>启用 Feign 客户端扫描</td></tr><tr><td><code>@FeignClient(name=&quot;service-name&quot;, path=&quot;/api&quot;)</code></td><td>声明远程服务接口</td></tr><tr><td><code>@RequestMapping / @GetMapping / @PostMapping</code></td><td>定义远程调用接口方法</td></tr></tbody></table><hr><h3 id="2️⃣-Feign-调用原理"><a href="#2️⃣-Feign-调用原理" class="headerlink" title="2️⃣ Feign 调用原理"></a>2️⃣ Feign 调用原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FeignClient Proxy（动态代理）</span><br><span class="line">    ↓</span><br><span class="line">Spring Cloud LoadBalancer（选择实例）</span><br><span class="line">    ↓</span><br><span class="line">Ribbon 或 RestTemplate 执行 HTTP 请求</span><br><span class="line">    ↓</span><br><span class="line">返回结果 → JSON 转对象</span><br></pre></td></tr></table></figure><hr><h3 id="3️⃣-示例"><a href="#3️⃣-示例" class="headerlink" title="3️⃣ 示例"></a>3️⃣ 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name=&quot;user-service&quot;, path=&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用 <code>userClient.getUser(1L)</code> 时：</p><ol><li>Feign 创建动态代理对象</li><li>使用服务注册中心获取可用实例</li><li>通过 HTTP 发起请求</li><li>返回 JSON 转对象</li></ol></blockquote><hr><h2 id="四、网关（Spring-Cloud-Gateway）"><a href="#四、网关（Spring-Cloud-Gateway）" class="headerlink" title="四、网关（Spring Cloud Gateway）"></a>四、网关（Spring Cloud Gateway）</h2><h3 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@EnableGateway</code></td><td>启用网关（Spring Boot 自动装配即可）</td></tr><tr><td><code>@Bean RouteLocator</code></td><td>配置路由规则</td></tr><tr><td><code>@Configuration</code></td><td>配置类，定义自定义过滤器</td></tr></tbody></table><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><ul><li>基于 <strong>WebFlux &#x2F; Netty</strong> 实现异步非阻塞网关</li><li>请求 → GlobalFilter → RouteLocator 匹配 → 目标服务</li><li>支持限流、熔断、重试、认证等功能</li></ul><hr><h2 id="五、熔断与降级（Resilience4j-Spring-Cloud-CircuitBreaker）"><a href="#五、熔断与降级（Resilience4j-Spring-Cloud-CircuitBreaker）" class="headerlink" title="五、熔断与降级（Resilience4j &#x2F; Spring Cloud CircuitBreaker）"></a>五、熔断与降级（Resilience4j &#x2F; Spring Cloud CircuitBreaker）</h2><h3 id="核心注解-1"><a href="#核心注解-1" class="headerlink" title="核心注解"></a>核心注解</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@EnableCircuitBreaker</code></td><td>启用熔断器</td></tr><tr><td><code>@CircuitBreaker(name=&quot;backend&quot;, fallbackMethod=&quot;fallback&quot;)</code></td><td>方法级熔断</td></tr><tr><td><code>@Retryable</code></td><td>方法重试</td></tr><tr><td><code>@TimeLimiter</code></td><td>异步方法超时控制</td></tr></tbody></table><hr><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>调用被监控方法</li><li>出现异常或超时，熔断器计数器累加</li><li>达到阈值 → 打开熔断，直接调用 fallback</li><li>超过时间或条件恢复 → 关闭熔断器</li></ol><hr><h2 id="六、面试高频问点"><a href="#六、面试高频问点" class="headerlink" title="六、面试高频问点"></a>六、面试高频问点</h2><table><thead><tr><th>问题</th><th>高分回答</th></tr></thead><tbody><tr><td>Spring Cloud 如何实现服务注册与发现？</td><td>微服务启动注册到 Eureka&#x2F;Nacos，通过客户端缓存获取可用服务列表，实现服务调用。</td></tr><tr><td>@FeignClient 如何负载均衡？</td><td>结合 Ribbon 或 Spring Cloud LoadBalancer，通过服务注册中心获取实例列表，并按策略选择。</td></tr><tr><td>网关路由原理？</td><td>请求经过 GlobalFilter → RouteLocator 匹配 → Forward 到目标服务，支持限流、认证、熔断。</td></tr><tr><td>熔断器是怎么工作的？</td><td>通过 CircuitBreaker 监控方法调用，达到阈值时打开熔断，调用 fallback 方法。</td></tr><tr><td>@RefreshScope 作用？</td><td>允许 Bean 在配置中心更新时热刷新，不重启应用即可生效。</td></tr></tbody></table><hr><p>完全可以 😎！我帮你整理一份 <strong>六大框架超级速记卡 &#x2F; 可打印版知识图谱</strong>，兼顾：</p><ul><li><strong>结构图</strong>：模块 + 核心注解分类</li><li><strong>流程链</strong>：底层执行顺序（请求 → 执行 → 返回）</li><li><strong>时机表</strong>：各注解触发时机 &#x2F; 生命周期</li></ul><p>我设计成一页 A4 可打印的面试速记卡风格，每个框架重点突出高频面试点。</p><hr><h3 id="样例结构（六大框架速查卡）"><a href="#样例结构（六大框架速查卡）" class="headerlink" title="样例结构（六大框架速查卡）"></a>样例结构（六大框架速查卡）</h3><hr><h2 id="1️⃣-Spring-核心注解-生命周期"><a href="#1️⃣-Spring-核心注解-生命周期" class="headerlink" title="1️⃣ Spring 核心注解 &amp; 生命周期"></a>1️⃣ Spring 核心注解 &amp; 生命周期</h2><p><strong>模块结构图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component / @Service / @Repository / @Controller</span><br><span class="line">         ↓</span><br><span class="line">@Autowired / @Qualifier → 依赖注入</span><br><span class="line">@PostConstruct / @PreDestroy → 生命周期回调</span><br><span class="line">@Scope → Bean 范围（Singleton / Prototype / Request / Session）</span><br></pre></td></tr></table></figure><p><strong>执行链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bean 定义加载 → BeanPostProcessor → 初始化（@PostConstruct） → 依赖注入完成 → Bean 可用</span><br></pre></td></tr></table></figure><p><strong>时机表</strong>：</p><table><thead><tr><th>注解</th><th>触发时机</th></tr></thead><tbody><tr><td>@Component&#x2F;@Service</td><td>容器启动扫描注册</td></tr><tr><td>@Autowired</td><td>Bean 初始化阶段注入</td></tr><tr><td>@PostConstruct</td><td>Bean 初始化后立即调用</td></tr><tr><td>@PreDestroy</td><td>容器关闭前调用</td></tr></tbody></table><hr><h2 id="2️⃣-SpringMVC-注解-请求处理"><a href="#2️⃣-SpringMVC-注解-请求处理" class="headerlink" title="2️⃣ SpringMVC 注解 &amp; 请求处理"></a>2️⃣ SpringMVC 注解 &amp; 请求处理</h2><p><strong>结构图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Controller / @RestController</span><br><span class="line">        ↓</span><br><span class="line">@RequestMapping / @GetMapping / @PostMapping</span><br><span class="line">        ↓</span><br><span class="line">@PathVariable / @RequestParam / @RequestBody / @ResponseBody</span><br><span class="line">        ↓</span><br><span class="line">@ExceptionHandler / @ControllerAdvice</span><br></pre></td></tr></table></figure><p><strong>执行链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP 请求 → DispatcherServlet → HandlerMapping → HandlerAdapter → Controller → ViewResolver → Response</span><br></pre></td></tr></table></figure><p><strong>时机表</strong>：</p><table><thead><tr><th>注解</th><th>触发时机</th></tr></thead><tbody><tr><td>@ControllerAdvice</td><td>Controller 异常触发</td></tr><tr><td>@InitBinder</td><td>Controller 方法调用前绑定参数</td></tr><tr><td>@RequestBody &#x2F; @ResponseBody</td><td>方法调用序列中请求解析 &amp; 响应序列化</td></tr></tbody></table><hr><h2 id="3️⃣-MyBatis-注解-SQL-执行"><a href="#3️⃣-MyBatis-注解-SQL-执行" class="headerlink" title="3️⃣ MyBatis 注解 &amp; SQL 执行"></a>3️⃣ MyBatis 注解 &amp; SQL 执行</h2><p><strong>结构图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Mapper / @MapperScan</span><br><span class="line">        ↓</span><br><span class="line">MapperProxy → SqlSession → Executor → StatementHandler → ResultSetHandler → 返回对象</span><br><span class="line">@Select / @Insert / @Update / @Delete</span><br><span class="line">@Param → 参数绑定</span><br><span class="line">@Results / @Result → 字段映射</span><br></pre></td></tr></table></figure><p><strong>执行链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口方法调用 → MapperProxy.invoke() → SqlSession.select() → Executor → JDBC → ResultSet → 映射到对象</span><br></pre></td></tr></table></figure><p><strong>时机表</strong>：</p><table><thead><tr><th>注解</th><th>触发时机</th></tr></thead><tbody><tr><td>@MapperScan</td><td>容器启动时扫描 Mapper</td></tr><tr><td>@Select &#x2F; @Insert</td><td>方法调用时解析 SQL</td></tr><tr><td>@Param</td><td>方法调用解析参数</td></tr><tr><td>@Results</td><td>执行 SQL 返回结果映射</td></tr></tbody></table><hr><h2 id="4️⃣-Spring-Boot-注解-自动装配"><a href="#4️⃣-Spring-Boot-注解-自动装配" class="headerlink" title="4️⃣ Spring Boot 注解 &amp; 自动装配"></a>4️⃣ Spring Boot 注解 &amp; 自动装配</h2><p><strong>结构图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">        ↓</span><br><span class="line">@SpringBootConfiguration / @EnableAutoConfiguration / @ComponentScan</span><br><span class="line">        ↓</span><br><span class="line">@ConfigurationProperties → 配置绑定</span><br><span class="line">@Conditional 系列 → 条件加载</span><br></pre></td></tr></table></figure><p><strong>执行链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.run() → ApplicationContext 创建 → 自动配置加载 → Bean 实例化 → 自动装配 → 容器启动</span><br></pre></td></tr></table></figure><p><strong>时机表</strong>：</p><table><thead><tr><th>注解</th><th>触发时机</th></tr></thead><tbody><tr><td>@EnableAutoConfiguration</td><td>ApplicationContext 创建阶段</td></tr><tr><td>@ConditionalOnClass &#x2F; OnMissingBean</td><td>Bean 实例化前条件判断</td></tr><tr><td>@ConfigurationProperties</td><td>Bean 实例化绑定属性</td></tr><tr><td>@Value</td><td>Bean 初始化注入属性</td></tr></tbody></table><hr><h2 id="5️⃣-Spring-Security-注解-权限控制"><a href="#5️⃣-Spring-Security-注解-权限控制" class="headerlink" title="5️⃣ Spring Security 注解 &amp; 权限控制"></a>5️⃣ Spring Security 注解 &amp; 权限控制</h2><p><strong>结构图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@EnableWebSecurity</span><br><span class="line">        ↓</span><br><span class="line">FilterChainProxy → 各类 Filter（认证/授权）</span><br><span class="line">@Secured / @PreAuthorize / @PostAuthorize / @RolesAllowed</span><br><span class="line">@AuthenticationPrincipal → 注入用户</span><br><span class="line">@WithMockUser → 测试</span><br></pre></td></tr></table></figure><p><strong>执行链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求 → FilterChainProxy → AuthenticationManager → UserDetailsService → 验证 → SecurityContextHolder → 授权 → Controller</span><br></pre></td></tr></table></figure><p><strong>时机表</strong>：</p><table><thead><tr><th>注解</th><th>触发时机</th></tr></thead><tbody><tr><td>@EnableWebSecurity</td><td>容器启动配置安全过滤器链</td></tr><tr><td>@PreAuthorize &#x2F; @Secured</td><td>方法调用前判断权限</td></tr><tr><td>@PostAuthorize</td><td>方法执行后基于返回值判断</td></tr><tr><td>@AuthenticationPrincipal</td><td>Controller 方法参数注入当前用户</td></tr></tbody></table><hr><h2 id="6️⃣-Spring-Cloud-注解-微服务调用"><a href="#6️⃣-Spring-Cloud-注解-微服务调用" class="headerlink" title="6️⃣ Spring Cloud 注解 &amp; 微服务调用"></a>6️⃣ Spring Cloud 注解 &amp; 微服务调用</h2><p><strong>结构图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableEurekaClient / @EnableDiscoveryClient</span><br><span class="line">        ↓</span><br><span class="line">服务注册 → Eureka / Nacos</span><br><span class="line">@LoadBalanced → RestTemplate / WebClient</span><br><span class="line">@FeignClient → 声明式远程调用</span><br><span class="line">@CircuitBreaker / @Retryable → 熔断与重试</span><br><span class="line">@RefreshScope → 配置热刷新</span><br></pre></td></tr></table></figure><p><strong>执行链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端请求 → 服务注册中心获取实例 → 负载均衡选择 → 远程调用 → 返回 → 熔断/降级处理</span><br></pre></td></tr></table></figure><p><strong>时机表</strong>：</p><table><thead><tr><th>注解</th><th>触发时机</th></tr></thead><tbody><tr><td>@EnableEurekaClient</td><td>启动时注册服务</td></tr><tr><td>@FeignClient</td><td>接口方法调用时生成动态代理发 HTTP</td></tr><tr><td>@LoadBalanced</td><td>RestTemplate 调用前选择服务实例</td></tr><tr><td>@CircuitBreaker</td><td>方法执行异常或超时触发</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客面试题</title>
      <link href="/2025/10/01/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/"/>
      <url>/2025/10/01/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="Spring-牛客面经八股"><a href="#Spring-牛客面经八股" class="headerlink" title="Spring-牛客面经八股"></a>Spring-牛客面经八股</h2><hr><h3 id="1-说说-Spring-Boot-常用的注解"><a href="#1-说说-Spring-Boot-常用的注解" class="headerlink" title="1. 说说 Spring Boot 常用的注解"></a><strong>1. 说说 Spring Boot 常用的注解</strong></h3><ul><li><code>@SpringBootApplication</code>：组合注解（<code>@Configuration</code> + <code>@EnableAutoConfiguration</code> + <code>@ComponentScan</code>），应用入口常放在主类上。</li><li><code>@Configuration</code> &#x2F; <code>@Bean</code>：定义配置类和显式创建 Bean。</li><li><code>@Component</code> &#x2F; <code>@Service</code> &#x2F; <code>@Repository</code> &#x2F; <code>@Controller</code> &#x2F; <code>@RestController</code>：组件扫描管理类；<code>@RestController = @Controller + @ResponseBody</code>。</li><li><code>@Autowired</code> &#x2F; <code>@Qualifier</code> &#x2F; <code>@Value</code> &#x2F; <code>@Resource</code>：依赖注入、按类型&#x2F;按名称注入、读取配置。</li><li><code>@ConfigurationProperties</code>：将一组配置绑定到 POJO（推荐用于复杂配置）。</li><li><code>@EnableAutoConfiguration</code>（隐含在 <code>@SpringBootApplication</code> 中）：启用自动配置。</li><li>条件注解（常用于自动配置类）：<code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>、<code>@ConditionalOnProperty</code>、<code>@ConditionalOnBean</code> 等。</li><li><code>@Transactional</code>：声明式事务。</li><li><code>@RestControllerAdvice</code> &#x2F; <code>@ControllerAdvice</code>：统一异常&#x2F;全局处理。</li><li>测试相关：<code>@SpringBootTest</code>、<code>@WebMvcTest</code>、<code>@DataJpaTest</code> 等。</li><li>其他：<code>@EnableScheduling</code>、<code>@EnableCaching</code>、<code>@EnableFeignClients</code>、<code>@EnableDiscoveryClient</code> 等（看用到的组件）。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123; <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; SpringApplication.run(App.class, args); &#125; &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-Spring-Boot-启动流程"><a href="#2-Spring-Boot-启动流程" class="headerlink" title="2.Spring Boot 启动流程"></a><strong>2.Spring Boot 启动流程</strong></h3><p>入口一般是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol><li><h4 id="调用-SpringApplication-run"><a href="#调用-SpringApplication-run" class="headerlink" title="调用 SpringApplication.run(...)"></a>调用 <code>SpringApplication.run(...)</code></h4></li></ol><ul><li><strong>作用</strong>：创建一个 <code>SpringApplication</code> 实例，准备运行环境。</li><li><strong>关键点</strong>：<ul><li>判断当前应用类型（<code>NONE</code>、<code>SERVLET</code>、<code>REACTIVE</code>），决定用什么样的 <code>ApplicationContext</code>。</li><li>加载并设置 <code>ApplicationContextInitializer</code> 和 <code>ApplicationListener</code>。</li></ul></li></ul><hr><ol start="2"><li><h4 id="触发-SpringApplicationRunListeners-的-starting"><a href="#触发-SpringApplicationRunListeners-的-starting" class="headerlink" title="触发 SpringApplicationRunListeners 的 starting()"></a>触发 <code>SpringApplicationRunListeners</code> 的 <code>starting()</code></h4></li></ol><ul><li><strong>事件</strong>：<code>ApplicationStartingEvent</code>。</li><li><strong>触发时机</strong>：Spring 环境还未初始化前。</li><li><strong>用途</strong>：做一些极早期的日志初始化、Banner 输出等。</li></ul><hr><ol start="3"><li><h4 id="准备-Environment"><a href="#准备-Environment" class="headerlink" title="准备 Environment"></a>准备 <code>Environment</code></h4></li></ol><ul><li><strong>工作内容</strong>：<ul><li>创建 <code>ConfigurableEnvironment</code>（不同应用类型对应不同环境类）。</li><li>加载配置源：系统属性、环境变量、命令行参数、<code>application.properties</code> &#x2F; <code>application.yml</code>、<code>@PropertySource</code>。</li><li>执行 <code>ConfigFileApplicationListener</code>，解析并注入配置文件属性。</li></ul></li><li><strong>扩展点</strong>：可通过 <code>EnvironmentPostProcessor</code> 在环境准备阶段修改&#x2F;添加配置。</li></ul><hr><ol start="4"><li><h4 id="创建并准备-ApplicationContext"><a href="#创建并准备-ApplicationContext" class="headerlink" title="创建并准备 ApplicationContext"></a>创建并准备 <code>ApplicationContext</code></h4></li></ol><ul><li><strong>默认情况</strong>：<ul><li>普通应用 → <code>AnnotationConfigApplicationContext</code></li><li>Web Servlet 应用 → <code>AnnotationConfigServletWebServerApplicationContext</code></li><li>Web Reactive 应用 → <code>AnnotationConfigReactiveWebServerApplicationContext</code></li></ul></li><li><strong>扩展点</strong>：可通过 <code>SpringApplication.setApplicationContextClass()</code> 自定义上下文类型。</li></ul><hr><ol start="5"><li><h4 id="调用-ApplicationContextInitializer"><a href="#调用-ApplicationContextInitializer" class="headerlink" title="调用 ApplicationContextInitializer"></a>调用 <code>ApplicationContextInitializer</code></h4></li></ol><ul><li><strong>作用</strong>：在 <code>ApplicationContext</code> 刷新之前，可以对其进行个性化处理。</li><li><strong>加载方式</strong>：<ul><li><code>spring.factories</code> 中的 <code>ApplicationContextInitializer</code>。</li><li><code>SpringApplication.addInitializers(...)</code> 手动添加。</li></ul></li><li><strong>应用场景</strong>：在容器 refresh 前注册属性源、配置 BeanDefinition 等。</li></ul><hr><ol start="6"><li><h4 id="加载自动配置"><a href="#加载自动配置" class="headerlink" title="加载自动配置"></a>加载自动配置</h4></li></ol><ul><li><strong>关键机制</strong>：<ul><li><code>@EnableAutoConfiguration</code> 触发 <code>AutoConfigurationImportSelector</code>。</li><li>从 <code>META-INF/spring.factories</code> 或 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 加载所有候选配置类。</li><li>通过 <code>@ConditionalOnClass</code>、<code>@ConditionalOnBean</code>、<code>@ConditionalOnMissingBean</code> 等条件注解筛选。</li></ul></li><li><strong>结果</strong>：按需装配 starter 中的 Bean（如 <code>DataSourceAutoConfiguration</code>、<code>WebMvcAutoConfiguration</code> 等）。</li></ul><hr><ol start="7"><li><h4 id="执行-BeanFactoryPostProcessor"><a href="#执行-BeanFactoryPostProcessor" class="headerlink" title="执行 BeanFactoryPostProcessor"></a>执行 <code>BeanFactoryPostProcessor</code></h4></li></ol><ul><li><strong>代表类</strong>：<ul><li><code>ConfigurationClassPostProcessor</code>：解析 <code>@Configuration</code> 类、<code>@ComponentScan</code>、<code>@Import</code>、<code>@Bean</code> 等注解。</li><li>其他定制的 <code>BeanFactoryPostProcessor</code>。</li></ul></li><li><strong>扩展点</strong>：可以在 BeanDefinition 阶段修改 bean 的元数据。</li></ul><hr><ol start="8"><li><h4 id="创建并实例化单例-Bean"><a href="#创建并实例化单例-Bean" class="headerlink" title="创建并实例化单例 Bean"></a>创建并实例化单例 Bean</h4></li></ol><p>过程：</p><ol><li><strong>实例化</strong>（调用构造器）。</li><li><strong>依赖注入</strong>（populate 属性）。</li><li><strong>回调 Aware 接口</strong>（如 <code>BeanNameAware</code>、<code>ApplicationContextAware</code>）。</li><li><strong>BeanPostProcessor#postProcessBeforeInitialization</strong>。</li><li><strong>初始化方法</strong>（<code>@PostConstruct</code>、<code>InitializingBean.afterPropertiesSet()</code>、自定义 init-method）。</li><li><strong>BeanPostProcessor#postProcessAfterInitialization&#96;</strong>。</li><li>最终放入一级缓存（<code>singletonObjects</code>）。</li></ol><hr><ol start="9"><li><h4 id="容器-refresh-完成"><a href="#容器-refresh-完成" class="headerlink" title="容器 refresh() 完成"></a>容器 <code>refresh()</code> 完成</h4></li></ol><ul><li><strong>标志事件</strong>：<ul><li><code>ApplicationStartedEvent</code>：容器启动完成。</li><li><code>ApplicationReadyEvent</code>：应用准备好接收请求。</li></ul></li><li><strong>其他事件</strong>：<ul><li><code>ContextRefreshedEvent</code>（上下文刷新完成）。</li><li><code>WebServerInitializedEvent</code>（WebServer 启动完成）。</li></ul></li></ul><hr><ol start="10"><li><h4 id="应用接受请求-启动异常处理"><a href="#应用接受请求-启动异常处理" class="headerlink" title="应用接受请求 &#x2F; 启动异常处理"></a>应用接受请求 &#x2F; 启动异常处理</h4></li></ol><ul><li>成功：Web 应用启动，内嵌 Tomcat&#x2F;Jetty&#x2F;Undertow 已经监听端口。</li><li>失败：触发 <code>ApplicationFailedEvent</code>，进入 <code>FailureAnalyzers</code> 分析错误并输出人性化提示。</li></ul><hr><h4 id="🔑-重要扩展点总结"><a href="#🔑-重要扩展点总结" class="headerlink" title="🔑 重要扩展点总结"></a>🔑 重要扩展点总结</h4><ul><li><p><strong>ApplicationListeners</strong>：贯穿整个生命周期，可监听各种事件。</p></li><li><p><strong>ApplicationContextInitializer</strong>：在容器刷新前定制化上下文。</p></li><li><p><strong>BeanFactoryPostProcessor</strong>：修改 BeanDefinition。</p></li><li><p><strong>BeanPostProcessor</strong>：定制 Bean 实例化前后行为。</p></li><li><p><strong>@ConditionalOn…</strong>：自动配置的核心。</p><p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/5c3752c7c3fa4d4eafa6ea73fee027d7%7Etplv-k3u1fbpfcp-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.jpg" alt="Spring-Springboot启动流程图.jpg"></p></li></ul><hr><h3 id="3-对-IoC（Inversion-of-Control-依赖注入）的理解"><a href="#3-对-IoC（Inversion-of-Control-依赖注入）的理解" class="headerlink" title="3. 对 IoC（Inversion of Control &#x2F; 依赖注入）的理解"></a><strong>3. 对 IoC（Inversion of Control &#x2F; 依赖注入）的理解</strong></h3><ul><li>本质：把对象的创建和依赖的组装（控制权）从类内部移到容器（Spring）来管理——“控制反转”。实际表现为依赖注入（Dependency Injection）。</li><li>优点：解耦（组件只声明依赖，不负责创建）、易测试（可以注入 mock）、统一管理生命周期、便于 AOP 切面化。</li><li>注入方式：构造器注入（推荐，强制依赖、利于测试）、setter 注入、字段注入（简便但不推荐）。</li><li>容器职责：管理 bean 的实例化、装配、生命周期、作用域（singleton&#x2F;prototype&#x2F;request&#x2F;session）等。</li></ul><hr><h3 id="4-对-AOP（面向切面编程）的理解"><a href="#4-对-AOP（面向切面编程）的理解" class="headerlink" title="4. 对 AOP（面向切面编程）的理解"></a><strong>4. 对 AOP（面向切面编程）的理解</strong></h3><ul><li>目的：把横切关注点（日志&#x2F;事务&#x2F;安全&#x2F;缓存等）从业务代码分离出来。</li><li>术语：切面（Aspect）、通知（Advice：before&#x2F;after&#x2F;around&#x2F;afterReturning&#x2F;afterThrowing）、连接点（Join point）、切入点（Pointcut）、目标对象（Target）、代理（Proxy）。</li><li>实现方式：Spring 默认基于代理（JDK 动态代理：接口；CGLIB：类代理）；也可用 AspectJ（编译&#x2F;类加载期织入）实现更强的能力。</li><li>常见限制：代理是对象外部的包装 → 自身（同类）方法调用不会触发代理（self-invocation 问题）；可用 <code>AopContext.currentProxy()</code> 或 AspectJ 解决，或将需要切面的调用拆到另一个 bean。</li><li>使用示例（注解式）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">  <span class="meta">@Around(&quot;execution(* com.example.service..*(..))&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">log</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// before</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="comment">// after</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-Bean-的生命周期（主要步骤与钩子）"><a href="#5-Bean-的生命周期（主要步骤与钩子）" class="headerlink" title="5. Bean 的生命周期（主要步骤与钩子）"></a><strong>5. Bean 的生命周期（主要步骤与钩子）</strong></h3><ol><li><strong>实例化</strong>（instantiate bean）</li><li><strong>依赖注入</strong>（populate properties）</li><li>Aware 接口回调：<code>BeanNameAware.setBeanName()</code>、<code>BeanFactoryAware.setBeanFactory()</code>、<code>ApplicationContextAware.setApplicationContext()</code> 等</li><li><code>BeanPostProcessor.postProcessBeforeInitialization(...)</code></li><li>初始化回调：<code>@PostConstruct</code>、<code>afterPropertiesSet()</code> (InitializingBean)、自定义 <code>init-method</code></li><li><code>BeanPostProcessor.postProcessAfterInitialization(...)</code> → Bean 就绪可用（在容器中）</li><li><strong>销毁</strong>（单例在容器关闭时）: <code>@PreDestroy</code>、<code>DisposableBean.destroy()</code>、自定义 <code>destroy-method</code>。</li></ol><ul><li>另外：<code>SmartLifecycle</code>、<code>InitializingBean</code>、<code>DisposableBean</code>、<code>BeanFactoryPostProcessor</code>、<code>BeanPostProcessor</code> 等都参与生命周期扩展。</li></ul><hr><h3 id="6-Autowired-和-Resource-的区别"><a href="#6-Autowired-和-Resource-的区别" class="headerlink" title="6. @Autowired 和 @Resource 的区别"></a><strong>6. <code>@Autowired</code> 和 <code>@Resource</code> 的区别</strong></h3><ul><li>来源：<code>@Autowired</code> 是 Spring 注解；<code>@Resource</code> 是 JSR-250（Java 标准）。</li><li><strong>注入方式</strong>：<ul><li><code>@Autowired</code>：按 <strong>类型（byType）</strong> 注入；若有多个候选可结合 <code>@Qualifier</code> 或 <code>@Primary</code>。支持 <code>required</code>（默认 <code>true</code>，可设 <code>false</code>）或 <code>Optional&lt;T&gt;</code> &#x2F; <code>@Nullable</code>。支持构造器&#x2F;字段&#x2F;setter。</li><li><code>@Resource</code>：默认按 <strong>名称（byName）</strong> 注入（会先按 name 属性或字段名匹配 bean 名称），若找不到则回退按类型注入。没有 <code>required</code> 属性。</li></ul></li><li>使用习惯：<code>@Autowired</code> 更常见（Spring 风格）；如果需要严格按 bean 名称注入可用 <code>@Resource(name=&quot;...&quot;)</code>。</li><li>另外：<code>@Inject</code>（JSR-330）类似 <code>@Autowired</code>（按类型）。</li></ul><hr><h3 id="7-Spring-事务管理"><a href="#7-Spring-事务管理" class="headerlink" title="7. Spring 事务管理"></a><strong>7. Spring 事务管理</strong></h3><ul><li>两种方式：<strong>声明式</strong>（<code>@Transactional</code> 最常见）和<strong>编程式</strong>（<code>PlatformTransactionManager</code> + <code>TransactionTemplate</code>）。</li><li>事务管理器（常见）：<code>DataSourceTransactionManager</code>（JDBC）、<code>JpaTransactionManager</code>（JPA&#x2F;Hibernate）、<code>JtaTransactionManager</code>（分布式&#x2F;XA）。</li><li><code>@Transactional</code> 常用属性：<code>propagation</code>、<code>isolation</code>、<code>readOnly</code>、<code>timeout</code>、<code>rollbackFor</code>&#x2F;<code>noRollbackFor</code>。</li><li><strong>传播行为</strong>（常用几种）：<ul><li><code>REQUIRED</code>（默认）：如果有事务就加入，否则新建。</li><li><code>REQUIRES_NEW</code>：挂起当前事务，另启新事务（独立提交&#x2F;回滚）。</li><li><code>NESTED</code>：在同一物理连接上通过 savepoint 实现“子事务”（回滚到 savepoint），只有支持 JDBC 的事务管理器才有效。</li><li><code>SUPPORTS</code>、<code>NOT_SUPPORTED</code>、<code>MANDATORY</code>、<code>NEVER</code> 等。</li></ul></li><li>回滚规则：默认对 unchecked（<code>RuntimeException</code>、<code>Error</code>）回滚；若要对 checked exception 回滚需指定 <code>rollbackFor</code>。</li><li>注意点：<code>@Transactional</code> 通过 AOP 代理实现（代理对象拦截方法并管理事务），因此<strong>同类内部方法调用</strong>不会走代理，事务注解不会生效（self-invocation）。解决办法：把方法放到另一个 bean、使用 <code>AspectJ</code> 或手动通过 <code>TransactionTemplate</code>。</li><li>事务与连接：Spring 管理 JDBC 连接绑定到线程（事务同步），propagation 影响是否复用或者新开连接。</li></ul><hr><h3 id="8-Spring-MVC-的执行流程（请求到响应的完整链路）"><a href="#8-Spring-MVC-的执行流程（请求到响应的完整链路）" class="headerlink" title="8. Spring MVC 的执行流程（请求到响应的完整链路）"></a><strong>8. Spring MVC 的执行流程（请求到响应的完整链路）</strong></h3><p> 简化流程（按实际处理顺序）：</p><ol><li><strong>客户端请求</strong> → 到 <code>DispatcherServlet</code>（前端控制器，Front Controller）。</li><li><code>HandlerMapping</code> 根据 URL 找到对应的 Handler（Controller 方法，内部为 <code>HandlerMethod</code>）。</li><li>执行 <code>HandlerInterceptor.preHandle()</code>（可拦截、返回 false 终止）。</li><li><code>HandlerAdapter</code> 调用 Controller 方法：内部会执行 <code>HandlerMethodArgumentResolver</code>（解析方法参数）和 <code>HandlerMethodReturnValueHandler</code>（处理返回值）。对于 <code>@ResponseBody</code> &#x2F; 返回对象，会交给 <code>HttpMessageConverter</code> 序列化（JSON&#x2F;XML）。</li><li>Controller 返回 <code>ModelAndView</code> 或视图名或响应体。</li><li><code>HandlerInterceptor.postHandle()</code>（可修改 ModelAndView）。</li><li><code>ViewResolver</code> 解析视图，<code>View</code> 渲染最终响应；若 <code>@ResponseBody</code>，则直接写出。</li><li><code>HandlerInterceptor.afterCompletion()</code>（清理工作），以及 <code>ExceptionResolver</code> 处理异常路径。</li></ol><p>关键扩展点：拦截器、过滤器、异常处理器（<code>@ControllerAdvice</code> &#x2F; <code>HandlerExceptionResolver</code>）、参数解析（<code>@RequestParam</code>、<code>@PathVariable</code>、<code>@RequestBody</code>）等。</p><hr><h3 id="9-Component-和-Bean-的区别"><a href="#9-Component-和-Bean-的区别" class="headerlink" title="9. @Component 和 @Bean 的区别"></a><strong>9. <code>@Component</code> 和 <code>@Bean</code> 的区别</strong></h3><ul><li><code>@Component</code>：类级注解，交给组件扫描自动发现并注册为 bean。适合你自己写的类。</li><li><code>@Bean</code>：方法级注解，放在 <code>@Configuration</code> 类中，由方法的返回值注册为 bean。适合第三方类或需要程序化创建的 bean。</li><li>细节区别：<ul><li><code>@Configuration</code> 类会被 CGLIB 代理以保证 <code>@Bean</code> 方法的单例语义（同一配置类内调用 <code>@Bean</code> 方法会返回容器中的单例，而不是新实例）。</li><li><code>@Component</code> 比较“自动”，<code>@Bean</code> 更显式、可编程（可以在方法中做复杂逻辑）。</li><li>注入优先级&#x2F;覆盖规则：<code>@Bean</code> 定义的 bean 名称可和扫描到的组件冲突，容器按注册顺序&#x2F;配置决定覆盖或报错（可用 <code>@Primary</code>、<code>@Order</code> 或显式排除）。</li></ul></li></ul><hr><h3 id="10-Spring-中用到的设计模式"><a href="#10-Spring-中用到的设计模式" class="headerlink" title="10. Spring 中用到的设计模式"></a><strong>10. Spring 中用到的设计模式</strong></h3><ul><li><strong>单例模式（Singleton）</strong>：Spring 的单例 scope（容器保证）。</li><li><strong>工厂模式（Factory） &#x2F; 抽象工厂</strong>：<code>BeanFactory</code>&#x2F;<code>ApplicationContext</code> 提供 <code>getBean</code>。</li><li><strong>代理模式（Proxy）</strong>：AOP 使用（JDK 动态代理 &#x2F; CGLIB）。</li><li><strong>模板方法模式（Template Method）</strong>：<code>JdbcTemplate</code>, <code>JmsTemplate</code> 等，封装固定流程，留钩子给子类&#x2F;回调。</li><li><strong>策略模式（Strategy）</strong>：可插拔的实现选择，如不同的序列化&#x2F;编码&#x2F;厂商策略、事务策略。</li><li><strong>观察者模式（Observer）</strong>：<code>ApplicationEvent</code> &#x2F; <code>ApplicationListener</code>。</li><li><strong>前端控制器（Front Controller）</strong>：<code>DispatcherServlet</code>。</li><li><strong>适配器模式（Adapter）</strong>：<code>HandlerAdapter</code> 用于适配不同 handler。</li><li><strong>责任链（Chain of Responsibility）</strong>：Servlet Filter 链、Spring Security 的 filter chain、Interceptor 链。</li><li><strong>门面模式（Facade）</strong>：例如 <code>JdbcTemplate</code> 对复杂 JDBC 操作的简化封装。</li></ul><hr><h3 id="11-Spring-循环依赖是什么？介绍下三级缓存"><a href="#11-Spring-循环依赖是什么？介绍下三级缓存" class="headerlink" title="11. Spring 循环依赖是什么？介绍下三级缓存"></a><strong>11. Spring 循环依赖是什么？介绍下三级缓存</strong></h3><ul><li><strong>循环依赖</strong>：A -&gt; B -&gt; A 的依赖关系。Spring 能自动解决部分场景（<strong>单例 bean 且为 setter&#x2F;属性注入</strong> 的情况可以解决；<strong>构造器注入</strong> 则无法解决）。</li><li><strong>三级缓存（三缓存）</strong>（Spring 单例循环依赖解决的核心）：<ol><li><strong>singletonObjects</strong>（一级缓存）——完全初始化好的单例 bean 实例（最终放这里）。</li><li><strong>earlySingletonObjects</strong>（二级缓存）——提前曝光的 bean 实例（未完成初始化但可以被其它 bean 引用，通常用于原始对象或早期代理）。</li><li><strong>singletonFactories</strong>（三级缓存）——保存一个 <code>ObjectFactory</code>，当需要早期引用时可以调用它得到（常用于创建代理对象，支持 AOP 情况）。</li></ol></li><li><strong>简要流程</strong>（创建 bean A）：<ol><li>实例化 A（还没注入属性）。把 A 的 <code>ObjectFactory</code> 放入 <code>singletonFactories</code>（使别人能拿到早期引用）。</li><li>当创建 B 时需要 A，会先从 <code>singletonObjects</code> 看不到，再从 <code>earlySingletonObjects</code> &#x2F; <code>singletonFactories</code> 找到早期引用并加入 <code>earlySingletonObjects</code>。</li><li>B 的注入完成后返回，A 完成属性注入、执行后置处理器，最后把 A 放入 <code>singletonObjects</code>，并从早期缓存移除。</li></ol></li><li><strong>限制 &amp; 注意</strong>：<ul><li>只能解决<strong>单例且非构造器注入</strong>的循环依赖；构造器注入需要构造函数就得到依赖，无法提前暴露，故会抛异常。</li><li>AOP 代理会影响：默认如果需要代理，Spring 会在 <code>singletonFactories</code> 存入创建代理的工厂，这样早期引用能得到代理，避免后续再创建新的代理导致不一致。</li><li>Prototype scope（原型）不支持自动解决循环依赖。</li></ul></li></ul><hr><h3 id="12-Spring-Security-是什么？"><a href="#12-Spring-Security-是什么？" class="headerlink" title="12. Spring Security 是什么？"></a><strong>12. Spring Security 是什么？</strong></h3><ul><li>Spring Security 是一个提供认证（Authentication）与授权&#x2F;访问控制（Authorization）的企业级安全框架，功能包括：登录&#x2F;登出、权限控制、方法级安全、会话管理、CSRF 防护、加密密码、集成 OAuth2 &#x2F; OIDC &#x2F; SSO 等。</li><li>主要组件：<code>SecurityFilterChain</code>（一系列 Filter 拦截与安全处理）、<code>AuthenticationManager</code>、<code>UserDetailsService</code>（加载用户信息）、<code>GrantedAuthority</code>（权限）、密码编码器（如 <code>BCryptPasswordEncoder</code>）、<code>MethodSecurity</code>（<code>@Secured</code>、<code>@PreAuthorize</code>）等。</li><li>集成点：与 Spring MVC &#x2F; WebFlux 无缝集成，常用配置有基于 DSL 的 Java Config（Spring Security 5+ 风格）以及注解式方法安全。</li></ul><hr><h3 id="13-Spring、Spring-MVC、Spring-Boot-三者之间的关系"><a href="#13-Spring、Spring-MVC、Spring-Boot-三者之间的关系" class="headerlink" title="13. Spring、Spring MVC、Spring Boot 三者之间的关系"></a><strong>13. Spring、Spring MVC、Spring Boot 三者之间的关系</strong></h3><ul><li><strong>Spring Framework</strong>：底层核心框架，提供 IoC（依赖注入）、AOP、事务管理、数据访问支持等基础功能。</li><li><strong>Spring MVC</strong>：Spring 的一个模块（web 框架），实现 MVC 模式，基于 Spring 的 IoC&#x2F;AOP 运行，负责处理 HTTP 请求、分发到 Controller、渲染视图等。</li><li><strong>Spring Boot</strong>：基于 Spring 的约定优于配置（opinionated）框架，简化 Spring 应用的配置与启动（starter 依赖、自动配置、嵌入式容器、Actuator 等）。它不是替代 Spring，而是简化使用 Spring（及 Spring MVC、Spring Data、Spring Security 等生态）的方式。</li></ul><p>简单：<strong>Spring &#x3D; 基础，Spring MVC &#x3D; Web 模块，Spring Boot &#x3D; 用来快速启动&#x2F;配置 Spring 应用的工具集与约定。</strong></p><hr><h3 id="14-Spring-Boot-自动配置原理（原理概述）"><a href="#14-Spring-Boot-自动配置原理（原理概述）" class="headerlink" title="14. Spring Boot 自动配置原理（原理概述）"></a><strong>14. Spring Boot 自动配置原理（原理概述）</strong></h3><ul><li>核心：<code>@EnableAutoConfiguration</code>（隐含在 <code>@SpringBootApplication</code>）通过 <code>AutoConfigurationImportSelector</code> 导入大量候选自动配置类。</li><li>自动配置类通常放在 <code>org.springframework.boot.autoconfigure.*</code>，并带有条件注解（<code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>、<code>@ConditionalOnProperty</code> 等）来决定是否生效。</li><li><strong>自动配置候选的来源</strong>：传统上通过 <code>META-INF/spring.factories</code> 列表来发现（Spring Boot 2.x 常用），较新的 Boot 版本引入了更现代的自动配置注册机制（也使用 metadata 文件来列出 auto-config 类）。无论机制如何，核心思想是：<strong>按需注册、并允许用户通过 <code>spring.autoconfigure.exclude</code> 或 <code>@SpringBootApplication(exclude=...)</code> 覆盖&#x2F;排除</strong>。</li><li>覆盖顺序：用户显式定义的 <code>@Bean</code> 通常优先于自动配置；自动配置通过条件注解判断是否装配。</li><li>常用条件注解举例：<code>@ConditionalOnClass</code>（类在类路径中时生效）、<code>@ConditionalOnMissingBean</code>（当容器中没有某 bean 时生效）、<code>@ConditionalOnProperty</code>（基于配置属性启用&#x2F;禁用）。</li></ul><blockquote><p>提示：自动配置是“约定优于配置”的实现：在默认配置无法满足时，用户可通过自定义配置&#x2F;排除来自定义行为。</p></blockquote><hr><h3 id="15-Spring-Cloud-的组件有哪些？（常见模块与作用）"><a href="#15-Spring-Cloud-的组件有哪些？（常见模块与作用）" class="headerlink" title="15. Spring Cloud 的组件有哪些？（常见模块与作用）"></a><strong>15. Spring Cloud 的组件有哪些？（常见模块与作用）</strong></h3><p> Spring Cloud 是一套构建分布式系统的工具集合，包含很多子项目。常见模块（并非全部）：</p><ul><li><strong>Spring Cloud Config</strong>：集中式配置管理（server + client）。</li><li><strong>Spring Cloud Netflix</strong>（整合 Netflix OSS）：Eureka（服务发现）、Ribbon（客户端负载均衡，已在新版本逐步被 <code>Spring Cloud LoadBalancer</code> 取代）、Hystrix（断路器，已进入维护&#x2F;弃用，替代方案 <code>Resilience4j</code>）。</li><li><strong>Spring Cloud Gateway</strong>：API 网关&#x2F;路由。</li><li><strong>OpenFeign &#x2F; Spring Cloud OpenFeign</strong>：声明式 HTTP 客户端。</li><li><strong>Spring Cloud LoadBalancer</strong>：客户端负载均衡（替代 Ribbon）。</li><li><strong>Spring Cloud CircuitBreaker</strong>：抽象断路器，支持 Resilience4j 等实现。</li><li><strong>Spring Cloud Stream</strong>：事件&#x2F;消息驱动（Kafka&#x2F;RabbitMQ 绑定）。</li><li><strong>Spring Cloud Bus</strong>：消息总线（广播配置刷新等）。</li><li><strong>Spring Cloud Sleuth &#x2F; Zipkin &#x2F; Micrometer</strong>：分布式追踪与监控。</li><li><strong>Spring Cloud Gateway &#x2F; Zuul（老）</strong>：API 路由&#x2F;网关实现。</li><li><strong>Spring Cloud Contract</strong>：契约测试。</li><li><strong>Spring Cloud Kubernetes &#x2F; Consul &#x2F; Zookeeper</strong>：与 k8s、Consul、ZK 的整合。</li></ul><blockquote><p>注：Spring Cloud 生态很大，不同版本间有替代与弃用（例如 Ribbon -&gt; LoadBalancer，Hystrix 逐步被 Resilience4j 取代），实际项目中按需要选用。</p></blockquote><hr><h3 id="16-在-REQUIRES-NEW-场景下，子事务同时操作同一数据会发生什么？"><a href="#16-在-REQUIRES-NEW-场景下，子事务同时操作同一数据会发生什么？" class="headerlink" title="16. 在 REQUIRES_NEW 场景下，子事务同时操作同一数据会发生什么？"></a><strong>16. 在 <code>REQUIRES_NEW</code> 场景下，子事务同时操作同一数据会发生什么？</strong></h3><p>这是一个非常实战且需要深入理解数据库事务模型与 Spring 事务传播差异的问题。下面分几部分说明：<strong>实现细节、并发与隔离语义、可能的异常&#x2F;问题、解决方案&#x2F;最佳实践</strong>。</p><h4 id="（A）REQUIRES-NEW-的行为（实现层面）"><a href="#（A）REQUIRES-NEW-的行为（实现层面）" class="headerlink" title="（A）REQUIRES_NEW 的行为（实现层面）"></a>（A）<code>REQUIRES_NEW</code> 的行为（实现层面）</h4><ul><li><code>REQUIRES_NEW</code> 会 <strong>挂起</strong> 当前（外层）事务，然后在一个 <strong>独立的事务</strong> 中执行子事务。实现上（本地事务）通常意味着：挂起外层事务的连接&#x2F;事务状态，取得新的数据库连接（或从连接池取出），在该连接上开启新的事务；子事务完成后提交&#x2F;回滚并关闭该连接，然后恢复外层事务继续执行（用原来的连接与事务）。</li><li>结果：子事务的提交或回滚 <strong>与外层事务相互独立</strong>（子事务已提交后，即使外层后续回滚，也无法回滚子事务）。</li></ul><h4 id="（B）若子事务和外层-另一个子事务“同时”操作同一数据，会发生什么？"><a href="#（B）若子事务和外层-另一个子事务“同时”操作同一数据，会发生什么？" class="headerlink" title="（B）若子事务和外层&#x2F;另一个子事务“同时”操作同一数据，会发生什么？"></a>（B）若子事务和外层&#x2F;另一个子事务“同时”操作同一数据，会发生什么？</h4><p>行为由 <strong>数据库隔离级别</strong>、<strong>锁机制</strong>（悲观锁 &#x2F; 行级锁）、以及<strong>操作顺序</strong>决定。常见情况：</p><ol><li><strong>子事务在另一个事务之后提交（顺序不同）</strong><ul><li>若两个事务更新同一行，数据库会对行加锁（具体行为依 DB 引擎）。例如 InnoDB（MySQL）执行 <code>UPDATE</code> 会加行锁。第二个事务会在尝试修改时等待第一个事务释放锁（或触发死锁检测）。最终一个事务会被回滚（DB 检测到死锁）或等待成功后提交。Spring 会把底层 SQLException 转为 <code>DataAccessException</code> 抛出，事务会相应回滚或提交。</li></ul></li><li><strong>并发读写 + 隔离级别影响（READ_COMMITTED vs REPEATABLE_READ）</strong><ul><li><strong>READ_COMMITTED</strong>：每条语句看到的是已提交的数据；如果子事务提交后，外层事务在挂起后恢复并重新读取，会看到子事务的修改。</li><li><strong>REPEATABLE_READ（MySQL 默认）</strong>：事务开始时建立读快照；在外层事务尚未提交且使用 REPEATABLE_READ 时，外层事务可能不会看到子事务提交的更改，直到外层事务结束并重新开始事务。</li><li>因此：数据可见性取决隔离级别与何时读取。</li></ul></li><li><strong>丢失更新（Lost Update）</strong><ul><li>场景：T1（外层）读到值 <code>v</code> → 执行 REQUIRES_NEW 的子事务 T2 更新为 <code>v2</code> 并提交 → T1 继续基于旧 <code>v</code> 计算并写回 → 如果没有版本控制&#x2F;锁机制，会覆盖 T2 的更新（丢失更新）。</li></ul></li><li><strong>悲观锁 &#x2F; 乐观锁的影响</strong><ul><li><strong>悲观锁（SELECT … FOR UPDATE）</strong>：可以避免并发写冲突（会阻塞直到锁释放）。</li><li><strong>乐观锁（version 字段）</strong>：写时检查版本号，不匹配则抛出 <code>OptimisticLockingFailureException</code>，开发者可捕获重试以解决冲突。</li></ul></li></ol><h4 id="（C）与-NESTED-的对比（重要）"><a href="#（C）与-NESTED-的对比（重要）" class="headerlink" title="（C）与 NESTED 的对比（重要）"></a>（C）与 <code>NESTED</code> 的对比（重要）</h4><ul><li><code>NESTED</code> 在多数实现下使用 <strong>同一物理连接 + savepoint</strong> 实现：子事务回滚只是回到 savepoint，不会独立提交。<code>REQUIRES_NEW</code> 是独立事务并提交后不可撤销。</li><li>因此：若想实现“子事务失败不影响外层”且不希望子事务独立提交，<code>NESTED</code> 比 <code>REQUIRES_NEW</code> 更合适（但需 DB &amp; 事务管理器支持）。</li></ul><h4 id="（D）JPA-Hibernate-细节（ORM-层的问题）"><a href="#（D）JPA-Hibernate-细节（ORM-层的问题）" class="headerlink" title="（D）JPA&#x2F;Hibernate 细节（ORM 层的问题）"></a>（D）JPA&#x2F;Hibernate 细节（ORM 层的问题）</h4><ul><li>使用 JPA&#x2F;Hibernate 时，<code>REQUIRES_NEW</code> 会创建新的 <code>EntityManager</code> &#x2F; persistence context。外层事务的持久化上下文（1st-level cache）在恢复后仍保留旧实体的状态（可能是陈旧的）。因此：外层事务需要 <code>entityManager.refresh(entity)</code> 或 <code>entityManager.clear()</code> 来看到子事务的修改，否则可能基于陈旧实体写回，导致覆盖或冲突。</li><li>注意：<code>REQUIRES_NEW</code> 额外创建连接&#x2F;实体管理器，开销较大，且更容易产生并发冲突需要手工处理。</li></ul><h4 id="（E）示例场景（伪代码，说明丢失更新）："><a href="#（E）示例场景（伪代码，说明丢失更新）：" class="headerlink" title="（E）示例场景（伪代码，说明丢失更新）："></a>（E）示例场景（伪代码，说明丢失更新）：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外层事务 T1</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Account</span> <span class="variable">a</span> <span class="operator">=</span> repo.findById(<span class="number">1</span>); <span class="comment">// balance = 100  (snapshot)</span></span><br><span class="line">  modifyByRequiresNew();        <span class="comment">// 在 REQUIRES_NEW 中把 balance -&gt; 200 并提交</span></span><br><span class="line">  <span class="comment">// outer 仍持有 a.balance = 100（未刷新）</span></span><br><span class="line">  a.setBalance(a.getBalance() + <span class="number">50</span>); <span class="comment">// 基于旧值写回 150，覆盖了子事务的 200 -&gt; 丢失更新</span></span><br><span class="line">  repo.save(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyByRequiresNew</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Account</span> <span class="variable">a</span> <span class="operator">=</span> repo.findById(<span class="number">1</span>);</span><br><span class="line">  a.setBalance(<span class="number">200</span>);</span><br><span class="line">  repo.save(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：若不处理，可能出现覆盖&#x2F;丢失更新或不可预期的数据一致性问题。</p><h4 id="（F）数据库级别的异常（死锁、序列化失败等）"><a href="#（F）数据库级别的异常（死锁、序列化失败等）" class="headerlink" title="（F）数据库级别的异常（死锁、序列化失败等）"></a>（F）数据库级别的异常（死锁、序列化失败等）</h4><ul><li>并发更新同一资源可引发<strong>死锁</strong>，DB 会回滚其中一个事务并抛出异常（例如 MySQL 的死锁错误）。Spring 捕获后会抛出 DataAccessException 或其子类，事务回滚。需要在调用方处理（重试或降级）。</li><li>在更严格隔离（<code>SERIALIZABLE</code>）下可能出现序列化异常，也需要重试逻辑。</li></ul><h4 id="（G）最佳实践与建议"><a href="#（G）最佳实践与建议" class="headerlink" title="（G）最佳实践与建议"></a>（G）最佳实践与建议</h4><ol><li><strong>明确事务边界</strong>：不要随意大量使用 <code>REQUIRES_NEW</code>，它会增加连接数和复杂度。只在确实需要“子事务独立提交”的场景使用（如写审计日志、发送外部不可回滚的操作）。</li><li><strong>避免丢失更新</strong>：对重要并发更新场景使用**乐观锁（version）**或**悲观锁（SELECT … FOR UPDATE）**。</li><li><strong>在 JPA 场景谨慎处理 Persistence Context</strong>：<code>REQUIRES_NEW</code> 后如果外层要使用被子事务修改的实体，记得 <code>refresh()</code> 或 <code>clear()</code>，以避免使用 stale entity。</li><li><strong>NESTED vs REQUIRES_NEW</strong>：如果想在同一物理事务里局部回滚用 NESTED（savepoint），想要真正独立提交用 REQUIRES_NEW。</li><li><strong>处理异常与重试</strong>：对可能的死锁&#x2F;序列化冲突做重试策略（指数退避等）。Spring 的 <code>@Transactional</code> 不会自动重试，需自己实现。</li><li><strong>监控与容量注意</strong>：<code>REQUIRES_NEW</code> 增加并发连接数，注意数据库连接池容量。</li></ol><hr><h4 id="小结（关于第16题的实战提醒）"><a href="#小结（关于第16题的实战提醒）" class="headerlink" title="小结（关于第16题的实战提醒）"></a>小结（关于第16题的实战提醒）</h4><ul><li><code>REQUIRES_NEW</code> 会产生独立事务并独立提交。若外层&#x2F;其他事务同时对同一数据修改，最终行为取决于 DB 的锁与隔离级别：会有等待、死锁、丢失更新或序列化冲突等情况。</li><li>解决思路：用乐观锁&#x2F;悲观锁、合理选择传播行为（NESTED vs REQUIRES_NEW）、在 ORM 场景刷新&#x2F;清理持久化上下文、并实现重试策略与良好的异常处理。</li></ul><hr><h2 id="Java基础-牛客面经八股"><a href="#Java基础-牛客面经八股" class="headerlink" title="Java基础-牛客面经八股"></a>Java基础-牛客面经八股</h2><h3 id="1-Java-基本数据类型与引用类型"><a href="#1-Java-基本数据类型与引用类型" class="headerlink" title="1 Java 基本数据类型与引用类型"></a>1 Java 基本数据类型与引用类型</h3><h4 id="1-基本类型（Primitive-Types-8-种）"><a href="#1-基本类型（Primitive-Types-8-种）" class="headerlink" title="1. 基本类型（Primitive Types, 8 种）"></a>1. 基本类型（Primitive Types, 8 种）</h4><ul><li><strong>类型</strong>：<code>byte</code>(1B)、<code>short</code>(2B)、<code>int</code>(4B)、<code>long</code>(8B)、<code>float</code>(4B)、<code>double</code>(8B)、<code>char</code>(2B, UTF-16 code unit)、<code>boolean</code>（大小未在 JVM 规范中强制规定，通常用 1 bit&#x2F;1 byte 存储）。</li><li><strong>存放位置</strong>：<ul><li>方法里的局部变量 → <strong>JVM 栈帧的局部变量表</strong>（直接存值）。</li><li>如果是对象的字段 → 存在 <strong>堆内存的对象布局中</strong>（对象头 + 实例字段 + 对齐填充）。</li></ul></li><li><strong>优点</strong>：<ul><li>直接值语义，没有引用开销。</li><li>不参与 GC，性能高。</li><li>内存占用小。</li></ul></li><li><strong>缺点</strong>：<ul><li>不能为 <code>null</code>。</li><li>不具备面向对象特性（没有方法）。</li></ul></li></ul><hr><h4 id="2-引用类型（Reference-Types）"><a href="#2-引用类型（Reference-Types）" class="headerlink" title="2. 引用类型（Reference Types）"></a>2. 引用类型（Reference Types）</h4><ul><li><strong>类型</strong>：类、接口、数组、枚举、注解。</li><li><strong>存放方式</strong>：<ul><li><strong>引用变量</strong> 存在栈或对象字段中，存储的是对象在堆上的地址（引用）。</li><li><strong>对象本体</strong> 存在堆中（对象头 + 实例数据 + 对齐）。</li></ul></li><li><strong>特点</strong>：<ul><li>可以为 <code>null</code>。</li><li>传递时是 <strong>值传递</strong>，但值是引用的拷贝（可能导致“看起来像引用传递”）。</li><li>需要 GC 管理生命周期。</li></ul></li></ul><hr><h4 id="3-内存结构对比"><a href="#3-内存结构对比" class="headerlink" title="3. 内存结构对比"></a>3. 内存结构对比</h4><ul><li><strong>基本类型字段</strong>：直接存值，结构紧凑。</li><li><strong>包装类型（如 <code>Integer</code>）</strong>：对象有对象头（MarkWord + Klass 指针）+ 实例数据（int 值）+ 对齐填充。内存占用比基本类型大得多（通常至少 16B+）。</li><li><strong>布尔类型</strong>：虽然语义是 true&#x2F;false，但在对象中至少占 1B（HotSpot 会优化压缩到 bitset，但不保证）。</li></ul><h4 id="Q1-为什么-Java-有基本类型而不是全部用对象？"><a href="#Q1-为什么-Java-有基本类型而不是全部用对象？" class="headerlink" title="Q1. 为什么 Java 有基本类型而不是全部用对象？"></a>Q1. 为什么 Java 有基本类型而不是全部用对象？</h4><p>👉 <strong>回答要点</strong>：</p><ul><li>性能考虑。</li><li>基本类型避免了对象包装的额外开销（对象头、GC、指针寻址）。</li><li>在高频计算（循环、数值运算）中，大量创建对象会显著拖慢性能。</li></ul><hr><h4 id="Q2-基本类型和包装类型的区别？"><a href="#Q2-基本类型和包装类型的区别？" class="headerlink" title="Q2. 基本类型和包装类型的区别？"></a>Q2. 基本类型和包装类型的区别？</h4><p>👉 <strong>回答要点</strong>：</p><ul><li>基本类型直接存值，包装类型是对象（有引用开销）。</li><li>包装类型可以为 <code>null</code>，而基本类型不行。</li><li>包装类型支持方法（如 <code>Integer.valueOf</code>、<code>compareTo</code>）。</li><li>自动装箱&#x2F;拆箱可能引发性能问题。</li><li>比较时：<ul><li>基本类型用 <code>==</code> 比较值。</li><li>包装类型 <code>==</code> 比较引用（除非在 [-128,127] 缓存范围内的整型）。</li></ul></li></ul><hr><h4 id="Q3-为什么-Integer-i1-127-Integer-i2-127-i1-i2-返回-true，而换成-128-返回-false？"><a href="#Q3-为什么-Integer-i1-127-Integer-i2-127-i1-i2-返回-true，而换成-128-返回-false？" class="headerlink" title="Q3. 为什么 Integer i1 = 127; Integer i2 = 127; i1 == i2 返回 true，而换成 128 返回 false？"></a>Q3. 为什么 <code>Integer i1 = 127; Integer i2 = 127; i1 == i2</code> 返回 true，而换成 128 返回 false？</h4><p>👉 <strong>回答要点</strong>：</p><ul><li>因为 Java 对 <code>Integer</code> 做了缓存（<code>IntegerCache</code>，默认缓存 -128 ~ 127）。</li><li>超出范围会创建新的对象。</li></ul><hr><h4 id="Q4-对象在堆中的内存布局是怎样的？"><a href="#Q4-对象在堆中的内存布局是怎样的？" class="headerlink" title="Q4. 对象在堆中的内存布局是怎样的？"></a>Q4. 对象在堆中的内存布局是怎样的？</h4><p>👉 <strong>回答要点</strong>：</p><ol><li><strong>对象头</strong>：<ul><li>Mark Word（哈希码、锁信息、GC 信息）。</li><li>Klass Pointer（指向类元数据）。</li></ul></li><li><strong>实例数据</strong>：成员变量。</li><li><strong>对齐填充</strong>：保证 8 字节对齐。</li></ol><hr><h4 id="Q5-为什么建议用不可变对象（String-Integer-Long-等）作为共享数据？"><a href="#Q5-为什么建议用不可变对象（String-Integer-Long-等）作为共享数据？" class="headerlink" title="Q5. 为什么建议用不可变对象（String, Integer, Long 等）作为共享数据？"></a>Q5. 为什么建议用不可变对象（<code>String</code>, <code>Integer</code>, <code>Long</code> 等）作为共享数据？</h4><p>👉 <strong>回答要点</strong>：</p><ul><li>不可变 → 线程安全，不需要额外同步。</li><li>可作为 Map 的 key（不会被修改导致 hashCode 变化）。</li><li>方便缓存（如 String Pool）。</li></ul><hr><h4 id="Q6-什么时候用基本类型，什么时候用包装类型？"><a href="#Q6-什么时候用基本类型，什么时候用包装类型？" class="headerlink" title="Q6. 什么时候用基本类型，什么时候用包装类型？"></a>Q6. 什么时候用基本类型，什么时候用包装类型？</h4><p>👉 <strong>回答要点</strong>：</p><ul><li><strong>优先用基本类型</strong> → 性能敏感场景（循环计数器、数值计算）。</li><li><strong>必须用包装类型</strong> →<ul><li>需要使用泛型（<code>List&lt;Integer&gt;</code>）。</li><li>需要为 <code>null</code> 表示缺省值。</li><li>需要调用包装类的方法。</li></ul></li></ul><hr><h4 id="Q7-为什么-boolean-大小未定义？JVM-实际是怎么处理的？"><a href="#Q7-为什么-boolean-大小未定义？JVM-实际是怎么处理的？" class="headerlink" title="Q7. 为什么 boolean 大小未定义？JVM 实际是怎么处理的？"></a>Q7. 为什么 boolean 大小未定义？JVM 实际是怎么处理的？</h4><p>👉 <strong>回答要点</strong>：</p><ul><li>JVM 规范只定义了 boolean 的语义，没有强制大小。</li><li>实际实现：<ul><li>在数组中，boolean 常按 byte 存储。</li><li>在对象字段中，HotSpot 常把 boolean 当成 1B，但可能和其他字段合并压缩（bitfield）。</li></ul></li></ul><hr><h4 id="🔹-面试小结"><a href="#🔹-面试小结" class="headerlink" title="🔹 面试小结"></a>🔹 面试小结</h4><ul><li><strong>基本类型</strong> → 性能好，存值，不可为 null。</li><li><strong>引用类型</strong> → 面向对象特性，存引用，需 GC 管理。</li><li><strong>面试重点</strong>：装箱拆箱、缓存机制、对象内存布局、堆 vs 栈、不可变对象的好处。</li></ul><hr><h4 id="🔹-栈（Stack）"><a href="#🔹-栈（Stack）" class="headerlink" title="🔹 栈（Stack）"></a>🔹 栈（Stack）</h4><ul><li><strong>定义</strong>：线程私有，每个线程启动时会创建一个栈，生命周期和线程相同。</li><li><strong>存放内容</strong>：<ul><li><strong>局部变量</strong>（基本类型的值 &#x2F; 引用变量的引用值）。</li><li>方法调用信息（局部变量表、操作数栈、动态链接、返回地址）。</li></ul></li><li><strong>特点</strong>：<ul><li>内存小但访问快（栈帧出栈后，内存直接复用）。</li><li>线程隔离，不需要同步 → <strong>天然线程安全</strong>。</li><li>方法调用结束 → 栈帧自动销毁，无需 GC。</li></ul></li><li><strong>错误场景</strong>：<ul><li>递归过深或方法调用层次过多，会导致 <strong>StackOverflowError</strong>。</li></ul></li></ul><hr><h4 id="🔹-堆（Heap）"><a href="#🔹-堆（Heap）" class="headerlink" title="🔹 堆（Heap）"></a>🔹 堆（Heap）</h4><ul><li><strong>定义</strong>：Java 内存最大的一块，所有线程共享。</li><li><strong>存放内容</strong>：<ul><li><strong>对象实例</strong>（无论是成员变量还是数组）。</li><li>对象的实例数据（字段）。</li></ul></li><li><strong>特点</strong>：<ul><li>所有线程共享，需要 GC 来管理生命周期。</li><li>内存分配比栈复杂（对象需要内存分配、布局、回收）。</li><li>大小可配置（<code>-Xmx</code> &#x2F; <code>-Xms</code>）。</li></ul></li><li><strong>错误场景</strong>：<ul><li>堆不足时 → <strong>OutOfMemoryError: Java heap space</strong>。</li></ul></li></ul><hr><h4 id="🔹-对比总结"><a href="#🔹-对比总结" class="headerlink" title="🔹 对比总结"></a>🔹 对比总结</h4><table><thead><tr><th>对比点</th><th>栈</th><th>堆</th></tr></thead><tbody><tr><td><strong>管理</strong></td><td>方法调用自动分配&#x2F;销毁</td><td>JVM GC 管理</td></tr><tr><td><strong>存储内容</strong></td><td>基本类型的值、引用的地址</td><td>对象实例、成员变量</td></tr><tr><td><strong>线程安全</strong></td><td>线程私有，安全</td><td>线程共享，需同步</td></tr><tr><td><strong>生命周期</strong></td><td>方法结束自动销毁</td><td>对象被 GC 回收</td></tr><tr><td><strong>错误</strong></td><td><code>StackOverflowError</code></td><td><code>OutOfMemoryError</code></td></tr></tbody></table><hr><h4 id="🔹-常见面试追问"><a href="#🔹-常见面试追问" class="headerlink" title="🔹 常见面试追问"></a>🔹 常见面试追问</h4><h3 id="Q1-Java-中的变量存放在堆还是栈？"><a href="#Q1-Java-中的变量存放在堆还是栈？" class="headerlink" title="Q1. Java 中的变量存放在堆还是栈？"></a>Q1. Java 中的变量存放在堆还是栈？</h3><p>👉 <strong>回答要点</strong>：</p><ul><li>基本类型的局部变量 → 存在栈里。</li><li>引用变量（如 <code>Person p</code>） → 引用存在栈里，实际对象在堆里。</li><li>对象字段（即使是基本类型） → 随着对象存放在堆里。</li></ul><hr><h4 id="Q2-为什么栈比堆快？"><a href="#Q2-为什么栈比堆快？" class="headerlink" title="Q2. 为什么栈比堆快？"></a>Q2. 为什么栈比堆快？</h4><p>👉 <strong>回答要点</strong>：</p><ul><li>栈是顺序内存结构，分配&#x2F;释放只移动栈顶指针 → O(1)。</li><li>堆分配需要找合适的内存块，还要涉及 GC，成本高。</li></ul><hr><h4 id="Q3-栈里能存对象吗？"><a href="#Q3-栈里能存对象吗？" class="headerlink" title="Q3. 栈里能存对象吗？"></a>Q3. 栈里能存对象吗？</h4><p>👉 <strong>回答要点</strong>：</p><ul><li>严格来说，<strong>对象实例只能在堆中存</strong>。</li><li>栈里只能存对象引用（指向堆）。</li><li>但 JVM 的 JIT 优化可能会做<strong>逃逸分析</strong>，把未逃出方法的对象分配到栈上（Stack Allocation），甚至标量替换 → 提高性能。</li></ul><hr><h4 id="Q4-为什么要有堆和栈的区分？"><a href="#Q4-为什么要有堆和栈的区分？" class="headerlink" title="Q4. 为什么要有堆和栈的区分？"></a>Q4. 为什么要有堆和栈的区分？</h4><p>👉 <strong>回答要点</strong>：</p><ul><li>栈 → 方法调用和局部变量，高效且线程私有。</li><li>堆 → 对象共享，生命周期不固定，只能靠 GC。</li><li>各自职责清晰，才能兼顾性能和灵活性。</li></ul><hr><h4 id="Q5-GC-只回收堆吗？"><a href="#Q5-GC-只回收堆吗？" class="headerlink" title="Q5. GC 只回收堆吗？"></a>Q5. GC 只回收堆吗？</h4><p>👉 <strong>回答要点</strong>：</p><ul><li>对，GC 主要回收堆内存。</li><li>栈内存是随着方法出栈自动释放的，不需要 GC。</li></ul><hr><h4 id="🔹-面试快速答题版"><a href="#🔹-面试快速答题版" class="headerlink" title="🔹 面试快速答题版"></a>🔹 面试快速答题版</h4><ul><li><strong>栈</strong>：线程私有，存局部变量和方法调用信息，生命周期随方法，速度快但空间小，异常 <code>StackOverflowError</code>。</li><li><strong>堆</strong>：线程共享，存对象实例，由 GC 管理，灵活但慢，异常 <code>OutOfMemoryError</code>。</li></ul><hr><h3 id="2-抽象类-vs-接口"><a href="#2-抽象类-vs-接口" class="headerlink" title="2 抽象类 vs 接口"></a>2 抽象类 vs 接口</h3><ul><li><strong>抽象类（abstract class）</strong>：<ul><li>可以包含字段、构造器、具体方法和抽象方法。</li><li>适用于“is-a”关系且需要共享状态或实现细节的场景。</li><li>单继承：类只能继承一个抽象类。</li></ul></li><li><strong>接口（interface）</strong>：<ul><li>Java 8+ 支持 <code>default</code> 方法、<code>static</code> 方法；Java 9+ 支持私有方法。接口不能有实例字段（只允许 <code>public static final</code> 常量）。</li><li>支持多重实现（类可以实现多个接口），适合行为声明。</li></ul></li><li><strong>语义区别</strong>：抽象类关心“什么是”，接口关心“能做什么”。</li><li><strong>版本注意</strong>：由于 <code>default</code> 方法，接口现在可以携带实现，这使得“接口演进”更容易（兼容旧实现）。</li></ul><p><strong>面试要点</strong>：选择抽象类还是接口的理由；接口的多继承与菱形继承问题如何解决（Java 接口方法冲突规则）。</p><hr><h4 id="🔹-抽象类-vs-接口：如何选择？"><a href="#🔹-抽象类-vs-接口：如何选择？" class="headerlink" title="🔹 抽象类 vs 接口：如何选择？"></a>🔹 抽象类 vs 接口：如何选择？</h4><h5 id="1-抽象类的特点"><a href="#1-抽象类的特点" class="headerlink" title="1. 抽象类的特点"></a>1. 抽象类的特点</h5><ul><li>可以有 <strong>成员变量</strong>（实例变量、静态变量）、<strong>构造器</strong>（但不能直接实例化）。</li><li>可以有 <strong>方法实现</strong>（非抽象方法）。</li><li>可以提供 <strong>状态 + 行为</strong> 的部分实现。</li><li>类只能继承一个父类 → 抽象类适合<strong>类层次结构</strong>的扩展。</li></ul><p>👉 适用场景：</p><ul><li>表达 <strong>“is-a”</strong> 关系，且有 <strong>代码复用</strong>需求。</li><li>子类共享一些公共逻辑，但仍需要抽象定义。</li><li>比如 <code>AbstractList</code>、<code>HttpServlet</code>。</li></ul><hr><h5 id="2-接口的特点"><a href="#2-接口的特点" class="headerlink" title="2. 接口的特点"></a>2. 接口的特点</h5><ul><li>从 Java 8 开始，可以有 <strong>default 方法</strong> 和 <strong>static 方法</strong>（Java 9 引入 private 方法）。</li><li>不能有实例变量（只能有常量 <code>public static final</code>）。</li><li>用于定义 <strong>规范 &#x2F; 能力</strong>（行为约定），没有状态。</li><li>一个类可以实现多个接口 → 更灵活。</li></ul><p>👉 适用场景：</p><ul><li>表达 <strong>“can-do”</strong> 能力，不关心类的层次结构。</li><li>用于跨模块、跨层的解耦（如 <code>Serializable</code>、<code>Comparable</code>、<code>Runnable</code>）。</li><li>适合 <strong>API 设计</strong>，定义一组必须实现的功能。</li></ul><hr><h5 id="3-选择准则"><a href="#3-选择准则" class="headerlink" title="3. 选择准则"></a>3. 选择准则</h5><ul><li><strong>优先接口</strong>：如果只需定义行为，且希望解耦。</li><li><strong>抽象类</strong>：如果需要 <strong>共享状态</strong> 或 <strong>部分实现</strong>。</li><li><strong>接口 + default 方法</strong>：适合工具性扩展，不破坏已有实现。</li><li><strong>抽象类 + 模板方法模式</strong>：需要控制子类实现的调用顺序。</li></ul><hr><h4 id="🔹-接口的多继承-菱形继承问题"><a href="#🔹-接口的多继承-菱形继承问题" class="headerlink" title="🔹 接口的多继承 &amp; 菱形继承问题"></a>🔹 接口的多继承 &amp; 菱形继承问题</h4><h5 id="1-什么是菱形继承？"><a href="#1-什么是菱形继承？" class="headerlink" title="1. 什么是菱形继承？"></a>1. 什么是菱形继承？</h5><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;C&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">B</span>, C &#123;</span><br><span class="line">    <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>D</code> 同时继承了 <code>B</code> 和 <code>C</code>，它们都从 <code>A</code> 继承了 <code>hello</code>，并且覆盖了。<br> 问题：<code>D</code> 调用 <code>hello()</code> 时，调用哪个？</p><p>Java 编译规则：</p><ol><li><strong>类优先</strong> → 这里 <code>D</code> 自己没写，父类也没有，所以走不到。</li><li><strong>子接口更具体</strong> → 但 <code>B</code> 和 <code>C</code> 是并列接口，没有继承关系，无法判断谁更具体。</li><li><strong>必须显示覆盖</strong> → 由于有二义性，编译器直接报错，强制 <code>D</code> 必须自己实现 <code>hello()</code>。</li></ol><hr><h5 id="2-Java-的规则（接口方法冲突解决）"><a href="#2-Java-的规则（接口方法冲突解决）" class="headerlink" title="2. Java 的规则（接口方法冲突解决）"></a>2. Java 的规则（接口方法冲突解决）</h5><p>Java 避免了 C++ 的“菱形继承”困境，规则如下：</p><ol><li><strong>类优先原则</strong>：<ul><li>如果类和接口中有同名方法，优先使用类中的方法。</li><li>即 <strong>类 &gt; 接口 default 方法</strong>。</li></ul></li><li><strong>更具体接口优先原则</strong>：<ul><li>如果多个接口中有冲突的 default 方法，选择继承路径更“具体”的接口。</li><li>例：如果 <code>B extends A</code>，<code>C extends A</code>，类实现 <code>B, C</code> → 优先 <code>B</code> 或 <code>C</code> 的覆盖方法。</li></ul></li><li><strong>必须显式覆盖</strong>（冲突无法自动解决时）：<ul><li>如果继承了多个接口，且 default 方法签名冲突，必须在实现类里 <strong>显式 override</strong>。</li><li>可以用 <code>X.super.method()</code> 调用指定接口的默认实现。</li></ul></li></ol><hr><h5 id="3-例子：解决冲突"><a href="#3-例子：解决冲突" class="headerlink" title="3. 例子：解决冲突"></a>3. 例子：解决冲突</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">B</span>, C &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 必须显式解决</span></span><br><span class="line">        B.<span class="built_in">super</span>.hello(); <span class="comment">// 或 C.super.hello();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="🔹-面试快速答题版-1"><a href="#🔹-面试快速答题版-1" class="headerlink" title="🔹 面试快速答题版"></a>🔹 面试快速答题版</h4><ul><li><strong>抽象类 vs 接口</strong>：<ul><li>抽象类：有状态（字段）、有构造器、适合类层次结构，子类共享逻辑。</li><li>接口：定义行为规范，无状态，可多继承，解耦性更强。</li><li>一般 <strong>优先接口</strong>，当需要共享实现时用抽象类。</li></ul></li><li><strong>接口多继承的菱形问题</strong>：<ul><li>Java 通过 <strong>明确规则</strong>避免了 C++ 菱形继承的歧义：<ol><li>类优先于接口。</li><li>更具体的接口优先。</li><li>冲突时必须在实现类显式覆盖，并可用 <code>X.super.method()</code> 调用。</li></ol></li></ul></li></ul><hr><h3 id="3-final-关键字"><a href="#3-final-关键字" class="headerlink" title="3 final 关键字"></a>3 final 关键字</h3><ul><li><strong>final 类</strong>：不能被继承（确保行为不可扩展&#x2F;被覆盖）。</li><li><strong>final 方法</strong>：不能被重写（用于安全或性能提示）。</li><li><strong>final 变量</strong>：<ul><li>局部 final：必须在声明或构造器&#x2F;初始化块中初始化一次；在 lambda&#x2F;匿名内部类中要求变量为“effectively final”。</li><li>成员 final（字段）：在构造器中赋值后不可修改；对引用类型，final 限制的是引用不可改变，但对象状态仍可变。</li></ul></li><li><strong>JMM 中的 final 字段语义</strong>：final 字段有特殊的内存可见性保证：构造器中写入 final 字段并且对象正确发布后，其他线程能看到正确的 final 字段值（比普通字段更强）。但安全发布仍需注意（不要在构造器中把 <code>this</code> 逸出）。</li></ul><p><strong>面试点</strong>：final 与线程安全、final 与常量折叠（compile-time constant）、final 与继承&#x2F;多态影响。</p><p>很好 👌 你已经把 <strong><code>final</code> 的核心点</strong> 梳理得很完整了，我帮你再补充一些 <strong>细节 + 面试可能的追问点</strong>，这样遇到深挖问题也能答得很漂亮。</p><hr><h4 id="final-关键字总结"><a href="#final-关键字总结" class="headerlink" title="final 关键字总结"></a><strong>final 关键字总结</strong></h4><h5 id="1-final-类"><a href="#1-final-类" class="headerlink" title="1. final 类"></a>1. <code>final</code> 类</h5><ul><li><strong>含义</strong>：不能被继承（例如 <code>String</code>, <code>Integer</code>, <code>Math</code>）。</li><li><strong>设计原因</strong>：<ol><li>确保安全性（防止子类破坏不可变性，比如 <code>String</code>）。</li><li>JVM 优化（JIT 能更大胆做内联&#x2F;优化，因为知道不会被 override）。</li></ol></li><li><strong>面试追问</strong>：<ul><li>Q: 为什么 <code>String</code> 是 <code>final</code>？<ul><li>A: 保证不可变，避免哈希缓存、字符串池等被破坏，提升线程安全。</li></ul></li></ul></li></ul><hr><h5 id="2-final-方法"><a href="#2-final-方法" class="headerlink" title="2. final 方法"></a>2. <code>final</code> 方法</h5><ul><li><strong>含义</strong>：不能被重写（但可以被重载）。</li><li><strong>用途</strong>：<ul><li>确保某些方法的逻辑不会被子类篡改（模板方法模式常用）。</li><li>JVM 可做<strong>早期绑定</strong>（non-virtual call），提升性能。</li></ul></li><li><strong>面试追问</strong>：<ul><li>Q: <code>private</code> 方法能否是 <code>final</code>？<ul><li>A: 可以，但没有意义，因为 <code>private</code> 方法本来就不能被重写。</li></ul></li></ul></li></ul><hr><h5 id="3-final-变量"><a href="#3-final-变量" class="headerlink" title="3. final 变量"></a>3. <code>final</code> 变量</h5><h6 id="3-1-局部变量"><a href="#3-1-局部变量" class="headerlink" title="3.1 局部变量"></a>3.1 局部变量</h6><ul><li>必须初始化一次，之后不能改。</li><li><strong>lambda &amp; 匿名类</strong>：要求变量是 <strong>effectively final</strong>（未被重新赋值即可）。<ul><li>目的是保证闭包捕获的变量一致性。</li></ul></li></ul><h6 id="3-2-成员变量（字段）"><a href="#3-2-成员变量（字段）" class="headerlink" title="3.2 成员变量（字段）"></a>3.2 成员变量（字段）</h6><ul><li><p><code>final</code> 字段要么在声明时初始化，要么在构造函数&#x2F;初始化块中赋值。</p></li><li><p>对引用类型：引用本身不能修改，但对象内容可变（浅不可变）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;x&quot;</span>); <span class="comment">// ✅ 可行</span></span><br><span class="line">list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// ❌ 不行</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="3-3-常量折叠"><a href="#3-3-常量折叠" class="headerlink" title="3.3 常量折叠"></a>3.3 常量折叠</h6><ul><li><p><code>final static</code> 基本类型 + <code>String</code> 常量 → <strong>编译期常量</strong>，会在编译时内联。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">42</span>; </span><br><span class="line">System.out.println(A); <span class="comment">// 编译时就替换成 42</span></span><br></pre></td></tr></table></figure></li><li><p>面试追问：</p><ul><li>Q: 如果修改了常量定义，是否需要重新编译依赖的类？<ul><li>A: 需要，否则依赖类还用旧值（因为常量折叠到字节码里）。</li></ul></li></ul></li></ul><hr><h5 id="4-JMM-中的-final-语义"><a href="#4-JMM-中的-final-语义" class="headerlink" title="4. JMM 中的 final 语义"></a>4. JMM 中的 final 语义</h5><ul><li><strong>特殊内存语义</strong>：<ul><li>构造器中对 <code>final</code> 字段的写入，对其他线程是安全可见的（只要对象正确发布）。</li><li>与普通字段不同，普通字段可能出现“半初始化可见”。</li></ul></li><li><strong>注意点</strong>：<ul><li>不能在构造函数中把 <code>this</code> 逃逸（比如把自己注册到全局 map），否则 <code>final</code> 语义失效。</li></ul></li><li><strong>面试追问</strong>：<ul><li>Q: <code>final</code> 字段能完全保证不可变对象的线程安全性吗？<ul><li>A: 如果对象状态完全由 <code>final</code> 字段决定，并且没有泄漏 <code>this</code>，是安全的。</li></ul></li></ul></li></ul><hr><h4 id="✅-面试常见追问-答法"><a href="#✅-面试常见追问-答法" class="headerlink" title="✅ 面试常见追问 + 答法"></a>✅ 面试常见追问 + 答法</h4><ol><li><strong><code>final</code> 和 <code>finally</code>、<code>finalize</code> 的区别？</strong><ul><li><code>final</code>：修饰符</li><li><code>finally</code>：异常处理中的保证块</li><li><code>finalize()</code>：对象回收前调用的方法（已过时，不建议用）</li></ul></li><li><strong><code>final</code> 与不可变类的关系？</strong><ul><li><code>final</code> 字段是不可变类的基础；不可变类通常要求：类是 <code>final</code>，字段是 <code>final</code>，且没有 <code>setter</code>。</li></ul></li><li><strong>为什么 Java 要有 <code>final</code> 字段的内存模型特殊语义？</strong><ul><li>确保不可变对象真正安全（如 <code>String</code>、<code>Integer</code>），避免指令重排导致读到未初始化值。</li></ul></li></ol><hr><h3 id="4-static-关键字"><a href="#4-static-关键字" class="headerlink" title="4 static 关键字"></a>4 static 关键字</h3><ul><li><strong>static 变量</strong>（类变量）：类加载时初始化，所有实例共享。</li><li><strong>static 方法</strong>：与实例无关，不能直接访问非静态成员（因为没有 this）。静态方法在子类中被“隐藏”，不是多态（不能被 override，只能被子类定义同名静态方法，调用根据编译时类型）。</li><li><strong>static 块</strong>：类加载时执行（用于初始化复杂静态资源）。</li><li><strong>静态方法能否调用非静态成员？</strong> 不能直接调用。若需要，必须先获得某个实例并通过该实例访问非静态成员。</li><li><strong>static synchronized</strong>：锁的是 Class 对象（<code>MyClass.class</code>），而非实例。</li></ul><p><strong>面试点</strong>：类加载时机（静态初始化顺序）、类初始化与双亲委派、静态成员与内存泄漏（大量静态缓存）、静态方法隐藏 vs 实例方法重写。</p><hr><h4 id="static-关键字详解"><a href="#static-关键字详解" class="headerlink" title="static 关键字详解"></a><strong>static 关键字详解</strong></h4><h5 id="1-static-变量（类变量）"><a href="#1-static-变量（类变量）" class="headerlink" title="1. static 变量（类变量）"></a>1. static 变量（类变量）</h5><ul><li><strong>生命周期</strong>：类加载时分配，JVM 在方法区（JDK8 之后是 <strong>元空间</strong> + 堆里的静态区）为类变量分配内存。</li><li><strong>共享性</strong>：所有实例共享同一份内存。</li><li><strong>初始化顺序</strong>：<ul><li>静态变量 &amp; 静态块 → 按源码顺序依次执行。</li><li>在类初始化阶段完成。</li></ul></li><li><strong>面试追问</strong>：<ul><li>Q: 静态变量存放在哪里？<ul><li>JDK7 之前：方法区（永久代）。</li><li>JDK8 之后：方法区 → 元空间，引用存放在元空间，实际对象可能在堆上。</li></ul></li></ul></li></ul><hr><h5 id="2-static-方法"><a href="#2-static-方法" class="headerlink" title="2. static 方法"></a>2. static 方法</h5><ul><li><p><strong>特性</strong>：</p><ul><li>属于类本身（Class），不依赖对象。</li><li><strong>不能访问实例成员</strong>（没有 <code>this</code>）。</li><li>静态方法在子类中<strong>不会覆盖</strong>父类的静态方法，而是<strong>隐藏</strong>（Static Hiding）。</li></ul></li><li><p><strong>多态性区别</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A&quot;</span>); &#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B&quot;</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">a.hi(); <span class="comment">// 输出 A（静态绑定，取决于引用类型）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>面试追问</strong>：</p><ul><li>Q: 静态方法能否被重写？<ul><li>A: 不能，静态方法是类级别的，不走虚方法表，不具备运行时多态。</li></ul></li></ul></li></ul><hr><h5 id="3-static-代码块"><a href="#3-static-代码块" class="headerlink" title="3. static 代码块"></a>3. static 代码块</h5><ul><li><strong>执行时机</strong>：类初始化时（类加载 → 验证 → 准备 → 解析 → <strong>初始化</strong>）。</li><li><strong>顺序</strong>：<ul><li>父类静态代码块 → 子类静态代码块 → 父类构造块&#x2F;构造器 → 子类构造块&#x2F;构造器。</li></ul></li><li><strong>用途</strong>：<ul><li>初始化复杂静态变量（如 <code>Map</code>、<code>Set</code>）。</li><li>加载 native 库。</li></ul></li></ul><hr><h5 id="4-static-synchronized"><a href="#4-static-synchronized" class="headerlink" title="4. static synchronized"></a>4. static synchronized</h5><ul><li><strong>含义</strong>：锁住 <code>Class</code> 对象。</li><li><strong>区别</strong>：<ul><li><code>synchronized</code> 实例方法 → 锁住当前对象实例 (<code>this</code>)。</li><li><code>static synchronized</code> 方法 → 锁住当前类的 <code>Class</code> 对象。</li></ul></li><li><strong>面试追问</strong>：<ul><li>Q: 两个线程调用同一对象的实例方法（synchronized）和类方法（static synchronized），会互斥吗？<ul><li>A: 不会。因为前者锁的是实例对象，后者锁的是 <code>Class</code> 对象。</li></ul></li></ul></li></ul><hr><h4 id="⚡-常见面试陷阱"><a href="#⚡-常见面试陷阱" class="headerlink" title="⚡ 常见面试陷阱"></a>⚡ 常见面试陷阱</h4><h5 id="❌-1-静态成员与内存泄漏"><a href="#❌-1-静态成员与内存泄漏" class="headerlink" title="❌ 1. 静态成员与内存泄漏"></a>❌ 1. 静态成员与内存泄漏</h5><ul><li>若静态变量持有对象引用（尤其是集合、缓存），会导致对象无法被 GC 回收，造成 <strong>类加载器泄漏</strong>。</li><li>常见于 Web 容器（Tomcat）反复部署应用。</li></ul><h5 id="❌-2-静态方法调用实例方法"><a href="#❌-2-静态方法调用实例方法" class="headerlink" title="❌ 2. 静态方法调用实例方法"></a>❌ 2. 静态方法调用实例方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        g(); <span class="comment">// ❌ 编译错误，g() 是实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 必须通过实例来调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">t.g(); <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure><h5 id="❌-3-静态内部类与非静态内部类"><a href="#❌-3-静态内部类与非静态内部类" class="headerlink" title="❌ 3. 静态内部类与非静态内部类"></a>❌ 3. 静态内部类与非静态内部类</h5><ul><li><strong>静态内部类</strong>：不依赖外部类实例，可以直接创建 <code>new Outer.Inner()</code></li><li><strong>非静态内部类</strong>：需要外部类实例 <code>new Outer().new Inner()</code></li></ul><hr><h4 id="✅-高频面试追问"><a href="#✅-高频面试追问" class="headerlink" title="✅ 高频面试追问"></a>✅ 高频面试追问</h4><ol><li><strong>static 方法能否访问 this？</strong><ul><li>不能，因为静态方法属于类，没有 this 指针。</li></ul></li><li><strong>类什么时候被加载和初始化？</strong><ul><li>使用到静态变量&#x2F;静态方法时；</li><li>new 对象时；</li><li>反射调用时；</li><li>主类（包含 <code>main</code>）被启动时。</li></ul></li><li><strong>静态方法能否被重写？为什么？</strong><ul><li>不能。静态方法编译期绑定，属于类，不属于对象。子类的同名静态方法只是隐藏父类方法。</li></ul></li><li><strong>静态变量是否线程安全？</strong><ul><li>取决于是否被并发修改。<code>static</code> 本身只保证共享，不保证安全，仍需同步控制。</li></ul></li></ol><hr><hr><h3 id="5-String-StringBuffer-StringBuilder"><a href="#5-String-StringBuffer-StringBuilder" class="headerlink" title="5 String &#x2F; StringBuffer &#x2F; StringBuilder"></a>5 String &#x2F; StringBuffer &#x2F; StringBuilder</h3><ul><li><strong>String</strong>：<ul><li><strong>不可变</strong>（immutable）。任何修改都会产生新对象。好处：线程安全、可作为 Map&#x2F;Set 的 key、可安全缓存（字符串常量池 intern）。</li><li>Java 9 后内部表征从 <code>char[]</code> 变为 <code>byte[] + coder</code>（节省内存）。</li><li><code>String.intern()</code>：将字符串放到常量池，可能影响 permgen&#x2F;metaspace 使用。</li></ul></li><li><strong>StringBuffer</strong>：<ul><li>可变字符序列，<strong>线程安全</strong>（方法使用 <code>synchronized</code>）。适合多线程频繁修改单一实例的场景（但通常用得少）。</li></ul></li><li><strong>StringBuilder</strong>：<ul><li>可变字符序列，<strong>非线程安全</strong>，性能优于 <code>StringBuffer</code>（适合大多数单线程场景，如拼接循环中的字符串构造）。</li></ul></li><li><strong>容量增长</strong>：<ul><li><code>StringBuilder</code> 的扩容策略通常为 <code>newCapacity = (oldCapacity &lt;&lt; 1) + 2</code>（约 2x），不同 JDK 版本细节稍有差异。</li></ul></li><li><strong>性能建议</strong>：大量拼接用 <code>StringBuilder</code>；若作为 HashMap key，用不可变 <code>String</code>。</li></ul><p><strong>面试点</strong>：为什么 String 可作为 Map key（不可变性保证 hashCode 不变）、String 常量池与内存、拼接在循环里使用 + 的问题（导致大量临时 String）。</p><hr><h4 id="1-为什么-String-可以作为-Map-的-key？"><a href="#1-为什么-String-可以作为-Map-的-key？" class="headerlink" title="1. 为什么 String 可以作为 Map 的 key？"></a>1. <strong>为什么 <code>String</code> 可以作为 <code>Map</code> 的 key？</strong></h4><ul><li><code>HashMap</code> 的 key 依赖 <code>hashCode()</code> 和 <code>equals()</code>。</li><li>如果 key 可变，放入后修改会导致：<ul><li><strong>hashCode 改变</strong> → 无法找到原来的 bucket。</li><li><strong>equals 改变</strong> → 逻辑错误。</li></ul></li></ul><p>👉 <code>String</code> 是 <strong>不可变对象</strong>：</p><ul><li><code>hashCode</code> 在第一次计算后会缓存（lazy 计算，存在 <code>hash</code> 字段里）。</li><li>因为内容不变，hashCode 永远一致，保证放入 Map 后可以稳定检索。</li><li><code>equals</code> 比较基于内容，逻辑也稳定。</li></ul><p>💡 面试点延伸：</p><ul><li>为什么 <code>String</code>、<code>Integer</code>、<code>Long</code> 等不可变对象经常作为 <code>Map</code> key？<br> 👉 因为<strong>不可变性保证了哈希一致性</strong>。</li></ul><hr><h4 id="2-String-常量池与内存"><a href="#2-String-常量池与内存" class="headerlink" title="2. String 常量池与内存"></a>2. <strong>String 常量池与内存</strong></h4><ul><li><p><strong>字符串常量池（String Pool）</strong>：</p><ul><li>存放编译期确定的字面量和运行时调用 <code>intern()</code> 的字符串。</li><li>在 JDK 6 以前，常量池在 <strong>永久代 (PermGen)</strong>；JDK 7+ 移到 <strong>堆</strong>；JDK 8+ <strong>完全在堆中</strong>。</li></ul></li><li><p><strong>工作原理</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;         <span class="comment">// 放入常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;         <span class="comment">// 直接引用池中的同一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 在堆中创建新对象，不会自动放入池</span></span><br></pre></td></tr></table></figure></li><li><p><strong>intern() 方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>).intern();</span><br><span class="line">System.out.println(s1 == s4); <span class="comment">// true，引用池对象</span></span><br></pre></td></tr></table></figure></li></ul><p>👉 <strong>好处</strong>：</p><ul><li>节省内存（相同字面量只存一份）。</li><li>提高比较性能（字符串常量池对象可以直接用 <code>==</code> 判断）。</li></ul><hr><h4 id="3-循环中使用-拼接字符串的问题"><a href="#3-循环中使用-拼接字符串的问题" class="headerlink" title="3. 循环中使用 + 拼接字符串的问题"></a>3. <strong>循环中使用 <code>+</code> 拼接字符串的问题</strong></h4><ul><li><p><code>String</code> 是不可变的，每次拼接都会生成 <strong>新的对象</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    s = s + i; <span class="comment">// 每次拼接都 new 一个新的 String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>内部相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).append(i).toString();</span><br></pre></td></tr></table></figure></li><li><p>导致创建 <strong>大量临时对象</strong>，性能极差（O(n²)）。</p></li></ul></li><li><p><strong>正确写法</strong>：使用 <code>StringBuilder</code> 或 <code>StringBuffer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure></li></ul><p>💡 面试官可能会追问：</p><ul><li><strong>为什么 <code>&quot;a&quot; + &quot;b&quot; + &quot;c&quot;</code> 没问题？</strong><br> 👉 编译器优化，常量折叠成 <code>&quot;abc&quot;</code>，不会产生额外对象。</li><li><strong>为什么循环里不优化？</strong><br> 👉 循环次数不确定，编译器无法提前合并。</li></ul><hr><h4 id="4-面试高频追问"><a href="#4-面试高频追问" class="headerlink" title="4. 面试高频追问"></a>4. <strong>面试高频追问</strong></h4><ol><li><strong>为什么 <code>String</code> 设计成不可变？</strong><ul><li>安全性（避免泄露，例如 JDBC URL、ClassLoader 字符串）。</li><li>线程安全（不可变对象天然线程安全）。</li><li>常量池优化（相同字面量可复用）。</li><li>作为 HashMap key 的稳定性。</li></ul></li><li><strong>intern() 会造成内存泄漏吗？</strong><ul><li>JDK 6：常量池在永久代，<code>intern()</code> 多了可能 OOM。</li><li>JDK 7+：移到堆中，和 GC 一起回收，不会永久泄漏。</li></ul></li><li><strong>StringBuilder vs StringBuffer？</strong><ul><li><code>StringBuilder</code>：非线程安全，单线程高性能。</li><li><code>StringBuffer</code>：线程安全（方法有 <code>synchronized</code>），适合多线程环境。</li></ul></li></ol><hr><p>✅ <strong>简答版（面试 1 分钟答法）</strong>：</p><ul><li><code>String</code> 作为 Map key：不可变性保证 hashCode 和 equals 一致性。</li><li>常量池：字符串字面量和 intern() 存在池中，节省内存，提升性能。</li><li>循环拼接：<code>+</code> 会创建大量临时对象，应使用 <code>StringBuilder</code>。</li></ul><hr><h3 id="6-与-equals"><a href="#6-与-equals" class="headerlink" title="6 &#x3D;&#x3D; 与 equals()"></a>6 &#x3D;&#x3D; 与 equals()</h3><ul><li><strong>&#x3D;&#x3D;</strong>：<ul><li>基本类型：比较值。</li><li>引用类型：比较引用地址（是否同一对象）。</li></ul></li><li><strong>equals()</strong>：<ul><li><code>Object.equals()</code> 默认是 <code>==</code>（引用相等）。很多类（如 <code>String</code>、集合类、包装类）重写了 <code>equals()</code> 比较语义上的“等价性”。</li></ul></li><li><strong>常见陷阱</strong>：<ul><li><code>Integer a = 127; Integer b = 127; a == b // true</code>（因为 JVM 缓存 -128~127 范围的 Integer.valueOf）；<code>Integer x = 128; Integer y = 128; x == y // false</code>。</li><li><code>new String(&quot;x&quot;) == &quot;x&quot;</code> 为 <code>false</code>（不同对象），但 <code>new String(&quot;x&quot;).intern() == &quot;x&quot;</code> 为 <code>true</code>。</li></ul></li></ul><p><strong>面试点</strong>：何时用 equals（内容比较），何时用 &#x3D;&#x3D;（引用比较）；实现 equals 时遵守对称性、传递性、反射性、稳定性。</p><hr><h4 id="1-：比较引用-基本类型值"><a href="#1-：比较引用-基本类型值" class="headerlink" title="1. ==：比较引用&#x2F;基本类型值"></a>1. <strong><code>==</code>：比较引用&#x2F;基本类型值</strong></h4><h5 id="1-1-基本类型"><a href="#1-1-基本类型" class="headerlink" title="1.1 基本类型"></a>1.1 基本类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>, b = <span class="number">5</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true，比较值</span></span><br></pre></td></tr></table></figure><ul><li>对于 <strong>基本类型</strong>，<code>==</code> 比较的是 <strong>实际存储的值</strong>。</li></ul><h5 id="1-2-引用类型"><a href="#1-2-引用类型" class="headerlink" title="1.2 引用类型"></a>1.2 引用类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false，比较引用地址</span></span><br></pre></td></tr></table></figure><ul><li>对于 <strong>对象引用</strong>，<code>==</code> 比较的是 <strong>是否指向同一内存地址</strong>（即是否同一个对象）。</li><li>面试常考点：<ul><li>常量池里的字面量 <code>String s3 = &quot;abc&quot;; String s4 = &quot;abc&quot;;</code> → <code>s3 == s4</code> 为 <code>true</code>（引用相同）。</li><li><code>new String(&quot;abc&quot;)</code> 每次创建新对象 → 引用不同。</li></ul></li></ul><hr><h4 id="2-equals-：比较内容"><a href="#2-equals-：比较内容" class="headerlink" title="2. equals()：比较内容"></a>2. <strong><code>equals()</code>：比较内容</strong></h4><ul><li>定义在 <code>Object</code> 中：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span> == obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>但大多数类（如 <code>String</code>, <code>Integer</code>, <code>List</code>）都会重写 <code>equals()</code>，<strong>比较对象的逻辑内容</strong>而不是引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true，内容相同</span></span><br></pre></td></tr></table></figure><hr><h4 id="3-使用准则"><a href="#3-使用准则" class="headerlink" title="3. 使用准则"></a>3. <strong>使用准则</strong></h4><table><thead><tr><th>场景</th><th>使用方式</th><th>原因</th></tr></thead><tbody><tr><td>基本类型</td><td><code>==</code></td><td>比较值</td></tr><tr><td>对象引用是否同一对象</td><td><code>==</code></td><td>比较内存地址</td></tr><tr><td>对象内容是否相同</td><td><code>equals()</code></td><td>比较逻辑内容，需要类正确重写 equals()</td></tr><tr><td>容器&#x2F;Map key 比较</td><td><code>equals()</code></td><td>Map&#x2F;Set 查找时根据 equals() 决定逻辑相等</td></tr></tbody></table><hr><h4 id="4-常见面试陷阱"><a href="#4-常见面试陷阱" class="headerlink" title="4. 常见面试陷阱"></a>4. <strong>常见面试陷阱</strong></h4><ol><li><strong>String 比较</strong>：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol><li><strong>包装类比较</strong>（Integer、Long）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">127</span>, i2 = <span class="number">127</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// true，-128~127 缓存池</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>, i4 = <span class="number">128</span>;</span><br><span class="line">System.out.println(i3 == i4); <span class="comment">// false，超过缓存范围</span></span><br></pre></td></tr></table></figure><ol><li><strong>自定义类未重写 equals()</strong>：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; String name; &#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">System.out.println(p1.equals(p2)); <span class="comment">// false，Object 默认比较引用</span></span><br></pre></td></tr></table></figure><ul><li>面试点：自定义类使用内容比较需要 <strong>重写 equals()</strong>（同时重写 hashCode()）。</li></ul><hr><h4 id="5-面试快捷答法"><a href="#5-面试快捷答法" class="headerlink" title="5. 面试快捷答法"></a>5. <strong>面试快捷答法</strong></h4><ul><li><code>==</code>：<ul><li>基本类型 → 值比较</li><li>引用类型 → 地址比较（同一个对象吗）</li></ul></li><li><code>equals()</code>：<ul><li>内容比较（逻辑相等），前提类重写了 equals()</li></ul></li><li>容器&#x2F;Map 使用 <code>equals()</code> 判断元素或 key 是否相等</li></ul><hr><p>💡 <strong>延伸小技巧</strong>：</p><ul><li>写 <code>a.equals(b)</code> 前最好检查 <code>a != null</code>，或者用 <code>Objects.equals(a, b)</code> 防止 NullPointerException。</li></ul><hr><h3 id="7-hashCode-与-equals"><a href="#7-hashCode-与-equals" class="headerlink" title="7 hashCode() 与 equals()"></a>7 hashCode() 与 equals()</h3><ul><li><p><strong>合同</strong>：</p><ol><li>如果两个对象 <code>equals()</code> 返回 <code>true</code>，那么它们的 <code>hashCode()</code> 必须相等。</li><li>如果 <code>equals()</code> 返回 <code>false</code>，<code>hashCode()</code> 可以相等也可以不同（哈希冲突允许）。</li><li><code>hashCode()</code> 在一次应用运行中应该保持稳定（对象没有修改时）。</li></ol></li><li><p><strong>为什么必须重写 hashCode？</strong></p><ul><li>Hash 系数据结构（<code>HashMap</code>&#x2F;<code>HashSet</code>）使用 <code>hashCode()</code> 先定位桶，再用 <code>equals()</code> 检查具体相等性。若只重写 <code>equals()</code> 而不重写 <code>hashCode()</code>，两个逻辑相等对象可能具有不同哈希，导致放入 HashSet 后无法找到或产生重复键。</li></ul></li><li><p><strong>实现建议</strong>：用不可变字段计算 hash，常用 <code>Objects.hash(...)</code> 或 IDE 生成；避免使用容易改变的字段（会导致键失效）。</p></li><li><p><strong>示例坑</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123; ... &#125; <span class="comment">// 基于 name、age</span></span><br><span class="line">  <span class="comment">// 忘了重写 hashCode -&gt; 在 HashSet/HashMap 中会出现问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>面试点</strong>：Mutable key 的危害（例如使用可变字段做 HashMap key，然后修改字段），如何设计正确的 hashCode（均匀分布、避免碰撞）。</p><hr><h3 id="8-包装类的自动装箱-拆箱"><a href="#8-包装类的自动装箱-拆箱" class="headerlink" title="8 包装类的自动装箱&#x2F;拆箱"></a>8 包装类的自动装箱&#x2F;拆箱</h3><ul><li><strong>装箱（boxing）</strong>：基本类型 → 对应包装类（编译器插入 <code>Integer.valueOf(int)</code> 等）。</li><li><strong>拆箱（unboxing）</strong>：包装类 → 基本类型（编译器插入 <code>intValue()</code> 等）。</li><li><strong>缓存</strong>：<code>Integer.valueOf</code> 缓存 <code>-128 ~ 127</code>，<code>Boolean.valueOf</code> 缓存 <code>true/false</code>。<code>Long</code> 也缓存某些小值；其他包装类行为取决实现。</li><li><strong>风险</strong>：<ul><li><code>NullPointerException</code>：<code>Integer a = null; int b = a; // NPE</code>。</li><li>性能损失：频繁装拆箱会产生对象分配和 GC 压力。</li><li><code>==</code> 在装箱时比较的是引用（可能受缓存影响）。</li></ul></li><li><strong>编译例子</strong>：<code>Integer a = 10; int b = a + 5;</code> → 编译器生成 <code>int b = a.intValue() + 5;</code>。</li></ul><p><strong>面试点</strong>：注意 NPE、缓存范围、避免在性能敏感路径频繁装拆箱（比如大循环中），使用原始类型或专用库（Trove、fastutil）在高性能场景下替代。</p><hr><h3 id="9-重载（Overload）-vs-重写（Override）"><a href="#9-重载（Overload）-vs-重写（Override）" class="headerlink" title="9 重载（Overload） vs 重写（Override）"></a>9 重载（Overload） vs 重写（Override）</h3><ul><li><strong>重载（同一类或子类中）</strong>：<ul><li>同名方法，参数列表不同（参数数&#x2F;类型&#x2F;顺序），返回类型可不同（但仅返回类型不同不能构成重载）。</li><li>解析在<strong>编译时</strong>（静态绑定），基于编译时类型与参数类型选择。</li></ul></li><li><strong>重写（子类对父类方法）</strong>：<ul><li>方法签名完全一致（Java 8 后允许不同返回类型的协变返回），访问权限不可更严格，异常声明不能扔出新的更受检的异常。</li><li>调用是<strong>运行时绑定</strong>（多态）。</li></ul></li><li><strong>面试点</strong>：不能重写 static 方法（静态方法隐藏）；不能重写 final 方法；构造器不能重写只能重载；桥接方法（bridge methods）与泛型类型擦除下的兼容。</li></ul><hr><h3 id="10-Java-泛型"><a href="#10-Java-泛型" class="headerlink" title="10 Java 泛型"></a>10 Java 泛型</h3><ul><li><p><strong>目的</strong>：提供编译时类型检查和更安全的代码复用。</p></li><li><p><strong>实现机制</strong>：类型擦除（type erasure）——在编译时移除泛型信息，插入必要的类型转换和桥接方法以兼容旧字节码。</p></li><li><p><strong>限制</strong>：</p><ul><li>不能在运行时做 <code>instanceof</code> 某个具体泛型类型（只能 <code>instanceof List</code>）。</li><li>不能创建泛型数组（<code>new T[10]</code> 不允许）。</li><li>不能有泛型的静态成员直接使用类型参数（静态上下文没有类型参数信息）。</li><li>泛型异常（cannot create generic array of T）和不能抛出带泛型参数的受检异常。</li></ul></li><li><p><strong>通配符</strong>：</p><ul><li><code>&lt;? extends T&gt;</code>（生产者，只能读，PECS：Producer Extends）</li><li><code>&lt;? super T&gt;</code>（消费者，只能写，PECS：Consumer Super）</li></ul></li><li><p><strong>泛型方法与类型参数</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">pick</span><span class="params">(T a1, T a2)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>原生类型和擦除向后兼容</strong>：旧代码兼容，新代码编译会插入 casts。</p></li><li><p><strong>面试点</strong>：PECS、类型擦除造成的桥接方法、泛型与反射（通过 <code>Type</code>, <code>ParameterizedType</code> 获取泛型信息在运行时只能从声明处读取）。</p></li></ul><hr><h4 id="1️⃣-PECS-原则（Producer-Extends-Consumer-Super）"><a href="#1️⃣-PECS-原则（Producer-Extends-Consumer-Super）" class="headerlink" title="1️⃣ PECS 原则（Producer Extends, Consumer Super）"></a>1️⃣ <strong>PECS 原则（Producer Extends, Consumer Super）</strong></h4><p><strong>概念</strong>：</p><ul><li><p>针对泛型的<strong>上限、下限使用场景</strong>，由 Effective Java 提出。</p></li><li><p><strong>公式</strong>：</p><blockquote><p><code>? extends T</code> → 生产者（读取），不能写<br> <code>? super T</code> → 消费者（写入），可以写</p></blockquote></li><li><p>英文记忆：<strong>PECS &#x3D; Producer Extends, Consumer Super</strong></p></li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="type">Number</span> <span class="variable">n</span> <span class="operator">=</span> nums.get(<span class="number">0</span>); <span class="comment">// ✅ 可以读取</span></span><br><span class="line">nums.add(<span class="number">1</span>); <span class="comment">// ❌ 编译错误，类型未知</span></span><br><span class="line"></span><br><span class="line">List&lt;? <span class="built_in">super</span> Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">list.add(<span class="number">1</span>); <span class="comment">// ✅ 可以写</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// ✅ 只能当 Object 读</span></span><br></pre></td></tr></table></figure><h5 id="面试追问："><a href="#面试追问：" class="headerlink" title="面试追问："></a>面试追问：</h5><ul><li>为什么 <code>? extends</code> 不允许写入？<ul><li>因为具体类型可能是 <code>Integer</code>、<code>Double</code> 等，写入不安全。</li></ul></li><li>为什么 <code>? super</code> 可以写入？<ul><li>至少可以保证写入对象是其父类类型兼容。</li></ul></li></ul><hr><h4 id="2️⃣-类型擦除与桥接方法（Bridge-Method）"><a href="#2️⃣-类型擦除与桥接方法（Bridge-Method）" class="headerlink" title="2️⃣ 类型擦除与桥接方法（Bridge Method）"></a>2️⃣ <strong>类型擦除与桥接方法（Bridge Method）</strong></h4><h5 id="2-1-类型擦除"><a href="#2-1-类型擦除" class="headerlink" title="2.1 类型擦除"></a>2.1 <strong>类型擦除</strong></h5><ul><li>Java 泛型在编译期会被 <strong>类型擦除</strong> → 编译后字节码不保留泛型信息（JVM 层面不支持泛型）。</li><li><strong>例子</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译器保证类型安全 → 泛型约束只在<strong>编译期</strong>检查。</li></ul><hr><h5 id="2-2-桥接方法（Bridge-Method）"><a href="#2-2-桥接方法（Bridge-Method）" class="headerlink" title="2.2 桥接方法（Bridge Method）"></a>2.2 <strong>桥接方法（Bridge Method）</strong></h5><ul><li>当子类继承泛型父类或实现泛型接口时，类型擦除可能导致 <strong>方法签名不同</strong> → 编译器生成“桥接方法”保证多态。</li><li><strong>例子</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;child&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后，JVM 方法签名：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;child&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> get(); &#125; <span class="comment">// 桥接方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>桥接方法保证调用 <code>Parent</code> 的引用时多态正常。</li></ul><h5 id="面试追问：-1"><a href="#面试追问：-1" class="headerlink" title="面试追问："></a>面试追问：</h5><ul><li>Q: 为什么要生成桥接方法？<ul><li>A: 类型擦除后子类方法签名与父类不同，桥接方法保持编译期类型安全 + 运行时多态。</li></ul></li></ul><hr><h4 id="3️⃣-泛型与反射"><a href="#3️⃣-泛型与反射" class="headerlink" title="3️⃣ 泛型与反射"></a>3️⃣ <strong>泛型与反射</strong></h4><h5 id="3-1-普通反射获取泛型"><a href="#3-1-普通反射获取泛型" class="headerlink" title="3.1 普通反射获取泛型"></a>3.1 <strong>普通反射获取泛型</strong></h5><ul><li>泛型类型在运行时被擦除，只能获取 <strong>声明处信息</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    T value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Box.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">System.out.println(f.getType()); <span class="comment">// class java.lang.Object</span></span><br></pre></td></tr></table></figure><ul><li>只能看到 <code>Object</code>，实际 <code>T</code> 已被擦除。</li></ul><hr><h5 id="3-2-ParameterizedType-获取泛型信息"><a href="#3-2-ParameterizedType-获取泛型信息" class="headerlink" title="3.2 ParameterizedType 获取泛型信息"></a>3.2 <strong>ParameterizedType 获取泛型信息</strong></h5><ul><li>对方法、字段或类声明的泛型可以通过 <code>Type</code>&#x2F;<code>ParameterizedType</code> 获取：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringBox</span> <span class="keyword">extends</span> <span class="title class_">Box</span>&lt;String&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Type</span> <span class="variable">superType</span> <span class="operator">=</span> StringBox.class.getGenericSuperclass();</span><br><span class="line"><span class="keyword">if</span>(superType <span class="keyword">instanceof</span> ParameterizedType pt) &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">actualType</span> <span class="operator">=</span> pt.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    System.out.println(actualType); <span class="comment">// class java.lang.String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：只能获取<strong>继承&#x2F;声明处的泛型</strong>，运行时对象类型信息丢失：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;String&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line"><span class="type">Type</span> <span class="variable">t</span> <span class="operator">=</span> box.getClass().getGenericSuperclass(); <span class="comment">// 还是 Box&lt;T&gt;，T 无法知道</span></span><br></pre></td></tr></table></figure><h5 id="面试追问：-2"><a href="#面试追问：-2" class="headerlink" title="面试追问："></a>面试追问：</h5><ul><li>Q: 为什么 <code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在 JVM 层面是一样的？<ul><li>A: 泛型擦除，运行时都是 <code>List</code>，类型信息只在编译期存在。</li></ul></li></ul><hr><h4 id="4️⃣-面试答题模板"><a href="#4️⃣-面试答题模板" class="headerlink" title="4️⃣ 面试答题模板"></a>4️⃣ <strong>面试答题模板</strong></h4><ol><li><strong>PECS 原则</strong>：<ul><li><code>? extends T</code> → 生产者，读取安全，写入不安全</li><li><code>? super T</code> → 消费者，可写入，读取只能当 Object</li></ul></li><li><strong>类型擦除</strong>：<ul><li>泛型信息在编译期检查，运行期擦除成原始类型。</li><li>编译器通过<strong>桥接方法</strong>保持多态和类型安全</li></ul></li><li><strong>反射获取泛型</strong>：<ul><li>只能读取 <strong>声明处类型</strong></li><li><code>Type</code> &#x2F; <code>ParameterizedType</code> → 获取具体泛型类型</li><li>运行期对象泛型类型丢失</li></ul></li></ol><hr><p>💡 <strong>小技巧面试答法</strong>：</p><ul><li>提到桥接方法和类型擦除时，可以画一条箭头：<br> <code>Parent&lt;T&gt;</code> → <code>Child extends Parent&lt;String&gt;</code> → 编译器生成桥接方法 → JVM 方法签名多态保持一致</li></ul><hr><h3 id="11-反射"><a href="#11-反射" class="headerlink" title="11 反射"></a>11 反射</h3><ul><li><p><strong>作用</strong>：在运行时加载类、查看结构（字段&#x2F;方法&#x2F;构造器）、动态调用方法&#x2F;访问字段、创建对象。</p></li><li><p><strong>核心 API</strong>：<code>Class&lt;?&gt;</code>、<code>Field</code>、<code>Method</code>、<code>Constructor</code>、<code>Annotation</code>。</p></li><li><p><strong>常见用法</strong>：框架（Spring&#x2F;ORMs）、测试工具、序列化库、动态代理。</p></li><li><p><strong>性能与安全</strong>：</p><ul><li>反射调用速度比直接调用慢很多（因为涉及安全检查、解析），可以通过 <code>setAccessible(true)</code> 跳过访问检查来提高性能（但 Java 9 的模块化和安全策略会限制）。</li><li>替代方案：<code>MethodHandle</code> &#x2F; <code>invokeWithArguments</code>（更快），或者生成字节码（ASM）&#x2F;动态代理。</li></ul></li><li><p><strong>访问私有成员</strong>：<code>field.setAccessible(true)</code>（受 Java 模块化与安全管理器影响）。</p></li><li><p><strong>面试点</strong>：反射的用途与成本、如何用反射实现依赖注入、<code>Class.forName()</code> 与类加载器、类加载器三层结构与资源隔离。</p></li></ul><hr><h4 id="1️⃣-反射的用途"><a href="#1️⃣-反射的用途" class="headerlink" title="1️⃣ 反射的用途"></a>1️⃣ <strong>反射的用途</strong></h4><p>反射是 Java 动态获取类&#x2F;对象信息、动态调用方法的机制。常用用途：</p><ol><li><strong>动态创建对象</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.User&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure><ol><li><strong>动态获取&#x2F;修改属性</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">f.set(obj, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) f.get(obj);</span><br></pre></td></tr></table></figure><ol><li><strong>动态调用方法</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line">m.invoke(obj, <span class="string">&quot;Tom&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li><strong>实现依赖注入（DI）和 IoC</strong></li></ol><ul><li>框架在运行时扫描类，自动实例化对象、注入依赖（Spring、Guice 原理）。</li><li><strong>思路</strong>：<ol><li>扫描类路径，找到带注解的类。</li><li>通过 <code>Class.newInstance()</code> 或 <code>getDeclaredConstructor().newInstance()</code> 创建实例。</li><li>使用 <code>Field.set()</code> 注入依赖对象。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository repo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Spring 实现：<ul><li>利用 <code>ReflectionUtils</code> 设置私有字段可访问</li><li>注入 bean，实现松耦合</li></ul></li></ul><hr><h4 id="2️⃣-反射的成本"><a href="#2️⃣-反射的成本" class="headerlink" title="2️⃣ 反射的成本"></a>2️⃣ <strong>反射的成本</strong></h4><ol><li><strong>性能开销</strong><ul><li>方法调用绕过静态类型检查 → JVM 无法内联优化 → 相比普通方法慢 10~20 倍</li><li>访问私有成员需要 <code>setAccessible(true)</code> → 打破 JIT 优化</li></ul></li><li><strong>安全问题</strong><ul><li>可访问私有字段和方法 → 可能破坏封装</li><li>需要 <code>SecurityManager</code> 或模块系统权限限制</li></ul></li><li><strong>可维护性</strong><ul><li>编译期无法检查成员存在 → 容易出错</li><li>不利于重构</li></ul></li></ol><p><strong>总结</strong>：反射强大但开销大、可读性差，一般用于框架层、工具类或动态代理，不适合业务频繁调用。</p><hr><h4 id="3️⃣-Class-forName-与类加载器"><a href="#3️⃣-Class-forName-与类加载器" class="headerlink" title="3️⃣ Class.forName() 与类加载器"></a>3️⃣ <strong>Class.forName() 与类加载器</strong></h4><ol><li><p><strong><code>Class.forName(String className)</code></strong></p><ul><li><p><strong>作用</strong>：加载指定类，执行静态初始化块（类初始化阶段）</p></li><li><p>常用在 JDBC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;MyClass&gt; clazz = MyClass.class; <span class="comment">// 不触发初始化</span></span><br><span class="line">Class.forName(<span class="string">&quot;MyClass&quot;</span>); <span class="comment">// 会初始化类</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>类加载器</strong></p></li></ol><ul><li><strong>ClassLoader</strong>：负责加载 <code>.class</code> 字节码 → JVM 在内存生成 <code>Class</code> 对象</li><li><strong>核心方法</strong>：<ul><li><code>loadClass()</code> → 只加载，不初始化</li><li><code>defineClass()</code> → 将字节码转换成 Class 对象</li><li>初始化阶段触发静态块</li></ul></li></ul><hr><h4 id="4️⃣-类加载器三层结构与资源隔离"><a href="#4️⃣-类加载器三层结构与资源隔离" class="headerlink" title="4️⃣ 类加载器三层结构与资源隔离"></a>4️⃣ <strong>类加载器三层结构与资源隔离</strong></h4><p>Java 类加载器采用 <strong>父委托模型（Parent Delegation Model）</strong>，常见三层：</p><table><thead><tr><th>层级</th><th>典型实现</th><th>加载范围</th><th>面试要点</th></tr></thead><tbody><tr><td><strong>Bootstrap（启动类加载器）</strong></td><td>JVM 内置</td><td><code>java.*</code></td><td>加载核心类库，无法直接获取对象</td></tr><tr><td><strong>Extension（扩展类加载器 &#x2F; Platform）</strong></td><td><code>sun.misc.Launcher$ExtClassLoader</code></td><td><code>jre/lib/ext</code></td><td>加载扩展类库</td></tr><tr><td><strong>Application（系统类加载器 &#x2F; AppClassLoader）</strong></td><td>默认</td><td>classpath 下应用类</td><td>加载业务代码和第三方依赖</td></tr></tbody></table><ul><li><strong>父委托原则</strong>：<ul><li>子加载器先委托父加载器</li><li>避免类被重复加载，保证核心类安全性</li></ul></li><li><strong>资源隔离</strong>：<ul><li>不同类加载器加载同名类是不同 <code>Class</code> 对象（内存隔离）</li><li>典型应用：Web 容器（Tomcat）每个 webapp 一个类加载器 → 防止类冲突和资源泄漏</li></ul></li></ul><hr><h4 id="5️⃣-面试追问"><a href="#5️⃣-面试追问" class="headerlink" title="5️⃣ 面试追问"></a>5️⃣ <strong>面试追问</strong></h4><ol><li><strong>反射能调用 private 方法吗？</strong><ul><li>✅ 可以，使用 <code>setAccessible(true)</code>，破坏封装，但有安全风险。</li></ul></li><li><strong>为什么 Class.forName() 要抛 ClassNotFoundException？</strong><ul><li>因为指定的类可能不存在，加载失败时必须捕获异常。</li></ul></li><li><strong>为什么不同类加载器加载同名类是不同类型？</strong><ul><li>JVM 内存中 <code>Class</code> 对象由 <strong>类加载器 + 类全限定名</strong> 唯一确定 → 同名不同加载器，视为不同类。</li></ul></li><li><strong>反射创建对象和直接 new 的性能差异？</strong><ul><li>反射慢 10~20 倍，主要因为动态解析、绕过 JIT 优化。</li></ul></li></ol><hr><p>✅ <strong>快速答题模板（面试版）</strong>：</p><ul><li><strong>反射用途</strong>：动态创建对象、获取&#x2F;修改属性、调用方法 → 框架 DI&#x2F;IoC 核心</li><li><strong>反射成本</strong>：性能慢、破坏封装、安全风险、可维护性低</li><li><strong>依赖注入</strong>：扫描类 + newInstance() + Field.set()</li><li><strong>Class.forName()</strong>：加载类并初始化</li><li><strong>类加载器三层</strong>：<ul><li>Bootstrap → 核心类</li><li>Extension → 扩展类</li><li>App → 应用类</li></ul></li><li><strong>父委托 + 资源隔离</strong>：<ul><li>避免类重复加载，Web 容器隔离每个应用，防止冲突</li></ul></li></ul><hr><h4 id="1️⃣-双亲委派（Parent-Delegation-Model）"><a href="#1️⃣-双亲委派（Parent-Delegation-Model）" class="headerlink" title="1️⃣ 双亲委派（Parent Delegation Model）"></a>1️⃣ 双亲委派（Parent Delegation Model）</h4><p><strong>核心思想</strong>：</p><ul><li><strong>类加载请求先交给父类加载器</strong>，父加载器无法加载时才由子加载器自己加载。</li><li>保证核心类由 <strong>Bootstrap ClassLoader</strong> 加载，避免重复加载或安全问题。</li></ul><h5 id="加载流程："><a href="#加载流程：" class="headerlink" title="加载流程："></a>加载流程：</h5><ol><li>子加载器收到加载请求（比如 AppClassLoader）</li><li>委托给父加载器（ExtClassLoader）</li><li>父加载器继续委托给更上层（Bootstrap）</li><li>Bootstrap 能加载 → 返回 Class 对象</li><li>父加载器无法加载 → 子加载器自己加载</li></ol><p><strong>特点</strong>：</p><ul><li>防止核心类被篡改（例如 <code>java.lang.String</code> 永远由 Bootstrap 加载）</li><li>保证每个类在 JVM 中唯一（Class+ClassLoader 唯一标识）</li></ul><hr><h3 id="12-线程安全的集合与使用"><a href="#12-线程安全的集合与使用" class="headerlink" title="12 线程安全的集合与使用"></a>12 线程安全的集合与使用</h3><ul><li><strong>同步封装</strong>（JDK Collections 工厂）：<ul><li><code>Collections.synchronizedList/Map/Set(...)</code>：把单个操作同步化（方法级锁）。<strong>注意</strong>：复合操作（check-then-act）仍需外部同步。</li></ul></li><li><strong>并发集合（java.util.concurrent）</strong>：<ul><li><code>ConcurrentHashMap</code>：高并发哈希表（JDK8 以 CAS + synchronized on bin 为主）。<code>putIfAbsent</code>, <code>remove(key, val)</code>, <code>replace</code> 等原子操作。迭代弱一致（weakly consistent），不会抛 ConcurrentModificationException。</li><li><code>CopyOnWriteArrayList/CopyOnWriteArraySet</code>：写时复制，读多写少场景优秀（读无需锁，写创建新数组）。</li><li><code>BlockingQueue</code>（见第 22 题）用于生产者-消费者。</li><li><code>ConcurrentLinkedQueue</code>（无界非阻塞队列），基于 CAS 的链表。</li></ul></li><li><strong>如何使用</strong>：<ul><li><code>ConcurrentHashMap</code> 适合频繁并发读写：使用 <code>computeIfAbsent</code> 避免 check-then-put race。</li><li>对于复杂事务性操作，使用外部锁或事务机制；不要依赖单个集合的同步保证跨多个集合的一致性。</li></ul></li></ul><p><strong>面试点</strong>：为什么 <code>Collections.synchronizedMap</code> 不能完全替代 <code>ConcurrentHashMap</code>（并发粒度和性能差别）；CopyOnWrite 的开销与适用场景。</p><hr><h3 id="13-HashMap-底层原理与扩容机制"><a href="#13-HashMap-底层原理与扩容机制" class="headerlink" title="13 HashMap 底层原理与扩容机制"></a>13 HashMap 底层原理与扩容机制</h3><ul><li><strong>主要数据结构</strong>：数组（<code>Node&lt;K,V&gt;[] table</code>） + 单向链表（发生哈希冲突时） + 当单条链表长度超过阈值时转为红黑树（<code>TreeNode</code>）。</li><li><strong>重要常量</strong>（JDK8）：<ul><li><code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（16）</li><li><code>MAXIMUM_CAPACITY = 1 &lt;&lt; 30</code></li><li><code>TREEIFY_THRESHOLD = 8</code>（链表长度超过 8 时考虑树化）</li><li><code>UNTREEIFY_THRESHOLD = 6</code>（树退回链表阈值）</li><li><code>MIN_TREEIFY_CAPACITY = 64</code>（只有当 table 长度 &gt;&#x3D; 64 时才树化，否则先扩容）</li><li><code>DEFAULT_LOAD_FACTOR = 0.75f</code>（负载因子）</li></ul></li><li><strong>hash 计算</strong>：<ul><li><code>static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;</code></li><li>通过高位与低位混合（扰动）减小冲突（高位影响到低位）。</li></ul></li><li><strong>索引计算</strong>：<code>index = (n - 1) &amp; hash</code>（利用容量为2的幂使位运算快速定位）。</li><li><strong>put 操作流程</strong>：<ol><li>若 table 为 null，先初始化（默认容量 16）。</li><li>计算 hash、定位 bucket。</li><li>若 bucket 为空，直接插入（用 CAS 在并发场景未锁定时也能操作）。</li><li>若不为空，遍历链表或树：若发现 key 相等，覆盖 value；否则追加到链表尾或在树中插入。</li><li>若链表长度超过 TREEIFY_THRESHOLD 并且 table 长度 &gt;&#x3D; MIN_TREEIFY_CAPACITY，则树化；否则触发 resize。</li><li>每次插入后检查 <code>size &gt; threshold</code>（threshold &#x3D; capacity * loadFactor），超出则触发扩容。</li></ol></li><li><strong>扩容（resize）</strong>：<ul><li>扩容为 2 倍（<code>newCap = oldCap &lt;&lt; 1</code>），计算新阈值 <code>newThr = oldThr &lt;&lt; 1</code>。</li><li>JDK8 中 resize 会把旧链表拆分为两个链表（low 和 high），利用节点 hash 与 oldCap 的单个位判断新索引，避免完全重新计算哈希。</li><li>扩容成本高（rehash），会导致短暂性能抖动；并发扩容会带来线程安全问题（HashMap 在并发写时可能造成链表成环导致 CPU 100% 等问题，故 HashMap <strong>不是线程安全</strong> 的）。</li></ul></li><li><strong>get 操作复杂度</strong>：平均 O(1)，最坏在所有元素冲突为同一槽且未树化时 O(n)，JDK8 树化后降为 O(log n)。</li></ul><p><strong>面试点&#x2F;常考题</strong>：</p><ul><li><p>HashMap 的扩容触发条件与默认容量；为什么使用负载因子；为什么选择 0.75（时间&#x2F;空间折中）。</p></li><li><p>为何要树化，何时树化（避免 O(n) 退化）。</p></li><li><p>在并发写入下 HashMap 会出现什么问题（死循环&#x2F;链表环），以及解决方式（使用 ConcurrentHashMap 或外部同步）。</p></li><li><p>HashMap key 应该不可变，否则查找会出问题（例如 key 的 hashCode 依赖可变字段被修改后找不到）。</p><hr></li></ul><h4 id="1️⃣-HashMap-扩容与负载因子"><a href="#1️⃣-HashMap-扩容与负载因子" class="headerlink" title="1️⃣ HashMap 扩容与负载因子"></a>1️⃣ <strong>HashMap 扩容与负载因子</strong></h4><h5 id="1-1-扩容触发条件"><a href="#1-1-扩容触发条件" class="headerlink" title="1.1 扩容触发条件"></a>1.1 扩容触发条件</h5><ul><li><p><strong>默认初始容量</strong>：16（2 的幂）</p></li><li><p><strong>默认负载因子</strong>：0.75</p></li><li><p><strong>触发条件</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当 size &gt; capacity * loadFactor 时，触发扩容</span><br></pre></td></tr></table></figure><ul><li>size：当前元素个数</li><li>capacity：当前 table 长度</li></ul></li><li><p>扩容通常 <strong>容量翻倍</strong>（2 倍）</p></li></ul><h5 id="1-2-为什么使用负载因子？"><a href="#1-2-为什么使用负载因子？" class="headerlink" title="1.2 为什么使用负载因子？"></a>1.2 为什么使用负载因子？</h5><ul><li>控制 HashMap <strong>空间利用率与查找性能的折中</strong>。</li><li><strong>负载因子过小</strong>：<ul><li>table 空间浪费严重</li><li>扩容频繁 → 性能开销大</li></ul></li><li><strong>负载因子过大</strong>：<ul><li>链表长度增加 → 查找效率降低</li></ul></li><li><strong>0.75 的理由</strong>：<ul><li>Java 官方选择 0.75 作为折中点</li><li>平均查找 O(1)，空间利用率较高</li></ul></li></ul><hr><h4 id="2️⃣-为什么要树化（红黑树）"><a href="#2️⃣-为什么要树化（红黑树）" class="headerlink" title="2️⃣ 为什么要树化（红黑树）"></a>2️⃣ <strong>为什么要树化（红黑树）</strong></h4><h5 id="2-1-问题背景"><a href="#2-1-问题背景" class="headerlink" title="2.1 问题背景"></a>2.1 问题背景</h5><ul><li>JDK8 前 HashMap 使用链表存储哈希冲突</li><li>当哈希碰撞严重，链表长度达到 O(n)，查找退化成 O(n)</li></ul><h5 id="2-2-树化规则"><a href="#2-2-树化规则" class="headerlink" title="2.2 树化规则"></a>2.2 树化规则</h5><ul><li>当链表长度 &gt; <strong>TREEIFY_THRESHOLD &#x3D; 8</strong> 且数组长度 &gt;&#x3D; <strong>MIN_TREEIFY_CAPACITY &#x3D; 64</strong></li><li>链表会转为 <strong>红黑树</strong></li><li>查找、插入、删除 → O(log n)</li></ul><h5 id="2-3-面试追问"><a href="#2-3-面试追问" class="headerlink" title="2.3 面试追问"></a>2.3 面试追问</h5><ul><li>为什么加数组长度限制（MIN_TREEIFY_CAPACITY）？<ul><li>小数组直接扩容比树化更划算</li></ul></li><li>为什么红黑树而不是 AVL 树？<ul><li>红黑树插入删除调整成本低，适合哈希表冲突场景</li></ul></li></ul><hr><h4 id="3️⃣-HashMap-并发写入问题"><a href="#3️⃣-HashMap-并发写入问题" class="headerlink" title="3️⃣ HashMap 并发写入问题"></a>3️⃣ <strong>HashMap 并发写入问题</strong></h4><h5 id="3-1-并发问题表现"><a href="#3-1-并发问题表现" class="headerlink" title="3.1 并发问题表现"></a>3.1 并发问题表现</h5><ul><li>JDK8 前：<ul><li>多线程 put 时链表可能形成环 → <code>get()</code> 死循环</li></ul></li><li>JDK8+：<ul><li>仍不保证线程安全 → 写入可能丢失或覆盖</li></ul></li></ul><h5 id="3-2-解决方式"><a href="#3-2-解决方式" class="headerlink" title="3.2 解决方式"></a>3.2 解决方式</h5><ol><li><p><strong>使用 ConcurrentHashMap</strong> → 分段锁（JDK7）或 CAS + synchronized（JDK8+），线程安全</p></li><li><p><strong>外部同步</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;K,V&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br></pre></td></tr></table></figure></li><li><p><strong>禁止在多线程下直接操作 HashMap</strong></p></li></ol><hr><h4 id="4️⃣-HashMap-key-应该不可变"><a href="#4️⃣-HashMap-key-应该不可变" class="headerlink" title="4️⃣ HashMap key 应该不可变"></a>4️⃣ <strong>HashMap key 应该不可变</strong></h4><h5 id="4-1-原因"><a href="#4-1-原因" class="headerlink" title="4.1 原因"></a>4.1 原因</h5><ul><li><p>key 的 hashCode 和 equals 必须稳定</p></li><li><p>如果 key 可变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">map.put(p, <span class="string">&quot;data&quot;</span>);</span><br><span class="line">p.setName(<span class="string">&quot;Jerry&quot;</span>); <span class="comment">// hashCode 改变</span></span><br><span class="line">map.get(p); <span class="comment">// 返回 null，找不到原 key</span></span><br></pre></td></tr></table></figure></li><li><p>HashMap 查找依赖 <strong>hashCode → bucket → equals</strong></p></li></ul><h5 id="4-2-面试追问"><a href="#4-2-面试追问" class="headerlink" title="4.2 面试追问"></a>4.2 面试追问</h5><ul><li>可变 key 可以做什么防护？<ul><li>不允许修改关键字段</li><li>使用不可变类（String、Integer、UUID）</li><li>或重新 put&#x2F;update map</li></ul></li></ul><hr><h4 id="5️⃣-面试快速答题模板"><a href="#5️⃣-面试快速答题模板" class="headerlink" title="5️⃣ 面试快速答题模板"></a>5️⃣ <strong>面试快速答题模板</strong></h4><ol><li><strong>扩容</strong><ul><li>默认容量 16，负载因子 0.75 → 触发扩容</li><li>0.75 是时间&#x2F;空间折中</li></ul></li><li><strong>树化</strong><ul><li>链表长度 &gt; 8 且容量 &gt;&#x3D; 64 → 红黑树</li><li>提高查找性能，避免 O(n)</li></ul></li><li><strong>并发写入</strong><ul><li>多线程 HashMap 可能死循环&#x2F;数据丢失</li><li>解决：ConcurrentHashMap 或外部同步</li></ul></li><li><strong>key 不可变</strong><ul><li>hashCode&#x2F;equals 稳定 → 确保 put&#x2F;get 正确</li></ul></li></ol><hr><p>💡 <strong>补充底层知识点</strong></p><ul><li><p><strong>扩容时 rehash</strong>：每个元素都需要重新计算桶索引</p></li><li><p><strong>hash 再扰动</strong>：</p><ul><li><p>为了减少高位相同导致冲突，JDK8 对 hash 做扰动处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>链表转树条件</strong>：</p><ul><li>链表太长 → 树化</li><li>树节点太少 → 链表化（UNTREEIFY_THRESHOLD &#x3D; 6）</li></ul></li></ul><hr><h3 id="14-ConcurrentHashMap-的线程安全实现（深入，JDK7-vs-JDK8）"><a href="#14-ConcurrentHashMap-的线程安全实现（深入，JDK7-vs-JDK8）" class="headerlink" title="14 ConcurrentHashMap 的线程安全实现（深入，JDK7 vs JDK8）"></a>14 ConcurrentHashMap 的线程安全实现（深入，JDK7 vs JDK8）</h3><ul><li><strong>JDK7（老的实现）</strong>：<ul><li>基于分段锁（<code>Segment[] segments</code>），每个 Segment 维护一把锁，锁的粒度为 segment（可并行度 &#x3D; segment 数）；操作在单个 segment 内并发安全。</li></ul></li><li><strong>JDK8（重构后的实现）</strong>：<ul><li><strong>去掉 Segment</strong>，使用与 HashMap 类似的 <code>Node&lt;K,V&gt;[] table</code>。</li><li><strong>无全表锁</strong>：采用多种优化——CAS 创建节点&#x2F;置入、synchronized 仅在单个 bin 上（链表或 tree bin 上）用于插入&#x2F;修改，读取操作不加锁（volatile 可见）。</li><li><strong>关键概念</strong>：<ul><li><code>table</code> 是 volatile，节点 <code>next</code>、<code>value</code> 等字段使用 volatile&#x2F;CAS，以保证可见性和原子性。</li><li><code>put</code>：先 CAS 尝试把新 node 放到空桶；若失败或桶非空，采用 synchronized(binHead) 来完成插入（以避免竞争）。</li><li><code>putIfAbsent</code>、<code>computeIfAbsent</code> 等使用 CAS + 锁配合来保证原子性。</li><li><strong>树化</strong>：当单个 bucket 链表长度过大时，会转为树（与 HashMap 类似）。</li><li><strong>扩容</strong>：采用多线程协助搬迁（transfer），<code>sizeCtl</code> 字段控制迁移状态，多个线程可以参与一次扩容以提升效率。</li></ul></li><li><strong>读取</strong>：<code>get</code> 通常是无锁的，遍历链表或 tree bin，用 volatile 读取确保可见。</li></ul></li><li><strong>弱一致性迭代</strong>：迭代器不会抛出 <code>ConcurrentModificationException</code>，返回的是“弱一致”视图（可能看不到一些并发修改，也可能看到）。</li><li><strong>性能</strong>：JDK8 的实现综合使用 CAS 和局部锁，读性能非常好，写性能也较 JDK7 改进。</li></ul><p><strong>面试点</strong>：ConcurrentHashMap 为什么不需要全局锁，get 为什么不加锁安全，为什么 remove&#x2F;size 等操作不是常 O(1) 精确（需要并发统计）。</p><hr><h4 id="1️⃣-为什么-ConcurrentHashMap-不需要全局锁？"><a href="#1️⃣-为什么-ConcurrentHashMap-不需要全局锁？" class="headerlink" title="1️⃣ 为什么 ConcurrentHashMap 不需要全局锁？"></a>1️⃣ <strong>为什么 ConcurrentHashMap 不需要全局锁？</strong></h4><h5 id="1-1-JDK-7-vs-JDK-8"><a href="#1-1-JDK-7-vs-JDK-8" class="headerlink" title="1.1 JDK 7 vs JDK 8"></a>1.1 JDK 7 vs JDK 8</h5><table><thead><tr><th>版本</th><th>锁机制</th></tr></thead><tbody><tr><td>JDK 7</td><td>分段锁（Segment + ReentrantLock）</td></tr><tr><td>JDK 8+</td><td>Node + CAS + synchronized（链表&#x2F;红黑树节点）</td></tr></tbody></table><h5 id="1-2-核心思想"><a href="#1-2-核心思想" class="headerlink" title="1.2 核心思想"></a>1.2 核心思想</h5><ul><li><strong>细粒度锁</strong>，只锁某个桶（bucket）或链表节点，而不是整个表</li><li><strong>CAS（Compare-And-Swap）+ synchronized</strong>：大部分操作通过 CAS 保证原子更新，链表&#x2F;树节点操作用局部锁</li><li><strong>结果</strong>：并发写入多个桶时不会互相阻塞 → 高吞吐量</li></ul><hr><h4 id="2️⃣-为什么-get-不加锁也安全？"><a href="#2️⃣-为什么-get-不加锁也安全？" class="headerlink" title="2️⃣ 为什么 get 不加锁也安全？"></a>2️⃣ <strong>为什么 get 不加锁也安全？</strong></h4><h5 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h5><ul><li><strong>volatile + final 保证可见性</strong><ul><li>HashMap table、Node.value 都是 volatile 或 final → 线程读取总能看到最新对象</li></ul></li><li><strong>读取操作不修改结构</strong><ul><li><code>get()</code> 只是按 hash 找到 bucket，再遍历链表&#x2F;红黑树读取 value → 不改变链表结构</li></ul></li><li><strong>JMM 保证可见性</strong><ul><li>写入操作（put&#x2F;resize）保证 happens-before → get 读取安全</li></ul></li></ul><h5 id="2-2-面试要点"><a href="#2-2-面试要点" class="headerlink" title="2.2 面试要点"></a>2.2 面试要点</h5><ul><li>get 不加锁 → 高性能，线程安全</li><li>注意：<ul><li>遍历过程中，写入可能正在进行 → 可能 get 不到最新数据，但不会抛异常</li></ul></li></ul><hr><h4 id="3️⃣-remove-size-等操作为什么不是-O-1-精确？"><a href="#3️⃣-remove-size-等操作为什么不是-O-1-精确？" class="headerlink" title="3️⃣ remove&#x2F;size 等操作为什么不是 O(1) 精确？"></a>3️⃣ <strong>remove&#x2F;size 等操作为什么不是 O(1) 精确？</strong></h4><h5 id="3-1-remove"><a href="#3-1-remove" class="headerlink" title="3.1 remove"></a>3.1 remove</h5><ul><li>remove 需要找到对应桶，再修改链表&#x2F;树节点</li><li>对每个桶局部加锁，不同线程可能同时删除 → 最终结果仍正确</li><li>不是全局锁 → 并发 remove 与 put&#x2F;resize 会交错，复杂度取决于链表长度（O(n&#x2F;k)）</li></ul><h5 id="3-2-size"><a href="#3-2-size" class="headerlink" title="3.2 size()"></a>3.2 size()</h5><ul><li>ConcurrentHashMap <strong>不维护全局计数器</strong></li><li>各个桶独立统计 size → 获取精确值需要遍历所有桶并累加</li><li>在高并发情况下，size() 可能 <strong>瞬间不精确</strong><ul><li>避免频繁全局锁 → 提升性能</li></ul></li><li>如果需要精确 size，可以用 <code>mappingCount()</code> 或外部同步</li></ul><hr><h4 id="4️⃣-面试答题模板-1"><a href="#4️⃣-面试答题模板-1" class="headerlink" title="4️⃣ 面试答题模板"></a>4️⃣ <strong>面试答题模板</strong></h4><ol><li><strong>不需要全局锁</strong><ul><li>JDK8 使用 <strong>CAS + synchronized（局部桶锁）</strong></li><li>写操作只锁部分桶 → 高并发性能</li></ul></li><li><strong>get 不加锁安全</strong><ul><li>Node.value&#x2F;next 是 volatile&#x2F;final → 线程可见性</li><li>读取不修改结构 → 不会破坏链表&#x2F;树</li></ul></li><li><strong>remove&#x2F;size 非 O(1)</strong><ul><li>remove → 需要遍历桶 → 复杂度取决于链表长度</li><li>size → 各桶统计，不加全局锁 → 可能瞬间不精确</li></ul></li><li><strong>总结</strong><ul><li>高性能 → get 无锁</li><li>写入局部锁 → 避免全局阻塞</li><li>size&#x2F;remove 不保证严格 O(1) → 设计折中性能和精确性</li></ul></li></ol><hr><p>💡 <strong>补充知识点</strong></p><ul><li><strong>JDK8 table resize</strong>：使用 <code>ForwardingNode</code> + CAS，保证扩容期间并发安全</li><li><strong>红黑树&#x2F;链表转换</strong>：在并发环境下用 synchronized 保证线程安全</li><li><strong>volatile 语义</strong>：<ul><li>避免部分线程看到旧值</li><li>保证 Node 节点读写顺序</li></ul></li></ul><hr><h3 id="15-ArrayList-vs-LinkedList"><a href="#15-ArrayList-vs-LinkedList" class="headerlink" title="15 ArrayList vs LinkedList"></a>15 ArrayList vs LinkedList</h3><ul><li><strong>ArrayList</strong>：<ul><li>内部是动态数组（<code>Object[] elementData</code>）。</li><li>随机访问 <code>get(i)</code> 为 O(1)。</li><li>插入&#x2F;删除在尾部 amortized O(1)；在中间位置插入&#x2F;删除需要移动元素 O(n)。</li><li>扩容策略：默认初始为空数组（jdk8之后），第一次 add 会扩容到 10；后续扩容 <code>newCapacity = old + (old &gt;&gt; 1)</code>（约 1.5x）。</li><li>内存紧凑，良好缓存局部性（CPU cache 友好）。</li></ul></li><li><strong>LinkedList</strong>：<ul><li>基于双向链表（<code>Node</code> 包含 prev&#x2F;next&#x2F;item）。</li><li>随机访问 <code>get(i)</code> 为 O(n)（需要顺序遍历）。</li><li>在列表中间插入&#x2F;删除为 O(1)（仅修改邻接节点指针），前提是已定位到节点（定位本身 O(n)）。</li><li>内存占用高（每个节点多个指针对象），GC 压力更大。</li></ul></li><li><strong>选择准则</strong>：<ul><li>频繁随机访问 → <code>ArrayList</code>。</li><li>频繁在列表中间插入&#x2F;删除且遍历更多 → <code>LinkedList</code>（但在多数场景 <code>ArrayList</code> 仍优，因为插入删除远不如随机访问常见，而且复制成本在局部更低）。</li></ul></li></ul><p><strong>面试点</strong>：扩容开销、ensureCapacity、trimToSize、迭代时的 fail-fast（modCount）机制。</p><hr><h4 id="1️⃣-扩容开销"><a href="#1️⃣-扩容开销" class="headerlink" title="1️⃣ 扩容开销"></a>1️⃣ <strong>扩容开销</strong></h4><h5 id="1-1-扩容触发条件-1"><a href="#1-1-扩容触发条件-1" class="headerlink" title="1.1 扩容触发条件"></a>1.1 扩容触发条件</h5><ul><li><p>ArrayList 内部用 <code>Object[] elementData</code> 存储元素</p></li><li><p><strong>触发条件</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size &gt;= elementData.length</span><br></pre></td></tr></table></figure></li><li><p>默认容量：</p><ul><li><strong>初始容量</strong>：10（无参构造）</li><li>构造器可指定初始容量 <code>ArrayList(int initialCapacity)</code></li></ul></li></ul><h5 id="1-2-扩容机制"><a href="#1-2-扩容机制" class="headerlink" title="1.2 扩容机制"></a>1.2 扩容机制</h5><ul><li>扩容时通常 <strong>1.5 倍或 2 倍</strong>（JDK 8 ArrayList 为 1.5 倍）</li><li>扩容开销：<ol><li>新数组分配 → O(n)</li><li>旧数组元素复制 → O(n)</li></ol></li><li>面试追问：<ul><li>批量插入大量元素时最好指定初始容量 → 避免多次扩容</li></ul></li></ul><hr><h4 id="2️⃣-ensureCapacity-int-minCapacity"><a href="#2️⃣-ensureCapacity-int-minCapacity" class="headerlink" title="2️⃣ ensureCapacity(int minCapacity)"></a>2️⃣ <strong>ensureCapacity(int minCapacity)</strong></h4><h5 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h5><ul><li>手动确保 ArrayList 至少有 <code>minCapacity</code> 容量</li><li>提前分配数组 → 避免频繁扩容</li></ul><h5 id="2-2-使用示例"><a href="#2-2-使用示例" class="headerlink" title="2.2 使用示例"></a>2.2 使用示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.ensureCapacity(<span class="number">1000</span>); <span class="comment">// 提前分配空间</span></span><br></pre></td></tr></table></figure><h5 id="2-3-面试点"><a href="#2-3-面试点" class="headerlink" title="2.3 面试点"></a>2.3 面试点</h5><ul><li>用于性能优化</li><li>避免批量添加时不断触发扩容和数组复制</li></ul><hr><h4 id="3️⃣-trimToSize"><a href="#3️⃣-trimToSize" class="headerlink" title="3️⃣ trimToSize()"></a>3️⃣ <strong>trimToSize()</strong></h4><h5 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h5><ul><li>将 <code>elementData</code> 数组容量缩减到 <strong>当前 size</strong></li><li>节约内存空间，特别是 ArrayList 元素较少且容量大时</li></ul><h5 id="3-2-使用示例"><a href="#3-2-使用示例" class="headerlink" title="3.2 使用示例"></a>3.2 使用示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.trimToSize(); <span class="comment">// 数组长度缩减为 1</span></span><br></pre></td></tr></table></figure><h5 id="3-3-面试点"><a href="#3-3-面试点" class="headerlink" title="3.3 面试点"></a>3.3 面试点</h5><ul><li>用于 <strong>内存优化</strong></li><li>注意：之后再次 add 元素可能触发扩容 → 有性能开销</li></ul><hr><h4 id="4️⃣-迭代时的-fail-fast（modCount）机制"><a href="#4️⃣-迭代时的-fail-fast（modCount）机制" class="headerlink" title="4️⃣ 迭代时的 fail-fast（modCount）机制"></a>4️⃣ <strong>迭代时的 fail-fast（modCount）机制</strong></h4><h5 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h5><ul><li><p>ArrayList 内部维护 <code>modCount</code>：</p><ul><li>每次 <strong>结构性修改</strong>（add&#x2F;remove&#x2F;clear） → modCount++</li></ul></li><li><p>Iterator 获取 modCount 副本 <code>expectedModCount</code></p></li><li><p><strong>遍历时检查</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-2-触发场景"><a href="#4-2-触发场景" class="headerlink" title="4.2 触发场景"></a>4.2 触发场景</h5><ul><li>结构性修改 → <strong>抛 ConcurrentModificationException</strong></li><li><strong>非结构性修改</strong>（如 <code>set()</code> 替换元素）不会触发</li></ul><h5 id="4-3-面试点"><a href="#4-3-面试点" class="headerlink" title="4.3 面试点"></a>4.3 面试点</h5><ul><li><strong>目的</strong>：快速发现并发或不安全操作 → fail-fast</li><li><strong>注意</strong>：<ul><li>并发修改 ArrayList → Iterator 异常</li><li>并发安全 → 使用 <code>CopyOnWriteArrayList</code> 或手动同步</li></ul></li></ul><hr><h4 id="5️⃣-面试快速答题模板-1"><a href="#5️⃣-面试快速答题模板-1" class="headerlink" title="5️⃣ 面试快速答题模板"></a>5️⃣ <strong>面试快速答题模板</strong></h4><ol><li><strong>扩容开销</strong><ul><li>扩容触发条件：<code>size &gt;= capacity</code></li><li>扩容过程：新数组 + 元素复制 → O(n)</li><li>优化：指定初始容量</li></ul></li><li><strong>ensureCapacity</strong><ul><li>提前分配容量，避免频繁扩容</li></ul></li><li><strong>trimToSize</strong><ul><li>缩减数组长度到当前 size → 节约内存</li></ul></li><li><strong>fail-fast</strong><ul><li><code>modCount</code> 记录结构性修改</li><li>Iterator 检查 <code>expectedModCount</code></li><li>结构修改 → <code>ConcurrentModificationException</code></li></ul></li></ol><hr><p>💡 <strong>补充知识点</strong></p><ul><li>ArrayList 扩容策略是 <strong>时间&#x2F;空间折中</strong></li><li>迭代器 fail-fast 并非严格同步机制 → <strong>只是快速失败检测</strong></li><li>批量插入 + ensureCapacity → 性能最佳实践</li></ul><hr><h4 id="1️⃣-LinkedList-基本原理"><a href="#1️⃣-LinkedList-基本原理" class="headerlink" title="1️⃣ LinkedList 基本原理"></a>1️⃣ <strong>LinkedList 基本原理</strong></h4><ul><li><p><strong>底层结构</strong>：<strong>双向链表（Doubly Linked List）</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>存储特点</strong>：</p><ul><li>每个节点包含元素值 + 前驱 + 后继指针</li><li>内存分配按节点动态分配（Heap）</li><li>不需要预分配容量 → 没有扩容概念</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>增删快：O(1)（已定位节点时）</li><li>查找慢：O(n)（按索引遍历节点）</li><li>支持双向遍历：prev&#x2F;next</li></ul></li></ul><hr><h4 id="2️⃣-插入与删除"><a href="#2️⃣-插入与删除" class="headerlink" title="2️⃣ 插入与删除"></a>2️⃣ <strong>插入与删除</strong></h4><ul><li><strong>add &#x2F; addFirst &#x2F; addLast</strong><ul><li>创建新节点 → 更新前驱&#x2F;后继 → size++</li><li>已知节点可在 O(1) 完成插入</li></ul></li><li><strong>remove &#x2F; removeFirst &#x2F; removeLast</strong><ul><li>更新前驱&#x2F;后继指针 → GC 回收节点 → size–</li></ul></li><li><strong>按索引插入&#x2F;删除</strong><ul><li>需遍历节点 → O(n)</li></ul></li></ul><h5 id="面试点"><a href="#面试点" class="headerlink" title="面试点"></a>面试点</h5><ul><li>插入删除头尾快，随机访问慢</li><li>对比 ArrayList：随机访问慢，尾部插入快或慢取决于是否扩容</li></ul><hr><h4 id="3️⃣-迭代器与-fail-fast"><a href="#3️⃣-迭代器与-fail-fast" class="headerlink" title="3️⃣ 迭代器与 fail-fast"></a>3️⃣ <strong>迭代器与 fail-fast</strong></h4><ul><li><p><strong>modCount 机制</strong>与 ArrayList 类似</p><ul><li>LinkedList 每次结构修改（add&#x2F;remove&#x2F;clear） → <code>modCount++</code></li></ul></li><li><p><strong>迭代器</strong></p><ul><li><p>创建时记录 <code>expectedModCount = modCount</code></p></li><li><p>next()&#x2F;remove() 时检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (modCount != expectedModCount) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>特点</strong></p><ul><li>遍历链表时结构修改 → <strong>fail-fast</strong></li><li>非结构性修改（修改元素值 <code>set()</code>）不触发异常</li></ul></li></ul><hr><h4 id="4️⃣-LinkedList-特点总结"><a href="#4️⃣-LinkedList-特点总结" class="headerlink" title="4️⃣ LinkedList 特点总结"></a>4️⃣ <strong>LinkedList 特点总结</strong></h4><table><thead><tr><th>特性</th><th>LinkedList</th><th>ArrayList</th></tr></thead><tbody><tr><td>底层结构</td><td>双向链表</td><td>动态数组</td></tr><tr><td>随机访问</td><td>O(n)</td><td>O(1)</td></tr><tr><td>插入&#x2F;删除</td><td>O(1) 已知节点</td><td>O(n) 平均</td></tr><tr><td>内存分配</td><td>节点动态分配</td><td>整体数组扩容（复制元素）</td></tr><tr><td>迭代器</td><td>fail-fast</td><td>fail-fast</td></tr><tr><td>扩容</td><td>不需要</td><td>需要复制数组（O(n)）</td></tr><tr><td>内存开销</td><td>大，每个节点多 2 个指针</td><td>小，连续内存</td></tr></tbody></table><hr><h4 id="5️⃣-面试追问-1"><a href="#5️⃣-面试追问-1" class="headerlink" title="5️⃣ 面试追问"></a>5️⃣ <strong>面试追问</strong></h4><ol><li><strong>LinkedList 和 ArrayList 何时用哪个？</strong><ul><li>ArrayList：随机访问多，插入删除少</li><li>LinkedList：频繁插入&#x2F;删除头尾，随机访问少</li></ul></li><li><strong>为什么 LinkedList 没有扩容？</strong><ul><li>每个节点单独分配，链表不需要连续内存 → 不存在数组复制开销</li></ul></li><li><strong>fail-fast 能保证并发安全吗？</strong><ul><li>❌ 不能，只是快速失败检测</li><li>并发操作需外部同步或使用 <code>CopyOnWriteArrayList</code>&#x2F;<code>ConcurrentLinkedDeque</code></li></ul></li><li><strong>为什么 LinkedList 内存占用大？</strong><ul><li>每个节点额外保存两个引用（prev&#x2F;next）</li><li>对象头 + 数据 + 两个引用 → 比 ArrayList 每元素占用多</li></ul></li></ol><hr><h4 id="6️⃣-面试快速答题模板"><a href="#6️⃣-面试快速答题模板" class="headerlink" title="6️⃣ 面试快速答题模板"></a>6️⃣ <strong>面试快速答题模板</strong></h4><ul><li><strong>底层</strong>：双向链表 → 每节点：item&#x2F;prev&#x2F;next</li><li><strong>扩容</strong>：无，动态分配节点</li><li><strong>增删</strong>：头尾 O(1)，随机 O(n)</li><li><strong>迭代器</strong>：fail-fast，通过 modCount 检测结构修改</li><li><strong>适用场景</strong>：频繁插入&#x2F;删除，顺序遍历；随机访问少</li><li><strong>内存开销</strong>：比 ArrayList 高（节点指针多）</li></ul><hr><p>💡 <strong>补充知识点</strong></p><ul><li>Java 8 LinkedList 内部节点还是 <code>Node&lt;E&gt;</code> + 双向链表</li><li>支持 <strong>Deque 接口</strong> → 可以用作栈&#x2F;队列</li><li>fail-fast 和多线程并发同样不安全 → 外部同步或使用 <code>ConcurrentLinkedDeque</code></li></ul><hr><h3 id="16-基本类型-vs-包装类型"><a href="#16-基本类型-vs-包装类型" class="headerlink" title="16 基本类型 vs 包装类型"></a>16 基本类型 vs 包装类型</h3><ul><li><strong>基本类型</strong>：<ul><li>存放值，效率高，不能为 <code>null</code>。</li><li>不能用于泛型（必须使用包装类），不能放入集合（需要装箱）。</li></ul></li><li><strong>包装类型（如 Integer）</strong>：<ul><li>对象，存放在堆，有对象头，有引用开销，支持 <code>null</code>。</li><li>提供方法（parse、valueOf 等）。</li></ul></li><li><strong>性能差异</strong>：包装类型会产生额外对象分配与 GC，尽量在性能敏感场景使用基本类型数组（<code>int[]</code>）或原语流&#x2F;第三方库。</li></ul><hr><h3 id="17-Java-的-Object-类常用方法"><a href="#17-Java-的-Object-类常用方法" class="headerlink" title="17 Java 的 Object 类常用方法"></a>17 Java 的 <code>Object</code> 类常用方法</h3><ul><li><code>equals(Object obj)</code>：比较逻辑相等。</li><li><code>hashCode()</code>：哈希码。</li><li><code>toString()</code>：字符串表示。</li><li><code>getClass()</code>：返回运行时 Class 对象。</li><li><code>clone()</code>：浅拷贝（需实现 <code>Cloneable</code> 才有效，通常不推荐使用 clone）。</li><li><code>finalize()</code>：对象回收前调用（已弃用，不可靠，JDK9+ 标记为 deprecated）。</li><li><code>wait()/notify()/notifyAll()</code>：对象监视器（必须在 synchronized 块中调用），用于线程间通信。</li><li><code>registerNatives()</code> 等（本地方法）。</li></ul><p><strong>面试点</strong>：为什么不建议使用 finalize；如何正确使用 wait&#x2F;notify（必须在同步块中，防止虚假唤醒用 while 循环判断 condition）。</p><p>好的，<code>wait/notify</code> 是 Java 多线程协作的核心面试点，常被问“为什么必须在同步块中”、“虚假唤醒如何处理”，我帮你系统整理，并给出例子。</p><hr><h4 id="1️⃣-wait-notify-基本原理"><a href="#1️⃣-wait-notify-基本原理" class="headerlink" title="1️⃣ wait&#x2F;notify 基本原理"></a>1️⃣ <strong>wait&#x2F;notify 基本原理</strong></h4><ul><li><strong>wait()</strong><ul><li>让当前线程进入<strong>等待状态</strong>，释放持有的锁</li><li>等待其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒</li><li>必须在 <strong>同步块&#x2F;方法中</strong>调用，否则抛 <code>IllegalMonitorStateException</code></li></ul></li><li><strong>notify() &#x2F; notifyAll()</strong><ul><li>唤醒在当前对象 monitor 上等待的线程</li><li>notify：随机唤醒一个</li><li>notifyAll：唤醒所有线程</li></ul></li></ul><hr><h4 id="2️⃣-必须在同步块中的原因"><a href="#2️⃣-必须在同步块中的原因" class="headerlink" title="2️⃣ 必须在同步块中的原因"></a>2️⃣ <strong>必须在同步块中的原因</strong></h4><ul><li><p>每个对象有 <strong>对象监视器（monitor）</strong></p></li><li><p><code>wait/notify</code> 操作依赖持有 monitor</p></li><li><p>Java 语言规定：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">monitor.enter(); // synchronized</span><br><span class="line">wait()          // 释放 monitor，进入等待队列</span><br><span class="line">notify()        // 唤醒等待队列线程</span><br><span class="line">monitor.exit();</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="3️⃣-防止虚假唤醒"><a href="#3️⃣-防止虚假唤醒" class="headerlink" title="3️⃣ 防止虚假唤醒"></a>3️⃣ <strong>防止虚假唤醒</strong></h4><ul><li><p><strong>虚假唤醒</strong>：线程可能被唤醒，但条件不满足</p></li><li><p>因此 <strong>wait 必须放在 while 循环中检查条件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件满足，执行任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>不要用 if</strong>，因为虚假唤醒或多线程唤醒可能导致错误执行</p></li></ul><hr><p>4️⃣ <strong>wait&#x2F;notify 使用模板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (available) &#123;       <span class="comment">// 条件不满足就等待</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Producing...&quot;</span>);</span><br><span class="line">        available = <span class="literal">true</span>;</span><br><span class="line">        notifyAll();              <span class="comment">// 唤醒消费者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!available) &#123;      <span class="comment">// 条件不满足就等待</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consuming...&quot;</span>);</span><br><span class="line">        available = <span class="literal">false</span>;</span><br><span class="line">        notifyAll();              <span class="comment">// 唤醒生产者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>特点</strong>：<ol><li>条件检查放在 <code>while</code> 中 → 防虚假唤醒</li><li><code>wait/notifyAll</code> 都在 <strong>synchronized 方法或块</strong> 中</li><li><code>notifyAll</code> 通常比 <code>notify</code> 更安全，避免某些线程永远等待</li></ol></li></ul><hr><h4 id="5️⃣-示例：生产者-消费者"><a href="#5️⃣-示例：生产者-消费者" class="headerlink" title="5️⃣ 示例：生产者-消费者"></a>5️⃣ <strong>示例：生产者-消费者</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) r.produce();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) r.consume();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示意</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Producing...</span><br><span class="line">Consuming...</span><br><span class="line">Producing...</span><br><span class="line">Consuming...</span><br></pre></td></tr></table></figure><ul><li>生产者和消费者轮流执行</li><li><code>while</code> 循环保证虚假唤醒时线程不会错误执行</li><li>synchronized + wait&#x2F;notifyAll 保证线程安全</li></ul><hr><p>✅ <strong>面试要点总结</strong></p><ol><li><strong>必须在同步块中</strong> → 持有对象 monitor</li><li><strong>防止虚假唤醒</strong> → <code>while(condition)</code></li><li><strong>notify vs notifyAll</strong><ul><li>notify 唤醒一个线程，效率高，但可能导致线程饿死</li><li>notifyAll 唤醒所有线程，更安全</li></ul></li><li><strong>线程安全协作</strong><ul><li>wait 释放锁 → allow 其他线程执行</li><li>条件改变后 notifyAll 唤醒等待线程</li></ul></li></ol><hr><h3 id="18-深拷贝-浅拷贝-引用拷贝"><a href="#18-深拷贝-浅拷贝-引用拷贝" class="headerlink" title="18 深拷贝 &#x2F; 浅拷贝 &#x2F; 引用拷贝"></a>18 深拷贝 &#x2F; 浅拷贝 &#x2F; 引用拷贝</h3><ul><li><strong>引用拷贝</strong>：变量复制引用，两者指向同一对象（<code>a = b</code>）。</li><li><strong>浅拷贝</strong>：<ul><li>对象本身复制一份（字段为基本类型复制值），引用类型字段复制引用（不复制引用对象）。</li><li><code>Object.clone()</code> 默认实现就是浅拷贝（只复制字段）。</li></ul></li><li><strong>深拷贝</strong>：<ul><li>不仅复制对象本身，还递归复制所有引用对象（或复制所需的子对象），得到完全独立的对象树。</li><li>实现方式：手写递归复制、通过序列化（对象-&gt;字节-&gt;对象）或使用第三方库（如 Apache Commons Lang <code>SerializationUtils.clone()</code>）&#x2F;手动 copy constructor。</li></ul></li><li><strong>面试点</strong>：浅拷贝带来的共享可变子对象问题；clone 的陷阱（浅拷贝导致共享、需要实现 Cloneable 并覆盖 clone、异常处理）；如何实现可扩展的深拷贝（每个类提供 copy constructor 或工厂方法）。</li></ul><hr><h3 id="19-JDK-动态代理-CGLIB"><a href="#19-JDK-动态代理-CGLIB" class="headerlink" title="19 JDK 动态代理 &amp; CGLIB"></a>19 JDK 动态代理 &amp; CGLIB</h3><ul><li><p><strong>JDK 动态代理（java.lang.reflect.Proxy）</strong>：</p><ul><li><p>基于接口：只能为实现了接口的类创建代理。</p></li><li><p>通过 <code>InvocationHandler</code> 的 <code>invoke(Object proxy, Method method, Object[] args)</code> 拦截所有方法调用。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyInterface</span> <span class="variable">proxy</span> <span class="operator">=</span> (MyInterface) Proxy.newProxyInstance(</span><br><span class="line">  loader,</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;MyInterface.class&#125;,</span><br><span class="line">  (p, m, a) -&gt; &#123; <span class="comment">/* 横切逻辑 */</span> <span class="keyword">return</span> m.invoke(target, a); &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>CGLIB（字节码生成, org.springframework.cglib 或 net.sf.cglib）</strong>：</p><ul><li>基于生成目标类的子类（继承）并重写方法，适用于没有接口的类。</li><li>不能为 <code>final</code> 类或 <code>final</code> 方法创建代理（因为继承时无法覆盖 final 方法）。</li></ul></li><li><p><strong>Spring AOP</strong>：默认使用 JDK 动态代理（若目标实现接口），否则回退到 CGLIB（或可强制使用 CGLIB）。</p></li><li><p><strong>性能</strong>：JDK Proxy 在接口较多时开销较小，CGLIB 在没有接口的情况下是必须选项；现代实现都很快，但生成字节码开销存在（通常在代理创建时发生一次）。</p></li></ul><p><strong>面试点</strong>：自调用（同类方法内部调用）不会触发通过代理的拦截（因为代理是外部包装）；如何绕开（用 AopContext.currentProxy() 或把逻辑放到另一个 bean）。</p><hr><h3 id="20-序列化-反序列化"><a href="#20-序列化-反序列化" class="headerlink" title="20 序列化 &#x2F; 反序列化"></a>20 序列化 &#x2F; 反序列化</h3><ul><li><p><strong>序列化</strong>：将对象转成字节流（保存到文件&#x2F;传输网络）。</p></li><li><p><strong>反序列化</strong>：字节流还原为对象。</p></li><li><p><strong>Java 原生序列化</strong>：</p><ul><li>对象需实现 <code>Serializable</code>。可以定义 <code>private static final long serialVersionUID</code> 控制版本兼容。</li><li>可标 <code>transient</code> 字段为不序列化。</li><li>缺点：体积大、性能差、安全风险（直接反序列化恶意数据存在 RCE 风险），版本兼容复杂。</li></ul></li><li><p><strong>替代协议</strong>：Protobuf、Avro、Thrift、Kryo、Hessian、JSON 等（更紧凑&#x2F;跨语言&#x2F;更安全）。</p></li><li><p><strong>面试点</strong>：serialVersionUID 作用、如何实现自定义序列化（<code>writeObject</code>&#x2F;<code>readObject</code>）、安全问题与防御（不要直接反序列化不可信数据、使用白名单、安全库）。</p><hr></li></ul><h4 id="1️⃣-serialVersionUID-作用"><a href="#1️⃣-serialVersionUID-作用" class="headerlink" title="1️⃣ serialVersionUID 作用"></a>1️⃣ <strong>serialVersionUID 作用</strong></h4><ul><li><strong>定义</strong>：<code>private static final long serialVersionUID</code></li><li><strong>用途</strong>：序列化时标识类版本</li><li><strong>工作原理</strong>：<ol><li>序列化对象 → 在字节流中写入 <code>serialVersionUID</code></li><li>反序列化 → JVM 检查流中 <code>serialVersionUID</code> 与本地类是否匹配</li><li>不匹配 → 抛 <code>InvalidClassException</code></li></ol></li><li><strong>默认行为</strong>：<ul><li>如果没有显式声明，JVM 会根据类结构自动生成 UID</li><li>类结构变更 → UID 变更 → 反序列化失败</li></ul></li><li><strong>面试答题重点</strong>：<ul><li>显式声明 <code>serialVersionUID</code> → 保证类结构轻微变动后仍能兼容</li><li>推荐所有可序列化类都显式声明</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="2️⃣-自定义序列化"><a href="#2️⃣-自定义序列化" class="headerlink" title="2️⃣ 自定义序列化"></a>2️⃣ <strong>自定义序列化</strong></h4><ul><li>默认实现：<ul><li><code>ObjectOutputStream.writeObject()</code> → 按字段顺序写入</li><li><code>ObjectInputStream.readObject()</code> → 按字段顺序读取</li></ul></li><li><strong>自定义</strong>：通过实现 <code>writeObject</code> &#x2F; <code>readObject</code> 方法</li></ul><h5 id="2-1-示例"><a href="#2-1-示例" class="headerlink" title="2.1 示例"></a>2.1 示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age; <span class="comment">// transient 字段默认不序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.name = name; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream oos)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        oos.defaultWriteObject();   <span class="comment">// 写非 transient 字段</span></span><br><span class="line">        oos.writeInt(age);          <span class="comment">// 自定义写 transient 字段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ois.defaultReadObject();    <span class="comment">// 读非 transient 字段</span></span><br><span class="line">        <span class="built_in">this</span>.age = ois.readInt();   <span class="comment">// 自定义读 transient 字段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> name + <span class="string">&quot;, &quot;</span> + age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>特点</strong>：<ul><li><code>defaultWriteObject()</code> &#x2F; <code>defaultReadObject()</code> → 保留默认序列化</li><li>可自定义处理 transient 或敏感字段</li><li>可以做数据加密、压缩或版本兼容处理</li></ul></li></ul><hr><h4 id="3️⃣-安全问题"><a href="#3️⃣-安全问题" class="headerlink" title="3️⃣ 安全问题"></a>3️⃣ <strong>安全问题</strong></h4><h5 id="3-1-常见问题"><a href="#3-1-常见问题" class="headerlink" title="3.1 常见问题"></a>3.1 常见问题</h5><ol><li><strong>反序列化不可信数据</strong><ul><li>攻击者可以构造恶意对象 → 触发任意代码执行</li><li>典型 CVE：<code>CommonsCollections</code> 反序列化链攻击</li></ul></li><li><strong>对象注入</strong><ul><li>构造特殊 payload → 修改程序行为、执行任意方法</li></ul></li></ol><hr><h5 id="3-2-防御措施"><a href="#3-2-防御措施" class="headerlink" title="3.2 防御措施"></a>3.2 防御措施</h5><ol><li><p><strong>避免直接反序列化外部数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream());</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject(); <span class="comment">// 危险</span></span><br></pre></td></tr></table></figure><ul><li>尽量使用 <strong>安全库</strong> 或 <strong>数据转换格式</strong>（JSON、Protobuf）</li></ul></li><li><p><strong>白名单机制</strong></p><ul><li><p>JDK 9+ 提供 <code>ObjectInputFilter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputFilter</span> <span class="variable">filter</span> <span class="operator">=</span> ObjectInputFilter.Config.createFilter(<span class="string">&quot;java.base/*;!*&quot;</span>);</span><br><span class="line">ois.setObjectInputFilter(filter);</span><br></pre></td></tr></table></figure></li><li><p>只允许特定类反序列化，拒绝未知类</p></li></ul></li><li><p><strong>自定义 readObject() 验证数据</strong></p><ul><li>检查字段合法性、防止恶意 payload</li></ul></li><li><p><strong>序列化替代方案</strong></p><ul><li>JSON、Protobuf、Kryo（安全配置）</li></ul></li></ol><hr><h4 id="4️⃣-面试答题模板-2"><a href="#4️⃣-面试答题模板-2" class="headerlink" title="4️⃣ 面试答题模板"></a>4️⃣ <strong>面试答题模板</strong></h4><ol><li><strong>serialVersionUID</strong><ul><li>标识类版本</li><li>显式声明避免类结构改动破坏兼容</li></ul></li><li><strong>自定义序列化</strong><ul><li><code>writeObject</code> &#x2F; <code>readObject</code></li><li>处理 transient &#x2F; 加密 &#x2F; 压缩 &#x2F; 版本兼容</li></ul></li><li><strong>安全问题</strong><ul><li>不可信数据反序列化 → 可执行任意代码</li><li>防御：白名单、过滤器、自定义验证、使用安全库</li></ul></li><li><strong>最佳实践</strong><ul><li>所有 Serializable 类显式声明 UID</li><li>避免直接反序列化外部输入</li><li>对敏感数据用 transient + 自定义序列化处理</li></ul></li></ol><hr><p>💡 <strong>补充知识点</strong></p><ul><li><code>readResolve()</code> &#x2F; <code>writeReplace()</code> → 允许序列化替换对象</li><li>反序列化安全是高频面试点 → 尤其是 Java 企业安全岗</li></ul><hr><h3 id="21-常见序列化协议（优缺点）"><a href="#21-常见序列化协议（优缺点）" class="headerlink" title="21 常见序列化协议（优缺点）"></a>21 常见序列化协议（优缺点）</h3><ul><li><strong>Java 原生</strong>：易用但臃肿、慢、安全问题。</li><li><strong>JSON</strong>（Jackson &#x2F; Gson）：可读、跨语言、慢于二进制、无模式（schema）。</li><li><strong>Protobuf（Google）</strong>：二进制、高效、需要 schema、跨语言。</li><li><strong>Avro</strong>：支持 schema 演进，适合大数据。</li><li><strong>Thrift</strong>：类似 Protobuf，支持 RPC。</li><li><strong>Kryo</strong>：高性能 Java 专用序列化（用于低延迟场景）。</li><li><strong>Hessian</strong>：二进制 Web 服务序列化，跨语言。</li></ul><p><strong>面试点</strong>：如何基于场景（跨语言&#x2F;性能&#x2F;兼容性）选择序列化协议。</p><hr><h3 id="22-BlockingQueue"><a href="#22-BlockingQueue" class="headerlink" title="22 BlockingQueue"></a>22 BlockingQueue</h3><ul><li><strong>定义</strong>：<code>BlockingQueue</code> 支持在队列为空时阻塞消费者；在队列为满时阻塞生产者。常用于生产者-消费者模式，线程池的 work queue。</li><li><strong>方法</strong>：<ul><li>阻塞：<code>put(E)</code>（满时阻塞）、<code>take()</code>（空时阻塞）。</li><li>非阻塞：<code>offer(E)</code>、<code>poll()</code>（可返回 null 或布尔）。</li><li>带超时：<code>offer(E, timeout, unit)</code> &#x2F; <code>poll(timeout, unit)</code>。</li></ul></li><li><strong>常见实现</strong>：<ul><li><code>ArrayBlockingQueue</code>：基于数组、固定大小、可选择公平&#x2F;非公平锁（ReentrantLock）实现。</li><li><code>LinkedBlockingQueue</code>：基于链表，可选边界（默认 Integer.MAX_VALUE），读写使用不同锁，吞吐量高。</li><li><code>PriorityBlockingQueue</code>：基于优先队列，不保证 FIFO，非公平（无阻塞 put，因为无界）。</li><li><code>SynchronousQueue</code>：不保存元素，每个 put 必须等待一个 take（直接交付）。适合线程间直连交互（常用在 ForkJoinPool，或 ThreadPoolExecutor 饱和策略）。</li><li><code>DelayQueue</code>：元素带延迟，只有到期后才能被 take（常用于定时任务）。</li></ul></li><li><strong>使用建议</strong>：根据吞吐与公平性选择实现；<code>LinkedBlockingQueue</code> 适合高吞吐，<code>ArrayBlockingQueue</code> 提供固定容量和可控行为。</li></ul><hr><h3 id="23-PriorityQueue"><a href="#23-PriorityQueue" class="headerlink" title="23 PriorityQueue"></a>23 PriorityQueue</h3><ul><li><strong>实现</strong>：基于二叉堆（通常是数组形式的最小堆），在 JDK 中 <code>PriorityQueue</code> 是最小堆（最小元素优先）。</li><li><strong>复杂度</strong>：<ul><li><code>offer()</code> &#x2F; <code>poll()</code>：O(log n)（上下调整堆）。</li><li><code>peek()</code>：O(1)。</li><li><code>remove(Object)</code>：O(n)（删除任意元素需要线性查找并重新堆化）。</li></ul></li><li><strong>元素要求</strong>：要么实现 <code>Comparable</code>，要么在构造时传入 <code>Comparator</code>。不能保存 <code>null</code>。</li><li><strong>非线程安全</strong>：多线程需要外部同步或使用 <code>PriorityBlockingQueue</code>。</li><li><strong>用途</strong>：任务调度、A* 算法的 open set、定时任务优先级管理（结合 DelayQueue&#x2F;自定义时间比较器）。</li><li><strong>实现细节</strong>：内部使用 <code>siftUp</code> &#x2F; <code>siftDown</code> 操作维持堆性质。</li></ul><h3 id="24-设计原则"><a href="#24-设计原则" class="headerlink" title="24 设计原则"></a>24 设计原则</h3><p>面向对象的设计模式有七大基本原则：</p><ul><li>开闭原则（Open Closed Principle，OCP）</li><li>单一职责原则（Single Responsibility Principle, SRP）</li><li>里氏代换原则（Liskov Substitution Principle，LSP）</li><li>依赖倒转原则（Dependency Inversion Principle，DIP）</li><li>接口隔离原则（Interface Segregation Principle，ISP）</li><li>合成&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle，CARP）</li><li>最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of  Demeter，LOD）</li></ul><table><thead><tr><th align="left">标记</th><th align="left">设计模式原则名称</th><th align="left">简单定义</th></tr></thead><tbody><tr><td align="left">OCP</td><td align="left">开闭原则</td><td align="left">对扩展开放，对修改关闭</td></tr><tr><td align="left">SRP</td><td align="left">单一职责原则</td><td align="left">一个类只负责一个功能领域中的相应职责</td></tr><tr><td align="left">LSP</td><td align="left">里氏代换原则</td><td align="left">所有引用基类的地方必须能透明地使用其子类的对象</td></tr><tr><td align="left">DIP</td><td align="left">依赖倒转原则</td><td align="left">依赖于抽象，不能依赖于具体实现</td></tr><tr><td align="left">ISP</td><td align="left">接口隔离原则</td><td align="left">类之间的依赖关系应该建立在最小的接口上</td></tr><tr><td align="left">CARP</td><td align="left">合成&#x2F;聚合复用原则</td><td align="left">尽量使用合成&#x2F;聚合，而不是通过继承达到复用的目的</td></tr><tr><td align="left">LOD</td><td align="left">迪米特法则</td><td align="left">一个软件实体应当尽可能少的与其他实体发生相互作用</td></tr></tbody></table><p>其中，单一职责原则、开闭原则、迪米特法则、里氏代换原则和接口隔离原则就是我们平常熟知的<strong>SOLID</strong>。</p><h3 id="小结-典型面试追问准备"><a href="#小结-典型面试追问准备" class="headerlink" title="小结 + 典型面试追问准备"></a><strong>小结 + 典型面试追问准备</strong></h3><ul><li>HashMap、ConcurrentHashMap、ArrayList&#x2F;LinkedList、String 系列、equals&#x2F;hashCode、volatile&#x2F;final&#x2F;static 是高频点；务必能画数据结构示意图与关键代码路径（比如 put&#x2F;get 的流程图）。</li><li>练习写出 <code>equals</code> &#x2F; <code>hashCode</code> 的正确实现样例，能解释 HashMap 的扩容和树化阈值（16&#x2F;0.75&#x2F;8&#x2F;64）。</li><li>熟悉 <code>synchronized</code> vs <code>Lock</code> vs <code>volatile</code> 的语义与性能差异；理解 JMM 基础（happens-before，final 字段语义）。</li><li>对并发集合，能解释为什么 <code>ConcurrentHashMap.get()</code> 不加锁仍安全（volatile 可见与不变性保证）。</li></ul><h2 id="数据库基础-牛客面经八股"><a href="#数据库基础-牛客面经八股" class="headerlink" title="数据库基础-牛客面经八股"></a>数据库基础-牛客面经八股</h2><hr><h3 id="1-MySQL-的存储引擎有哪些？它们之间有什么区别？默认使用哪个？"><a href="#1-MySQL-的存储引擎有哪些？它们之间有什么区别？默认使用哪个？" class="headerlink" title="1. MySQL 的存储引擎有哪些？它们之间有什么区别？默认使用哪个？"></a><strong>1. MySQL 的存储引擎有哪些？它们之间有什么区别？默认使用哪个？</strong></h3><p>常见引擎（并非全部）：</p><ul><li><strong>InnoDB</strong>：事务性引擎，支持 ACID、行级锁、MVCC、外键、崩溃恢复（redo&#x2F;undo、doublewrite）、自带缓冲池（buffer pool）。适合 OLTP。<strong>默认引擎（MySQL 5.5+）</strong>。</li><li><strong>MyISAM</strong>：非事务、表级锁、较小 IO 延迟、全文索引（早期），恢复能力弱，不支持外键。适合只读或读多写少场景。</li><li><strong>MEMORY</strong>（HEAP）：把数据放内存，访问极快，但断电丢失，适合临时表或高速缓存。</li><li><strong>CSV</strong>：把每行存为 CSV 文件，便于导&#x2F;出，但功能非常有限。</li><li><strong>ARCHIVE</strong>：适合归档写入（高压缩、只追加、只支持 INSERT&#x2F;SELECT），不能索引（或索引能力弱）。</li><li><strong>NDB（MySQL Cluster）</strong>：分布式内存存储引擎，适用于高可用、分布式场景（复杂运维）。</li><li><strong>其他第三方&#x2F;变体</strong>：如 MyRocks（Facebook 的 RocksDB 后端，写放大与压缩优化）、TokuDB 等。</li></ul><p><strong>区别要点</strong>：</p><ul><li>事务支持（InnoDB 支持，MyISAM 不支持）。</li><li>锁粒度（InnoDB 行级锁，MyISAM 表级锁）。</li><li>崩溃恢复（InnoDB 有 redo&#x2F;undo&#x2F;doublewrite），MyISAM 依赖修复工具。</li><li>存储与索引实现细节（索引类型、压缩、聚簇索引等）。</li><li>性能定位：InnoDB 通常更平衡适合并发写；MyISAM 在单纯读场景可能略快。</li></ul><p><strong>默认引擎</strong>：现代 MySQL（5.5 之后）默认是 <strong>InnoDB</strong>。</p><hr><h3 id="2-MyISAM-与-InnoDB-的区别？如何选择？"><a href="#2-MyISAM-与-InnoDB-的区别？如何选择？" class="headerlink" title="2. MyISAM 与 InnoDB 的区别？如何选择？"></a><strong>2. MyISAM 与 InnoDB 的区别？如何选择？</strong></h3><p><strong>关键差别</strong>：</p><ul><li>事务：InnoDB 支持事务（ACID），MyISAM 不支持。</li><li>锁：InnoDB 行级锁（更高并发性）；MyISAM 表级锁（写操作会阻塞读写）。</li><li>崩溃恢复：InnoDB 支持 redo&#x2F;undo + doublewrite（较安全）；MyISAM 恢复能力差（需 myisamchk）。</li><li>外键：InnoDB 支持外键约束；MyISAM 不支持。</li><li>存储：InnoDB 有聚簇索引（主键与数据同 B+Tree），MyISAM 主数据与索引分离（非聚簇）。</li><li>全文搜索：历史上 MyISAM 支持全文索引；新 MySQL 版本 InnoDB 也支持全文索引。</li><li>IO &amp; 性能：MyISAM 在简单读场景可能低延迟；InnoDB 在高并发写&#x2F;读混合时更好。</li></ul><p><strong>如何选择</strong>：</p><ul><li>需要事务&#x2F;并发写&#x2F;外键&#x2F;崩溃安全 → <strong>InnoDB</strong>。</li><li>只读或极少写、对数据一致性要求低、老系统或特殊查询（极短）→ MyISAM 可考虑，但现在建议首选 InnoDB。</li><li>如果是高速缓存性质短期数据可考虑 MEMORY。</li><li>总体建议：生产 OLTP 系统用 InnoDB。</li></ul><hr><h3 id="3-InnoDB-是如何存储数据的？"><a href="#3-InnoDB-是如何存储数据的？" class="headerlink" title="3. InnoDB 是如何存储数据的？"></a><strong>3. InnoDB 是如何存储数据的？</strong></h3><p>核心概念（实现层）：</p><ul><li><strong>表空间（tablespace）</strong>：InnoDB 用 tablespace 存储数据页与索引页。可以是共享系统表空间 (<code>ibdata1</code>) 或 <code>innodb_file_per_table=ON</code>（每表单文件 .ibd）。</li><li><strong>页（page）</strong>：默认页大小 16KB（可配置）。页是读写的最小单位，页里包含多个记录（row）与链表&#x2F;目录。</li><li><strong>B+ 树索引</strong>：<ul><li><strong>聚簇索引（clustered index）</strong>：主键索引就是数据的物理组织（叶子节点存放完整行）。若无主键，InnoDB 会选择第一个非 NULL 唯一键或内部生成隐式列作为聚簇键。</li><li><strong>二级索引（secondary index）</strong>：非主键索引的叶子存放索引列 + <strong>主键值</strong>（作为指向聚簇索引的“指针”）；因此二级索引查到行后还需回聚簇索引读取完整行（称回表）。</li></ul></li><li><strong>事务日志</strong>：<ul><li><strong>Redo log（重做日志）</strong>：预写日志（WAL），用于崩溃恢复（ib_logfile*）。</li><li><strong>Undo log（回滚&#x2F;MVCC）</strong>：用于多版本并发控制（MVCC），支持一致性读（快照读），undo 存在系统表空间或独立 undo tablespace。</li><li><strong>Doublewrite buffer</strong>：写入磁盘前把页写入 doublewrite 区，防止半页写入导致损坏（提高崩溃安全）。</li></ul></li><li><strong>Buffer Pool</strong>：InnoDB 的核心缓存区，缓存数据页和索引页，读写都尽量在 buffer pool 完成以减 IO。</li><li><strong>MVCC（多版本并发）</strong>：<ul><li>通过在行上或 undo-log 中保存旧版本来实现一致性读（Read View）。读写隔离依赖 undo 来提供快照。</li><li>默认隔离级别 <code>REPEATABLE-READ</code>（MySQL 特性：使用间隙锁 + next-key lock 以避免幻读）。</li></ul></li><li><strong>插入缓冲&#x2F;变更缓冲（change buffer&#x2F;insert buffer）</strong>：延迟索引操作合并以提高插入吞吐（针对非聚簇索引）。</li><li><strong>行格式</strong>：REDUNDANT&#x2F;COMPACT&#x2F;DYNAMIC&#x2F;COMPRESSED；大字段（BLOB&#x2F;TEXT 或超长 VARCHAR）可 off-page（只在行内留 20 字节指针），减少行膨胀。</li></ul><hr><h3 id="4-MySQL-一行记录是怎么存储的？"><a href="#4-MySQL-一行记录是怎么存储的？" class="headerlink" title="4. MySQL 一行记录是怎么存储的？"></a><strong>4. MySQL 一行记录是怎么存储的？</strong></h3><p>以 <strong>InnoDB</strong> 为例（聚簇行存放在 B+ 树叶子页）：</p><ul><li><strong>页头 + 页目录（slot） + 记录区 + 空闲区 + 页尾&#x2F;校验</strong>。页头包含 LSN、Page number 等元信息；页尾可能有校验信息。</li><li><strong>记录格式</strong>（简化）：<ul><li>记录头（记录类型、链表指针、事务信息、记录长度）。</li><li><strong>NULL 位图</strong>（标记哪些列为 NULL）。</li><li><strong>记字段数据</strong>：固定长度列（定长）先写，变长列（VARCHAR、BLOB）写长度与内容；若内容很长，InnoDB 的 DYNAMIC&#x2F;COMPRESSED 行格式会把大字段存放到外部 overflow 页，行内只保留指针（通常 20 字节）。</li></ul></li><li><strong>二级索引条目</strong>：只包含索引列 + 主键（作为定位聚簇行的“引用”）。因此二级索引不会重复存储全部行内容，节省空间但会导致回表。</li></ul><p><strong>MyISAM</strong>：每行存在数据文件（.MYD），索引在 .MYI；没有聚簇索引，索引里存偏移量指向数据文件中的行。</p><hr><h3 id="5-详细描述一条-SQL-在-MySQL-中的执行过程"><a href="#5-详细描述一条-SQL-在-MySQL-中的执行过程" class="headerlink" title="5. 详细描述一条 SQL 在 MySQL 中的执行过程"></a><strong>5. 详细描述一条 SQL 在 MySQL 中的执行过程</strong></h3><p>高层步骤（客户端到存储引擎）：</p><ol><li><strong>客户端层</strong>：应用通过连接（Connector&#x2F;J 等）发送 SQL 到 MySQL Server（线程池&#x2F;one-thread-per-connection）。</li><li><strong>连接与认证</strong>：MySQL 验证账号&#x2F;权限（authentication plugin、grant tables）。</li><li><strong>解析（Parser）</strong>：SQL 被词法&#x2F;语法解析器转换为解析树（parse tree），检查语法正确性。</li><li><strong>预处理 &#x2F; 语义分析</strong>：解析树变成 parse tree 的语义检查，解析表名、列名是否存在，权限检查。</li><li><strong>重写&#x2F;视图&#x2F;子查询优化</strong>：展开视图、优化子查询（视具体版本，子查询可重写为 JOIN）、派生表（derived table）处理（有时会创建临时表）。</li><li><strong>查询优化器（Optimizer）</strong>：<ul><li>根据表统计信息、索引、条件，生成若干候选执行计划（访问路径、连接顺序、连接算法）。</li><li>使用代价模型（cost estimates）选择最优计划。会决定是否使用索引、哪种索引、join 顺序等。</li></ul></li><li><strong>执行引擎（Execution Engine）&#x2F;计划执行</strong>：<ul><li>根据执行计划逐步执行：遍历表、应用 WHERE、做 JOIN、聚合 GROUP BY、排序 ORDER BY、生成结果行。</li><li>在执行过程中与**存储引擎（Handler API）**交互做实际 IO（InnoDB、MyISAM）。</li></ul></li><li><strong>存储引擎层</strong>（如 InnoDB）：<ul><li>执行页读取、索引查找、事务隔离控制（锁、MVCC）、读写缓冲、写日志（redo）等底层操作。</li></ul></li><li><strong>返回结果</strong>：执行引擎把结果发送回客户端；若是写操作，会提交事务（若是自动提交或显式提交），redo log 刷盘（强制或延迟由配置决定）。</li><li><strong>统计&#x2F;缓存更新</strong>：query cache（若启用且有效，但在新版本中已弃用&#x2F;移除），慢查询记录等。</li></ol><p><strong>注意</strong>：实际过程包含很多优化（例如谓词下推、索引条件下推、block nested loop、batched key access、histograms 等），不同 MySQL 版本细节不同，但总体流程如上。</p><hr><h3 id="6-MySQL-的查询优化器如何选择执行计划？"><a href="#6-MySQL-的查询优化器如何选择执行计划？" class="headerlink" title="6. MySQL 的查询优化器如何选择执行计划？"></a><strong>6. MySQL 的查询优化器如何选择执行计划？</strong></h3><p>核心机制：</p><ul><li><strong>基于成本的优化器（CBO）</strong>：使用统计信息（表基数、索引基数、分布直方图等）估算每个访问路径（全表扫描、索引范围、索引唯一查找等）的代价（IO、CPU）。</li><li><strong>统计信息来源</strong>：通过 <code>ANALYZE TABLE</code> 更新，也会由执行过程中动态采样。MySQL 8 引入了更精细的直方图支持（更好估算非均匀分布列）。</li><li><strong>选择因素</strong>：<ul><li>索引可用性（是否存在合适索引、是否为覆盖索引）。</li><li>选择性（selectivity）——该索引能筛掉多少行。</li><li>表大小（行数）、列基数。</li><li>连接顺序、连接算法（Nested-Loop 为主；有时使用 Index Merge、Block Nested Loop、Hash Join 在某些版本&#x2F;场景可用）。</li><li>是否可以进行 <code>index-only</code>（覆盖索引）避免回表。</li><li>物化临时表 vs on-the-fly 的成本（派生表策略）。</li></ul></li><li><strong>搜索策略</strong>：MySQL 会根据 join 数量与成本在一定规则下枚举 join 顺序（对较多表会采用启发式或限制性搜索以避免指数爆炸）。</li><li><strong>优化器提示与开关</strong>：可以通过 <code>USE INDEX</code> &#x2F; <code>FORCE INDEX</code> &#x2F; <code>STRAIGHT_JOIN</code> &#x2F; <code>OPTIMIZER_SWITCH</code> 等影响计划选择。</li><li><strong>上手实践</strong>：使用 <code>EXPLAIN</code> &#x2F; <code>EXPLAIN ANALYZE</code>（MySQL 8）查看执行计划、识别 full table scan、filesort、temporary 的使用，并据此调整索引&#x2F;SQL 重写&#x2F;统计信息。</li></ul><hr><h3 id="7-SQL-中-SELECT、FROM、JOIN、WHERE、GROUP-BY、HAVING、ORDER-BY、LIMIT-的执行顺序？"><a href="#7-SQL-中-SELECT、FROM、JOIN、WHERE、GROUP-BY、HAVING、ORDER-BY、LIMIT-的执行顺序？" class="headerlink" title="7. SQL 中 SELECT、FROM、JOIN、WHERE、GROUP BY、HAVING、ORDER BY、LIMIT 的执行顺序？"></a><strong>7. SQL 中 <code>SELECT</code>、<code>FROM</code>、<code>JOIN</code>、<code>WHERE</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>ORDER BY</code>、<code>LIMIT</code> 的执行顺序？</strong></h3><p>逻辑&#x2F;标准的<strong>处理顺序（简化）</strong>：</p><ol><li><strong>FROM</strong>（包含 JOIN，并先应用 ON 条件用于连接裁剪&#x2F;过滤）</li><li><strong>WHERE</strong>（行级过滤）</li><li><strong>GROUP BY</strong>（分组）</li><li><strong>HAVING</strong>（对分组结果的过滤）</li><li><strong>SELECT</strong>（投影、表达式计算）</li><li><strong>DISTINCT</strong>（去重，如果有）</li><li><strong>ORDER BY</strong>（排序）</li><li><strong>LIMIT</strong>（限制返回行数）</li></ol><p>注意：</p><ul><li><strong>子查询 &#x2F; 派生表</strong> 在其内部先执行（或由优化器重写）。</li><li>优化器在物理执行上可能重排序或采用更有效算法（例如把谓词下推到存储引擎），但逻辑意义遵循以上顺序。</li><li><code>ON</code> 与 <code>WHERE</code> 的区别：<code>ON</code> 常用于连接条件（可以影响是否为外连接保留行）；<code>WHERE</code> 在连接后对整行做最终过滤。</li></ul><hr><h3 id="8-MySQL-中的数据排序（ORDER-BY）是如何实现的？"><a href="#8-MySQL-中的数据排序（ORDER-BY）是如何实现的？" class="headerlink" title="8. MySQL 中的数据排序（ORDER BY）是如何实现的？"></a><strong>8. MySQL 中的数据排序（ORDER BY）是如何实现的？</strong></h3><p>两种主要方式：</p><ol><li><strong>走索引顺序</strong>（避免 filesort）：<ul><li>当 <code>ORDER BY</code> 的列正好与一个可用索引的左前缀相匹配，并且排序方向与索引一致，且查询没有要求额外的排序列或必须在不同表之间合并排序，优化器可以直接按照索引读取数据，<strong>无需显式排序</strong>（称为 “Using index”）。</li><li>覆盖索引（索引包含所有 SELECT 列）还能避免回表。</li></ul></li><li><strong>Filesort（外部排序）</strong>：<ul><li>MySQL 会把需要排序的记录（或键）取出来，放到内存（sort_buffer）里排序；如果超出内存，会使用临时文件（磁盘）进行外部排序。EXPLAIN 会显示 <code>Using filesort</code>。</li><li>实现常见为 quicksort&#x2F;mergesort 的变体：对于 large datasets，会分段排序并归并（外部排序）。</li><li>若查询还需要 group by + order by，会可能生成临时表（<code>Using temporary</code>），再排序。</li></ul></li><li><strong>优化点</strong>：<ul><li>为 ORDER BY 列建立合适的索引（左前缀），并尽量让查询使用覆盖索引，能显著避免 filesort。</li><li>减少 sort_buffer_size 不要盲目增大；更好的方法是优化索引与 SQL。</li></ul></li><li><strong>EXPLAIN 线索</strong>：<ul><li><code>Using filesort</code> → 排序发生（可能开销大）。</li><li><code>Using index</code> 与 <code>Using where</code> 等组合能提示是否能走索引避免排序。</li></ul></li></ol><hr><h3 id="9-为什么阿里巴巴-Java-手册不推荐使用存储过程？"><a href="#9-为什么阿里巴巴-Java-手册不推荐使用存储过程？" class="headerlink" title="9. 为什么阿里巴巴 Java 手册不推荐使用存储过程？"></a><strong>9. 为什么阿里巴巴 Java 手册不推荐使用存储过程？</strong></h3><p>基于工程实践的常见理由（多组织采用一致性观点）：</p><ul><li><strong>可维护性差</strong>：业务逻辑分散在应用代码与数据库存储过程里，版本控制、代码 review、测试、CI&#x2F;CD 管理不便。</li><li><strong>可测试性差</strong>：存储过程难以做单元测试，缺少成熟的构建&#x2F;测试生态。</li><li><strong>可移植性差</strong>：不同数据库的存储过程语法差异大，锁定供应商（vendor lock-in）。</li><li><strong>复杂逻辑不适合</strong>：复杂业务逻辑写在 DB 层会降低可读性、让 DB 成为业务瓶颈。</li><li><strong>伸缩性限制</strong>：数据库的横向扩展（读写分离、分库分表）会使存储过程管理复杂；应用层更易于水平扩展。</li><li><strong>运维与安全</strong>：频繁修改存储过程需要谨慎部署，不当操作可能影响全表数据。</li></ul><p><strong>但并不是绝对禁止</strong>：存储过程在某些场景仍有价值（复杂的数据库内聚合计算、减少网络往返、一些数据临近处理），关键是权衡与团队能否做好治理（版本管理、测试与文档）。</p><hr><h3 id="10-如何实现数据库不停服迁移？"><a href="#10-如何实现数据库不停服迁移？" class="headerlink" title="10. 如何实现数据库不停服迁移？"></a><strong>10. 如何实现数据库不停服迁移？</strong></h3><p>常见做法与工具（线上敏感操作的通用流程）：</p><h4 id="A-Schema-变更（DDL-无停机化策略）："><a href="#A-Schema-变更（DDL-无停机化策略）：" class="headerlink" title="A. Schema 变更（DDL 无停机化策略）："></a><strong>A. Schema 变更（DDL 无停机化策略）</strong>：</h4><ul><li>使用在线 DDL 工具：<strong>gh-ost</strong>、<strong>pt-online-schema-change（pt-osc）</strong>（Percona），原理通常是：<ol><li>创建目标结构的 shadow 表（新表）。</li><li>全量复制旧表数据到新表（分批、无锁读取）。</li><li>使用触发器或 binlog 双写在复制期间捕获并应用变更（保持同步）。</li><li>切换（RENAME TABLE 原子操作）完成替换（极短时间锁），或利用应用层路由切换表名。</li><li>清理旧表与中间对象。</li></ol></li><li>MySQL 新版本支持 <strong>instant &#x2F; in-place DDL</strong>（对部分操作如某些 ADD COLUMN 可瞬时完成），要根据 MySQL 版本能力安排。</li></ul><h4 id="B-数据迁移（不停服搬库）："><a href="#B-数据迁移（不停服搬库）：" class="headerlink" title="B. 数据迁移（不停服搬库）："></a><strong>B. 数据迁移（不停服搬库）</strong>：</h4><ul><li>使用逻辑复制&#x2F;同步：<ul><li>使用 <strong>replica</strong>（基于 binlog）把流量从老库写到新库，切换读写角色（master-master &#x2F; master-slave 切换），或多写短期双写，最后切走流量。</li><li>使用工具：<strong>gh-ost</strong>, <strong>pt-osc</strong>, <strong>MaxScale</strong>, <strong>Canal</strong>, <strong>Debezium</strong>（CDC）等。</li></ul></li><li>使用物理复制&#x2F;备份恢复：<ul><li>使用 <code>Percona XtraBackup</code> 做热备恢复到新实例，再提升为主库（需注意 binlog 位点迁移与增量）。</li></ul></li><li><strong>切换策略</strong>：<ul><li>先做读切换：把只读流量切到新库进行验证。</li><li>再短暂降级写或使用双写&#x2F;幂等写策略，最终切换写主。</li><li>最后回放或同步最后的 binlog。</li></ul></li></ul><h4 id="实战注意："><a href="#实战注意：" class="headerlink" title="实战注意："></a><strong>实战注意</strong>：</h4><ul><li><strong>自动化、灰度</strong>：分阶段灰度切换，避免一次性切换全量流量。</li><li><strong>监控与回滚</strong>：详细监控（延迟、错误率），支持快速回滚方案。</li><li><strong>数据一致性验证</strong>：使用 checksum（pt-table-checksum）等验证数据一致性。</li><li><strong>schema migration 工具链</strong>：Liquibase&#x2F;Flyway 管理 schema 版本，配合在线 DDL。</li><li><strong>压力与资源</strong>：复制过程中会对源库添加额外负载，提前评估资源与窗口。</li></ul><hr><h3 id="11-UNSIGNED-属性有什么用？"><a href="#11-UNSIGNED-属性有什么用？" class="headerlink" title="11. UNSIGNED 属性有什么用？"></a><strong>11. <code>UNSIGNED</code> 属性有什么用？</strong></h3><ul><li>只适用于整数类型（TINYINT&#x2F;SMALLINT&#x2F;MEDIUMINT&#x2F;INT&#x2F;BIGINT）：<code>UNSIGNED</code> 表示无符号，<strong>范围从 0 到 2^N − 1</strong>（例如 INT UNSIGNED 范围 0 ~ 4294967295）。</li><li><strong>作用</strong>：把同样字节数的上限往正数方向翻倍（允许更大正数），但不能存负数。</li><li><strong>注意点</strong>：<ul><li>查询&#x2F;比较时注意有符号与无符号的比较规则（有时会隐式转换）。</li><li>与应用语言映射（Java 的 int 是有符号）要小心越界与类型不匹配。</li><li>存储大小（字节数）不变，只有数值范围变化。</li></ul></li></ul><hr><h3 id="12-MySQL-中-int-11-的-11-表示什么？"><a href="#12-MySQL-中-int-11-的-11-表示什么？" class="headerlink" title="12. MySQL 中 int(11) 的 11 表示什么？"></a><strong>12. MySQL 中 <code>int(11)</code> 的 11 表示什么？</strong></h3><ul><li><strong><code>(11)</code> 只是显示宽度（display width）</strong>，仅在与 <code>ZEROFILL</code> 一起使用时生效（会用前导零补齐到显示宽度）。并<strong>不影响存储大小或范围</strong>。</li><li>实际存储仍由 INT 类型决定（4 字节）。</li><li>从 MySQL 8.0.17 起，整数显示宽度已被弃用（除了 TINYINT(1) 的布尔习惯），因此不要依赖这个数字表示精度或范围。</li></ul><hr><h3 id="13-CHAR-与-VARCHAR-有何区别？"><a href="#13-CHAR-与-VARCHAR-有何区别？" class="headerlink" title="13. CHAR 与 VARCHAR 有何区别？"></a><strong>13. <code>CHAR</code> 与 <code>VARCHAR</code> 有何区别？</strong></h3><ul><li><strong>CHAR(n)</strong>：<ul><li>固定长度（n 个字符），存储时不足部分用空格填充（右填充）。读取时空格可能被忽略（在比较与一些行为中）。</li><li>适合长度固定的小字段（例如国家码、固定码）。</li><li>存取更简单、性能稳定（少指针&#x2F;长度字节开销）。</li></ul></li><li><strong>VARCHAR(n)</strong>：<ul><li>可变长度，用 1 或 2 字节保存长度前缀（长度 ≤ 255 用 1 字节，≥256 用 2 字节，取决于实际定义与字符集），存储仅占用实际字符 + 前缀字节。</li><li>适合变长字符串（名字、描述等）。</li></ul></li><li><strong>存储与索引注意</strong>：<ul><li>InnoDB 行最大长度限制（受整行 65KB 限制影响），长 VARCHAR 可能 off-page（BLOB&#x2F;TEXT 处理类似）。</li><li>CHAR 比 VARCHAR 更适合短且固定的值；VARCHAR 更节省空间但带有长度前缀。</li></ul></li></ul><hr><h3 id="14-VARCHAR-100-与-VARCHAR-10-的区别？"><a href="#14-VARCHAR-100-与-VARCHAR-10-的区别？" class="headerlink" title="14. VARCHAR(100) 与 VARCHAR(10) 的区别？"></a><strong>14. <code>VARCHAR(100)</code> 与 <code>VARCHAR(10)</code> 的区别？</strong></h3><ul><li>主要差别是<strong>允许的最大长度</strong>（100 vs 10 字符），以及索引前缀限制和潜在行大小影响。</li><li><strong>实际影响</strong>：<ul><li>若使用 UTF8&#x2F;utf8mb4，100 字符可能最多占用 400 字节（4 bytes&#x2F;char），会影响最大行大小与索引长度（索引长度以字节计算）。</li><li>索引时若 <code>VARCHAR(100)</code> 太长，可能需要指定索引前缀（<code>INDEX(col(50))</code>）以不超过索引长度限制。</li><li>性能上，若字段大且频繁被读取，IO 与缓存压力更大。</li></ul></li><li><strong>建议</strong>：为字段设置合理上限（既能容纳业务数据又不过分浪费），并考虑字符集的字节长度。</li></ul><hr><h3 id="15-DECIMAL-与-FLOAT-DOUBLE-的区别？"><a href="#15-DECIMAL-与-FLOAT-DOUBLE-的区别？" class="headerlink" title="15. DECIMAL 与 FLOAT/DOUBLE 的区别？"></a><strong>15. <code>DECIMAL</code> 与 <code>FLOAT/DOUBLE</code> 的区别？</strong></h3><ul><li><strong>DECIMAL</strong>：<ul><li><strong>定点（精确）数值</strong>，用于金融场景避免舍入误差（用人眼可理解的十进制精度）。在 MySQL 内部通常以压缩的二进制形式或 BCD packs 存储（每几个十进制位打包），不是 IEEE 浮点。</li><li>定义如 <code>DECIMAL(M,D)</code>：总位数 M，小数位 D（注意 M 包括小数点两侧总位数）。</li><li>优点：精确、适合金钱。缺点：运算可能比浮点慢，存储更复杂。</li></ul></li><li><strong>FLOAT &#x2F; DOUBLE</strong>：<ul><li><strong>浮点数（近似）</strong>，基于 IEEE 754，表示为二进制近似。<code>FLOAT</code> 单精度，<code>DOUBLE</code> 双精度。</li><li>适合科学计算、需要范围大但对微小舍入误差可容忍的场景。</li></ul></li><li><strong>结论</strong>：<strong>存金额用 DECIMAL（或整数 cents）</strong>，浮点用于近似计算。</li></ul><hr><h3 id="16-DATETIME-与-TIMESTAMP-的区别？"><a href="#16-DATETIME-与-TIMESTAMP-的区别？" class="headerlink" title="16. DATETIME 与 TIMESTAMP 的区别？"></a><strong>16. <code>DATETIME</code> 与 <code>TIMESTAMP</code> 的区别？</strong></h3><ul><li><strong>存储范围与字节</strong>：<ul><li><code>DATETIME</code>：可表示 <code>&#39;1000-01-01 00:00:00&#39;</code> 到 <code>&#39;9999-12-31 23:59:59&#39;</code>（8 字节传统实现；自 5.6 支持微秒扩展）。</li><li><code>TIMESTAMP</code>：通常以 UTC 的 Unix 时间戳为基础（较早实现 4 字节，范围受限制大约 1970-2038 在某些实现），MySQL 新版本扩展也有改进。</li></ul></li><li><strong>时区处理</strong>：<ul><li><code>TIMESTAMP</code> 会根据连接&#x2F;服务器时区进行存储时转换（存储为 UTC，显示时转换为当前会话时区），因此适合表示“瞬间（时点）”。</li><li><code>DATETIME</code> 不会随时区自动转换，存储的是“本地时间点”。适合表示固定本地时间，如日程表（不希望时区转换）。</li></ul></li><li><strong>默认值 &#x2F; CURRENT_TIMESTAMP</strong>：<code>TIMESTAMP</code> 更早支持 <code>CURRENT_TIMESTAMP</code> 作为默认值&#x2F;自动更新；现代 MySQL 已允许 <code>DATETIME</code> 使用 <code>CURRENT_TIMESTAMP</code>（从 5.6.5 起）。</li><li><strong>建议</strong>：<ul><li>表示事件时间点（跨时区）使用 <code>TIMESTAMP</code> 或统一存 UTC（并在应用层转换）。</li><li>表示本地日历时间或无时区语义用 <code>DATETIME</code>。</li></ul></li></ul><hr><h3 id="17-NULL-与-有什么区别？"><a href="#17-NULL-与-有什么区别？" class="headerlink" title="17. NULL 与 &#39;&#39; 有什么区别？"></a><strong>17. <code>NULL</code> 与 <code>&#39;&#39;</code> 有什么区别？</strong></h3><ul><li><code>NULL</code>：<strong>未知&#x2F;缺失值</strong>；不是值，表示“没有值”。<ul><li>与任何比较（<code>=</code>, <code>&lt;&gt;</code>）的结果为 <code>NULL</code>（即未知）；必须使用 <code>IS NULL</code> &#x2F; <code>IS NOT NULL</code> 判断。</li><li>聚合函数（如 <code>SUM</code>, <code>AVG</code>）通常忽略 NULL 值；<code>COUNT(col)</code> 不计 NULL，<code>COUNT(*)</code> 计行数包括 NULL 列。</li></ul></li><li><code>&#39;&#39;</code>：空字符串，是一种确定的值（长度 0 的字符串），不等于 NULL。</li><li><strong>索引与存储</strong>：NULL 在索引中有特殊表示；空字符串按照字符存储。</li><li><strong>实践</strong>：语义不同 — 把“未填写”与“填写为空字符串”区分开来通常更有意义。尽量选择一种约定并统一（例如允许 NULL 表示未填写）。</li></ul><hr><h3 id="18-Boolean-类型在-MySQL-中如何表示？"><a href="#18-Boolean-类型在-MySQL-中如何表示？" class="headerlink" title="18. Boolean 类型在 MySQL 中如何表示？"></a><strong>18. Boolean 类型在 MySQL 中如何表示？</strong></h3><ul><li>MySQL 中没有独立的原生 <code>BOOLEAN</code> 存储类型；<code>BOOLEAN</code> 是 <code>TINYINT(1)</code> 的别名（0 假&#x2F;false，非 0 为 true 通常视为 true）。</li><li>也可以用 <code>BIT(1)</code> 来代表布尔（但读写和表达上需要注意转换）。</li><li>实践：习惯用 <code>TINYINT(1)</code> 或在应用层把 0&#x2F;1 映射为 false&#x2F;true。</li></ul><hr><h3 id="19-为什么不推荐使用-TEXT-和-BLOB？"><a href="#19-为什么不推荐使用-TEXT-和-BLOB？" class="headerlink" title="19. 为什么不推荐使用 TEXT 和 BLOB？"></a><strong>19. 为什么不推荐使用 <code>TEXT</code> 和 <code>BLOB</code>？</strong></h3><p><strong>原因与权衡</strong>：</p><ul><li><strong>索引限制</strong>：不能对整列做索引（需要前缀索引），并且索引长度受限（与字符集、InnoDB 页布局相关）；全文检索需专门的全文索引或 ElasticSearch。</li><li><strong>性能与 IO</strong>：大对象（LOB）多数情况下会被存放到页外（off-page），增加额外 IO 与指针回访成本；排序&#x2F;分组涉及临时表时可能导致大量磁盘 I&#x2F;O（临时表落盘）。</li><li><strong>内存&#x2F;缓存问题</strong>：查询含大字段会拉大内存使用（临时表、buffers、网络传输），影响并发能力。</li><li><strong>可维护性</strong>：大对象在备份&#x2F;恢复&#x2F;复制时显著增加备份大小与时间。</li><li><strong>替代方案</strong>：若文件较大（图片、音频、视频），通常推荐把文件放在对象存储（S3&#x2F;OSS）或文件系统，并在 DB 中保存引用 URL&#x2F;元数据；若确实需要 DB 存储（事务性要求），可以用 BLOB，但需注意分块&#x2F;流式处理。</li></ul><p><strong>实践建议</strong>：短文本用 <code>VARCHAR</code>；长文本搜索用专门搜索引擎（Elasticsearch）或 InnoDB 的全文索引；大二进制数据建议外部存储。</p><hr><h3 id="20-在-MySQL-中存储金额应使用什么数据类型？"><a href="#20-在-MySQL-中存储金额应使用什么数据类型？" class="headerlink" title="20. 在 MySQL 中存储金额应使用什么数据类型？"></a><strong>20. 在 MySQL 中存储金额应使用什么数据类型？</strong></h3><ul><li><strong>推荐：<code>DECIMAL(precision, scale)</code></strong>（例如 <code>DECIMAL(13,2)</code> 或 <code>DECIMAL(10,2)</code> 视业务而定），因为 DECIMAL 提供精确的十进制表示，避免浮点舍入误差。</li><li><strong>备选</strong>：整型存“最小单位”（例如 cents），用 <code>INT</code> 或 <code>BIGINT</code> 存储（性能好，简单准确），显示时按 100&#x2F;1000 转换。</li><li><strong>建议</strong>：选定单位与精度并在全系统一致使用（数据库、API、前端）。</li></ul><hr><h3 id="21-MySQL-如何存储-IP-地址？"><a href="#21-MySQL-如何存储-IP-地址？" class="headerlink" title="21. MySQL 如何存储 IP 地址？"></a><strong>21. MySQL 如何存储 IP 地址？</strong></h3><ul><li><p><strong>IPv4</strong>：</p><ul><li><p>存为整数：<code>INT UNSIGNED</code> + <code>INET_ATON()</code> &#x2F; <code>INET_NTOA()</code> 函数转换。优点：占用 4 字节、索引速度快。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> t (ip) <span class="keyword">VALUES</span> (INET_ATON(<span class="string">&#x27;192.168.0.1&#x27;</span>));</span><br><span class="line"><span class="keyword">SELECT</span> INET_NTOA(ip) <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>IPv6</strong>：</p><ul><li>使用 <code>VARBINARY(16)</code>（或 <code>BINARY(16)</code>），使用 <code>INET6_ATON()</code> &#x2F; <code>INET6_NTOA()</code> 进行转换（兼容 IPv4&#x2F;IPv6）。也可用 <code>CHAR(39)</code> 存文本表现，但二进制更紧凑且便于索引。</li></ul></li><li><p><strong>注意</strong>：比较与排序最好保持二进制&#x2F;整数形式，减少字符串处理开销；存储时要考虑字节序（INET_ATON&#x2F;NTOA 处理好）。</p></li></ul><hr><h3 id="22-什么是数据库视图？"><a href="#22-什么是数据库视图？" class="headerlink" title="22. 什么是数据库视图？"></a><strong>22. 什么是数据库视图？</strong></h3><ul><li><strong>视图（VIEW）</strong>：基于 SQL 查询的虚拟表，定义后可以像表一样查询。视图并不总是存储数据（除非是物化视图，MySQL 本身不原生支持物化视图）。</li><li><strong>用途</strong>：<ul><li>抽象复杂查询、封装业务逻辑、权限控制（给用户只读视图）、简化客户端查询。</li></ul></li><li><strong>类型</strong>：<ul><li><strong>可更新视图</strong>：在满足一定条件时（单表、无聚合、无 DISTINCT、无 GROUP BY、无 LIMIT 等）可以通过视图执行 INSERT&#x2F;UPDATE&#x2F;DELETE。</li><li><strong>不可更新视图</strong>：含聚合、分组、连接等，不能直接更新。</li></ul></li><li><strong>性能</strong>：视图是查询的“别名”，执行时会把视图展开为真实查询，复杂视图会带来性能影响；对于频繁计算的大查询，可以考虑物化策略（手工维护的物化表）。</li></ul><hr><h3 id="23-什么是数据库游标？"><a href="#23-什么是数据库游标？" class="headerlink" title="23. 什么是数据库游标？"></a><strong>23. 什么是数据库游标？</strong></h3><ul><li><strong>游标（Cursor）</strong>：在存储过程&#x2F;函数或数据库会话中用于逐行处理结果集的机制。游标允许你在 PL&#x2F;SQL&#x2F;存储过程里按顺序取出行并逐行处理。</li><li><strong>MySQL 游标特点</strong>：<ul><li>在存储过程中 <code>DECLARE cursor_name CURSOR FOR select_statement; OPEN cursor_name; FETCH cursor_name INTO ...; CLOSE cursor_name;</code></li><li>MySQL 的游标通常是<strong>只进&#x2F;只读（forward-only, read-only）</strong>，不像高级 DB（Oracle）支持可滚动游标。</li></ul></li><li><strong>使用场景</strong>：需要逐行处理复杂逻辑、触发器或批量逐行迁移（但通常行处理效率差，优先考虑集合式 SQL 方案）。</li><li><strong>性能提示</strong>：尽量避免在大数据量上使用游标逐行处理，改为批量 SQL 或应用层并行处理更高效。</li></ul><hr><h3 id="24-为什么不建议直接存储大对象（图片-音频-视频）？"><a href="#24-为什么不建议直接存储大对象（图片-音频-视频）？" class="headerlink" title="24. 为什么不建议直接存储大对象（图片 &#x2F; 音频 &#x2F; 视频）？"></a><strong>24. 为什么不建议直接存储大对象（图片 &#x2F; 音频 &#x2F; 视频）？</strong></h3><p><strong>主要问题</strong>：</p><ul><li><strong>备份&#x2F;恢复压力</strong>：数据库备份会包含这些大文件，导致备份体积和恢复时间急剧上升。</li><li><strong>性能与 IO</strong>：读写 BLOB 需大量 IO，影响数据库的整体响应性能；大对象导致内存&#x2F;网络传输压力。</li><li><strong>可扩展性</strong>：数据库扩容成本高；通常对象存储（S3&#x2F;OSS）更易横向扩展、CDN 分发。</li><li><strong>费用</strong>：托管 DB 存储成本高于对象存储系统。</li><li><strong>替代方案</strong>：将大对象存对象存储或 CDN，数据库仅保存元数据（文件路径&#x2F;URL、校验信息、版本）。</li></ul><p><strong>但有例外</strong>：若强事务一致性要求非常高或小文件数量有限，存 BLOB 有时更方便（例如需要事务回滚把文件也回滚），需评估权衡与方案。</p><hr><h3 id="25-数据库的三大范式（1NF-2NF-3NF）是什么？"><a href="#25-数据库的三大范式（1NF-2NF-3NF）是什么？" class="headerlink" title="25. 数据库的三大范式（1NF &#x2F; 2NF &#x2F; 3NF）是什么？"></a><strong>25. 数据库的三大范式（1NF &#x2F; 2NF &#x2F; 3NF）是什么？</strong></h3><p><strong>第一范式（1NF）</strong>：</p><ul><li>要求表中每个字段都是原子值（atomic），不能是集合或重复列。</li><li>例如，不应该有 <code>phones</code> 字段保存多个电话号码（而应该拆成多行或独立表）。</li></ul><p><strong>第二范式（2NF）</strong>：</p><ul><li>在满足 1NF 的前提下，<strong>每个非主属性完全依赖于主键</strong>（解决部分依赖）。</li><li>针对复合主键：不能让非主属性只依赖于部分键。若有部分依赖，应拆表。</li></ul><p><strong>第三范式（3NF）</strong>：</p><ul><li>在 2NF 基础上，<strong>消除传递依赖</strong>（非主属性不能依赖于其他非主属性）。即每个非主属性直接依赖主键。</li><li>例如表 <code>order(order_id, customer_id, customer_name)</code>，<code>customer_name</code> 依赖于 <code>customer_id</code>（非主属性→非主属性依赖），应拆成 <code>customer</code> 表。</li></ul><p><strong>补充</strong>：</p><ul><li><strong>BCNF（Boyce–Codd NF）</strong> 更强，要求每个决定因素都是候选键。</li><li><strong>范式优点</strong>：减少数据冗余，避免更新异常（插入&#x2F;删除&#x2F;更新异常），提高数据一致性。</li><li><strong>范式代价 &#x2F; 实战</strong>：<ul><li>过度范式化会导致大量 join（性能开销），在 OLTP&#x2F;OLAP&#x2F;高性能场景常采用 <strong>适度反范式化</strong>（为查询性能牺牲部分冗余），并通过应用&#x2F;触发器保证一致性或使用 ETL 保持数据同步。</li><li>实际设计通常是「第三范式为主，针对性能热点做有控制的反范式化或采用缓存&#x2F;聚合表」。</li></ul></li></ul><hr><h3 id="最后：实战建议（综合）"><a href="#最后：实战建议（综合）" class="headerlink" title="最后：实战建议（综合）"></a>最后：实战建议（综合）</h3><ul><li>生产数据库首选 <strong>InnoDB</strong>，设计表时优先考虑事务一致性与索引策略。</li><li>对 SQL 性能：学会用 <code>EXPLAIN</code> &#x2F; <code>EXPLAIN ANALYZE</code>、慢查询日志、profiling 工具（pt-query-digest）定位问题；避免 SELECT *、滥用子查询；合理设计索引与覆盖索引。</li><li>对大数据&#x2F;大对象：避免将大量二进制内容放 DB；使用对象存储 + DB 存元数据。</li><li>Schema 变更：使用 gh-ost&#x2F;pt-osc&#x2F;ONLINE DDL 工具实现不停服。</li><li>金额用 DECIMAL 或 integer cents；IP 用整型或 VARBINARY(16)；时间点用 TIMESTAMP（或统一存 UTC）。</li></ul><h2 id="JVM-牛客面经八股"><a href="#JVM-牛客面经八股" class="headerlink" title="JVM-牛客面经八股"></a>JVM-牛客面经八股</h2><h3 id="JVM结构图"><a href="#JVM结构图" class="headerlink" title="JVM结构图"></a>JVM结构图</h3><p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/16f4750982daa7b6%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/16f47509829e2b5b%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/16f4750983bf3620%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p><h3 id="创建一个新对象-内存分配流程"><a href="#创建一个新对象-内存分配流程" class="headerlink" title="创建一个新对象 内存分配流程"></a>创建一个新对象 内存分配流程</h3><p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/16f4750983d600e5%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/0082zybply1gc6fz21n8kj30u00wpn5v.jpg" alt="JVM 基础- JVM 内存结构| Java 全栈知识体系"></p><hr><h3 id="1-JVM-内存模型（运行时数据区）——深入"><a href="#1-JVM-内存模型（运行时数据区）——深入" class="headerlink" title="1) JVM 内存模型（运行时数据区）——深入"></a>1) JVM 内存模型（运行时数据区）——深入</h3><p>JVM 将运行时数据区分为<strong>线程私有</strong>和<strong>多线程共享</strong>两类。</p><p><strong>线程私有区域</strong></p><ul><li><strong>程序计数器（PC）</strong>：每线程一份，记录下一条要执行的字节码指令地址（用于执行字节码的分支控制）。如果线程在执行本地方法，该寄存器值为 undefined。</li><li><strong>虚拟机栈（JVM Stack）</strong>：每个线程一个栈，栈帧包含局部变量表、操作数栈、动态连接和方法返回地址。局部变量表保存基本类型和对象引用。栈溢出会抛出 <code>StackOverflowError</code>。</li><li><strong>本地方法栈（Native Stack）</strong>：专门用于处理本地方法（C&#x2F;C++实现）调用的栈（HotSpot 在实际实现上可与 JVM Stack 合并或分开实现）。</li></ul><p><strong>多线程共享区域</strong></p><ul><li><strong>堆（Heap）</strong>：存放对象实例与数组，是 GC 管理的主要区域。堆细分为**年轻代（Eden + Survivor0&#x2F;1）*<em>和*<em>老年代</em></em>（Tenured）。堆还可能包含永久代或元空间（见下）。</li><li><strong>方法区（Method Area）&#x2F;元空间（Metaspace）</strong>：存放类的元数据（Class 对象、常量池、静态变量、方法字节码）。JDK 8 起把 PermGen 替换为 Metaspace（在本地内存），可以通过 <code>-XX:MaxMetaspaceSize</code> 限制。</li><li><strong>直接内存（Direct Memory）</strong>：不在 JVM 堆中，由 <code>ByteBuffer.allocateDirect()</code> 等分配。虽然不在堆中，但会被本地内存耗尽导致 OOME（需要监控 native memory）。</li></ul><p><strong>重要细节</strong></p><ul><li>对象头（Mark Word + Klass Pointer）包含 GC 元信息（锁标记、哈希码、分代年龄等）和类指针（或 compressed klass pointer）。</li><li>对齐与压缩：<code>-XX:+UseCompressedOops</code>（默认常开）影响对象引用大小与堆布局。</li><li>类加载器与类元数据泄露：类无法卸载的常见原因是类加载器仍有引用（静态集合、线程池、ThreadLocal 导致的 classloader leak）。</li></ul><hr><h3 id="2-JVM-的垃圾回收算法"><a href="#2-JVM-的垃圾回收算法" class="headerlink" title="2) JVM 的垃圾回收算法"></a>2) JVM 的垃圾回收算法</h3><p>JVM 中常用&#x2F;经典的 GC 算法原则与实现：</p><p><strong>基础算法</strong></p><ul><li><strong>引用计数（Reference Counting）</strong>：为每个对象维护引用计数，计数为 0 时回收。缺点：无法处理循环引用。<em>HotSpot 不采用此算法</em>。</li><li><strong>可达性分析（Trace-based）</strong>：从 GC Roots 开始通过引用图遍历，标记活对象，未标记即回收。HotSpot 采用此方法。</li></ul><p><strong>回收策略</strong></p><ul><li><strong>标记-清除（Mark-Sweep）</strong>：标记所有可达对象，然后清除未标记对象。优点：实现简单；缺点：产生内存碎片。</li><li><strong>标记-整理（Mark-Compact）</strong>：标记活对象，然后将活对象压缩到一端，更新引用，消除碎片。适合老年代。</li><li><strong>复制（Copying）</strong>：把活对象从一个空间复制到另一个空间（两块半区或多个区），空出整个区域，避免碎片。优点：简单高效。常用于年轻代（Eden&#x2F;Survivor）。</li><li><strong>分代收集（Generational）</strong>：根据对象存活期长短分代（年轻代&#x2F;老年代）。年轻代使用复制算法（低成本），老年代使用标记-清除或标记-整理。因为大多数对象寿命短（弱生成假设），分代策略能显著提高性能。</li></ul><p><strong>现代收集器（概述）</strong></p><ul><li><strong>Serial GC</strong>：单线程收集，STW（Stop The World），适用于单核或小内存场景。</li><li><strong>Parallel（Throughput）GC</strong>：多线程并行回收，追求吞吐量，适合 batch、后台服务。</li><li><strong>CMS（Concurrent Mark-Sweep）</strong>：并发标记清理，低暂停，使用并发阶段来减少 STW。已在新版 JDK 中被标注为过时&#x2F;删除。</li><li><strong>G1（Garbage-First）</strong>：把堆划分为 region，进行 region 级别回收与并行压缩，设计目标是可预测的暂停与高吞吐，现代服务器应用默认或推荐使用。</li><li><strong>ZGC &#x2F; Shenandoah</strong>：以并发压缩为目标，追求极低停顿（几毫秒级甚至微秒级），适合超大堆与低延迟需求。</li></ul><hr><h3 id="3-GC-的可达性分析"><a href="#3-GC-的可达性分析" class="headerlink" title="3) GC 的可达性分析"></a>3) GC 的可达性分析</h3><p><strong>根（GC Roots）来源</strong></p><ul><li>Java 虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中的静态引用（静态变量）。</li><li>本地方法栈或 JNI 中的引用。</li><li>运行时常量池中直接引用（部分实现）。</li><li>其他 JVM 内部持有的引用（例如 ClassLoader 的引用）。</li></ul><p><strong>引用类型的语义</strong></p><ul><li><strong>强引用（StrongReference）</strong>：普通引用，GC 不会回收强引用对象。</li><li><strong>软引用（SoftReference）</strong>：在内存不足时回收，适用于缓存（<code>SoftReference</code>）。</li><li><strong>弱引用（WeakReference）</strong>：在下一次 GC 时就可能回收，适用于 canonicalized mappings 等。</li><li><strong>虚引用（PhantomReference）</strong>：对象被回收后会把引用加入引用队列，可用于在对象被回收后做清理（配合 ReferenceQueue），并且 <code>get()</code> 返回 null。</li></ul><p><strong>遍历算法</strong></p><ul><li>从 GC Roots 开始做图遍历（BFS&#x2F;DFS）标记所有可达对象；未标记即为垃圾。</li><li>优点：能处理循环引用（与引用计数对比），是 HotSpot 的主流做法。</li><li>一些优化：<ul><li><strong>增量&#x2F;并发标记</strong>：把标记工作分阶段与应用线程并发执行，以减少 STW。</li><li><strong>卡表（Card Table）跟踪写入屏障</strong>：在分代收集中用于记录跨代引用（例如老-&gt;新），推动并行或并发回收优化。</li></ul></li></ul><hr><h3 id="4-CMS-Concurrent-Mark-Sweep-垃圾回收器-——-细节与调优"><a href="#4-CMS-Concurrent-Mark-Sweep-垃圾回收器-——-细节与调优" class="headerlink" title="4) CMS (Concurrent Mark Sweep) 垃圾回收器 —— 细节与调优"></a>4) CMS (Concurrent Mark Sweep) 垃圾回收器 —— 细节与调优</h3><p><strong>目标</strong>：尽量减少与应用线程的 STW 停顿（低延迟），主要用于老年代收集（年轻代通常用并行收集 <code>ParNew</code>）。</p><p><strong>CMS 工作阶段（常见实现顺序）</strong></p><ol><li><strong>初始标记（Initial Mark）</strong> — STW：标记直接可达的对象（通常从根开始快速标记与 GC Roots 直接关联的对象）；时间较短。</li><li><strong>并发标记（Concurrent Mark）</strong> — 与应用线程并发：遍历引用图标记可达对象。</li><li><strong>并发预清理（Concurrent Preclean）</strong> —（可选）修正并发期间的部分浮动垃圾。</li><li><strong>重新标记（Remark）</strong> — STW：修正并发标记期间因应用线程持有或释放引用导致的漏标（这一步相对短于传统全量标记，因为大部分工作已并发完成）。</li><li><strong>并发清理（Concurrent Sweep）</strong> — 与应用线程并发：清理未标记对象并维护空闲链表。</li><li><strong>并发重置&#x2F;重组（Concurrent Reset）</strong>：准备下一次 GC。</li></ol><p><strong>实现细节与问题</strong></p><ul><li><strong>不做压缩（默认）</strong>：CMS 清理不会压缩老年代，因此会留下内存碎片。碎片问题可能导致“内存足够但无法满足连续大对象分配”从而触发 Full GC。</li><li><strong>并发模式失败（Concurrent Mode Failure）</strong>：如果 CMS 无法在合理时间内完成并发回收（例如分配速率非常高或堆碎片太多），会触发 fallback：做一次 STW 的 Full GC（通常由 Serial GC 或 Parallel Old 执行），其停顿可能很长。</li><li><strong>并发标记期间的“floating garbage”</strong>：由于并发执行，某些对象在标记时刚好变为不可达或变得可达，需要 re-mark 来修正。</li><li><strong>配套 Young Collector</strong>：CMS 常与 <code>ParNew</code>（并行年轻代收集器）配合使用以减少年轻代停顿。</li></ul><p><strong>常见调优参数（典型）</strong></p><ul><li><code>-XX:+UseConcMarkSweepGC</code>：开启 CMS（旧 JDK）。</li><li><code>-XX:+UseParNewGC</code>：并行年轻代与 CMS 协同。</li><li><code>-XX:CMSInitiatingOccupancyFraction=XX</code>：触发 CMS 的老年代占用率阈值（百分比）。默认例如 68 或 75，通常设置为 60~75，视应用而定。</li><li><code>-XX:+UseCMSInitiatingOccupancyOnly</code>：只使用指定阈值（避免 JVM 自适应更改）。</li><li><code>-XX:+CMSParallelRemarkEnabled</code>：并行 re-mark，减少 remark 停顿。</li><li><code>-XX:+CMSClassUnloadingEnabled</code>：允许 CMS 在并发过程中卸载类并回收元空间中无用的 class 元数据（防止 metaspace 泄漏）。</li></ul><p><strong>排查 CMS 问题</strong></p><ul><li><strong>频繁 Full GC &#x2F; Concurrent Mode Failure</strong>：查看 GC 日志（<code>-Xlog:gc*</code> 或 <code>-XX:+PrintGCDetails</code>），识别是否为 CMS 失败导致的 Full GC；增大堆或调高 <code>CMSInitiatingOccupancyFraction</code>，或减少老年代占用速率（减少晋升&#x2F;减少内存占用）。</li><li><strong>碎片问题</strong>：增加老年代大小，或在 Full GC 时触发压缩（Full GC 通常会做 compact）；考虑切换到 G1（自带整理能力）。</li><li><strong>已被弃用&#x2F;移除</strong>：注意在新版本 JDK（例如 JDK 14+）CMS 已被移除或标记弃用，应优先考虑 G1、ZGC 或 Shenandoah。</li></ul><hr><h3 id="5-G1-收集器（Garbage-First）"><a href="#5-G1-收集器（Garbage-First）" class="headerlink" title="5) G1 收集器（Garbage-First）"></a>5) G1 收集器（Garbage-First）</h3><p><strong>目标</strong>：在大堆场景下提供可预测的停顿目标（低延迟）与高吞吐，同时减少碎片。JDK9+ 的默认回收器通常为 G1（视 JVM 版本而定）。</p><p><strong>核心思想</strong></p><ul><li><strong>Region（区域）</strong>：G1 把堆划分为等大小的 region（通常 1MB~32MB，自动根据堆大小选择），每个 region 可以被逻辑地视为 Eden&#x2F;Survivor&#x2F;Old。</li><li><strong>记忆集（Remembered Sets, RSet）</strong>：为了记录跨 region 的引用（比如老区指向年轻区），G1 使用 RSet 来快速定位哪些 region 可能引用某 region 的对象，以便并发&#x2F;并行回收时正确处理根集合。</li><li><strong>并发标记阶段 + 混合回收</strong>：<ol><li><strong>初始标记（STW）</strong>：短暂停顿做 root scanning（与 Eden GC 同步）。</li><li><strong>并发标记（Concurrent Mark）</strong>：并发地标记可达对象，构建 liveness 信息和 region 的垃圾率估算。</li><li><strong>重新标记（Remark）</strong>：STW，修正并发期间变更。</li><li><strong>并发清理（Cleanup）</strong>：确定哪些 region 应该被回收&#x2F;合并（形成 Evacuation Set）。</li><li><strong>混合回收（Mixed GC）</strong>：在并发阶段之后执行若干次混合回收，回收年轻代 region 以及一些老年代 region，直到满足堆回收目标。</li></ol></li><li><strong>Evacuation（搬迁）</strong>：G1 回收采用“复制&#x2F;搬迁”策略，把选中的 region 中的存活对象复制到其他空闲 region（可合并 region），以避免碎片并保持连续可用空间。</li><li><strong>Humongous objects</strong>：大对象（大于 region size&#x2F;2）被视为 humongous，会占用连续多个 region，并直接交付给老年代（并采用专门策略回收）。</li></ul><p><strong>G1 的优点</strong></p><ul><li>区域化管理，支持并行、并发、压缩（搬迁）操作，降低碎片概率。</li><li>可以设置 <code>-XX:MaxGCPauseMillis</code> 作为目标，G1 会尝试在此暂停目标下选择回收区域集合以满足目标（并不能保证严格实现）。</li><li>支持并发标记并回收老年代（mixed GC），提高可预测性。</li></ul><p><strong>重要参数与调优</strong></p><ul><li><code>-XX:+UseG1GC</code>：启用 G1（现代 JDK 常为默认）。</li><li><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code>：G1 尝试将停顿控制到 N ms（软目标）。</li><li><code>-XX:InitiatingHeapOccupancyPercent=&lt;pct&gt;</code>（默认 ~45）：并发标记触发阈值（当堆占用达到此百分比时启动 concurrent marking）。</li><li><code>-XX:G1HeapRegionSize=&lt;size&gt;</code>：region 大小，自动调整但可显式设置（1MB~32MB），影响 humongous 阈值与 remembered set 管理开销。</li><li><code>-XX:ConcGCThreads</code> &#x2F; <code>-XX:ParallelGCThreads</code>：并发&#x2F;并行线程数目，通常与 CPU core 配置有关。</li><li><code>-XX:MaxTenuringThreshold</code>：对象晋升阈值控制（与 Survivor 区的年龄策略相关）。</li></ul><p><strong>诊断与问题</strong></p><ul><li><strong>Humongous 分配问题</strong>：大量 humongous 对象可能导致 region 被大量占用并影响 G1 的效率；可考虑调整 region size 或改用分块存储。</li><li><strong>Remembered Set 开销</strong>：对于很多跨 region 引用（即对象分布极为分散或写入热点多），RSet 更新开销高。</li><li><strong>GC 日志分析</strong>：使用 <code>-Xlog:gc*:file=gc.log</code>（JDK9+）或 <code>-XX:+PrintGCDetails</code>（老方式），并用 GC 分析工具（GCEasy、GCViewer、JClarity）查看 pause、mixed GC 次数、humongous 比例等。</li></ul><hr><h3 id="6-类加载机制（加载、链接、初始化）"><a href="#6-类加载机制（加载、链接、初始化）" class="headerlink" title="6) 类加载机制（加载、链接、初始化）"></a>6) 类加载机制（加载、链接、初始化）</h3><p><strong>加载（Loading）</strong></p><ul><li>ClassLoader 读取类的二进制字节流，将其转换为 <code>Class</code> 对象（在方法区&#x2F;MetaSpace 存储元数据），并在 JVM 的方法区中创建相应的数据结构（方法、常量池、字段布局等）。</li></ul><p><strong>链接（Linking）</strong></p><ul><li><strong>验证（Verification）</strong>：确保字节流符合 JVM 规范（格式正确、语义不违背安全约束）。</li><li><strong>准备（Preparation）</strong>：为类的静态变量分配内存并赋默认值（但不执行显式初始值）。</li><li><strong>解析（Resolution）</strong>：把符号引用解析成直接引用（如类的全限定名解析为直接内存地址或指针）。解析可以是懒解析（首次使用时解析）。</li></ul><p><strong>初始化（Initialization）</strong></p><ul><li>执行类的 <code>&lt;clinit&gt;</code> 方法（由编译器合成，包含 static 初始化器和静态字段的赋值语句），这是执行静态初始化的阶段。初始化由 VM 控制（线程安全，按需触发）。</li><li><strong>什么时候触发初始化</strong>（例子）：<ul><li>首次主动使用（new、调用静态方法、读取&#x2F;写入静态字段、反射调用 Class.forName 等）。</li><li><code>Class.forName()</code> 会强制初始化（除非用 <code>Class.forName(name, false, loader)</code>）。</li></ul></li></ul><p><strong>类加载器层次</strong></p><ul><li><strong>Bootstrap（启动）类加载器</strong>：加载核心类库（JRE&#x2F;lib） — C&#x2F;C++ 实现，不是 Java 对象。</li><li><strong>Platform &#x2F; Extension 类加载器</strong>（JDK 9+ 为 Platform loader）：负责加载平台类。</li><li><strong>Application &#x2F; System 类加载器</strong>：加载应用类路径（-classpath 指定路径）。</li><li><strong>自定义类加载器</strong>：通过继承 <code>ClassLoader</code> 覆盖 <code>findClass</code> 或 <code>loadClass</code> 来实现自定义行为（隔离、热部署、沙箱等）。</li></ul><p><strong>类卸载</strong></p><ul><li>类及其 ClassLoader 可以被卸载，前提是：<ul><li>所有该类由其 ClassLoader 加载的类实例、静态引用、线程上下文等均被回收（ClassLoader 没有活跃引用）。</li><li>在 HotSpot 中，类卸载由垃圾回收触发（常在 Full GC 或并发标记期间进行）；一些 GC（如 CMS、G1）支持类卸载（需要相应参数，如 <code>CMSClassUnloadingEnabled</code> 在 CMS 中）。</li></ul></li><li><strong>常见导致类无法卸载问题</strong>：线程池未停止的线程持有 ThreadLocal 的引用、静态单例、JDBC 驱动未注销等。</li></ul><hr><h3 id="7-双亲委派模型-如何打破"><a href="#7-双亲委派模型-如何打破" class="headerlink" title="7) 双亲委派模型 &amp; 如何打破"></a>7) 双亲委派模型 &amp; 如何打破</h3><p><strong>双亲委派（Parent Delegation）机制</strong></p><ul><li>加载类的请求先委托给父加载器，如果父加载器无法加载再由子加载器尝试加载。目的：<ul><li>保证核心类优先由 Bootstrap Loader 加载（安全性，避免自定义类覆盖 java.lang.*）。</li><li>简化类的唯一性管理，避免重复加载核心类。</li></ul></li></ul><p><strong>实现流程（High-level）</strong></p><ul><li><code>ClassLoader.loadClass(name)</code>：<ol><li>检查缓存是否已加载。</li><li>如果未加载，委托给 parent.loadClass(name)（若 parent 存在）。</li><li>如果 parent 无法找到，再调用本地 <code>findClass(name)</code> 去加载（子加载器）。</li></ol></li></ul><p><strong>打破双亲委派的理由与方法</strong></p><ul><li><strong>为什么要打破</strong>：某些容器（如应用服务器、插件框架、OSGi、Tomcat 的 webapp classloader）需要实现“子优先（child-first）”加载策略以隔离应用或实现热部署。</li><li><strong>如何打破</strong>：<ul><li><strong>覆盖 <code>loadClass</code></strong>：自定义 <code>ClassLoader</code> 重写 <code>loadClass</code> 方法，先尝试 <code>findLoadedClass</code> 和 <code>findClass</code>（子加载器），若找不到再委托 parent。注意处理 <code>java.*</code> 或核心类仍应委托父加载器以避免安全风险。</li><li><strong>在容器实现中使用 child-first 策略</strong>（Tomcat 中有设置），以便在 webapp 中优先加载 WEB-INF&#x2F;lib&#x2F; classes。</li></ul></li><li><strong>风险 &amp; 问题</strong>：<ul><li><strong>类卸载与类型不兼容</strong>：若相同的类由不同 ClassLoader 加载，类的“身份”不同，会出现 <code>ClassCastException</code>（即使类名相同）。</li><li><strong>安全风险</strong>：子加载器加载 core 类可能覆盖 JDK 内部类，带来安全隐患。</li><li><strong>复杂性</strong>：对依赖关系的管理更复杂，特别是 native library 绑定与单例行为。</li></ul></li></ul><hr><h3 id="8-出现-Full-GC-的场景"><a href="#8-出现-Full-GC-的场景" class="headerlink" title="8) 出现 Full GC 的场景"></a>8) 出现 Full GC 的场景</h3><p>Full GC（通常指触发了老年代回收和可能会做类&#x2F;元空间回收或堆压缩的 STW）可由多种原因触发，常见包含：</p><p><strong>内存与分配相关</strong></p><ul><li><strong>老年代空间不足</strong>（老年代无法容纳晋升对象）：当晋升失败或老年代碎片严重导致无法找到连续空间分配大对象。</li><li><strong>空间被大量持久对象占满</strong>（例如缓存过大、未释放的集合、内存泄漏）。</li><li><strong>Promotion Failure &#x2F; Allocation Failure</strong>：年轻代 GC 后向老年代晋升对象失败，可能触发 Full GC。</li><li><strong>太多 Humongous 对象（G1 &#x2F; region-based）</strong>：大对象占据大量 region，影响分配&#x2F;回收，进而触发 Full GC。</li></ul><p><strong>元空间（Metaspace）或永久代（PermGen）</strong></p><ul><li><strong>Metaspace&#x2F;PermGen 用尽</strong>：类&#x2F;字节码元数据分配失败会触发 Full GC 来尝试回收类并卸载无用类（如果成功则释放空间），否则抛出 <code>OutOfMemoryError: Metaspace</code>。</li></ul><p><strong>显式或系统触发</strong></p><ul><li><strong>System.gc() &#x2F; 显式垃圾回收请求</strong>：若未禁用显式 GC，会触发一次 Full GC（可通过 <code>-XX:+DisableExplicitGC</code> 忽略）。</li><li><strong>某些 VM 操作</strong>（如类卸载、某些 JNI 操作、资源限制检查）需要 Full GC。</li></ul><p><strong>GC 内部</strong></p><ul><li><strong>并发回收器失败（Concurrent Mode Failure）</strong>：例如 CMS 无法并发完成回收，会回退为 Full GC（STW）。</li><li><strong>碎片化</strong>：尤其 CMS 未压缩导致碎片，分配大对象失败导致 Full GC。</li><li><strong>Native 内存压力或直接内存用尽</strong>：某些场景下 JVM 为回收资源触发 Full GC（例如清理 PhantomReference &#x2F; finalizer 队列）。</li></ul><p><strong>其他</strong></p><ul><li><strong>Finalizer 队列阻塞</strong>：对象有 <code>finalize()</code> 且 finalizer 执行滞后，可能导致大量对象等待 finalization，从而触发更多 GC。</li><li><strong>虚拟机内建的阈值&#x2F;策略</strong>：某些 GC 收集器根据内部策略在阈值到达时触发 Full 回收。</li></ul><hr><h3 id="9-常见的-JVM-参数"><a href="#9-常见的-JVM-参数" class="headerlink" title="9) 常见的 JVM 参数"></a>9) 常见的 JVM 参数</h3><p>下面按功能分类给出常见参数、作用与典型取值建议：</p><p><strong>堆内存与分代</strong></p><ul><li><code>-Xms&lt;size&gt;</code>：初始堆大小（建议与 -Xmx 一致以避免扩容开销）。</li><li><code>-Xmx&lt;size&gt;</code>：最大堆大小。</li><li><code>-Xmn&lt;size&gt;</code>：年轻代大小（也可用 <code>-XX:NewSize</code> &#x2F; <code>-XX:MaxNewSize</code>）。</li><li><code>-XX:NewRatio=n</code>：老年代与年轻代比率（老:新 &#x3D; n:1）。</li><li><code>-XX:SurvivorRatio=n</code>：Eden 与 Survivor 的比例。</li><li><code>-XX:MaxTenuringThreshold=&lt;n&gt;</code>：最大晋升年龄（决定对象在 Survivor 区停留的代数）。</li></ul><p><strong>GC 选择</strong></p><ul><li><code>-XX:+UseG1GC</code>：使用 G1 收集器（现代推荐）。</li><li><code>-XX:+UseParallelGC</code> &#x2F; <code>-XX:+UseParallelOldGC</code>：并行 GC，追求吞吐。</li><li><code>-XX:+UseConcMarkSweepGC</code>：CMS（旧）。</li><li><code>-XX:+UseSerialGC</code>：串行 GC（小堆、单线程场景）。</li><li><code>-XX:+UseZGC</code> &#x2F; <code>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</code>：新一代低停顿收集器（视 JDK 版本）。</li></ul><p><strong>GC 日志</strong></p><ul><li>JDK8 及更早：<ul><li><code>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/path/gc.log</code></li></ul></li><li>JDK9+（统一日志）：<ul><li><code>-Xlog:gc*:file=/path/gc.log:time,uptime,level,tags</code></li></ul></li><li>辅助：<code>-XX:+PrintTenuringDistribution</code>、<code>-XX:+PrintGCApplicationStoppedTime</code>。</li></ul><p><strong>元空间 &#x2F; 类加载</strong></p><ul><li><code>-XX:MetaspaceSize=&lt;n&gt;</code>：触发第一次扩展的阈值（非上限）。</li><li><code>-XX:MaxMetaspaceSize=&lt;n&gt;</code>：最大元空间大小（否则可能导致 OOME）。</li><li><code>-XX:+TraceClassLoading</code> &#x2F; <code>-XX:+TraceClassUnloading</code>：调试类加载&#x2F;卸载。</li></ul><p><strong>诊断 &amp; 堆转储</strong></p><ul><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：OOM 时自动 dump heap。</li><li><code>-XX:HeapDumpPath=/path/dump.hprof</code>。</li><li><code>-XX:+DisableExplicitGC</code>：忽略 <code>System.gc()</code> 调用。</li><li><code>-XX:+PrintFlagsFinal</code>：打印最终生效的 JVM 参数。</li></ul><p><strong>JIT 与调优</strong></p><ul><li><code>-XX:+PrintCompilation</code>、<code>-XX:+LogCompilation</code>、<code>-XX:+PrintInlining</code>、<code>-XX:CompileThreshold</code>（编译阈值）。</li><li><code>-XX:+AggressiveOpts</code>（试验性，不推荐在生产）。</li></ul><p><strong>线程与并行</strong></p><ul><li><code>-XX:ParallelGCThreads=&lt;n&gt;</code>：GC 并行线程数（与 CPU 相关）。</li><li><code>-XX:ConcGCThreads=&lt;n&gt;</code>：并发 GC 的线程数（G1&#x2F;ZGC 等适用）。</li><li><code>-Xss&lt;size&gt;</code>：每个线程栈大小（注意线程数多时总内存消耗）。</li></ul><p><strong>容器 &#x2F; 限制相关</strong></p><ul><li><code>-XX:+UseContainerSupport</code> &#x2F; <code>-XX:MaxRAMPercentage</code> &#x2F; <code>-XX:InitialRAMPercentage</code>：针对容器和 cgroup 的内存配额支持（现代 JDK）。</li></ul><p><strong>性能增强</strong></p><ul><li><code>-XX:+UseCompressedOops</code>：压缩指针（默认通常启用），降低内存占用。</li><li><code>-XX:+UseStringDeduplication</code>（G1）：启用字符串去重，降低堆中重复字符串内存占用（需要配合 G1）。</li></ul><hr><h3 id="10-JDK-的监控工具-线上处理实战案例（诊断步骤与-runbook）"><a href="#10-JDK-的监控工具-线上处理实战案例（诊断步骤与-runbook）" class="headerlink" title="10) JDK 的监控工具 &amp; 线上处理实战案例（诊断步骤与 runbook）"></a>10) JDK 的监控工具 &amp; 线上处理实战案例（诊断步骤与 runbook）</h3><p>下面用常见问题场景（CPU、内存泄漏、频繁 Full GC、死锁）来给出可复用的线上诊断步骤、命令与处置策略。</p><h4 id="常用工具（一句话）"><a href="#常用工具（一句话）" class="headerlink" title="常用工具（一句话）"></a>常用工具（一句话）</h4><ul><li><code>jps</code>：列出 Java 进程（PID）。</li><li><code>jstack &lt;pid&gt;</code>：线程栈（死锁&#x2F;线程阻塞&#x2F;CPU 占用）。</li><li><code>jmap -histo[:live] &lt;pid&gt;</code>：堆中对象统计（按类计数，<code>live</code> 只列存活对象）。</li><li><code>jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</code> 或 <code>jcmd &lt;pid&gt; GC.heap_dump file</code>：导出堆快照（用于 MAT 分析）。</li><li><code>jcmd</code>：功能强大，可触发 GC、打印系统属性、堆信息、执行诊断命令（<code>jcmd &lt;pid&gt; GC.heap_info</code>、<code>VM.system_properties</code>、<code>Thread.print</code> 等）。</li><li><code>jstat -gc &lt;pid&gt; &lt;interval&gt;</code>：实时查看 GC 活动（年轻代、老年代使用情况）。</li><li><code>jconsole</code> &#x2F; <code>VisualVM</code>：图形化监控（JMX）。</li><li><code>jcmd GC.run</code>：触发 GC。</li><li><code>jcmd VM.native_memory summary</code>：查看 native 内存使用（需要 <code>-XX:NativeMemoryTracking=detail</code> 启动）。</li><li>第三方工具：<strong>Arthas</strong>（线上探查、方法级追踪、实时 heapdump）、async-profiler（采样 CPU &#x2F; JIT 火焰图）、MAT（Heap分析）。</li></ul><h4 id="场景-1：CPU-突增"><a href="#场景-1：CPU-突增" class="headerlink" title="场景 1：CPU 突增"></a>场景 1：CPU 突增</h4><p><strong>诊断步骤</strong></p><ol><li><code>top</code> &#x2F; <code>ps</code> 确认 Java 进程 CPU 占用。</li><li><code>jstack -l &lt;pid&gt; &gt; threaddump.txt</code>（收集多个间隔 5s 的线程快照更有价值）。</li><li>分析线程 dump：找出 RUNNABLE 的热点方法（循环、I&#x2F;O、锁竞争）。</li><li>若需要更精确调用占比，使用 <code>async-profiler</code> 生成火焰图，或 <code>perf</code>（Linux）做系统级采样。</li></ol><p><strong>快速处置</strong></p><ul><li>若是 GC 占用：查看 GC 日志（<code>jstat</code> &#x2F; gc.log），若频繁 GC，考虑增加堆、调整 genç 大小或切换收集器。</li><li>若是代码热点：优化代码（减少同步、减少阻塞 I&#x2F;O、提高并行度），使用缓存或限流策略。</li></ul><h4 id="场景-2：内存泄漏（持续内存增长-OOM）"><a href="#场景-2：内存泄漏（持续内存增长-OOM）" class="headerlink" title="场景 2：内存泄漏（持续内存增长 &#x2F; OOM）"></a>场景 2：内存泄漏（持续内存增长 &#x2F; OOM）</h4><p><strong>诊断步骤</strong></p><ol><li>查看内存使用趋势（<code>jstat -gc</code> 或监控系统）。</li><li>导出堆快照（<code>jcmd &lt;pid&gt; GC.heap_dump file</code> 或 <code>jmap -dump</code>）。<strong>注意</strong>：堆 dump 操作可能会消耗大量 IO 和临时内存，生产上谨慎执行并提前协调维护窗口&#x2F;流量降级。</li><li>用 MAT（Eclipse Memory Analyzer）分析 dominator tree，找出最大的保留者（retained size）并沿引用链定位泄漏源（常见是静态集合、ThreadLocal、缓存、未关闭的资源）。</li><li>查看类加载器统计（<code>jcmd &lt;pid&gt; VM.class_histo</code> 或 <code>jmap -clstats</code>），判断是否类或 classloader 泄漏（热部署后的 webapp 卸载失败常见）。</li></ol><p><strong>处置</strong></p><ul><li>释放占用：清除缓存、关闭连接、停止线程，以便对象可被收集。</li><li>修复代码：使用弱引用或显式资源管理（try-with-resources）、确保在 webapp undeploy 时清理静态引用与线程。</li><li>监控回归，增加单元&#x2F;集成测试覆盖内存留存场景。</li></ul><h4 id="场景-3：频繁-Full-GC-GC-瘫痪（应用停顿）"><a href="#场景-3：频繁-Full-GC-GC-瘫痪（应用停顿）" class="headerlink" title="场景 3：频繁 Full GC &#x2F; GC 瘫痪（应用停顿）"></a>场景 3：频繁 Full GC &#x2F; GC 瘫痪（应用停顿）</h4><p><strong>诊断</strong></p><ol><li>检查 GC 日志：<code>-Xlog:gc*</code> 或 <code>-XX:+PrintGCDetails</code>。识别是 Full GC、CMS ConcurrentModeFailure、还是晋升失败。</li><li><code>jstat -gc</code> 查看年轻代&#x2F;老年代使用比例、晋升速率。</li><li><code>jmap -histo</code> 看增长的对象类型（是否有大量短期大对象导致频繁晋升）。</li><li>检查 Metaspace 是否耗尽（<code>jcmd &lt;pid&gt; VM.system_properties</code> + <code>-XX:MaxMetaspaceSize</code>）。</li></ol><p><strong>处置</strong></p><ul><li>增加堆或调整分代大小（<code>-Xmx</code>, <code>-Xmn</code>）、或切换 G1 并调 <code>InitiatingHeapOccupancyPercent</code>。</li><li>若是碎片化（CMS 特有），考虑暂时触发 Full GC 以 compact，或迁移到 G1。</li><li>优化代码以减少大对象分配、减少晋升速率（晋升失败），或使用对象池。</li><li>禁用显式 GC（<code>-XX:+DisableExplicitGC</code>）。</li></ul><h4 id="场景-4：死锁-线程阻塞"><a href="#场景-4：死锁-线程阻塞" class="headerlink" title="场景 4：死锁 &#x2F; 线程阻塞"></a>场景 4：死锁 &#x2F; 线程阻塞</h4><p><strong>诊断</strong></p><ol><li><code>jstack -l &lt;pid&gt;</code>：查看 BLOCKED&#x2F;WAITING&#x2F; TIMED_WAITING 线程，寻找循环等待锁的线程堆栈。</li><li><code>jstack</code> 输出中 <code>Found one Java-level deadlock</code> 会标明死锁详情。</li></ol><p><strong>处置</strong></p><ul><li>临时：重启受影响线程或整个服务（如果可承受）。</li><li>根治：查找锁顺序，改进锁策略（减少锁持有时间、使用更细粒度锁或无锁结构），增加超时与监控报警。</li></ul><h4 id="现场常用命令模板（示例）"><a href="#现场常用命令模板（示例）" class="headerlink" title="现场常用命令模板（示例）"></a>现场常用命令模板（示例）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出 Java 进程</span></span><br><span class="line">jps -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程转储（多次）</span></span><br><span class="line">jstack -l &lt;pid&gt; &gt; /tmp/threads-1.txt</span><br><span class="line"><span class="built_in">sleep</span> 5</span><br><span class="line">jstack -l &lt;pid&gt; &gt; /tmp/threads-2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆对象统计（按类）</span></span><br><span class="line">jmap -histo:live &lt;pid&gt; &gt; /tmp/histo.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出堆快照（谨慎）</span></span><br><span class="line">jcmd &lt;pid&gt; GC.heap_dump /tmp/heap-$(<span class="built_in">date</span> +%s).hprof</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 GC stats（实时）</span></span><br><span class="line">jstat -gc &lt;pid&gt; 1000 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 native memory（需 NMT 启动）</span></span><br><span class="line">jcmd &lt;pid&gt; VM.native_memory summary</span><br></pre></td></tr></table></figure><p><strong>生产注意事项</strong></p><ul><li>堆 dump、jmap 等可能引起停顿并占用额外磁盘&#x2F;内存；在高可用场景下先流量降级或在副本上运行诊断。</li><li>建议在生产环境启用可控 GC 日志（并定期轮转）与 JMX 暴露指标，结合监控平台（Prometheus&#x2F;Grafana）和 APM（比如 Pinpoint, SkyWalking）做长期趋势分析。</li><li>使用 <code>jcmd</code> 的命令集优于老旧 <code>jmap/jstack</code> 功能更强，且适配新 JVM。</li></ul><hr><h4 id="总结与推荐（面试与线上实战要点）"><a href="#总结与推荐（面试与线上实战要点）" class="headerlink" title="总结与推荐（面试与线上实战要点）"></a>总结与推荐（面试与线上实战要点）</h4><ul><li><strong>理解内存模型</strong> 是定位 OOM、内存泄漏与调优 GC 的基础（知道对象在哪、什么时候晋升、元空间的影响）。</li><li><strong>分代策略</strong> 解释了为什么年轻代短 GC（复制）与老年代不同（标记&#x2F;清理&#x2F;整理）。</li><li><strong>CMS 与 G1 的差异</strong>：CMS 低停顿但易碎片；G1 更适合大堆与可控停顿，企业建议以 G1 为首选（或在更低停顿需求下考虑 ZGC&#x2F;Shenandoah）。</li><li><strong>线上诊断</strong>：熟练使用 <code>jstack</code>, <code>jcmd</code>, <code>jmap</code>, <code>jstat</code>，并结合 GC 日志与堆分析工具（MAT &#x2F; async-profiler）是工程师必备能力。</li><li><strong>工程实践</strong>：默认把 <code>Xms=Xmx</code>、启用 GC 日志（统一日志 <code>-Xlog</code>），避免 System.gc，监控元空间与直接内存，做好容器&#x2F;VM 限制适配（cgroup-aware flags）。</li></ul><h3 id="11）常见OOM（内存溢出）"><a href="#11）常见OOM（内存溢出）" class="headerlink" title="11）常见OOM（内存溢出）"></a>11）常见OOM（内存溢出）</h3><h4 id="1-Java-堆内存溢出（Java-heap-space）"><a href="#1-Java-堆内存溢出（Java-heap-space）" class="headerlink" title="1. Java 堆内存溢出（Java heap space）"></a>1. <strong>Java 堆内存溢出（Java heap space）</strong></h4><ul><li><strong>原理</strong>：<br> Java 堆用来存放对象实例，当不断创建新对象且 GC 无法回收时，就会导致堆空间耗尽。</li><li><strong>常见场景</strong>：<ul><li>集合类（如 <code>List/Map</code>）中存放了大量对象但未释放（内存泄漏）。</li><li>无限循环创建新对象。</li><li>缓存设计不合理（未设置过期策略）。</li></ul></li><li><strong>排查方式</strong>：<ul><li><code>jmap -heap &lt;pid&gt;</code> 查看堆内存使用情况。</li><li><code>jmap -histo &lt;pid&gt;</code> 查看对象数量分布。</li><li><code>MAT</code> (Memory Analyzer Tool) 分析堆 dump。</li></ul></li><li><strong>解决方案</strong>：<ul><li>优化代码，避免内存泄漏。</li><li>增加 JVM 堆内存：<code>-Xmx</code>。</li><li>引入缓存淘汰策略（LRU、TTL）。</li></ul></li></ul><hr><h4 id="2-GC-overhead-limit-exceeded"><a href="#2-GC-overhead-limit-exceeded" class="headerlink" title="2. GC overhead limit exceeded"></a>2. <strong>GC overhead limit exceeded</strong></h4><ul><li><strong>原理</strong>：<br> GC 占用过多时间但回收效果极差（例如 98% 的时间在 GC，回收的内存却小于 2%）。</li><li><strong>常见场景</strong>：<ul><li>内存几乎被占满，不断发生 Minor&#x2F;Full GC。</li><li>内存泄漏导致垃圾对象无法被回收。</li></ul></li><li><strong>排查方式</strong>：<ul><li>查看 GC 日志 (<code>-XX:+PrintGCDetails</code>)。</li><li>检查是否有大对象频繁分配。</li></ul></li><li><strong>解决方案</strong>：<ul><li>优化代码，减少对象频繁创建。</li><li>调整堆大小。</li><li>排查内存泄漏。</li></ul></li></ul><hr><h4 id="3-Metaspace-OOM（PermGen-OOM，Java-8-之前叫-PermGen-space）"><a href="#3-Metaspace-OOM（PermGen-OOM，Java-8-之前叫-PermGen-space）" class="headerlink" title="3. Metaspace OOM（PermGen OOM，Java 8 之前叫 PermGen space）"></a>3. <strong>Metaspace OOM（PermGen OOM，Java 8 之前叫 PermGen space）</strong></h4><ul><li><strong>原理</strong>：<br> Metaspace（元空间）用于存放类的元数据、方法区信息。若动态生成过多类，或者类加载器泄漏，元空间会被占满。</li><li><strong>常见场景</strong>：<ul><li>大量反射、动态代理。</li><li>应用频繁部署但类卸载失败（Tomcat 热部署）。</li><li>框架生成过多字节码（如 CGLIB、Javassist）。</li></ul></li><li><strong>排查方式</strong>：<ul><li><code>jmap -clstats &lt;pid&gt;</code> 查看类加载信息。</li><li>Dump 分析哪些类加载器没有释放。</li></ul></li><li><strong>解决方案</strong>：<ul><li>增加 <code>-XX:MaxMetaspaceSize</code>。</li><li>避免频繁动态生成类。</li><li>修复类加载器泄漏问题。</li></ul></li></ul><hr><h4 id="4-Direct-Buffer-Memory-OOM"><a href="#4-Direct-Buffer-Memory-OOM" class="headerlink" title="4. Direct Buffer Memory OOM"></a>4. <strong>Direct Buffer Memory OOM</strong></h4><ul><li><strong>原理</strong>：<br> NIO 的 <code>ByteBuffer.allocateDirect</code> 会申请堆外内存，若申请过多超过 <code>-XX:MaxDirectMemorySize</code> 限制，就会 OOM。</li><li><strong>常见场景</strong>：<ul><li>Netty、大量使用 NIO。</li><li>文件&#x2F;网络缓冲区分配不当。</li></ul></li><li><strong>排查方式</strong>：<ul><li>观察是否有 DirectByteBuffer 未释放。</li><li><code>jconsole</code> &#x2F; <code>Arthas</code> 监控。</li></ul></li><li><strong>解决方案</strong>：<ul><li>显式调用 <code>ByteBuffer.cleaner()</code> 释放堆外内存（JDK9+ 自动管理）。</li><li>合理配置 <code>-XX:MaxDirectMemorySize</code>。</li><li>避免频繁分配大块堆外内存。</li></ul></li></ul><hr><h4 id="5-unable-to-create-new-native-thread"><a href="#5-unable-to-create-new-native-thread" class="headerlink" title="5. unable to create new native thread"></a>5. <strong>unable to create new native thread</strong></h4><ul><li><p><strong>原理</strong>：</p><p> JVM 进程申请新线程时，需要操作系统分配本地内存栈。如果线程数过多，系统资源耗尽，就会报错。</p></li><li><p><strong>常见场景</strong>：</p><ul><li>创建了大量线程（如线程池配置不合理）。</li><li>每个线程栈内存（<code>-Xss</code>）过大。</li></ul></li><li><p><strong>排查方式</strong>：</p><ul><li><code>top -H -p &lt;pid&gt;</code> 查看线程数。</li><li><code>jstack</code> 打印线程堆栈。</li></ul></li><li><p><strong>解决方案</strong>：</p><ul><li>使用线程池控制线程数量。</li><li>降低 <code>-Xss</code> 设置，减少每个线程的栈空间。</li><li>使用异步或事件驱动模型代替大量线程。</li></ul></li></ul><hr><h4 id="6-StackOverflowError"><a href="#6-StackOverflowError" class="headerlink" title="6. StackOverflowError"></a>6. <strong>StackOverflowError</strong></h4><ul><li><strong>原理</strong>：<br> 方法调用层级过深，导致线程栈内存溢出。</li><li><strong>常见场景</strong>：<ul><li>无限递归调用。</li><li>方法嵌套过深。</li></ul></li><li><strong>排查方式</strong>：<ul><li>查看异常堆栈。</li><li>检查递归出口条件。</li></ul></li><li><strong>解决方案</strong>：<ul><li>修复递归逻辑。</li><li>调整栈大小：<code>-Xss</code>。</li></ul></li></ul><hr><h4 id="7-OOM-Map-Failed"><a href="#7-OOM-Map-Failed" class="headerlink" title="7. OOM: Map Failed"></a>7. <strong>OOM: Map Failed</strong></h4><ul><li><strong>原理</strong>：<br> 堆外内存（mmap 文件映射）申请失败。</li><li><strong>常见场景</strong>：<ul><li>大文件映射（<code>MappedByteBuffer</code>）。</li><li>系统虚拟内存不足。</li></ul></li><li><strong>排查方式</strong>：<ul><li>查看 OS 虚拟内存使用情况。</li></ul></li><li><strong>解决方案</strong>：<ul><li>使用流式 IO 替代全量映射。</li><li>增加虚拟内存。</li></ul></li></ul><hr><h4 id="🔍-总结面试高频考点"><a href="#🔍-总结面试高频考点" class="headerlink" title="🔍 总结面试高频考点"></a>🔍 总结面试高频考点</h4><ol><li><strong>堆内存溢出</strong>（最常考）</li><li><strong>GC overhead limit exceeded</strong></li><li><strong>Metaspace OOM（类加载相关）</strong></li><li><strong>Direct buffer memory OOM（堆外内存）</strong></li><li><strong>unable to create new native thread（线程数过多）</strong></li><li><strong>StackOverflowError（递归）</strong></li></ol><hr><h2 id="Redis-牛客面经八股"><a href="#Redis-牛客面经八股" class="headerlink" title="Redis-牛客面经八股"></a>Redis-牛客面经八股</h2><h3 id="1-Redis-的数据类型"><a href="#1-Redis-的数据类型" class="headerlink" title="1. Redis 的数据类型"></a>1. Redis 的数据类型</h3><p>Redis 提供多种内建数据类型与高级数据结构（模块除外）：</p><ol><li><strong>String</strong><ul><li>二进制安全，最大可达 512MB。</li><li>用途：缓存、计数器、序列化对象、分布式限流&#x2F;锁等。</li></ul></li><li><strong>List</strong><ul><li>双端链表（old impl）→ 现在是 <strong>quicklist</strong>（ziplist&#x2F;listpack + linked list 的混合实现）。</li><li>支持 <code>LPUSH/RPUSH</code>、<code>LPOP/RPOP</code>、<code>LRANGE</code> 等，适合消息队列（阻塞 <code>BLPOP</code>）。</li></ul></li><li><strong>Set</strong><ul><li>无序集合，内部用哈希表实现。</li><li>支持集合运算 <code>SINTER/SUNION/SDIFF</code>。</li></ul></li><li><strong>Sorted Set (ZSet)</strong><ul><li>有序集合：每个 member 有一个 score，支持按 score 排序。</li><li>内部实现：<strong>跳表 (skiplist)</strong> + <strong>哈希表(dict)</strong>（hash: member→score；skiplist 用于按 score 快速范围查询）。</li></ul></li><li><strong>Hash</strong><ul><li>字段集合（类似小型对象 &#x2F; map）。</li><li>小 hash 使用紧凑编码（ziplist &#x2F; listpack）；大 hash 使用哈希表。</li></ul></li><li><strong>Bitmap</strong><ul><li>用 String 的位操作实现（<code>SETBIT/GETBIT/BITCOUNT/BITOP</code>）。常用于海量用户标记、UV&#x2F;活跃用户统计（配合 bitset）。</li></ul></li><li><strong>HyperLogLog</strong><ul><li>基数估算（基于概率，固定内存 ~ 12KB），用于 UV 去重估算（<code>PFADD</code>, <code>PFCOUNT</code>）。</li></ul></li><li><strong>Stream</strong><ul><li>Redis Streams（日志式数据结构）支持 append-only 记录、ID、Consumer Groups（可靠消费、ACK、pending）、适合消息队列&#x2F;事件流。</li><li>内部：<strong>rax（radix tree）</strong> 映射 ID-&gt;listpack，entry 存于 listpack（紧凑结构）。</li></ul></li><li><strong>Geo</strong><ul><li>基于 Sorted Set 的地理位置 API（<code>GEOADD/GEORADIUS</code>），score 存编码后的经纬度。</li></ul></li><li><strong>Modules</strong><ul><li>可以通过模块增加类型（RedisJSON、RedisTimeSeries、RediSearch 等）。</li></ul></li></ol><p><strong>工程要点</strong></p><ul><li>小集合尽量利用紧凑编码（减少内存），但超过阈值会切换成普通哈希&#x2F;zip 切换（可通过配置调整阈值）。</li><li>用正确类型匹配场景：排行榜用 ZSet；计数器与短字符串用 String；High-cardinality 用 HyperLogLog。</li></ul><hr><h3 id="2-Redis-单线程架构（详解-现代补充）"><a href="#2-Redis-单线程架构（详解-现代补充）" class="headerlink" title="2. Redis 单线程架构（详解 + 现代补充）"></a>2. Redis 单线程架构（详解 + 现代补充）</h3><p><strong>核心点</strong></p><ul><li>Redis 在命令的<strong>解析与执行</strong>上是<strong>单线程</strong>的：所有命令的逻辑执行（读写内存、更新数据结构）都在主线程顺序执行，这带来两个重要效果：<ul><li>简化并发控制：无需对象级锁，避免竞态与复杂锁逻辑。</li><li>单个请求执行不会被其它命令打断（除非调用阻塞或 fork 等）。</li></ul></li><li><strong>I&#x2F;O 多路复用</strong>：单线程用 <code>epoll</code> &#x2F; <code>kqueue</code> &#x2F; <code>select</code> 等事件机制处理网络连接（read&#x2F;write 的 readiness）。常见实现为 <code>ae</code> 事件库。</li><li><strong>耗时&#x2F;阻塞操作处理</strong>：<ul><li>持久化操作（RDB save、AOF rewrite）通过 <strong>fork 子进程</strong> 在后台做，子进程写文件；父进程继续服务（写入过程会 copy-on-write 增加内存）。</li><li>从 Redis 6 开始，引入了<strong>I&#x2F;O 线程（networking threads）</strong> 可选地并行处理 socket read&#x2F;write（把网络 IO 的读写解包&#x2F;组包放到 IO 线程），但命令执行仍在主线程；这可以提升高并发小命令场景下的吞吐。</li><li>Redis 也可能使用后台线程做某些任务（例如 RDB&#x2F;AOF rewrite、lazy free、lazy migration 等），但数据结构修改仍是单线程保证原子。</li></ul></li></ul><p><strong>优缺点</strong></p><ul><li>优点：实现简单、命令原子性强、易预测。</li><li>缺点：单线程 CPU 瓶颈（但实际 Redis 单命令耗时很短、并可以用多实例&#x2F;分片&#x2F;Cluster 横向扩展）。</li></ul><hr><h3 id="3-Redis-的持久化策略（RDB-AOF-混合）"><a href="#3-Redis-的持久化策略（RDB-AOF-混合）" class="headerlink" title="3. Redis 的持久化策略（RDB &#x2F; AOF &#x2F; 混合）"></a>3. Redis 的持久化策略（RDB &#x2F; AOF &#x2F; 混合）</h3><ol><li><strong>RDB（快照）</strong><ul><li><code>SAVE</code>&#x2F;<code>BGSAVE</code> 生成数据集快照（RDB 文件）。</li><li>优点：文件紧凑、恢复速度快、对 Redis 运行影响小（BGSAVE 使用 fork，父进程继续服务）。</li><li>缺点：可能丢失自上次快照以来的写（数据不够实时）；fork 时内存复制（写时复制）会消耗内存。</li></ul></li><li><strong>AOF（Append Only File）</strong><ul><li>将写命令追加到文件（每条命令的 Redis 协议表示）。</li><li>持久化策略（fsync）：<ul><li><code>always</code>（每次命令 fsync）——最安全但最慢；</li><li><code>everysec</code>（默认）——每秒 fsync，一致性稍弱，但性能好；</li><li><code>no</code>（操作系统决定）——最快但最不安全。</li></ul></li><li>AOF 支持重写（rewrite）来压缩历史命令（生成紧凑的 AOF），这个过程在后台 <code>bgrewriteaof</code> 实现。</li><li>优点：更小的数据丢失窗口，恢复时以 AOF 重演命令（可设置 <code>no-appendfsync-on-rewrite</code>）。</li><li>缺点：文件大、重写会开销大，恢复速度比 RDB 慢（但可配置重写和重写压缩）。</li></ul></li><li><strong>RDB + AOF</strong><ul><li>你可以同时开启 RDB 与 AOF；常见做法：以 RDB 为主备份、AOF 提升数据安全性。也可在 AOF 重写和 RDB 快照间做权衡。</li></ul></li><li><strong>持久化选型建议</strong><ul><li>对可接受少量数据丢失（例如缓存）可只用 RDB 或关闭持久化；</li><li>要求高可靠性和最小数据丢失 → AOF (<code>everysec</code>)+定期 RDB 快照；</li><li>生产上通常开 AOF everysec，并同时配置 RDB 作为备份点。</li></ul></li></ol><hr><h3 id="4-Redis-的缓存淘汰策略（maxmemory-policy）"><a href="#4-Redis-的缓存淘汰策略（maxmemory-policy）" class="headerlink" title="4. Redis 的缓存淘汰策略（maxmemory-policy）"></a>4. Redis 的缓存淘汰策略（maxmemory-policy）</h3><p>当达到 <code>maxmemory</code> 限制时，根据 <code>maxmemory-policy</code> 采取淘汰：</p><ul><li><code>noeviction</code>：不淘汰，写操作返回错误（默认）。</li><li><code>allkeys-lru</code>：对所有 key 使用 LRU（近似实现）。</li><li><code>volatile-lru</code>：对设置了 TTL 的 key 使用 LRU。</li><li><code>allkeys-lfu</code>：LFU（频度）算法。</li><li><code>volatile-lfu</code>：对有 TTL 的 key 使用 LFU。</li><li><code>allkeys-random</code> &#x2F; <code>volatile-random</code>：随机淘汰。</li><li><code>volatile-ttl</code>：优先淘汰 TTL 更短的 key。</li></ul><p><strong>实现细节</strong></p><ul><li>Redis 的 LRU&#x2F;LFU 都是<strong>近似实现</strong>，采用采样和时间戳&#x2F;频率计数的方式（不是精确维护全局 LRU 双链表，以节省内存开销）。</li><li>LFU 采用一个小计数器并周期性衰减（防止旧热点一直占用）。</li></ul><p><strong>工程建议</strong></p><ul><li>选择 <code>allkeys-lfu</code> 可在热点稳定时取得较好效果，但注意对不同 workload 的适配。</li><li>对数据重要性不同的 key 可设置 TTL（结合 <code>volatile-*</code> 策略）。</li><li>监控 <code>maxmemory</code>、evicted_keys、used_memory_policy 等指标。</li></ul><hr><h3 id="5-Redis-高可用实现（主从-Sentinel-Cluster-third-party）"><a href="#5-Redis-高可用实现（主从-Sentinel-Cluster-third-party）" class="headerlink" title="5. Redis 高可用实现（主从 + Sentinel &#x2F; Cluster &#x2F; third-party）"></a>5. Redis 高可用实现（主从 + Sentinel &#x2F; Cluster &#x2F; third-party）</h3><ol><li><strong>主从复制 + Sentinel（自动故障转移）</strong><ul><li><strong>复制</strong>：主（master）将写操作通过异步复制到从（replica）。从可以做读操作（读写分离）。</li><li><strong>Sentinel</strong>：监控 master 和 replicas，自动故障检测与选举（当 master 挂掉时，Sentinel 会选举新的 master 并通知客户端或客户端重试）。</li><li>优点：成熟、简单；缺点：异步复制可能丢失主未同步到 replica 的数据（数据丢失风险）。</li></ul></li><li><strong>Redis Cluster</strong><ul><li>内置分片与高可用：将 key 空间划分成 <strong>16384 hash slots</strong>，多个 master 分布这些 slot，每个 master 可以有多个 replica。</li><li>客户端通过 MOVED&#x2F;ASK 重定向与 cluster topology 通讯；自动故障转移由 cluster 协议处理（基于投票）。</li><li>优点：水平扩展（sharding） + 高可用；缺点：跨 slot 的 multi-key 操作有限制（需要放在同 slot，或者使用 hash tag）。</li></ul></li><li><strong>数据一致性 &amp; 可用性权衡</strong><ul><li>默认复制是异步（主进写时不会阻塞等待 replica ack），可能数据丢失。可以用 <code>WAIT</code> 命令等待 master 把写传播到 N 个 replicas。</li><li>对强一致性要求高的场景，建议使用外部一致性系统（ZooKeeper&#x2F;etcd）或 Redis-on-Raft 实现（例如 RedisRaft、Dragonfly 堆栈等）。</li></ul></li><li><strong>工程实践</strong><ul><li>使用 Sentinel 时确保多个 Sentinel 分布在不同机器&#x2F;可用区。</li><li>使用 Cluster 时确保键划分合理，避免跨 slot 多键事务。</li><li>备份策略 + 监控 + 自动报警必不可少。</li></ul></li></ol><hr><h3 id="6-利用-Redis-实现分布式锁（正确方式与注意）"><a href="#6-利用-Redis-实现分布式锁（正确方式与注意）" class="headerlink" title="6. 利用 Redis 实现分布式锁（正确方式与注意）"></a>6. 利用 Redis 实现分布式锁（正确方式与注意）</h3><p><strong>最常见的简单实现</strong></p><ul><li>取得锁：<code>SET lockKey token NX PX 30000</code><ul><li>NX：仅当键不存在时设置（原子），PX：过期时间（毫秒）</li><li><code>token</code> 用唯一值（UUID），用于后续释放判断所有权。</li></ul></li><li>释放锁（必须先校验 token，再 DEL）要原子执行，建议用 Lua：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- release.lua</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;GET&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&quot;DEL&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>调用：<code>EVALSHA sha1 1 lockKey token</code></p><p><strong>Redlock（多实例分布式锁，Antirez 提出）</strong></p><ul><li>在多个独立 Redis 实例上分别尝试获取锁（SET NX PX），在大多数实例成功（例如 3&#x2F;5）视为获得锁。加锁与释放需在最短时间内完成以避免时钟不同步、网络延迟问题。</li><li><strong>争议</strong>：Redlock 在网络分区与异步复制场景下的安全性有争议；某些专家认为它不满足强一致性的分布式锁需求。使用前要评估需求。</li></ul><p><strong>工程建议</strong></p><ul><li>对强一致性要求较高的分布式锁场景（例如分布式协调&#x2F;leader election），建议使用专门的一致性系统（ZooKeeper&#x2F;etcd）或使用 Redis Raft。</li><li>使用 Redis 做锁时请保证：<ul><li>设置合理的过期时间（避免死锁），</li><li>释放锁时校验 token（防止误删别人的锁），</li><li>对长时间执行的任务可用续租机制（延长过期），但续租也要很小心（线程崩溃导致续租失败）。</li></ul></li><li>注意 Redis 单实例的复制延迟会带来风险；最好配合 <code>WAIT</code> 或使用 <code>SET</code> NX PX 在主节点直接获得。</li></ul><hr><h3 id="7-Redis-怎么实现延时消息"><a href="#7-Redis-怎么实现延时消息" class="headerlink" title="7. Redis 怎么实现延时消息"></a>7. Redis 怎么实现延时消息</h3><p><strong>常见实现 1 — Sorted Set（延时队列）</strong></p><ul><li>用 <code>ZADD delayQueue score=timestamp member=payloadId</code>（score 为可处理时间）。</li><li>消费者轮询：<ol><li><code>ZRANGEBYSCORE delayQueue -inf now LIMIT 0 1</code> 得到到期条目 id。</li><li>尝试用 Lua 原子地 <code>ZREM</code> 并把 payload 推到处理队列（或直接处理）。</li></ol></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- pop_due.lua</span></span><br><span class="line"><span class="keyword">local</span> zkey = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> items = redis.call(<span class="string">&quot;ZRANGEBYSCORE&quot;</span>, zkey, <span class="string">&quot;-inf&quot;</span>, now, <span class="string">&quot;LIMIT&quot;</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> #items == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> item = items[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> removed = redis.call(<span class="string">&quot;ZREM&quot;</span>, zkey, item)</span><br><span class="line"><span class="keyword">if</span> removed == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure><ul><li>优点：实现简单，顺序可控。</li><li>缺点：轮询成本（可用 <code>BRPOPLPUSH</code> 与 list 组合或在消费端做 sleep&#x2F;backoff），并发时要用 Lua 保证原子移除。</li></ul><p><strong>常见实现 2 — 使用 Streams + consumer groups</strong></p><ul><li>将消息写入 streams，携带 <code>deliver_at</code> 字段，消费者检查 <code>deliver_at</code> 并在到期时处理（或使用 XAUTOCLAIM &#x2F; XCLAIM 来抢占未 ACK 的消息）。</li><li>Streams 提供 ACK、PENDING、重试功能，比 ZSet 更适合可靠消费&#x2F;重试场景。</li></ul><p><strong>工程建议</strong></p><ul><li>如果需要精确的延时（毫秒级）并发处理，使用专门消息队列（Kafka&#x2F; Pulsar &#x2F; RabbitMQ + delayed plugin）可能更稳健。</li><li>Redis 实现适合中等规模的延时任务和简单可靠性场景；要考虑并发锁与去重、一定的重复消费&#x2F;幂等处理。</li></ul><hr><h3 id="8-Redis-中的-String-是怎么实现的？"><a href="#8-Redis-中的-String-是怎么实现的？" class="headerlink" title="8. Redis 中的 String 是怎么实现的？"></a>8. Redis 中的 String 是怎么实现的？</h3><p><strong>SDS（Simple Dynamic String）</strong></p><ul><li>Redis <code>String</code> 的底层使用 <strong>SDS</strong> 而不是 C 的 NUL-terminated <code>char*</code>。SDS 提供：<ul><li>二进制安全（可以包含 <code>\0</code>）；</li><li>存储长度（O(1) 获取），避免每次 <code>strlen</code>；</li><li>预留空间（free 字段），减少重复 realloc。</li></ul></li><li><strong>Object encoding</strong>：<ul><li><strong>RAW</strong>：标准 SDS 存储。</li><li><strong>EMBSTR</strong>：当字符串短时，将 SDS 与 Redis 对象 header 一起分配在一个内存块（减少内存碎片、提升效率）。</li><li><strong>INT</strong>：对于纯数字字符串，Redis 可以把对象以 long long int 存储为整数编码以节约空间&#x2F;加速。</li></ul></li><li><strong>指令语义</strong>：<code>SET</code>&#x2F;<code>GET</code>&#x2F;<code>INCR</code>&#x2F;<code>APPEND</code> 等直接操作 SDS。</li></ul><hr><h3 id="9-Redis-中-ZSet（有序集合）怎么实现的？"><a href="#9-Redis-中-ZSet（有序集合）怎么实现的？" class="headerlink" title="9. Redis 中 ZSet（有序集合）怎么实现的？"></a>9. Redis 中 ZSet（有序集合）怎么实现的？</h3><p><strong>双结构实现</strong></p><ul><li><strong>跳表（skiplist）</strong>：按 score 排序，支持按 score 范围查询、分页、顺序遍历。skiplist 使得范围查询与插入复杂度 O(log N)。</li><li><strong>哈希表（dict）</strong>：<code>member -&gt; score</code> 映射，用于 O(1) 校验 member 是否存在 &amp; 直接更新 score。</li><li>操作流程：<ul><li><code>ZADD</code>：先在 dict 看是否存在 member：若存在则更新跳表（先删除旧 score 再插入新 score）；否则新插入到 dict 且插入跳表。</li><li><code>ZRANGE</code> &#x2F; <code>ZRANGEBYSCORE</code>：跳表定位起点，然后按链表遍历返回 M 个元素（复杂度 O(log N + M)）。</li></ul></li><li><strong>优势</strong>：结合哈希表及跳表兼顾了 O(1) 查找与 O(log N) 排序操作。</li></ul><hr><h3 id="10-使用-Redis-实现排行榜（Leaderboard）"><a href="#10-使用-Redis-实现排行榜（Leaderboard）" class="headerlink" title="10. 使用 Redis 实现排行榜（Leaderboard）"></a>10. 使用 Redis 实现排行榜（Leaderboard）</h3><p><strong>Simple（单实例）</strong></p><ul><li>使用 ZSet，member&#x3D;用户ID，score&#x3D;分值。<ul><li>加分&#x2F;设置分数：<code>ZINCRBY leaderboard delta userId</code> 或 <code>ZADD leaderboard score userId</code></li><li>获取排名（倒序，分值高为第一）：<code>ZREVRANK leaderboard userId</code>（返回索引，从0开始）</li><li>获取 top N：<code>ZREVRANGE leaderboard 0 N-1 WITHSCORES</code></li><li>获取范围分页：<code>ZREVRANGE leaderboard start stop WITHSCORES</code></li></ul></li><li>注意分数精度：Redis score 是 double 浮点；若需要精确整数，直接存整数或把分数放大（乘 100）存为 double。</li></ul><p><strong>带用户信息</strong></p><ul><li>存分数在 ZSet，用户详情放 in Hash <code>user:userid</code>。</li><li>在返回 top N 时 <code>ZREVRANGE ... WITHSCORES</code> 得到 ids，再批量 <code>HMGET</code> 拉取信息（pipeline）。</li></ul><p><strong>并发&#x2F;多实例&#x2F;集群</strong></p><ul><li>在 Cluster 模式确保访问同一 key（slot）或者使用客户端支持跨 slot 聚合。</li><li>若写入非常频繁并导致单点瓶颈，可考虑分片或以时间段为单位分 ZSet 再合并（复杂）。</li></ul><p><strong>大规模与历史榜</strong></p><ul><li>使用 time-windowed sorted sets（例如按日&#x2F;周&#x2F;月 leaderboard）来实现历史和滚动排名。</li></ul><hr><h3 id="11-用-Redis-实现注册中心（Service-Registry）"><a href="#11-用-Redis-实现注册中心（Service-Registry）" class="headerlink" title="11. 用 Redis 实现注册中心（Service Registry）"></a>11. 用 Redis 实现注册中心（Service Registry）</h3><p><strong>思路（轻量）</strong></p><ul><li>每个服务实例启动时 <code>SET service:&#123;name&#125;:&#123;instanceId&#125; metadata NX PX heartbeatInterval*...</code> 或 <code>HSET service:&#123;name&#125; &#123;instanceId&#125; metadata</code> 并配合 <code>EXPIRE</code> 或定时续租心跳。</li><li>客户端注册：<code>SET</code> 或 <code>HSET</code> + TTL，每隔 <code>t</code> 秒心跳延长 TTL（或重新 <code>SET</code>）。</li><li>服务发现：客户端查询 <code>SCAN</code>&#x2F;<code>KEYS service:&#123;name&#125;*</code> 或使用 <code>SMEMBERS services:&#123;name&#125;</code>（如果用集合管理）。</li><li>监听变更：使用 Pub&#x2F;Sub 或 Redis Stream 发布 <code>service-up</code> &#x2F; <code>service-down</code> 事件；或者消费者轮询 TTL 变化。</li></ul><p><strong>优点&#x2F;缺点</strong></p><ul><li>优点：简单、延迟低。</li><li>缺点：<ul><li>Redis 仍是单点（需 Sentinel&#x2F;Cluster 做 HA），</li><li>对于强一致性（leader 选举、分布式锁）不如 ZooKeeper&#x2F;etcd 可靠（但可做）。</li></ul></li><li><strong>改进</strong>：使用 Redis + Sentinel&#x2F;Cluster + 客户端缓存 + watch&#x2F;notify 来降低读延时与感知延迟。</li></ul><hr><h3 id="12-Redis-的线程模型"><a href="#12-Redis-的线程模型" class="headerlink" title="12. Redis 的线程模型"></a>12. Redis 的线程模型</h3><ul><li>单主线程处理命令（event-loop），I&#x2F;O 多路复用。</li><li>背景线程&#x2F;进程：<ul><li><strong>子进程 fork</strong>：RDB 保存与 AOF rewrite 用 fork 的子进程做 IO 操作；</li><li><strong>后台线程</strong>（某些版本）用于异步删除（lazyfree）、部分模块、RDB&#x2F;AOF rewrite 辅助；</li><li><strong>I&#x2F;O 线程</strong>（自 Redis 6 起）可并行化 socket read&#x2F;write，但命令处理仍在主线程。</li></ul></li><li>写时复制（COW）在 fork 时会复制页面，可能导致内存短期上涨。</li><li>因为命令执行单线程，所以任何阻塞式命令或慢命令（例如 <code>KEYS</code>、大 <code>SORT</code>、遍历超大集合）会阻塞整个服务。要避免这些慢命令或使用 <code>SCAN</code> &#x2F; <code>SSCAN</code> &#x2F; <code>ZSCAN</code> &#x2F; <code>HSCAN</code> 做渐进式遍历。</li></ul><hr><h3 id="13-Redis-的事务（MULTI-EXEC-WATCH）"><a href="#13-Redis-的事务（MULTI-EXEC-WATCH）" class="headerlink" title="13. Redis 的事务（MULTI&#x2F;EXEC&#x2F;WATCH）"></a>13. Redis 的事务（MULTI&#x2F;EXEC&#x2F;WATCH）</h3><ul><li><strong>MULTI &#x2F; EXEC &#x2F; DISCARD</strong><ul><li><code>MULTI</code> 开始事务（只是命令排队）。</li><li>客户端在 <code>EXEC</code> 时，队列中的命令会被一次性执行（单线程原子性：中间不会被其他命令插入），但 <strong>如果命令内部失败，事务不会回滚</strong>，失败的只是那条命令。</li></ul></li><li><strong>WATCH</strong>（乐观锁）<ul><li><code>WATCH key1 key2</code> 监视 key，如果在 <code>EXEC</code> 前这些 key 被其他客户端改动，则 <code>EXEC</code> 返回 null，事务失败（可重试）。</li><li><code>UNWATCH</code> 取消监视。</li></ul></li><li><strong>局限</strong><ul><li>Redis 事务不是关系型数据库意义上的事务（没有隔离级别、没有回滚机制）；只是命令批量的“原子提交”。</li><li>在 Cluster 上，MULTI&#x2F;EXEC 要求所有 key 属于同一 hash slot（否则会报错）。</li></ul></li><li><strong>替代</strong>：Lua 脚本（EVAL）在 Redis 中是原子执行、能做复杂原子操作、支持返回值；在多数场景下比 MULTI 更强大与安全。</li></ul><hr><h3 id="14-Redis-IO-多路复用模型（实现细节）"><a href="#14-Redis-IO-多路复用模型（实现细节）" class="headerlink" title="14. Redis IO 多路复用模型（实现细节）"></a>14. Redis IO 多路复用模型（实现细节）</h3><ul><li>使用 <code>ae</code> 事件库封装系统调用：<code>select</code> &#x2F; <code>poll</code> &#x2F; <code>epoll</code> &#x2F; <code>kqueue</code>。在 Linux 下主要使用 <code>epoll</code>。</li><li>事件循环做两件事：处理读&#x2F;写&#x2F;accept 等事件 &amp; 执行命令。网络读到完整请求后放到客户端上下文，主线程解析命令并执行。</li><li>Redis 采用<strong>非阻塞 IO</strong>与事件驱动来实现高并发连接处理。</li></ul><hr><h3 id="15-Redis-的大-key（big-key）以及原因"><a href="#15-Redis-的大-key（big-key）以及原因" class="headerlink" title="15. Redis 的大 key（big key）以及原因"></a>15. Redis 的大 key（big key）以及原因</h3><p><strong>什么是大 key</strong></p><ul><li>指一个 key 本身内部的数据量很大（如一个包含数百万元素的 list&#x2F;hash&#x2F;zset 或非常大的 string），导致对该 key 的任何操作都很耗时且可能阻塞服务。</li></ul><p><strong>为什么产生</strong></p><ul><li>不合理的数据模型（把太多用户或日志塞入单个 list&#x2F;hash）。</li><li>未分片或未分块地存储大量数据（例如把百万级别日志存在一个 list）。</li><li>忽用 <code>KEYS</code> &#x2F; <code>SMEMBERS</code> 等一次性返回全量接口。</li></ul><p><strong>问题</strong></p><ul><li>操作该 key（如 <code>LRANGE</code>、<code>DEL</code>、<code>HGETALL</code>）将占用大量 CPU &#x2F; 内存并可能阻塞主线程，导致延迟飙升。</li><li><code>DEL</code> 可能会阻塞；现代 Redis 有 <code>UNLINK</code>（异步删除后台释放内存）来缓解。</li></ul><p><strong>检测大 key</strong></p><ul><li><code>redis-cli --bigkeys</code>（工具）会扫描样本并报告大 key。</li><li><code>MEMORY USAGE key</code> 查看内存占用。</li><li><code>DEBUG OBJECT key</code>（谨慎）或 <code>OBJECT encoding key</code> 查看编码&#x2F;结构。</li></ul><p><strong>对策</strong></p><ul><li>设计分片，比如把单个 list 分成为 <code>list:YYYYMMDD:shardId</code>。</li><li>使用流（Streams）或外部存储（对象存储）分离非常大的二进制数据。</li><li>使用 <code>UNLINK</code> 替代 <code>DEL</code> 做异步删除。</li><li>避免一次性全量操作，使用 <code>SCAN/SSCAN/ZSCAN/HSCAN</code> 进行增量遍历。</li></ul><hr><h3 id="16-Redis-的集群模式（工作原理）"><a href="#16-Redis-的集群模式（工作原理）" class="headerlink" title="16. Redis 的集群模式（工作原理）"></a>16. Redis 的集群模式（工作原理）</h3><p><strong>核心概念</strong></p><ul><li>将 key 空间分为 <strong>16384 slots</strong>，每个 master 负责若干 slot。</li><li><strong>节点角色</strong>：master + optional replicas（replica 用于 failover）。</li><li><strong>重定向</strong>：客户端访问非本节点的 slot 会收到 <code>MOVED</code>（静态重定位）或 <code>ASK</code>（重分配临时重定向）。</li><li><strong>数据迁移（resharding）</strong>：通过 <code>MIGRATE</code> 或 <code>CLUSTER</code> 命令把 slot 从一个节点迁到另一个节点（期间会产生 <code>ASK</code> 临时指令）。</li><li><strong>故障转移</strong>：<ul><li>Cluster 各节点通过 gossip 协议互相通告状态，若 master 挂掉且多数 replicas 同意（based on configEpoch &amp; votes），会选举一个 replica 为新的 master（自动 failover）。</li></ul></li><li><strong>事务与 multi-key 操作</strong><ul><li>多 key 命令要求所有 key 在同一 slot（或使用 <code>&#123;hash-tag&#125;</code> 把相关 key 放入同 slot），否则报错。</li></ul></li><li><strong>客户端</strong><ul><li>Cluster-aware 客户端会缓存 cluster slots 映射并自动跟随 <code>MOVED</code> 重定向。</li></ul></li><li><strong>工程注意</strong><ul><li>设计时尽量把相关 key 放同 slot（hash tag）。</li><li>监控 cluster slots 分布、replication lag、failover 次数。</li><li>节点拓扑要冗余部署（不同机房&#x2F;可用区）。</li></ul></li></ul><h3 id="17-Redssion"><a href="#17-Redssion" class="headerlink" title="17.Redssion"></a>17.Redssion</h3><h4 id="1-Redisson-简介"><a href="#1-Redisson-简介" class="headerlink" title="1. Redisson 简介"></a>1. Redisson 简介</h4><ul><li><strong>Redisson</strong> 是 Redis 官方推荐的 <strong>Java 客户端</strong>，比 Jedis、Lettuce 更高级。</li><li>除了基本 Redis 操作，它还提供了 <strong>分布式对象、分布式集合、分布式锁、限流器、信号量</strong> 等并发工具。</li><li>最常用的功能就是 <strong>分布式锁</strong>（ReentrantLock、FairLock、ReadWriteLock、Semaphore 等）。</li></ul><hr><h4 id="2-Redisson-分布式锁的核心机制"><a href="#2-Redisson-分布式锁的核心机制" class="headerlink" title="2. Redisson 分布式锁的核心机制"></a>2. Redisson 分布式锁的核心机制</h4><p>Redisson 的分布式锁相比自己写的 <code>SET NX EX</code> 有三大改进：</p><h5 id="2-1-自动续期（看门狗机制）"><a href="#2-1-自动续期（看门狗机制）" class="headerlink" title="2.1 自动续期（看门狗机制）"></a>2.1 自动续期（看门狗机制）</h5><ul><li>加锁时默认过期时间 &#x3D; 30 秒。</li><li>如果业务逻辑未完成，Redisson 内部会有一个 <strong>watchdog 守护线程</strong>，每隔 10 秒自动续期，保证锁不会提前过期。</li><li>如果客户端宕机，守护线程也会停止，锁会在过期时间后自动释放 → <strong>避免死锁</strong>。</li></ul><h5 id="2-2-可重入锁"><a href="#2-2-可重入锁" class="headerlink" title="2.2 可重入锁"></a>2.2 可重入锁</h5><ul><li>和 Java 的 <code>ReentrantLock</code> 一样，Redisson 的 <code>RLock</code> 支持可重入（同一线程多次加锁不会死锁）。</li><li>实现方式：用 Redis <code>Hash</code> 存储锁的持有者（线程 ID + 重入次数）。</li></ul><h5 id="2-3-多种锁类型"><a href="#2-3-多种锁类型" class="headerlink" title="2.3 多种锁类型"></a>2.3 多种锁类型</h5><p>Redisson 提供了丰富的锁实现：</p><ul><li><strong>RLock</strong>：普通可重入锁</li><li><strong>FairLock</strong>：公平锁（FIFO 排队）</li><li><strong>ReadWriteLock</strong>：读写锁（共享读 &#x2F; 独占写）</li><li><strong>MultiLock</strong>：多个 Redis 节点上的联合锁（类似 Redlock）</li><li><strong>RedLock</strong>：实现 Redis 官方的 Redlock 算法</li><li><strong>Semaphore</strong>：分布式信号量</li><li><strong>CountDownLatch</strong>：分布式闭锁</li></ul><hr><h4 id="3-使用示例（Java）"><a href="#3-使用示例（Java）" class="headerlink" title="3. 使用示例（Java）"></a>3. 使用示例（Java）</h4><h5 id="3-1-引入依赖"><a href="#3-1-引入依赖" class="headerlink" title="3.1 引入依赖"></a>3.1 引入依赖</h5><p>Maven：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.27.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3-2-创建-Redisson-客户端"><a href="#3-2-创建-Redisson-客户端" class="headerlink" title="3.2 创建 Redisson 客户端"></a>3.2 创建 Redisson 客户端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RedissonClient redisson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RedissonClient <span class="title function_">getClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (redisson == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">            config.useSingleServer()</span><br><span class="line">                  .setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>)</span><br><span class="line">                  .setDatabase(<span class="number">0</span>);</span><br><span class="line">            redisson = Redisson.create(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-获取分布式锁"><a href="#3-3-获取分布式锁" class="headerlink" title="3.3 获取分布式锁"></a>3.3 获取分布式锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> RedissonManager.getClient();</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;orderLock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取锁，最多等待 5 秒，拿到锁后 10 秒自动释放</span></span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到锁，开始执行任务...&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟业务逻辑</span></span><br><span class="line">                Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;任务执行完成&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;未获取到锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁（只有持有锁的线程能释放）</span></span><br><span class="line">            <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-多种锁示例"><a href="#4-多种锁示例" class="headerlink" title="4. 多种锁示例"></a>4. 多种锁示例</h4><h5 id="4-1-公平锁（先来先得）"><a href="#4-1-公平锁（先来先得）" class="headerlink" title="4.1 公平锁（先来先得）"></a>4.1 公平锁（先来先得）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> redisson.getFairLock(<span class="string">&quot;fairLock&quot;</span>);</span><br><span class="line">fairLock.lock();</span><br></pre></td></tr></table></figure><h5 id="4-2-读写锁"><a href="#4-2-读写锁" class="headerlink" title="4.2 读写锁"></a>4.2 读写锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;rwLock&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读锁（共享）</span></span><br><span class="line">rwLock.readLock().lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写锁（排他）</span></span><br><span class="line">rwLock.writeLock().lock();</span><br></pre></td></tr></table></figure><h5 id="4-3-信号量"><a href="#4-3-信号量" class="headerlink" title="4.3 信号量"></a>4.3 信号量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RSemaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> redisson.getSemaphore(<span class="string">&quot;semaphore&quot;</span>);</span><br><span class="line">semaphore.trySetPermits(<span class="number">3</span>); <span class="comment">// 设置许可数</span></span><br><span class="line">semaphore.acquire();  <span class="comment">// 获取许可</span></span><br><span class="line">semaphore.release();  <span class="comment">// 释放许可</span></span><br></pre></td></tr></table></figure><hr><h4 id="5-常见问题与最佳实践"><a href="#5-常见问题与最佳实践" class="headerlink" title="5. 常见问题与最佳实践"></a>5. 常见问题与最佳实践</h4><ol><li><strong>锁过期导致业务未完成</strong><br>Redisson 自带看门狗续期机制（默认 30 秒 + 每 10 秒续期），一般不用担心。</li><li><strong>死锁问题</strong><ul><li>如果用 <code>SETNX</code> 自己实现，可能出现死锁。</li><li>Redisson 通过过期 + 看门狗避免死锁。</li></ul></li><li><strong>性能问题</strong><ul><li>分布式锁毕竟是跨进程的，性能不如本地锁。</li><li>适合关键资源互斥，不要滥用。</li></ul></li><li><strong>高可用 Redis</strong><ul><li>推荐 Redis <strong>哨兵模式 &#x2F; 集群模式</strong>，避免单点问题。</li><li>Redisson 原生支持这些模式，配置简单。</li></ul></li></ol><hr><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><ul><li><strong>如果你只要一个分布式锁</strong>：Redisson 的 <code>RLock</code> + 自动续期足够了。</li><li><strong>如果要公平性&#x2F;可重入&#x2F;读写锁&#x2F;信号量</strong>：Redisson 都提供现成实现。</li><li><strong>如果是核心业务</strong>：用 Redisson + Redis 哨兵&#x2F;集群模式，确保高可用。</li></ul><h2 id="Mybatis-牛客面经八股"><a href="#Mybatis-牛客面经八股" class="headerlink" title="Mybatis-牛客面经八股"></a>Mybatis-牛客面经八股</h2><h3 id="1-与-的区别"><a href="#1-与-的区别" class="headerlink" title="1. $ 与 # 的区别"></a>1. <code>$</code> 与 <code>#</code> 的区别</h3><ul><li><code>#&#123;param&#125;</code>：使用 JDBC 的 <code>PreparedStatement</code> 占位符 <code>?</code> 绑定参数，会进行 <strong>类型转换 &amp; 自动转义</strong>（防 SQL 注入），例如 <code>WHERE name = #&#123;name&#125;</code> 生成 <code>WHERE name = ?</code>。</li><li><code>$&#123;param&#125;</code>：直接字符串替换（文本替换），相当于把 param 拼进 SQL；用于列名 &#x2F; 表名等动态 SQL 片段，但<strong>存在 SQL 注入风险</strong>。<br> <strong>建议</strong>：优先用 <code>#&#123;&#125;</code>，只有在必须动态拼字段&#x2F;表名时且经过严格白名单校验时才用 <code>$&#123;&#125;</code>。</li></ul><hr><h3 id="2-MyBatis-的缓存机制"><a href="#2-MyBatis-的缓存机制" class="headerlink" title="2. MyBatis 的缓存机制"></a>2. MyBatis 的缓存机制</h3><ul><li><strong>一级缓存（Local Cache）</strong><ul><li>作用域：<code>SqlSession</code> 级别（会话级），默认开启。</li><li>行为：相同 <code>SqlSession</code> 内重复执行同一查询会命中缓存，直到 <code>SqlSession</code> 关闭或执行更新操作（UPDATE&#x2F;INSERT&#x2F;DELETE）导致缓存失效。</li></ul></li><li><strong>二级缓存（Global Cache）</strong><ul><li>作用域：namespace（mapper）级别，跨 SqlSession 共享。</li><li>需要在 <code>mapper.xml</code> 中 <code>&lt;cache/&gt;</code> 显式开启（或配置实现），也可以自定义 Cache 实现。</li><li>缓存 key 由 <code>CacheKey</code> 生成（含 mappedStatement id、SQL、param、分页、环境等）。</li><li>写操作会清空（flush）对应 namespace 的二级缓存（默认行为）。</li></ul></li><li><strong>实现细节</strong><ul><li>二级缓存会序列化&#x2F;反序列化对象（默认 Java 序列化），可插入更高效的序列化（Kryo、FST）或用外部存储（Redis）实现二级缓存。</li><li>若对象含有可变字段，缓存可能产生 stale 数据；要慎重设计缓存失效策略。</li></ul></li><li><strong>常见优化</strong><ul><li>使用二级缓存时需确保对象可序列化并合理设置 <code>flushInterval</code>、<code>size</code>、<code>readWrite</code>（readWrite&#x3D;true 表示序列化读写以保证线程安全）。</li><li>对于频繁变更的数据不适合二级缓存。</li></ul></li></ul><hr><h3 id="3-MyBatis-实现一对多关联查询（两种主要方式）"><a href="#3-MyBatis-实现一对多关联查询（两种主要方式）" class="headerlink" title="3. MyBatis 实现一对多关联查询（两种主要方式）"></a>3. MyBatis 实现一对多关联查询（两种主要方式）</h3><ol><li><p><strong>一条 SQL 联表查询 + resultMap 映射</strong></p><ul><li>使用 <code>JOIN</code>，配置 <code>&lt;resultMap&gt;</code>，其中 <code>&lt;collection property=&quot;orders&quot; ofType=&quot;Order&quot;&gt;</code> 映射子集合，通过 <code>resultMap</code> 的 <code>column</code> 指定关联字段。</li><li>优点：只一次数据库往返；缺点：如果主表 N 行、子表 M 行，返回的行数为笛卡尔展开，可能造成重复主对象需要去重（MyBatis 自动处理但会消耗内存）。</li></ul></li><li><p><strong>分两次查询（N+1 问题的改良）</strong></p><ul><li><p>先查询主表集合，得到 id 列表；再用 <code>IN</code> 查询子表 <code>WHERE fk IN (...)</code>，然后在 Java 层组装。</p></li><li><p>MyBatis 提供 <code>&lt;select&gt;</code> 的 <code>resultMap</code> 嵌套 <code>&lt;collection&gt;</code> 的 <code>fetchType=&quot;lazy&quot;</code> 或 <code>select</code> 属性（嵌套查询）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Order&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectOrdersByUserId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>优点：避免单次大联表重复数据，适合主从表一对多规模较大场景。<br> <strong>工程建议</strong>：对于小表&#x2F;数据量少，用单表 JOIN；对于大数据量&#x2F;分页场景，用两步查询（单次 IN 查询）并注意限制 IN 的长度或分批查询。</p></li></ul></li></ol><hr><h3 id="4-MyBatis-如何防止-SQL-注入"><a href="#4-MyBatis-如何防止-SQL-注入" class="headerlink" title="4. MyBatis 如何防止 SQL 注入"></a>4. MyBatis 如何防止 SQL 注入</h3><ul><li><strong>首要原则</strong>：使用 <code>#&#123;&#125;</code> 参数绑定（PreparedStatement）代替字符串拼接。</li><li>对必须拼接的元数据（表名、列名）使用白名单校验（只允许已知的列名&#x2F;表名），不要直接把来自用户的原始值放到 <code>$&#123;&#125;</code>。</li><li>使用数据库权限最小化策略、审核 SQL 日志、在应用层做参数校验与类型检查。</li><li>对动态 SQL 执行做好限制（分页参数必须是整型、限制 pageSize 最大值等）。</li></ul><hr><h3 id="5-MyBatis-和-MyBatis-Plus-的区别"><a href="#5-MyBatis-和-MyBatis-Plus-的区别" class="headerlink" title="5. MyBatis 和 MyBatis-Plus 的区别"></a>5. MyBatis 和 MyBatis-Plus 的区别</h3><ul><li><strong>MyBatis</strong><ul><li>更轻量、原始、需要手写 SQL&#x2F;映射。</li><li>灵活性高，适合复杂 SQL 与精确控制。</li></ul></li><li><strong>MyBatis-Plus (MP)</strong><ul><li>在 MyBatis 基础上提供<strong>增强功能</strong>：通用 CRUD（无需写 SQL）、代码生成器、Wrapper 条件构造器、分页插件、逻辑删除、性能分析插件等。</li><li>优点：提高开发效率，减少重复 CRUD 代码。</li><li>缺点：抽象层更多，可能隐藏 SQL 细节（需要关注生成 SQL 性能）；对复杂 SQL 还是需要自定义。<br> <strong>选择</strong>：如果项目是标准 CRUD 大量重复，使用 MP 可以大幅提升效率；对复杂查询&#x2F;性能敏感的模块仍应手写 Mapper SQL。</li></ul></li></ul><hr><h3 id="6-MyBatis-如何实现分页查询"><a href="#6-MyBatis-如何实现分页查询" class="headerlink" title="6. MyBatis 如何实现分页查询"></a>6. MyBatis 如何实现分页查询</h3><ul><li><p><strong>RowBounds（物理分页）</strong>：MyBatis 提供 <code>RowBounds</code> 类用于客户端分页。缺点：默认实现会在内存中做分页（取出全部结果再截取），不适合大量数据。</p></li><li><p><strong>数据库分页（推荐）</strong>：使用 <code>LIMIT/OFFSET</code>（MySQL&#x2F;Postgres），或相应 DB dialect 的分页语法。通常使用分页插件（例如 PageHelper）或 MyBatis-Plus 的 <code>IPage</code>&#x2F;<code>Page</code> 对象自动注入分页 SQL。</p></li><li><p><strong>步骤示例（MySQL）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users</span><br><span class="line">WHERE ...</span><br><span class="line">ORDER BY created_at DESC</span><br><span class="line">LIMIT #&#123;offset&#125;, #&#123;pageSize&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>高级</strong>：对于大偏移（offset 大），建议使用基于索引的分页（记录上次最后 id）避免 OFFSET 扫描开销。</p></li></ul><hr><h3 id="7-MyBatis-中动态-SQL-的作用"><a href="#7-MyBatis-中动态-SQL-的作用" class="headerlink" title="7. MyBatis 中动态 SQL 的作用"></a>7. MyBatis 中动态 SQL 的作用</h3><ul><li><p>使用 XML 标签（<code>&lt;if&gt;</code>, <code>&lt;where&gt;</code>, <code>&lt;trim&gt;</code>, <code>&lt;foreach&gt;</code>, <code>&lt;choose&gt;</code> 等）根据传入参数动态拼装 SQL。</p></li><li><p>作用：</p><ul><li>避免手写大量 SQL 变体。</li><li>提高复用性：同一 mapper 方法根据条件生成不同 where 子句。</li></ul></li><li><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUsers&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM user</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>AND name = #&#123;name&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span>AND age = #&#123;age&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="8-MyBatis-的插件原理（Interceptor）"><a href="#8-MyBatis-的插件原理（Interceptor）" class="headerlink" title="8. MyBatis 的插件原理（Interceptor）"></a>8. MyBatis 的插件原理（Interceptor）</h3><ul><li>MyBatis 提供插件接口 <code>org.apache.ibatis.plugin.Interceptor</code>，可以拦截：<ul><li><code>Executor</code>（执行器）、</li><li><code>StatementHandler</code>（SQL 执行）、</li><li><code>ParameterHandler</code>（参数处理）、</li><li><code>ResultSetHandler</code>（结果处理）。</li></ul></li><li>插件通过 <code>Plugin.wrap(target, this)</code> 返回代理对象（JDK 动态代理）。拦截器的 <code>intercept(Invocation invocation)</code> 可以在调用前&#x2F;后做增强，或替换执行逻辑。</li><li>插件在配置文件中注册并按顺序生效。典型应用：分页插件、性能监控、动态数据源切换等。</li></ul><h4 id="PageHelper-插件原理分析"><a href="#PageHelper-插件原理分析" class="headerlink" title="PageHelper 插件原理分析"></a><strong>PageHelper 插件原理分析</strong></h4><p>PageHelper 是一个 <strong>MyBatis 插件（Interceptor）</strong>，它的核心思想是：<br> 通过 <strong>拦截 SQL 执行过程</strong>，在执行真正的 SQL 前后，动态修改 SQL 语句，在 SQL 中追加 <code>LIMIT</code>（MySQL）&#x2F; <code>ROWNUM</code>（Oracle） 等分页语法，从而实现物理分页。</p><hr><h5 id="1-PageHelper-的使用方式"><a href="#1-PageHelper-的使用方式" class="headerlink" title="1. PageHelper 的使用方式"></a><strong>1. PageHelper 的使用方式</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);  <span class="comment">// 开始分页（第 1 页，每页 10 条）</span></span><br><span class="line">List&lt;User&gt; list = userMapper.selectAll();</span><br><span class="line">PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(list);</span><br></pre></td></tr></table></figure><ul><li><code>PageHelper.startPage()</code> 并不是直接分页，而是 <strong>设置分页参数到 ThreadLocal</strong>。</li><li>当 MyBatis 执行查询 SQL 时，PageHelper 插件会 <strong>检测到当前线程存在分页参数</strong>，拦截 SQL 并修改。</li></ul><hr><h5 id="2-PageHelper-的拦截点"><a href="#2-PageHelper-的拦截点" class="headerlink" title="2. PageHelper 的拦截点"></a><strong>2. PageHelper 的拦截点</strong></h5><p>PageHelper 是基于 MyBatis 的插件机制实现的，主要拦截：</p><ul><li><strong>Executor.query</strong><br> MyBatis 执行 SQL 查询的入口点。</li><li>具体类：<code>PageInterceptor</code>，实现了 <code>Interceptor</code> 接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">  @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Intercepts</code> 注解表示拦截 <code>Executor.query()</code> 方法。</li><li>当执行 Mapper 的 <code>select</code> 方法时，会被拦截。</li></ul><hr><h5 id="3-PageHelper-的核心流程"><a href="#3-PageHelper-的核心流程" class="headerlink" title="3. PageHelper 的核心流程"></a><strong>3. PageHelper 的核心流程</strong></h5><h6 id="1-PageHelper-startPage"><a href="#1-PageHelper-startPage" class="headerlink" title="(1) PageHelper.startPage()"></a>(1) <code>PageHelper.startPage()</code></h6><ul><li>把分页参数（页码 pageNum，每页大小 pageSize，是否统计 count）放入 <code>ThreadLocal</code>。</li><li>这样就可以在后续 SQL 执行时，读取到这些分页参数。</li></ul><hr><h6 id="2-PageInterceptor-拦截-query"><a href="#2-PageInterceptor-拦截-query" class="headerlink" title="(2) PageInterceptor 拦截 query()"></a>(2) PageInterceptor 拦截 <code>query()</code></h6><p>拦截到 SQL 执行时，会做几件事：</p><ol><li><p><strong>获取分页参数</strong>（从 <code>ThreadLocal</code>）。</p></li><li><p><strong>解析原始 SQL</strong>，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure></li><li><p><strong>生成分页 SQL</strong>（根据不同数据库方言，比如 MySQL &#x2F; Oracle）：</p><ul><li><p>MySQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">0</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>Oracle:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> rownum rn, t.<span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>) t <span class="keyword">WHERE</span> rownum <span class="operator">&lt;=</span> <span class="number">10</span></span><br><span class="line">) <span class="keyword">WHERE</span> rn <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>PostgreSQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>生成 count SQL（可选）</strong>，如果需要分页总数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><ul><li>PageHelper 会先执行 count SQL，得到总记录数。</li><li>然后再执行分页 SQL，得到当前页数据。</li></ul></li></ol><hr><h6 id="3-执行分页-SQL-返回结果"><a href="#3-执行分页-SQL-返回结果" class="headerlink" title="(3) 执行分页 SQL &amp; 返回结果"></a>(3) 执行分页 SQL &amp; 返回结果</h6><ul><li>PageHelper 执行改写后的分页 SQL。</li><li>把结果封装成 <code>Page</code> 或 <code>PageInfo</code> 对象，包含：<ul><li><code>pageNum</code>（当前页）</li><li><code>pageSize</code>（每页大小）</li><li><code>total</code>（总记录数）</li><li><code>pages</code>（总页数）</li><li><code>list</code>（当前页数据）</li></ul></li></ul><hr><h5 id="4-PageHelper-的核心类"><a href="#4-PageHelper-的核心类" class="headerlink" title="4. PageHelper 的核心类"></a><strong>4. PageHelper 的核心类</strong></h5><ul><li><code>PageHelper</code>：入口工具类，负责设置分页参数（存入 ThreadLocal）。</li><li><code>Page</code>：继承 <code>ArrayList</code>，存放分页结果，同时保存分页信息（total, pageNum, pageSize）。</li><li><code>PageInterceptor</code>：MyBatis 插件拦截器，核心逻辑在这里。</li><li><code>Dialect</code>：方言类，不同数据库分页 SQL 的实现（MySQLDialect、OracleDialect 等）。</li></ul><hr><h5 id="5-PageHelper-的优势"><a href="#5-PageHelper-的优势" class="headerlink" title="5. PageHelper 的优势"></a><strong>5. PageHelper 的优势</strong></h5><ul><li>使用方便：只需 <code>startPage()</code> 即可，不用手写分页 SQL。</li><li>支持多数据库：内部有方言适配器。</li><li>支持自动 count，总页数计算简单。</li><li>基于 MyBatis 插件机制，不需要改动 SQL。</li></ul><hr><h5 id="6-PageHelper-的局限性"><a href="#6-PageHelper-的局限性" class="headerlink" title="6. PageHelper 的局限性"></a><strong>6. PageHelper 的局限性</strong></h5><ol><li><strong>线程绑定问题</strong><ul><li><code>startPage()</code> 依赖 <code>ThreadLocal</code>，必须在查询语句之前调用，否则无效。</li><li>如果一个线程执行多个分页，可能会出现混乱，需要注意调用顺序。</li></ul></li><li><strong>count 性能问题</strong><ul><li>大表 <code>COUNT(*)</code> 代价很高，可能导致分页慢。</li><li>可通过优化 SQL 或冗余字段来避免。</li></ul></li><li><strong>复杂 SQL 的 count 不准确</strong><ul><li>比如包含 <code>GROUP BY</code> &#x2F; <code>DISTINCT</code> 时，count 语句可能需要手动优化。</li></ul></li></ol><hr><h5 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h5><p>👉 <strong>PageHelper 的核心原理：</strong></p><ul><li>基于 MyBatis 插件机制，拦截 <code>Executor.query()</code>。</li><li>利用 <code>ThreadLocal</code> 传递分页参数。</li><li>动态改写 SQL，生成 <code>count SQL + limit SQL</code>。</li><li>执行后封装结果集为分页对象返回。</li></ul><hr><h3 id="9-MyBatis-底层原理（请求执行全流程）"><a href="#9-MyBatis-底层原理（请求执行全流程）" class="headerlink" title="9. MyBatis 底层原理（请求执行全流程）"></a>9. MyBatis 底层原理（请求执行全流程）</h3><p><strong>核心组件与调用链（简化）</strong></p><ol><li><strong>Configuration</strong>：解析 mapper XML &#x2F; 注解，构建 <code>MappedStatement</code>、<code>ResultMap</code>、<code>SqlSource</code> 等。</li><li><strong>SqlSessionFactory</strong>：负责创建 <code>SqlSession</code>。</li><li><strong>SqlSession</strong>：一切 DB 操作入口，提供 <code>select/insert/update/delete</code> 等方法。</li><li><strong>Mapper Proxy</strong>：<code>Mapper</code> 接口通过 JDK Proxy（或 CGLIB）生成，调用 mapper 方法会转发到 <code>MapperProxy</code>，最终调用 <code>SqlSession</code> 执行对应 <code>MappedStatement</code>。</li><li><strong>Executor</strong>：执行器负责缓存策略、调用 <code>StatementHandler</code> 执行 JDBC。<ul><li>Executor -&gt; <code>StatementHandler.prepare()</code> -&gt; <code>ParameterHandler.setParameters()</code> -&gt; <code>Statement.executeQuery()</code> -&gt; <code>ResultSetHandler.handleResultSets()</code>。</li></ul></li><li><strong>StatementHandler &#x2F; ParameterHandler &#x2F; ResultSetHandler</strong><ul><li><code>StatementHandler</code> 负责创建 JDBC Statement（PreparedStatement）、设置分页 SQL（如果 RowBounds）或其他变换。</li><li><code>ParameterHandler</code> 负责把参数绑定到 PreparedStatement 的 <code>?</code> 上（依赖 TypeHandler）。</li><li><code>ResultSetHandler</code> 把 JDBC <code>ResultSet</code> 映射成 Java 对象（使用 <code>ResultMap</code> 的映射规则）。</li></ul></li><li><strong>TypeHandler</strong><ul><li>用于 Java 类型与 JDBC 类型映射（可以自定义，例如 JSON 序列化）。</li></ul></li><li><strong>动态 SQL 处理</strong><ul><li>Mapper XML 中的 <code>&lt;if&gt;</code>&#x2F;<code>&lt;foreach&gt;</code> 在构建 <code>SqlSource</code> 时会被解析为 <code>DynamicSqlSource</code>，执行时生成 <code>BoundSql</code>（最终 SQL + 参数映射）。</li></ul></li><li><strong>缓存</strong><ul><li>Executor 在执行前会根据 <code>CacheKey</code> 进行一级&#x2F;二级缓存查询。</li></ul></li><li><strong>事务</strong><ul><li><code>SqlSession</code> 管理事务（底层使用 JDBC 事务或 Spring 的 DataSource 事务管理）。</li></ul></li></ol><p><strong>关键点</strong></p><ul><li>MyBatis 把 SQL 与 Java 映射隔离，运行时通过配置构建执行计划。</li><li>动态 SQL 在解析时产生一颗语法树，在执行时按参数生成真实 SQL。</li><li>MyBatis 允许自定义拦截器、TypeHandler、插件扩展点。</li></ul><h2 id="SQL-牛客面经八股"><a href="#SQL-牛客面经八股" class="headerlink" title="SQL-牛客面经八股"></a>SQL-牛客面经八股</h2><p>好 —— 我把你 1–31 每一条都<strong>逐项放大解读</strong>，把原理、实现细节、面试要点、常见例子、实践建议和可复制的解决办法都写清楚。篇幅较长，但这是一次把知识“掰开揉碎”到能直接答面试与做线上定位的版本。每一节都尽量包含：<strong>原理 → 行为&#x2F;例子 → 故障&#x2F;失效场景 → 优化&#x2F;修复办法</strong>。</p><hr><h3 id="1-什么是索引？索引有哪些分类？"><a href="#1-什么是索引？索引有哪些分类？" class="headerlink" title="1. 什么是索引？索引有哪些分类？"></a>1. 什么是索引？索引有哪些分类？</h3><p><strong>概念（本质）</strong><br> 索引是为表中一列或多列建立的 <strong>辅助数据结构</strong>，用于快速定位满足某些条件的记录，减少磁盘 I&#x2F;O 和全表扫描。数据库把索引看成“查表的导航”。</p><p><strong>按维度分类（并扩展解释）</strong></p><ul><li><strong>按数据结构</strong><ul><li><strong>B+Tree（B+ 树）</strong>：最常见。支持范围查询、排序、分页；磁盘&#x2F;页友好（一次读回多个 key）。</li><li><strong>Hash</strong>：O(1) 等值查询，不能做范围&#x2F;排序。MySQL InnoDB 没有用户可见 Hash index，但 MEMORY 存储引擎提供 hash 索引。InnoDB 有 <strong>Adaptive Hash Index（自适应哈希索引）</strong> 作为优化。</li><li><strong>Fulltext</strong>：倒排索引，用于全文检索（MATCH…AGAINST）。</li><li><strong>R-Tree &#x2F; GiST &#x2F; SPATIAL</strong>：用于空间数据（GIS）。</li></ul></li><li><strong>按逻辑用途</strong><ul><li><strong>主键索引（PRIMARY KEY）</strong>：唯一，不能为 NULL，InnoDB 中是聚簇索引。</li><li><strong>唯一索引（UNIQUE）</strong>：保证列唯一性。</li><li><strong>普通索引（INDEX）</strong></li></ul></li><li><strong>按物理存放与访问</strong><ul><li><strong>聚簇索引（Clustered）</strong>：叶子存整行（InnoDB 主键）。</li><li><strong>非聚簇索引（Secondary）</strong>：叶子存主键值（回表）。</li></ul></li><li><strong>按列数</strong><ul><li><strong>单列索引</strong>、<strong>联合（复合）索引</strong>。</li></ul></li></ul><p><strong>面试&#x2F;实践要点</strong>：<br> 索引不是越多越好。索引是读优化并以写代价换取的：每次写&#x2F;更新都要维护索引（开销 + 额外 IO + 可能的锁）。</p><hr><h3 id="2-Hash-索引-与-BTree-索引-的详细区别（含-InnoDB-特例）"><a href="#2-Hash-索引-与-BTree-索引-的详细区别（含-InnoDB-特例）" class="headerlink" title="2. Hash 索引 与 BTree 索引 的详细区别（含 InnoDB 特例）"></a>2. Hash 索引 与 BTree 索引 的详细区别（含 InnoDB 特例）</h3><p><strong>Hash 索引</strong></p><ul><li>查找：哈希表根据 key 直接定位桶 → 平均 O(1)。</li><li>适用：等值查找（<code>=</code>、<code>IN</code>）。</li><li>不适用：范围查询（<code>BETWEEN</code>、<code>&gt;</code>、<code>LIKE &#39;a%&#39;</code> 也不能排序&#x2F;范围）。</li><li>MySQL 场景：MEMORY 引擎的 hash index。InnoDB 本身没有对用户表提供持久 Hash index，但内部会根据热数据构建自适应哈希索引（AHI）提升热点范围访问速度（AHI 是运行时构建的）。</li></ul><p><strong>B+Tree（B+ 树）</strong></p><ul><li>查找：O(logN)，每层读一个节点（磁盘页），节点 fanout 高，层数小。</li><li>优点：支持前缀匹配、范围查询、顺序扫描、order by 利用索引避免 filesort。</li><li>叶子节点链表使顺序遍历非常快（适合范围、分页）。</li></ul><p><strong>举例</strong></p><ul><li><code>WHERE username = &#39;alice&#39;</code>：Hash 和 B+ 树都可以很快。</li><li><code>WHERE age BETWEEN 20 AND 30</code>：Hash 无解，B+ 树优选。</li><li><code>ORDER BY created_at DESC LIMIT 10</code>：若有 B+ 树按 created_at 排序，能直接用索引返回；Hash 无法帮助排序。</li></ul><p><strong>实战提示</strong>：当查询只做大量简单等值并且无需排序&#x2F;范围时 MEMORY+Hash 或缓存（Redis）是合适的，但对于持久化大表与混合查询，B+Tree 是通用选择。</p><hr><h3 id="3-为什么-MySQL-采用-B-树？"><a href="#3-为什么-MySQL-采用-B-树？" class="headerlink" title="3. 为什么 MySQL 采用 B+ 树？"></a>3. 为什么 MySQL 采用 B+ 树？</h3><p><strong>关键原因</strong></p><ol><li><strong>磁盘&#x2F;页导向</strong>：B+ 树节点能容纳多个 key，单次磁盘读取可获得更多 key（高 fanout，低高度），极大减少磁盘 IO。</li><li><strong>范围&#x2F;排序原生支持</strong>：叶子节点链表可 O(1) 地从一个叶子顺序遍历到下一个叶子，范围查询&#x2F;排序&#x2F;分页高效。</li><li><strong>稳定的页型组织</strong>：内、外节点分工明确（内节点索引，叶节点记录或指针），便于磁盘&#x2F;缓存优化。</li><li><strong>顺序插入&#x2F;删除代价较低</strong>：相比红黑树的每一次调整（指针微调），B+ 树整体在磁盘环境下的重排更可控。</li></ol><p><strong>对比红黑树（或 AVL）</strong></p><ul><li>红黑树每个节点只含几个 key，深度更高，磁盘访问更多，IO 不友好。</li><li>B+ 树将所有 key 放在叶子并形成链表，范围扫描复杂度低且局部性好。</li></ul><hr><h3 id="4-B-树查询数据的全过程"><a href="#4-B-树查询数据的全过程" class="headerlink" title="4. B+ 树查询数据的全过程"></a>4. B+ 树查询数据的全过程</h3><p>以 InnoDB 的二级索引查询为例 <code>SELECT col1,col2 FROM t WHERE idx_col = ?</code>：</p><p><strong>步骤</strong></p><ol><li><strong>从根节点读取内存页</strong>：读取节点内的索引范围信息，根据 key 找到对应 child 指针（页 id）。</li><li><strong>递归下钻</strong>：在内节点根据 key 比较决定下一跳，直到叶子节点。</li><li><strong>叶子节点定位</strong>：<ul><li><strong>二级索引（非聚簇）</strong>：叶子 node 存储 <code>(indexed_key, PRIMARY_KEY)</code>。</li><li>找到匹配叶子项后获得主键值，<strong>回表</strong>（再走聚簇索引）以读取完整记录。</li><li><strong>聚簇索引（主键）</strong>：叶子直接存储完整行（或指向行在页中的偏移），无需回表。</li></ul></li><li><strong>返回结果</strong>：把结果发送给上层 SQL 引擎。</li></ol><p><strong>注意</strong>：</p><ul><li>回表成本是二级索引的一项主要开销（每命中二级索引都可能触发一或多次聚簇索引访问）。</li><li><strong>覆盖索引</strong>（索引包含查询所需列）可以避免回表，大幅提升效率。</li></ul><hr><h3 id="5-三层-B-树能存多少数据？"><a href="#5-三层-B-树能存多少数据？" class="headerlink" title="5. 三层 B+ 树能存多少数据？"></a>5. 三层 B+ 树能存多少数据？</h3><p><strong>公式法</strong></p><ul><li>假设 page（页）大小 P（常见 16KB），每个索引条目占用 S 字节（S &#x3D; key_length + pointer_length + overhead）。</li><li><strong>fanout ≈ floor(P &#x2F; S)</strong>（每个节点可指向 fanout 个子节点）。</li><li>如果高度为 h（根为第 1 层、叶为第 h 层），能表达的叶子条目数 ≈ fanout^(h-1) * entries_per_leaf（approx）。</li></ul><p><strong>举例（简化前面例子）</strong></p><ul><li>P &#x3D; 16KB &#x3D; 16384 bytes</li><li>S ≈ 16 bytes (8B key + 8B pointer)</li><li>fanout ≈ 1024</li><li>三层（root + level2 + leaf level）大致能表达 1024^2 ≈ 1,048,576 leaf pages，每页可包含多条记录（或 1 条 row pointer），合并到记录数上可达到亿级甚至十亿级，取决于 leaf 的条目数。</li></ul><p><strong>现实中</strong></p><ul><li>InnoDB 的 leaf 存储的是索引条目（可能多个列、变长），因此每页条目数受字符集和列长度影响。</li><li>实际层高通常较低（3–4），能支撑数 10^8 到 10^10 级别的记录。</li></ul><hr><h3 id="6-聚簇索引（Clustered）-vs-非聚簇索引（Secondary）"><a href="#6-聚簇索引（Clustered）-vs-非聚簇索引（Secondary）" class="headerlink" title="6. 聚簇索引（Clustered） vs 非聚簇索引（Secondary）"></a>6. 聚簇索引（Clustered） vs 非聚簇索引（Secondary）</h3><p><strong>聚簇索引（InnoDB 主键）</strong></p><ul><li>叶子节点存整行数据（实际数据页即为 B+ 树叶子）。</li><li>表的物理顺序以主键顺序组织（插入大量随机主键会导致随机写&#x2F;页面分裂）。</li><li>好处：<ul><li>主键范围查询、ORDER BY&#x2F;绿色扫描很快。</li><li>访问主键直接命中无需回表。</li></ul></li><li>坏处：<ul><li>每个表只能有一个聚簇索引（即只有一个物理排序方式）。</li><li>主键变更代价高，因为行必须移动。</li></ul></li></ul><p><strong>非聚簇索引（Secondary）</strong></p><ul><li>叶子节点存索引列 + <strong>主键</strong>（作为 row identifier）。</li><li>访问二级索引后需回表（通过主键再走聚簇索引获取整行）。</li><li>好处：<ul><li>可建立多种不同访问路径（多个二级索引）。</li></ul></li><li>坏处：<ul><li>回表开销，尤其是命中很多条且非覆盖时。</li></ul></li></ul><p><strong>实践建议</strong></p><ul><li>设计主键尽量使用 <strong>自增或有序主键</strong>（减少页分裂），或使用 <code>UUID</code> 的有序变体（ULID）。</li><li>对于频繁的聚合&#x2F;查询字段，考虑建立<strong>覆盖索引</strong>（把能覆盖查询的列都加入索引）。</li></ul><hr><h3 id="7-联合索引的存储结构与“最左前缀”原则"><a href="#7-联合索引的存储结构与“最左前缀”原则" class="headerlink" title="7. 联合索引的存储结构与“最左前缀”原则"></a>7. 联合索引的存储结构与“最左前缀”原则</h3><p><strong>结构</strong><br> 索引 <code>(a,b,c)</code> 在 B+ 树中是按 <code>(a,b,c)</code> 的字典序排列。索引条目的 key 为复合值。</p><p><strong>最左前缀原则</strong><br> 索引可用于以下查询：</p><ul><li><code>WHERE a = ?</code></li><li><code>WHERE a = ? AND b = ?</code></li><li><code>WHERE a = ? AND b BETWEEN ? AND ?</code> （b 的范围仍能使用）</li><li><code>WHERE a LIKE &#39;prefix%&#39;</code>（前缀匹配）</li><li><code>ORDER BY a, b</code>（与索引顺序匹配的排序可避免 filesort）</li></ul><p><strong>被阻断的情形（典型例子）</strong></p><ul><li><code>WHERE b = ?</code>（没有 a 的条件）不能直接利用 <code>(a,b,c)</code> 索引寻找单个 b。</li><li><code>WHERE a &gt; ? AND b = ? AND c = ?</code>：当对 a 使用范围（<code>&gt;</code>、<code>BETWEEN</code>），索引只能使用到 a 的范围定位，<code>b</code>&#x2F;<code>c</code> 的等值后续列不能用于索引访问（但仍可用于过滤或排序优化取决于引擎）。</li></ul><p><strong>补救办法</strong></p><ul><li>如果业务常按 b 查询，应加单列索引 <code>b</code> 或把联合索引换为 <code>(b,a,c)</code> 之类，按访问频率与选择性设计。</li><li>使用 <strong>索引覆盖</strong> 并合理排序联合索引字段以匹配常见 WHERE&#x2F;ORDER BY。</li></ul><hr><h3 id="8-SELECT-IN-模糊查询-中如何使用索引"><a href="#8-SELECT-IN-模糊查询-中如何使用索引" class="headerlink" title="8. SELECT IN &#x2F; 模糊查询 中如何使用索引"></a>8. SELECT IN &#x2F; 模糊查询 中如何使用索引</h3><p><strong>IN</strong></p><ul><li><code>col IN (v1, v2, v3)</code> 等价于多个等值条件的 OR，MySQL 可以利用索引做多个快速定位（多次索引查找或范围查找），性能通常好于多个 OR，但是具体行为可在执行计划中查看。</li></ul><p><strong>LIKE 模糊查询</strong></p><ul><li><code>LIKE &#39;abc%&#39;</code>：前缀匹配，<strong>能走索引</strong>（B+ 树从 ‘abc’ 起定位并顺序扫描）。</li><li><code>LIKE &#39;%abc&#39;</code>：前导通配符导致索引失效（无法从索引开始定位，因为任意前缀）。</li><li><code>LIKE &#39;%abc%&#39;</code>：同上，不能利用 B+ 树索引；解决方式：全文索引（FULLTEXT）或外部搜索（Elasticsearch）；或倒排索引&#x2F;三gram。</li></ul><p><strong>优化思路</strong></p><ul><li>将模糊搜索重构为前缀匹配或使用全文索引。</li><li>对 IN 的大集合要小心，如果 IN 列表非常长，优先把常用值放入临时表并 <code>IN (SELECT)</code> 或使用 join。</li></ul><hr><h3 id="9-建索引注意事项"><a href="#9-建索引注意事项" class="headerlink" title="9. 建索引注意事项"></a>9. 建索引注意事项</h3><p><strong>何时建</strong></p><ul><li>经常出现在 WHERE &#x2F; JOIN &#x2F; ORDER BY &#x2F; GROUP BY 中的列。</li><li>作为外键引用的列（保证 join 性能）。</li></ul><p><strong>字段选择与顺序（联合索引）</strong></p><ul><li>把选择性高（distinct 值多）的列放在前面。</li><li>把经常用于 range 的字段放在后面（因为范围会停止利用后续列）。</li></ul><p><strong>索引类型 &#x2F; 编码注意</strong></p><ul><li>字符串字符集影响索引长度（utf8mb4 每字符最多 4 字节），索引前缀长度受限（历史上 InnoDB 有 767&#x2F;3072 字节限制）；使用 <code>VARCHAR(255)</code> 在 utf8mb4 下可能需要更短的前缀或压缩。</li><li>对大文本列使用前缀索引：<code>INDEX(name(50))</code>（节省空间，但会降低准确性）。</li></ul><p><strong>尽量避免</strong></p><ul><li>在低选择性的列（如性别、布尔标志）上建立单列索引（索引命中率低）。</li><li>在频繁写入、更新的列上建立过多索引（维护成本高）。</li><li>盲目建立冗余索引（比如已有 <code>(a,b)</code> 就无需再建 <code>(a)</code> 一般情形可省，除非单列查询高频）。</li></ul><p><strong>覆盖索引</strong></p><ul><li>将查询所需字段都放在索引中（select 列为索引列）能避免回表，显著提速。</li></ul><p><strong>面试追问要点</strong></p><ul><li>讨论索引的空间&#x2F;写入开销、选择性和基数（cardinality），以及如何用 <code>SHOW INDEX</code> &#x2F; <code>ANALYZE TABLE</code> 来获取统计信息。</li></ul><hr><h3 id="10-如何评估-判断索引是否生效？常见索引失效场景详尽列举"><a href="#10-如何评估-判断索引是否生效？常见索引失效场景详尽列举" class="headerlink" title="10. 如何评估 &#x2F; 判断索引是否生效？常见索引失效场景详尽列举"></a>10. 如何评估 &#x2F; 判断索引是否生效？常见索引失效场景详尽列举</h3><p><strong>判断索引是否生效（步骤）</strong></p><ol><li>使用 <code>EXPLAIN &lt;SQL&gt;</code>（或 <code>EXPLAIN FORMAT=JSON</code>）查看：<code>key</code>（使用的索引）、<code>type</code>（访问类型）、<code>rows</code>（估算扫描行数）、<code>Extra</code>（filesort&#x2F;Using temporary&#x2F;Using index）。</li><li>查看实际执行时间与 <code>EXPLAIN ANALYZE</code>（MySQL 8+）的真实耗时、IO。</li><li><code>SHOW INDEX FROM table_name</code> 查看索引定义及 cardinality。</li><li><code>ANALYZE TABLE table_name</code> 更新统计信息后再用 EXPLAIN 检查（有时统计失真会让优化器选择差计划）。</li></ol><p><strong>常见索引失效场景（详述）</strong></p><ul><li><p><strong>对索引列做函数&#x2F;表达式</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> <span class="type">DATE</span>(created_at) <span class="operator">=</span> <span class="string">&#x27;2025-10-01&#x27;</span>  <span class="comment">-- 索引失效</span></span><br></pre></td></tr></table></figure><p>修复：写作 <code>WHERE created_at &gt;= &#39;2025-10-01&#39; AND created_at &lt; &#39;2025-10-02&#39;</code>。</p></li><li><p><strong>隐式类型转换</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>  <span class="comment">-- 如果 id 是 INT，隐式转换可能导致索引不使用</span></span><br></pre></td></tr></table></figure><p>修复：确保参数类型匹配或强制类型转换在常量上。</p></li><li><p><strong>Leading wildcard（前导通配符）</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>  <span class="comment">-- 无法用索引</span></span><br></pre></td></tr></table></figure><p>修复：避免前导 <code>%</code>，或使用 FULLTEXT&#x2F;倒排索引。</p></li><li><p><strong>OR 條件中没有共同索引</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> b <span class="operator">=</span> <span class="number">2</span>  <span class="comment">-- 若 a,b 都有索引，查询可能会采用 index_merge，但复杂情况仍可能全表扫描</span></span><br></pre></td></tr></table></figure><p>修复：用 UNION 优化（<code>SELECT ... WHERE a=1 UNION SELECT ... WHERE b=2</code>），或添加合适联合索引。</p></li><li><p><strong>范围搜索切断联合索引后续列</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> a <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">3</span>  <span class="comment">-- 如果 a 是范围条件，后续 b,c 通常不能利用索引进行定位（但可以作为过滤）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>NOT</code>、<code>&lt;&gt;</code>、<code>IS NULL</code>（依赖场景）</strong>：<code>NOT</code> 和 <code>&lt;&gt;</code> 通常导致全表扫描。<code>IS NULL</code> 可用索引但要看实现与数据分布。</p></li><li><p><strong>隐含返回过多列导致不能使用覆盖索引</strong>：<code>SELECT *</code> 会导致回表。</p></li><li><p><strong>统计信息过期或不准确</strong>：优化器基于统计，如果统计不准会选错索引，使用 <code>ANALYZE TABLE</code> 更新。</p></li></ul><p><strong>演练：如何修复某常见失效</strong><br> 场景：<code>WHERE DATE(ts) = &#39;2025-10-01&#39;</code>。<br> 解决：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 改写为范围</span></span><br><span class="line"><span class="keyword">WHERE</span> ts <span class="operator">&gt;=</span> <span class="string">&#x27;2025-10-01&#x27;</span> <span class="keyword">AND</span> ts <span class="operator">&lt;</span> <span class="string">&#x27;2025-10-02&#x27;</span></span><br></pre></td></tr></table></figure><p>好处：能利用 ts 上的索引，避免函数计算。</p><hr><h3 id="11-索引失效后怎么办？"><a href="#11-索引失效后怎么办？" class="headerlink" title="11. 索引失效后怎么办？"></a>11. 索引失效后怎么办？</h3><ul><li><strong>第一步：EXPLAIN</strong> 看当前计划与 <code>key</code> 列。</li><li><strong>第二步：确认 WHERE &#x2F; ORDER BY &#x2F; JOIN</strong> 中列的表达式是否会破坏索引（函数、类型转换、范围切断）。</li><li><strong>第三步：重写 SQL</strong>：<ul><li>把函数移动到常量端或使用等价的区间（日期函数改为区间）。</li><li>避免 SELECT *，改为需要列（利于覆盖索引）。</li><li>对 OR 用 UNION 或添加合适索引。</li></ul></li><li><strong>第四步：增加或调整索引</strong>：<ul><li>做覆盖索引或按查询列顺序建立复合索引。</li><li>对 TEXT&#x2F;VARCHAR 做前缀索引（必要时）。</li></ul></li><li><strong>第五步：统计&#x2F;版本</strong>：<ul><li><code>ANALYZE TABLE</code> 后再次 EXPLAIN。</li><li>了解 MySQL 版本的优化器行为（例如 5.7 vs 8.0 在 subquery rewrite 上有差别）。</li></ul></li><li><strong>第六步：测试与回滚</strong>：<ul><li>在预发布&#x2F;测试环境验证索引是否改善查询计划和实际耗时。</li><li>使用慢查询日志对比。</li></ul></li></ul><hr><h3 id="12-数据库索引重构过程（线上零停机实践）"><a href="#12-数据库索引重构过程（线上零停机实践）" class="headerlink" title="12. 数据库索引重构过程（线上零停机实践）"></a>12. 数据库索引重构过程（线上零停机实践）</h3><p><strong>目标</strong>：修改索引（添加&#x2F;删除&#x2F;重建）而<strong>不影响线上业务</strong>。</p><p><strong>常用工具与策略</strong></p><ul><li><p><strong>ALTER TABLE … ADD INDEX</strong>：在较新 MySQL 支持 <code>ALGORITHM=INPLACE, LOCK=NONE</code> 可在线加索引（不阻塞读写）。但并非所有场景都支持（依赖表引擎、列类型、已有 DDL 状态）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> t <span class="keyword">ADD</span> INDEX idx_col(col) ALGORITHM<span class="operator">=</span>INPLACE, LOCK<span class="operator">=</span><span class="keyword">NONE</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>pt-online-schema-change（Percona Toolkit）</strong>：原理：创建一个新表（目标结构），用触发器&#x2F;复制把变更期间的数据同步到新表，最后原子 RENAME 表交换。优点成熟，适用范围广，但在高写场景触发器开销大。</p></li><li><p><strong>gh-ost（GitHub）</strong>：基于 binlog 的在线 schema change，低风险、对主库影响小；更适合高并发写表。原理类似：复制数据到 ghost table 并实时追赶 binlog，然后切换。</p></li><li><p><strong>手工方案（可用于大批量重建索引）</strong>：</p><ol><li>在 off-peak 期间创建新索引副本表（若可行）。</li><li>使用分批迁移或分区交换（PARTITION EXCHANGE）来减少停机。</li><li>使用 <code>ALTER TABLE ... DISABLE KEYS</code>（MyISAM）或 <code>pt-online-schema-change</code>。</li></ol></li></ul><p><strong>注意事项</strong></p><ul><li>在线建索引会额外占用 IO &#x2F; CPU &#x2F; binlog，有流量控制（Throttle）。</li><li>在多主&#x2F;主从拓扑中，要考虑 Replica 上的 DDL 是否也会执行、binlog_format（ROW&#x2F;STATEMENT）影响。</li><li>切换前务必备份与验证。</li></ul><hr><h3 id="13-为什么数据库用-B-树不使用红黑树"><a href="#13-为什么数据库用-B-树不使用红黑树" class="headerlink" title="13. 为什么数据库用 B+ 树不使用红黑树"></a>13. 为什么数据库用 B+ 树不使用红黑树</h3><ul><li><strong>磁盘页角度</strong>：B+ 树内节点可包含许多 key→降低树高度→减少磁盘页读写次数（关键点：磁盘 IO 是瓶颈）。</li><li><strong>顺序遍历</strong>：B+ 树叶子链表提供顺序遍历，非常适合范围扫描和排序操作；红黑树的中序遍历需更多随机 IO。</li><li><strong>空间局部性</strong>：B+ 树把叶子节点放在连续页中（或缓存友好），提高 cache 命中率。</li><li><strong>写放与页分裂</strong>：B+ 树专门为页管理设计，插入造成页分裂的代价在磁盘系统中更可控。</li></ul><hr><h3 id="14-数据库分页的实现方式"><a href="#14-数据库分页的实现方式" class="headerlink" title="14. 数据库分页的实现方式"></a>14. 数据库分页的实现方式</h3><p><strong>方法 A：LIMIT OFFSET（通用）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>问题</strong>：数据库需要扫描并跳过前 1,000,000 行（或者移动游标），成本与 offset 线性增长（O(offset)）。</li></ul><p><strong>方法 B：基于索引的 Keyset &#x2F; Seek Pagination（推荐）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 前端保存上页最后 id = last_id</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> (order_col, id) <span class="operator">&gt;</span> (last_order_col, last_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_col, id</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：避免 large offset，随机访问对索引友好，稳定性好。</li><li><strong>限制</strong>：不能随意跳到任意页（只支持“下一页&#x2F;上一页”或基于 cursor 的跳转），不适合“跳到第 N 页”的场景。</li></ul><p><strong>方法 C：预先计算&#x2F;物化分页结果</strong></p><ul><li>对于复杂查询或热点分页，预计算并把排名&#x2F;页结果写到缓存（Redis、materialized view）。</li></ul><p><strong>方法 D：使用索引覆盖 + 子查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">10</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这在某些场景下，子查询只返回 id（索引列）能稍微减轻代价，但仍要注意 offset 开销。</p><p><strong>方法 E：使用窗口函数（MySQL 8）</strong></p><ul><li>可用 <code>ROW_NUMBER()</code> 辅助复杂场景，但底层仍需要扫描&#x2F;排序。</li></ul><hr><h3 id="15-LIMIT-100000000-10-与-LIMIT-10-性能差异"><a href="#15-LIMIT-100000000-10-与-LIMIT-10-性能差异" class="headerlink" title="15. LIMIT 100000000,10 与 LIMIT 10 性能差异"></a>15. LIMIT 100000000,10 与 LIMIT 10 性能差异</h3><p><strong>原因</strong></p><ul><li>MySQL 的 OFFSET 会找到行数然后弃掉前面 N 行（游标移动、IO 扫描），实质上做了大量无用工作。</li><li><code>LIMIT 10</code> 可在索引上迅速返回起始几行。</li></ul><p><strong>解决办法</strong></p><ul><li>用 keyset 分页（上一节）。</li><li>如果必须跳转到大 offset，考虑预计算（cache）或分区查询、倒排索引、物化。</li></ul><hr><h3 id="16-如何使用-EXPLAIN-分析查询？关注哪些列与含义"><a href="#16-如何使用-EXPLAIN-分析查询？关注哪些列与含义" class="headerlink" title="16. 如何使用 EXPLAIN 分析查询？关注哪些列与含义"></a>16. 如何使用 EXPLAIN 分析查询？关注哪些列与含义</h3><p>执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> ...;</span><br><span class="line"><span class="comment">-- 或 MySQL8: EXPLAIN FORMAT=JSON SELECT ...;</span></span><br><span class="line"><span class="comment">-- 或 EXPLAIN ANALYZE SELECT ...; (8.0+, 会实际执行并给出真实时间)</span></span><br></pre></td></tr></table></figure><p><strong>关键列解释</strong></p><ul><li><code>id</code>：查询序号，越大越早执行（子查询&#x2F;union 时重要）。</li><li><code>select_type</code>：SIMPLE&#x2F;PRIMARY&#x2F;DERIVED&#x2F;SUBQUERY&#x2F;UNION 等。</li><li><code>table</code>：当前访问的表 (NULL&#x2F;const&#x2F;table name)。</li><li><code>type</code>（最重要的性能指标之一）：<ul><li><code>system</code>、<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>range</code>、<code>index</code>、<code>ALL</code>（由好到差）。</li><li><code>ALL</code> &#x3D; 全表扫描，<code>range</code> &#x3D; 范围扫描（走索引），<code>ref/eq_ref</code> &#x3D; 精确匹配索引。</li></ul></li><li><code>possible_keys</code>：优化器认为可能使用的索引。</li><li><code>key</code>：实际使用的索引（NULL 表示没有使用）。</li><li><code>key_len</code>：使用的索引长度（字节），表明索引使用了多少前缀。</li><li><code>ref</code>：索引列与哪些值比较（常数或其他列）。</li><li><code>rows</code>：优化器估算需要扫描的行数（越小越好）。</li><li><code>Extra</code>：其他信息（<code>Using where</code>、<code>Using index</code>、<code>Using temporary</code>、<code>Using filesort</code>、<code>Using join buffer</code>）。<ul><li><code>Using index</code> &#x3D; 覆盖索引（好）；</li><li><code>Using filesort</code> 或 <code>Using temporary</code> 说明排序&#x2F;分组需要额外资源（可能慢）。</li></ul></li></ul><p><strong>实践步骤</strong></p><ol><li><code>EXPLAIN</code> 看 <code>type</code> &#x2F; <code>key</code> &#x2F; <code>rows</code>。若 <code>type=ALL</code> 或 <code>rows</code> 很大 → 优先优化。</li><li>若 <code>Using filesort</code> 或 <code>Using temporary</code> → 检查 ORDER BY&#x2F;GROUP BY 是否能用索引或是否导致临时表（改索引&#x2F;改SQL）。</li><li>用 <code>EXPLAIN ANALYZE</code> 获取真实执行耗时和行数（有时估算与真实差异大）。</li></ol><hr><h3 id="17-COUNT-、COUNT-1-、COUNT-列-的区别"><a href="#17-COUNT-、COUNT-1-、COUNT-列-的区别" class="headerlink" title="17. COUNT(*)、COUNT(1)、COUNT(列) 的区别"></a>17. COUNT(*)、COUNT(1)、COUNT(列) 的区别</h3><ul><li><strong>COUNT(*)</strong>：计数 <em>行数</em>（计数所有行，包括 NULL 列），对于 MyISAM 引擎是 O(1)（有表元数据），InnoDB 则通常需要扫描或走索引统计（没有存储全表行计数）。</li><li><strong>COUNT(1)</strong>：语义与 <code>COUNT(*)</code> 相同，MySQL 优化器会把它处理为计数行。</li><li><strong>COUNT(col)</strong>：只计数该列非 NULL 的行数（忽略 NULL）。</li></ul><p><strong>优化点</strong></p><ul><li>若需要对全表计数并且不带 WHERE，使用 MyISAM（历史）会更快，但现代 InnoDB 下 <code>COUNT(*)</code> 需要扫描索引或全表（可用一列非 NULL 索引优化）。</li><li>若要快速统计大表某条件的行数，考虑维护计数缓存或实时物化表。</li></ul><hr><h3 id="18-SQL-聚合函数"><a href="#18-SQL-聚合函数" class="headerlink" title="18. SQL 聚合函数"></a>18. SQL 聚合函数</h3><ul><li><strong>聚合函数</strong>：<code>COUNT()</code>、<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>、<code>MIN()</code>、<code>GROUP_CONCAT()</code>。</li><li><strong>实现细节</strong>：<ul><li>GROUP BY 会触发临时表和排序（若没有索引辅助），大数据量上会产生 <code>Using temporary; Using filesort</code>。</li><li>对于 <code>SUM</code>&#x2F;<code>AVG</code> 等，利用合适索引或预聚合表（materialized view）能显著提速。</li></ul></li><li><strong>优化</strong>：<ul><li>对 group by 列建立联合索引可避免 filesort。</li><li>对频繁统计的维度表考虑预计算或 OLAP 引擎（ClickHouse、Druid、Presto）。</li></ul></li></ul><hr><h3 id="19-WHERE-与-HAVING-的区别）"><a href="#19-WHERE-与-HAVING-的区别）" class="headerlink" title="19. WHERE 与 HAVING 的区别）"></a>19. WHERE 与 HAVING 的区别）</h3><ul><li><strong>WHERE</strong>：在分组前对行做过滤（作用于源数据）。性能高，尽量把能在 WHERE 过滤的条件写在 WHERE。</li><li><strong>HAVING</strong>：在 <code>GROUP BY</code> 后对分组后的聚合结果过滤（可以使用聚合函数，如 <code>HAVING SUM(x) &gt; 100</code>）。HAVING 需要先产生分组结果，成本较高。</li></ul><p><strong>示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_id, <span class="built_in">SUM</span>(amount) total</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;paid&#x27;</span>  <span class="comment">-- 先过滤行</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(amount) <span class="operator">&gt;</span> <span class="number">1000</span>;  <span class="comment">-- 再过滤分组</span></span><br></pre></td></tr></table></figure><hr><h3 id="20-EXISTS-与-IN-的区别（含-NULL-语义差异）"><a href="#20-EXISTS-与-IN-的区别（含-NULL-语义差异）" class="headerlink" title="20. EXISTS 与 IN 的区别（含 NULL&#x2F;语义差异）"></a>20. EXISTS 与 IN 的区别（含 NULL&#x2F;语义差异）</h3><p><strong>语义</strong></p><ul><li><code>IN</code>（子查询）通常会先执行子查询（或优化成半连接）并在结果集上做匹配。</li><li><code>EXISTS</code> 是相关子查询逐行判断，只要子查询对外层行存在匹配就返回 true（内层子查询常以 correlated subquery 形式出现）。</li></ul><p><strong>执行差异</strong></p><ul><li>对于非相关子查询，优化器可能将 <code>IN</code> 重写成 semi-join（性能接近）。</li><li>对于相关子查询，<code>EXISTS</code> 通常更高效（提前短路），尤其当内层表有合适索引能快速定位时。</li></ul><p><strong>NULL 语义</strong></p><ul><li><code>IN</code> 的子查询结果中若存在 <code>NULL</code>，在某些情况下会改变逻辑（导致不直观的行为），需谨慎。</li><li>示例差异：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设 subquery 返回 (1, NULL)</span></span><br><span class="line">a <span class="keyword">IN</span> (<span class="keyword">SELECT</span> b <span class="keyword">FROM</span> t)  <span class="comment">-- 结果的真值取决于 a 与 NULL 的比较，可能为 UNKNOWN</span></span><br></pre></td></tr></table></figure><p><strong>实践建议</strong></p><ul><li>对于子查询较大或有相关情况，偏好 <code>EXISTS</code> 或改写为 JOIN&#x2F;SEMI-JOIN。</li><li>对于小静态列表（常量 list），<code>IN (v1,v2,...)</code> 非常合适。</li></ul><hr><h3 id="21-SQL-注入-及-防范"><a href="#21-SQL-注入-及-防范" class="headerlink" title="21. SQL 注入 及 防范"></a>21. SQL 注入 及 防范</h3><p><strong>原理</strong></p><ul><li>直接拼接字符串会把用户输入当成 SQL 代码执行，例如 <code>&quot;... WHERE id = &quot; + userInput</code>，若用户输入 <code>1 OR 1=1</code>，将变为总是为真的条件。</li></ul><p><strong>防护措施</strong></p><ol><li><p><strong>参数化查询 &#x2F; PreparedStatement</strong>（最重要）：使用占位符 <code>?</code>，数据库驱动负责转义与类型校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE login = ?&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">1</span>, userInput);</span><br></pre></td></tr></table></figure></li><li><p><strong>白名单校验</strong>：对于列名、表名、排序字段等必须是字符串拼接处，先用白名单校验（只允许预定义值）。</p></li><li><p><strong>最小权限原则</strong>：数据库账号只授予必要权限（应用不能用 root）。</p></li><li><p><strong>防火墙&#x2F;代理</strong>：使用 SQL 防火墙、WAF、审计机制。</p></li><li><p><strong>ORM&#x2F;框架功能</strong>：使用框架的查询构建器减少手写 SQL。</p></li><li><p><strong>日志与检测</strong>：监控异常模式、慢查询、尝试注入字符串。</p></li></ol><p><strong>面试点</strong>：能举出具体注入示例、解释 PreparedStatement 原理（预编译、参数绑定）并能说明白名单的作用。</p><h4 id="SQL-注入-—-原理与典型示例"><a href="#SQL-注入-—-原理与典型示例" class="headerlink" title="SQL 注入 — 原理与典型示例"></a>SQL 注入 — 原理与典型示例</h4><p><strong>原理（本质）</strong>：当把不可信输入直接拼接到 SQL 文本里时，攻击者可以构造输入，使其成为 SQL 语句的一部分（即“把数据当成代码”），从而改变语句逻辑或执行额外命令。</p><p><strong>常见注入类型与示例</strong>：</p><ol><li><p><strong>基于布尔&#x2F;联合（Union &#x2F; OR）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vulnerable</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE id = &quot;</span> + userInput;</span><br><span class="line"><span class="comment">// userInput = &quot;1 OR 1=1&quot; -&gt; SELECT * FROM users WHERE id = 1 OR 1=1</span></span><br></pre></td></tr></table></figure><p>结果：泄露全表数据或绕过认证。</p></li><li><p><strong>基于错误（Error-based）</strong><br> 构造使 DB 抛错误，从错误信息中泄露数据&#x2F;结构。</p></li><li><p><strong>联合查询（UNION）注入</strong><br> 在查询后追加 <code>UNION SELECT ...</code> 来读取其它表数据。</p></li><li><p><strong>时间盲注 &#x2F; 布尔盲注</strong><br> 无直接输出时通过 <code>IF(condition, SLEEP(5), 0)</code> 等观察响应延迟或真假分支来抽取数据。</p></li><li><p><strong>存储&#x2F;二次注入</strong><br> 恶意 payload 存入 DB，后续在另一处被拼接执行造成注入。</p></li></ol><h4 id="防护措施（核心与实践）"><a href="#防护措施（核心与实践）" class="headerlink" title="防护措施（核心与实践）"></a>防护措施（核心与实践）</h4><h5 id="1-参数化查询-PreparedStatement（最重要）"><a href="#1-参数化查询-PreparedStatement（最重要）" class="headerlink" title="1. 参数化查询 &#x2F; PreparedStatement（最重要）"></a>1. 参数化查询 &#x2F; PreparedStatement（最重要）</h5><p><strong>示例（Java）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE login = ?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, userInput);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br></pre></td></tr></table></figure><p><strong>为什么能防注入</strong>：</p><ul><li><strong>分离代码与数据</strong>：占位符 <code>?</code> 在 SQL 语法中固定，参数作为数据绑定，不会被解析为 SQL 关键字或语句片段。</li><li><strong>类型和转义由驱动&#x2F;数据库负责</strong>：参数在发送到 DB 前&#x2F;或由 DB 端绑定为常量值。</li><li><strong>预编译（可缓存执行计划）</strong>：数据库通常把 SQL 模板编译成执行计划，再把参数绑定执行（这也是性能加成）。注意：某些 JDBC 驱动对 PreparedStatement 可能做客户端仿真，但即便仿真也会做正确的转义&#x2F;绑定，仍比拼接安全得多。</li></ul><p><strong>面试加分点</strong>：</p><ul><li>说明预编译的细节：服务器端预编译 + 参数绑定，可防止注入并提升性能（减少解析开销）。</li><li>补充：某些驱动&#x2F;DB 在网络层实现参数化或驱动端模拟，仍能防止注入，但最好确认驱动实现。</li></ul><h5 id="2-白名单校验（用于标识符、排序字段等不能用占位符的场景）"><a href="#2-白名单校验（用于标识符、排序字段等不能用占位符的场景）" class="headerlink" title="2. 白名单校验（用于标识符、排序字段等不能用占位符的场景）"></a>2. 白名单校验（用于标识符、排序字段等不能用占位符的场景）</h5><ul><li><p>占位符不能替换 SQL 标识符（如列名、表名、ORDER BY 字段）——这些必须在 SQL 文本中写出或拼接。此时<strong>必须用白名单</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; allowedSort = Set.of(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;created_at&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!allowedSort.contains(userSort)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users ORDER BY &quot;</span> + userSort;</span><br></pre></td></tr></table></figure></li><li><p>白名单保证只允许预期的、安全的标识符，拒绝任意输入。</p></li></ul><h5 id="3-最小权限原则"><a href="#3-最小权限原则" class="headerlink" title="3. 最小权限原则"></a>3. 最小权限原则</h5><ul><li>应用使用的 DB 账户应只授予必要权限（SELECT&#x2F;INSERT&#x2F;UPDATE&#x2F;DELETE 的子集），不要用 <code>root</code> 或高权限账号执行应用 SQL，限制损害面。</li></ul><h5 id="4-输入验证与输出转义（辅助）"><a href="#4-输入验证与输出转义（辅助）" class="headerlink" title="4. 输入验证与输出转义（辅助）"></a>4. 输入验证与输出转义（辅助）</h5><ul><li>对长度、格式、字符集做验证（但不要把它当作唯一防线）。</li><li>对动态生成给 UI 的内容做适当转义（防 XSS），与注入防护属于不同层。</li></ul><h5 id="5-使用-ORM-查询构建器（并正确使用参数化-API）"><a href="#5-使用-ORM-查询构建器（并正确使用参数化-API）" class="headerlink" title="5. 使用 ORM &#x2F; 查询构建器（并正确使用参数化 API）"></a>5. 使用 ORM &#x2F; 查询构建器（并正确使用参数化 API）</h5><ul><li>现代 ORM（Hibernate、MyBatis）提供参数化接口和占位符，正确使用能避免绝大多数注入问题。</li><li><strong>但注意</strong>：不要把用户输入直接拼接成 HQL&#x2F;SQL&#x2F;OrderBy 字符串。</li></ul><h5 id="6-防火墙-监控-审计"><a href="#6-防火墙-监控-审计" class="headerlink" title="6. 防火墙 &#x2F; 监控 &#x2F; 审计"></a>6. 防火墙 &#x2F; 监控 &#x2F; 审计</h5><ul><li>使用 WAF&#x2F;数据库防火墙检测异常 SQL 模式（如 <code>UNION SELECT</code>、注入特征）并阻断。</li><li>日志与告警：监控异常查询、慢查询、重复错误模式。</li></ul><h5 id="7-不要直接反序列化不可信数据-避免-eval"><a href="#7-不要直接反序列化不可信数据-避免-eval" class="headerlink" title="7. 不要直接反序列化不可信数据 &#x2F; 避免 eval"></a>7. 不要直接反序列化不可信数据 &#x2F; 避免 eval</h5><ul><li>不要 eval 字符串形成 SQL 或通过反序列化直接执行任意语句。</li></ul><h4 id="示例对比（易读）"><a href="#示例对比（易读）" class="headerlink" title="示例对比（易读）"></a>示例对比（易读）</h4><p><strong>易被注入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE name = &#x27;&quot;</span> + userInput + <span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure><p>若 <code>userInput = &quot;a&#39; OR &#39;1&#39;=&#39;1&quot;</code> -&gt; 成为 SQL</p><p><strong>安全写法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE name = ?&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">1</span>, userInput);</span><br></pre></td></tr></table></figure><h4 id="其他面试可能追问与简洁回答要点"><a href="#其他面试可能追问与简洁回答要点" class="headerlink" title="其他面试可能追问与简洁回答要点"></a>其他面试可能追问与简洁回答要点</h4><ul><li><strong>Stored procedures 能否防注入？</strong><ul><li>如果所有输入都作为参数传入存储过程，并在 DB 端使用参数化执行，能降低风险；但存储过程内部若动态拼接 SQL 仍存在注入风险。不是万灵药。</li></ul></li><li><strong>为何不能对所有输入只做简单转义？</strong><ul><li>转义容易出错、依赖数据库方言、容易遗漏边界条件；参数化更稳健。</li></ul></li><li><strong>如何防盲注（time-based）？</strong><ul><li>参数化 + 严格 SQL 构造；WAF 可检测可疑延时查询；限制返回信息和错误信息。</li></ul></li><li><strong>PreparedStatement 性能问题？</strong><ul><li>预编译使数据库可以缓存执行计划（提升性能）。在高并发 &#x2F; 批量场景下，PreparedStatement 通常更快。</li></ul></li><li><strong>如何处理动态列&#x2F;表名？</strong><ul><li>只能用白名单或映射表（不要直接用用户输入）。</li></ul></li></ul><h4 id="面试一分种快速答法（可背）"><a href="#面试一分种快速答法（可背）" class="headerlink" title="面试一分种快速答法（可背）"></a>面试一分种快速答法（可背）</h4><ul><li><strong>原理</strong>：注入是把用户数据当作 SQL 代码执行。</li><li><strong>首要防护</strong>：使用参数化查询 &#x2F; PreparedStatement（分离代码与数据）。</li><li><strong>补充策略</strong>：白名单（用于列名&#x2F;排序等标识符）、最小权限、ORM + 参数化 API、WAF&#x2F;监控、不要反序列化&#x2F;执行不可信输入。</li><li><strong>示例</strong>：展示一个拼接示例导致 <code>OR 1=1</code>，再给出 PreparedStatement 安全写法。</li></ul><hr><h3 id="22-将一张表部分数据更新到另一张表（多种方式）"><a href="#22-将一张表部分数据更新到另一张表（多种方式）" class="headerlink" title="22. 将一张表部分数据更新到另一张表（多种方式）"></a>22. 将一张表部分数据更新到另一张表（多种方式）</h3><p><strong>场景</strong>：用 tableA 的某列更新 tableB。</p><p><strong>写法 A：JOIN 更新（常见且高效）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tableB b</span><br><span class="line"><span class="keyword">JOIN</span> tableA a <span class="keyword">ON</span> a.id <span class="operator">=</span> b.id</span><br><span class="line"><span class="keyword">SET</span> b.col <span class="operator">=</span> a.col</span><br><span class="line"><span class="keyword">WHERE</span> a.some_condition;</span><br></pre></td></tr></table></figure><p><strong>写法 B：子查询方式</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tableB b</span><br><span class="line"><span class="keyword">SET</span> b.col <span class="operator">=</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> a.col <span class="keyword">FROM</span> tableA a <span class="keyword">WHERE</span> a.id <span class="operator">=</span> b.id LIMIT <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> tableA a <span class="keyword">WHERE</span> a.id <span class="operator">=</span> b.id <span class="keyword">AND</span> a.some_condition);</span><br></pre></td></tr></table></figure><p><strong>写法 C：INSERT … ON DUPLICATE KEY UPDATE</strong>（当要插入或更新）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> tableB (id, col)</span><br><span class="line"><span class="keyword">SELECT</span> id, col <span class="keyword">FROM</span> tableA <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> col <span class="operator">=</span> <span class="keyword">VALUES</span>(col);</span><br></pre></td></tr></table></figure><p><strong>实践说明</strong></p><ul><li>JOIN 方式通常速度更快（单次扫描，优化器能做更好 join order）。</li><li>注意事务与锁（大批量更新建议分批处理）。</li></ul><hr><h3 id="23-如何将行转成列（行列转换-Pivot）——常见-SQL-模式"><a href="#23-如何将行转成列（行列转换-Pivot）——常见-SQL-模式" class="headerlink" title="23. 如何将行转成列（行列转换 &#x2F; Pivot）——常见 SQL 模式"></a>23. 如何将行转成列（行列转换 &#x2F; Pivot）——常见 SQL 模式</h3><p><strong>方式 A：聚合 + CASE（最通用）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> type<span class="operator">=</span><span class="string">&#x27;A&#x27;</span> <span class="keyword">THEN</span> val <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> A,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> type<span class="operator">=</span><span class="string">&#x27;B&#x27;</span> <span class="keyword">THEN</span> val <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">FROM</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> id;</span><br></pre></td></tr></table></figure><p><strong>方式 B：使用 GROUP_CONCAT（拼接）</strong>（当列类型多样且不定时）<br> <strong>方式 C：动态列 Pivot（需要动态 SQL）</strong></p><ul><li>若列类型不可预知，生成动态 SQL（查询 distinct 值并拼接 CASE 子句）。</li></ul><p><strong>性能考虑</strong></p><ul><li>Pivot 多数需要扫描并分组，依赖 group by 索引&#x2F;分区来加速；对大表要慎用或基于物化视图&#x2F;ETL 做离线计算。</li></ul><hr><h3 id="24-表之间如何关联（关联方式详解）"><a href="#24-表之间如何关联（关联方式详解）" class="headerlink" title="24. 表之间如何关联（关联方式详解）"></a>24. 表之间如何关联（关联方式详解）</h3><p><strong>常用方式</strong></p><ul><li><strong>JOIN（内联&#x2F;外联）</strong>：按条件联表（最常见）。</li><li><strong>外键（FK）约束</strong>：数据库层面保障参照完整性（但大量外键在高并发写场景会影响性能）。</li><li><strong>应用层关联</strong>：在代码层把多个小查询组装（用于跨库或性能考量）。</li><li><strong>基于索引的查找（子查询&#x2F;EXISTS）</strong>：有时 <code>EXISTS</code> 更高效。</li></ul><p><strong>实践选择</strong></p><ul><li>小表 join 大表用 hash join &#x2F; nested loop 视执行计划；对分库分表场景，避免跨库 join（改在应用层做聚合或使用分布式查询引擎）。</li></ul><hr><h3 id="25-INNER-LEFT-RIGHT-JOIN-的区别（带例子）"><a href="#25-INNER-LEFT-RIGHT-JOIN-的区别（带例子）" class="headerlink" title="25. INNER &#x2F; LEFT &#x2F; RIGHT JOIN 的区别（带例子）"></a>25. INNER &#x2F; LEFT &#x2F; RIGHT JOIN 的区别（带例子）</h3><ul><li><strong>INNER JOIN</strong>：返回两表交集（满足 join 条件的行）。</li><li><strong>LEFT JOIN</strong>：返回左表所有行 + 匹配右表的行（右表无匹配则为 NULL）。</li><li><strong>RIGHT JOIN</strong>：返回右表所有行 + 匹配左表的行（左表无匹配则为 NULL）。</li></ul><p><strong>示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- inner</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.aid;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- left</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.aid;</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：LEFT JOIN 很多时候在逻辑上需要做 <code>WHERE B.id IS NULL</code> 来实现“左表存在右表不存在”的 anti-join（查找孤立记录），性能会受影响，建议用 <code>NOT EXISTS</code> 或 <code>NOT IN</code>（注意 NULL 行）做替代。</p><hr><h3 id="26-为什么不推荐多表-JOIN？"><a href="#26-为什么不推荐多表-JOIN？" class="headerlink" title="26. 为什么不推荐多表 JOIN？"></a>26. 为什么不推荐多表 JOIN？</h3><p><strong>问题多出自以下几点</strong></p><ol><li><strong>成本指数增长</strong>：多表 join（尤其大表）会产生巨大的中间集（笛卡尔扩展风险），优化器不得当时性能爆炸。</li><li><strong>跨库无法 JOIN</strong>：分库分表后跨库 JOIN 太昂贵或不支持。</li><li><strong>可维护性差</strong>：SQL 复杂、难读、难改，调试困难。</li><li><strong>优化器依赖统计</strong>：索引&#x2F;统计不准时，join 顺序选择差导致大代价执行计划。</li></ol><p><strong>替代方案</strong></p><ul><li><strong>应用层聚合</strong>：逐表查询并在应用层合并（适合分布式场景）。</li><li><strong>预计算&#x2F;物化</strong>：把复杂 join 结果写入聚合表（定期 ETL）。</li><li><strong>使用 OLAP 引擎 &#x2F; 搜索引擎</strong>：对于分析场景，使用专门的数据仓库（ClickHouse&#x2F;Presto）或搜索（Elasticsearch）。</li></ul><hr><h3 id="27-SQL-调优常见方法"><a href="#27-SQL-调优常见方法" class="headerlink" title="27. SQL 调优常见方法"></a>27. SQL 调优常见方法</h3><ol><li><strong>索引策略</strong><ul><li>建覆盖索引、联合索引（按查询顺序）、避免冗余。</li></ul></li><li><strong>重写 SQL</strong><ul><li>避免函数作用于索引列，避免 <code>SELECT *</code>，拆分复杂查询。</li></ul></li><li><strong>分区&#x2F;分库分表</strong><ul><li>水平分表（sharding）、分区表（MySQL partition）减少扫描边界。</li></ul></li><li><strong>缓存</strong><ul><li>热点数据用缓存（Redis）；页面&#x2F;查询使用缓存策略。</li></ul></li><li><strong>物化&#x2F;预聚合</strong><ul><li>预计算汇总表&#x2F;物化视图。</li></ul></li><li><strong>避免大事务</strong><ul><li>小批量提交，避免锁膨胀与 undo&#x2F;redo 压力。</li></ul></li><li><strong>使用批量操作</strong><ul><li>批量 insert&#x2F;replace&#x2F;insert…on duplicate，使用 LOAD DATA INFILE。</li></ul></li><li><strong>避免无索引排序&#x2F;分组</strong><ul><li>为 ORDER BY&#x2F;GROUP BY 列建立索引，使之成为 index-only 操作。</li></ul></li><li><strong>分析执行计划</strong><ul><li>EXPLAIN&#x2F;EXPLAIN ANALYZE、慢查询日志、pt-query-digest 来定位瓶颈。</li></ul></li><li><strong>硬件与配置</strong><ul><li>调整 Buffer Pool（InnoDB）、innodb_flush_log_at_trx_commit、innodb_buffer_pool_instances、tmp_table_size、max_heap_table_size 等。</li></ul></li></ol><hr><h3 id="28-如何监控并优化慢-SQL）"><a href="#28-如何监控并优化慢-SQL）" class="headerlink" title="28. 如何监控并优化慢 SQL）"></a>28. 如何监控并优化慢 SQL）</h3><p><strong>监控</strong></p><ul><li>打开 <code>slow_query_log</code> 并设置合适阈值与日志轮转。</li><li>使用 <code>pt-query-digest</code> 或线上 APM（Pinpoint、SkyWalking、Datadog）做聚合分析。</li></ul><p><strong>分析流程</strong></p><ol><li>收集慢 SQL（按耗时&#x2F;锁&#x2F;scan 行数排序）。</li><li>对单条慢 SQL 执行 <code>EXPLAIN</code> 分析，关注 <code>type</code> 与 <code>rows</code>。</li><li>检查索引覆盖性、是否 filesort 或 temporary。</li><li>若是锁等待导致慢，查看 <code>SHOW ENGINE INNODB STATUS</code> 或 <code>INNODB_TRX</code>、<code>PROCESSLIST</code> 诊断锁冲突。</li><li>重写 SQL 或加索引并用 <code>EXPLAIN</code> 验证。</li></ol><p><strong>线上处置</strong></p><ul><li>在高峰直接用 <code>pt-kill</code>&#x2F;慢查询阻断&#x2F;限流短时缓解（谨慎）。</li><li>对于极耗时的聚合，建议用异步&#x2F;批处理&#x2F;预计算。</li></ul><hr><h3 id="29-如何高效批量插入数据"><a href="#29-如何高效批量插入数据" class="headerlink" title="29. 如何高效批量插入数据"></a>29. 如何高效批量插入数据</h3><ol><li><p><strong>多值 INSERT</strong>（比逐条插入快很多）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> t (a,b) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>LOAD DATA INFILE</strong>（最快，适合导入 CSV）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">&#x27;/tmp/data.csv&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> t FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> (a,b,c);</span><br></pre></td></tr></table></figure></li><li><p><strong>禁用索引&#x2F;约束后导入</strong>（谨慎）：</p><ul><li>对 MyISAM 可 <code>ALTER TABLE t DISABLE KEYS</code> 导入后 <code>ENABLE KEYS</code>，对 InnoDB 不适用同样方式，建议分批或临时删除二级索引后导入再重建。</li></ul></li><li><p><strong>控制事务大小</strong>：大批量分成多个事务（如每 5k 行一提交）以避免过大 undo&#x2F;redo。</p></li><li><p><strong>关闭二进制日志（临时）</strong>：在可接受风险下短时关闭 binlog 可提速，但会丢失复制&#x2F;恢复能力（通常不建议在生产主库上做）。</p></li><li><p><strong>使用并发导入</strong>：分表并发导入，每个线程导入不同数据段（受 IO&#x2F;CPU 限制）。</p></li></ol><hr><h3 id="30-大表（千万级）查询-维护"><a href="#30-大表（千万级）查询-维护" class="headerlink" title="30. 大表（千万级）查询 &#x2F; 维护"></a>30. 大表（千万级）查询 &#x2F; 维护</h3><p><strong>设计阶段</strong></p><ul><li>逻辑分库分表：按业务或哈希分片分布数据，减少单表压力。</li><li>分区表（range&#x2F;list&#x2F;hash）用于热冷分离与分区裁剪（partition pruning）。</li></ul><p><strong>索引与查询</strong></p><ul><li>给热点查询建覆盖索引，避免回表。</li><li>使用分区键&#x2F;分片键作为查询条件以利用分区 &#x2F; 分片定向扫描。</li></ul><p><strong>维护</strong></p><ul><li><strong>分批删除</strong>（不要一次性 delete 大量行）：<ul><li>分段删除 <code>DELETE FROM t WHERE id BETWEEN x AND y</code> 每次限制 batch size。</li><li>或使用 <code>ALTER TABLE ... DROP PARTITION</code>（若按时间分区）来快速删除历史数据。</li></ul></li><li><strong>重建索引</strong>：在线工具（gh-ost &#x2F; pt-online-schema-change）做 index rebuild。</li><li><strong>归档</strong>：将历史冷数据移出到分析库或对象存储。</li><li><strong>监控</strong>：慢查询、表扫描、锁等待、IO 使用情况。</li></ul><p><strong>备份</strong></p><ul><li>使用物理备份（XtraBackup）做热备份，避免在线 mysqldump 导致性能问题。</li></ul><hr><h3 id="31-DELETE、TRUNCATE、DROP-区别"><a href="#31-DELETE、TRUNCATE、DROP-区别" class="headerlink" title="31. DELETE、TRUNCATE、DROP 区别"></a>31. DELETE、TRUNCATE、DROP 区别</h3><p><strong>DELETE</strong></p><ul><li>DML 操作，逐行删除（执行 DELETE 语句会为每行生成 undo&#x2F;redo），触发器触发，事务可回滚。</li><li>对大表慢且会产生大量 undo&#x2F;log。</li></ul><p><strong>TRUNCATE</strong></p><ul><li>DDL 操作（在 MySQL 中通常为 drop + create 或快速清空表），效果等同于删除所有数据并重置 AUTO_INCREMENT（实现依引擎不同）。</li><li>通常不可回滚（会隐式提交当前事务）。</li><li>快速、不会逐行触发 DELETE 触发器（因为不是逐行删除）。</li></ul><p><strong>DROP</strong></p><ul><li>删除整个表结构与数据，删除后元数据也不存在。</li><li>同样通常是 DDL、会释放表空间（取决于引擎&#x2F;配置）。</li></ul><p><strong>实践建议</strong></p><ul><li>需要可回滚删除历史数据：做分批 DELETE 并通过事务或备份策略应对回滚需求。</li><li>需要快速清空表（并接受隐式提交）：用 TRUNCATE。</li><li>需要删除表与结构：DROP。</li></ul><h2 id="Java多线程-牛客面经八股"><a href="#Java多线程-牛客面经八股" class="headerlink" title="Java多线程-牛客面经八股"></a>Java多线程-牛客面经八股</h2><hr><h3 id="1-线程的创建方式（Java-中常见-4-种、及实际工程常用模式）"><a href="#1-线程的创建方式（Java-中常见-4-种、及实际工程常用模式）" class="headerlink" title="1. 线程的创建方式（Java 中常见 4 种、及实际工程常用模式）"></a>1. 线程的创建方式（Java 中常见 4 种、及实际工程常用模式）</h3><p><strong>方式 A — 继承 <code>Thread</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br></pre></td></tr></table></figure><ul><li>优点：直观。</li><li>缺点：无法共享 Runnable，再继承受限。</li></ul><p><strong>方式 B — 实现 <code>Runnable</code></strong>（最常用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; <span class="comment">/* ... */</span> &#125; &#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyTask</span>()).start();</span><br></pre></td></tr></table></figure><ul><li>优点：任务与线程分离，能被线程池复用。</li></ul><p><strong>方式 C — 实现 <code>Callable&lt;V&gt;</code> + <code>FutureTask</code></strong>（可返回值、可抛异常）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; c = () -&gt; <span class="number">42</span>;</span><br><span class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(c);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(ft).start();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();</span><br></pre></td></tr></table></figure><ul><li>常与 <code>ExecutorService.submit(callable)</code> 配合使用。</li></ul><p><strong>方式 D — 通过 <code>ExecutorService</code> &#x2F; 线程池</strong>（推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">pool.submit(() -&gt; &#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li>生产环境首选；管理线程生命周期、复用、任务队列、异常处理。</li></ul><p><strong>补充：Fork&#x2F;Join 与虚拟线程</strong></p><ul><li><code>ForkJoinPool</code> &#x2F; <code>RecursiveTask</code>：用于分治并行计算。</li><li>JDK 19+ Project Loom：虚拟线程（轻量级，数十万并发）——尚在演进，注意与同步&#x2F;阻塞交互。</li></ul><hr><h3 id="2-线程的生命周期和状态（Java-Thread-State）"><a href="#2-线程的生命周期和状态（Java-Thread-State）" class="headerlink" title="2. 线程的生命周期和状态（Java Thread.State）"></a>2. 线程的生命周期和状态（Java Thread.State）</h3><p><strong>六种状态</strong>（Java 枚举 <code>Thread.State</code>）：</p><ul><li><code>NEW</code>：刚创建，未调用 <code>start()</code>。</li><li><code>RUNNABLE</code>：可运行或正在运行（在 JVM&#x2F;OS 中可能是 runnable 或 running）。</li><li><code>BLOCKED</code>：阻塞在 monitor（即等待进入 <code>synchronized</code> 的监视器）。</li><li><code>WAITING</code>：等待另一个线程显式唤醒（<code>Object.wait()</code> &#x2F; <code>Thread.join()</code> &#x2F; <code>LockSupport.park()</code>）——无限期等待。</li><li><code>TIMED_WAITING</code>：带超时的等待（<code>sleep(ms)</code>、带 timeout 的 <code>wait</code>&#x2F;<code>join</code>&#x2F;<code>parkNanos</code>）。</li><li><code>TERMINATED</code>：已执行完毕或发生未捕获异常导致终止。</li></ul><p><strong>典型状态转移</strong></p><ul><li><code>NEW</code> -&gt; <code>start()</code> -&gt; <code>RUNNABLE</code></li><li><code>RUNNABLE</code> -&gt; <code>sleep()</code> -&gt; <code>TIMED_WAITING</code> -&gt; 超时 -&gt; <code>RUNNABLE</code></li><li><code>RUNNABLE</code> -&gt; <code>synchronized</code> 被其他线程持有 -&gt; <code>BLOCKED</code> -&gt; 获得锁 -&gt; <code>RUNNABLE</code></li><li><code>RUNNABLE</code> -&gt; <code>wait()</code> -&gt; <code>WAITING</code> -&gt; <code>notify()</code> -&gt; <code>RUNNABLE</code></li><li><code>RUNNABLE</code> -&gt; 结束执行 -&gt; <code>TERMINATED</code></li></ul><p><strong>面试点</strong>：<code>RUNNABLE</code> 在 JVM 层既包含“可运行队列”也包含“正在运行（OS thread）”两种含义；<code>BLOCKED</code> 专指等待 monitor。</p><hr><h3 id="3-wait-与-sleep-的区别（关键点）"><a href="#3-wait-与-sleep-的区别（关键点）" class="headerlink" title="3. wait() 与 sleep() 的区别（关键点）"></a>3. <code>wait()</code> 与 <code>sleep()</code> 的区别（关键点）</h3><table><thead><tr><th>特性</th><th><code>wait()</code>（Object）</th><th><code>sleep()</code>（Thread）</th></tr></thead><tbody><tr><td>是否释放锁</td><td><strong>释放当前对象监视器锁</strong>（必须在同步块&#x2F;方法内调用）</td><td><strong>不释放锁</strong>（不需要在同步块）</td></tr><tr><td>所在类</td><td><code>Object</code>（每个对象有 wait set）</td><td><code>Thread</code></td></tr><tr><td>被唤醒方式</td><td><code>notify()</code> &#x2F; <code>notifyAll()</code> 或 InterruptedException</td><td>超时或被中断（<code>interrupt()</code>）</td></tr><tr><td>适用场景</td><td>线程间协调（生产&#x2F;消费），需要条件等待</td><td>线程暂停，不用于线程间协作（定时）</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!condition) lock.wait(); <span class="comment">// releases lock</span></span><br><span class="line">  <span class="comment">// 被唤醒且重获锁后继续</span></span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>); <span class="comment">// 不释放锁</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-线程同步方式"><a href="#4-线程同步方式" class="headerlink" title="4. 线程同步方式"></a>4. 线程同步方式</h3><ol><li><strong>内置锁（synchronized）</strong>：基于对象监视器（monitor），支持重入、wait&#x2F;notify、JVM 优化（偏向、轻量级、重量级）。</li><li><strong>显式锁（<code>java.util.concurrent.locks.Lock</code>）</strong>：<code>ReentrantLock</code>、<code>ReadWriteLock</code>，支持可中断锁获取、<code>tryLock</code>、<code>Condition</code>。</li><li><strong>AQS（AbstractQueuedSynchronizer）+ 基于队列的同步器</strong>：ReentrantLock、Semaphore、CountDownLatch、FutureTask 等底层支持类。</li><li><strong>原子变量（<code>java.util.concurrent.atomic</code>）</strong>：CAS（<code>AtomicInteger</code>、<code>AtomicReference</code>）、乐观并发，不阻塞。</li><li><strong>并发集合</strong>：<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>BlockingQueue</code> 等内部有并发控制。</li><li><strong>并发工具类</strong>：<code>Semaphore</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Phaser</code>（协调线程）等。</li><li><strong>线程间通信</strong>：<code>wait/notify</code>、<code>Lock</code> + <code>Condition</code>、<code>BlockingQueue</code>（生产-消费模式里推荐<code>BlockingQueue</code>）。</li></ol><p><strong>建议</strong>：尽可能使用 <code>java.util.concurrent</code> 提供的高层抽象（线程池 + 阻塞队列 + 原子类）而不用自己低级实现。</p><hr><h3 id="5-synchronized-与-Lock-的区别"><a href="#5-synchronized-与-Lock-的区别" class="headerlink" title="5. synchronized 与 Lock 的区别"></a>5. <code>synchronized</code> 与 <code>Lock</code> 的区别</h3><p><strong>共同点</strong>：都能保证互斥与可见性（互斥与内存可见性由 JMM 和实现共同保证）。</p><p><strong><code>synchronized</code>（内置监视器）</strong></p><ul><li>优点：用法简单、异常安全（自动释放锁）、JVM 优化强（偏向锁、轻量级锁、锁消除&#x2F;合并）。</li><li>缺点：功能有限（不支持 <code>tryLock</code>、超时、可中断），不支持多个条件队列。</li></ul><p><strong><code>Lock</code>（显式锁）</strong></p><ul><li>优点：支持 <code>tryLock</code>、<code>lockInterruptibly</code>、可中断、支持超时、多个 <code>Condition</code>（类似多个 wait-set），更灵活。</li><li>缺点：编程复杂，必须在 finally 中 <code>unlock()</code>，否则易死锁；性能在低争用时可能和 <code>synchronized</code> 相近或稍慢，但高争用时 <code>ReentrantLock</code> 可优于 <code>synchronized</code>（尤其是公平&#x2F;非公平策略控制）。</li></ul><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">/* critical section */</span> &#125;</span><br><span class="line"><span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-synchronized-的用法及原理"><a href="#6-synchronized-的用法及原理" class="headerlink" title="6. synchronized 的用法及原理"></a>6. <code>synchronized</code> 的用法及原理</h3><p><strong>用法</strong></p><ul><li>修饰实例方法：<code>synchronized void m()</code> → 锁住 <code>this</code></li><li>修饰静态方法：<code>synchronized static void m()</code> → 锁住 Class 对象 (<code>Class&lt;?&gt;</code>)</li><li>同步代码块：<code>synchronized(lockObj) &#123; ... &#125;</code> → 锁住 <code>lockObj</code></li></ul><p><strong>实现原理（HotSpot）</strong></p><ul><li>JVM 层面：对象头（Mark Word）中存有锁标记，JVM 通过 CAS 操作对象头来尝试获取锁。</li><li>锁优化流程（热点优化）：<ol><li><strong>偏向锁</strong>（偏向单线程场景，避免 CAS）</li><li><strong>轻量级锁</strong>（使用 CAS 在栈上记录锁记录）</li><li><strong>重量级锁（monitor）</strong>（线程竞争时进入操作系统互斥锁，使用 OS mutex&#x2F;park&#x2F;unpark）</li></ol></li><li><code>monitorenter</code> &#x2F; <code>monitorexit</code> 字节码对应 JVM 的锁进入&#x2F;释放操作。</li><li><code>wait()</code>：会把线程放入对象的 wait-set，释放 monitor 并进入 WAITING；<code>notify()</code> 会把某线程从 wait-set 移入到 entry-list（竞争 monitor）。</li></ul><p><strong>重入性</strong>：同一线程重复获得同一 monitor，JVM 内部会记录递归计数，释放时减少计数。</p><p><strong>JVM 优化</strong>：JIT 可做锁消除（如逃逸分析）或锁粗化（合并多次临近锁）以减少开销。</p><hr><h3 id="7-对-AQS（AbstractQueuedSynchronizer）的理解（关键概念、内部结构与工作流程）"><a href="#7-对-AQS（AbstractQueuedSynchronizer）的理解（关键概念、内部结构与工作流程）" class="headerlink" title="7. 对 AQS（AbstractQueuedSynchronizer）的理解（关键概念、内部结构与工作流程）"></a>7. 对 AQS（AbstractQueuedSynchronizer）的理解（关键概念、内部结构与工作流程）</h3><p><strong>用途</strong>：AQS 是 JDK 提供的用于构建锁和同步器的基础框架（基于 FIFO 队列），<code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>FutureTask</code> 等都基于 AQS。</p><p><strong>核心字段</strong></p><ul><li><code>volatile int state</code>：表示同步状态（不同同步器含义不同，例如 <code>ReentrantLock</code> 用低位计重入，<code>Semaphore</code> 用作许可计数）。</li><li><code>volatile Node head, tail</code>：双向队列头尾，队列实现 CLH 风格（FIFO），节点代表线程等待队列。</li><li><code>Node</code> 的 <code>waitStatus</code>（CANCELLED,SIGNAL,CONDITION,PROPAGATE等）。</li></ul><p><strong>两种模式</strong></p><ul><li><strong>独占模式（Exclusive）</strong>：只有一个线程能占有（例如 <code>ReentrantLock</code> 的 writeLock）。<ul><li>API hook：<code>tryAcquire(int)</code>、<code>tryRelease(int)</code>、<code>isHeldExclusively()</code>。</li></ul></li><li><strong>共享模式（Shared）</strong>：多个线程可同时占有（例如 <code>Semaphore</code>, <code>ReadLock</code> 的一些实现）。<ul><li>API hook：<code>tryAcquireShared(int)</code>、<code>tryReleaseShared(int)</code>。</li></ul></li></ul><p><strong>获取锁的高层流程（独占）</strong></p><ol><li>调用 <code>acquire(arg)</code>。首先尝试 <code>tryAcquire(arg)</code>（子类实现）——若成功，直接返回。</li><li>若失败，线程封装为 Node 并入队（CAS 设置 tail）。</li><li>线程在队列中循序等待，前驱释放时唤醒后继线程（<code>unpark</code>），然后重试 <code>tryAcquire</code>，直到成功或超时&#x2F;中断。</li><li>释放时 <code>tryRelease</code> 被调用，成功后会 <code>unpark</code> 下一个等待线程。</li></ol><p><strong>Condition（条件队列）</strong><br> AQS 提供 <code>ConditionObject</code>，将等待线程放到 Condition 队列（与 AQS 队列分开），<code>await()</code> 会把当前线程迁移到 Condition 队列并释放同步状态，<code>signal()</code> 会把线程移回同步队列，等待获取锁。</p><p><strong>实现细节亮点</strong></p><ul><li>使用 <code>Unsafe.compareAndSwapInt</code> 做 state、head、tail 的原子更新（CAS）。</li><li><code>LockSupport.park/unpark</code> 用于线程挂起&#x2F;唤醒（比 <code>wait/notify</code> 更灵活，不要求持有 monitor）。</li><li>AQS 还处理中断、超时、取消节点、队列清理等复杂逻辑。</li></ul><hr><h3 id="8-如何创建线程池？线程池常见参数有哪些？（ThreadPoolExecutor-深入）"><a href="#8-如何创建线程池？线程池常见参数有哪些？（ThreadPoolExecutor-深入）" class="headerlink" title="8. 如何创建线程池？线程池常见参数有哪些？（ThreadPoolExecutor 深入）"></a>8. 如何创建线程池？线程池常见参数有哪些？（<code>ThreadPoolExecutor</code> 深入）</h3><p><strong>推荐方式</strong>：直接使用 <code>ThreadPoolExecutor</code> 构造（不要盲用 <code>Executors</code> 的工厂方法在生产环境，因其某些返回队列为无界会隐藏风险）。</p><p><strong>常用构造器参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(</span><br><span class="line">  <span class="type">int</span> corePoolSize,</span><br><span class="line">  <span class="type">int</span> maximumPoolSize,</span><br><span class="line">  <span class="type">long</span> keepAliveTime,</span><br><span class="line">  TimeUnit unit,</span><br><span class="line">  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">  ThreadFactory threadFactory,</span><br><span class="line">  RejectedExecutionHandler handler</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>corePoolSize</code>：核心线程数（默认维护即使空闲也不回收，除非 <code>allowCoreThreadTimeOut(true)</code>）。</li><li><code>maximumPoolSize</code>：最大线程数。</li><li><code>keepAliveTime</code>：非核心线程空闲存活时间。</li><li><code>workQueue</code>：任务队列（<code>ArrayBlockingQueue</code> &#x2F; <code>LinkedBlockingQueue</code> &#x2F; <code>SynchronousQueue</code> &#x2F; <code>PriorityBlockingQueue</code> 等）。</li><li><code>threadFactory</code>：创建线程（可定制名字、daemon、优先级、异常处理）。</li><li><code>handler</code>：拒绝策略（<code>AbortPolicy</code>、<code>CallerRunsPolicy</code>、<code>DiscardPolicy</code>、<code>DiscardOldestPolicy</code> 或自定义）。</li></ul><p><strong>执行策略（重要）</strong></p><ol><li>如果运行中的线程数 &lt; <code>corePoolSize</code>，立即启动新线程处理任务；</li><li>else 如果工作队列未满，任务入队；</li><li>else 如果线程数 &lt; <code>maximumPoolSize</code>，启动新线程处理任务；</li><li>else 拒绝任务（触发 <code>RejectedExecutionHandler</code>）。</li></ol><p><strong>线程池与队列配合示例</strong></p><ul><li><code>LinkedBlockingQueue</code>（默认无界）+ <code>maximumPoolSize</code> 无效（因为队列不满就入队）</li><li><code>SynchronousQueue</code>（零容量）强制快速扩展线程数，常与 <code>maximumPoolSize</code> 配合（适合短任务高并发）</li></ul><p><strong>线程池参数调优建议</strong></p><ul><li>CPU 密集型：<code>poolSize ≈ Ncpu</code> 或 <code>Ncpu+1</code>。</li><li>IO 密集型：<code>poolSize ≈ Ncpu * (1 + wait/io ratio)</code>。</li><li>使用 bounded queue + proper rejection handling + metrics（队列长度、活跃线程数、任务提交速率）才安全。</li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">  <span class="number">8</span>,  <span class="comment">// core</span></span><br><span class="line">  <span class="number">32</span>, <span class="comment">// max</span></span><br><span class="line">  <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">NamedThreadFactory</span>(<span class="string">&quot;worker-&quot;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="9-volatile-的用法及原理（Java-内存语义）"><a href="#9-volatile-的用法及原理（Java-内存语义）" class="headerlink" title="9. volatile 的用法及原理（Java 内存语义）"></a>9. <code>volatile</code> 的用法及原理（Java 内存语义）</h3><p><strong>语义</strong></p><ul><li><code>volatile</code> 变量具有 <strong>可见性</strong>：写入一个 volatile 变量后，对该变量的写入对随后读取该变量的所有线程可见（建立 <code>happens-before</code>）。</li><li>禁止指令重排序（部分）：volatile 写有 <strong>释放（release）语义</strong>，volatile 读有 <strong>获取（acquire）语义</strong>。写 <code>volatile</code> 之前的操作不会被搬到写之后；读 <code>volatile</code> 之后的操作不会被搬到读之前（强制内存屏障）。</li><li><strong>不保证原子性</strong>（复合操作如 <code>i++</code> 不是原子）。</li></ul><p><strong>实现原理（HotSpot）</strong></p><ul><li>Java 编译器&#x2F;CPU 内存屏障（fence）+ JVM intrinsics：volatile 写会产生 StoreStore + StoreLoad 屏障（或更严格），volatile 读会产生 LoadLoad + LoadStore 屏障，保证内存可见性和一定顺序。</li></ul><p><strong>典型使用场景</strong></p><ul><li>状态标志（<code>volatile boolean running</code>），用于停止线程。</li><li>双重检查锁（DCL）中 <code>volatile</code> 修饰单例（防止构造对象引用外逃）。</li><li>轻量级的可见性需求，不需完整锁开销的场景。</li></ul><p><strong>示例（停止线程）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (running) &#123; doWork(); &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123; running = <span class="literal">false</span>; &#125; <span class="comment">// 其他线程可立即看到</span></span><br></pre></td></tr></table></figure><hr><h3 id="10-ThreadLocal-的用法和实现原理（ThreadLocalMap）"><a href="#10-ThreadLocal-的用法和实现原理（ThreadLocalMap）" class="headerlink" title="10. ThreadLocal 的用法和实现原理（ThreadLocalMap）"></a>10. <code>ThreadLocal</code> 的用法和实现原理（ThreadLocalMap）</h3><p><strong>用途</strong></p><ul><li>为每个线程维护独立的变量副本（例如：用户上下文、SimpleDateFormat、DB session 等），避免锁竞争。</li></ul><p><strong>使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; TL =</span><br><span class="line">    ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line"></span><br><span class="line">Date <span class="title function_">parse</span><span class="params">(String s)</span> &#123; <span class="keyword">return</span> TL.get().parse(s); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必要时清理</span></span><br><span class="line">TL.remove();</span><br></pre></td></tr></table></figure><p><strong>实现原理</strong></p><ul><li>每个 <code>Thread</code> 对象内部维护一个 <code>ThreadLocalMap</code>（不是全局 map），键是 <code>ThreadLocal&lt;?&gt;</code> 的弱引用（<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>），值是强引用到实际对象。</li><li><code>ThreadLocalMap</code> 是数组 + open addressing（线性探测）实现，<code>ThreadLocal</code> 有自己的 hash（threadLocalHashCode）。</li></ul><p><strong>内存泄露风险（关键点）</strong></p><ul><li><code>ThreadLocal</code> 的 <strong>key</strong> 是弱引用，若你把 <code>ThreadLocal</code> 变量设为局部变量或在某个类中只保存弱引用并丢弃强引用，key 可能被 GC，但 <code>ThreadLocalMap</code> 中的该 entry 的 <strong>value</strong> 是强引用，<strong>不会自动被清理</strong>（直到下一次 <code>ThreadLocal</code> 操作或某次 <code>ThreadLocalMap</code> 执行 expungeStaleEntries）。</li><li>在使用线程池时线程不会死亡，ThreadLocal 的 value 若不显式 <code>remove()</code> 会一直占用内存 → 导致内存泄漏。<br> <strong>防范</strong>：在 <code>finally</code> 中调用 <code>remove()</code>，避免把 <code>ThreadLocal</code> 设为静态且不清理。</li></ul><hr><h3 id="11-Java-里的-CAS（Compare-And-Swap）（概念-使用）"><a href="#11-Java-里的-CAS（Compare-And-Swap）（概念-使用）" class="headerlink" title="11. Java 里的 CAS（Compare-And-Swap）（概念 + 使用）"></a>11. Java 里的 CAS（Compare-And-Swap）（概念 + 使用）</h3><p><strong>概念</strong></p><ul><li>CAS 是无锁编程的原子操作：比较内存中的某个位置的当前值 <code>V</code> 与期望值 <code>A</code>，若相等则将其更新为 <code>B</code>；否则不更新。返回是否成功。</li><li>Java 通过 <code>Unsafe.compareAndSwapInt/Long/Object</code> 或 <code>VarHandle</code> 提供 CAS。</li></ul><p><strong>常见用法</strong></p><ul><li><code>AtomicInteger</code>、<code>AtomicReference</code> 的 <code>compareAndSet()</code>。</li><li>在自旋循环中：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> expect, update;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  expect = atomic.get();</span><br><span class="line">  update = compute(expect);</span><br><span class="line">&#125; <span class="keyword">while</span> (!atomic.compareAndSet(expect, update));</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：避免阻塞、低延迟（无上下文切换）<br> <strong>缺点</strong>：高并发下自旋会浪费 CPU、需要重试（活跃性 vs 饥饿可能），存在 ABA 问题。</p><hr><h3 id="12-CAS-会出现什么问题？ABA-问题如何解决？"><a href="#12-CAS-会出现什么问题？ABA-问题如何解决？" class="headerlink" title="12. CAS 会出现什么问题？ABA 问题如何解决？"></a>12. CAS 会出现什么问题？ABA 问题如何解决？</h3><p><strong>问题</strong></p><ol><li><strong>ABA 问题</strong>：线程 T1 读取值 A；T2 把 A -&gt; B -&gt; A（短时间内）；T1 执行 CAS 发现仍为 A，误以为未被修改过。</li><li><strong>自旋开销</strong>：长时间重试浪费 CPU。</li><li><strong>只解决单变量原子性</strong>：复杂更新需要分步或额外同步。</li></ol><p><strong>解决 ABA 的常见方法</strong></p><ul><li><strong>版本号（带标记）</strong>：把值与版本（stamp）一起 CAS（<code>AtomicStampedReference</code>），每次修改版本号+1。CAS 检查不仅值还检查版本。</li><li><strong><code>AtomicMarkableReference</code>&#x2F;<code>AtomicStampedReference</code></strong>：JDK 提供两种封装用于区分状态。</li><li><strong>垃圾回收&#x2F;内存管理策略</strong>：在某些场景中使用 GC 或引用计数减少 ABA 可能性（语言&#x2F;平台相关）。</li></ul><hr><h3 id="13-Java-线程与操作系统线程区别（概念与-HotSpot-实现）"><a href="#13-Java-线程与操作系统线程区别（概念与-HotSpot-实现）" class="headerlink" title="13. Java 线程与操作系统线程区别（概念与 HotSpot 实现）"></a>13. Java 线程与操作系统线程区别（概念与 HotSpot 实现）</h3><p><strong>Java 线程（<code>java.lang.Thread</code>）</strong></p><ul><li>Java 层的抽象，描述执行单元。</li><li>HotSpot 自 JDK1.3 之后使用 <strong>1:1 映射</strong> 到 OS 原生线程（native threads）。早期某些 JVM 可能使用 green threads（用户级线程），但现在主流 JVM 都用 native threads。</li></ul><p><strong>区别&#x2F;联系</strong></p><ul><li><strong>调度</strong>：实际由操作系统调度（time slice, priority）；JVM 可以调用 <code>park</code>&#x2F;<code>unpark</code> &#x2F; <code>suspend</code>(deprecated) 来配合。</li><li><strong>资源</strong>：OS 线程有系统栈、线程控制块等，开销大；虚拟线程（Loom）是 JVM 层的轻量线程，调度由 JVM 管理、挂起成本低。</li><li><strong>中断与同步语义</strong>：Java 定义了一套线程中断、锁语义、内存模型（JMM）抽象，这些由 JVM 映射成 OS 调用与内存屏障实现。</li></ul><hr><h3 id="14-Java-中如何检测死锁？如何预防和避免线程死锁？"><a href="#14-Java-中如何检测死锁？如何预防和避免线程死锁？" class="headerlink" title="14. Java 中如何检测死锁？如何预防和避免线程死锁？"></a>14. Java 中如何检测死锁？如何预防和避免线程死锁？</h3><p><strong>检测死锁方法</strong></p><ul><li><strong>ThreadMXBean</strong>（JMX）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadMXBean</span> <span class="variable">tm</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line"><span class="type">long</span>[] ids = tm.findDeadlockedThreads(); <span class="comment">// 或 findMonitorDeadlockedThreads()</span></span><br><span class="line"><span class="keyword">if</span> (ids != <span class="literal">null</span>) &#123;</span><br><span class="line">  ThreadInfo[] infos = tm.getThreadInfo(ids,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 分析 stack trace 和 locked monitors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>jstack</strong>：在生产上拿多份线程 dump（间隔几秒）观察是否多线程相互持有对方锁并等待 <code>Found one Java-level deadlock</code>。</li></ul><p><strong>死锁产生条件（四必要条件）</strong></p><ol><li>互斥（至少一个资源被独占）</li><li>占有且等待（线程持有资源且等待其他资源）</li><li>不可抢占（资源不能被强行从线程拿走）</li><li>环路等待（A 等待 B，B 等待 C，…，Z 等待 A）</li></ol><p><strong>预防与避免策略</strong></p><ul><li><strong>统一加锁顺序</strong>：保证多个线程按固定顺序获取锁（最简单有效）。</li><li><strong>使用 <code>tryLock(timeout)</code></strong>：若没有获得锁，回退并重试或按其它逻辑处理，防止永远等待。</li><li><strong>减少锁粒度&#x2F;持有时间</strong>：尽量把临界区缩小。</li><li><strong>资源分配策略</strong>：一次性申请全部需要的锁或使用锁分层。</li><li><strong>避免嵌套锁</strong>：尽量减少持有锁时去请求别的锁。</li><li><strong>使用无锁&#x2F;乐观算法</strong>：如 CAS、Concurrent Collections 等。</li></ul><hr><h3 id="15-写一个-Java-死锁的例子（示例代码）"><a href="#15-写一个-Java-死锁的例子（示例代码）" class="headerlink" title="15. 写一个 Java 死锁的例子（示例代码）"></a>15. 写一个 Java 死锁的例子（示例代码）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t1 acquired A and B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t2 acquired B and A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start(); t2.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> ms)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(ms); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：可能出现 t1 持有 A 等待 B，t2 持有 B 等待 A → 永久阻塞（死锁）。</li></ul><hr><h3 id="16-volatile-可以保证原子性么？"><a href="#16-volatile-可以保证原子性么？" class="headerlink" title="16. volatile 可以保证原子性么？"></a>16. <code>volatile</code> 可以保证原子性么？</h3><p><strong>结论</strong>：<strong>不能</strong>保证复合操作的原子性（例如 <code>i++</code> 不是原子）。</p><ul><li>单次读&#x2F;写 <code>volatile</code> 对象或基本类型（除 long&#x2F;double 在早期 JVM）是原子性的（JMM 保证对 <code>volatile long/double</code> 的写也是原子的）。</li><li>若需要原子复合操作，使用 <code>synchronized</code> 或 <code>AtomicInteger</code> &#x2F; <code>AtomicLong</code>。</li></ul><hr><h3 id="17-公平锁与非公平锁有什么区别？"><a href="#17-公平锁与非公平锁有什么区别？" class="headerlink" title="17. 公平锁与非公平锁有什么区别？"></a>17. 公平锁与非公平锁有什么区别？</h3><p><strong>公平锁</strong>：线程获取锁的顺序按照请求顺序（FIFO）。能防止饥饿，但吞吐量较低（因为每次释放后必须唤醒队列头部线程，且上下文切换频率更高）。<code>new ReentrantLock(true)</code> 表示公平锁。</p><p><strong>非公平锁</strong>（默认）：释放锁后线程可以“插队”再次获取（即有竞争时当前线程更可能再次拿到锁），可提高吞吐量但可能导致某些线程饥饿。</p><p><strong>synchronized</strong> 在 HotSpot 实现中是<strong>非公平</strong>的（存在偏向锁、轻量级锁优化）。</p><hr><h3 id="18-乐观锁与悲观锁（思想-典型实现）"><a href="#18-乐观锁与悲观锁（思想-典型实现）" class="headerlink" title="18. 乐观锁与悲观锁（思想 + 典型实现）"></a>18. 乐观锁与悲观锁（思想 + 典型实现）</h3><p><strong>悲观锁</strong></p><ul><li>假设并发会导致冲突，进入临界区前先加锁（阻塞其他线程）。</li><li>典型实现：<code>synchronized</code>、<code>ReentrantLock</code>（独占锁）。</li></ul><p><strong>乐观锁</strong></p><ul><li>假设并发冲突少，用无锁方式尝试更新，冲突发生时回退重试。</li><li>典型实现：CAS（<code>Atomic*</code> 类）、数据库中的 <code>version</code> 字段 + <code>WHERE version = ?</code>（乐观更新）</li><li>优点：在读多写少时能极大提高并发；缺点：高冲突时会频繁重试，性能下降。</li></ul><p><strong>实际选择</strong>：大并发读、少量写可选乐观锁；高冲突写密集场景选悲观锁。</p><hr><h3 id="19-synchronized-和-volatile-的区别（再对比）"><a href="#19-synchronized-和-volatile-的区别（再对比）" class="headerlink" title="19. synchronized 和 volatile 的区别（再对比）"></a>19. <code>synchronized</code> 和 <code>volatile</code> 的区别（再对比）</h3><ul><li><code>synchronized</code>：互斥 + 可见性（保证原子性、互斥进入临界区、自动释放锁），并且实现了内存可见性（通过 monitorenter&#x2F;monitorexit）。</li><li><code>volatile</code>：只保证<strong>可见性与一定的指令序</strong>（禁止某些重排序），<strong>不保证原子性</strong>。不能用来保护复合操作。</li></ul><p><strong>总结</strong>：<code>volatile</code> 适合标志位等轻量同步；<code>synchronized</code> 适合需要原子修改共享状态的场景。</p><hr><h3 id="20-ReentrantLock-的定义和特性"><a href="#20-ReentrantLock-的定义和特性" class="headerlink" title="20. ReentrantLock 的定义和特性"></a>20. <code>ReentrantLock</code> 的定义和特性</h3><p><strong>定义</strong>：<code>ReentrantLock</code> 是 <code>Lock</code> 接口的可重入实现（基于 AQS）。</p><p><strong>主要特性</strong></p><ul><li><strong>可重入</strong>：同一线程可多次获取，AQS <code>state</code> 记录重入次数。</li><li><strong>可中断获取锁</strong>：<code>lockInterruptibly()</code> 支持响应中断。</li><li><strong>支持超时获取</strong>：<code>tryLock(long timeout, TimeUnit unit)</code>。</li><li><strong>支持公平&#x2F;非公平策略</strong>：构造器接受 <code>fair</code> 标志。</li><li><strong>Condition 支持</strong>：<code>lock.newCondition()</code> 提供比 Object.wait&#x2F;notify 更灵活的多个条件队列。</li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">cond</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (!condition) cond.await(); <span class="comment">// 可响应 interrupt</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="21-ReentrantReadWriteLock-的使用场景"><a href="#21-ReentrantReadWriteLock-的使用场景" class="headerlink" title="21. ReentrantReadWriteLock 的使用场景"></a>21. <code>ReentrantReadWriteLock</code> 的使用场景</h3><p><strong>用途</strong>：读多写少场景：允许多个线程并发读，但写时独占（读写互斥）。<br> <strong>使用场景</strong>：</p><ul><li>缓存&#x2F;内存共享资源频繁读、偶尔写：例如配置缓存、只读数据查询等。<br> <strong>注意点</strong>：</li><li>写锁获取时会等待所有读锁释放，读锁在写等待时可导致写饥饿（默认实现有写锁优先或公平选项可用）。</li><li>读锁内部实现较复杂（基于 AQS 的 state 高 16 位或低位用于计数，实际设计细节会随 JDK 版本微调）。</li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">rw.readLock().lock();</span><br><span class="line"><span class="keyword">try</span> &#123; read(); &#125; <span class="keyword">finally</span> &#123; rw.readLock().unlock(); &#125;</span><br><span class="line">rw.writeLock().lock();</span><br><span class="line"><span class="keyword">try</span> &#123; write(); &#125; <span class="keyword">finally</span> &#123; rw.writeLock().unlock(); &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="22-ThreadLocal-内存泄露如何导致的？"><a href="#22-ThreadLocal-内存泄露如何导致的？" class="headerlink" title="22. ThreadLocal 内存泄露如何导致的？"></a>22. <code>ThreadLocal</code> 内存泄露如何导致的？</h3><p><strong>具体机理</strong>：</p><ul><li><code>Thread</code> 对象持有 <code>ThreadLocalMap</code>，该 map 的 key 是 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，value 是强引用。</li><li>若 ThreadLocal 实例被外部丢弃（例如设置为 null），key 弱引用会被 GC 回收 → <code>ThreadLocalMap</code> 中该 entry 的 key 变为 <code>null</code>，但 value 仍然是强引用，不会被回收，导致内存泄露。</li><li>在使用线程池时，线程会被复用，不会结束，entry 永远存在，产生长期泄露。</li></ul><p><strong>防范</strong></p><ul><li>在使用 <code>ThreadLocal</code> 的地方确保 <code>remove()</code>（尤其在线程池中使用时）。</li><li>避免把 ThreadLocal 当成静态缓存存放大量对象，或确保在任务结束时清理。</li><li>使用 try&#x2F;finally：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(obj);</span><br><span class="line"><span class="keyword">try</span> &#123; ... &#125; <span class="keyword">finally</span> &#123; threadLocal.remove(); &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="23-线程池常用的阻塞队列（BlockingQueue）"><a href="#23-线程池常用的阻塞队列（BlockingQueue）" class="headerlink" title="23. 线程池常用的阻塞队列（BlockingQueue）"></a>23. 线程池常用的阻塞队列（BlockingQueue）</h3><ul><li><code>ArrayBlockingQueue</code>：有界、基于数组、固定容量、可选择公平策略。</li><li><code>LinkedBlockingQueue</code>：常用，可有界或无界（默认无界），吞吐高。</li><li><code>SynchronousQueue</code>：不存储元素，直接交接，适合短任务，配合 <code>maximumPoolSize</code> 扩展线程。</li><li><code>PriorityBlockingQueue</code>：优先级队列，元素需实现 <code>Comparable</code>（或传入 Comparator），注意是无界队列（默认）。</li><li><code>DelayQueue</code>：延迟队列（任务带延迟），常和调度&#x2F;延时任务配合。</li><li><code>LinkedTransferQueue</code>：高性能无界队列，支持 transfer semantics。</li></ul><p><strong>要点</strong>：队列的选择强烈影响线程池行为（是否会扩容、是否会阻塞生产者等）。</p><hr><h3 id="24-设计一个线程池，使其按任务优先级运行（思路-注意）"><a href="#24-设计一个线程池，使其按任务优先级运行（思路-注意）" class="headerlink" title="24. 设计一个线程池，使其按任务优先级运行（思路 + 注意）"></a>24. 设计一个线程池，使其按任务优先级运行（思路 + 注意）</h3><p><strong>思路</strong>：使用 <code>PriorityBlockingQueue&lt;Runnable&gt;</code> 作为任务队列，任务实现 <code>Comparable</code>（或包装一个 <code>PriorityRunnable</code>）。<br> <strong>问题&#x2F;注意</strong>：</p><ul><li><code>PriorityBlockingQueue</code> 默认是无界的，可能导致 <code>maximumPoolSize</code> 无效（因为队列永远不满，不会触发扩容），通常搭配 bounded wrapper 或自定义拒绝策略。</li><li>由于优先级队列不保证相同优先级的 FIFO 顺序，若需要稳定顺序需在比较器中包含序号。</li></ul><p><strong>实现示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Comparable&lt;PriorityRunnable&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> priority;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> seq;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</span><br><span class="line">  <span class="comment">// constructor...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PriorityRunnable o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Integer.compare(o.priority, <span class="built_in">this</span>.priority); <span class="comment">// higher priority first</span></span><br><span class="line">    <span class="keyword">return</span> r != <span class="number">0</span> ? r : Long.compare(<span class="built_in">this</span>.seq, o.seq);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; task.run(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">PriorityBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>&lt;&gt;();</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">  core, max, keepAlive, TimeUnit.SECONDS, queue, threadFactory, handler);</span><br></pre></td></tr></table></figure><p><strong>更好方案</strong>：若要有界行为且保持优先级，使用 <code>PriorityBlockingQueue</code> + <code>Semaphore</code> 或自定义 bounded priority queue。</p><hr><h3 id="25-Callable-和-Future（区别与使用）"><a href="#25-Callable-和-Future（区别与使用）" class="headerlink" title="25. Callable 和 Future（区别与使用）"></a>25. <code>Callable</code> 和 <code>Future</code>（区别与使用）</h3><ul><li><code>Callable&lt;V&gt;</code>：任务接口，<code>V call()</code> 可返回结果并抛异常。</li><li><code>Future&lt;V&gt;</code>：表示异步计算的结果句柄，常用方法：<code>get()</code>（阻塞拿结果）、<code>cancel()</code>、<code>isDone()</code>、<code>isCancelled()</code>。</li><li><code>FutureTask&lt;V&gt;</code>：同时实现 <code>Runnable</code> 和 <code>Future</code>，可被 <code>Executor</code> 执行并支持 <code>get()</code>。</li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Future&lt;Integer&gt; f = pool.submit(() -&gt; &#123;</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> f.get(); <span class="comment">// 阻塞直到结果或异常</span></span><br></pre></td></tr></table></figure><hr><h3 id="26-Semaphore-有什么用？（原理与常见用途）"><a href="#26-Semaphore-有什么用？（原理与常见用途）" class="headerlink" title="26. Semaphore 有什么用？（原理与常见用途）"></a>26. <code>Semaphore</code> 有什么用？（原理与常见用途）</h3><p><strong>概念</strong>：信号量，用来控制访问某类资源的并发数量（许可数 permits）。可以公平或非公平。内部基于 AQS（共享模式）。</p><p><strong>常见用途</strong></p><ul><li>连接池并发控制：限制同时获取 DB 连接的线程数。</li><li>限流：例如并发请求数控制。</li><li>保护稀缺资源。</li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">sem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>);</span><br><span class="line">sem.acquire();</span><br><span class="line"><span class="keyword">try</span> &#123; accessResource(); &#125; <span class="keyword">finally</span> &#123; sem.release(); &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="27-CountDownLatch-有什么用？（用途、内部与示例）"><a href="#27-CountDownLatch-有什么用？（用途、内部与示例）" class="headerlink" title="27. CountDownLatch 有什么用？（用途、内部与示例）"></a>27. <code>CountDownLatch</code> 有什么用？（用途、内部与示例）</h3><p><strong>概念</strong>：一次性计数器，初始化一个计数 N，调用 <code>countDown()</code> 将计数减 1；<code>await()</code> 阻塞直到计数为 0。底层基于 AQS（共享模式）。</p><p><strong>用途</strong></p><ul><li>等待多个初始化任务完成（主线程等待多个子线程加载资源）。</li><li>简单的线程同步点（一次性的 barrier）。</li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    doWork();</span><br><span class="line">    latch.countDown();</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">latch.await(); <span class="comment">// 等 3 个任务完成</span></span><br></pre></td></tr></table></figure><p><strong>不可重用</strong>：CountDownLatch 一旦计数到 0 就不能复位（若需复用用 <code>CyclicBarrier</code> 或 <code>Phaser</code>）。</p><hr><h3 id="附：一些常见面试问答扩展（精选应答）"><a href="#附：一些常见面试问答扩展（精选应答）" class="headerlink" title="附：一些常见面试问答扩展（精选应答）"></a>附：一些常见面试问答扩展（精选应答）</h3><ul><li><strong>如何检测死锁</strong>：用 <code>ThreadMXBean.findDeadlockedThreads()</code> 或 <code>jstack</code> 多份堆栈分析。</li><li><strong>如何避免索引&#x2F;线程池级别死锁或线程饥饿</strong>：统一锁顺序、使用 <code>tryLock(timeout)</code>、合理配置池大小和队列。</li><li><strong>何时用 volatile vs Atomic vs synchronized</strong>：<ul><li><code>volatile</code>：只需可见性&#x2F;禁止重排序的标志位；</li><li><code>Atomic*</code>：需要原子更新但无复杂互斥；</li><li><code>synchronized</code>&#x2F;<code>Lock</code>：需要复杂的互斥逻辑、条件等待或复合操作原子性时使用。</li></ul></li><li><strong>为什么 prefer ExecutorService</strong>：线程复用、统一异常处理、资源控制、监控与伸缩。</li></ul><h2 id="测试理论基础-牛客面经八股"><a href="#测试理论基础-牛客面经八股" class="headerlink" title="测试理论基础-牛客面经八股"></a>测试理论基础-牛客面经八股</h2><p>好的 ✅，这一组问题涉及 <strong>软件测试基础、测试设计方法、Bug管理、性能测试、接口测试</strong> 等核心知识点。我会逐题展开，保证细节和深度，适合面试八股 + 实际场景。</p><hr><h3 id="1、黑盒测试与白盒测试的区别是什么？"><a href="#1、黑盒测试与白盒测试的区别是什么？" class="headerlink" title="1、黑盒测试与白盒测试的区别是什么？"></a><strong>1、黑盒测试与白盒测试的区别是什么？</strong></h3><ul><li><strong>黑盒测试</strong>（功能测试）<ul><li><strong>关注点</strong>：功能是否符合需求说明书，<strong>不关心内部实现</strong>。</li><li><strong>特点</strong>：输入 → 输出，测试员像用户一样。</li><li><strong>方法</strong>：等价类划分、边界值、因果图、判定表。</li><li><strong>优点</strong>：贴近用户，容易发现功能缺陷。</li><li><strong>缺点</strong>：覆盖率有限，不能发现内部逻辑错误。</li></ul></li><li><strong>白盒测试</strong>（结构测试）<ul><li><strong>关注点</strong>：程序代码逻辑、语句、分支、条件。</li><li><strong>特点</strong>：需要了解源码。</li><li><strong>方法</strong>：语句覆盖、分支覆盖、条件覆盖、路径覆盖。</li><li><strong>优点</strong>：能发现隐藏的逻辑漏洞。</li><li><strong>缺点</strong>：需要开发技能，难以覆盖大规模系统。<br> 👉 实际项目中：<strong>黑盒为主，白盒为辅</strong>。</li></ul></li></ul><hr><p><strong>2、什么是冒烟测试？</strong></p><ul><li><strong>定义</strong>：冒烟测试是一种<strong>快速验证构建质量</strong>的测试方式，验证核心功能是否正常。</li><li><strong>目标</strong>：确保系统的基本功能可用，构建稳定，适合进一步测试。</li><li><strong>特点</strong>：<ul><li>测试范围小，但覆盖核心功能。</li><li>常常自动化（CI&#x2F;CD 中构建后立即跑冒烟测试）。</li></ul></li><li><strong>比喻</strong>：像开机时先通电 → 如果冒烟，就说明问题大，没必要继续测试。</li></ul><hr><h3 id="3、测试用例设计时需要注意什么？提Bug需要注意哪些点？"><a href="#3、测试用例设计时需要注意什么？提Bug需要注意哪些点？" class="headerlink" title="3、测试用例设计时需要注意什么？提Bug需要注意哪些点？"></a><strong>3、测试用例设计时需要注意什么？提Bug需要注意哪些点？</strong></h3><ul><li><strong>测试用例注意点</strong>：<ul><li>覆盖需求的每个点。</li><li>既考虑正常场景（正向用例），也考虑异常输入（逆向用例）。</li><li>优先级划分（P0&#x2F;P1&#x2F;P2）。</li><li>可复现、可执行、结果可验证。</li></ul></li><li><strong>提Bug注意点</strong>：<ul><li><strong>完整性</strong>：复现步骤、期望结果、实际结果、环境信息。</li><li><strong>准确性</strong>：确认是 Bug，而不是需求不符或环境问题。</li><li><strong>复现率</strong>：提供最小复现条件。</li><li><strong>影响评估</strong>：说明 Bug 的严重性、优先级。</li></ul></li></ul><hr><h3 id="4、了解Bug的逃逸率吗？怎么降低？"><a href="#4、了解Bug的逃逸率吗？怎么降低？" class="headerlink" title="4、了解Bug的逃逸率吗？怎么降低？"></a><strong>4、了解Bug的逃逸率吗？怎么降低？</strong></h3><ul><li><strong>Bug逃逸率</strong>：指 <strong>测试未发现而用户发现的Bug &#x2F; 总Bug数</strong>。</li><li><strong>公式</strong>：Bug逃逸率 &#x3D; 生产环境发现的Bug数 ÷ 总Bug数 × 100%</li><li><strong>降低方法</strong>：<ul><li>需求评审：保证需求清晰。</li><li>测试用例设计全面，覆盖边界、异常场景。</li><li>加强自动化测试（单测、接口、UI）。</li><li>增加性能、兼容、异常测试。</li><li>回归测试保证修复不引入新Bug。</li></ul></li></ul><hr><h3 id="5、测试报告是怎么写的？"><a href="#5、测试报告是怎么写的？" class="headerlink" title="5、测试报告是怎么写的？"></a><strong>5、测试报告是怎么写的？</strong></h3><p>一个完整的 <strong>测试报告</strong> 包括：</p><ol><li><strong>背景</strong>：测试版本、时间、测试范围。</li><li><strong>测试内容</strong>：功能点列表，覆盖情况。</li><li><strong>测试执行结果</strong>：<ul><li>用例数：总数 &#x2F; 执行数 &#x2F; 通过 &#x2F; 失败。</li><li>Bug数量：总数、已解决、未解决、按严重级别分类。</li></ul></li><li><strong>风险与遗留问题</strong>：哪些Bug未解决，可能影响哪些功能。</li><li><strong>结论与建议</strong>：是否建议上线，注意事项。</li></ol><hr><h3 id="6、你有没有接触一些和AI相关的自动化测试？"><a href="#6、你有没有接触一些和AI相关的自动化测试？" class="headerlink" title="6、你有没有接触一些和AI相关的自动化测试？"></a><strong>6、你有没有接触一些和AI相关的自动化测试？</strong></h3><ul><li><strong>AI在自动化测试中的应用</strong>：<ul><li><strong>智能元素识别</strong>：传统 UI 自动化容易因 DOM 变化失败，AI 可做视觉识别（OCR + 图像识别）。</li><li><strong>智能用例生成</strong>：基于需求文档、日志分析，自动生成测试用例。</li><li><strong>异常检测</strong>：AI 可基于日志或监控，自动识别异常模式。</li><li><strong>智能 Bug 分析</strong>：根据历史数据，预测 Bug 可能的根因。<br> 👉 越来越多企业用 <strong>AI + 自动化测试平台（Selenium、Appium + AI 辅助）</strong>。</li></ul></li></ul><hr><h3 id="7、性能测试怎么做？需要关注哪些指标？"><a href="#7、性能测试怎么做？需要关注哪些指标？" class="headerlink" title="7、性能测试怎么做？需要关注哪些指标？"></a><strong>7、性能测试怎么做？需要关注哪些指标？</strong></h3><ul><li><strong>性能测试目标</strong>：验证系统在高并发、大数据量情况下的表现。</li><li><strong>方法</strong>：<ul><li>使用工具：JMeter、LoadRunner、Locust。</li><li>模拟用户请求，逐步加压。</li></ul></li><li><strong>关注指标</strong>：<ol><li><strong>吞吐量（TPS&#x2F;QPS）</strong></li><li><strong>响应时间（RT，P90&#x2F;P95&#x2F;P99）</strong></li><li><strong>并发用户数</strong></li><li><strong>CPU、内存、IO、带宽</strong></li><li><strong>错误率</strong></li></ol></li><li><strong>场景</strong>：<ul><li>压力测试：极限承载。</li><li>负载测试：逐渐增加并发。</li><li>稳定性测试：长时间运行。</li></ul></li></ul><hr><h3 id="8、如何判断一个Bug是前端还是后端引起的？"><a href="#8、如何判断一个Bug是前端还是后端引起的？" class="headerlink" title="8、如何判断一个Bug是前端还是后端引起的？"></a><strong>8、如何判断一个Bug是前端还是后端引起的？</strong></h3><ul><li><strong>判断思路</strong>：<ol><li><strong>接口测试</strong>：<ul><li>如果接口返回异常 → 后端问题。</li><li>接口正常但页面展示错误 → 前端问题。</li></ul></li><li><strong>抓包 &#x2F; 调试工具</strong>：Fiddler、Postman、浏览器 Network。</li><li><strong>日志分析</strong>：<ul><li>前端控制台报错。</li><li>后端日志报错（异常栈、SQL错误）。</li></ul></li><li><strong>复现路径</strong>：<ul><li>单接口调试通过，前端渲染有问题 → 前端。</li><li>单接口调试失败 → 后端。</li></ul></li></ol></li></ul><hr><h3 id="9、接口测试工具及方法、接口自动化框架搭建及参数化实现"><a href="#9、接口测试工具及方法、接口自动化框架搭建及参数化实现" class="headerlink" title="9、接口测试工具及方法、接口自动化框架搭建及参数化实现"></a><strong>9、接口测试工具及方法、接口自动化框架搭建及参数化实现</strong></h3><ul><li><strong>接口测试工具</strong>：Postman、JMeter、Swagger、Apifox。</li><li><strong>方法</strong>：<ul><li>验证请求参数、返回值、状态码。</li><li>验证业务逻辑、异常处理。</li><li>安全性（SQL注入、越权访问）。</li></ul></li><li><strong>接口自动化框架</strong>：<ul><li>语言：Java（RestAssured + TestNG）、Python（pytest + requests）。</li><li><strong>框架结构</strong>：用例层 → 数据驱动层 → 公共方法层 → 报告层。</li><li><strong>参数化实现</strong>：用 Excel&#x2F;CSV&#x2F;JSON&#x2F;YAML 存储数据，框架读取并循环执行。<br> 👉 最终实现 <strong>持续集成（CI）+ 持续交付（CD）</strong>。</li></ul></li></ul><hr><h3 id="10、除了功能测试、性能测试，还有什么测试类型？"><a href="#10、除了功能测试、性能测试，还有什么测试类型？" class="headerlink" title="10、除了功能测试、性能测试，还有什么测试类型？"></a><strong>10、除了功能测试、性能测试，还有什么测试类型？</strong></h3><ul><li><strong>安全测试</strong>：SQL注入、XSS、CSRF。</li><li><strong>兼容性测试</strong>：不同浏览器、不同设备。</li><li><strong>可用性测试</strong>：用户体验。</li><li><strong>接口测试</strong>。</li><li><strong>回归测试</strong>。</li><li><strong>可靠性测试</strong>。</li><li><strong>并发测试</strong>。</li><li><strong>灰度测试 &#x2F; A&#x2F;B 测试</strong>。</li></ul><hr><h3 id="11、发现了支付成功但后台订单未生成的问题，从发现到提交Bug会做哪些工作？"><a href="#11、发现了支付成功但后台订单未生成的问题，从发现到提交Bug会做哪些工作？" class="headerlink" title="11、发现了支付成功但后台订单未生成的问题，从发现到提交Bug会做哪些工作？"></a><strong>11、发现了支付成功但后台订单未生成的问题，从发现到提交Bug会做哪些工作？</strong></h3><ol><li><strong>确认现象</strong>：<ul><li>支付是否真实成功（第三方支付回调成功？）。</li><li>是否是单次还是批量问题。</li></ul></li><li><strong>排查前端</strong>：<ul><li>看请求是否正确发出。</li><li>参数是否正确传递。</li></ul></li><li><strong>排查后端</strong>：<ul><li>查看日志（支付回调、订单生成流程）。</li><li>是否卡在消息队列 &#x2F; 数据库。</li></ul></li><li><strong>复现Bug</strong>：<ul><li>在测试环境复现，确认稳定。</li></ul></li><li><strong>提交Bug</strong>：<ul><li>标题：支付成功订单未生成。</li><li>复现步骤：支付流程、支付工具。</li><li>期望结果：支付成功后生成订单。</li><li>实际结果：未生成。</li><li>环境信息：测试环境 &#x2F; 生产环境。</li><li>附加信息：接口请求&#x2F;响应、日志。</li></ul></li></ol><hr><h2 id="HTTP-HTTPS-牛客面经八股"><a href="#HTTP-HTTPS-牛客面经八股" class="headerlink" title="HTTP&#x2F;HTTPS-牛客面经八股"></a>HTTP&#x2F;HTTPS-牛客面经八股</h2><p>太好了 ✅，这组题目涉及 <strong>HTTP 协议全家桶</strong>（1.0 → 3.0 演进、状态码、缓存、HTTPS、WebSocket、SSE），是前端&#x2F;后端&#x2F;运维面试的高频考点。我逐个给你讲，保证深入、细节全，既能应对面试，也能真正理解。</p><hr><h3 id="1、HTTP-1-0、HTTP-1-1、HTTP-2-0、HTTP-3-0-的区别？"><a href="#1、HTTP-1-0、HTTP-1-1、HTTP-2-0、HTTP-3-0-的区别？" class="headerlink" title="1、HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2.0、HTTP&#x2F;3.0 的区别？"></a><strong>1、HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2.0、HTTP&#x2F;3.0 的区别？</strong></h3><ul><li><strong>HTTP&#x2F;1.0</strong>（1996）<ul><li><strong>短连接</strong>：每次请求都要建立 TCP 连接。</li><li>只支持 <code>GET/POST/HEAD</code> 方法。</li><li>缺少 Host 头，不支持虚拟主机。</li></ul></li><li><strong>HTTP&#x2F;1.1</strong>（1999）<ul><li><strong>长连接（Connection: keep-alive）</strong>，复用 TCP。</li><li>新增方法：<code>PUT/DELETE/OPTIONS</code>。</li><li>支持 <strong>管道化（Pipelining）</strong>，但容易队头阻塞。</li><li><strong>缓存控制</strong>：<code>Cache-Control</code>。</li></ul></li><li><strong>HTTP&#x2F;2.0</strong>（2015，基于 SPDY）<ul><li><strong>二进制分帧</strong>，效率更高。</li><li><strong>多路复用</strong>：一个 TCP 连接上并发多个请求，解决队头阻塞（但仍受 TCP 队头阻塞影响）。</li><li><strong>头部压缩（HPACK）</strong>，减少带宽。</li><li><strong>服务端推送</strong>。</li></ul></li><li><strong>HTTP&#x2F;3.0</strong>（2022，基于 QUIC&#x2F;UDP）<ul><li><strong>QUIC 协议（UDP + TLS 1.3）</strong>，彻底解决 TCP 队头阻塞。</li><li>连接迁移（换 IP 也不中断）。</li><li>更快的握手（1-RTT &#x2F; 0-RTT）。</li></ul></li></ul><p>👉 总结：<strong>1.0 短连接 → 1.1 长连接 → 2.0 多路复用 → 3.0 基于 UDP。</strong></p><hr><h3 id="2、HTTP-常见状态码有哪些？"><a href="#2、HTTP-常见状态码有哪些？" class="headerlink" title="2、HTTP 常见状态码有哪些？"></a><strong>2、HTTP 常见状态码有哪些？</strong></h3><ul><li><strong>1xx</strong>：信息（100 Continue）</li><li><strong>2xx</strong>：成功（200 OK，201 Created，204 No Content）</li><li><strong>3xx</strong>：重定向（301 永久，302 临时，304 Not Modified）</li><li><strong>4xx</strong>：客户端错误（400 Bad Request，401 Unauthorized，403 Forbidden，404 Not Found，405 Method Not Allowed）</li><li><strong>5xx</strong>：服务端错误（500 Internal Server Error，502 Bad Gateway，503 Service Unavailable，504 Gateway Timeout）</li></ul><hr><h3 id="3、HTTP-请求头中到底包含什么？"><a href="#3、HTTP-请求头中到底包含什么？" class="headerlink" title="3、HTTP 请求头中到底包含什么？"></a><strong>3、HTTP 请求头中到底包含什么？</strong></h3><p>常见请求头分为几类：</p><ul><li><strong>通用头</strong>：<code>Date</code>，<code>Connection</code></li><li><strong>请求头</strong>：<code>Host</code>，<code>User-Agent</code>，<code>Accept</code>，<code>Referer</code>，<code>Cookie</code></li><li><strong>响应头</strong>：<code>Server</code>，<code>Set-Cookie</code>，<code>Location</code></li><li><strong>实体头</strong>：<code>Content-Type</code>，<code>Content-Length</code>，<code>Content-Encoding</code></li></ul><hr><h3 id="4、HTTP-是基于-TCP-还是-UDP？"><a href="#4、HTTP-是基于-TCP-还是-UDP？" class="headerlink" title="4、HTTP 是基于 TCP 还是 UDP？"></a><strong>4、HTTP 是基于 TCP 还是 UDP？</strong></h3><ul><li><strong>HTTP&#x2F;1.0 &amp; HTTP&#x2F;1.1 &amp; HTTP&#x2F;2.0 → 基于 TCP</strong></li><li><strong>HTTP&#x2F;3.0 → 基于 QUIC（UDP）</strong><br> 👉 所以，HTTP <strong>主要基于 TCP</strong>，但最新版本用 UDP。</li></ul><hr><h3 id="5、HTTP-常见字段有哪些？"><a href="#5、HTTP-常见字段有哪些？" class="headerlink" title="5、HTTP 常见字段有哪些？"></a><strong>5、HTTP 常见字段有哪些？</strong></h3><ul><li><strong>缓存相关</strong>：<code>Cache-Control</code>，<code>Expires</code>，<code>ETag</code>，<code>Last-Modified</code></li><li><strong>内容相关</strong>：<code>Content-Type</code>，<code>Content-Length</code>，<code>Content-Encoding</code></li><li><strong>连接相关</strong>：<code>Connection</code>，<code>Keep-Alive</code></li><li><strong>安全相关</strong>：<code>Cookie</code>，<code>Set-Cookie</code>，<code>Authorization</code></li></ul><hr><h3 id="6、HTTP-的缓存机制，服务器如何判断缓存是否过期？"><a href="#6、HTTP-的缓存机制，服务器如何判断缓存是否过期？" class="headerlink" title="6、HTTP 的缓存机制，服务器如何判断缓存是否过期？"></a><strong>6、HTTP 的缓存机制，服务器如何判断缓存是否过期？</strong></h3><ol><li><strong>强制缓存（Expires &#x2F; Cache-Control）</strong><ul><li><code>Expires: Wed, 21 Oct 2025 07:28:00 GMT</code>（绝对时间）</li><li><code>Cache-Control: max-age=3600</code>（相对时间）<br> 👉 未过期 → 直接用本地缓存。</li></ul></li><li><strong>协商缓存（ETag &#x2F; Last-Modified）</strong><ul><li><code>ETag</code>（文件唯一标识） → If-None-Match</li><li><code>Last-Modified</code> → If-Modified-Since<br> 👉 服务器校验后返回 <strong>304 Not Modified</strong>。</li></ul></li></ol><hr><h3 id="7、HTTP-长连接-vs-短连接的区别是？"><a href="#7、HTTP-长连接-vs-短连接的区别是？" class="headerlink" title="7、HTTP 长连接 vs 短连接的区别是？"></a><strong>7、HTTP 长连接 vs 短连接的区别是？</strong></h3><ul><li><strong>短连接（1.0）</strong>：一次请求&#x2F;响应就关闭连接。</li><li><strong>长连接（1.1 Keep-Alive）</strong>：多个请求复用一个 TCP 连接，减少握手开销。</li></ul><hr><h3 id="8、从「敲下一个-URL」到「页面出现在屏幕」整条链路全景"><a href="#8、从「敲下一个-URL」到「页面出现在屏幕」整条链路全景" class="headerlink" title="8、从「敲下一个 URL」到「页面出现在屏幕」整条链路全景"></a><strong>8、从「敲下一个 URL」到「页面出现在屏幕」整条链路全景</strong></h3><ol><li>浏览器解析 URL，检查缓存（强缓存&#x2F;协商缓存）。</li><li>DNS 解析域名 → 得到 IP。</li><li>建立 TCP&#x2F;UDP 连接（TLS 握手）。</li><li>发送 HTTP 请求。</li><li>服务器处理请求，返回响应（HTML&#x2F;CSS&#x2F;JS）。</li><li>浏览器解析 HTML，构建 DOM 树、CSSOM 树 → 渲染树。</li><li>执行 JS，可能发起 AJAX 请求。</li><li>页面渲染到屏幕。</li></ol><hr><h3 id="9、什么是重定向？重定向与请求转发的区别？"><a href="#9、什么是重定向？重定向与请求转发的区别？" class="headerlink" title="9、什么是重定向？重定向与请求转发的区别？"></a><strong>9、什么是重定向？重定向与请求转发的区别？</strong></h3><ul><li><strong>重定向（Redirect）</strong>：<ul><li>服务器返回 <code>3xx</code>，告诉浏览器去新地址。</li><li><strong>二次请求</strong>，地址栏改变。</li></ul></li><li><strong>请求转发（Forward，服务端内部行为）</strong>：<ul><li>Web 服务器内部转发到另一个资源。</li><li><strong>一次请求</strong>，地址栏不变。</li></ul></li></ul><hr><h3 id="10、GET-与-POST-有什么区别"><a href="#10、GET-与-POST-有什么区别" class="headerlink" title="10、GET 与 POST 有什么区别?"></a><strong>10、GET 与 POST 有什么区别?</strong></h3><h4 id="1-语义（核心区别）"><a href="#1-语义（核心区别）" class="headerlink" title="1. 语义（核心区别）"></a>1. <strong>语义（核心区别）</strong></h4><ul><li><strong>GET</strong>：获取资源<ul><li>语义上用于“查询 &#x2F; 读取”资源，不会修改服务器状态。</li><li>要求是<strong>幂等</strong>（多次请求结果一样）和<strong>安全</strong>（不会改变数据）。</li></ul></li><li><strong>POST</strong>：提交资源<ul><li>语义上用于“新增 &#x2F; 修改”资源，会对服务器状态造成影响。</li><li>通常<strong>非幂等</strong>（多次提交会重复写入数据）。</li></ul></li></ul><p>👉 <strong>面试回答点</strong>：<br> HTTP 语义层面，GET 与 POST 的区别远大于“参数放在 URL 还是 Body”，核心是幂等性与安全性。</p><hr><h4 id="2-参数传递方式"><a href="#2-参数传递方式" class="headerlink" title="2. 参数传递方式"></a>2. <strong>参数传递方式</strong></h4><ul><li><strong>GET</strong><ul><li>参数拼接在 <strong>URL</strong>，格式为 <code>?key=value&amp;key2=value2</code>。</li><li><strong>长度限制</strong>：HTTP 协议本身无限制，但 <strong>浏览器 &#x2F; 服务器 &#x2F; 代理</strong> 一般限制在 2KB ~ 8KB。</li><li>适合少量参数、查询条件。</li></ul></li><li><strong>POST</strong><ul><li>参数放在 <strong>请求体 (Body)</strong>，理论上无限制，适合大数据提交。</li><li>但部分服务器或代理仍会限制 Body 大小（通常在 2MB ~ 50MB）。</li></ul></li></ul><p>👉 <strong>总结</strong>：GET 传输小数据（查询），POST 传输大数据（表单、文件）。</p><hr><h4 id="3-缓存机制"><a href="#3-缓存机制" class="headerlink" title="3. 缓存机制"></a>3. <strong>缓存机制</strong></h4><ul><li><strong>GET</strong><ul><li>天生支持缓存：浏览器、CDN、代理服务器可缓存 GET 请求结果。</li><li>结合 <strong>Etag、Last-Modified、Cache-Control</strong> 等头部，减少重复请求。</li></ul></li><li><strong>POST</strong><ul><li>默认<strong>不缓存</strong>，每次都会提交到服务器。</li><li>可以强行配置缓存（但很少这样做）。</li></ul></li></ul><p>👉 <strong>考点</strong>：为什么搜索接口一般用 GET？——为了利用浏览器 &#x2F; CDN 缓存，提高性能。</p><hr><h4 id="4-安全性"><a href="#4-安全性" class="headerlink" title="4. 安全性"></a>4. <strong>安全性</strong></h4><ul><li><strong>GET</strong><ul><li>参数暴露在 URL，可能被浏览器历史记录、日志、书签记录。</li><li>不适合传输敏感信息（密码、token）。</li></ul></li><li><strong>POST</strong><ul><li>参数在请求体里，不会出现在 URL，但仍然可能被抓包工具获取。</li><li>只是<strong>安全性略好</strong>，并不是绝对安全。</li><li>真正安全要依赖 <strong>HTTPS 加密传输</strong>。</li></ul></li></ul><p>👉 面试时要强调：<strong>GET 和 POST 安全性本质上没有区别，安全取决于 HTTPS，而不是请求方法。</strong></p><hr><h4 id="5-性能与-TCP-层面"><a href="#5-性能与-TCP-层面" class="headerlink" title="5. 性能与 TCP 层面"></a>5. <strong>性能与 TCP 层面</strong></h4><ul><li><strong>TCP 层面</strong>：<ul><li>GET 与 POST <strong>底层都是 TCP</strong>，没有性能差异。</li><li>区别只在于 <strong>请求格式</strong> 和 <strong>浏览器处理</strong>。</li></ul></li><li><strong>性能差异的根源</strong>：<ul><li><strong>GET</strong> 请求更容易被缓存，性能更高。</li><li><strong>POST</strong> 请求每次都要到服务器处理，性能稍差。</li></ul></li></ul><p>👉 <strong>面试陷阱</strong>：有人说“POST 会比 GET 多一次 TCP 握手”其实是 <strong>误解</strong>。</p><ul><li>事实是：<strong>HTTP&#x2F;1.1 默认长连接</strong>，不会重复握手。</li></ul><hr><h4 id="6-应用场景"><a href="#6-应用场景" class="headerlink" title="6. 应用场景"></a>6. <strong>应用场景</strong></h4><ul><li><strong>GET</strong><ul><li>查询数据、获取资源（如搜索、文章详情）。</li><li>可被书签保存，可直接分享 URL。</li></ul></li><li><strong>POST</strong><ul><li>提交数据（如表单提交、文件上传、支付下单）。</li><li>需要传输复杂或大量数据。</li></ul></li></ul><hr><h4 id="🔑-面试高频总结回答"><a href="#🔑-面试高频总结回答" class="headerlink" title="🔑 面试高频总结回答"></a><strong>🔑 面试高频总结回答</strong></h4><blockquote><p><strong>面试官常问：“GET 和 POST 有什么区别？” 你</strong>可以这样答：</p></blockquote><ol><li><strong>语义不同</strong>：GET 用于获取资源（幂等、安全），POST 用于提交资源（非幂等）。</li><li><strong>参数传递不同</strong>：GET 参数在 URL，有长度限制；POST 在 Body，适合大数据。</li><li><strong>缓存机制</strong>：GET 默认可缓存，POST 默认不缓存。</li><li><strong>安全性</strong>：GET 参数暴露在 URL，POST 参数在 Body，安全性稍高，但真正安全要靠 HTTPS。</li><li><strong>性能</strong>：底层都是 TCP，无本质性能差异，GET 主要因缓存而更快。</li><li><strong>应用场景</strong>：GET 用于查询，POST 用于提交和修改数据。</li></ol><hr><h3 id="11、HTTP-vs-HTTPS-有什么区别"><a href="#11、HTTP-vs-HTTPS-有什么区别" class="headerlink" title="11、HTTP vs. HTTPS 有什么区别?"></a><strong>11、HTTP vs. HTTPS 有什么区别?</strong></h3><ul><li><strong>HTTP</strong>：明文传输，不安全。</li><li><strong>HTTPS</strong>：HTTP + TLS&#x2F;SSL，数据加密。</li><li><strong>区别</strong>：<ul><li>端口不同（80 vs 443）。</li><li>HTTPS 需要证书。</li><li>HTTPS 有握手过程，性能略低。</li></ul></li></ul><hr><h3 id="12、HTTPS-的「秘钥交换-证书校验」全流程"><a href="#12、HTTPS-的「秘钥交换-证书校验」全流程" class="headerlink" title="12、HTTPS 的「秘钥交换 + 证书校验」全流程"></a><strong>12、HTTPS 的「秘钥交换 + 证书校验」全流程</strong></h3><ol><li>浏览器请求 HTTPS 网站。</li><li>服务器返回 <strong>证书（包含公钥 + 签名）</strong>。</li><li>浏览器验证证书合法性（CA 签发、域名匹配、未过期）。</li><li>客户端生成 <strong>随机对称密钥</strong>，用服务器公钥加密，发给服务器。</li><li>服务器用私钥解密，得到对称密钥。</li><li>后续通信用 <strong>对称加密</strong>（AES）。</li></ol><hr><h3 id="13、HTTPS（TLS）里都用到了哪些加密算法？"><a href="#13、HTTPS（TLS）里都用到了哪些加密算法？" class="headerlink" title="13、HTTPS（TLS）里都用到了哪些加密算法？"></a><strong>13、HTTPS（TLS）里都用到了哪些加密算法？</strong></h3><ul><li><strong>对称加密</strong>：AES、ChaCha20（数据加密）。</li><li><strong>非对称加密</strong>：RSA、ECC（秘钥交换）。</li><li><strong>摘要算法</strong>：SHA-256（完整性校验）。</li><li><strong>数字签名</strong>：RSA-SHA256 &#x2F; ECDSA。</li></ul><hr><h3 id="14、WebSocket-简介-与-HTTP-的核心区别"><a href="#14、WebSocket-简介-与-HTTP-的核心区别" class="headerlink" title="14、WebSocket 简介 &amp; 与 HTTP 的核心区别"></a><strong>14、WebSocket 简介 &amp; 与 HTTP 的核心区别</strong></h3><ul><li><strong>WebSocket</strong>：全双工通信协议，运行在 TCP 之上。</li><li><strong>与 HTTP 的区别</strong>：<ul><li>HTTP 是 <strong>请求-响应模式</strong>。</li><li>WebSocket 是 <strong>双向通信</strong>，服务端可主动推送数据。</li><li>建立时通过 HTTP <strong>Upgrade</strong> 头，从 HTTP 升级为 WebSocket。</li></ul></li></ul><hr><h3 id="15、WebSocket-的工作过程是什么样的？"><a href="#15、WebSocket-的工作过程是什么样的？" class="headerlink" title="15、WebSocket 的工作过程是什么样的？"></a><strong>15、WebSocket 的工作过程是什么样的？</strong></h3><ol><li>客户端发起 HTTP 请求，带 <code>Upgrade: websocket</code>。</li><li>服务器同意，返回 101 Switching Protocols。</li><li>双方升级为 WebSocket 协议，保持 TCP 长连接。</li><li>客户端 &amp; 服务端可以互相发送消息（Text&#x2F;Binary Frame）。</li></ol><hr><h3 id="16、SSE（Server-Sent-Events）与-WebSocket-有什么区别"><a href="#16、SSE（Server-Sent-Events）与-WebSocket-有什么区别" class="headerlink" title="16、SSE（Server-Sent Events）与 WebSocket 有什么区别?"></a><strong>16、SSE（Server-Sent Events）与 WebSocket 有什么区别?</strong></h3><ul><li><strong>SSE</strong>（服务器推送事件）：<ul><li>基于 HTTP 协议。</li><li>单向：服务器 → 客户端。</li><li>适合实时数据推送（股票、消息提醒）。</li></ul></li><li><strong>WebSocket</strong>：<ul><li>独立协议。</li><li>双向通信（客户端 &amp; 服务端都能主动发送）。</li><li>适合聊天室、在线游戏。</li></ul></li></ul><p>👉 <strong>总结</strong>：</p><ul><li><strong>SSE</strong>：轻量级，单向推送。</li><li><strong>WebSocket</strong>：强大，双向通信。</li></ul><hr><h2 id="分布式-牛客面经八股"><a href="#分布式-牛客面经八股" class="headerlink" title="分布式-牛客面经八股"></a>分布式-牛客面经八股</h2><hr><h3 id="1-缓存穿透-缓存击穿-缓存雪崩-—-区别与防护"><a href="#1-缓存穿透-缓存击穿-缓存雪崩-—-区别与防护" class="headerlink" title="1. 缓存穿透 &#x2F; 缓存击穿 &#x2F; 缓存雪崩 — 区别与防护"></a><strong>1. 缓存穿透 &#x2F; 缓存击穿 &#x2F; 缓存雪崩 — 区别与防护</strong></h3><ul><li><p><strong>定义</strong></p><ul><li><strong>缓存穿透</strong>：请求查询的 key 在缓存未命中且数据库也不存在（或是恶意请求大量不存在 key），导致大量请求直接打到 DB。</li><li><strong>缓存击穿</strong>（又称 cache breakdown）：某个热点 key 的缓存过期或被淘汰，短时间内大量并发请求同时去读 DB，造成 DB 峰值压力。</li><li><strong>缓存雪崩</strong>：缓存层在短时间内大量 key 同时失效（例如同一 TTL 或重启导致），整体流量穿透到 DB，造成服务雪崩。</li></ul></li><li><p><strong>防护策略（实战）</strong></p><ul><li><strong>穿透</strong>：<ul><li>使用 <strong>布隆过滤器</strong> 预过滤不存在的 key（内存小、允许一定误报），把合法 key 的集合放入布隆过滤器。</li><li>对不存在的结果做 <strong>负缓存（empty cache）</strong>：把空结果也缓存，但 TTL 较短（例如 30s~5min），避免无限缓存错误数据。注意 TTL 应短且带随机抖动避免同时过期。</li></ul></li><li><strong>击穿</strong>：<ul><li>使用 <strong>互斥锁 &#x2F; singleflight</strong>：一个请求去 DB 构建缓存，其他请求等待或返回旧值；例如 Redis 的 <code>SETNX</code> + value-token + Lua 验证释放锁。</li><li><strong>提前重建 &#x2F; 热点预热</strong>：对已知热点提前刷新或延长 TTL。</li><li>使用 <strong>永不过期缓存 + 后台刷新</strong>（主动刷新策略）。</li></ul></li><li><strong>雪崩</strong>：<ul><li>给 TTL 加 <strong>随机抖动</strong>（使 key 不会同一时刻失效）。</li><li>限制缓存穿透到 DB 的 QPS（熔断&#x2F;降级、限流）。</li><li>多级缓存（本地 + 分布式）与冷备（备用 DB 副本、读副本）。</li><li>Cache warming（重启后先行预热重要 key）。</li></ul></li></ul></li><li><p><strong>实现要点 &#x2F; 伪代码</strong></p><ul><li><p>负缓存示例（伪）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">val = redis.get(key)</span><br><span class="line">if val != null:</span><br><span class="line">  if val == &quot;__EMPTY__&quot;:</span><br><span class="line">    return 404</span><br><span class="line">  return val</span><br><span class="line">// miss</span><br><span class="line">lock = redis.set(&quot;lock:&quot;+key, uuid, NX, PX, 30000)</span><br><span class="line">if lock:</span><br><span class="line">  val = db.query(key)</span><br><span class="line">  if val:</span><br><span class="line">    redis.set(key, val, TTL)</span><br><span class="line">  else:</span><br><span class="line">    redis.set(key, &quot;__EMPTY__&quot;, shortTTL)</span><br><span class="line">  redis.del(&quot;lock:&quot;+key)</span><br><span class="line">  return val</span><br><span class="line">else:</span><br><span class="line">  sleep(50ms) // 或者等待 singleflight 返回</span><br><span class="line">  retry get from cache</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>常见面试追问</strong>：布隆误报率如何计算？NX+PX 的锁为什么还要校验 value？为什么负缓存 TTL 要短？singleflight 的实现细节。</p></li></ul><p>你这几个问题都是<strong>高频追问</strong>，答得要够深入，面试官才会认可。下面我分点逐一展开：</p><hr><h4 id="1-布隆过滤器的误报率计算"><a href="#1-布隆过滤器的误报率计算" class="headerlink" title="1. 布隆过滤器的误报率计算"></a>1. 布隆过滤器的误报率计算</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>布隆过滤器由一个 <strong>长度为 m 的 bit 数组</strong>和 <strong>k 个哈希函数</strong>组成。</p><ul><li>插入一个元素时，计算 k 次 hash，将结果位置置为 1。</li><li>查询一个元素时，若有任意一个位置为 0，则一定不存在；若全部为 1，则可能存在（误报）。</li></ul><h5 id="误报率公式"><a href="#误报率公式" class="headerlink" title="误报率公式"></a><strong>误报率公式</strong></h5><ol><li><p>插入 n 个元素时，某个 bit 位保持为 0 的概率：<br>$$<br>[<br> \left(1 - \frac{1}{m}\right)^{kn} \approx e^{-\frac{kn}{m}}<br> ]<br>$$</p></li><li><p>某个 bit 位为 1 的概率：<br>$$<br>[<br> 1 - e^{-\frac{kn}{m}}<br> ]<br>$$</p></li><li><p>查询时，k 个 hash 都命中的概率（即误报概率）：<br>$$<br>[<br> P_{false} &#x3D; \left(1 - e^{-\frac{kn}{m}}\right)^k<br> ]<br>$$</p></li></ol><h5 id="最佳-k-值（哈希函数个数）"><a href="#最佳-k-值（哈希函数个数）" class="headerlink" title="最佳 k 值（哈希函数个数）"></a><strong>最佳 k 值（哈希函数个数）</strong></h5><p>为了降低误报率，k 要适配：<br>$$<br>[<br> k &#x3D; \frac{m}{n} \ln 2<br> ]<br>$$</p><h5 id="关键点总结（面试答法）"><a href="#关键点总结（面试答法）" class="headerlink" title="关键点总结（面试答法）"></a><strong>关键点总结（面试答法）</strong></h5><ul><li><p>误报率 ≈<br>$$<br>(\left(1 - e^{-\frac{kn}{m}}\right)^k)<br>$$</p></li><li><p>哈希函数数量<br>$$<br>k ≈ (m&#x2F;n) * ln 2<br>$$</p></li><li><p>误报率随 m 增大、k 合理时下降；但不会为 0。</p></li></ul><hr><h4 id="2-Redis-分布式锁-NX-PX-为什么还要校验-value？"><a href="#2-Redis-分布式锁-NX-PX-为什么还要校验-value？" class="headerlink" title="2. Redis 分布式锁 NX+PX 为什么还要校验 value？"></a>2. Redis 分布式锁 NX+PX 为什么还要校验 value？</h4><h5 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a><strong>问题背景</strong></h5><p>Redis 分布式锁常见写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value NX PX ttl</span><br></pre></td></tr></table></figure><ul><li><code>NX</code>：只在 key 不存在时设置，避免重复获取。</li><li><code>PX ttl</code>：过期时间，避免死锁。</li></ul><h5 id="为什么还要校验-value？"><a href="#为什么还要校验-value？" class="headerlink" title="为什么还要校验 value？"></a><strong>为什么还要校验 value？</strong></h5><ul><li>多客户端竞争锁时，可能会出现 <strong>锁被误删</strong> 的问题：<ol><li>客户端 A 拿到锁（key&#x3D;lock，value&#x3D;uuidA，ttl&#x3D;5s）。</li><li>A 执行时间过长，锁过期自动释放。</li><li>客户端 B 拿到锁（key&#x3D;lock，value&#x3D;uuidB）。</li><li>A 任务结束，执行 <code>DEL lock</code>，结果把 B 的锁删掉了。</li></ol></li></ul><p>这样会导致 <strong>并发安全问题</strong>。</p><h5 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a><strong>解决方式</strong></h5><p>删除时必须 <strong>先比对 value 是否属于自己</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>👉 <strong>总结一句话</strong>：校验 value 的原因是避免删除其他客户端的锁。</p><hr><h4 id="3-负缓存（缓存空值）TTL-为什么要短？"><a href="#3-负缓存（缓存空值）TTL-为什么要短？" class="headerlink" title="3. 负缓存（缓存空值）TTL 为什么要短？"></a>3. 负缓存（缓存空值）TTL 为什么要短？</h4><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h5><ul><li>缓存穿透时（大量查询不存在的数据），常用做法是 <strong>缓存空值</strong>，避免频繁打到数据库。</li><li>但空值可能未来会变成真实存在的数据（例如用户刚注册）。</li></ul><h5 id="为什么-TTL-要短？"><a href="#为什么-TTL-要短？" class="headerlink" title="为什么 TTL 要短？"></a><strong>为什么 TTL 要短？</strong></h5><ul><li>如果负缓存 TTL 太长，新插入的数据会长时间无法被访问（缓存一直返回空）。</li><li>TTL 短可以在一段时间后自动过期，让新数据有机会被查询到。</li></ul><h5 id="取舍"><a href="#取舍" class="headerlink" title="取舍"></a><strong>取舍</strong></h5><ul><li>短 TTL：避免数据延迟太长。</li><li>太短会让缓存命中率下降。</li><li>一般设置 <strong>几秒到几十秒</strong>（依业务场景权衡）。</li></ul><p>👉 <strong>一句话总结</strong>：负缓存 TTL 短，是为了兼顾抗穿透和数据及时性。</p><hr><h4 id="4-singleflight-的实现细节（Go-中的典型方案）"><a href="#4-singleflight-的实现细节（Go-中的典型方案）" class="headerlink" title="4. singleflight 的实现细节（Go 中的典型方案）"></a>4. singleflight 的实现细节（Go 中的典型方案）</h4><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h5><ul><li>常见于缓存击穿问题：同一时间大量请求打到 DB。</li><li>singleflight 让同一个 key 的请求，只执行一次函数，其它请求等待结果。</li></ul><h5 id="Go-官方实现（sync-singleflight）"><a href="#Go-官方实现（sync-singleflight）" class="headerlink" title="Go 官方实现（sync&#x2F;singleflight）"></a><strong>Go 官方实现（sync&#x2F;singleflight）</strong></h5><p>核心结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line">  m  <span class="keyword">map</span>[<span class="type">string</span>]*call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">  wg  sync.WaitGroup</span><br><span class="line">  val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  err <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a><strong>执行流程</strong></h5><ol><li>请求到来时，先加锁，检查 key 是否已有 call：<ul><li>如果没有：新建 call，<code>wg.Add(1)</code>，异步执行 fn。</li><li>如果有：说明已有请求在跑，当前请求等待 <code>wg.Wait()</code>。</li></ul></li><li>fn 执行完成，存储结果 <code>val, err</code>，<code>wg.Done()</code> 唤醒等待的请求。</li><li>所有等待请求拿到同一个结果。</li></ol><h5 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a><strong>伪代码</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">  g.mu.Lock()</span><br><span class="line">  <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">    c.wg.Wait()</span><br><span class="line">    <span class="keyword">return</span> c.val, c.err</span><br><span class="line">  &#125;</span><br><span class="line">  c := <span class="built_in">new</span>(call)</span><br><span class="line">  c.wg.Add(<span class="number">1</span>)</span><br><span class="line">  g.m[key] = c</span><br><span class="line">  g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  c.val, c.err = fn()</span><br><span class="line">  c.wg.Done()</span><br><span class="line"></span><br><span class="line">  g.mu.Lock()</span><br><span class="line">  <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">  g.mu.Unlock()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h5><ul><li>保证同一 key 只执行一次，减少 DB 压力。</li><li>其他请求等待结果，避免击穿。</li><li>等待线程很多时可能放大延迟，但比打 DB 好。</li></ul><hr><p>✅ 面试答法总结：</p><ol><li><strong>布隆误报率</strong>：公式 + 最佳 k 值。</li><li><strong>NX+PX 校验 value</strong>：避免误删他人锁。</li><li><strong>负缓存 TTL 短</strong>：兼顾抗穿透和数据实时性。</li><li><strong>singleflight 实现</strong>：map+waitgroup，核心是请求合并。</li></ol><hr><h3 id="2-Redis-与数据库保持双写一致性的常见方案（权衡与实现）"><a href="#2-Redis-与数据库保持双写一致性的常见方案（权衡与实现）" class="headerlink" title="2. Redis 与数据库保持双写一致性的常见方案（权衡与实现）"></a><strong>2. Redis 与数据库保持双写一致性的常见方案（权衡与实现）</strong></h3><ul><li><strong>几类常见模式</strong><ul><li><strong>Cache-Aside（旁路缓存）</strong>（最常见）<ul><li>应用先读缓存（miss 去 DB 并回填缓存）；写操作先写 DB，再删除&#x2F;更新缓存（delete-then-write 或 write-then-delete 都有争议）。</li></ul></li><li><strong>Write-Through &#x2F; Read-Through</strong><ul><li>Write-through：应用写缓存，由缓存层负责同步写 DB（同步或异步）。优点：简单的一致性模型；缺点：写延迟高或缓存写失败复杂。</li><li>Read-through：缓存 miss 自动去 DB 并回填（由 cache 框架处理）。</li></ul></li><li><strong>Write-Behind（异步回写）</strong><ul><li>写入缓存并异步写入 DB（高吞吐但风险：崩溃可能丢数据）。</li></ul></li><li><strong>消息队列 + Eventual Consistency（推荐在分布式系统中）</strong><ul><li>写 DB -&gt; 产生事件（消息） -&gt; 异步消费者更新&#x2F;失效缓存。或写 DB 后删除 cache，再通过队列异步再次确认&#x2F;回写。</li></ul></li></ul></li><li><strong>常见一致性问题（race 条件）</strong><ul><li>写 DB 后竞争：A 写 DB 并删除缓存；B 并发读 DB 后写回旧值到缓存（导致缓存旧数据）。解决方法：<ul><li><strong>操作顺序</strong>：常见做法是 <code>DB write</code> -&gt; <code>delete cache</code>，但需要加锁或使用版本号&#x2F;时间戳来避免竞态。</li><li><strong>利用消息队列</strong>：DB 写完成后发消息，消费者串行&#x2F;有序地更新缓存或删除；保证缓存更新顺序。</li><li><strong>带版本号的数据</strong>：在缓存中存入版本号或时间戳，写入时比较版本仅写入更新的值。</li><li><strong>分布式锁</strong>：在更新缓存&#x2F;DB 时获得锁，防止并发回写旧数据（但影响并发性能）。</li></ul></li></ul></li><li><strong>推荐实践</strong><ul><li>优先采用 <strong>Cache-Aside + 消息队列</strong>：对写操作先写 DB，产生日志&#x2F;事件，缓存由消费者异步处理（保证最终一致）。读路径仍是先缓存。</li><li>对强一致性要求极高的场景考虑 <strong>数据库为主、缓存为辅</strong>（或使用 DB 的二级索引、Materialized View）。</li><li>使用 <strong>幂等、重试与版本控制</strong> 来降低竞态带来的不一致风险。</li></ul></li></ul><hr><h3 id="3-布隆过滤器（Bloom-Filter）原理、公式、变体与实战"><a href="#3-布隆过滤器（Bloom-Filter）原理、公式、变体与实战" class="headerlink" title="3. 布隆过滤器（Bloom Filter）原理、公式、变体与实战"></a><strong>3. 布隆过滤器（Bloom Filter）原理、公式、变体与实战</strong></h3><ul><li><p><strong>基本原理</strong></p><ul><li>使用一段位数组（m 位）和 k 个独立哈希函数。添加元素时对 k 个哈希位设为 1；查询时检查对应的 k 个位是否都为 1。如果有位为 0，则肯定不存在（无假阴性）。若全部为 1，说明“可能存在”（存在假阳性）。</li></ul></li><li><p><strong>关键公式</strong></p><ul><li><p>在插入 n 个元素，使用 m 位和 k 个哈希下，假阳性率近似为：<br>$$<br>p \approx \left(1 - e^{-kn&#x2F;m}\right)^k<br>$$</p></li><li><p>最优 k（使 p 最小）约等于 </p><p>$$<br>(k &#x3D; \frac{m}{n} \ln 2)<br>$$</p></li></ul></li><li><p><strong>变体</strong></p><ul><li><strong>Counting Bloom Filter</strong>：计数器代替位数组，支持删除（通过减计数），但内存大。</li><li><strong>Scalable Bloom Filter</strong>：当元素增长时，动态增加子过滤器来控制误报率。</li><li><strong>Partitioned Bloom &#x2F; Blocked Bloom</strong>：减少缓存行冲突、提高并发性能。</li></ul></li><li><p><strong>实现与应用</strong></p><ul><li>常用于：缓存穿透防护、数据库去重、web 去重、分布式系统快速判断存在性。</li><li><strong>实现注意</strong>：哈希函数必须分布均匀、独立（可用双哈希技术衍生多个哈希）。</li></ul></li><li><p><strong>示例（伪）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="number">10_000_000</span></span><br><span class="line">k = <span class="number">7</span></span><br><span class="line">bitarray = [<span class="number">0</span>]*m</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">    idx = hash_i(x, i) % m</span><br><span class="line">    bitarray[idx] = <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">might_contain</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">    <span class="keyword">if</span> bitarray[hash_i(x,i)%m] == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li><li><p><strong>面试追问</strong>：如何选择 m,k？怎样在分布式环境共享布隆过滤器（位图分片、Redis bitmap）？</p></li></ul><hr><h4 id="1-如何选择-m（位数组大小）和-k（哈希函数个数）？"><a href="#1-如何选择-m（位数组大小）和-k（哈希函数个数）？" class="headerlink" title="1. 如何选择 m（位数组大小）和 k（哈希函数个数）？"></a>1. 如何选择 m（位数组大小）和 k（哈希函数个数）？</h4><h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h5><p>已知：</p><ul><li>n &#x3D; 预计插入的元素数</li><li>p &#x3D; 允许的误报率</li></ul><p>求：</p><ul><li>m（bit 数组长度）</li><li>k（哈希函数个数）</li></ul><h5 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a><strong>公式推导</strong></h5><p>布隆过滤器误报率公式：<br>$$<br>[<br> p \approx \left(1 - e^{-\frac{kn}{m}}\right)^k<br> ]<br>$$<br>最优哈希函数个数（推导结论）：<br>$$<br>[<br> k &#x3D; \frac{m}{n} \ln 2<br> ]<br>$$<br>位数组大小：<br>$$<br>[<br> m &#x3D; -\frac{n \ln p}{(\ln 2)^2}<br> ]<br>$$<br>代入后，误报率约等于：<br>$$<br>[<br> p &#x3D; \left(0.6185\right)^{\frac{m}{n}}<br> ]<br>$$</p><hr><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a><strong>举例</strong></h5><p>比如：</p><ul><li>预计存 1000 万个 key（n&#x3D;10^7）</li><li>希望误报率 p&#x3D;1%</li></ul><p>计算：<br>$$<br>[<br> m &#x3D; - \frac{10^7 \times \ln(0.01)}{(\ln 2)^2} \approx 9.6 \times 10^7 \text{ bit} \approx 12 MB<br> ]<br>$$</p><p>$$<br>[<br> k &#x3D; \frac{m}{n} \ln 2 \approx 7<br> ]<br>$$</p><p>👉 所以要配置一个 12MB 的位数组，7 个 hash 函数，就能在千万级数据下保证 1% 的误报率。</p><hr><h4 id="2-分布式环境如何共享布隆过滤器？"><a href="#2-分布式环境如何共享布隆过滤器？" class="headerlink" title="2. 分布式环境如何共享布隆过滤器？"></a>2. 分布式环境如何共享布隆过滤器？</h4><p>单机内存版布隆过滤器没法直接支撑分布式系统，常见有两种思路：</p><h5 id="方案-A：位图分片（分布式切片存储）"><a href="#方案-A：位图分片（分布式切片存储）" class="headerlink" title="方案 A：位图分片（分布式切片存储）"></a><strong>方案 A：位图分片（分布式切片存储）</strong></h5><ul><li>将布隆过滤器的位数组 <strong>拆分成多个分片</strong>，存放在不同节点。</li><li>插入&#x2F;查询时，用 hash 定位到具体分片，然后设置&#x2F;检查位。</li><li>类似 <strong>一致性哈希</strong> 的思路，每个节点存自己的一部分。</li></ul><p><strong>优点</strong>：</p><ul><li>横向扩展，突破单机内存限制。</li><li>节点可以独立存储，减少单点瓶颈。</li></ul><p><strong>缺点</strong>：</p><ul><li>跨节点网络开销大（需要路由）。</li><li>容错要处理（某个节点挂掉可能丢失一部分位信息）。</li></ul><hr><h5 id="方案-B：共享存储（Redis-bitmap-最常见）"><a href="#方案-B：共享存储（Redis-bitmap-最常见）" class="headerlink" title="方案 B：共享存储（Redis bitmap 最常见）"></a><strong>方案 B：共享存储（Redis bitmap 最常见）</strong></h5><ul><li><p>把布隆过滤器的 bit 数组直接放在 Redis，利用 Redis 的 <strong>bitmap</strong> 操作。</p></li><li><p>插入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT bloom key offset 1</span><br></pre></td></tr></table></figure></li><li><p>查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT bloom key offset</span><br></pre></td></tr></table></figure></li><li><p>Redis 本身就是分布式的，可以通过 <strong>Cluster&#x2F;分片</strong> 方式存储超大 bit 数组。</p></li></ul><p><strong>优点</strong>：</p><ul><li>使用 Redis 内建的持久化和高可用，省去自己管理分片。</li><li>简单易用，社区有现成实现（如 Redisson 提供布隆过滤器）。</li></ul><p><strong>缺点</strong>：</p><ul><li>Redis 成为性能瓶颈（高并发下 bitmap 操作频繁）。</li><li>网络 IO 增加延迟（相比本地内存）。</li></ul><hr><h5 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a><strong>其他方案</strong></h5><ul><li><strong>RocksDB + bitmap</strong>：适合本地持久化布隆。</li><li><strong>Kafka Streams &#x2F; Flink</strong>：流式场景下，用布隆做过滤，分片交给框架本身的 state 管理。</li><li><strong>Counting Bloom Filter</strong>：用计数器代替 bit，可支持删除（但占用更多空间）。</li></ul><hr><h4 id="🔑-面试答法总结"><a href="#🔑-面试答法总结" class="headerlink" title="🔑 面试答法总结"></a>🔑 面试答法总结</h4><ul><li><strong>选择 m,k</strong>：<ul><li>m &#x3D; (-n \ln p &#x2F; (\ln 2)^2)</li><li>k &#x3D; (m&#x2F;n) ln 2</li></ul></li><li><strong>共享布隆过滤器</strong>：<ol><li><strong>位图分片</strong>（类似一致性哈希，节点分片存储）。</li><li><strong>Redis bitmap</strong>（集中式存储，利用 Redis 的 SETBIT&#x2F;GETBIT）。</li></ol></li></ul><hr><h3 id="4-消息队列如何保证顺序消费？（策略与代价）"><a href="#4-消息队列如何保证顺序消费？（策略与代价）" class="headerlink" title="4. 消息队列如何保证顺序消费？（策略与代价）"></a><strong>4. 消息队列如何保证顺序消费？（策略与代价）</strong></h3><ul><li><strong>保证顺序的基本思路</strong><ul><li>顺序消费需要对一组相关消息在单一顺序流（partition&#x2F;queue）中处理：<strong>把同 key 的消息映射到同一个分区&#x2F;队列</strong>，并由该 partition 的单一消费者或单线程序列化消费。</li></ul></li><li><strong>常见实现</strong><ul><li><strong>Kafka</strong>：按 <code>key</code> 分区，单个 partition 内消息有序；由同一 consumer instance 顺序消费（注意重平衡时可能短暂中断）。</li><li><strong>RabbitMQ</strong> &#x2F; 传统队列：把相关消息放在同一队列，由单一消费者顺序消费（但单一消费者可能成为瓶颈）。</li><li><strong>SQS FIFO</strong>：提供 <code>MessageGroupId</code> 保证组内顺序。</li></ul></li><li><strong>要点与陷阱</strong><ul><li>顺序与吞吐量冲突：单 partition&#x2F;单消费者限制吞吐量；为兼顾吞吐需要分 key 粒度切分。</li><li>消费失败与重试：若失败导致重复消费或延迟，会影响全局顺序（需要 careful 设计，如顺序重试队列或把失败消息单独挪出）。</li><li>消费者水平扩展时要保持 key 到 partition 的映射稳定（避免重分区导致不必要的重新排序）。</li></ul></li><li><strong>实践建议</strong><ul><li>分配合适的 partition 数量与 key 设计（热点 key 可能成为瓶颈）。</li><li>对需要严格全局顺序的场景（较少）考虑单线程处理或全局序列号系统。</li><li>使用幂等消费逻辑与事务&#x2F;offset 管理保证在重试时仍能正确处理。</li></ul></li></ul><hr><h3 id="5-消息队列如何保证消息不丢？（持久化、复制、ACK）"><a href="#5-消息队列如何保证消息不丢？（持久化、复制、ACK）" class="headerlink" title="5. 消息队列如何保证消息不丢？（持久化、复制、ACK）"></a><strong>5. 消息队列如何保证消息不丢？（持久化、复制、ACK）</strong></h3><ul><li><strong>关键机制</strong><ul><li><strong>持久化（durable）</strong>：消息写入磁盘（或持久日志），即使 Broker 重启消息仍在。</li><li><strong>副本&#x2F;复制</strong>：将消息复制到多个 broker 节点（例如 Kafka 的 ISR），至少写入多数副本才算成功（降低单点丢失）。</li><li><strong>确认机制（ACK）</strong>：消费者处理后返回 ACK；Broker 在确认后才删除消息（或提交 offset）。</li><li><strong>重试与死信队列（DLQ）</strong>：失败的消息重试若超过阈值发往 DLQ。</li><li><strong>事务&#x2F;幂等生产者</strong>：保证生产端的重复发送不会丢或重复计数（Kafka 的幂等 producer + transactional）。</li></ul></li><li><strong>系统参数（以 Kafka 为例）</strong><ul><li><code>acks=all</code>（生产者要求 leader 等待 ISR 中多数副本确认）</li><li><code>min.insync.replicas</code>（要求写入的最小同步副本数）</li><li><code>replication.factor</code>（副本数）</li></ul></li><li><strong>设计权衡</strong><ul><li>更高的持久性 → 写延迟上升、吞吐下降。</li><li>同步复制 vs 异步复制的选择：异步快但有丢数据风险。</li></ul></li><li><strong>实战建议</strong><ul><li>对关键数据启用同步复制、持久化、且配置合适的 <code>min.insync.replicas</code>。</li><li>使用事务&#x2F;幂等保证端到端一致性（当需要 exactly-once 或低丢失）。</li></ul></li></ul><hr><h3 id="6-消息队列如何保证不重复消费？（幂等、去重、事务）"><a href="#6-消息队列如何保证不重复消费？（幂等、去重、事务）" class="headerlink" title="6. 消息队列如何保证不重复消费？（幂等、去重、事务）"></a><strong>6. 消息队列如何保证不重复消费？（幂等、去重、事务）</strong></h3><ul><li><p><strong>常见目标与模式</strong></p><ul><li>通常消息传递模型是 <strong>at-least-once</strong>（可能重复），需要消费者保证幂等或使用外部去重。</li></ul></li><li><p><strong>实现方法</strong></p><ul><li><strong>幂等处理</strong>：业务操作本身设计为幂等（例如使用 PUT 替代增量操作，或根据消息 id 做一次性处理）。</li><li><strong>去重表（Dedup store）</strong>：消费者在处理消息前检查消息 ID（例如 <code>msgId</code> 存入 Redis&#x2F;DB 的集合&#x2F;表），若已存在则跳过。需要 TTL 或清理策略。</li><li><strong>事务性写入 + 提交 offset 的原子性</strong>（exactly-once）：<ul><li>Kafka 提供事务 API：消费者读取、处理并把结果写回 Kafka，再原子提交 offset（实现端到端 exactly-once 在一定场景下）。</li><li><strong>Outbox Pattern</strong>：在 DB 事务中把消息写入 outbox 表，事务提交后异步将 outbox 的消息发到消息队列；消费者消费幂等写入到 DB。</li></ul></li></ul></li><li><p><strong>复杂性与代价</strong></p><ul><li>去重存储是状态式，可能成为瓶颈；需要高性能的去重存储（Redis、Cassandra）。</li><li>完全 exactly-once 跨服务极难，通常用幂等+去重+事务组合来实现近似 exactly-once。</li></ul></li><li><p><strong>示例（伪）</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if redis.sismember(&quot;processed&quot;, msg.id):</span><br><span class="line">    ack and return</span><br><span class="line">process business</span><br><span class="line">record = db.write(...)</span><br><span class="line">redis.sadd(&quot;processed&quot;, msg.id); set TTL</span><br><span class="line">ack</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-消息队列：Push（推）与-Pull（拉）使用场景对比"><a href="#7-消息队列：Push（推）与-Pull（拉）使用场景对比" class="headerlink" title="7. 消息队列：Push（推）与 Pull（拉）使用场景对比"></a><strong>7. 消息队列：Push（推）与 Pull（拉）使用场景对比</strong></h3><ul><li><strong>Push（Broker 推送到 Consumer）</strong><ul><li>优点：低延迟、实现简单（事件驱动），适用于消费端能快速处理或有背压机制的场景；常见于 RabbitMQ（broker push 模式）、webhooks。</li><li>缺点：消费者容易被突发流量压垮（需要流量控制、限速、QoS）。</li><li>场景：实时通知、webhook、低延迟实时事件。</li></ul></li><li><strong>Pull（Consumer 拉取消息）</strong><ul><li>优点：消费者控制消费速率（自然背压），易于扩展消费者并发；适合高吞吐、批量处理场景。常见于 Kafka、SQS。</li><li>缺点：拉取轮询或长轮询会增加实现复杂度、延迟稍高。</li><li>场景：日志收集、大数据批量处理、消费者需要控制批量大小或处理速度（例如按窗口消费）。</li></ul></li><li><strong>混合&#x2F;折中</strong><ul><li>长轮询（SQS long polling）或 push + client-side window 控制提供折中方案。</li><li>Broker 可以根据 consumer 的能力调整推送速率（Flow control &#x2F; QoS）。</li></ul></li></ul><hr><h3 id="8-分布式锁：原理与常见实现"><a href="#8-分布式锁：原理与常见实现" class="headerlink" title="8. 分布式锁：原理与常见实现"></a><strong>8. 分布式锁：原理与常见实现</strong></h3><ul><li><p><strong>核心目标</strong>：在分布式环境下对共享资源做互斥控制（同一时刻只有一个客户端持有锁）。</p></li><li><p><strong>常见实现方式</strong></p><ul><li><strong>Redis + SET NX PX</strong>：<ul><li><code>SET key value NX PX ttl</code>：原子取得锁并设置超时，释放锁需检查 value（防止误删别人的锁）。</li><li>释放锁用 Lua 脚本保证原子性（先比较 value，再删除）。</li></ul></li><li><strong>RedLock</strong>（多 Redis 实例交叉锁定）：<ul><li>在多个独立 Redis 节点上尝试加锁，过半成功则认为获得锁；争议：理论上在网络分区下可能不安全，需谨慎使用。</li></ul></li><li><strong>Zookeeper</strong>：<ul><li>使用临时顺序节点（ephemeral sequential）实现锁，节点删除或会话断开时自动释放锁；ZK 提供强一致性（推荐用于强一致性场景）。</li></ul></li><li><strong>etcd &#x2F; Consul</strong>：<ul><li>基于 Lease + Compare-And-Swap（CAS）实现，且有自动延续 lease 的机制。</li></ul></li><li><strong>数据库行锁</strong>（SELECT … FOR UPDATE &#x2F; update with condition）：<ul><li>简单但可能影响 DB 性能，适用于不高并发或已有 DB 保证版场景。</li></ul></li></ul></li><li><p><strong>注意点</strong></p><ul><li>锁超时要合理，避免持有锁的客户端长时间阻塞（但若过短又可能被误抢）。</li><li>锁的可重入、可续租（renew）、可释放性设计。</li><li>要保证释放锁的操作是原子且只释放自己的锁（比较 value）。</li></ul></li><li><p><strong>示例：Redis 释放 Lua（伪）</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p><strong>面试追问</strong>：RedLock 的争议是什么？为什么 ZK&#x2F;etcd 更安全（因为它们使用强一致的 consensus）？</p></li></ul><hr><h4 id="1-RedLock-的背景"><a href="#1-RedLock-的背景" class="headerlink" title="1. RedLock 的背景"></a>1. RedLock 的背景</h4><p>RedLock 是 Redis 作者 antirez 提出的<strong>分布式锁算法</strong>：</p><ul><li>在 N 个 Redis 节点上尝试获取锁（例如 5 个节点）。</li><li>至少在多数节点（N&#x2F;2+1）成功才算加锁成功。</li><li>通过设置过期时间（TTL）防止死锁。</li><li>用于容错，避免单机 Redis 挂掉导致锁失效。</li></ul><hr><h4 id="2-RedLock-的争议点"><a href="#2-RedLock-的争议点" class="headerlink" title="2. RedLock 的争议点"></a>2. RedLock 的争议点</h4><p>虽然 RedLock 在 Redis 场景下很火，但它<strong>并不被业界普遍认为是严格安全的分布式锁</strong>，主要争议：</p><h5 id="1-基于过期时间的安全性不足"><a href="#1-基于过期时间的安全性不足" class="headerlink" title="(1) 基于过期时间的安全性不足"></a>(1) <strong>基于过期时间的安全性不足</strong></h5><ul><li>RedLock 依赖锁的 TTL，防止持有者宕机导致死锁。</li><li>但如果 <strong>GC 停顿 &#x2F; 网络分区 &#x2F; 客户端挂起</strong>，锁可能在 TTL 到期后被其他进程获取。</li><li>原持有者恢复后，可能“误以为自己还持有锁”，导致<strong>两个客户端同时认为自己有锁</strong> → <strong>安全性问题</strong>。</li></ul><h5 id="2-Redis-本身是-AP-系统（高可用优先）"><a href="#2-Redis-本身是-AP-系统（高可用优先）" class="headerlink" title="(2) Redis 本身是 AP 系统（高可用优先）"></a>(2) <strong>Redis 本身是 AP 系统</strong>（高可用优先）</h5><ul><li>Redis 集群主从复制是 <strong>异步</strong> 的。</li><li>当写入锁 key 后，主节点宕机、从节点切换为主节点时，<strong>可能丢失锁记录</strong>（数据还没同步到从节点）。</li><li>导致<strong>锁丢失</strong> → 另一个客户端能重新加锁。</li></ul><h5 id="3-复杂环境下正确性无法保证"><a href="#3-复杂环境下正确性无法保证" class="headerlink" title="(3) 复杂环境下正确性无法保证"></a>(3) <strong>复杂环境下正确性无法保证</strong></h5><ul><li>Martin Kleppmann（分布式系统专家，《Designing Data-Intensive Applications》作者）在博客里<strong>批评过 RedLock</strong>：<ul><li>RedLock 没有给出严格的形式化证明，不能保证在网络分区、时钟漂移等场景下一致性。</li><li>认为 RedLock 在需要“强安全性”的业务（例如金融转账、支付）里不合适。</li></ul></li></ul><hr><h4 id="3-为什么-Zookeeper-etcd-更安全？"><a href="#3-为什么-Zookeeper-etcd-更安全？" class="headerlink" title="3. 为什么 Zookeeper &#x2F; etcd 更安全？"></a>3. 为什么 Zookeeper &#x2F; etcd 更安全？</h4><h5 id="1-基于强一致性共识协议（Consensus）"><a href="#1-基于强一致性共识协议（Consensus）" class="headerlink" title="(1) 基于强一致性共识协议（Consensus）"></a>(1) <strong>基于强一致性共识协议（Consensus）</strong></h5><ul><li>Zookeeper：基于 <strong>ZAB（Zookeeper Atomic Broadcast）</strong> 协议，本质类似 Paxos。</li><li>etcd：基于 <strong>Raft 共识算法</strong>。</li><li>这类系统保证：<ul><li>写入数据必须经过多数派确认。</li><li>所有节点对锁的状态有<strong>强一致性保证</strong>。</li><li>不会出现“一个客户端认为有锁，另一个客户端也认为有锁”的情况。</li></ul></li></ul><h5 id="2-锁释放-会话管理更可靠"><a href="#2-锁释放-会话管理更可靠" class="headerlink" title="(2) 锁释放&#x2F;会话管理更可靠"></a>(2) <strong>锁释放&#x2F;会话管理更可靠</strong></h5><ul><li>ZK&#x2F;etcd 支持 <strong>临时节点（Ephemeral Node）</strong>：<ul><li>客户端与服务端保持会话心跳。</li><li>一旦客户端宕机或网络断开，临时节点会自动删除，锁自动释放。</li></ul></li><li>这比 Redis 的 TTL + value check 更强健，避免了 GC 停顿、长延迟导致的锁误删&#x2F;锁漂移问题。</li></ul><h5 id="3-阻塞-顺序保证"><a href="#3-阻塞-顺序保证" class="headerlink" title="(3) 阻塞&#x2F;顺序保证"></a>(3) <strong>阻塞&#x2F;顺序保证</strong></h5><ul><li>Zookeeper 的 <strong>有序节点（Sequential Node）</strong> + Watch 机制，可以实现 <strong>公平锁</strong>（按顺序排队获取锁）。</li><li>Redis 分布式锁一般只能实现“谁抢到就是谁的”，无法实现严格的排队公平性。</li></ul><hr><h4 id="4-总结面试答法"><a href="#4-总结面试答法" class="headerlink" title="4. 总结面试答法"></a>4. 总结面试答法</h4><p>如果面试官问：<br> <strong>“RedLock 争议在哪里？为什么用 ZK&#x2F;etcd 更安全？”</strong></p><p>你可以这么答：</p><blockquote><p>RedLock 的核心问题在于它依赖 TTL 和 Redis 的异步复制，在 GC 停顿、网络分区或主从切换时，可能导致多个客户端同时认为自己持有锁；而 Redis 本身更偏向 AP，不能保证强一致性。</p><p>相比之下，Zookeeper 和 etcd 基于强一致性共识协议（ZAB &#x2F; Raft），锁的状态必须经过多数派确认，并且利用临时节点和会话机制确保锁自动释放，因此不会出现 RedLock 的安全性漏洞，更适合需要严格分布式一致性的场景。</p></blockquote><hr><p>✅ 简化记忆版：</p><ul><li><strong>RedLock 争议</strong>：基于过期时间，不抗 GC&#x2F;网络分区&#x2F;主从切换；Redis 异步复制可能丢锁。</li><li><strong>ZK&#x2F;etcd 优势</strong>：强一致（共识协议）、临时节点（会话自动释放）、顺序保证（公平锁）。</li></ul><hr><h3 id="9-分布式事务与常见解决方案"><a href="#9-分布式事务与常见解决方案" class="headerlink" title="9. 分布式事务与常见解决方案"></a><strong>9. 分布式事务与常见解决方案</strong></h3><ul><li><strong>问题定义</strong>：跨多个服务 &#x2F; 数据源的事务一致性（ACID）难以直接用单体数据库事务保证。</li><li><strong>常见方案</strong><ul><li><strong>2PC（Two-Phase Commit）</strong>：<ul><li>协调者先询问参与者是否准备提交（prepare），若都准备则提交（commit）；问题：阻塞、实现复杂、对性能影响大。</li></ul></li><li><strong>3PC（Three-Phase Commit）</strong>：在 2PC 基础上缓解阻塞，但复杂性更高，实际少用。</li><li><strong>Saga 模式</strong>（推荐）：<ul><li>把一个长事务拆成多个本地事务，各自提交并通过补偿事务回滚（两类实现：choreography（事件驱动）或 orchestration（集中编排器））。</li><li>优点：无全局锁、易扩展；缺点：实现补偿逻辑复杂、最终一致性而非强一致。</li></ul></li><li><strong>TCC（Try-Confirm-Cancel）</strong>：<ul><li>三阶段：try（资源预留），confirm（实际提交），cancel（回滚）。适合需要明确资源预占的场景。</li></ul></li><li><strong>Outbox Pattern + Message Relay &#x2F; CDC</strong>：<ul><li>在本地 DB 事务中写入业务数据 + outbox 表（原子），事务提交后异步把 outbox 发送给消息总线，其他服务消费。避免消息丢失与跨服务事务问题。</li></ul></li><li><strong>基于事件驱动的最终一致性</strong>：事件来源（event sourcing）+消费端对事件进行处理。</li></ul></li><li><strong>选择标准</strong><ul><li>强一致性 vs 可用性权衡：业务是否能容忍最终一致性？</li><li>复杂度和运维成本：2PC 很难扩展到微服务环境，Saga&#x2F;Outbox 更现实。</li></ul></li><li><strong>面试追问</strong>：如何保证 Saga 的补偿能成功？如何处理补偿失败（人工干预&#x2F;补偿队列）？</li></ul><hr><h3 id="10-CAP-理论（与扩展-PACELC）"><a href="#10-CAP-理论（与扩展-PACELC）" class="headerlink" title="10. CAP 理论（与扩展 PACELC）"></a><strong>10. CAP 理论（与扩展 PACELC）</strong></h3><ul><li><strong>CAP 三要素</strong><ul><li><strong>Consistency（一致性）</strong>：所有节点在同一时间看到相同数据（读到最新写入）。</li><li><strong>Availability（可用性）</strong>：每个请求都能在有限时间内得到成功或失败响应（系统持续可用）。</li><li><strong>Partition tolerance（分区容忍性）</strong>：系统在出现网络分区（分节点间通信失败）下仍可继续运行。</li></ul></li><li><strong>定理结论</strong>：在网络分区发生时，分布式系统只能在一致性（C）和可用性（A）间做权衡（只能保证其中之一 + partition）。</li><li><strong>现实系统的取舍</strong><ul><li><strong>CP 系统</strong>（优先一致性）：例如 HBase 在分区期选择不可用以保证一致性。</li><li><strong>AP 系统</strong>（优先可用性）：例如 Cassandra 在分区期仍提供服务，但数据可能最终一致。</li></ul></li><li><strong>PACELC 扩展</strong><ul><li>PACELC：在 Partition（P）发生时在 A 与 C 之间取舍；Else（E）在正常情况下在 Latency（L）和 Consistency（C）之间取舍。</li></ul></li><li><strong>面试要点</strong><ul><li>不要直接说某系统“遵循 CAP”，而是说明在何种故障场景选择了哪种折中。</li><li>系统常采用复制策略、Quorum 写&#x2F;读策略来在一致性&#x2F;可用性间做灵活配置（例如 quorum 写多数策略）。</li></ul></li></ul><hr><h3 id="11-数据库连接池：是什么、为何需要、关键配置项"><a href="#11-数据库连接池：是什么、为何需要、关键配置项" class="headerlink" title="11. 数据库连接池：是什么、为何需要、关键配置项"></a><strong>11. 数据库连接池：是什么、为何需要、关键配置项</strong></h3><ul><li><strong>概念</strong>：在应用中维护一组可复用的数据库连接，避免频繁创建&#x2F;销毁连接的开销。</li><li><strong>为什么需要</strong><ul><li>建立数据库连接开销大（TCP 握手、认证、会话建立）。</li><li>限制并发连接数，防止 DB 被过多连接冲垮。</li><li>提高性能（连接复用、预热好处），并可缓存 PreparedStatements。</li></ul></li><li><strong>重要配置</strong><ul><li><code>maxPoolSize</code>（最大连接数）、<code>minIdle</code>、<code>maxIdle</code>、<code>connectionTimeout</code>、<code>idleTimeout</code>、<code>validationQuery</code>、<code>leakDetectionThreshold</code>。</li><li><code>testOnBorrow/testOnReturn</code>（是否在借出&#x2F;归还时检测连接健康）。</li></ul></li><li><strong>实现注意</strong><ul><li><strong>连接泄露监测</strong>：若开发者忘记关闭连接需能检测并回收。</li><li><strong>事务边界</strong>：确保在事务结束时释放连接（尤其在框架&#x2F;中间件层）。</li><li><strong>Pool 与 DB 的匹配</strong>：maxPoolSize 不应超过 DB 能支持的最大并发连接数。</li></ul></li><li><strong>常见连接池实现</strong>：HikariCP（推荐，性能优）、Tomcat JDBC pool、Druid、c3p0。</li><li><strong>面试追问</strong>：为什么 <code>maxPoolSize</code> 不能设太大？如何排查连接泄漏？如何检测连接是否活着（validation）？</li></ul><hr><h3 id="12-一致性哈希（Consistent-Hashing）详解"><a href="#12-一致性哈希（Consistent-Hashing）详解" class="headerlink" title="12. 一致性哈希（Consistent Hashing）详解"></a><strong>12. 一致性哈希（Consistent Hashing）详解</strong></h3><ul><li><strong>问题背景</strong>：节点增删时，如何尽量减少 key 重映射（降低缓存失效带来的重建压力）。</li><li><strong>基本机制</strong><ul><li>把整个哈希空间想成环（0..2^32-1），每个节点映射到环上的若干位置（虚拟节点 vnodes）。Key 的 hash 决定它在环上的位置，向顺时针找到第一个节点作为该 key 的负责节点。</li></ul></li><li><strong>优点</strong><ul><li>节点加入&#x2F;删除只影响相邻片段的 key（只需迁移少部分 key）。</li><li>使用虚拟节点能均衡负载（一个真实节点挂多个 vnode）。</li></ul></li><li><strong>实现要点</strong><ul><li>选择稳定且分布均匀的哈希函数（例如 MurmurHash）。</li><li>使用足够多的虚拟节点根据节点权重分配（权重高的节点分配更多 vnode）。</li><li>支持副本（复制到环上连续的下 k 个 vnode）保证容错。</li></ul></li><li><strong>应用场景</strong><ul><li>缓存分片（Memcached&#x2F;Ketama）、分布式存储&#x2F;查找（DHT）。</li></ul></li><li><strong>面试追问</strong>：如何处理节点权重？为什么需要虚拟节点？如何在一致性哈希上做数据迁移？</li></ul><hr><h3 id="13-负载均衡（LB）"><a href="#13-负载均衡（LB）" class="headerlink" title="13. 负载均衡（LB）"></a><strong>13. 负载均衡（LB）</strong></h3><ul><li><strong>分类</strong><ul><li><strong>DNS 负载均衡</strong>：把域名解析到多个 IP（粗粒度，受 DNS 缓存影响）。</li><li><strong>L4（传输层）负载均衡</strong>：基于 IP&#x2F;端口（如 LVS、Nginx 的 stream 模式）。</li><li><strong>L7（应用层）负载均衡</strong>：基于 HTTP 信息（URI、Header、Cookie）做路由（如 Nginx、Envoy、Traefik）。</li><li><strong>全局负载均衡（GSLB）</strong>：跨区域&#x2F;数据中心调度。</li></ul></li><li><strong>常见调度算法</strong><ul><li>轮询（Round Robin）、加权轮询、最少连接、源地址哈希（IP hash）、一致性哈希、响应时间加权。</li></ul></li><li><strong>功能</strong><ul><li>健康检查（主动 probe、被动探测）、会话保持（sticky session）、SSL 终止、速率限制、熔断、路由规则。</li></ul></li><li><strong>实现细节</strong><ul><li>健康检查频率、超时和失败阈值设定直接影响可用性和故障转移速度。</li><li>粘性会话：通过 cookie 或源 IP 维持会话，但影响水平扩展和容错。</li><li>与自动扩缩结合：LB 应感知实例的加入&#x2F;移除（服务发现）。</li></ul></li><li><strong>面试点</strong>：L4 与 L7 的区别、何时使用粘性会话、负载均衡的瓶颈与调优参数（连接池、keepalive）。</li></ul><hr><h3 id="14-限流算法（详述：Token-Bucket-Leaky-Bucket-Fixed-Window-Sliding-Window）"><a href="#14-限流算法（详述：Token-Bucket-Leaky-Bucket-Fixed-Window-Sliding-Window）" class="headerlink" title="14. 限流算法（详述：Token Bucket, Leaky Bucket, Fixed Window, Sliding Window）"></a><strong>14. 限流算法（详述：Token Bucket, Leaky Bucket, Fixed Window, Sliding Window）</strong></h3><ul><li><strong>Fixed Window（固定窗口计数）</strong><ul><li>将时间划分到固定窗口（例如每分钟），用计数器统计请求数。实现简单但边界窗口会导致突发流量（例如窗口末尾+窗口开始）。</li></ul></li><li><strong>Sliding Window Log（滑动窗口日志）</strong><ul><li>记录每个请求时间戳，精确但内存消耗大。</li></ul></li><li><strong>Sliding Window Counter（滑动计数器）</strong><ul><li>把时间分成多个小桶，近似滑动窗口精度与性能的折中。</li></ul></li><li><strong>Token Bucket（令牌桶）</strong>（常用）<ul><li>系统以固定速率向桶中放令牌，消费请求取令牌；允许短时间突发（桶有存量）。</li></ul></li><li><strong>Leaky Bucket（漏桶）</strong><ul><li>请求进桶，按恒定速率漏出消费；更偏向平滑输出，抑制突发。</li></ul></li><li><strong>分布式实现</strong><ul><li>Redis + 原子脚本（Lua）实现计数与令牌发放，或使用内置限流中间件（Envoy rate limit）。</li><li>要保证原子性（避免 race），通常使用 Lua 脚本在 Redis 上实现令牌桶。</li></ul></li><li><strong>示例 Redis Lua（令牌桶思路，伪）</strong><ul><li>检查并更新时间戳与令牌计数，返回允许&#x2F;拒绝。</li></ul></li><li><strong>选择建议</strong><ul><li>需要短突发能力用 Token Bucket；要求严格平滑输出用 Leaky Bucket；简单限速可用 Fixed Window。</li></ul></li><li><strong>面试追问</strong>：如何在分布式部署下实现全局限流？（使用 centralized Redis、或 local token + periodic refill）</li></ul><hr><h3 id="15-分布式-ID（生成方案：UUID-Snowflake-DB-sequence-Redis）"><a href="#15-分布式-ID（生成方案：UUID-Snowflake-DB-sequence-Redis）" class="headerlink" title="15. 分布式 ID（生成方案：UUID &#x2F; Snowflake &#x2F; DB sequence &#x2F; Redis）"></a><strong>15. 分布式 ID（生成方案：UUID &#x2F; Snowflake &#x2F; DB sequence &#x2F; Redis）</strong></h3><ul><li><strong>常用方案对比</strong><ul><li><strong>UUID</strong>：全局唯一，冲突概率极低，但长度大、不可顺序排序（影响索引）。</li><li><strong>Snowflake（Twitter）</strong>：时间戳 + dataCenterId + workerId + sequence —— 有序（按时间近似排序），高吞吐，常见实现。<ul><li>优点：有序、短小、可解码（包含时间），高性能。</li><li>风险：时间回退会导致 ID 冲突，机器 ID 管理困难，sequence 溢出需要等待下一毫秒。</li></ul></li><li><strong>数据库 Sequence</strong>：简单、强一致（如果用单 DB），但单点与性能受限。</li><li><strong>Redis INCR</strong>：高性能、分布式，但跨实例同步与持久性需注意（及分区问题）。</li><li><strong>KSUID &#x2F; ULID &#x2F; Sonyflake</strong>：支持排序与更长时间范围的变种。</li></ul></li><li><strong>Snowflake 典型位分配（示例）</strong><ul><li>1 bit unused | 41 bits timestamp | 10 bits machine id | 12 bits sequence</li></ul></li><li><strong>实践注意</strong><ul><li><strong>时间回退</strong>问题：使用 NTP，要对时钟回退做防护（拒绝、等待或使用逻辑时钟）。</li><li><strong>机器 ID 分配</strong>：静态配置或通过注册中心分配；需避免冲突。</li><li><strong>高可用</strong>：可使用多个发号服务并保证不同范围&#x2F;前缀来避免冲突。</li></ul></li><li><strong>面试追问</strong>：如何解决 Snowflake 在时钟回退情况下的冲突？如何保证全局唯一与高性能并行发号？</li></ul><hr><h4 id="一、Snowflake-在时钟回退（clock-rollback-clock-drift）下的常见风险"><a href="#一、Snowflake-在时钟回退（clock-rollback-clock-drift）下的常见风险" class="headerlink" title="一、Snowflake 在时钟回退（clock rollback &#x2F; clock drift）下的常见风险"></a>一、Snowflake 在时钟回退（clock rollback &#x2F; clock drift）下的常见风险</h4><p>核心风险是：如果节点本地时钟回退（比如 NTP 同步、虚拟机迁移、系统时间被改、短暂的时钟回拨），生成的 timestamp 可能小于之前生成的 <code>lastTimestamp</code>，导致：</p><ul><li>生成重复 ID（如果 timestamp 部分变小而 sequence 又从 0 开始），或</li><li>生成“时间倒序”的 ID，破坏单调性，影响有序性依赖的系统（日志、排序、DB 分区键等）。</li></ul><hr><h4 id="二、常用的解决策略（按从简单到稳健排序）"><a href="#二、常用的解决策略（按从简单到稳健排序）" class="headerlink" title="二、常用的解决策略（按从简单到稳健排序）"></a>二、常用的解决策略（按从简单到稳健排序）</h4><h5 id="1-最简单：拒绝-等待（Recommended-first-line）"><a href="#1-最简单：拒绝-等待（Recommended-first-line）" class="headerlink" title="1) 最简单：拒绝&#x2F;等待（Recommended first-line）"></a>1) 最简单：拒绝&#x2F;等待（Recommended first-line）</h5><ul><li>实现：检测到 <code>now &lt; lastTimestamp</code> 时，<strong>阻塞并等待</strong>直到 <code>now &gt;= lastTimestamp</code>（spin&#x2F;sleep 少量毫秒）。</li><li>何时用：回退幅度很小（几十毫秒 ~ 几百毫秒）。</li><li>缺点：如果回退较大，会导致服务阻塞；不能在低可用场景无限等待。</li></ul><p><strong>伪码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">now := currentMillis()</span><br><span class="line"><span class="keyword">if</span> now &lt; lastTimestamp &#123;</span><br><span class="line">    <span class="comment">// spin/wait up to threshold</span></span><br><span class="line">    waitUntil(lastTimestamp)</span><br><span class="line">    now = currentMillis()</span><br><span class="line">    <span class="keyword">if</span> now &lt; lastTimestamp &#123; <span class="type">error</span>(<span class="string">&quot;clock moved backwards too much&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="2-使用备用-sequence-空间（短期“虚拟时间”）"><a href="#2-使用备用-sequence-空间（短期“虚拟时间”）" class="headerlink" title="2) 使用备用 sequence 空间（短期“虚拟时间”）"></a>2) 使用备用 sequence 空间（短期“虚拟时间”）</h5><ul><li>思路：当 <code>now &lt; lastTimestamp</code> 且差值小于阈值时，<strong>继续使用 lastTimestamp，但把 sequence 推进到一个高位段</strong>（使在同一 timestamp 下仍产生唯一 id）。</li><li>要点：sequence 位要足够（例如 12 位），但这种做法在 long rollback 情况下会耗尽 sequence 导致失败。</li><li>风险：破坏严格的时间语义（ID 看起来像是同一毫秒生成），但仍保证唯一。</li></ul><p><strong>伪码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> now &lt; lastTimestamp &#123;</span><br><span class="line">  <span class="keyword">if</span> lastTimestamp - now &lt;= allowedBackwards &#123;</span><br><span class="line">    <span class="comment">// use lastTimestamp, advance sequence</span></span><br><span class="line">    seq = (seq + <span class="number">1</span>) &amp; maxSeq</span><br><span class="line">    <span class="keyword">if</span> seq == <span class="number">0</span> &#123; waitForNextMillis(lastTimestamp) &#125;</span><br><span class="line">    ts = lastTimestamp</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="3-用逻辑时钟-Hybrid-Logical-Clock-HLC"><a href="#3-用逻辑时钟-Hybrid-Logical-Clock-HLC" class="headerlink" title="3) 用逻辑时钟 &#x2F; Hybrid Logical Clock (HLC)"></a>3) 用逻辑时钟 &#x2F; Hybrid Logical Clock (HLC)</h5><ul><li>思路：维护一个 <code>logicalCounter</code>，当物理时间回退时用 <code>lastTimestamp</code> 和 <code>logicalCounter++</code> 作为时间拓展。HLC 能保证单调的“时间戳”且兼顾部分真实时间。</li><li>优点：不必长时间阻塞，能在分布式系统中保持因果单调性。</li><li>代价：需要把 timestamp 的低位&#x2F;额外位划给 logical counter（减少可用时间位或 sequence 位）。</li></ul><p><strong>伪码（核心）</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if physicalNow &gt; lastTimestamp:</span><br><span class="line">   lastTimestamp = physicalNow</span><br><span class="line">   logical = 0</span><br><span class="line">else:</span><br><span class="line">   logical += 1</span><br><span class="line">// ID 构造使用 (lastTimestamp, logical, nodeId, sequence)</span><br></pre></td></tr></table></figure><hr><h5 id="4-持久化-lastTimestamp（重启-迁移安全）"><a href="#4-持久化-lastTimestamp（重启-迁移安全）" class="headerlink" title="4) 持久化 lastTimestamp（重启&#x2F;迁移安全）"></a>4) 持久化 lastTimestamp（重启&#x2F;迁移安全）</h5><ul><li>将 <code>lastTimestamp</code>（或最近分配的 max id）写到本地磁盘（或 etcd）在进程启动时读取；</li><li>启动时保证新的 <code>lastTimestamp</code> &gt; persisted 值（若物理时钟后退导致当前时间小于 persisted 值，可选择等待或使用 persisted+1 作为基准）。</li><li>优点：避免重启后重复分配旧 ID。</li><li>缺点：增加 IO；写入策略要保证性能（可异步定期 flush，但要兼顾安全）。</li></ul><hr><h5 id="5-严格策略：主控-仲裁或切换到强一致时钟来源"><a href="#5-严格策略：主控-仲裁或切换到强一致时钟来源" class="headerlink" title="5) 严格策略：主控&#x2F;仲裁或切换到强一致时钟来源"></a>5) 严格策略：主控&#x2F;仲裁或切换到强一致时钟来源</h5><ul><li>利用外部服务（NTP 高精度 &#x2F; GPS &#x2F; 时间服务器）或用共识系统（etcd&#x2F;zookeeper）来校验时间或分配时间段。</li><li>也可把时间戳分配成 “逻辑时间 + nodeRange”，将时间分配的责任集中化（牺牲一点可用性换强一致性）。</li></ul><hr><h5 id="6-退避到备用发号方案（failover）"><a href="#6-退避到备用发号方案（failover）" class="headerlink" title="6) 退避到备用发号方案（failover）"></a>6) 退避到备用发号方案（failover）</h5><ul><li>当检测到严重回退（超过阈值）时，切换到备用发号器：<ul><li>从数据库获取一个批次&#x2F;段（HiLo），或</li><li>请求 central allocator（有状态）给出一段 ID_range。</li></ul></li><li>好处：稳妥但依赖中心化服务（可做主备）。</li></ul><hr><h4 id="三、如何保证全局唯一且高性能并行发号（设计模式与实作建议）"><a href="#三、如何保证全局唯一且高性能并行发号（设计模式与实作建议）" class="headerlink" title="三、如何保证全局唯一且高性能并行发号（设计模式与实作建议）"></a>三、如何保证全局唯一且高性能并行发号（设计模式与实作建议）</h4><p>目标：在<strong>全球分布、多实例</strong>场景下，保证<strong>唯一性</strong>、<strong>低延迟</strong>、<strong>高吞吐</strong>、并尽量保留可排序性。</p><h5 id="1-Snowflake-本身的可扩展性点"><a href="#1-Snowflake-本身的可扩展性点" class="headerlink" title="1) Snowflake 本身的可扩展性点"></a>1) Snowflake 本身的可扩展性点</h5><ul><li>每个实例（节点）只需有<strong>唯一的 workerId</strong>（和 datacenterId）。</li><li>本地只需维护 <code>lastTimestamp</code> 和 <code>sequence</code>，不需要中心协调 -&gt; 本地化、低延迟、高并发（每 ms 用 sequence 分配）。</li><li>扩容：增加 workerId 数目（需要更多位），或增加数据中心标识位。</li></ul><p>要点：<strong>workerId 必须严格唯一且稳定</strong>（见下文如何分配）。</p><hr><h5 id="2-保证-workerId-唯一的常用方案"><a href="#2-保证-workerId-唯一的常用方案" class="headerlink" title="2) 保证 workerId 唯一的常用方案"></a>2) 保证 workerId 唯一的常用方案</h5><ul><li><strong>静态配置</strong>：部署时人为分配（小规模）——简单但运维复杂。</li><li><strong>服务注册中心</strong>：用 etcd &#x2F; Zookeeper &#x2F; consul 在启动时获取唯一 ID（基于租约&#x2F;序号）。常见做法：注册并获得自增序号或 ephemeral node 的序号。</li><li><strong>云环境元数据</strong>：使用实例 ID &#x2F; MAC &#x2F; 私有 IP hash 但要避免冲突并处理重启后的重复问题（需要加 lease）。</li><li><strong>持久化绑定</strong>：把 workerId 与机器或容器绑定并持久化，避免重启&#x2F;迁移造成重复。</li></ul><p>推荐：用 etcd&#x2F;zookeeper 做带租约的分配（启动登记获得唯一 id，断开后租约释放可重新分配），这样可以自动避免长期重复。</p><hr><h5 id="3-提升并发能力的方法（水平扩展与局部优化）"><a href="#3-提升并发能力的方法（水平扩展与局部优化）" class="headerlink" title="3) 提升并发能力的方法（水平扩展与局部优化）"></a>3) 提升并发能力的方法（水平扩展与局部优化）</h5><ul><li><strong>增加并行节点数</strong>（更多 workerId），每节点本地速度不受影响。</li><li><strong>增加 sequence 位数</strong>（如果业务允许，扩大同 ms 内可分配的数量），但会减少给 timestamp&#x2F;worker 位的比特数，要权衡。</li><li><strong>批量&#x2F;批次分配（prefetch &#x2F; HiLo &#x2F; Segment）</strong>：<ul><li>中央分配器（DB&#x2F;etcd）分配一段 ID range（high），本地用 low 指针消费（HiLo&#x2F;Segment 模式）。优点：中央压力低、本地发号速度极高。</li><li>适合需要全局严格唯一但不强要求按时间严格排序的场景。</li></ul></li><li><strong>使用更短时间粒度或更大时间位长度</strong>：例如把时间单位从 ms 改为 µs（需要更多位），理论上提高并发量但实现复杂。</li><li><strong>批量生成</strong>：API 返回一批 ID 给上层，减少频繁请求。</li></ul><hr><h5 id="4-典型替代-改进实现（在生产中常见）"><a href="#4-典型替代-改进实现（在生产中常见）" class="headerlink" title="4) 典型替代&#x2F;改进实现（在生产中常见）"></a>4) 典型替代&#x2F;改进实现（在生产中常见）</h5><ul><li><strong>Sonyflake</strong>（由日本开发者）：解决了 Snowflake 的一些时钟回退问题，使用单调递增的时间戳（利用 monotonic clock），并在 nodeId 管理上更友好。</li><li><strong>ULID &#x2F; KSUID &#x2F; UUIDv1</strong>：在可排序与分布式唯一上提供替代，但会牺牲部分特点（例如 ULID 可排序）。</li><li><strong>HiLo &#x2F; Segment ID</strong>：数据库或 coordinator 分配高位，节点本地分配低位；适合超高并发与全球分布。</li></ul><hr><h5 id="5-实战推荐（工程化的一套做法）"><a href="#5-实战推荐（工程化的一套做法）" class="headerlink" title="5) 实战推荐（工程化的一套做法）"></a>5) 实战推荐（工程化的一套做法）</h5><ol><li><strong>workerId 分配</strong>：使用 etcd&#x2F;zk 的 ephemeral 序号绑定（启动注册获得唯一 id + lease）。</li><li><strong>持久化 lastTimestamp</strong>：周期性或关键点写到本地（崩溃&#x2F;重启后读取以防回退复用）。</li><li><strong>回退策略</strong>：<ul><li>若回退幅度小（&lt; X ms），spin&#x2F;wait；</li><li>若在一个安全阈值内，采用 HLC&#x2F;逻辑计数器；</li><li>若超阈值，报警并走备用发号（从 central allocator 获取 ID 段）。</li></ul></li><li><strong>监控与告警</strong>：监控本地时间跳变、sequence 耗尽、分配延迟、租约失效等指标。</li><li><strong>可配置位宽</strong>：根据业务预估设定 time&#x2F;worker&#x2F;sequence 的位数（并留扩展计划）。</li><li><strong>测试</strong>：在 VM 快照回滚 &#x2F; NTP 停顿 &#x2F; 随机调整系统时间 的场景做压力测试。</li></ol><hr><h4 id="四、面试中如何快速回答（2–3-句话总结）"><a href="#四、面试中如何快速回答（2–3-句话总结）" class="headerlink" title="四、面试中如何快速回答（2–3 句话总结）"></a>四、面试中如何快速回答（2–3 句话总结）</h4><ul><li>“要防止 Snowflake 在时钟回退下冲突，基本思路是<strong>检测回退并采取等待&#x2F;逻辑时钟（HLC）或备用 sequence 空间</strong>，并在启动时持久化最近时间戳以避免重启复用。生产级做法常结合 etcd&#x2F;zookeeper 为节点分配唯一 workerId（带租约），并在严重回退时切换到中心化的段分配（HiLo）作为兜底。这样既保证全局唯一，又能通过本地化发号+批量预分配来实现高并发性能。”</li></ul><hr><h4 id="五、补充：关键权衡（可作为面试追问的答案）"><a href="#五、补充：关键权衡（可作为面试追问的答案）" class="headerlink" title="五、补充：关键权衡（可作为面试追问的答案）"></a>五、补充：关键权衡（可作为面试追问的答案）</h4><ul><li><strong>一致性 vs 可用性</strong>：集中 allocator 强一致但单点&#x2F;延迟高；本地 Snowflake 高可用低延迟但需处理时钟问题。</li><li><strong>有序性 vs 吞吐</strong>：保留时间有序性会限制每 ms 可发 ID 数量；若吞吐优先可以牺牲严格时间排序（用分段&#x2F;HiLo）。</li><li><strong>运维复杂度</strong>：使用 etcd&#x2F;zookeeper 分配 workerId 增加运维成本，但能显著降低重复风险。</li></ul><hr><h3 id="16-服务降级与熔断（如何实现、度量与实践）"><a href="#16-服务降级与熔断（如何实现、度量与实践）" class="headerlink" title="16. 服务降级与熔断（如何实现、度量与实践）"></a><strong>16. 服务降级与熔断（如何实现、度量与实践）</strong></h3><ul><li><strong>目标</strong>：当下游或某功能异常时，迅速降级&#x2F;保护系统，保证核心功能可用并快速恢复。</li><li><strong>常见机制</strong><ul><li><strong>超时与重试</strong>：设置合理超时，避免请求挂死。重试配合指数退避。</li><li><strong>熔断器（Circuit Breaker）</strong>：典型三态（Closed&#x2F;Open&#x2F;Half-Open）<ul><li>当失败率或响应延迟高于阈值，熔断器打开（Open），停止调用下游并立即返回降级结果；过一段时间进入 Half-Open 试探。</li></ul></li><li><strong>降级策略</strong>：返回缓存数据、默认值、功能降级（只展示基础信息）或返回错误提示。</li><li><strong>隔离（Bulkhead）</strong>：资源隔离（线程池&#x2F;连接池）防止一个服务耗尽整个系统资源。</li></ul></li><li><strong>实现工具</strong>：Hystrix（已停止维护）、Resilience4j、Istio&#x2F;Envoy 等服务网格提供熔断与限流能力。</li><li><strong>监控指标</strong><ul><li>错误率、延迟 P95&#x2F;P99、并发&#x2F;线程使用率、熔断打开次数。</li></ul></li><li><strong>实战建议</strong><ul><li>熔断阈值不要设得太敏感；结合业务重要度定制降级策略（核心业务更保守）。</li><li>使用自动回退 &amp; 慢启动（half-open 试探时限流）。</li></ul></li><li><strong>面试追问</strong>：熔断与限流的不同？如何设计 Half-Open 的试探策略？</li></ul><hr><h4 id="1-熔断-vs-限流-的区别"><a href="#1-熔断-vs-限流-的区别" class="headerlink" title="1. 熔断 vs 限流 的区别"></a>1. 熔断 vs 限流 的区别</h4><h5 id="限流（Rate-Limiting）"><a href="#限流（Rate-Limiting）" class="headerlink" title="限流（Rate Limiting）"></a><strong>限流（Rate Limiting）</strong></h5><ul><li><strong>目标</strong>：保护系统 <strong>不被流量压垮</strong>。</li><li><strong>触发条件</strong>：基于请求速率&#x2F;并发数 → 超过阈值则拒绝&#x2F;排队。</li><li><strong>典型实现</strong>：令牌桶、漏桶、计数器。</li><li><strong>场景</strong>：应对突发流量，比如秒杀、大促。</li><li><strong>本质</strong>：流量“闸门”。</li></ul><h5 id="熔断（Circuit-Breaker）"><a href="#熔断（Circuit-Breaker）" class="headerlink" title="熔断（Circuit Breaker）"></a><strong>熔断（Circuit Breaker）</strong></h5><ul><li><strong>目标</strong>：保护调用链路，避免“雪崩效应”。</li><li><strong>触发条件</strong>：调用错误率、超时率等指标超过阈值 → 熔断（拒绝请求，快速失败）。</li><li><strong>典型实现</strong>：Netflix Hystrix、Resilience4j。</li><li><strong>场景</strong>：调用下游服务不稳定时，避免请求堆积拖垮自己。</li><li><strong>本质</strong>：健康检测 + 快速失败。</li></ul><p>👉 <strong>一句话区分</strong>：</p><ul><li>限流解决的是“请求太多”。</li><li>熔断解决的是“服务太烂”。</li></ul><hr><h4 id="2-Half-Open-状态与试探策略"><a href="#2-Half-Open-状态与试探策略" class="headerlink" title="2. Half-Open 状态与试探策略"></a>2. Half-Open 状态与试探策略</h4><p>熔断器常见 3 态：</p><ul><li><strong>Closed</strong>（正常）→ 所有请求放行。</li><li><strong>Open</strong>（熔断）→ 拒绝所有请求，快速失败。</li><li><strong>Half-Open</strong>（半开）→ 允许少量探测请求，看服务是否恢复。</li></ul><h5 id="设计-Half-Open-的试探策略"><a href="#设计-Half-Open-的试探策略" class="headerlink" title="设计 Half-Open 的试探策略"></a><strong>设计 Half-Open 的试探策略</strong></h5><p>关键问题：</p><ul><li>多少请求允许通过？</li><li>什么时候恢复 Closed？</li><li>如何避免流量“洪峰”瞬间打回下游？</li></ul><h6 id="策略一：单请求试探"><a href="#策略一：单请求试探" class="headerlink" title="策略一：单请求试探"></a>策略一：单请求试探</h6><ul><li>在 Half-Open 时，只允许<strong>一个请求通过</strong>。</li><li>成功 → 进入 Closed，恢复流量。</li><li>失败 → 回到 Open，继续等待。</li><li><strong>优点</strong>：安全，避免大流量打崩。</li><li><strong>缺点</strong>：恢复速度慢。</li></ul><h6 id="策略二：小流量试探（推荐）"><a href="#策略二：小流量试探（推荐）" class="headerlink" title="策略二：小流量试探（推荐）"></a>策略二：小流量试探（推荐）</h6><ul><li>在 Half-Open 阶段，允许<strong>部分流量通过</strong>，比如 1% 或固定 QPS。</li><li>持续采集成功率 → 达到阈值（如 80% 成功）则关闭熔断。</li><li><strong>优点</strong>：恢复平滑。</li><li><strong>缺点</strong>：实现更复杂。</li></ul><h6 id="策略三：指数回退试探"><a href="#策略三：指数回退试探" class="headerlink" title="策略三：指数回退试探"></a>策略三：指数回退试探</h6><ul><li>第一次允许 1 个请求 → 成功则放 2 个 → 4 个 → 8 个 …</li><li><strong>指数扩张</strong>直到完全恢复。</li><li><strong>优点</strong>：既平滑又快，动态调整恢复速度。</li><li><strong>缺点</strong>：需要精心调参数。</li></ul><hr><h4 id="3-面试答题要点"><a href="#3-面试答题要点" class="headerlink" title="3. 面试答题要点"></a>3. 面试答题要点</h4><p>如果被问：<br> <strong>“熔断和限流区别？Half-Open 怎么设计？”</strong></p><p>你可以答：</p><blockquote><p>限流主要针对流量过大，避免系统被压垮，本质是“闸门”；熔断主要针对下游服务故障，本质是“保险丝”，快速失败避免雪崩。</p><p>Half-Open 阶段的核心在于<strong>小心探测服务是否恢复</strong>。常见策略有：</p><ul><li>单请求试探（安全但恢复慢），</li><li>小比例流量试探（常用，平滑恢复），</li><li>指数回退试探（恢复速度和安全性兼顾）。</li></ul><p>实际工程里，会结合失败率阈值和时间窗口来决定是否切换状态。</p></blockquote><hr><h3 id="17-单体架构-vs-微服务架构（区别、优劣、迁移策略）"><a href="#17-单体架构-vs-微服务架构（区别、优劣、迁移策略）" class="headerlink" title="17. 单体架构 vs 微服务架构（区别、优劣、迁移策略）"></a><strong>17. 单体架构 vs 微服务架构（区别、优劣、迁移策略）</strong></h3><ul><li><strong>单体（Monolith）</strong><ul><li>单一部署包（应用 + UI + DB schema）。开发简单、事务管理方便、性能调优集中。</li><li>缺点：团队协作瓶颈、难以按模块独立扩展、发布周期长、代码库复杂。</li></ul></li><li><strong>微服务（Microservices）</strong><ul><li>按业务域拆分为多个小服务，独立部署、独立扩缩、独立数据库（去中心化数据）。</li><li>优点：团队自治、按服务扩展、技术选型灵活、故障隔离。</li><li>缺点：分布式系统复杂（网络延迟、分布式事务、观察性、部署复杂度、运维成本）。</li></ul></li><li><strong>选择建议</strong><ul><li>初创&#x2F;小团队或产品早期：倾向单体（快速迭代）。</li><li>业务复杂、团队规模大、需要独立扩展与技术异构：考虑微服务。</li></ul></li><li><strong>迁移技巧</strong><ul><li>Strangler Pattern：逐步把单体功能提取到微服务，外层路由切换到新服务。</li><li>先做服务划分、定义清晰的边界与 API，建立统一的服务发现、认证和监控体系。</li></ul></li><li><strong>面试追问</strong>：微服务如何做事务？怎么做服务发现与熔断？如何做日志聚合与链路追踪？</li></ul><hr><h3 id="18-防抖（Debounce）与-节流（Throttle）及适用场景"><a href="#18-防抖（Debounce）与-节流（Throttle）及适用场景" class="headerlink" title="18. 防抖（Debounce）与 节流（Throttle）及适用场景"></a><strong>18. 防抖（Debounce）与 节流（Throttle）及适用场景</strong></h3><ul><li><p><strong>防抖（Debounce）</strong></p><ul><li><p>含义：在事件停止触发后等待一段时间才执行函数；多次触发只执行最后一次。</p></li><li><p>场景：输入联想、搜索框（用户停止输入后才触发搜索）。</p></li><li><p>JS 伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> t;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(t);</span><br><span class="line">    t = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args), wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>节流（Throttle）</strong></p><ul><li><p>含义：在固定时间间隔内只执行一次函数（如果持续触发则按间隔执行）。</p></li><li><p>场景：滚动、窗口 resize、按键长按等需要限制频率的操作。</p></li><li><p>JS 伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, limit</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> inThrottle = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!inThrottle) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      inThrottle = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> inThrottle = <span class="literal">false</span>, limit);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>选择原则</strong>：需在事件结束后执行 → 用防抖；需均匀限制调用频率 → 用节流。</p></li></ul><hr><h3 id="19-CDN（内容分发网络）详解：原理、优化与安全"><a href="#19-CDN（内容分发网络）详解：原理、优化与安全" class="headerlink" title="19. CDN（内容分发网络）详解：原理、优化与安全"></a><strong>19. CDN（内容分发网络）详解：原理、优化与安全</strong></h3><ul><li><strong>基本原理</strong>：把静态资源缓存到离用户更近的边缘节点（PoP），用户请求被路由到最近&#x2F;最优节点，降低延迟、减轻源站压力。</li><li><strong>主要能力</strong><ul><li>静态内容缓存（图片、JS&#x2F;CSS、视频分片）、动态内容加速（通过智能路由&#x2F;连接复用）、SSL 终止、WAF、DDoS 防护、负载均衡、边缘计算（边缘函数&#x2F;Workers）。</li></ul></li><li><strong>缓存控制</strong><ul><li><code>Cache-Control</code>（max-age, public&#x2F;private, s-maxage），<code>ETag</code>&#x2F;<code>Last-Modified</code>，<code>stale-while-revalidate</code>。</li><li>缓存失效策略：基于 URL 版本（内容哈希）、时间 TTL、手动 purge。</li></ul></li><li><strong>优化技巧</strong><ul><li>用内容哈希做文件名（避免复杂的 purge）。</li><li>使用 <code>prefetch</code> &#x2F; <code>preload</code> &#x2F; <code>edge caching</code> 提升体验（尤其首屏）。</li><li>Origin Shield（中间层缓存）保护源站免击穿。</li></ul></li><li><strong>安全</strong><ul><li>边缘 WAF、速率限制、地理封禁、签名 URL（短期授权）保护私有资源。</li></ul></li><li><strong>面试追问</strong>：如何缓存动态内容？CDN 缓存穿透到源站怎么办？如何做 CDN cache invalidation 最优策略？</li></ul><hr><h4 id="1-如何缓存动态内容？"><a href="#1-如何缓存动态内容？" class="headerlink" title="1. 如何缓存动态内容？"></a>1. 如何缓存动态内容？</h4><p>很多人以为“动态内容不能缓存”，其实不是。常见方法：</p><h5 id="1-页面片段缓存（Fragment-Caching）"><a href="#1-页面片段缓存（Fragment-Caching）" class="headerlink" title="(1) 页面片段缓存（Fragment Caching）"></a>(1) 页面片段缓存（Fragment Caching）</h5><ul><li>把页面拆分为 <strong>可缓存部分</strong>（例如导航栏、热门榜单）和 <strong>实时部分</strong>（例如购物车、账户余额）。</li><li>可缓存部分走 <strong>CDN&#x2F;Redis</strong>，实时部分通过 <strong>AJAX &#x2F; ESI（Edge Side Includes）</strong> 动态加载。</li><li>典型应用：门户网站首页、新闻频道。</li></ul><h5 id="2-API-缓存（Response-Cache）"><a href="#2-API-缓存（Response-Cache）" class="headerlink" title="(2) API 缓存（Response Cache）"></a>(2) API 缓存（Response Cache）</h5><ul><li>API 的响应虽然是动态生成的，但常常有<strong>幂等&#x2F;可预测</strong>的场景（如商品详情、榜单）。</li><li>可以在 <strong>CDN&#x2F;边缘节点</strong>缓存几秒&#x2F;几十秒，大幅削峰。</li><li>电商详情页通常设置 <strong>短 TTL（10s~60s）</strong>，保证新价格能及时更新。</li></ul><h5 id="3-参数化缓存（Key-Normalization）"><a href="#3-参数化缓存（Key-Normalization）" class="headerlink" title="(3) 参数化缓存（Key Normalization）"></a>(3) 参数化缓存（Key Normalization）</h5><ul><li>对动态请求，很多参数并不影响最终内容。</li><li>通过 <strong>Vary Header &#x2F; 参数归一化</strong>（例如只关心 <code>?id=123</code>，忽略 <code>utm_source</code>），让 CDN 命中率提升。</li></ul><h5 id="4-“Stale-while-revalidate”-“Stale-if-error”-策略"><a href="#4-“Stale-while-revalidate”-“Stale-if-error”-策略" class="headerlink" title="(4) “Stale-while-revalidate” &#x2F; “Stale-if-error” 策略"></a>(4) “Stale-while-revalidate” &#x2F; “Stale-if-error” 策略</h5><ul><li>先返回旧缓存（快速响应），后台异步刷新新内容。</li><li>出错时（源站挂了）也能兜底返回过期内容。</li><li>Cloudflare &#x2F; Fastly &#x2F; Nginx 都支持。</li></ul><p>👉 <strong>一句话总结</strong>：动态内容不是不能缓存，而是要<strong>拆分&#x2F;短 TTL&#x2F;容忍旧数据&#x2F;按需刷新</strong>。</p><hr><h4 id="2-CDN-缓存穿透到源站怎么办？"><a href="#2-CDN-缓存穿透到源站怎么办？" class="headerlink" title="2. CDN 缓存穿透到源站怎么办？"></a>2. CDN 缓存穿透到源站怎么办？</h4><p>所谓 <strong>穿透源站</strong> &#x3D; CDN 缓存没有命中，所有请求都打到源站 → 源站被打爆。</p><h5 id="常见原因"><a href="#常见原因" class="headerlink" title="常见原因"></a>常见原因</h5><ol><li><strong>请求参数多样化</strong> → cache key 太分散（<code>?timestamp=xxx</code>、<code>?random=xx</code>）。</li><li><strong>恶意攻击 &#x2F; 爬虫</strong> → 故意制造不命中的 key。</li><li><strong>缓存 TTL 太短</strong> → 经常 miss。</li><li><strong>动态内容未合理拆分</strong>。</li></ol><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ul><li><strong>参数归一化</strong>：只对真正影响结果的参数参与缓存。</li><li><strong>缓存缺省值</strong>：对无效参数&#x2F;不存在数据，缓存一个“空值”（短 TTL），避免透传。</li><li><strong>CDN 层限流 &#x2F; WAF</strong>：对恶意爬虫或异常请求先拦截。</li><li><strong>热点 Key 预热</strong>：秒杀&#x2F;大促前预先把热门内容推到 CDN 节点。</li><li><strong>多级缓存架构</strong>：CDN → 边缘缓存 → 应用层本地缓存 → DB，逐级兜底。</li></ul><p>👉 <strong>经验法则</strong>：能在 CDN 命中的，尽量别让它穿到源站。</p><hr><h4 id="3-CDN-Cache-Invalidation（缓存失效）的最优策略"><a href="#3-CDN-Cache-Invalidation（缓存失效）的最优策略" class="headerlink" title="3. CDN Cache Invalidation（缓存失效）的最优策略"></a>3. CDN Cache Invalidation（缓存失效）的最优策略</h4><p>缓存更新是最难的地方，因为 <strong>缓存更新 vs 性能&#x2F;成本</strong>是矛盾。常见策略：</p><h5 id="1-TTL-驱动（时间驱动）"><a href="#1-TTL-驱动（时间驱动）" class="headerlink" title="(1) TTL 驱动（时间驱动）"></a>(1) TTL 驱动（时间驱动）</h5><ul><li>给资源设置 TTL，到期后自动失效。</li><li>优点：简单，性能好。</li><li>缺点：实时性差（例如价格变化要等 60s）。</li></ul><h5 id="2-主动刷新（Push-Invalidation）"><a href="#2-主动刷新（Push-Invalidation）" class="headerlink" title="(2) 主动刷新（Push Invalidation）"></a>(2) 主动刷新（Push Invalidation）</h5><ul><li>应用在数据变更时，调用 CDN API 主动刷新或 Purge。</li><li>优点：强一致性。</li><li>缺点：成本高，刷新频繁会拖慢性能（尤其全站刷新）。</li></ul><h5 id="3-Key-版本号（Cache-Busting）"><a href="#3-Key-版本号（Cache-Busting）" class="headerlink" title="(3) Key 版本号（Cache Busting）"></a>(3) Key 版本号（Cache Busting）</h5><ul><li>热点资源：<strong>短 TTL + Stale-while-revalidate</strong>，兼顾实时性和性能。</li><li>冷门资源：<strong>长 TTL</strong>，减少源站压力。</li><li>数据敏感（价格&#x2F;库存）：<strong>主动刷新或 Key 版本号</strong>。</li></ul><p>👉 <strong>最佳实践</strong>：</p><ul><li><strong>静态内容</strong> → 长 TTL + 版本号（Cache Busting）。</li><li><strong>动态内容</strong> → 短 TTL + 主动刷新 + SWR（延迟刷新）。</li><li><strong>核心数据</strong>（库存&#x2F;支付） → 基本不走 CDN，而是走直连服务。</li></ul><hr><p>✅ 面试答题思路：</p><blockquote><p>动态内容可以通过片段缓存、短 TTL、参数归一化、Stale-while-revalidate 等方式缓存。<br> 当 CDN miss 穿透到源站时，要通过参数归一化、空值缓存、多级缓存和 WAF 限流来防御。<br> Cache invalidation 的最优解没有银弹，通常是 TTL 驱动 + 主动刷新 + 版本号策略的组合。静态资源走版本号，动态资源走短 TTL + SWR，关键业务则走直连。</p></blockquote><hr><h3 id="20-RBAC（Role-Based-Access-Control）详解"><a href="#20-RBAC（Role-Based-Access-Control）详解" class="headerlink" title="20. RBAC（Role-Based Access Control）详解"></a><strong>20. RBAC（Role-Based Access Control）详解</strong></h3><ul><li><strong>核心概念</strong><ul><li><strong>角色（Role）</strong>：代表一组权限（Permission）。</li><li><strong>权限（Permission）</strong>：通常是对资源的操作（read&#x2F;write&#x2F;delete）。</li><li><strong>用户（User）</strong>：被赋予角色，从而继承权限。</li></ul></li><li><strong>模型特性</strong><ul><li>支持 <strong>角色继承&#x2F;层级</strong>（例如 Admin 包含 User 权限）。</li><li>强调最小权限原则（least privilege）。</li></ul></li><li><strong>设计要点</strong><ul><li>把权限映射到资源&#x2F;操作（资源 + 操作作为权限单元）。</li><li>支持动态权限（例如 ABAC）用于属性&#x2F;上下文判断（时间、IP 等）。</li><li>缓存权限（例如 ACL cache）以加速鉴权，但需处理权限变更的失效。</li></ul></li><li><strong>实现数据库模式（简化）</strong><ul><li>tables: users, roles, permissions, user_roles, role_permissions。</li></ul></li><li><strong>扩展</strong>：ABAC（Attribute-Based）、PBAC（Policy-Based）当权限复杂时使用策略引擎（OPA）。</li><li><strong>面试点</strong>：RBAC 的优缺点、如何在分布式系统快速授权（token 携带权限&#x2F;JWT、或网关做中央鉴权）。</li></ul><hr><h3 id="21-Cookie（概念、属性、安全实践）"><a href="#21-Cookie（概念、属性、安全实践）" class="headerlink" title="21. Cookie（概念、属性、安全实践）"></a><strong>21. Cookie（概念、属性、安全实践）</strong></h3><ul><li><p><strong>概念</strong>：浏览器用来在客户端储存和跨请求携带少量数据（如 session id、偏好设置）。</p></li><li><p><strong>重要属性</strong></p><ul><li><code>Name=Value</code>、<code>Domain</code>、<code>Path</code>、<code>Expires/Max-Age</code>、<code>Secure</code>（仅 HTTPS）、<code>HttpOnly</code>（JS 不能访问）、<code>SameSite</code>（None&#x2F;Lax&#x2F;Strict）。</li></ul></li><li><p><strong>安全实践</strong></p><ul><li><code>HttpOnly</code> 防止 XSS 直接窃取 Cookie（但 CSRF 仍可能触发）。</li><li><code>SameSite</code> 设置合理值减少 CSRF（Strict 最严格但影响跨站场景，Lax 常用）。</li><li>与 <code>Secure</code> 配合，Cookie 只在 HTTPS 下传输。</li><li>对敏感数据不直接存储在 Cookie 中（只存 session id 或 token 的引用）。</li></ul></li><li><p><strong>大小与数量限制</strong>：浏览器对单个 cookie 与域名下的 cookie 数量有上限（实现时要注意）。</p></li><li><p><strong>面试追问</strong>：Cookie 与 localStorage 的区别？如何用 SameSite 防 CSRF？如何设置过期时间？</p><p>Cookie和Session的区别？</p><hr></li></ul><h4 id="1-Cookie-vs-localStorage"><a href="#1-Cookie-vs-localStorage" class="headerlink" title="1. Cookie vs localStorage"></a>1. Cookie vs localStorage</h4><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><ul><li><strong>作用</strong>：主要用于服务端与客户端交互（尤其是携带身份信息）。</li><li><strong>特点</strong>：<ul><li>每次请求自动携带到服务端（在请求头里）。</li><li>可设置 <code>HttpOnly</code>（JS 无法访问，防止 XSS 窃取）。</li><li>可设置 <code>Secure</code>（仅 HTTPS 传输）。</li><li>可设置 <code>SameSite</code>（防 CSRF）。</li></ul></li><li><strong>大小限制</strong>：单个域名约 4KB。</li><li><strong>过期时间</strong>：可设置 <code>Expires</code> 或 <code>Max-Age</code>，到期浏览器删除。</li></ul><h5 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h5><ul><li><strong>作用</strong>：纯前端存储，浏览器本地缓存数据。</li><li><strong>特点</strong>：<ul><li>仅在客户端使用，<strong>不会自动随请求发送</strong>。</li><li>容量较大（5MB 左右）。</li><li>API 简单：<code>localStorage.setItem/getItem</code>。</li><li>没有过期时间，除非手动清除。</li></ul></li><li><strong>安全性</strong>：易受 XSS 攻击窃取（不能设置 HttpOnly）。</li></ul><p>👉 <strong>一句话总结</strong>：</p><ul><li>Cookie 适合 <strong>和服务端交互的会话信息</strong>。</li><li>localStorage 适合 <strong>存放纯前端用的配置&#x2F;缓存</strong>。</li></ul><hr><h4 id="2-SameSite-防-CSRF"><a href="#2-SameSite-防-CSRF" class="headerlink" title="2. SameSite 防 CSRF"></a>2. SameSite 防 CSRF</h4><p><code>SameSite</code> 是 Cookie 的一个属性，用来限制跨站请求时 Cookie 的发送：</p><ul><li><code>SameSite=Strict</code>：最严格，只有在<strong>同域请求</strong>时才会带 Cookie。跨站点请求一律不带。</li><li><code>SameSite=Lax</code>：默认模式，跨站点 <strong>GET 请求</strong> 会带 Cookie，但 POST&#x2F;PUT&#x2F;DELETE 不会带。</li><li><code>SameSite=None</code>：允许跨站点请求携带 Cookie，但必须搭配 <code>Secure</code>（仅 HTTPS）。</li></ul><p>👉 <strong>防 CSRF 的思路</strong>：<br> CSRF 攻击依赖于“攻击者页面发请求时，浏览器自动带上受害者的 Cookie”。<br> 通过 <code>SameSite=Lax/Strict</code>，跨站点的请求大多数情况下不会携带 Cookie，从而阻断 CSRF 攻击。</p><hr><h4 id="3-Cookie-的过期时间"><a href="#3-Cookie-的过期时间" class="headerlink" title="3. Cookie 的过期时间"></a>3. Cookie 的过期时间</h4><ul><li><code>Session Cookie</code>：没有设置过期时间，浏览器关闭就删除。</li><li><code>Persistent Cookie</code>：设置了 <code>Expires</code>（绝对时间）或 <code>Max-Age</code>（相对时间），到期自动失效。</li></ul><p>示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>token=abc123; Max-Age=3600; HttpOnly; Secure; SameSite=Strict</span><br></pre></td></tr></table></figure><p>👉 表示 <code>token</code> 有效期 1 小时，HttpOnly 防 XSS，Strict 防 CSRF。</p><hr><h4 id="4-Cookie-vs-Session"><a href="#4-Cookie-vs-Session" class="headerlink" title="4. Cookie vs Session"></a>4. Cookie vs Session</h4><h5 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h5><ul><li>存在客户端，由浏览器管理。</li><li>大小限制（4KB 左右）。</li><li>安全性相对低（可能被窃取、篡改）。</li></ul><h5 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h5><ul><li>存在服务端，通常存储在内存&#x2F;Redis&#x2F;数据库。</li><li>客户端只保存 <strong>SessionID</strong>（一般放在 Cookie 里）。</li><li>服务端可存放更多、更安全的数据。</li><li>可集中管理（比如用户强制下线时，只需删服务端 session）。</li></ul><p>👉 <strong>核心区别</strong>：</p><ul><li><strong>Cookie</strong>：存储在客户端，可能被窃取篡改。</li><li><strong>Session</strong>：存储在服务端，客户端只保存 ID，更安全。</li></ul><hr><h4 id="面试答法总结"><a href="#面试答法总结" class="headerlink" title="面试答法总结"></a>面试答法总结</h4><blockquote><p>Cookie 用于客户端和服务端的状态传递，支持过期时间、HttpOnly、Secure、SameSite 等安全属性；localStorage 是纯前端存储，不会自动带到服务端，容量更大但不安全。</p><p>CSRF 可以用 Cookie 的 SameSite 属性来防御，配合 <code>Strict/Lax</code> 限制跨站请求携带 Cookie。</p><p>Cookie 有过期时间（Session Cookie &#x2F; Persistent Cookie），而 localStorage 默认没有过期。</p><p>Session 是存储在服务端的状态信息，客户端只保存一个 SessionID（通常在 Cookie 中），比直接把敏感信息存在 Cookie 里更安全。</p></blockquote><hr><h3 id="22-Session（服务器端会话管理）"><a href="#22-Session（服务器端会话管理）" class="headerlink" title="22. Session（服务器端会话管理）"></a><strong>22. Session（服务器端会话管理）</strong></h3><ul><li><strong>基本模式</strong><ul><li><strong>服务器端 Session</strong>：服务器保存 session 状态（内存、Redis、DB），客户端仅持有 session id（cookie）。</li><li><strong>无状态 Token（如 JWT）</strong>：状态保存在 token 本身，服务器不保存 session（但牺牲了即时下线&#x2F;撤销能力）。</li></ul></li><li><strong>Session 存储</strong><ul><li>本地内存（单实例）、共享存储（Redis 常用）、数据库（持久但慢）。</li><li>对于分布式多实例，建议用 Redis 或数据库持久化 session，或使用 sticky session（不推荐）。</li></ul></li><li><strong>安全与实践</strong><ul><li>Session 固定攻击防护（Session Fixation）：登录后旋转 session id。</li><li>会话过期、滑动过期（每次活动延长过期时间），并支持登出时的立即失效（需要服务端存储）。</li><li>持久化&#x2F;清理旧 session：TTL + 定期清理。</li></ul></li><li><strong>面试追问</strong>：为什么 JWT 无法轻易实现强撤销？如何在微服务中共享 session（Token 认证 + introspection 或集中认证服务）？如何设置过期时间？</li></ul><hr><h4 id="1-为什么-JWT-无法轻易实现强撤销？"><a href="#1-为什么-JWT-无法轻易实现强撤销？" class="headerlink" title="1. 为什么 JWT 无法轻易实现强撤销？"></a>1. 为什么 JWT 无法轻易实现强撤销？</h4><p><strong>原因</strong></p><ul><li><strong>JWT（JSON Web Token）是无状态的</strong>：<br> 生成后 Token 本身携带所有认证与授权信息（通常有 <code>sub, exp, scope</code> 等），服务端只需验证签名和有效期即可，不必访问数据库。</li><li><strong>签发后不可变</strong>：<br> 除非你更换签名密钥或让 Token 过期，否则服务端无法单方面使其失效。</li><li><strong>难撤销场景</strong>：<ul><li>用户主动注销（Logout）</li><li>密码修改 &#x2F; 权限变更</li><li>Token 被盗用</li><li>管理员紧急冻结</li></ul></li></ul><blockquote><p>这就是为什么 JWT 适合 <strong>高性能分布式认证</strong>，但在安全和撤销上天然存在缺陷。</p></blockquote><hr><h4 id="2-解决强撤销的常见思路"><a href="#2-解决强撤销的常见思路" class="headerlink" title="2. 解决强撤销的常见思路"></a>2. 解决强撤销的常见思路</h4><h5 id="2-1-Blacklist-Revocation-List（黑名单）"><a href="#2-1-Blacklist-Revocation-List（黑名单）" class="headerlink" title="2.1 Blacklist &#x2F; Revocation List（黑名单）"></a>2.1 Blacklist &#x2F; Revocation List（黑名单）</h5><ul><li><strong>做法</strong>：服务端维护一个被撤销的 JWT <code>jti</code>（JWT ID）或用户 ID 列表，每次验证时查询。</li><li><strong>缺点</strong>：查询会降低性能；如果存储在 Redis，还会增加网络开销。</li></ul><h5 id="2-2-短生命周期-Refresh-Token"><a href="#2-2-短生命周期-Refresh-Token" class="headerlink" title="2.2 短生命周期 + Refresh Token"></a>2.2 短生命周期 + Refresh Token</h5><ul><li><strong>思路</strong>：<ul><li>Access Token 只活几分钟（5~15min），即使被盗影响也有限。</li><li>Refresh Token 长生命周期，但服务端可存储并随时撤销。</li></ul></li><li><strong>优点</strong>：大幅降低撤销的复杂度，只要拒绝 Refresh Token 就能彻底阻止后续访问。</li><li><strong>缺点</strong>：需要额外的 Refresh 流程，复杂度增加。</li></ul><h5 id="2-3-Introspection（令牌内省）"><a href="#2-3-Introspection（令牌内省）" class="headerlink" title="2.3 Introspection（令牌内省）"></a>2.3 Introspection（令牌内省）</h5><ul><li><strong>OAuth2 标准</strong>：客户端提交 Token 给认证服务，认证服务实时返回其有效性和权限信息。</li><li><strong>实现</strong>：Token 变成“有状态”，服务端能立即撤销。</li><li><strong>缺点</strong>：性能不如纯 JWT，需要调用认证服务。</li></ul><h5 id="2-4-Key-Rolling（密钥轮换）"><a href="#2-4-Key-Rolling（密钥轮换）" class="headerlink" title="2.4 Key Rolling（密钥轮换）"></a>2.4 Key Rolling（密钥轮换）</h5><ul><li><strong>方式</strong>：定期更换 JWT 的签名秘钥，旧 Token 一律失效。</li><li><strong>适用场景</strong>：管理员强制全员下线。</li><li><strong>缺点</strong>：全量失效，粒度粗。</li></ul><hr><h4 id="3-微服务中如何共享-Session？"><a href="#3-微服务中如何共享-Session？" class="headerlink" title="3. 微服务中如何共享 Session？"></a>3. 微服务中如何共享 Session？</h4><h5 id="方案-1：Token-认证（JWT）"><a href="#方案-1：Token-认证（JWT）" class="headerlink" title="方案 1：Token 认证（JWT）"></a>方案 1：Token 认证（JWT）</h5><ul><li>每个微服务只需验证签名即可，无需共享状态。</li><li><strong>优点</strong>：高性能、分布式友好。</li><li><strong>缺点</strong>：撤销困难，如上所述。</li></ul><h5 id="方案-2：Introspection-中央认证服务"><a href="#方案-2：Introspection-中央认证服务" class="headerlink" title="方案 2：Introspection &#x2F; 中央认证服务"></a>方案 2：Introspection &#x2F; 中央认证服务</h5><ul><li>所有请求先交给 <strong>网关 &#x2F; Auth Service</strong>，由其验证 Token 是否有效。</li><li>服务内部调用时使用服务间信任（例如 mTLS &#x2F; 内部短期 Token）。</li><li><strong>优点</strong>：可即时撤销，权限可动态变更。</li><li><strong>缺点</strong>：增加认证服务负载。</li></ul><h5 id="方案-3：集中式-Session（Redis-DB）"><a href="#方案-3：集中式-Session（Redis-DB）" class="headerlink" title="方案 3：集中式 Session（Redis &#x2F; DB）"></a>方案 3：集中式 Session（Redis &#x2F; DB）</h5><ul><li>传统 Session 存储在 Redis，全局共享。</li><li><strong>优点</strong>：支持强撤销、实时变更。</li><li><strong>缺点</strong>：与 JWT 的无状态理念相悖；性能依赖 Redis。</li></ul><hr><h4 id="4-如何设置过期时间？"><a href="#4-如何设置过期时间？" class="headerlink" title="4. 如何设置过期时间？"></a>4. 如何设置过期时间？</h4><ul><li><p><strong>JWT Access Token</strong>：建议 5~15 分钟</p></li><li><p><strong>Refresh Token</strong>：7 天 ~ 30 天（可配置，支持续签）</p></li><li><p><strong>Session</strong>：一般 30 分钟不活跃就过期，可以 Sliding Expiration（续命策略）</p><p>1.在 Servlet 中动态设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionExampleServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取当前会话（如果不存在则创建）</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置过期时间为30分钟（单位：秒）</span></span><br><span class="line">        <span class="comment">// 注意：这是从最后一次请求活动开始计算的非活动时间</span></span><br><span class="line">        session.setMaxInactiveInterval(<span class="number">30</span> * <span class="number">60</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 存储数据到Session</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        response.getWriter().println(<span class="string">&quot;Session已创建，过期时间30分钟&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在 web.xml 中全局配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置所有Session的默认过期时间（单位：分钟） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span> <span class="comment">&lt;!-- 30分钟 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.使用 Spring 框架时的配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.servlet.session.timeout</span>=<span class="string">1800  # 30分钟</span></span><br></pre></td></tr></table></figure><ul><li><code>setMaxInactiveInterval(int seconds)</code>设置的是<strong>非活动过期时间</strong>，即从用户最后一次访问服务器开始计时</li><li>当设置为<code>-1</code>时，表示 Session 永不过期（不推荐在生产环境使用）</li><li>web.xml 中<code>session-timeout</code>的单位是<strong>分钟</strong>，而<code>setMaxInactiveInterval</code>的单位是<strong>秒</strong></li><li>动态设置（代码中）的优先级高于 web.xml 中的全局配置</li></ul></li><li><p><strong>黑名单策略</strong>：可以保留一段时间，比如存储在 Redis 并设置 TTL。</p></li></ul><hr><p>✅ <strong>总结一句话</strong>：</p><ul><li>JWT 高性能但难撤销 → 用 <strong>短生命周期 + Refresh Token</strong> 缓解；</li><li>需要强撤销场景 → 用 <strong>Introspection 或集中认证服务</strong>；</li><li>微服务共享会话 → 要么 JWT 自带权限，要么集中式认证。</li></ul><hr><h3 id="23-Token（JWT、Opaque-Token、OAuth2、刷新与安全）"><a href="#23-Token（JWT、Opaque-Token、OAuth2、刷新与安全）" class="headerlink" title="23. Token（JWT、Opaque Token、OAuth2、刷新与安全）"></a><strong>23. Token（JWT、Opaque Token、OAuth2、刷新与安全）</strong></h3><ul><li><p><strong>Token 类型</strong></p><ul><li><strong>Opaque token（不透明）</strong>：随机字符串，服务器需校验&#x2F;查询（例如 introspection endpoint）。</li><li><strong>JWT（JSON Web Token）</strong>：自包含，<code>header.payload.signature</code>，服务可离线验证签名并读取声明（claims）。</li></ul></li><li><p><strong>JWT 结构</strong></p><ul><li>Header（类型、算法） | Payload（claims：sub, exp, iat, scopes） | Signature（HMAC 或 RSA&#x2F;ECDSA）。</li></ul></li><li><p><strong>优缺点</strong></p><ul><li>JWT：无状态验证、性能好；缺点：难以即时撤销（需黑名单&#x2F;JTI）、token 体积较大、滥用风险高。</li><li>Opaque token：撤销&#x2F;控制更容易（服务器查），但需状态存储和额外网络开销。</li></ul></li><li><p><strong>OAuth2 &amp; Flow</strong></p><ul><li>常见 flows：Authorization Code（推荐带 PKCE 用于 browser + SPAs）、Client Credentials（服务间）、Resource Owner Password（不推荐）。</li><li>使用 refresh token 刷新 access token（短期 access token + 更长 refresh token）。</li></ul></li><li><p><strong>安全实践</strong></p><ul><li>Access token 短期有效、Refresh token 使用 rotation（每次刷新发新 refresh token 并使旧一个失效）。</li><li>存储在浏览器：若放 Cookie，应用 <code>HttpOnly</code> + <code>Secure</code> + <code>SameSite</code>；若放 localStorage 则易被 XSS 窃取。</li><li>使用 <code>jti</code> 或 token 黑名单&#x2F;撤销机制在必要时撤销 token。</li><li>签名算法使用非对称（RS256）可以方便公钥验证；密钥管理与轮换非常重要。</li></ul></li><li><p><strong>实现细节</strong></p><ul><li>在微服务中常使用 <strong>Token Introspection &#x2F; Auth Service</strong>：服务接到 token 时向 auth server 校验或直接验证 JWT 签名。</li><li>结合 OAuth scopes 与 RBAC 做精细权限控制。</li></ul></li><li><p><strong>面试追问</strong>：如何安全存储 refresh token？JWT 怎么做 token 撤销？什么是 token binding？</p><p>双刷新策略详细讲一下？Token和Session的比对？</p></li></ul><hr><h4 id="1-如何安全存储-Refresh-Token"><a href="#1-如何安全存储-Refresh-Token" class="headerlink" title="1. 如何安全存储 Refresh Token"></a>1. 如何安全存储 Refresh Token</h4><p>Refresh Token 是长期有效的凭证，如果泄露风险高，因此存储安全非常重要：</p><h5 id="客户端存储方式"><a href="#客户端存储方式" class="headerlink" title="客户端存储方式"></a>客户端存储方式</h5><ol><li><strong>移动端&#x2F;桌面应用</strong><ul><li>安全存储在系统提供的<strong>Keychain &#x2F; Keystore &#x2F; Secure Storage</strong></li><li>不要存入普通本地文件或 SharedPreferences&#x2F;NSUserDefaults 明文</li></ul></li><li><strong>Web 前端</strong><ul><li><strong>不要存 localStorage</strong>（易被 XSS 窃取）</li><li><strong>HttpOnly + Secure Cookie</strong> 最安全</li><li>可结合 <strong>SameSite&#x3D;Strict&#x2F;Lax</strong> 防止 CSRF</li></ul></li></ol><h5 id="服务端存储方式"><a href="#服务端存储方式" class="headerlink" title="服务端存储方式"></a>服务端存储方式</h5><ul><li><h4 id="可把-Refresh-Token-哈希存储在数据库或-Redis（类似密码存储），即使泄露也无法直接使用"><a href="#可把-Refresh-Token-哈希存储在数据库或-Redis（类似密码存储），即使泄露也无法直接使用" class="headerlink" title="可把 Refresh Token 哈希存储在数据库或 Redis（类似密码存储），即使泄露也无法直接使用"></a>可把 Refresh Token <strong>哈希存储在数据库或 Redis</strong>（类似密码存储），即使泄露也无法直接使用</h4></li><li><p>支持撤销：每次刷新前检查服务端存储状态</p></li></ul><hr><h4 id="2-JWT-怎么做-Token-撤销"><a href="#2-JWT-怎么做-Token-撤销" class="headerlink" title="2. JWT 怎么做 Token 撤销"></a>2. JWT 怎么做 Token 撤销</h4><p>JWT 默认无状态，不依赖服务器，所以强撤销有难度。常见解决方案：</p><h5 id="1-短生命周期-Refresh-Token"><a href="#1-短生命周期-Refresh-Token" class="headerlink" title="(1) 短生命周期 + Refresh Token"></a>(1) 短生命周期 + Refresh Token</h5><ul><li>Access Token 5–15 分钟</li><li>Refresh Token 7–30 天</li><li>通过拒绝 Refresh Token 刷新来实现撤销</li></ul><h5 id="2-Token-黑名单"><a href="#2-Token-黑名单" class="headerlink" title="(2) Token 黑名单"></a>(2) Token 黑名单</h5><ul><li>维护被撤销的 JWT ID（<code>jti</code>）列表</li><li>每次验证 JWT 时检查是否在黑名单</li><li>可结合 Redis TTL 自动过期</li></ul><h5 id="3-Introspection-中央认证"><a href="#3-Introspection-中央认证" class="headerlink" title="(3) Introspection &#x2F; 中央认证"></a>(3) Introspection &#x2F; 中央认证</h5><ul><li>微服务验证 Token 时调用 Auth Service 查询有效性</li><li>支持即时撤销</li></ul><h5 id="4-Key-Rolling（签名密钥轮换）"><a href="#4-Key-Rolling（签名密钥轮换）" class="headerlink" title="(4) Key Rolling（签名密钥轮换）"></a>(4) Key Rolling（签名密钥轮换）</h5><ul><li>更换 JWT 签名密钥 → 所有旧 Token 失效</li><li>用于全局紧急下线</li></ul><hr><h4 id="3-Token-Binding"><a href="#3-Token-Binding" class="headerlink" title="3. Token Binding"></a>3. Token Binding</h4><p><strong>Token Binding</strong> 是一种安全机制，用来防止 Token 被盗用。核心思想：</p><ul><li>将 Token 与客户端的 <strong>特定密钥 &#x2F; TLS 会话</strong> 绑定</li><li>攻击者即使窃取 Token，没有对应的客户端密钥，也无法使用</li><li>优势：防止中间人攻击 &#x2F; Token 被 XSS &#x2F; CSRF 盗用</li></ul><blockquote><p>类似于“钥匙只能在原来的锁上使用”，增加了 Token 安全性。</p></blockquote><hr><h4 id="4-双刷新策略（Double-Refresh-Sliding-Session）"><a href="#4-双刷新策略（Double-Refresh-Sliding-Session）" class="headerlink" title="4. 双刷新策略（Double Refresh &#x2F; Sliding Session）"></a>4. 双刷新策略（Double Refresh &#x2F; Sliding Session）</h4><p>解决问题：短生命周期 Access Token + 长生命周期 Refresh Token 的安全与可用性平衡</p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li><strong>两个 Token</strong>：Access Token + Refresh Token</li><li><strong>滑动刷新</strong>（Sliding Refresh）策略：<ol><li>Access Token 到期 → 使用 Refresh Token 获取新的 Access Token</li><li><strong>同时刷新 Refresh Token</strong>（生成新 Refresh Token）</li></ol></li><li>保证：<ul><li>Token 被盗用时，旧 Token 在很短时间内失效</li><li>用户活跃时，Token 可持续滑动续期</li><li>用户不活跃 → 自动过期</li></ul></li></ul><h5 id="流程示意"><a href="#流程示意" class="headerlink" title="流程示意"></a>流程示意</h5><ol><li>登录 → 返回 <code>&#123;access_token, refresh_token&#125;</code></li><li>Access Token 到期 → 请求刷新</li><li>Auth Service 验证 Refresh Token → 签发新的 Access Token + Refresh Token</li><li>原 Refresh Token 标记作废（服务端存储或哈希验证）</li></ol><blockquote><p>好处：即使 Refresh Token 被窃取，只能使用一次，减少长期滥用风险。</p></blockquote><hr><h4 id="5-Token-和-Session-对比"><a href="#5-Token-和-Session-对比" class="headerlink" title="5. Token 和 Session 对比"></a>5. Token 和 Session 对比</h4><table><thead><tr><th>维度</th><th>Token (JWT)</th><th>Session</th></tr></thead><tbody><tr><td>存储位置</td><td>客户端（可无状态）</td><td>服务端（存储 SessionID + 数据）</td></tr><tr><td>状态</td><td>无状态，可横向扩展</td><td>有状态，需共享存储（Redis&#x2F;DB）</td></tr><tr><td>验证方式</td><td>签名验证，无需访问 DB</td><td>查 Session 存储</td></tr><tr><td>撤销策略</td><td>难撤销，需黑名单&#x2F;短生命周期&#x2F;刷新机制</td><td>容易撤销，删除 Session 即失效</td></tr><tr><td>安全性</td><td>易受 XSS，如果存 localStorage</td><td>更安全，客户端只存 SessionID，可 HttpOnly Cookie</td></tr><tr><td>可扩展性</td><td>高，可横向扩展</td><td>需共享 Session 存储，跨微服务稍复杂</td></tr></tbody></table><hr><p>✅ <strong>面试答法总结</strong></p><blockquote><p>Refresh Token 应该安全存储（Web 用 HttpOnly+Secure Cookie，移动端用 Keychain&#x2F;Keystore），并支持撤销。<br> JWT 本身难以强撤销，可以用短生命周期 + 黑名单 + Refresh Token + 中央 introspection。<br> Token Binding 可以绑定 Token 与客户端密钥，防盗用。<br> 双刷新策略可以在滑动刷新 Access Token 的同时刷新 Refresh Token，提高安全性并保持用户在线体验。<br> Token 与 Session 本质差异在于“无状态 vs 有状态”，Token 更适合分布式横向扩展，Session 更容易撤销和管理敏感数据。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易版题目</title>
      <link href="/2025/09/23/%E7%AE%80%E6%98%93%E7%89%88%E9%A2%98%E7%9B%AE/"/>
      <url>/2025/09/23/%E7%AE%80%E6%98%93%E7%89%88%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="📚-数据库题库答案"><a href="#📚-数据库题库答案" class="headerlink" title="📚 数据库题库答案"></a>📚 数据库题库答案</h1><h3 id="1、OSI-七层模型"><a href="#1、OSI-七层模型" class="headerlink" title="1、OSI 七层模型"></a>1、OSI 七层模型</h3><ul><li>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li><li>功能：自下而上分别负责传输介质、链路控制、路由转发、端到端传输、会话管理、数据格式转换、应用服务。</li></ul><hr><h3 id="2、TCP-的三次握手"><a href="#2、TCP-的三次握手" class="headerlink" title="2、TCP 的三次握手"></a>2、TCP 的三次握手</h3><ol><li>客户端 → 服务端：SYN&#x3D;1（请求建立连接）。</li><li>服务端 → 客户端：SYN&#x3D;1, ACK&#x3D;1（确认并同意建立）。</li><li>客户端 → 服务端：ACK&#x3D;1（确认）。<br> 👉 作用：确保双方具备收发能力，并同步初始序列号。</li></ol><hr><h3 id="3、TCP-的四次挥手"><a href="#3、TCP-的四次挥手" class="headerlink" title="3、TCP 的四次挥手"></a>3、TCP 的四次挥手</h3><ol><li>客户端 → 服务端：FIN&#x3D;1（我没数据了）。</li><li>服务端 → 客户端：ACK&#x3D;1（收到）。</li><li>服务端 → 客户端：FIN&#x3D;1（我也没数据了）。</li><li>客户端 → 服务端：ACK&#x3D;1（收到）。<br> 👉 双方各自独立关闭。</li></ol><hr><h3 id="4、SQL-语言和方言的区别"><a href="#4、SQL-语言和方言的区别" class="headerlink" title="4、SQL 语言和方言的区别"></a>4、SQL 语言和方言的区别</h3><ul><li><strong>SQL 语言</strong>：标准 SQL（ANSI&#x2F;ISO 定义），如 <code>SELECT * FROM table;</code>。</li><li><strong>SQL 方言</strong>：不同数据库厂商在标准 SQL 基础上扩展的特性，如 MySQL 的 <code>LIMIT</code>，Oracle 的 <code>ROWNUM</code>。</li></ul><hr><h3 id="5、SQL-语句的分类"><a href="#5、SQL-语句的分类" class="headerlink" title="5、SQL 语句的分类"></a>5、SQL 语句的分类</h3><ul><li><strong>DDL</strong>：数据定义语言（CREATE、ALTER、DROP）。</li><li><strong>DML</strong>：数据操作语言（INSERT、UPDATE、DELETE）。</li><li><strong>DQL</strong>：数据查询语言（SELECT）。</li><li><strong>DCL</strong>：数据控制语言（GRANT、REVOKE）。</li><li><strong>TCL</strong>：事务控制语言（COMMIT、ROLLBACK、SAVEPOINT）。</li></ul><hr><h3 id="6、MySQL-中-double-和-decimal-的区别"><a href="#6、MySQL-中-double-和-decimal-的区别" class="headerlink" title="6、MySQL 中 double 和 decimal 的区别"></a>6、MySQL 中 double 和 decimal 的区别</h3><ul><li><strong>double</strong>：浮点型，近似值，速度快，可能有精度丢失。</li><li><strong>decimal</strong>：定点型，精确值（常用于金额）。</li></ul><hr><h3 id="7、NULL-值参与计算的结果是什么"><a href="#7、NULL-值参与计算的结果是什么" class="headerlink" title="7、NULL 值参与计算的结果是什么"></a>7、NULL 值参与计算的结果是什么</h3><ul><li>任何运算只要有 <code>NULL</code> 参与，结果就是 <code>NULL</code>。<br> 例：<code>1 + NULL = NULL</code>。</li></ul><hr><h3 id="8、关系型数据库中，NULL-值参与排序的结果"><a href="#8、关系型数据库中，NULL-值参与排序的结果" class="headerlink" title="8、关系型数据库中，NULL 值参与排序的结果"></a>8、关系型数据库中，NULL 值参与排序的结果</h3><ul><li><strong>升序（ASC）</strong>：NULL 在最前面。</li><li><strong>降序（DESC）</strong>：NULL 在最后面。<br> （部分数据库可用 <code>NULLS FIRST | LAST</code> 明确指定）。</li></ul><hr><h3 id="9、NULL-值是否参与聚合函数的计算"><a href="#9、NULL-值是否参与聚合函数的计算" class="headerlink" title="9、NULL 值是否参与聚合函数的计算"></a>9、NULL 值是否参与聚合函数的计算</h3><ul><li><code>COUNT(*)</code> 会统计 NULL。</li><li><code>COUNT(col)</code>、<code>SUM(col)</code>、<code>AVG(col)</code>、<code>MAX/MIN</code> 忽略 NULL。</li></ul><hr><h3 id="10、WHERE-和-HAVING-的区别"><a href="#10、WHERE-和-HAVING-的区别" class="headerlink" title="10、WHERE 和 HAVING 的区别"></a>10、WHERE 和 HAVING 的区别</h3><ul><li><strong>WHERE</strong>：对原始数据过滤，作用在分组前。</li><li><strong>HAVING</strong>：对分组结果过滤，作用在 <code>GROUP BY</code> 之后。</li></ul><hr><h3 id="11、数据库中约束的分类"><a href="#11、数据库中约束的分类" class="headerlink" title="11、数据库中约束的分类"></a>11、数据库中约束的分类</h3><ul><li><strong>实体完整性约束</strong>：主键约束、唯一约束。</li><li><strong>域完整性约束</strong>：非空约束、默认值约束、检查约束。</li><li><strong>参照完整性约束</strong>：外键约束。</li></ul><hr><h3 id="12、主键约束和非空且唯一约束的区别"><a href="#12、主键约束和非空且唯一约束的区别" class="headerlink" title="12、主键约束和非空且唯一约束的区别"></a>12、主键约束和非空且唯一约束的区别</h3><ul><li><strong>主键</strong>：唯一且非空，一个表只能有一个主键，可以由多个字段组成（复合主键）。</li><li><strong>唯一+非空</strong>：可以保证唯一性，但一个表可以有多个这样的约束。</li></ul><hr><h3 id="13、一对多关系怎么设置外键"><a href="#13、一对多关系怎么设置外键" class="headerlink" title="13、一对多关系怎么设置外键"></a>13、一对多关系怎么设置外键</h3><ul><li>在“多”的一方设置外键，引用“一”的一方的主键。</li></ul><hr><h3 id="14、数据库设计的三大范式"><a href="#14、数据库设计的三大范式" class="headerlink" title="14、数据库设计的三大范式"></a>14、数据库设计的三大范式</h3><ol><li><strong>第一范式（1NF）</strong>：字段不可再分。</li><li><strong>第二范式（2NF）</strong>：在 1NF 基础上，非主属性完全依赖于主键。</li><li><strong>第三范式（3NF）</strong>：在 2NF 基础上，非主属性不依赖于其他非主属性。</li></ol><hr><h3 id="15、内连接和左外连接的区别"><a href="#15、内连接和左外连接的区别" class="headerlink" title="15、内连接和左外连接的区别"></a>15、内连接和左外连接的区别</h3><ul><li><strong>内连接</strong>：只返回匹配上的数据。</li><li><strong>左外连接</strong>：返回左表的全部数据，没有匹配的地方用 NULL 填充。</li></ul><hr><h3 id="16、数据库中是否支持全连接"><a href="#16、数据库中是否支持全连接" class="headerlink" title="16、数据库中是否支持全连接"></a>16、数据库中是否支持全连接</h3><ul><li>MySQL 不支持 <code>FULL OUTER JOIN</code>，但可以用 <code>UNION</code>（<code>LEFT JOIN</code> + <code>RIGHT JOIN</code>）模拟。</li><li>Oracle、SQL Server 支持 <code>FULL JOIN</code>。</li></ul><hr><h3 id="17、UNION-ALL-和-UNION-的区别"><a href="#17、UNION-ALL-和-UNION-的区别" class="headerlink" title="17、UNION ALL 和 UNION 的区别"></a>17、UNION ALL 和 UNION 的区别</h3><ul><li><strong>UNION</strong>：合并去重。</li><li><strong>UNION ALL</strong>：合并不去重，效率更高。</li></ul><hr><h3 id="18、什么是事务"><a href="#18、什么是事务" class="headerlink" title="18、什么是事务"></a>18、什么是事务</h3><ul><li>一组数据库操作，要么全部执行，要么全部不执行，是数据库保证数据一致性的基本单位。</li></ul><hr><h3 id="19、事务是怎么保证同时成功或者同时失败的"><a href="#19、事务是怎么保证同时成功或者同时失败的" class="headerlink" title="19、事务是怎么保证同时成功或者同时失败的"></a>19、事务是怎么保证同时成功或者同时失败的</h3><ul><li>依靠 <strong>日志（Redo Log、Undo Log）</strong> 和 <strong>事务控制语句（COMMIT&#x2F;ROLLBACK）</strong>。</li><li>失败时回滚（Undo），成功时提交（Redo）。</li></ul><hr><h3 id="20、事务的四大特征（ACID）"><a href="#20、事务的四大特征（ACID）" class="headerlink" title="20、事务的四大特征（ACID）"></a>20、事务的四大特征（ACID）</h3><ol><li><strong>原子性</strong>：不可分割。</li><li><strong>一致性</strong>：数据前后状态一致。</li><li><strong>隔离性</strong>：并发事务互不干扰。</li><li><strong>持久性</strong>：提交后数据永久保存。</li></ol><hr><h3 id="21、事务的隔离级别及可能出现的问题"><a href="#21、事务的隔离级别及可能出现的问题" class="headerlink" title="21、事务的隔离级别及可能出现的问题"></a>21、事务的隔离级别及可能出现的问题</h3><ul><li><strong>读未提交</strong>：可能出现脏读。</li><li><strong>读已提交</strong>：可能出现不可重复读。</li><li><strong>可重复读（MySQL 默认）</strong>：可能出现幻读。</li><li><strong>串行化</strong>：无并发问题，但性能最差。</li></ul><hr><h3 id="22、慢查询的作用是什么"><a href="#22、慢查询的作用是什么" class="headerlink" title="22、慢查询的作用是什么"></a>22、慢查询的作用是什么</h3><ul><li>帮助定位性能瓶颈，找出执行时间超过阈值的 SQL，用于优化数据库。</li></ul><hr><h3 id="23、使用模糊查询时是否会导致索引失效"><a href="#23、使用模糊查询时是否会导致索引失效" class="headerlink" title="23、使用模糊查询时是否会导致索引失效"></a>23、使用模糊查询时是否会导致索引失效</h3><ul><li><code>LIKE &#39;%abc&#39;</code> 前缀模糊查询会导致索引失效。</li><li><code>LIKE &#39;abc%&#39;</code> 可以利用索引。</li></ul><hr><h3 id="24、联合索引走索引的条件是什么"><a href="#24、联合索引走索引的条件是什么" class="headerlink" title="24、联合索引走索引的条件是什么"></a>24、联合索引走索引的条件是什么</h3><ul><li>遵循 <strong>最左前缀原则</strong>：必须从索引最左列开始匹配。<br> 例：索引 <code>(a,b,c)</code>，可以用 <code>a</code>，<code>a,b</code>，<code>a,b,c</code>，但不能只用 <code>b</code> 或 <code>c</code>。</li></ul><hr><h3 id="25、索引的底层结构是什么"><a href="#25、索引的底层结构是什么" class="headerlink" title="25、索引的底层结构是什么"></a>25、索引的底层结构是什么</h3><ul><li><strong>B+ 树</strong>（最常见，MySQL InnoDB）。</li><li>其他：哈希索引、全文索引、空间索引（较少用）。</li></ul><hr><h3 id="26、B-树和-B-树的区别"><a href="#26、B-树和-B-树的区别" class="headerlink" title="26、B 树和 B+ 树的区别"></a>26、B 树和 B+ 树的区别</h3><ul><li><strong>B 树</strong>：每个节点既存储键，也存储数据。</li><li><strong>B+ 树</strong>：数据只存储在叶子节点，非叶子节点只存储索引；叶子节点有链表，方便范围查询。<br> 👉 B+ 树更适合数据库。</li></ul><hr><h1 id="☕-Java-基础题库答案"><a href="#☕-Java-基础题库答案" class="headerlink" title="☕ Java 基础题库答案"></a>☕ Java 基础题库答案</h1><h3 id="27、final-特点"><a href="#27、final-特点" class="headerlink" title="27、final 特点"></a>27、final 特点</h3><ul><li><strong>修饰类</strong>：类不可被继承。</li><li><strong>修饰方法</strong>：方法不可被重写。</li><li><strong>修饰变量</strong>：变量成为常量，只能赋值一次。</li><li><strong>修饰引用类型</strong>：引用地址不可变，但对象内容可变。</li></ul><hr><h3 id="28、static-的作用和特点"><a href="#28、static-的作用和特点" class="headerlink" title="28、static 的作用和特点"></a>28、static 的作用和特点</h3><ul><li>修饰变量 → 静态变量，属于类，共享一份存储。</li><li>修饰方法 → 静态方法，不依赖对象，可以通过类名调用。</li><li>修饰代码块 → 静态代码块，类加载时执行一次。</li><li>特点：先于对象存在，生命周期随类而生灭。</li></ul><hr><h3 id="29、静态代码块、构造代码块、构造方法的执行顺序和特点"><a href="#29、静态代码块、构造代码块、构造方法的执行顺序和特点" class="headerlink" title="29、静态代码块、构造代码块、构造方法的执行顺序和特点"></a>29、静态代码块、构造代码块、构造方法的执行顺序和特点</h3><ul><li>执行顺序：<br> <strong>静态代码块 → 构造代码块 → 构造方法</strong>。</li><li>特点：<ul><li>静态代码块：类加载时执行一次。</li><li>构造代码块：每次创建对象时都会执行。</li><li>构造方法：每次创建对象时执行，用于初始化对象。</li></ul></li></ul><hr><h3 id="30、多态的前提"><a href="#30、多态的前提" class="headerlink" title="30、多态的前提"></a>30、多态的前提</h3><ol><li>必须有继承或实现关系。</li><li>必须有方法重写。</li><li>必须有父类引用指向子类对象。</li></ol><hr><h3 id="31、多态中的成员访问特点"><a href="#31、多态中的成员访问特点" class="headerlink" title="31、多态中的成员访问特点"></a>31、多态中的成员访问特点</h3><ul><li>成员变量：编译看左边（父类），运行看左边。</li><li>成员方法：编译看左边，运行看右边（动态绑定）。</li><li>静态方法：编译和运行都看左边（属于类）。</li></ul><hr><h3 id="32、抽象类的特点"><a href="#32、抽象类的特点" class="headerlink" title="32、抽象类的特点"></a>32、抽象类的特点</h3><ul><li>用 <code>abstract</code> 修饰的类，不能实例化。</li><li>可以包含抽象方法，也可以有普通方法。</li><li>可以有构造方法。</li><li>必须被继承，子类实现抽象方法后才能实例化。</li></ul><hr><h3 id="33、抽象类的成员特点"><a href="#33、抽象类的成员特点" class="headerlink" title="33、抽象类的成员特点"></a>33、抽象类的成员特点</h3><ul><li><strong>成员变量</strong>：可以是任意修饰符（public、protected、private）。</li><li><strong>成员方法</strong>：既可以是抽象方法，也可以是普通方法。</li><li><strong>构造方法</strong>：可以有，用于子类初始化。</li></ul><hr><h3 id="34、接口中成员变量和成员方法的默认修饰符"><a href="#34、接口中成员变量和成员方法的默认修饰符" class="headerlink" title="34、接口中成员变量和成员方法的默认修饰符"></a>34、接口中成员变量和成员方法的默认修饰符</h3><ul><li><strong>成员变量</strong>：默认 <code>public static final</code>（常量）。</li><li><strong>成员方法</strong>：默认 <code>public abstract</code>（抽象方法）。</li><li>JDK 8+：允许有 <code>default</code> 和 <code>static</code> 方法。</li><li>JDK 9+：允许有 <code>private</code> 方法（仅接口内部使用）。</li></ul><hr><h3 id="35、接口的成员特点"><a href="#35、接口的成员特点" class="headerlink" title="35、接口的成员特点"></a>35、接口的成员特点</h3><ul><li>变量：<code>public static final</code>。</li><li>方法：<ul><li>抽象方法（默认 <code>public abstract</code>）。</li><li>默认方法（<code>default</code>，可以有方法体）。</li><li>静态方法（<code>static</code>，只能用接口名调用）。</li><li>私有方法（<code>private</code>，JDK 9 引入，用于接口内部复用）。</li></ul></li></ul><hr><h3 id="36、接口和抽象类的区别"><a href="#36、接口和抽象类的区别" class="headerlink" title="36、接口和抽象类的区别"></a>36、接口和抽象类的区别</h3><table><thead><tr><th>比较点</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>关键字</td><td><code>abstract class</code></td><td><code>interface</code></td></tr><tr><td>方法</td><td>可有抽象方法和普通方法</td><td>默认抽象方法，JDK8 以后支持 default &amp; static</td></tr><tr><td>变量</td><td>普通变量和常量</td><td>只能有常量</td></tr><tr><td>继承</td><td>只能单继承</td><td>可多实现</td></tr><tr><td>构造方法</td><td>可以有</td><td>不能有</td></tr><tr><td>设计目的</td><td>代码复用</td><td>规范约束</td></tr></tbody></table><hr><h3 id="37、多态的三种方式"><a href="#37、多态的三种方式" class="headerlink" title="37、多态的三种方式"></a>37、多态的三种方式</h3><ol><li>继承 + 方法重写。</li><li>实现接口。</li><li>抽象类的子类实现。</li></ol><hr><h3 id="38、内部类的分类"><a href="#38、内部类的分类" class="headerlink" title="38、内部类的分类"></a>38、内部类的分类</h3><ol><li><strong>成员内部类</strong>（定义在类中，和成员变量同级）。</li><li><strong>静态内部类</strong>（用 <code>static</code> 修饰，不依赖外部类实例）。</li><li><strong>局部内部类</strong>（定义在方法中）。</li><li><strong>匿名内部类</strong>（没有名字的内部类，多用于回调）。</li></ol><hr><h3 id="39、匿名内部类的前提和本质"><a href="#39、匿名内部类的前提和本质" class="headerlink" title="39、匿名内部类的前提和本质"></a>39、匿名内部类的前提和本质</h3><ul><li><strong>前提</strong>：必须继承一个类或实现一个接口。</li><li><strong>本质</strong>：编译器生成一个没有名字的子类，并立即创建对象。</li></ul><hr><h3 id="40、Object-类中有哪些常见的方法"><a href="#40、Object-类中有哪些常见的方法" class="headerlink" title="40、Object 类中有哪些常见的方法"></a>40、Object 类中有哪些常见的方法</h3><ul><li><code>toString()</code>：返回对象字符串表示。</li><li><code>equals()</code>：比较对象是否相等。</li><li><code>hashCode()</code>：返回哈希值。</li><li><code>clone()</code>：对象克隆（需实现 <code>Cloneable</code>）。</li><li><code>finalize()</code>：垃圾回收前调用（已过时）。</li><li><code>wait()</code> &#x2F; <code>notify()</code> &#x2F; <code>notifyAll()</code>：线程通信方法。</li><li><code>getClass()</code>：获取运行时类对象。</li></ul><hr><p>好的 ✅<br> 那我现在给你写 <strong>集合与源码机制（41–67 题）</strong> 的逐题答案，每道题都附上关键点总结，方便你复习。</p><hr><h1 id="📚-集合与源码机制题库答案"><a href="#📚-集合与源码机制题库答案" class="headerlink" title="📚 集合与源码机制题库答案"></a>📚 集合与源码机制题库答案</h1><h3 id="41-ArrayList-底层实现原理"><a href="#41-ArrayList-底层实现原理" class="headerlink" title="41. ArrayList 底层实现原理"></a><strong>41. ArrayList 底层实现原理</strong></h3><ul><li>底层是 <strong>动态数组</strong>，默认容量 10。</li><li>当容量不足时，会按 <code>1.5 倍扩容</code>。</li><li>支持随机访问，查找快（O(1)），插入&#x2F;删除慢（O(n)）。</li></ul><hr><h3 id="42-ArrayList-扩容机制"><a href="#42-ArrayList-扩容机制" class="headerlink" title="42. ArrayList 扩容机制"></a><strong>42. ArrayList 扩容机制</strong></h3><ul><li>默认容量 10。</li><li>新容量 &#x3D; 旧容量 + (旧容量 &gt;&gt; 1) &#x3D; <strong>1.5 倍</strong>。</li><li>通过 <code>Arrays.copyOf</code> 拷贝到新数组。</li></ul><hr><h3 id="43-LinkedList-底层实现原理"><a href="#43-LinkedList-底层实现原理" class="headerlink" title="43. LinkedList 底层实现原理"></a><strong>43. LinkedList 底层实现原理</strong></h3><ul><li>底层是 <strong>双向链表</strong>。</li><li>每个节点存储 <code>prev</code>、<code>next</code>、<code>item</code>。</li><li>插入&#x2F;删除快（O(1)），随机访问慢（O(n)）。</li></ul><hr><h3 id="44-ArrayList-和-LinkedList-区别"><a href="#44-ArrayList-和-LinkedList-区别" class="headerlink" title="44. ArrayList 和 LinkedList 区别"></a><strong>44. ArrayList 和 LinkedList 区别</strong></h3><ul><li>ArrayList：底层数组，随机访问快，插入删除慢。</li><li>LinkedList：底层链表，插入删除快，随机访问慢。</li><li>内存利用：ArrayList 连续内存，LinkedList 分散存储。</li></ul><hr><h3 id="45-HashMap-底层实现原理"><a href="#45-HashMap-底层实现原理" class="headerlink" title="45. HashMap 底层实现原理"></a><strong>45. HashMap 底层实现原理</strong></h3><ul><li>JDK7：数组 + 链表。</li><li>JDK8：数组 + 链表 + 红黑树（链表长度 ≥ 8 转为红黑树）。</li><li>通过 <strong>hash 值 + 取模运算</strong> 定位数组下标。</li><li>解决哈希冲突：拉链法。</li></ul><hr><h3 id="46-HashMap-默认容量-负载因子"><a href="#46-HashMap-默认容量-负载因子" class="headerlink" title="46. HashMap 默认容量 &amp; 负载因子"></a><strong>46. HashMap 默认容量 &amp; 负载因子</strong></h3><ul><li>默认容量：16</li><li>负载因子：0.75</li><li>阈值：容量 × 负载因子</li></ul><hr><h3 id="47-HashMap-扩容机制"><a href="#47-HashMap-扩容机制" class="headerlink" title="47. HashMap 扩容机制"></a><strong>47. HashMap 扩容机制</strong></h3><ul><li>当元素个数 &gt; 阈值时，扩容为 <strong>2 倍</strong>。</li><li>JDK8 之后扩容时会优化节点迁移，减少冲突。</li></ul><hr><h3 id="48-HashMap-为什么容量必须是-2-的幂次方"><a href="#48-HashMap-为什么容量必须是-2-的幂次方" class="headerlink" title="48. HashMap 为什么容量必须是 2 的幂次方"></a><strong>48. HashMap 为什么容量必须是 2 的幂次方</strong></h3><ul><li>计算下标时用 <code>(n - 1) &amp; hash</code>。</li><li>这样比取模运算快，并且分布更均匀。</li></ul><hr><h3 id="49-HashMap-put-流程"><a href="#49-HashMap-put-流程" class="headerlink" title="49. HashMap put 流程"></a><strong>49. HashMap put 流程</strong></h3><ol><li>计算 key 的 hash。</li><li>定位数组下标。</li><li>若位置为空 → 新建节点。</li><li>若存在节点 → 判断是否相等：<ul><li>相等 → 覆盖 value。</li><li>不相等 → 拉链&#x2F;红黑树插入。</li></ul></li><li>如果 size 超过阈值 → 扩容。</li></ol><hr><h3 id="50-HashMap-get-流程"><a href="#50-HashMap-get-流程" class="headerlink" title="50. HashMap get 流程"></a><strong>50. HashMap get 流程</strong></h3><ol><li>计算 key 的 hash，找到数组下标。</li><li>遍历链表&#x2F;红黑树，比较 key。</li><li>返回 value。</li></ol><hr><h3 id="51-HashMap-如何解决哈希冲突"><a href="#51-HashMap-如何解决哈希冲突" class="headerlink" title="51. HashMap 如何解决哈希冲突"></a><strong>51. HashMap 如何解决哈希冲突</strong></h3><ul><li>采用 <strong>链地址法（拉链法）</strong>。</li><li>JDK8 引入红黑树，提升查询效率。</li></ul><hr><h3 id="52-HashMap-与-Hashtable-区别"><a href="#52-HashMap-与-Hashtable-区别" class="headerlink" title="52. HashMap 与 Hashtable 区别"></a><strong>52. HashMap 与 Hashtable 区别</strong></h3><ul><li>HashMap：线程不安全，允许 <code>null key / null value</code>。</li><li>Hashtable：线程安全（synchronized），不允许 null。</li></ul><hr><h3 id="53-HashMap-与-ConcurrentHashMap-区别"><a href="#53-HashMap-与-ConcurrentHashMap-区别" class="headerlink" title="53. HashMap 与 ConcurrentHashMap 区别"></a><strong>53. HashMap 与 ConcurrentHashMap 区别</strong></h3><ul><li>HashMap：线程不安全。</li><li>ConcurrentHashMap：线程安全，JDK7 用分段锁，JDK8 用 CAS + synchronized。</li></ul><hr><h3 id="54-ConcurrentHashMap-底层实现"><a href="#54-ConcurrentHashMap-底层实现" class="headerlink" title="54. ConcurrentHashMap 底层实现"></a><strong>54. ConcurrentHashMap 底层实现</strong></h3><ul><li>JDK7：Segment + HashEntry（分段锁）。</li><li>JDK8：Node + CAS + synchronized，链表转红黑树。</li></ul><hr><h3 id="55-HashSet-底层实现原理"><a href="#55-HashSet-底层实现原理" class="headerlink" title="55. HashSet 底层实现原理"></a><strong>55. HashSet 底层实现原理</strong></h3><ul><li>基于 <strong>HashMap</strong> 实现。</li><li>元素存入 HashMap 的 key，value 用一个常量 <code>Object.PRESENT</code>。</li></ul><hr><h3 id="56-TreeSet-底层实现原理"><a href="#56-TreeSet-底层实现原理" class="headerlink" title="56. TreeSet 底层实现原理"></a><strong>56. TreeSet 底层实现原理</strong></h3><ul><li>基于 <strong>TreeMap</strong>（红黑树）实现。</li><li>元素必须实现 <code>Comparable</code> 或传入 <code>Comparator</code>。</li></ul><hr><h3 id="57-HashMap-为什么线程不安全"><a href="#57-HashMap-为什么线程不安全" class="headerlink" title="57. HashMap 为什么线程不安全"></a><strong>57. HashMap 为什么线程不安全</strong></h3><ul><li>多线程 put 可能覆盖，扩容可能死循环（JDK7）。</li><li>导致数据丢失或结构异常。</li></ul><hr><h3 id="58-HashMap-死循环问题"><a href="#58-HashMap-死循环问题" class="headerlink" title="58. HashMap 死循环问题"></a><strong>58. HashMap 死循环问题</strong></h3><ul><li>出现在 JDK7 并发扩容时。</li><li>链表迁移时头插法，可能形成环，导致 get&#x2F;put 死循环。</li></ul><hr><h3 id="59-fail-fast-机制"><a href="#59-fail-fast-机制" class="headerlink" title="59. fail-fast 机制"></a><strong>59. fail-fast 机制</strong></h3><ul><li>迭代器遍历时，如果集合被结构性修改，会抛出 <code>ConcurrentModificationException</code>。</li><li>依赖 <code>modCount</code> 判断。</li></ul><hr><h3 id="60-fail-safe-机制"><a href="#60-fail-safe-机制" class="headerlink" title="60. fail-safe 机制"></a><strong>60. fail-safe 机制</strong></h3><ul><li>基于 <strong>副本</strong> 实现（如 <code>CopyOnWriteArrayList</code>、<code>ConcurrentHashMap</code>）。</li><li>修改不会影响原集合，不会抛异常。</li></ul><hr><h3 id="61-HashMap-的-get-能否判断-key-是否存在？"><a href="#61-HashMap-的-get-能否判断-key-是否存在？" class="headerlink" title="61. HashMap 的 get() 能否判断 key 是否存在？"></a><strong>61. HashMap 的 get() 能否判断 key 是否存在？</strong></h3><ul><li>不能。因为返回 null 可能是：<ul><li>key 不存在</li><li>key 存在但 value 为 null</li></ul></li><li>判断应使用 <code>containsKey()</code>。</li></ul><hr><h3 id="62-HashMap-线程安全替代方案"><a href="#62-HashMap-线程安全替代方案" class="headerlink" title="62. HashMap 线程安全替代方案"></a><strong>62. HashMap 线程安全替代方案</strong></h3><ul><li><code>ConcurrentHashMap</code>（推荐）</li><li><code>Collections.synchronizedMap(new HashMap&lt;&gt;())</code>（性能差）。</li></ul><hr><h3 id="63-CopyOnWriteArrayList-底层原理"><a href="#63-CopyOnWriteArrayList-底层原理" class="headerlink" title="63. CopyOnWriteArrayList 底层原理"></a><strong>63. CopyOnWriteArrayList 底层原理</strong></h3><ul><li>每次写操作都会复制新数组。</li><li>读操作无锁，写操作加锁。</li><li>适合 <strong>读多写少</strong> 场景。</li></ul><hr><h3 id="64-ArrayList-与-Vector-区别"><a href="#64-ArrayList-与-Vector-区别" class="headerlink" title="64. ArrayList 与 Vector 区别"></a><strong>64. ArrayList 与 Vector 区别</strong></h3><ul><li>ArrayList：线程不安全，扩容 1.5 倍。</li><li>Vector：线程安全（方法加 synchronized），扩容 2 倍。</li></ul><hr><h3 id="65-BlockingQueue-常见实现"><a href="#65-BlockingQueue-常见实现" class="headerlink" title="65. BlockingQueue 常见实现"></a><strong>65. BlockingQueue 常见实现</strong></h3><ul><li>ArrayBlockingQueue：数组结构，固定容量。</li><li>LinkedBlockingQueue：链表结构，容量可指定。</li><li>PriorityBlockingQueue：带优先级。</li><li>DelayQueue：延时队列。</li></ul><hr><h3 id="66-WeakHashMap-底层原理"><a href="#66-WeakHashMap-底层原理" class="headerlink" title="66. WeakHashMap 底层原理"></a><strong>66. WeakHashMap 底层原理</strong></h3><ul><li>key 使用 <strong>弱引用</strong>。</li><li>当 key 没有强引用时，GC 会回收该 entry。</li></ul><hr><h3 id="67-EnumMap-底层实现"><a href="#67-EnumMap-底层实现" class="headerlink" title="67. EnumMap 底层实现"></a><strong>67. EnumMap 底层实现</strong></h3><ul><li>key 必须是 enum 类型。</li><li>底层是一个数组，用枚举的 <code>ordinal()</code> 作为索引，效率很高。</li></ul><hr><p>好的 ✅<br> 那我接着帮你整理 <strong>68–80（多线程与并发相关）</strong> 的题目答案。</p><hr><h1 id="⚡-Java-并发与多线程"><a href="#⚡-Java-并发与多线程" class="headerlink" title="⚡ Java 并发与多线程"></a>⚡ Java 并发与多线程</h1><h3 id="68-File-和-IO-的区别"><a href="#68-File-和-IO-的区别" class="headerlink" title="68. File 和 IO 的区别"></a><strong>68. File 和 IO 的区别</strong></h3><ul><li><code>File</code>：表示文件或目录路径，不涉及数据读写。</li><li><code>IO</code>：负责文件内容的读写操作（InputStream &#x2F; OutputStream &#x2F; Reader &#x2F; Writer）。</li></ul><hr><h3 id="69-flush-和-close-的区别"><a href="#69-flush-和-close-的区别" class="headerlink" title="69. flush 和 close 的区别"></a><strong>69. flush 和 close 的区别</strong></h3><ul><li><code>flush()</code>：强制把缓冲区的数据写入目的地，但流仍然可用。</li><li><code>close()</code>：先执行 flush，然后关闭流，流不可再用。</li></ul><hr><h3 id="70-IO-流中的相对路径和绝对路径"><a href="#70-IO-流中的相对路径和绝对路径" class="headerlink" title="70. IO 流中的相对路径和绝对路径"></a><strong>70. IO 流中的相对路径和绝对路径</strong></h3><ul><li>绝对路径：从磁盘根目录开始的完整路径，如 <code>C:/test/a.txt</code>。</li><li>相对路径：相对于项目运行的工作目录（<code>user.dir</code>）。</li></ul><hr><h3 id="71-程序、进程、线程、协程的区别"><a href="#71-程序、进程、线程、协程的区别" class="headerlink" title="71. 程序、进程、线程、协程的区别"></a><strong>71. 程序、进程、线程、协程的区别</strong></h3><ul><li>程序：静态的代码和数据集合。</li><li>进程：程序的执行实例，资源分配的最小单位。</li><li>线程：进程中的执行单元，CPU 调度的最小单位。</li><li>协程：用户态的轻量级线程，切换开销更低。</li></ul><hr><h3 id="72-并发和并行的区别"><a href="#72-并发和并行的区别" class="headerlink" title="72. 并发和并行的区别"></a><strong>72. 并发和并行的区别</strong></h3><ul><li>并发：一个 CPU 同时处理多个任务（宏观上同时，微观上切换）。</li><li>并行：多个 CPU 同时真正地执行多个任务。</li></ul><hr><h3 id="73-run-和-start-的区别"><a href="#73-run-和-start-的区别" class="headerlink" title="73. run 和 start 的区别"></a><strong>73. run 和 start 的区别</strong></h3><ul><li><code>run()</code>：普通方法调用，不会开启新线程。</li><li><code>start()</code>：启动新线程，由 JVM 调用 <code>run()</code>。</li></ul><hr><h3 id="74-描述线程的生命周期"><a href="#74-描述线程的生命周期" class="headerlink" title="74. 描述线程的生命周期"></a><strong>74. 描述线程的生命周期</strong></h3><ol><li><strong>新建（New）</strong>：<code>new Thread()</code>。</li><li><strong>就绪（Runnable）</strong>：调用 <code>start()</code>，等待 CPU 调度。</li><li><strong>运行（Running）</strong>：CPU 调度执行。</li><li><strong>阻塞&#x2F;等待（Blocked&#x2F;Waiting&#x2F;Timed Waiting）</strong>：等待资源或条件。</li><li><strong>终止（Terminated）</strong>：线程执行完毕或异常退出。</li></ol><hr><h3 id="75-HashMap-和-Hashtable-的区别"><a href="#75-HashMap-和-Hashtable-的区别" class="headerlink" title="75. HashMap 和 Hashtable 的区别"></a><strong>75. HashMap 和 Hashtable 的区别</strong></h3><ul><li>HashMap：线程不安全，效率高，允许 null key 和 null value。</li><li>Hashtable：线程安全（方法加 synchronized），不允许 null。</li></ul><hr><h3 id="76-volatile-关键字的作用"><a href="#76-volatile-关键字的作用" class="headerlink" title="76. volatile 关键字的作用"></a><strong>76. volatile 关键字的作用</strong></h3><ul><li>保证 <strong>内存可见性</strong>（一个线程修改后，其他线程立即可见）。</li><li>禁止指令重排，保证一定的有序性。</li><li><strong>不保证原子性</strong>。</li></ul><hr><h3 id="77-使用线程池的好处"><a href="#77-使用线程池的好处" class="headerlink" title="77. 使用线程池的好处"></a><strong>77. 使用线程池的好处</strong></h3><ul><li>避免频繁创建和销毁线程，降低开销。</li><li>控制最大并发数，防止资源耗尽。</li><li>提高线程的可管理性和可扩展性。</li></ul><hr><h3 id="78-ThreadPoolExecutor-的七大参数"><a href="#78-ThreadPoolExecutor-的七大参数" class="headerlink" title="78. ThreadPoolExecutor 的七大参数"></a><strong>78. ThreadPoolExecutor 的七大参数</strong></h3><ol><li><code>corePoolSize</code>：核心线程数（常驻）。</li><li><code>maximumPoolSize</code>：最大线程数。</li><li><code>keepAliveTime</code>：非核心线程的存活时间。</li><li><code>unit</code>：存活时间的单位。</li><li><code>workQueue</code>：任务队列。</li><li><code>threadFactory</code>：线程工厂（自定义线程名等）。</li><li><code>handler</code>：拒绝策略。</li></ol><hr><h3 id="79-ThreadPoolExecutor-线程池的工作原理"><a href="#79-ThreadPoolExecutor-线程池的工作原理" class="headerlink" title="79. ThreadPoolExecutor 线程池的工作原理"></a><strong>79. ThreadPoolExecutor 线程池的工作原理</strong></h3><ol><li>任务提交 → 判断线程数是否 &lt; corePoolSize → 创建新线程。</li><li>否则 → 放入任务队列。</li><li>队列满 → 若线程数 &lt; maximumPoolSize → 创建新线程。</li><li>若已达最大线程数 → 执行拒绝策略。</li></ol><hr><h3 id="80-实现多线程的方式"><a href="#80-实现多线程的方式" class="headerlink" title="80. 实现多线程的方式"></a><strong>80. 实现多线程的方式</strong></h3><ol><li>继承 <code>Thread</code> 类，重写 <code>run()</code>。</li><li>实现 <code>Runnable</code> 接口，重写 <code>run()</code>。</li><li>实现 <code>Callable&lt;V&gt;</code> 接口，重写 <code>call()</code>，可返回结果，配合 <code>FutureTask</code>。</li><li>使用线程池 <code>ExecutorService</code> 提交任务。</li></ol><hr><h1 id="Java-基础-OOP-题库答案"><a href="#Java-基础-OOP-题库答案" class="headerlink" title="Java 基础 &amp; OOP 题库答案"></a>Java 基础 &amp; OOP 题库答案</h1><p><strong>1、Java 的版本分类有哪些</strong></p><ul><li><strong>Java SE</strong>（Standard Edition）：标准版，提供核心语法和 API。</li><li><strong>Java EE</strong>（Enterprise Edition）：企业版，基于 SE，增加 Web、分布式开发支持。</li><li><strong>Java ME</strong>（Micro Edition）：微型版，面向嵌入式、移动设备。</li></ul><hr><p><strong>2、Java 中跨平台的原理是什么</strong></p><ul><li>原理：<strong>一次编译，到处运行</strong>。</li><li><code>.java → .class (字节码)</code>，由 <strong>JVM</strong> 在不同系统上解释&#x2F;执行。</li></ul><hr><p><strong>3、JDK、JRE 和 JVM 的区别</strong></p><ul><li><strong>JVM</strong>：Java 虚拟机，执行字节码。</li><li><strong>JRE</strong>：运行环境 &#x3D; JVM + 核心类库。</li><li><strong>JDK</strong>：开发工具包 &#x3D; JRE + 编译器 <code>javac</code> + 调试工具等。</li></ul><hr><p><strong>4、Java 中的注释有哪几种，分别怎么表示</strong></p><ul><li>单行注释：<code>//</code></li><li>多行注释：<code>/* ... */</code></li><li>文档注释（javadoc）：<code>/** ... */</code></li></ul><hr><p><strong>5、Java 中常量的分类</strong></p><ul><li><strong>字面值常量</strong>：如 <code>123</code>、<code>&quot;hello&quot;</code>。</li><li><strong>符号常量</strong>：<code>final</code> 修饰的变量。</li></ul><hr><p><strong>6、Java 中的数据类型有哪些</strong></p><ul><li><strong>基本类型</strong>（8 个）：<ul><li>整数：<code>byte, short, int, long</code></li><li>浮点：<code>float, double</code></li><li>字符：<code>char</code></li><li>布尔：<code>boolean</code></li></ul></li><li><strong>引用类型</strong>：类、接口、数组。</li></ul><hr><p><strong>7、a++ 和 ++a 的区别</strong></p><ul><li><code>a++</code>：先用后加（返回旧值，再自增）。</li><li><code>++a</code>：先加后用（先自增，返回新值）。</li></ul><hr><p><strong>8、为什么要使用 IDEA</strong></p><ul><li>强大的 IDE，支持智能提示、调试、Maven&#x2F;Gradle 集成、Spring 支持、快捷键高效。</li></ul><hr><p><strong>9、方法的分类</strong></p><ul><li>按是否有返回值：有返回值 &#x2F; 无返回值（<code>void</code>）。</li><li>按访问权限：<code>public</code> &#x2F; <code>protected</code> &#x2F; <code>private</code>。</li><li>按修饰符：实例方法 &#x2F; 静态方法 &#x2F; 抽象方法 &#x2F; final 方法。</li></ul><hr><p><strong>10、什么是方法重载</strong></p><ul><li>同一类中，方法名相同，<strong>参数列表不同</strong>（个数 &#x2F; 类型 &#x2F; 顺序），与返回值无关。</li></ul><hr><p><strong>11、switch 小括号里的表达式可以是哪些数据类型</strong></p><ul><li><strong>允许</strong>：<code>byte, short, int, char, enum, String</code>（JDK7+）。</li><li><strong>不允许</strong>：<code>long, float, double, boolean</code>。</li></ul><hr><p><strong>12、数组的特点</strong></p><ul><li>长度固定，不可变。</li><li>元素类型相同，内存连续。</li><li>支持随机访问（下标 O(1)）。</li></ul><hr><p><strong>13、数组的动态创建方式和静态创建方式的区别</strong></p><ul><li>静态初始化：<code>int[] a = &#123;1, 2, 3&#125;;</code>（定义+赋值同时进行）。</li><li>动态初始化：<code>int[] a = new int[3];</code>（只分配空间，值为默认值）。</li></ul><hr><p><strong>14、Java 中的内存划分</strong></p><ul><li><strong>栈</strong>：方法调用、局部变量。</li><li><strong>堆</strong>：对象实例、数组。</li><li><strong>方法区（元空间）</strong>：类信息、常量池、静态变量。</li><li><strong>程序计数器</strong>：线程执行位置。</li><li><strong>本地方法栈</strong>：JNI 调用。</li></ul><hr><p><strong>15、面向对象和面向过程的区别</strong></p><ul><li><strong>面向过程</strong>：关注步骤和流程。</li><li><strong>面向对象</strong>：关注对象及其行为，强调封装、继承、多态。</li></ul><hr><p><strong>16、什么是类？什么是对象？</strong></p><ul><li><strong>类</strong>：对象的抽象（模板&#x2F;蓝图）。</li><li><strong>对象</strong>：类的实例，具体存在。</li></ul><hr><p><strong>17、类和对象的关系</strong></p><ul><li>类是抽象概念，对象是具体实例。</li><li>类定义属性&#x2F;行为，对象存储数据并调用方法。</li></ul><hr><p><strong>18、成员变量和局部变量的区别</strong></p><table><thead><tr><th>对比项</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>定义位置</td><td>类中，方法外</td><td>方法内、参数列表中</td></tr><tr><td>生命周期</td><td>随对象存在</td><td>随方法执行</td></tr><tr><td>默认值</td><td>有默认值</td><td>没有默认值，必须赋值</td></tr><tr><td>修饰符</td><td>可加权限修饰符</td><td>不可加权限修饰符</td></tr></tbody></table><hr><p><strong>19、面向对象的三大特征</strong></p><ul><li><strong>封装</strong>：隐藏细节，对外暴露接口。</li><li><strong>继承</strong>：子类复用父类代码。</li><li><strong>多态</strong>：同一接口，不同实现（编译时多态：重载；运行时多态：重写）。</li></ul><hr><p><strong>20、封装的作用和原则</strong></p><ul><li><strong>作用</strong>：隐藏内部实现，保证安全性和可维护性。</li><li><strong>原则</strong>：<ul><li>属性私有化（<code>private</code>）。</li><li>提供 <code>getter/setter</code> 控制访问。</li><li>对外暴露有限接口。</li></ul></li></ul><hr><h1 id="Java-基础-OOP"><a href="#Java-基础-OOP" class="headerlink" title="Java 基础 &amp; OOP"></a>Java 基础 &amp; OOP</h1><p><strong>21、给成员变量赋值的方式有哪些</strong></p><ol><li>定义时直接赋值</li><li>构造方法赋值</li><li>set 方法赋值</li><li>代码块赋值（静态&#x2F;构造代码块）</li></ol><hr><p><strong>22、继承的好处和缺点</strong></p><ul><li><strong>好处</strong>：代码复用、结构清晰、扩展方便。</li><li><strong>缺点</strong>：父类改动会影响子类，过度继承会造成耦合度高。</li></ul><hr><p><strong>23、继承中成员变量、构造方法、成员方法的访问特点</strong></p><ul><li><strong>成员变量</strong>：就近原则（子类和父类同名时，默认访问子类的）。</li><li><strong>构造方法</strong>：不能被继承，但子类会通过 <code>super()</code> 调用父类构造方法。</li><li><strong>成员方法</strong>：子类重写覆盖父类方法；父类引用指向子类对象时，调用子类重写的方法（多态）。</li></ul><hr><p><strong>24、方法重载和方法重写的区别</strong></p><ul><li><strong>重载（Overload）</strong>：同一类中，方法名相同，参数列表不同。</li><li><strong>重写（Override）</strong>：子类对父类方法进行改写，方法签名相同。</li></ul><hr><p><strong>25、package、import、class 的顺序关系</strong></p><ul><li>顺序必须是：<ul><li><code>package</code>（最多一个）</li><li><code>import</code>（可以多个）</li><li><code>class</code>（类定义）</li></ul></li></ul><hr><p><strong>26、四种权限修饰符</strong></p><table><thead><tr><th>修饰符</th><th>同类</th><th>同包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>protected</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>默认（不写）</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>private</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><hr><p><strong>27、final 特点</strong></p><ul><li><strong>类</strong>：不能被继承。</li><li><strong>方法</strong>：不能被重写。</li><li><strong>变量</strong>：值不能改变（常量）。</li></ul><hr><p><strong>28、static 的作用和特点</strong></p><ul><li><strong>作用</strong>：表示静态资源，属于类，不属于对象。</li><li><strong>特点</strong>：<ul><li>静态变量：所有对象共享。</li><li>静态方法：只能访问静态成员，不能访问 <code>this</code>。</li><li>静态代码块：类加载时执行一次。</li></ul></li></ul><hr><p><strong>29、静态代码块、构造代码块、构造方法的执行顺序和特点</strong></p><ul><li><strong>顺序</strong>：静态代码块（只执行一次） → 构造代码块（每次 new 执行） → 构造方法。</li><li><strong>特点</strong>：<ul><li>静态代码块：初始化类信息。</li><li>构造代码块：对象公共初始化逻辑。</li><li>构造方法：对象个性化初始化逻辑。</li></ul></li></ul><hr><p><strong>30、多态的前提</strong></p><ol><li>继承或实现关系。</li><li>子类重写父类方法。</li><li>父类引用指向子类对象。</li></ol><hr><p><strong>31、多态中的成员访问特点</strong></p><ul><li><strong>成员变量</strong>：编译看左边（父类），运行也看左边。</li><li><strong>成员方法</strong>：编译看左边（父类），运行看右边（子类，动态绑定）。</li><li><strong>静态方法</strong>：不具备多态性，编译和运行都看左边。</li></ul><hr><p><strong>32、抽象类的特点</strong></p><ul><li>用 <code>abstract</code> 修饰。</li><li>不能直接实例化。</li><li>可以有构造方法、成员变量、普通方法、抽象方法。</li></ul><hr><p><strong>33、抽象类的成员特点</strong></p><ul><li>成员变量：既可有普通变量，也可有常量。</li><li>构造方法：可以有。</li><li>成员方法：既可以有普通方法，也可以有抽象方法。</li></ul><hr><p><strong>34、接口中成员变量和成员方法的默认修饰符</strong></p><ul><li><strong>变量</strong>：<code>public static final</code>（常量）。</li><li><strong>方法（JDK8 之前）</strong>：<code>public abstract</code>。</li><li><strong>JDK8 新增</strong>：<code>default</code> 默认方法、<code>static</code> 静态方法。</li><li><strong>JDK9 新增</strong>：<code>private</code> 方法。</li></ul><hr><p><strong>35、接口的成员特点</strong></p><ul><li>只能包含常量和抽象方法（JDK8 之前）。</li><li>接口中的方法默认 <code>public abstract</code>，变量默认 <code>public static final</code>。</li><li>支持多继承。</li></ul><hr><p><strong>36、接口和抽象类的区别</strong></p><table><thead><tr><th>对比项</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>关键字</td><td><code>abstract class</code></td><td><code>interface</code></td></tr><tr><td>继承</td><td>单继承</td><td>多继承</td></tr><tr><td>成员变量</td><td>普通变量 + 常量</td><td>只能常量</td></tr><tr><td>成员方法</td><td>普通方法 + 抽象方法</td><td>默认抽象（JDK8+ 可有 default、static）</td></tr><tr><td>构造方法</td><td>可以有</td><td>不能有</td></tr></tbody></table><hr><p><strong>37、多态的三种方式</strong></p><ol><li><strong>继承 + 方法重写</strong></li><li><strong>接口实现</strong></li><li><strong>抽象类实现</strong></li></ol><hr><p><strong>38、内部类的分类</strong></p><ul><li>成员内部类（定义在类中，方法外）。</li><li>静态内部类（<code>static</code> 修饰）。</li><li>局部内部类（方法内部定义）。</li><li>匿名内部类（没有类名，直接创建实例）。</li></ul><hr><p><strong>39、匿名内部类的前提和本质</strong></p><ul><li><strong>前提</strong>：必须继承一个类或实现一个接口。</li><li><strong>本质</strong>：继承父类&#x2F;实现接口的子类匿名对象。</li></ul><hr><p><strong>40、Object 类中有哪些常见的方法</strong></p><ul><li><code>toString()</code>：返回对象字符串表示。</li><li><code>equals(Object obj)</code>：判断对象是否相等。</li><li><code>hashCode()</code>：返回对象哈希值。</li><li><code>clone()</code>：对象克隆（需实现 <code>Cloneable</code> 接口）。</li><li><code>finalize()</code>：垃圾回收前调用（已过时）。</li><li><code>getClass()</code>：获取运行时类对象。</li><li><code>wait()/notify()/notifyAll()</code>：线程通信。</li></ul><hr><p>好的 ✅<br> 那我接着帮你整理 <strong>41–67（集合 &amp; 源码机制）</strong> 的答案。</p><hr><h1 id="集合-源码机制"><a href="#集合-源码机制" class="headerlink" title="集合 &amp; 源码机制"></a>集合 &amp; 源码机制</h1><p><strong>41、Object类中的finalize方法的作用</strong></p><ul><li>在垃圾回收器回收对象之前调用，用于资源释放。</li><li>但不可靠，可能不会被调用（已被废弃）。</li></ul><hr><p><strong>42、Java中垃圾回收机制（gc方法）的原理</strong></p><ul><li><code>System.gc()</code> 只是<strong>建议</strong> JVM 进行 GC，真正是否执行由 JVM 决定。</li><li>垃圾回收机制通过可达性分析（GC Roots）判断对象是否存活。</li></ul><hr><p><strong>43、基本数据类型和包装类的对应关系</strong></p><ul><li>byte → Byte</li><li>short → Short</li><li>int → Integer</li><li>long → Long</li><li>float → Float</li><li>double → Double</li><li>char → Character</li><li>boolean → Boolean</li></ul><hr><p><strong>44、基本数据类型怎么转字符串？字符串怎么转基本数据类型？</strong></p><ul><li>基本类型 → 字符串：<code>String.valueOf(x)</code> 或 <code>x + &quot;&quot;</code>。</li><li>字符串 → 基本类型：<code>Integer.parseInt(&quot;123&quot;)</code>、<code>Double.parseDouble(&quot;3.14&quot;)</code> 等。</li></ul><hr><p><strong>45、length和length()、size()的区别</strong></p><ul><li><code>length</code>：数组长度。</li><li><code>length()</code>：字符串长度（<code>String</code> 的方法）。</li><li><code>size()</code>：集合大小（<code>List/Set/Map</code>）。</li></ul><hr><p><strong>46、String、StringBuffer、StringBuilder的区别</strong></p><ul><li><strong>String</strong>：不可变，每次修改生成新对象。</li><li><strong>StringBuffer</strong>：可变，线程安全（同步）。</li><li><strong>StringBuilder</strong>：可变，线程不安全，效率更高。</li></ul><hr><p><strong>47、编译期异常和运行期异常的区别</strong></p><ul><li>编译期异常（Checked Exception）：必须处理，否则编译不通过。例：IOException。</li><li>运行期异常（RuntimeException）：可不处理，运行时可能抛出。例：NullPointerException。</li></ul><hr><p><strong>48、try—catch和throws的区别</strong></p><ul><li><code>try-catch</code>：在方法内部捕获并处理异常。</li><li><code>throws</code>：在方法声明处抛出异常，交给调用者处理。</li></ul><hr><p><strong>49、throw和throws的区别</strong></p><ul><li><code>throw</code>：方法内部，抛出异常对象。</li><li><code>throws</code>：方法声明处，声明可能抛出的异常类型。</li></ul><hr><p><strong>50、设计模式的七大原则是什么</strong></p><ol><li>单一职责原则</li><li>开放封闭原则</li><li>里氏替换原则</li><li>接口隔离原则</li><li>依赖倒置原则</li><li>合成复用原则</li><li>迪米特法则</li></ol><hr><p><strong>51、Java中对方法的增强的方式有哪些</strong></p><ul><li>继承重写</li><li>装饰器模式</li><li>动态代理（JDK Proxy、CGLIB）</li><li>AOP（Spring 面向切面编程）</li></ul><hr><p><strong>52、集合和数组的区别是什么</strong></p><ul><li>数组：长度固定、存储单一数据类型。</li><li>集合：长度可变、存储对象，提供丰富的操作方法。</li></ul><hr><p><strong>53、在List集合中删除元素的注意事项</strong></p><ul><li>遍历时删除需注意：<ul><li>for-each 删除会抛 <code>ConcurrentModificationException</code>。</li><li>解决：用 <code>Iterator.remove()</code> 或 <code>ListIterator</code>。</li></ul></li></ul><hr><p><strong>54、ArrayList、LinkedList、Vector的区别</strong></p><ul><li>ArrayList：基于数组，查询快，增删慢，线程不安全。</li><li>LinkedList：基于双向链表，增删快，查询慢，线程不安全。</li><li>Vector：基于数组，线程安全（方法加 <code>synchronized</code>），效率低。</li></ul><hr><p><strong>55、ArrayList集合底层结构是什么</strong></p><ul><li>动态数组（<code>Object[]</code>）。</li></ul><hr><p><strong>56、ArrayList集合的扩容机制</strong></p><ul><li>初始容量：10。</li><li>每次扩容：<code>1.5 倍</code>（即 oldCapacity + oldCapacity &gt;&gt; 1）。</li></ul><hr><p><strong>57、HashSet、LinkedHashSet、TreeSet集合的底层结构</strong></p><ul><li>HashSet：基于 HashMap。</li><li>LinkedHashSet：基于 LinkedHashMap，保证插入顺序。</li><li>TreeSet：基于 TreeMap，红黑树实现，保证排序。</li></ul><hr><p><strong>58、HashSet集合是怎么保证元素唯一性的</strong></p><ul><li>底层依赖 HashMap 的 key 唯一性。</li><li>判断逻辑：先比较 <code>hashCode()</code>，再比较 <code>equals()</code>。</li></ul><hr><p><strong>59、TreeSet集合是怎么保证元素唯一性的</strong></p><ul><li>依赖元素的 <code>compareTo()</code> 或 <code>Comparator</code>。</li><li>比较结果为 0，认为元素相等，不会存入。</li></ul><hr><p><strong>60、可变参数的本质是什么</strong></p><ul><li>本质是一个数组。</li><li>方法内部把传入的参数打包成数组。</li></ul><hr><p><strong>61、HashMap集合的底层结构</strong></p><ul><li>JDK1.7：数组 + 链表。</li><li>JDK1.8：数组 + 链表 + 红黑树。</li></ul><hr><p><strong>62、HashMap集合的无参构造，在第一次添加元素的时候数组的初始大小</strong></p><ul><li>16（默认容量）。</li></ul><hr><p><strong>63、HashMap集合加载因子为什么是0.75</strong></p><ul><li>在时间和空间利用率之间的折中。</li><li>较低：浪费空间。</li><li>较高：冲突多，效率下降。</li></ul><hr><p><strong>64、HashMap集合中链表什么时候转红黑树</strong></p><ul><li>当链表长度 ≥ 8 且数组长度 ≥ 64 时，转为红黑树。</li></ul><hr><p><strong>65、HashMap集合中红黑树什么时候转链表</strong></p><ul><li>当红黑树节点数 ≤ 6 时，退化为链表。</li></ul><hr><p><strong>66、HashMap集合中数组的扩容为什么都是2的n次幂</strong></p><ul><li>计算下标时使用按位与（<code>(n - 1) &amp; hash</code>），比取余效率高。</li></ul><hr><p><strong>67、HashMap集合添加元素的时候，计算数组下标为什么不使用取余，而使用按位与</strong></p><ul><li>按位与比取余运算快。</li><li>需要数组长度为 2 的幂，保证 <code>(n - 1) &amp; hash</code> 等价于 <code>hash % n</code>。</li></ul><hr><p>好的 ✅<br> 那我接着帮你写 <strong>68–80（多线程与并发）</strong> 的详细答案。</p><hr><h1 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发</h1><p><strong>68、File 和 IO 的区别</strong></p><ul><li><code>File</code>：仅表示文件或目录的路径信息，不涉及读写内容。</li><li><code>IO</code>：真正执行输入&#x2F;输出操作的流，用于读写文件数据。</li></ul><hr><p><strong>69、flush 和 close 的区别</strong></p><ul><li><code>flush()</code>：强制将缓冲区数据写入目标，但流仍然可用。</li><li><code>close()</code>：先 <code>flush()</code>，再关闭流，流关闭后不能再使用。</li></ul><hr><p><strong>70、IO流中的相对路径和绝对路径</strong></p><ul><li><strong>绝对路径</strong>：从根目录开始，如 <code>C:/test/a.txt</code> 或 <code>/usr/local/a.txt</code>。</li><li><strong>相对路径</strong>：相对于项目的工作目录（<code>user.dir</code>），如 <code>./data/a.txt</code>。</li></ul><hr><p><strong>71、程序、进程、线程、协程的区别</strong></p><ul><li>程序：静态的代码集合。</li><li>进程：程序的一次执行，资源分配的最小单位。</li><li>线程：进程中的执行单元，CPU 调度的最小单位。</li><li>协程：用户态的轻量级线程，切换效率更高。</li></ul><hr><p><strong>72、并发和并行的区别</strong></p><ul><li>并发：一个 CPU 同时处理多个任务（宏观上同时，微观上切换）。</li><li>并行：多个 CPU 同时真正执行多个任务。</li></ul><hr><p><strong>73、run 和 start 的区别</strong></p><ul><li><code>run()</code>：普通方法调用，不会创建新线程。</li><li><code>start()</code>：启动一个新线程，由 JVM 调用 <code>run()</code> 方法。</li></ul><hr><p><strong>74、描述线程的生命周期</strong></p><ol><li><strong>新建（New）</strong>：创建 Thread 对象。</li><li><strong>就绪（Runnable）</strong>：调用 <code>start()</code>，等待 CPU 调度。</li><li><strong>运行（Running）</strong>：获得 CPU 执行 <code>run()</code> 方法。</li><li><strong>阻塞&#x2F;等待（Blocked&#x2F;Waiting&#x2F;Timed Waiting）</strong>：等待资源或超时等待。</li><li><strong>终止（Terminated）</strong>：线程执行完毕或异常结束。</li></ol><hr><p><strong>75、HashMap 和 Hashtable 的区别</strong></p><ul><li>HashMap：线程不安全，效率高，允许 <code>null</code> 键和值。</li><li>Hashtable：线程安全（方法加 <code>synchronized</code>），不允许 <code>null</code> 键或值。</li></ul><hr><p><strong>76、volatile 关键字的作用</strong></p><ul><li>保证 <strong>内存可见性</strong>：线程修改后，其他线程能立即看到。</li><li>禁止 <strong>指令重排序</strong>，保证一定有序性。</li><li>不保证 <strong>原子性</strong>。</li></ul><hr><p><strong>77、使用线程池的好处是什么</strong></p><ul><li>降低线程频繁创建&#x2F;销毁的开销。</li><li>控制并发线程数，防止资源耗尽。</li><li>统一管理线程，提高可扩展性和稳定性。</li></ul><hr><p><strong>78、ThreadPoolExecutor 的七大参数</strong></p><ol><li><code>corePoolSize</code>：核心线程数，常驻线程数。</li><li><code>maximumPoolSize</code>：最大线程数。</li><li><code>keepAliveTime</code>：非核心线程空闲存活时间。</li><li><code>unit</code>：时间单位。</li><li><code>workQueue</code>：任务队列。</li><li><code>threadFactory</code>：线程工厂（可自定义线程名）。</li><li><code>handler</code>：拒绝策略（丢弃、抛异常、调用者执行等）。</li></ol><hr><p><strong>79、ThreadPoolExecutor 线程池的工作原理</strong></p><ol><li>提交任务 → 判断运行线程数是否小于 <code>corePoolSize</code>，若是则创建线程执行。</li><li>否则 → 任务进入队列 <code>workQueue</code>。</li><li>队列满 → 若线程数 &lt; <code>maximumPoolSize</code>，创建非核心线程执行任务。</li><li>若已达最大线程数且队列满 → 执行拒绝策略。</li></ol><hr><p><strong>80、实现多线程的方式</strong></p><ol><li>继承 <code>Thread</code> 类，重写 <code>run()</code>。</li><li>实现 <code>Runnable</code> 接口，重写 <code>run()</code>。</li><li>实现 <code>Callable&lt;V&gt;</code> 接口，重写 <code>call()</code>，配合 <code>FutureTask</code>。</li><li>使用线程池 <code>ExecutorService</code> 提交任务。</li></ol><hr><p><strong>经典的线程通信案例——生产者消费者模式</strong>，使用 <strong><code>wait()</code> 和 <code>notify()</code></strong> 来实现线程通</p><hr><h1 id="生产者消费者案例"><a href="#生产者消费者案例" class="headerlink" title="生产者消费者案例"></a>生产者消费者案例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == MAX_COUNT) &#123;</span><br><span class="line">            wait(); <span class="comment">// 容量满，等待消费者消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 生产了产品，当前库存：&quot;</span> + count);</span><br><span class="line">        notifyAll(); <span class="comment">// 通知消费者可以消费</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            wait(); <span class="comment">// 库存空，等待生产者生产</span></span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 消费了产品，当前库存：&quot;</span> + count);</span><br><span class="line">        notifyAll(); <span class="comment">// 通知生产者可以生产</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.product = product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                product.produce();</span><br><span class="line">                Thread.sleep(<span class="number">500</span>); <span class="comment">// 模拟生产时间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.product = product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                product.consume();</span><br><span class="line">                Thread.sleep(<span class="number">800</span>); <span class="comment">// 模拟消费时间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(product), <span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(product), <span class="string">&quot;生产者2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(product), <span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(product), <span class="string">&quot;消费者2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer1.start();</span><br><span class="line">        producer2.start();</span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="核心点解析"><a href="#核心点解析" class="headerlink" title="核心点解析"></a>核心点解析</h2><ol><li><strong>共享资源</strong>：<code>Product</code> 类中的 <code>count</code> 表示库存。</li><li><strong>同步机制</strong>：<code>synchronized</code> 确保同一时间只有一个线程访问资源。</li><li><strong>线程通信</strong>：<ul><li><code>wait()</code>：线程等待，释放锁，进入等待队列。</li><li><code>notifyAll()</code>：唤醒等待线程，让其重新竞争锁。</li></ul></li><li><strong>生产&#x2F;消费逻辑</strong>：<ul><li>当库存满时，生产者阻塞等待。</li><li>当库存空时，消费者阻塞等待。</li></ul></li></ol><hr><p>这个案例是面试中非常经典的 <strong>多线程通信问题</strong>，可以扩展为 <strong>阻塞队列 <code>BlockingQueue</code> 版本</strong>，效率更高且无需手动管理 <code>wait/notify</code>。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Linux </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go</title>
      <link href="/2025/09/22/go/"/>
      <url>/2025/09/22/go/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="一、Go-基础语法"><a href="#一、Go-基础语法" class="headerlink" title="一、Go 基础语法"></a>一、Go 基础语法</h2><ol><li><p><strong>Go 的主要特点有哪些？</strong></p><ul><li>静态类型、编译型、并发原生支持（goroutine + channel）、内存安全、垃圾回收、跨平台、语法简洁。</li></ul></li><li><p><strong>Go 有哪些内置基本数据类型？</strong></p><ul><li>整型：<code>int8, int16, int32, int64, int</code></li><li>无符号整型：<code>uint8(byte), uint16, uint32, uint64, uint</code></li><li>浮点型：<code>float32, float64</code></li><li>复数：<code>complex64, complex128</code></li><li>字符：<code>rune</code></li><li>布尔：<code>bool</code></li><li>字符串：<code>string</code></li></ul></li><li><p><strong>Go 变量声明方式？</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">c := <span class="number">30</span>  <span class="comment">// 短变量声明</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Go 常量和 iota 的作用？</strong></p><ul><li><code>const</code> 定义常量。</li><li><code>iota</code> 是常量计数器，用于枚举。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    A = <span class="literal">iota</span>  <span class="comment">// 0</span></span><br><span class="line">    B         <span class="comment">// 1</span></span><br><span class="line">    C         <span class="comment">// 2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>字符串在 Go 中是可变的吗？</strong></p><ul><li>不可变。修改字符串必须转成 <code>[]byte</code> 或 <code>[]rune</code>。</li></ul></li></ol><hr><h2 id="二、Go-容器类型"><a href="#二、Go-容器类型" class="headerlink" title="二、Go 容器类型"></a>二、Go 容器类型</h2><ol><li><strong>切片 (slice) 和数组 (array) 区别？</strong><ul><li>数组：长度固定，值类型。</li><li>切片：基于数组实现，长度可变，引用类型。</li></ul></li><li><strong>map 的特点？</strong><ul><li>哈希表实现，<code>map[key]value</code>。</li><li>key 必须可比较（不能是 slice、map、function）。</li><li>访问不存在的 key 返回零值。</li></ul></li><li><strong>range 的返回值？</strong><ul><li>遍历 slice&#x2F;array：返回 index 和 value。</li><li>遍历 map：返回 key 和 value。</li><li>遍历 string：返回索引和 rune。</li></ul></li></ol><hr><h2 id="三、函数与方法"><a href="#三、函数与方法" class="headerlink" title="三、函数与方法"></a>三、函数与方法</h2><ol><li><strong>Go 支持函数重载吗？</strong><ul><li>不支持。</li></ul></li><li><strong>defer 的执行顺序？</strong></li></ol><ul><li><strong>后进先出 (LIFO)</strong>。</li></ul><ol><li><strong>值传递 vs 引用传递？</strong></li></ol><ul><li>Go 所有参数都是值传递。</li><li>传引用类型（slice、map、channel、指针）时，值里存的是底层数据地址。</li></ul><hr><h2 id="四、结构体与接口"><a href="#四、结构体与接口" class="headerlink" title="四、结构体与接口"></a>四、结构体与接口</h2><ol><li><strong>结构体和类的区别？</strong></li></ol><ul><li>Go 没有类，只有结构体（struct）。</li><li>没有继承，支持组合。</li></ul><ol><li><strong>Go 的接口特点？</strong></li></ol><ul><li>隐式实现，无需显式 <code>implements</code>。</li><li>接口是方法集合，零值是 <code>nil</code>。</li></ul><ol><li><strong>空接口 <code>interface&#123;&#125;</code> 的作用？</strong></li></ol><ul><li>可存放任意类型，相当于 Java 的 <code>Object</code>。</li></ul><hr><h2 id="五、并发与协程"><a href="#五、并发与协程" class="headerlink" title="五、并发与协程"></a>五、并发与协程</h2><ol><li><strong>goroutine 是什么？</strong></li></ol><ul><li>Go 的轻量级线程，由 Go runtime 调度。比 OS 线程更轻。</li></ul><ol><li><strong>channel 的作用？</strong></li></ol><ul><li>在 goroutine 之间安全传递数据。</li><li>支持无缓冲、有缓冲。</li></ul><ol><li><strong>select 的作用？</strong></li></ol><ul><li>多路复用，用于监听多个 channel。</li></ul><hr><h2 id="六、内存与-GC"><a href="#六、内存与-GC" class="headerlink" title="六、内存与 GC"></a>六、内存与 GC</h2><ol><li><strong>Go 的垃圾回收机制？</strong></li></ol><ul><li>三色标记 + 混合写屏障。</li></ul><ol><li><strong>make 和 new 的区别？</strong></li></ol><ul><li><code>new(T)</code> 分配内存，返回指针，零值初始化。</li><li><code>make</code> 用于 slice、map、chan 初始化，返回对象。</li></ul><ol><li><strong>逃逸分析 (escape analysis) 是什么？</strong></li></ol><ul><li>编译器决定变量分配在栈还是堆。</li></ul><hr><h2 id="七、常见陷阱题"><a href="#七、常见陷阱题" class="headerlink" title="七、常见陷阱题"></a>七、常见陷阱题</h2><ol><li><strong>for range 遍历 slice 时修改值会怎样？</strong></li></ol><ul><li>修改循环变量不会影响原切片，要用索引操作。</li></ul><ol><li><strong>nil slice 和空 slice 区别？</strong></li></ol><ul><li><code>nil slice</code>：<code>var s []int</code>，<code>len=0, cap=0</code>。</li><li><code>空 slice</code>：<code>s := []int&#123;&#125;</code>，<code>len=0, cap=0</code>，但非 nil。</li></ul><ol><li><strong>map 并发读写会怎样？</strong></li></ol><ul><li>直接 panic，需要 <code>sync.Map</code> 或加锁。</li></ul><ol><li><strong>defer 在 return 前还是后执行？</strong></li></ol><ul><li><strong>在 return 之后，但返回值赋值之前</strong>。</li></ul><hr><h2 id="八、标准库与实践"><a href="#八、标准库与实践" class="headerlink" title="八、标准库与实践"></a>八、标准库与实践</h2><ol><li><strong>常见 Go 标准库？</strong></li></ol><ul><li><code>fmt</code>：格式化 I&#x2F;O</li><li><code>net/http</code>：HTTP 服务</li><li><code>sync</code>：并发同步</li><li><code>time</code>：时间操作</li><li><code>os</code>、<code>io</code>、<code>bufio</code>：文件操作</li></ul><ol><li><strong>Go 如何处理错误？</strong></li></ol><ul><li>使用 <code>error</code> 接口，返回值明确错误。</li><li>不支持异常捕获，只有 <code>panic/recover</code>。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要点提纲</title>
      <link href="/2025/09/22/%E6%80%BB%E7%BB%93/"/>
      <url>/2025/09/22/%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="要点提纲"><a href="#要点提纲" class="headerlink" title="要点提纲"></a>要点提纲</h1><h2 id="1-网络"><a href="#1-网络" class="headerlink" title="1. 网络"></a>1. 网络</h2><h3 id="1-1-OSI-七层模型"><a href="#1-1-OSI-七层模型" class="headerlink" title="1.1 OSI 七层模型"></a>1.1 OSI 七层模型</h3><ul><li>物理层：比特流传输，网线、光纤、网卡。</li><li>数据链路层：成帧、MAC 地址、交换机、以太网协议。</li><li>网络层：IP 地址、子网、路由、ICMP、ARP。</li><li>传输层：TCP（可靠，面向连接）、UDP（无连接、不可靠，低延迟）。</li><li>会话层：建立、管理、终止会话。</li><li>表示层：数据表示、加密解密（SSL&#x2F;TLS）、编码（Unicode）。</li><li>应用层：HTTP、HTTPS、FTP、DNS、SMTP、SSH。</li></ul><h3 id="1-2-TCP-IP-四层模型"><a href="#1-2-TCP-IP-四层模型" class="headerlink" title="1.2 TCP&#x2F;IP 四层模型"></a>1.2 TCP&#x2F;IP 四层模型</h3><ul><li>网络接口层：驱动、网卡、MAC。</li><li>网络层：IP、ICMP。</li><li>传输层：TCP、UDP。</li><li>应用层：HTTP、DNS、SMTP。</li></ul><h3 id="1-3-TCP-机制"><a href="#1-3-TCP-机制" class="headerlink" title="1.3 TCP 机制"></a>1.3 TCP 机制</h3><ul><li>三次握手：SYN、SYN+ACK、ACK → 同步序列号，建立可靠连接。</li><li>四次挥手：FIN&#x2F;ACK → 关闭通道，TIME_WAIT 等待 2MSL。</li><li>状态机：SYN_SENT、ESTABLISHED、FIN_WAIT、CLOSE_WAIT、TIME_WAIT。</li><li>拥塞控制：慢启动、拥塞避免、快重传、快恢复。</li><li>流量控制：滑动窗口。</li><li>常见问题：粘包&#x2F;拆包、SYN 攻击。</li></ul><h3 id="1-4-UDP"><a href="#1-4-UDP" class="headerlink" title="1.4 UDP"></a>1.4 UDP</h3><ul><li>无连接、无重传，适合实时通信（视频、语音、DNS）。</li></ul><h3 id="1-5-HTTPS-TLS"><a href="#1-5-HTTPS-TLS" class="headerlink" title="1.5 HTTPS&#x2F;TLS"></a>1.5 HTTPS&#x2F;TLS</h3><ul><li>握手：证书验证、公钥交换、对称密钥协商。</li><li>TLS 版本：1.2、1.3（前向保密 PFS）。</li><li>证书链、CA、CRL&#x2F;OCSP。</li></ul><h3 id="1-6-常用网络工具"><a href="#1-6-常用网络工具" class="headerlink" title="1.6 常用网络工具"></a>1.6 常用网络工具</h3><ul><li>ping、traceroute、tcpdump、wireshark、ss、netstat、iftop。</li></ul><hr><h2 id="2-Linux"><a href="#2-Linux" class="headerlink" title="2. Linux"></a>2. Linux</h2><ul><li>常用命令：top、ps、df、du、netstat、ss、lsof、journalctl。</li><li>权限管理：rwx、chmod、chown、ACL、SUID&#x2F;SGID&#x2F;sticky bit。</li><li>进程管理：kill、jobs、fg、bg、nohup、tmux。</li><li>文件系统：ext4、inode、硬&#x2F;软链接、挂载。</li><li>IO 模型：阻塞、非阻塞、I&#x2F;O 多路复用（select、poll、epoll）。</li><li>网络排查：ping、tcpdump、iftop。</li><li>性能调优：ulimit、sysctl、内存管理、I&#x2F;O 调度。</li><li>systemd：systemctl、服务管理。</li><li>安全：SELinux、AppArmor。</li></ul><hr><h2 id="3-MySQL"><a href="#3-MySQL" class="headerlink" title="3. MySQL"></a>3. MySQL</h2><h3 id="3-1-慢查询优化"><a href="#3-1-慢查询优化" class="headerlink" title="3.1 慢查询优化"></a>3.1 慢查询优化</h3><ul><li>slow_query_log、EXPLAIN、performance_schema。</li></ul><h3 id="3-2-索引"><a href="#3-2-索引" class="headerlink" title="3.2 索引"></a>3.2 索引</h3><ul><li>B+ 树结构，聚簇索引 vs 非聚簇索引。</li><li>分类：主键、唯一、普通、组合（最左匹配）、全文索引。</li><li>覆盖索引 vs 回表。</li><li>失效场景：函数操作、隐式转换、like %xxx。</li></ul><h3 id="3-3-事务"><a href="#3-3-事务" class="headerlink" title="3.3 事务"></a>3.3 事务</h3><ul><li>ACID。</li><li>隔离级别：读未提交、读已提交、可重复读（默认）、串行化。</li><li>并发问题：脏读、不可重复读、幻读。</li><li>MVCC：undo log + read view + 隐藏列。</li></ul><h3 id="3-4-锁"><a href="#3-4-锁" class="headerlink" title="3.4 锁"></a>3.4 锁</h3><ul><li>表锁、行锁。</li><li>共享锁、排他锁。</li><li>间隙锁、Next-Key 锁。</li><li>乐观锁、悲观锁。</li></ul><h3 id="3-5-存储引擎"><a href="#3-5-存储引擎" class="headerlink" title="3.5 存储引擎"></a>3.5 存储引擎</h3><ul><li>InnoDB：事务、行锁、MVCC。</li><li>MyISAM：不支持事务，表锁，读快写慢。</li></ul><h3 id="3-6-日志"><a href="#3-6-日志" class="headerlink" title="3.6 日志"></a>3.6 日志</h3><ul><li>redo log：保证持久性。</li><li>undo log：回滚、MVCC。</li><li>binlog：主从复制、恢复。</li></ul><hr><h2 id="4-Java"><a href="#4-Java" class="headerlink" title="4. Java"></a>4. Java</h2><h3 id="4-1-基本类型与包装类"><a href="#4-1-基本类型与包装类" class="headerlink" title="4.1 基本类型与包装类"></a>4.1 基本类型与包装类</h3><ul><li>八种基本类型。</li><li>自动装箱&#x2F;拆箱，缓存范围（Integer -128~127）。</li></ul><h3 id="4-2-Object-类"><a href="#4-2-Object-类" class="headerlink" title="4.2 Object 类"></a>4.2 Object 类</h3><ul><li>equals、hashCode、toString、clone、wait&#x2F;notify。</li></ul><h3 id="4-3-String"><a href="#4-3-String" class="headerlink" title="4.3 String"></a>4.3 String</h3><ul><li>不可变性、String Pool。</li><li>StringBuilder vs StringBuffer。</li></ul><h3 id="4-4-异常"><a href="#4-4-异常" class="headerlink" title="4.4 异常"></a>4.4 异常</h3><ul><li>Checked vs Unchecked。</li><li>try-with-resources。</li></ul><h3 id="4-5-并发"><a href="#4-5-并发" class="headerlink" title="4.5 并发"></a>4.5 并发</h3><ul><li>synchronized、ReentrantLock、CAS、原子类。</li><li>ThreadLocal（内存泄漏风险）。</li><li>Thread、Runnable、Callable。</li><li>线程状态：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED。</li><li>线程池：ThreadPoolExecutor（核心数、最大数、队列、拒绝策略）。</li></ul><h3 id="4-6-集合"><a href="#4-6-集合" class="headerlink" title="4.6 集合"></a>4.6 集合</h3><ul><li>List：ArrayList（数组）、LinkedList（链表）。</li><li>Set：HashSet、TreeSet。</li><li>Map：HashMap（哈希表+红黑树）、LinkedHashMap、TreeMap。</li><li>并发集合：ConcurrentHashMap（CAS+分段锁）、CopyOnWriteArrayList。</li></ul><h3 id="4-7-JVM-内部结构"><a href="#4-7-JVM-内部结构" class="headerlink" title="4.7 JVM 内部结构"></a>4.7 JVM 内部结构</h3><ul><li>运行时内存区域：堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器。</li><li>类加载过程：加载、验证、准备、解析、初始化。</li><li>双亲委派模型：避免类冲突。</li><li>OOM 类型：<ul><li>Java heap space。</li><li>Metaspace。</li><li>StackOverflowError。</li><li>Direct buffer memory。</li></ul></li></ul><h3 id="4-8-GC（垃圾回收）"><a href="#4-8-GC（垃圾回收）" class="headerlink" title="4.8 GC（垃圾回收）"></a>4.8 GC（垃圾回收）</h3><ul><li>垃圾回收算法：引用计数、标记清除、标记整理、复制算法。</li><li>分代回收：新生代（Eden+Survivor）、老年代。</li><li>收集器：Serial、Parallel、CMS、G1、ZGC、Shenandoah。</li><li>Minor GC、Full GC。</li></ul><hr><h2 id="5-Web"><a href="#5-Web" class="headerlink" title="5. Web"></a>5. Web</h2><ul><li>HTTP：请求方法、状态码、Header。</li><li>HTTPS：TLS 加密。</li><li>Cookie、Session、Token。</li><li>RESTful API 设计。</li><li>跨域：CORS、JSONP。</li><li>缓存：Cache-Control、ETag、Last-Modified。</li><li>WebSocket、SSE、长轮询。</li></ul><hr><h2 id="6-框架"><a href="#6-框架" class="headerlink" title="6. 框架"></a>6. 框架</h2><h3 id="6-1-Spring"><a href="#6-1-Spring" class="headerlink" title="6.1 Spring"></a>6.1 Spring</h3><ul><li>IoC 容器、Bean 生命周期。</li><li>AOP：JDK 动态代理、CGLIB。</li><li>常用注解</li><li>原理</li><li>启动流程</li></ul><h3 id="6-2-Spring-Boot"><a href="#6-2-Spring-Boot" class="headerlink" title="6.2 Spring Boot"></a>6.2 Spring Boot</h3><ul><li>自动配置原理：@EnableAutoConfiguration。</li><li>Starter 模块化。</li><li>配置文件优先级。</li><li>Actuator：健康检查、监控。</li><li>常用注解</li><li>原理</li><li>启动流程</li></ul><h3 id="6-3-Spring-MVC"><a href="#6-3-Spring-MVC" class="headerlink" title="6.3 Spring MVC"></a>6.3 Spring MVC</h3><ul><li>DispatcherServlet 流程：HandlerMapping、HandlerAdapter、ViewResolver。</li><li>拦截器、异常处理。</li></ul><h3 id="6-4-MyBatis"><a href="#6-4-MyBatis" class="headerlink" title="6.4 MyBatis"></a>6.4 MyBatis</h3><ul><li>SQL 映射、动态 SQL。</li><li>一级缓存、二级缓存。</li><li>N+1 问题。</li></ul><hr><h2 id="7-分布式"><a href="#7-分布式" class="headerlink" title="7. 分布式"></a>7. 分布式</h2><h3 id="7-1-Spring-Cloud"><a href="#7-1-Spring-Cloud" class="headerlink" title="7.1 Spring Cloud"></a>7.1 Spring Cloud</h3><ul><li>服务注册发现：Eureka、Nacos。</li><li>负载均衡：Ribbon、Feign。</li><li>网关：Spring Cloud Gateway。</li><li>熔断限流：Hystrix、Sentinel。</li></ul><h3 id="7-2-分布式核心要点"><a href="#7-2-分布式核心要点" class="headerlink" title="7.2 分布式核心要点"></a>7.2 分布式核心要点</h3><ul><li>雪花算法：分布式唯一 ID。</li><li>JWT、OAuth2：无状态认证。</li><li>Redis：<ul><li>数据结构：String、Hash、List、Set、ZSet。</li><li>持久化：RDB、AOF。</li><li>集群：哨兵集群、完全集群。</li><li>分布式锁：SETNX+过期时间，Redisson。</li><li>缓存问题：穿透、击穿、雪崩。</li></ul></li><li>MQ：<ul><li>场景：削峰填谷、解耦、异步。</li><li>Kafka、RocketMQ、RabbitMQ。</li><li>消费语义：at-most-once、at-least-once、exactly-once。</li></ul></li><li>分布式事务：<ul><li>2PC、XA。</li><li>Saga、补偿。</li><li>Seata。</li></ul></li><li>CAP、BASE 理论。</li><li>一致性协调：Zookeeper、etcd。</li><li>可观测性：ELK、Prometheus、Grafana、Jaeger。</li></ul><hr><h2 id="8-运维-容器化"><a href="#8-运维-容器化" class="headerlink" title="8. 运维&#x2F;容器化"></a>8. 运维&#x2F;容器化</h2><ul><li>Docker：镜像、容器、Dockerfile。</li><li>Kubernetes：<ul><li>Pod、Deployment、Service、Ingress。</li><li>ConfigMap、Secret、StatefulSet。</li></ul></li><li>部署策略：滚动更新、蓝绿、金丝雀。</li><li>CI&#x2F;CD：Jenkins、GitLab CI、ArgoCD。</li><li>高可用：多 AZ、故障切换、自动伸缩。</li><li>监控与告警：SLO&#x2F;SLI&#x2F;SLA，Prometheus+Grafana。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2025/09/22/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2025/09/22/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题库</title>
      <link href="/2025/09/22/%E9%A2%98%E5%BA%93/"/>
      <url>/2025/09/22/%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="模块-1：网络"><a href="#模块-1：网络" class="headerlink" title="模块 1：网络"></a>模块 1：网络</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><h4 id="物理层（比特流传输，网线、光纤、网卡）"><a href="#物理层（比特流传输，网线、光纤、网卡）" class="headerlink" title="物理层（比特流传输，网线、光纤、网卡）"></a>物理层（比特流传输，网线、光纤、网卡）</h4><p><strong>题目 1（基础）</strong>：<br> 物理层的主要功能是什么？常见设备有哪些？</p><p><strong>答案</strong>：</p><ul><li>功能：在物理媒介上传输比特流（0&#x2F;1），实现数据的原始传输，不关心数据含义。</li><li>设备：网线（铜缆）、光纤、网卡、集线器、收发器。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 公司内网出现频繁掉线，怀疑是物理层问题，你会如何排查？</p><p><strong>答案</strong>：</p><ul><li>检查网线是否损坏或接触不良；</li><li>使用网线测试仪或更换线缆；</li><li>检查光纤接口是否有污染或折损；</li><li>查看网卡指示灯或更换网卡；</li><li>检查集线器&#x2F;交换机端口状态。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 物理层和数据链路层的主要区别是什么？</p><p><strong>答案</strong>：</p><ul><li>物理层：负责比特流传输，只关注信号，不处理数据含义；</li><li>数据链路层：负责成帧、MAC 地址寻址、差错检测，保证帧正确到达邻居节点。</li></ul><hr><h4 id="数据链路层（成帧、MAC-地址、交换机、以太网协议）"><a href="#数据链路层（成帧、MAC-地址、交换机、以太网协议）" class="headerlink" title="数据链路层（成帧、MAC 地址、交换机、以太网协议）"></a>数据链路层（成帧、MAC 地址、交换机、以太网协议）</h4><p><strong>题目 1（基础）</strong>：<br> 交换机是如何通过 MAC 地址转发数据的？</p><p><strong>答案</strong>：</p><ul><li>交换机维护 MAC 地址表，将端口和 MAC 地址对应；</li><li>帧到达交换机时查表决定转发端口，若未知则广播。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 内网出现广播风暴，网络拥堵，原因可能是什么？如何解决？</p><p><strong>答案</strong>：</p><ul><li>原因：交换机环路、MAC 表不完整导致频繁广播。</li><li>解决方案：启用 STP（生成树协议）、检查拓扑避免环路、划分 VLAN 减少广播域。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 以太网帧结构包含哪些字段？</p><p><strong>答案</strong>：</p><ul><li>前导码+帧头（同步）；</li><li>目的 MAC（6B）、源 MAC（6B）；</li><li>类型&#x2F;长度（2B）；</li><li>数据（46~1500B）；</li><li>CRC（4B）用于错误检测。</li></ul><hr><h4 id="网络层（IP-地址、子网、路由、ICMP、ARP）"><a href="#网络层（IP-地址、子网、路由、ICMP、ARP）" class="headerlink" title="网络层（IP 地址、子网、路由、ICMP、ARP）"></a>网络层（IP 地址、子网、路由、ICMP、ARP）</h4><p><strong>题目 1（基础）</strong>：<br> 网络层的主要功能是什么？</p><p><strong>答案</strong>：</p><ul><li>功能：为数据包选择路径和传输，进行逻辑地址寻址；</li><li>主要协议：IP、ICMP、ARP；</li><li>设备：路由器。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 用户无法访问某服务器，ping 不通，如何排查网络层问题？</p><p><strong>答案</strong>：</p><ul><li>检查本机 IP、子网掩码、默认网关；</li><li>使用 <strong>ping</strong> 测试本机、网关、目标 IP；</li><li>使用 <strong>traceroute</strong> 查看路由是否异常；</li><li>检查防火墙和路由策略。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> ARP 协议的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>ARP 用于将 IP 地址映射到 MAC 地址，实现局域网通信；</li><li>通过广播请求目标 IP 的 MAC，目标回复 MAC。</li></ul><hr><h4 id="传输层（TCP、UDP）"><a href="#传输层（TCP、UDP）" class="headerlink" title="传输层（TCP、UDP）"></a>传输层（TCP、UDP）</h4><p><strong>题目 1（基础）</strong>：<br> TCP 和 UDP 的区别是什么？</p><p><strong>答案</strong>：</p><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接</td><td>面向连接</td><td>无连接</td></tr><tr><td>可靠性</td><td>可靠传输</td><td>不可靠</td></tr><tr><td>传输方式</td><td>流式</td><td>数据报</td></tr><tr><td>应用</td><td>文件传输、HTTP</td><td>视频、语音、DNS</td></tr></tbody></table><p><strong>题目 2（场景题）</strong>：<br> 视频会议使用 UDP 而不是 TCP，为什么？</p><p><strong>答案</strong>：</p><ul><li>UDP 无连接、延迟低；</li><li>丢包不会触发重传，保证实时性；</li><li>TCP 重传可能导致延迟增加，影响视频流畅度。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> TCP 如何保证可靠传输？</p><p><strong>答案</strong>：</p><ul><li>三次握手建立连接；</li><li>序列号、确认号保证顺序与可靠性；</li><li>流量控制：滑动窗口；</li><li>拥塞控制：慢启动、拥塞避免、快重传、快恢复。</li></ul><hr><h4 id="会话层（建立、管理、终止会话）"><a href="#会话层（建立、管理、终止会话）" class="headerlink" title="会话层（建立、管理、终止会话）"></a>会话层（建立、管理、终止会话）</h4><p><strong>题目 1（基础）</strong>：<br> 会话层的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>建立、管理、终止应用间会话；</li><li>提供会话恢复、同步、对话控制。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 在长连接的聊天应用中，会话层出现问题可能导致什么？</p><p><strong>答案</strong>：</p><ul><li>会话无法正确建立 → 无法通信；</li><li>会话异常终止 → 消息丢失或重复；</li><li>解决方案：心跳包检测、会话重连机制。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 举例说明会话层协议。</p><p><strong>答案</strong>：</p><ul><li>PPTP、RPC、NetBIOS、SSL&#x2F;TLS（兼作表示层加密）。</li></ul><hr><h4 id="表示层（数据表示、加密解密、编码）"><a href="#表示层（数据表示、加密解密、编码）" class="headerlink" title="表示层（数据表示、加密解密、编码）"></a>表示层（数据表示、加密解密、编码）</h4><p><strong>题目 1（基础）</strong>：<br> 表示层的主要功能是什么？</p><p><strong>答案</strong>：</p><ul><li>数据表示、加密解密、编码转换；</li><li>常用协议：SSL&#x2F;TLS、Unicode、ASCII。</li></ul><p><strong>题目 2（场景题）</strong>：<br> HTTP 数据在网络上传输是明文还是加密？TLS 在表示层如何工作？</p><p><strong>答案</strong>：</p><ul><li>HTTP 明文传输，HTTPS 使用 TLS 加密；</li><li>TLS 握手交换公钥、协商对称密钥，建立加密通道；</li><li>表示层负责数据加密和解密。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 解释前向保密（PFS）是什么？</p><p><strong>答案</strong>：</p><ul><li>即使私钥泄露，也无法解密历史通信数据；</li><li>TLS1.3 默认支持 PFS，通过临时密钥保证安全。</li></ul><hr><h4 id="应用层（HTTP、HTTPS、FTP、DNS、SMTP、SSH）"><a href="#应用层（HTTP、HTTPS、FTP、DNS、SMTP、SSH）" class="headerlink" title="应用层（HTTP、HTTPS、FTP、DNS、SMTP、SSH）"></a>应用层（HTTP、HTTPS、FTP、DNS、SMTP、SSH）</h4><p><strong>题目 1（基础）</strong>：<br> 应用层协议有哪些？功能是什么？</p><p><strong>答案</strong>：</p><ul><li>HTTP&#x2F;HTTPS：网页传输；</li><li>FTP：文件传输；</li><li>DNS：域名解析；</li><li>SMTP：邮件发送；</li><li>SSH：远程登录。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 用户访问网页显示 404，说明了什么？</p><p><strong>答案</strong>：</p><ul><li>HTTP 状态码 404 → 请求的资源不存在；</li><li>可通过 URL 检查、服务器文件路径、虚拟主机配置排查。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> HTTPS 与 HTTP 的区别是什么？</p><p><strong>答案</strong>：</p><ul><li>HTTP 明文传输；</li><li>HTTPS 使用 TLS 加密，保证数据机密性、完整性和身份验证。</li></ul><h4 id="网络接口层（驱动、网卡、MAC）"><a href="#网络接口层（驱动、网卡、MAC）" class="headerlink" title="网络接口层（驱动、网卡、MAC）"></a>网络接口层（驱动、网卡、MAC）</h4><p><strong>题目 1（基础）</strong>：<br> 网络接口层的主要功能是什么？</p><p><strong>答案</strong>：</p><ul><li>功能：负责把数据从主机传到物理网络，处理网卡驱动、MAC 地址寻址。</li><li>设备：网卡、驱动程序。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 网卡被替换后，局域网无法访问，怀疑网络接口层问题，你如何排查？</p><p><strong>答案</strong>：</p><ul><li>检查网卡是否正确安装驱动；</li><li>确认 MAC 地址是否被禁用或冲突；</li><li>使用 <code>ifconfig</code> 或 <code>ip addr</code> 查看网卡状态；</li><li>测试物理连通性。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> MAC 地址在网络接口层的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>唯一标识网络接口设备；</li><li>局域网中用于帧的目的&#x2F;源地址寻址；</li><li>交换机根据 MAC 地址转发帧。</li></ul><hr><h4 id="网络层（IP、ICMP）"><a href="#网络层（IP、ICMP）" class="headerlink" title="网络层（IP、ICMP）"></a>网络层（IP、ICMP）</h4><p><strong>题目 1（基础）</strong>：<br> 网络层的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>功能：逻辑地址寻址、路由选择、数据包传输。</li><li>协议：IP、ICMP、ARP（局域网辅助）。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 用户无法访问外网，ping 路由器成功但 ping 外网失败，如何排查？</p><p><strong>答案</strong>：</p><ul><li>检查默认网关配置是否正确；</li><li>查看路由表（<code>route -n</code> 或 <code>ip route</code>）；</li><li>检查防火墙规则或 NAT 设置；</li><li>使用 <code>traceroute</code> 确认数据包到达路径。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> ICMP 的主要作用是什么？</p><p><strong>答案</strong>：</p><ul><li>网络诊断（如 <code>ping</code>）；</li><li>报告网络错误（目的不可达、超时等）；</li><li>帮助路由器控制数据流。</li></ul><hr><h4 id="传输层（TCP、UDP）-1"><a href="#传输层（TCP、UDP）-1" class="headerlink" title="传输层（TCP、UDP）"></a>传输层（TCP、UDP）</h4><p><strong>题目 1（基础）</strong>：<br> 传输层的功能是什么？</p><p><strong>答案</strong>：</p><ul><li>为应用提供端到端通信；</li><li>实现可靠传输（TCP）或低延迟传输（UDP）；</li><li>流量控制、端口寻址。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 同一台服务器同时运行 HTTP（TCP）和 DNS（UDP）服务，它们如何通过端口区分？</p><p><strong>答案</strong>：</p><ul><li>传输层通过 <strong>端口号</strong> 区分不同应用；</li><li>TCP HTTP 默认 80&#x2F;443，UDP DNS 默认 53；</li><li>内核根据四元组（源 IP&#x2F;端口 + 目的 IP&#x2F;端口 + 协议）区分流量。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> TCP 如何保证可靠传输？</p><p><strong>答案</strong>：</p><ul><li>三次握手建立连接；</li><li>序列号、确认号保证顺序；</li><li>滑动窗口进行流量控制；</li><li>拥塞控制：慢启动、拥塞避免、快重传、快恢复。</li></ul><hr><h3 id="TCP-机制"><a href="#TCP-机制" class="headerlink" title="TCP 机制"></a>TCP 机制</h3><h4 id="三次握手（SYN、SYN-ACK、ACK）"><a href="#三次握手（SYN、SYN-ACK、ACK）" class="headerlink" title="三次握手（SYN、SYN+ACK、ACK）"></a>三次握手（SYN、SYN+ACK、ACK）</h4><p><strong>题目 1（基础）</strong>：<br> TCP 三次握手的目的是什么？</p><p><strong>答案</strong>：</p><ul><li>建立可靠连接；</li><li>双方同步初始序列号；</li><li>确认通道可用。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 三次握手中客户端发送 SYN 但服务器未响应，可能原因是什么？</p><p><strong>答案</strong>：</p><ul><li>服务器端口未开启；</li><li>防火墙阻止 SYN 包；</li><li>网络丢包或路由问题；</li><li>SYN 攻击导致资源耗尽。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 三次握手与四次挥手的区别是什么？</p><p><strong>答案</strong>：</p><ul><li>三次握手用于建立连接，双方确认序列号；</li><li>四次挥手用于断开连接，双方确认数据已传输完毕，涉及 TIME_WAIT 状态。</li></ul><hr><h4 id="四次挥手（FIN-ACK、TIME-WAIT）"><a href="#四次挥手（FIN-ACK、TIME-WAIT）" class="headerlink" title="四次挥手（FIN&#x2F;ACK、TIME_WAIT）"></a>四次挥手（FIN&#x2F;ACK、TIME_WAIT）</h4><p><strong>题目 1（基础）</strong>：<br> TCP 四次挥手的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>正确关闭 TCP 连接；</li><li>确保双方数据传输完毕；</li><li>TIME_WAIT 防止旧报文干扰新连接。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 客户端关闭连接后一直处于 TIME_WAIT，这会影响服务器吗？</p><p><strong>答案</strong>：</p><ul><li>TIME_WAIT 会占用本地端口；</li><li>不会直接影响服务器，但大量短连接可能耗尽可用端口；</li><li>可通过缩短 TIME_WAIT 或复用端口优化。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> TCP 状态机中 CLOSE_WAIT、FIN_WAIT 的含义是什么？</p><p><strong>答案</strong>：</p><ul><li>CLOSE_WAIT：等待本端关闭连接（收到 FIN）；</li><li>FIN_WAIT：等待对端确认关闭连接。</li></ul><hr><h4 id="拥塞控制、流量控制"><a href="#拥塞控制、流量控制" class="headerlink" title="拥塞控制、流量控制"></a>拥塞控制、流量控制</h4><p><strong>题目 1（基础）</strong>：<br> TCP 拥塞控制包含哪些算法？</p><p><strong>答案</strong>：</p><ul><li>慢启动（Slow Start）；</li><li>拥塞避免（Congestion Avoidance）；</li><li>快重传（Fast Retransmit）；</li><li>快恢复（Fast Recovery）。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 大量并发用户下载文件，服务器出现拥塞，TCP 如何缓解？</p><p><strong>答案</strong>：</p><ul><li>慢启动限制初始发送窗口；</li><li>拥塞避免算法动态调整窗口大小；</li><li>快重传+快恢复减少丢包重传延迟；</li><li>流量控制（滑动窗口）防止接收端过载。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 流量控制与拥塞控制的区别是什么？</p><p><strong>答案</strong>：</p><ul><li>流量控制：接收端控制发送端，保证接收端不溢出；</li><li>拥塞控制：网络控制，防止过多报文导致网络拥塞。</li></ul><hr><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p><strong>题目 1（基础）</strong>：<br> UDP 的特点是什么？</p><p><strong>答案</strong>：</p><ul><li>无连接、不可靠；</li><li>无序到达、无重传；</li><li>低延迟，适合实时通信。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 在线直播使用 UDP，如果出现丢包，该怎么办？</p><p><strong>答案</strong>：</p><ul><li>丢包不重传保证实时性；</li><li>使用前向纠错（FEC）或应用层重传部分关键帧；</li><li>使用 QoS 优化网络优先级。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> UDP 如何区分不同应用？</p><p><strong>答案</strong>：</p><ul><li>通过 <strong>源端口和目的端口</strong>；</li><li>内核使用四元组（源 IP&#x2F;端口 + 目的 IP&#x2F;端口 + 协议）区分不同数据流。</li></ul><hr><h3 id="HTTPS-TLS"><a href="#HTTPS-TLS" class="headerlink" title="HTTPS&#x2F;TLS"></a>HTTPS&#x2F;TLS</h3><h3 id="握手、证书、加密"><a href="#握手、证书、加密" class="headerlink" title="握手、证书、加密"></a>握手、证书、加密</h3><p><strong>题目 1（基础）</strong>：<br> HTTPS 与 HTTP 的区别是什么？</p><p><strong>答案</strong>：</p><ul><li>HTTP 明文传输；</li><li>HTTPS 在应用层使用 TLS 加密，保证机密性、完整性和身份验证。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 访问 HTTPS 网站时，浏览器提示证书不可信，可能原因是什么？</p><p><strong>答案</strong>：</p><ul><li>自签名证书；</li><li>CA 根证书未安装或过期；</li><li>中间证书链缺失；</li><li>域名与证书不匹配。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> TLS 握手流程简述。</p><p><strong>答案</strong>：</p><ol><li>客户端发 ClientHello，支持协议版本和加密套件；</li><li>服务端发 ServerHello，选择协议和套件，并发送证书；</li><li>客户端验证证书，生成预主密钥并加密发送；</li><li>双方生成会话密钥，完成握手；</li><li>加密通信开始。</li></ol><h3 id="TLS-版本与前向保密"><a href="#TLS-版本与前向保密" class="headerlink" title="TLS 版本与前向保密"></a>TLS 版本与前向保密</h3><p><strong>题目 1（基础）</strong>：<br> TLS1.3 相比 TLS1.2 有哪些改进？</p><p><strong>答案</strong>：</p><ul><li>简化握手，减少 RTT；</li><li>默认启用前向保密（PFS）；</li><li>弃用不安全加密算法（如 RC4、MD5）。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 攻击者获取服务器私钥，是否可以解密历史 HTTPS 会话？</p><p><strong>答案</strong>：</p><ul><li>TLS1.2+使用 PFS 或 TLS1.3：不能解密历史会话；</li><li>非 PFS 情况：可解密历史通信。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 证书链、CA、OCSP 的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>证书链验证身份的可信性；</li><li>CA 签发证书，保证合法性；</li><li>CRL&#x2F;OCSP 用于撤销检查，防止使用被吊销的证书。</li></ul><hr><h3 id="常用网络工具"><a href="#常用网络工具" class="headerlink" title="常用网络工具"></a>常用网络工具</h3><h4 id="ping、traceroute"><a href="#ping、traceroute" class="headerlink" title="ping、traceroute"></a>ping、traceroute</h4><p><strong>题目 1（基础）</strong>：<br> ping 命令的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>检测网络连通性；</li><li>测量往返时间（RTT）；</li><li>使用 ICMP 回显请求。</li></ul><p><strong>题目 2（场景题）</strong>：<br> ping 成功但网页访问失败，可能原因是什么？</p><p><strong>答案</strong>：</p><ul><li>HTTP&#x2F;HTTPS 服务未启动或端口被阻塞；</li><li>防火墙允许 ICMP、阻止 TCP；</li><li>DNS 解析失败。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> traceroute 的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>显示数据包经过的路由节点；</li><li>帮助定位网络延迟或故障点。</li></ul><hr><h4 id="tcpdump、wireshark"><a href="#tcpdump、wireshark" class="headerlink" title="tcpdump、wireshark"></a>tcpdump、wireshark</h4><p><strong>题目 1（基础）</strong>：<br> tcpdump 和 Wireshark 的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>抓包、分析网络流量；</li><li>tcpdump 命令行，Wireshark 图形化。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 用户访问 HTTP 网站超时，用 tcpdump 如何分析？</p><p><strong>答案</strong>：</p><ul><li>抓取客户端和服务器通信包；</li><li>检查 SYN&#x2F;ACK 是否正常返回；</li><li>检查是否有丢包、重传或拒绝连接。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> tcpdump 常用参数有哪些？</p><p><strong>答案</strong>：</p><ul><li><code>-i</code> 指定接口；</li><li><code>-n</code> 不解析域名；</li><li><code>-s</code> 指定抓包长度；</li><li><code>port</code> 或 <code>host</code> 过滤特定流量。</li></ul><hr><h4 id="ss、netstat、iftop"><a href="#ss、netstat、iftop" class="headerlink" title="ss、netstat、iftop"></a>ss、netstat、iftop</h4><p><strong>题目 1（基础）</strong>：<br> netstat 和 ss 有什么区别？</p><p><strong>答案</strong>：</p><ul><li>ss 更快、替代 netstat；</li><li>显示 TCP&#x2F;UDP 连接、监听端口、套接字状态；</li><li>支持高级过滤。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 服务器高负载时，如何用 iftop 排查流量？</p><p><strong>答案</strong>：</p><ul><li>iftop 实时显示网络带宽使用情况；</li><li>可按源&#x2F;目的 IP 排序，找到流量大户；</li><li>可结合 tcpdump 精细抓包分析。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> netstat&#x2F;ss 可以查看哪些信息？</p><p><strong>答案</strong>：</p><ul><li>本地和远端 IP&#x2F;端口；</li><li>TCP 状态（ESTABLISHED、TIME_WAIT）；</li><li>使用的程序 PID&#x2F;名称；</li><li>统计数据（包数、字节数）。</li></ul><hr><h2 id="模块-2：Linux"><a href="#模块-2：Linux" class="headerlink" title="模块 2：Linux"></a>模块 2：Linux</h2><h3 id="常用命令（top、ps、df、du、netstat、ss、lsof、journalctl）"><a href="#常用命令（top、ps、df、du、netstat、ss、lsof、journalctl）" class="headerlink" title="常用命令（top、ps、df、du、netstat、ss、lsof、journalctl）"></a>常用命令（top、ps、df、du、netstat、ss、lsof、journalctl）</h3><p><strong>题目 1（基础）</strong>：<br> <code>top</code> 命令显示了哪些关键指标？</p><p><strong>答案</strong>：</p><ul><li>CPU 使用率（us、sy、id、wa）；</li><li>内存使用情况（total、used、free、buffers&#x2F;cache）；</li><li>进程信息（PID、USER、%CPU、%MEM、COMMAND）；</li><li>负载平均值（load average）。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 服务器 CPU 占用过高，如何使用 <code>top</code> 和 <code>ps</code> 排查？</p><p><strong>答案</strong>：</p><ul><li><code>top</code> 查看占用 CPU 高的进程；</li><li><code>ps aux --sort=-%cpu</code> 查看 CPU 排名前几的进程；</li><li>结合 <code>lsof</code> 查看进程打开的文件；</li><li>判断是否为异常进程或应用逻辑问题。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> <code>df</code> 与 <code>du</code> 的区别是什么？</p><p><strong>答案</strong>：</p><ul><li><code>df</code> 显示文件系统剩余空间（按分区统计）；</li><li><code>du</code> 显示目录或文件占用的实际空间；</li><li><code>df</code> 查看磁盘整体使用，<code>du</code> 查看具体目录。</li></ul><hr><h3 id="权限管理（rwx、chmod、chown、ACL、SUID-SGID-sticky-bit）"><a href="#权限管理（rwx、chmod、chown、ACL、SUID-SGID-sticky-bit）" class="headerlink" title="权限管理（rwx、chmod、chown、ACL、SUID&#x2F;SGID&#x2F;sticky bit）"></a>权限管理（rwx、chmod、chown、ACL、SUID&#x2F;SGID&#x2F;sticky bit）</h3><p><strong>题目 1（基础）</strong>：<br> Linux 文件权限 r、w、x 分别代表什么？</p><p><strong>答案</strong>：</p><ul><li>r：可读；</li><li>w：可写；</li><li>x：可执行；</li><li>权限分为 <strong>用户、用户组、其他</strong> 三类。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 用户 A 无法执行某脚本，文件权限显示 <code>-rw-r--r--</code>，如何解决？</p><p><strong>答案</strong>：</p><ul><li>脚本缺少执行权限；</li><li>使用 <code>chmod +x script.sh</code> 添加执行权限；</li><li>若需要指定特定用户或组执行，可使用 SUID&#x2F;SGID 或修改所有者。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> SUID、SGID 和 sticky bit 的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>SUID：执行文件时以文件所有者权限运行；</li><li>SGID：新建文件继承目录组或执行文件以文件组权限运行；</li><li>Sticky bit：目录下文件只能被所有者或 root 删除。</li></ul><hr><h3 id="进程管理（kill、jobs、fg、bg、nohup、tmux）"><a href="#进程管理（kill、jobs、fg、bg、nohup、tmux）" class="headerlink" title="进程管理（kill、jobs、fg、bg、nohup、tmux）"></a>进程管理（kill、jobs、fg、bg、nohup、tmux）</h3><p><strong>题目 1（基础）</strong>：<br> Linux 中如何查看所有进程？</p><p><strong>答案</strong>：</p><ul><li><code>ps aux</code> 显示所有进程；</li><li><code>top</code> 实时监控；</li><li><code>htop</code> 图形化显示（如安装）。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 后台运行的任务被意外终止，如何保证任务继续执行？</p><p><strong>答案</strong>：</p><ul><li>使用 <code>nohup command &amp;</code> 或 <code>disown</code>；</li><li>使用 <code>tmux</code> 或 <code>screen</code> 启动会话保持任务；</li><li>可通过 <code>jobs</code>、<code>fg</code>、<code>bg</code> 管理作业。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> kill 命令中不同信号作用是什么？</p><p><strong>答案</strong>：</p><ul><li><code>kill -9</code>：强制终止（不可捕获）；</li><li><code>kill -15</code>：正常终止，可捕获处理；</li><li><code>kill -HUP</code>：重新加载配置。</li></ul><hr><h3 id="文件系统（ext4、inode、硬-软链接、挂载）"><a href="#文件系统（ext4、inode、硬-软链接、挂载）" class="headerlink" title="文件系统（ext4、inode、硬&#x2F;软链接、挂载）"></a>文件系统（ext4、inode、硬&#x2F;软链接、挂载）</h3><p><strong>题目 1（基础）</strong>：<br> inode 在文件系统中的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>保存文件元数据（权限、所有者、时间戳、数据块地址）；</li><li>文件名存储在目录结构中与 inode 对应；</li><li>修改文件名不影响 inode。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 硬链接和软链接有什么区别？</p><p><strong>答案</strong>：</p><table><thead><tr><th>特性</th><th>硬链接</th><th>软链接</th></tr></thead><tbody><tr><td>指向对象</td><td>inode</td><td>文件路径</td></tr><tr><td>可跨文件系统</td><td>❌</td><td>✅</td></tr><tr><td>删除原文件</td><td>链接仍可访问数据</td><td>链接失效</td></tr></tbody></table><p><strong>题目 3（考点延伸）</strong>：<br> 如何挂载新磁盘并永久生效？</p><p><strong>答案</strong>：</p><ol><li>分区：<code>fdisk</code> 或 <code>parted</code>；</li><li>格式化：<code>mkfs.ext4 /dev/sdx1</code>；</li><li>临时挂载：<code>mount /dev/sdx1 /mnt</code>；</li><li>永久挂载：编辑 <code>/etc/fstab</code> 添加挂载信息。</li></ol><hr><h3 id="IO-模型（阻塞、非阻塞、I-O-多路复用）"><a href="#IO-模型（阻塞、非阻塞、I-O-多路复用）" class="headerlink" title="IO 模型（阻塞、非阻塞、I&#x2F;O 多路复用）"></a>IO 模型（阻塞、非阻塞、I&#x2F;O 多路复用）</h3><p><strong>题目 1（基础）</strong>：<br> Linux 中常见 IO 模型有哪些？</p><p><strong>答案</strong>：</p><ul><li>阻塞 IO：调用阻塞，等待完成；</li><li>非阻塞 IO：立即返回，需轮询；</li><li>I&#x2F;O 多路复用：<code>select</code>、<code>poll</code>、<code>epoll</code>；</li><li>信号驱动 IO、异步 IO（AIO）。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 高并发服务器使用阻塞 IO，会遇到什么问题？如何优化？</p><p><strong>答案</strong>：</p><ul><li>问题：线程&#x2F;进程数受限，CPU 利用率低，阻塞等待影响性能；</li><li>优化：使用 epoll 或异步 IO，实现单线程处理大量连接。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> epoll 相比 select 有哪些优势？</p><p><strong>答案</strong>：</p><ul><li>支持大量 fd（文件描述符）；</li><li>O(1) 查询事件；</li><li>支持水平触发（LT）和边缘触发（ET）；</li><li>减少内核&#x2F;用户空间复制开销。</li></ul><hr><h3 id="网络排查（ping、tcpdump、iftop）"><a href="#网络排查（ping、tcpdump、iftop）" class="headerlink" title="网络排查（ping、tcpdump、iftop）"></a>网络排查（ping、tcpdump、iftop）</h3><p><strong>题目 1（基础）</strong>：<br> ping 命令用于什么？</p><p><strong>答案</strong>：</p><ul><li>检测网络连通性；</li><li>测量延迟（RTT）；</li><li>使用 ICMP 回显请求。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 网络访问慢，如何用 iftop 和 tcpdump 排查？</p><p><strong>答案</strong>：</p><ul><li><code>iftop</code>：实时显示带宽使用情况，找出流量大 IP；</li><li><code>tcpdump</code>：抓取异常流量或丢包数据包；</li><li>分析网络瓶颈或异常连接。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> ss 和 netstat 的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>查看 TCP&#x2F;UDP 连接、监听端口；</li><li>查看套接字状态和对应进程 PID；</li><li>ss 更快，可替代 netstat。</li></ul><hr><h3 id="性能调优（ulimit、sysctl、内存管理、I-O-调度）"><a href="#性能调优（ulimit、sysctl、内存管理、I-O-调度）" class="headerlink" title="性能调优（ulimit、sysctl、内存管理、I&#x2F;O 调度）"></a>性能调优（ulimit、sysctl、内存管理、I&#x2F;O 调度）</h3><p><strong>题目 1（基础）</strong>：<br> <code>ulimit</code> 的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>限制用户进程资源：最大打开文件数、最大内存、最大进程数等；</li><li>可防止单用户消耗过多系统资源。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 高并发应用报 “Too many open files”，如何解决？</p><p><strong>答案</strong>：</p><ul><li>增加用户文件描述符限制：<code>ulimit -n 65535</code>；</li><li>修改 <code>/etc/security/limits.conf</code> 永久生效；</li><li>检查应用是否正确关闭文件。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> Linux I&#x2F;O 调度器有哪些？如何选择？</p><p><strong>答案</strong>：</p><ul><li>cfq：适合桌面系统；</li><li>deadline：实时&#x2F;数据库系统；</li><li>noop： SSD 设备，最少调度；</li><li>可通过 <code>cat /sys/block/sda/queue/scheduler</code> 查看并切换。</li></ul><hr><h3 id="systemd（systemctl、服务管理）"><a href="#systemd（systemctl、服务管理）" class="headerlink" title="systemd（systemctl、服务管理）"></a>systemd（systemctl、服务管理）</h3><p><strong>题目 1（基础）</strong>：<br> <code>systemctl</code> 用于什么？</p><p><strong>答案</strong>：</p><ul><li>管理 systemd 服务：启动、停止、重启、状态查询；</li><li>管理开机启动项。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 某服务无法启动，日志提示依赖未满足，如何排查？</p><p><strong>答案</strong>：</p><ul><li>查看服务状态：<code>systemctl status service</code>；</li><li>查看依赖关系：<code>systemctl list-dependencies service</code>；</li><li>查看 journal 日志：<code>journalctl -u service</code>；</li><li>修复依赖或配置后重新启动。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> systemd 启动流程简述。</p><p><strong>答案</strong>：</p><ul><li>PID 1 启动 systemd；</li><li>读取 <code>/etc/systemd/system</code> 配置；</li><li>启动 target（类似 runlevel）；</li><li>按依赖顺序启动服务单元。</li></ul><hr><h3 id="安全（SELinux、AppArmor）"><a href="#安全（SELinux、AppArmor）" class="headerlink" title="安全（SELinux、AppArmor）"></a>安全（SELinux、AppArmor）</h3><p><strong>题目 1（基础）</strong>：<br> SELinux 的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>提供强制访问控制（MAC），限制进程对资源访问；</li><li>安全策略：enforcing、permissive、disabled。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 应用访问文件被拒绝，但权限正常，如何排查？</p><p><strong>答案</strong>：</p><ul><li>检查 SELinux 状态：<code>getenforce</code>；</li><li>查看审计日志 <code>/var/log/audit/audit.log</code>；</li><li>临时切换 permissive 或调整策略解决。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> AppArmor 与 SELinux 区别是什么？</p><p><strong>答案</strong>：</p><ul><li>SELinux：基于标签的强制访问控制，粒度更细；</li><li>AppArmor：基于路径控制，策略易于配置，但粒度相对粗；</li><li>SELinux 更复杂、AppArmor 更易上手。</li></ul><hr><p>好的，我们继续生成 <strong>模块 3：MySQL</strong> 的完整面试题库，每个小要点至少三题（基础题、场景题、考点延伸题），并给出详细解答。</p><hr><h2 id="模块-3：MySQL"><a href="#模块-3：MySQL" class="headerlink" title="模块 3：MySQL"></a>模块 3：MySQL</h2><h3 id="慢查询优化（slow-query-log、EXPLAIN、performance-schema）"><a href="#慢查询优化（slow-query-log、EXPLAIN、performance-schema）" class="headerlink" title="慢查询优化（slow_query_log、EXPLAIN、performance_schema）"></a>慢查询优化（slow_query_log、EXPLAIN、performance_schema）</h3><p><strong>题目 1（基础）</strong>：<br> 如何开启 MySQL 慢查询日志？</p><p><strong>答案</strong>：</p><ul><li>配置 <code>my.cnf</code>：</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/log/mysql/slow.log</span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">log_queries_not_using_indexes</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>启动后，记录执行时间超过 <code>long_query_time</code> 的 SQL；</li><li>可通过 <code>mysqldumpslow</code> 分析日志。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 查询执行很慢，如何定位瓶颈？</p><p><strong>答案</strong>：</p><ol><li>查看慢查询日志，找出耗时 SQL；</li><li>使用 <code>EXPLAIN SELECT ...</code> 查看执行计划（全表扫描、索引使用情况）；</li><li>使用 <code>performance_schema</code> 监控查询、锁、IO、等待事件；</li><li>针对慢查询优化：添加索引、改写 SQL、分表分库。</li></ol><p><strong>题目 3（考点延伸）</strong>：<br> <code>EXPLAIN</code> 输出中 key、type、rows 字段分别代表什么？</p><p><strong>答案</strong>：</p><ul><li>key：使用的索引；</li><li>type：访问类型（ALL、index、range、ref、eq_ref、const）；</li><li>rows：估计扫描行数；</li><li>通过这些信息判断是否全表扫描或索引失效。</li></ul><hr><h3 id="索引（B-树结构、聚簇索引-vs-非聚簇索引）"><a href="#索引（B-树结构、聚簇索引-vs-非聚簇索引）" class="headerlink" title="索引（B+ 树结构、聚簇索引 vs 非聚簇索引）"></a>索引（B+ 树结构、聚簇索引 vs 非聚簇索引）</h3><p><strong>题目 1（基础）</strong>：<br> InnoDB 默认索引结构是什么？</p><p><strong>答案</strong>：</p><ul><li>B+ 树；</li><li>主键索引为聚簇索引，数据和索引在一起存储；</li><li>辅助索引为非聚簇索引，叶子节点存主键。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 查询使用了索引但速度仍慢，可能原因是什么？</p><p><strong>答案</strong>：</p><ul><li>索引失效：函数操作、隐式类型转换、<code>like %xxx</code>；</li><li>数据分布不均衡导致索引选择不理想；</li><li>覆盖索引未命中，需要回表。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 聚簇索引和非聚簇索引的区别？</p><p><strong>答案</strong>：</p><table><thead><tr><th>特性</th><th>聚簇索引</th><th>非聚簇索引</th></tr></thead><tbody><tr><td>数据存储</td><td>叶子节点存数据</td><td>叶子节点存主键</td></tr><tr><td>查询效率</td><td>范围查询快</td><td>单值查询快</td></tr><tr><td>占用空间</td><td>较大</td><td>较小</td></tr></tbody></table><hr><h3 id="事务（ACID、隔离级别、并发问题、MVCC）"><a href="#事务（ACID、隔离级别、并发问题、MVCC）" class="headerlink" title="事务（ACID、隔离级别、并发问题、MVCC）"></a>事务（ACID、隔离级别、并发问题、MVCC）</h3><p><strong>题目 1（基础）</strong>：<br> MySQL 支持哪些事务隔离级别？</p><p><strong>答案</strong>：</p><ol><li>读未提交（Read Uncommitted）：可能脏读；</li><li>读已提交（Read Committed）：避免脏读，但可能不可重复读；</li><li>可重复读（Repeatable Read，默认）：避免脏读和不可重复读，但可能幻读；</li><li>串行化（Serializable）：完全避免并发问题，但性能最低。</li></ol><p><strong>题目 2（场景题）</strong>：<br> 两条并发事务读写同一行数据，出现不可重复读，如何解决？</p><p><strong>答案</strong>：</p><ul><li>设置事务隔离级别为可重复读或串行化；</li><li>使用锁（行锁）保证一致性；</li><li>使用 MVCC（InnoDB 默认）避免读阻塞。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> MVCC 的实现原理是什么？</p><p><strong>答案</strong>：</p><ul><li>利用 <strong>undo log</strong> 保存数据旧版本；</li><li><strong>read view</strong> 决定事务可见数据版本；</li><li>隐藏列存储事务 ID，保证快照读；</li><li>保证读写不阻塞，提高并发。</li></ul><hr><h3 id="锁（表锁、行锁、共享锁、排他锁、间隙锁、Next-Key-锁、乐观锁、悲观锁）"><a href="#锁（表锁、行锁、共享锁、排他锁、间隙锁、Next-Key-锁、乐观锁、悲观锁）" class="headerlink" title="锁（表锁、行锁、共享锁、排他锁、间隙锁、Next-Key 锁、乐观锁、悲观锁）"></a>锁（表锁、行锁、共享锁、排他锁、间隙锁、Next-Key 锁、乐观锁、悲观锁）</h3><p><strong>题目 1（基础）</strong>：<br> InnoDB 支持哪些锁类型？</p><p><strong>答案</strong>：</p><ul><li>行锁（Record Lock）、表锁；</li><li>共享锁（S）：可读但不可写；</li><li>排他锁（X）：读写都阻塞；</li><li>Next-Key 锁 &#x3D; 行锁 + 间隙锁（防止幻读）。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 大量更新出现死锁，如何排查并解决？</p><p><strong>答案</strong>：</p><ul><li>使用 <code>SHOW ENGINE INNODB STATUS\G</code> 查看死锁信息；</li><li>确认事务操作顺序一致，避免交叉锁；</li><li>对热点数据加索引，减少锁粒度；</li><li>考虑乐观锁（版本号）替代悲观锁。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 乐观锁与悲观锁的区别？</p><p><strong>答案</strong>：</p><ul><li>乐观锁：假设无冲突，通过版本号&#x2F;时间戳检查冲突，适合读多写少；</li><li>悲观锁：假设会冲突，先加锁，适合写多场景。</li></ul><hr><h3 id="存储引擎（InnoDB、MyISAM）"><a href="#存储引擎（InnoDB、MyISAM）" class="headerlink" title="存储引擎（InnoDB、MyISAM）"></a>存储引擎（InnoDB、MyISAM）</h3><p><strong>题目 1（基础）</strong>：<br> InnoDB 与 MyISAM 区别？</p><p><strong>答案</strong>：</p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>事务</td><td>支持</td><td>不支持</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td></tr><tr><td>MVCC</td><td>支持</td><td>不支持</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr></tbody></table><p><strong>题目 2（场景题）</strong>：<br> MyISAM 表频繁更新大表导致锁争用，如何优化？</p><p><strong>答案</strong>：</p><ul><li>改用 InnoDB 支持行锁；</li><li>分表分库降低单表压力；</li><li>优化索引减少全表扫描。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> InnoDB 事务日志有哪些？作用？</p><p><strong>答案</strong>：</p><ul><li><strong>redo log</strong>：保证持久性（Crash 恢复）；</li><li><strong>undo log</strong>：回滚事务，实现 MVCC；</li><li><strong>binlog</strong>：主从复制和数据恢复。</li></ul><hr><h3 id="日志（redo-log、undo-log、binlog）"><a href="#日志（redo-log、undo-log、binlog）" class="headerlink" title="日志（redo log、undo log、binlog）"></a>日志（redo log、undo log、binlog）</h3><p><strong>题目 1（基础）</strong>：<br> redo log 的作用是什么？</p><p><strong>答案</strong>：</p><ul><li>保证事务提交的持久性；</li><li>写入磁盘前采用预写日志（WAL），事务提交后再刷新数据页。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 数据库突然宕机，如何利用日志恢复？</p><p><strong>答案</strong>：</p><ul><li>利用 redo log 恢复已提交事务；</li><li>利用 undo log 回滚未提交事务；</li><li>binlog 可用于主从同步或点时间恢复。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> binlog 有哪些格式？</p><p><strong>答案</strong>：</p><ul><li><strong>STATEMENT</strong>：记录 SQL 语句，体积小，但可能出现不可重复执行问题；</li><li><strong>ROW</strong>：记录每行数据变化，精确但体积大；</li><li><strong>MIXED</strong>：混合模式，根据情况选择。</li></ul><hr><h2 id="模块-4：Java"><a href="#模块-4：Java" class="headerlink" title="模块 4：Java"></a>模块 4：Java</h2><h3 id="基本类型与包装类"><a href="#基本类型与包装类" class="headerlink" title="基本类型与包装类"></a>基本类型与包装类</h3><p><strong>题目 1（基础）</strong>：<br> Java 有哪八种基本数据类型及其包装类？</p><p><strong>答案</strong>：</p><table><thead><tr><th>类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p><strong>题目 2（场景题）</strong>：<br> <code>Integer a = 100; Integer b = 100;</code> <code>a == b</code> 是 true 还是 false？为什么？</p><p><strong>答案</strong>：</p><ul><li>true；</li><li>因为 JVM 缓存了 -128~127 的 Integer 对象；</li><li>超出范围则 <code>==</code> 比较不同对象引用返回 false。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 自动装箱&#x2F;拆箱可能带来哪些性能或空指针风险？</p><p><strong>答案</strong>：</p><ul><li>装箱：基本类型 → 包装类对象，增加对象创建开销；</li><li>拆箱：包装类 → 基本类型；</li><li>null 拆箱会抛出 NullPointerException。</li></ul><hr><h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><p><strong>题目 1（基础）</strong>：<br> Object 类常用方法有哪些？</p><p><strong>答案</strong>：</p><ul><li><code>equals()</code>：比较对象内容；</li><li><code>hashCode()</code>：返回对象哈希值；</li><li><code>toString()</code>：对象字符串表示；</li><li><code>clone()</code>：浅拷贝对象；</li><li><code>wait()</code>&#x2F;<code>notify()</code>&#x2F;<code>notifyAll()</code>：线程通信。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 两个对象 <code>a</code> 和 <code>b</code> 内容相同但 <code>a == b</code> 返回 false，如何让 <code>a.equals(b)</code> 返回 true？</p><p><strong>答案</strong>：</p><ul><li>重写 <code>equals()</code> 方法，按属性判断对象内容是否相等；</li><li>通常同时重写 <code>hashCode()</code> 保证哈希一致性。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> clone() 和深拷贝、浅拷贝区别？</p><p><strong>答案</strong>：</p><ul><li>浅拷贝：对象属性引用仍指向原对象；</li><li>深拷贝：对象属性也复制新对象；</li><li><code>clone()</code> 默认浅拷贝，需手动实现深拷贝。</li></ul><hr><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><strong>题目 1（基础）</strong>：<br> 为什么 String 是不可变对象？</p><p><strong>答案</strong>：</p><ul><li>String 存储在字符串常量池中；</li><li>通过不可变性保证线程安全；</li><li>修改操作会生成新对象，原对象不变。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 大量字符串拼接性能低，如何优化？</p><p><strong>答案</strong>：</p><ul><li>使用 <code>StringBuilder</code>（非线程安全，效率高）或 <code>StringBuffer</code>（线程安全，略慢）；</li><li>避免频繁生成临时 String 对象。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> StringPool 是如何工作的？</p><p><strong>答案</strong>：</p><ul><li>字符串常量池保存编译期确定的字符串；</li><li>相同字面量只存一份，节省内存；</li><li><code>new String(&quot;abc&quot;)</code> 会生成新对象，不在池中。</li></ul><hr><h3 id="异常（Checked-vs-Unchecked、try-with-resources）"><a href="#异常（Checked-vs-Unchecked、try-with-resources）" class="headerlink" title="异常（Checked vs Unchecked、try-with-resources）"></a>异常（Checked vs Unchecked、try-with-resources）</h3><p><strong>题目 1（基础）</strong>：<br> Checked 与 Unchecked 异常区别？</p><p><strong>答案</strong>：</p><ul><li>Checked：编译器检查，必须处理或抛出（如 IOException）；</li><li>Unchecked：运行时异常，不强制捕获（如 NullPointerException、ArrayIndexOutOfBoundsException）。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 如何保证文件操作后资源被正确关闭？</p><p><strong>答案</strong>：</p><ul><li>使用 <code>try-with-resources</code> 自动关闭实现 <code>AutoCloseable</code> 接口的资源；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 读文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目 3（考点延伸）</strong>：<br> 异常的传播机制是怎样的？</p><p><strong>答案</strong>：</p><ul><li>异常沿调用栈向上抛出；</li><li>捕获最接近的匹配 <code>catch</code> 块；</li><li>finally 块保证无论是否抛异常都执行资源释放。</li></ul><hr><h3 id="并发（synchronized、ReentrantLock、CAS、原子类、ThreadLocal、Thread、Runnable、Callable、线程池）"><a href="#并发（synchronized、ReentrantLock、CAS、原子类、ThreadLocal、Thread、Runnable、Callable、线程池）" class="headerlink" title="并发（synchronized、ReentrantLock、CAS、原子类、ThreadLocal、Thread、Runnable、Callable、线程池）"></a>并发（synchronized、ReentrantLock、CAS、原子类、ThreadLocal、Thread、Runnable、Callable、线程池）</h3><p><strong>题目 1（基础）</strong>：<br> synchronized 与 ReentrantLock 区别？</p><p><strong>答案</strong>：</p><table><thead><tr><th>特性</th><th>synchronized</th><th>ReentrantLock</th></tr></thead><tbody><tr><td>是否可重入</td><td>是</td><td>是</td></tr><tr><td>公平锁</td><td>不支持</td><td>支持</td></tr><tr><td>手动释放锁</td><td>否</td><td>是</td></tr><tr><td>支持条件变量</td><td>否</td><td>是（Condition）</td></tr></tbody></table><p><strong>题目 2（场景题）</strong>：<br> 多线程累加共享变量出现错误，如何解决？</p><p><strong>答案</strong>：</p><ul><li>使用 <code>synchronized</code> 或 <code>ReentrantLock</code> 保护共享变量；</li><li>使用 <code>AtomicInteger</code> 等原子类；</li><li>避免同时修改非线程安全对象。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> Thread、Runnable、Callable 的区别？</p><p><strong>答案</strong>：</p><ul><li>Thread：继承 Thread 类实现线程；</li><li>Runnable：实现接口，适合资源共享，不能返回值；</li><li>Callable：实现接口，可返回值并抛异常；</li><li>Runnable 可通过 <code>FutureTask</code> 转 Callable 使用。</li></ul><p><strong>题目 4（线程池）</strong>：<br> ThreadPoolExecutor 核心参数及作用？</p><p><strong>答案</strong>：</p><ul><li>corePoolSize：核心线程数；</li><li>maximumPoolSize：最大线程数；</li><li>keepAliveTime：空闲线程存活时间；</li><li>workQueue：任务队列；</li><li>RejectionPolicy：拒绝策略（Abort、CallerRuns、Discard、DiscardOldest）。</li></ul><hr><h3 id="集合（List、Set、Map、并发集合）"><a href="#集合（List、Set、Map、并发集合）" class="headerlink" title="集合（List、Set、Map、并发集合）"></a>集合（List、Set、Map、并发集合）</h3><p><strong>题目 1（基础）</strong>：<br> ArrayList 与 LinkedList 区别？</p><p><strong>答案</strong>：</p><table><thead><tr><th>特性</th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>底层结构</td><td>动态数组</td><td>双向链表</td></tr><tr><td>随机访问</td><td>O(1)</td><td>O(n)</td></tr><tr><td>插入删除</td><td>慢（数组搬移）</td><td>快（链表操作）</td></tr></tbody></table><p><strong>题目 2（场景题）</strong>：<br> HashMap 的 get() 方法能否判断 key 是否存在？</p><p><strong>答案</strong>：</p><ul><li>不能；因为 value 可能为 null；</li><li>使用 <code>containsKey()</code> 判断 key 是否存在。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> ConcurrentHashMap 如何保证线程安全？</p><p><strong>答案</strong>：</p><ul><li>Java 8 采用 <strong>CAS + 链表&#x2F;红黑树 + 分段锁</strong> 机制；</li><li>读操作无锁，写操作仅锁局部桶，提高并发性能；</li><li>避免全局锁。</li></ul><hr><h3 id="JVM-内部结构（运行时内存区域、类加载、双亲委派、OOM）"><a href="#JVM-内部结构（运行时内存区域、类加载、双亲委派、OOM）" class="headerlink" title="JVM 内部结构（运行时内存区域、类加载、双亲委派、OOM）"></a>JVM 内部结构（运行时内存区域、类加载、双亲委派、OOM）</h3><p><strong>题目 1（基础）</strong>：<br> JVM 堆和方法区区别？</p><p><strong>答案</strong>：</p><ul><li>堆：存对象实例，垃圾回收主要区域；</li><li>方法区（元空间）：存类元信息、静态变量、常量；</li><li>堆可调节大小，方法区可使用 Metaspace。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 出现 <code>java.lang.OutOfMemoryError: Metaspace</code>，可能原因及解决？</p><p><strong>答案</strong>：</p><ul><li>原因：类加载过多、内存泄漏（动态生成类未卸载）；</li><li>解决：增加 Metaspace 大小，检查类加载逻辑，避免动态类泄漏。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 双亲委派机制为什么重要？</p><p><strong>答案</strong>：</p><ul><li>保证核心类优先由父类加载器加载，避免类冲突；</li><li>防止加载不安全的自定义类覆盖核心类；</li><li>提高类加载安全性和稳定性。</li></ul><hr><h3 id="GC（垃圾回收）"><a href="#GC（垃圾回收）" class="headerlink" title="GC（垃圾回收）"></a>GC（垃圾回收）</h3><p><strong>题目 1（基础）</strong>：<br> 常见垃圾回收算法有哪些？</p><p><strong>答案</strong>：</p><ul><li>引用计数；</li><li>标记清除；</li><li>标记整理；</li><li>复制算法。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 新生代 Minor GC 和老年代 Full GC 的区别？</p><p><strong>答案</strong>：</p><ul><li>Minor GC：回收新生代对象，频繁、快速；</li><li>Full GC：回收整个堆（新生代 + 老年代），耗时长；</li><li>调优：控制对象存活时间，减少 Full GC。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> G1、CMS、ZGC、Shenandoah 各自特点？</p><p><strong>答案</strong>：</p><ul><li>CMS：并发标记清理，减少停顿；</li><li>G1：分代 + 区域化管理，控制停顿时间；</li><li>ZGC、Shenandoah：低延迟 GC，适合大内存应用。</li></ul><hr><h2 id="模块-5：Web"><a href="#模块-5：Web" class="headerlink" title="模块 5：Web"></a>模块 5：Web</h2><h3 id="HTTP（请求方法、状态码、Header）"><a href="#HTTP（请求方法、状态码、Header）" class="headerlink" title="HTTP（请求方法、状态码、Header）"></a>HTTP（请求方法、状态码、Header）</h3><p><strong>题目 1（基础）</strong>：<br> 常用 HTTP 请求方法有哪些？分别作用是什么？</p><p><strong>答案</strong>：</p><ul><li>GET：获取资源，不应有副作用；</li><li>POST：提交数据，可能创建或修改资源；</li><li>PUT：更新或创建资源；</li><li>DELETE：删除资源；</li><li>PATCH：部分更新资源；</li><li>HEAD：只获取响应头，不返回正文；</li><li>OPTIONS：获取支持的方法。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 浏览器请求页面返回 304 状态码，意味着什么？如何处理？</p><p><strong>答案</strong>：</p><ul><li>304 Not Modified：客户端缓存未过期，资源未修改；</li><li>浏览器直接使用缓存，减少带宽和加载时间；</li><li>通过 ETag 或 Last-Modified 进行缓存验证。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> HTTP 常用 Header 及作用？</p><p><strong>答案</strong>：</p><ul><li>请求头：<code>Content-Type</code>（请求类型）、<code>Authorization</code>（身份验证）、<code>Accept</code>（可接受类型）；</li><li>响应头：<code>Content-Type</code>、<code>Cache-Control</code>、<code>Set-Cookie</code>、<code>Location</code>（重定向）；</li><li>Header 用于控制缓存、安全、数据格式等。</li></ul><hr><h3 id="HTTPS（TLS-加密）"><a href="#HTTPS（TLS-加密）" class="headerlink" title="HTTPS（TLS 加密）"></a>HTTPS（TLS 加密）</h3><p><strong>题目 1（基础）</strong>：<br> HTTPS 与 HTTP 区别？</p><p><strong>答案</strong>：</p><ul><li>HTTPS 在 HTTP 基础上使用 TLS&#x2F;SSL 加密；</li><li>确保数据传输机密性、完整性、身份认证；</li><li>HTTPS 端口默认 443，HTTP 端口 80。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 浏览器访问 HTTPS 页面提示证书错误，可能原因？</p><p><strong>答案</strong>：</p><ul><li>证书过期；</li><li>证书不被信任（非 CA 签发）；</li><li>域名不匹配；</li><li>证书链不完整。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> TLS 握手流程简述。</p><p><strong>答案</strong>：</p><ol><li>客户端发起握手，发送支持的加密套件；</li><li>服务端返回证书及选定加密套件；</li><li>客户端验证证书，生成对称密钥并加密发送；</li><li>服务端解密，握手完成，双方使用对称密钥加密数据。</li></ol><hr><h3 id="Cookie、Session、Token"><a href="#Cookie、Session、Token" class="headerlink" title="Cookie、Session、Token"></a>Cookie、Session、Token</h3><p><strong>题目 1（基础）</strong>：<br> Cookie 与 Session 区别？</p><p><strong>答案</strong>：</p><table><thead><tr><th>特性</th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td>存储位置</td><td>客户端</td><td>服务器</td></tr><tr><td>容量限制</td><td>小（4KB）</td><td>较大（服务器内存）</td></tr><tr><td>安全性</td><td>容易被篡改</td><td>相对安全</td></tr><tr><td>生命周期</td><td>可设置过期</td><td>默认会话结束清除</td></tr></tbody></table><p><strong>题目 2（场景题）</strong>：<br> 实现用户登录状态保持有哪些方式？</p><p><strong>答案</strong>：</p><ul><li>Cookie + Session：服务器存储 Session，客户端保存 SessionID；</li><li>JWT（Token）：无状态认证，客户端存储 Token，每次请求携带验证；</li><li>Redis 保存 Token，提高分布式场景一致性。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> Token 相比 Session 的优势？</p><p><strong>答案</strong>：</p><ul><li>无状态，易扩展分布式系统；</li><li>不依赖服务器内存；</li><li>支持自包含信息，减少数据库查询。</li></ul><hr><h3 id="RESTful-API-设计"><a href="#RESTful-API-设计" class="headerlink" title="RESTful API 设计"></a>RESTful API 设计</h3><p><strong>题目 1（基础）</strong>：<br> RESTful API 设计原则有哪些？</p><p><strong>答案</strong>：</p><ul><li>资源为中心（URI 表示资源）；</li><li>使用 HTTP 方法表示操作（GET、POST、PUT、DELETE）；</li><li>无状态请求；</li><li>返回合适 HTTP 状态码；</li><li>可使用 JSON&#x2F;XML 表示数据。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 设计用户管理接口，哪些 URL 和方法符合 RESTful 规范？</p><p><strong>答案</strong>：</p><table><thead><tr><th>操作</th><th>URL</th><th>方法</th></tr></thead><tbody><tr><td>查询用户</td><td>&#x2F;users&#x2F;{id}</td><td>GET</td></tr><tr><td>创建用户</td><td>&#x2F;users</td><td>POST</td></tr><tr><td>更新用户</td><td>&#x2F;users&#x2F;{id}</td><td>PUT</td></tr><tr><td>删除用户</td><td>&#x2F;users&#x2F;{id}</td><td>DELETE</td></tr></tbody></table><p><strong>题目 3（考点延伸）</strong>：<br> RESTful 与 RPC 风格 API 区别？</p><p><strong>答案</strong>：</p><ul><li>RESTful：以资源为中心，使用标准 HTTP 方法；</li><li>RPC：以动作或函数为中心，通常 POST 调用；</li><li>RESTful 易于缓存、可扩展，符合 Web 标准。</li></ul><hr><h3 id="跨域（CORS、JSONP）"><a href="#跨域（CORS、JSONP）" class="headerlink" title="跨域（CORS、JSONP）"></a>跨域（CORS、JSONP）</h3><p><strong>题目 1（基础）</strong>：<br> 什么是跨域请求？</p><p><strong>答案</strong>：</p><ul><li>浏览器同源策略限制不同域、协议或端口的请求访问资源；</li><li>跨域请求需特殊处理。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 前端请求跨域接口报错，如何解决？</p><p><strong>答案</strong>：</p><ul><li>CORS：服务端设置 <code>Access-Control-Allow-Origin</code> 等 Header；</li><li>JSONP：通过 <code>&lt;script&gt;</code> 标签请求跨域 GET 接口；</li><li>代理转发：前端请求同源接口，由后端转发到目标域。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> CORS 的简单请求与预检请求区别？</p><p><strong>答案</strong>：</p><ul><li>简单请求：GET&#x2F;POST（Content-Type 为 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain），直接发送；</li><li>预检请求：复杂请求（PUT、DELETE 或自定义 Header），浏览器先发 OPTIONS 请求确认。</li></ul><hr><h3 id="缓存（Cache-Control、ETag、Last-Modified）"><a href="#缓存（Cache-Control、ETag、Last-Modified）" class="headerlink" title="缓存（Cache-Control、ETag、Last-Modified）"></a>缓存（Cache-Control、ETag、Last-Modified）</h3><p><strong>题目 1（基础）</strong>：<br> HTTP 缓存机制有哪些？</p><p><strong>答案</strong>：</p><ul><li>强缓存：浏览器直接使用缓存，<code>Cache-Control</code> 或 <code>Expires</code>；</li><li>协商缓存：浏览器与服务器确认资源是否更新，<code>ETag</code>、<code>Last-Modified</code>。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 前端请求频繁导致服务器压力大，如何优化？</p><p><strong>答案</strong>：</p><ul><li>设置合理缓存策略，减少重复请求；</li><li>使用 ETag 或 Last-Modified 验证资源更新；</li><li>对静态资源 CDN 缓存加速。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> Cache-Control 指令常见有哪些？</p><p><strong>答案</strong>：</p><ul><li><code>no-cache</code>：必须向服务器验证；</li><li><code>no-store</code>：不缓存；</li><li><code>max-age</code>：最大缓存时间；</li><li><code>public</code>：可被共享缓存；</li><li><code>private</code>：只能被浏览器缓存。</li></ul><hr><h3 id="WebSocket、SSE、长轮询"><a href="#WebSocket、SSE、长轮询" class="headerlink" title="WebSocket、SSE、长轮询"></a>WebSocket、SSE、长轮询</h3><p><strong>题目 1（基础）</strong>：<br> WebSocket 与 HTTP 有何区别？</p><p><strong>答案</strong>：</p><ul><li>WebSocket：全双工通信，客户端和服务器可主动发送消息；</li><li>HTTP：请求-响应模式，客户端发起请求；</li><li>WebSocket 建立后可持续连接，减少轮询开销。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 实现实时聊天应用，如何选择通信方式？</p><p><strong>答案</strong>：</p><ul><li>需要高频率双向通信：WebSocket；</li><li>只需服务端推送，客户端偶尔获取：SSE；</li><li>无 WebSocket 支持，低频通信：长轮询。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 长轮询与 WebSocket 性能差异？</p><p><strong>答案</strong>：</p><ul><li>长轮询：每次请求结束立即重新发送，频繁 HTTP 建立连接，开销大；</li><li>WebSocket：一次连接可持续通信，CPU 和网络开销小；</li><li>高并发或低延迟场景推荐 WebSocket。</li></ul><hr><h2 id="模块-6：框架"><a href="#模块-6：框架" class="headerlink" title="模块 6：框架"></a>模块 6：框架</h2><h3 id="6-1-Spring（IoC-容器、Bean-生命周期、AOP）"><a href="#6-1-Spring（IoC-容器、Bean-生命周期、AOP）" class="headerlink" title="6.1 Spring（IoC 容器、Bean 生命周期、AOP）"></a>6.1 Spring（IoC 容器、Bean 生命周期、AOP）</h3><p><strong>题目 1（基础）</strong>：<br> Spring 的 IoC 容器是什么？</p><p><strong>答案</strong>：</p><ul><li>IoC（Inversion of Control，控制反转）：对象创建、依赖管理交给容器；</li><li>容器管理 Bean 的生命周期和依赖注入；</li><li>支持 XML、注解、JavaConfig 等配置方式。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 如何自定义 Bean 初始化和销毁方法？</p><p><strong>答案</strong>：</p><ul><li>方法一：在 <code>@Bean(initMethod=&quot;init&quot;, destroyMethod=&quot;destroy&quot;)</code> 中指定；</li><li>方法二：实现 <code>InitializingBean.afterPropertiesSet()</code> 和 <code>DisposableBean.destroy()</code>；</li><li>方法三：使用 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> Spring AOP 的实现原理？</p><p><strong>答案</strong>：</p><ul><li>JDK 动态代理：接口代理，生成代理对象实现接口；</li><li>CGLIB：继承目标类生成子类代理（非接口类）；</li><li>代理对象拦截方法调用，织入切面逻辑（Before、After、Around）。</li></ul><hr><h3 id="6-2-Spring-Boot（自动配置原理、Starter-模块、配置优先级、Actuator）"><a href="#6-2-Spring-Boot（自动配置原理、Starter-模块、配置优先级、Actuator）" class="headerlink" title="6.2 Spring Boot（自动配置原理、Starter 模块、配置优先级、Actuator）"></a>6.2 Spring Boot（自动配置原理、Starter 模块、配置优先级、Actuator）</h3><p><strong>题目 1（基础）</strong>：<br> Spring Boot 自动配置原理是什么？</p><p><strong>答案</strong>：</p><ul><li>通过 <code>@EnableAutoConfiguration</code> 注解触发；</li><li>根据类路径存在的依赖、条件注解（<code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>）自动创建 Bean；</li><li>避免手动繁琐配置，提高开发效率。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 同一个配置项在多个地方定义，Spring Boot 如何选择？</p><p><strong>答案</strong>：</p><ul><li>优先级：命令行 &gt; <code>application.yml</code>&#x2F;<code>application.properties</code> &gt; 外部配置文件 &gt; <code>@Value</code>&#x2F;<code>@ConfigurationProperties</code> 默认值；</li><li>Spring Boot 按顺序覆盖配置，确保灵活性。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> Spring Boot Actuator 能做什么？</p><p><strong>答案</strong>：</p><ul><li>健康检查 <code>/actuator/health</code>；</li><li>监控应用指标 <code>/actuator/metrics</code>；</li><li>查看环境变量 <code>/actuator/env</code>；</li><li>支持自定义端点，结合 Prometheus&#x2F;Grafana 可观测性。</li></ul><hr><h3 id="6-3-Spring-MVC（DispatcherServlet、拦截器、异常处理）"><a href="#6-3-Spring-MVC（DispatcherServlet、拦截器、异常处理）" class="headerlink" title="6.3 Spring MVC（DispatcherServlet、拦截器、异常处理）"></a>6.3 Spring MVC（DispatcherServlet、拦截器、异常处理）</h3><p><strong>题目 1（基础）</strong>：<br> Spring MVC 的请求处理流程？</p><p><strong>答案</strong>：</p><ol><li>请求到 <code>DispatcherServlet</code>；</li><li>根据 <code>HandlerMapping</code> 找到 Controller 方法；</li><li><code>HandlerAdapter</code> 执行方法；</li><li>返回 <code>ModelAndView</code>；</li><li><code>ViewResolver</code> 渲染视图；</li><li>返回响应给客户端。</li></ol><p><strong>题目 2（场景题）</strong>：<br> 需要在 Controller 执行前后做统一处理，比如日志或权限，如何实现？</p><p><strong>答案</strong>：</p><ul><li>使用 Spring MVC 拦截器 <code>HandlerInterceptor</code>；</li><li><code>preHandle</code> 前置处理，<code>postHandle</code> 后置处理，<code>afterCompletion</code> 请求完成处理；</li><li>可用于统一日志记录、权限校验、性能监控。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> Spring MVC 如何统一处理异常？</p><p><strong>答案</strong>：</p><ul><li>使用 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>；</li><li>也可继承 <code>ResponseEntityExceptionHandler</code>；</li><li>可返回统一错误响应 JSON，方便前端处理。</li></ul><hr><h3 id="6-4-MyBatis（SQL-映射、动态-SQL、缓存、N-1-问题）"><a href="#6-4-MyBatis（SQL-映射、动态-SQL、缓存、N-1-问题）" class="headerlink" title="6.4 MyBatis（SQL 映射、动态 SQL、缓存、N+1 问题）"></a>6.4 MyBatis（SQL 映射、动态 SQL、缓存、N+1 问题）</h3><p><strong>题目 1（基础）</strong>：<br> MyBatis 的核心功能是什么？</p><p><strong>答案</strong>：</p><ul><li>SQL 映射：Java 对象与数据库表对应；</li><li>动态 SQL：通过 <code>&lt;if&gt;</code>、<code>&lt;where&gt;</code> 等标签生成 SQL；</li><li>支持 XML 和注解方式配置；</li><li>支持一级缓存、二级缓存提高性能。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 查询用户及其订单列表出现 N+1 问题，如何优化？</p><p><strong>答案</strong>：</p><ul><li>使用关联查询（JOIN）减少 SQL 次数；</li><li>使用 <code>collection</code> 或 <code>association</code> 在 MyBatis 中一条 SQL 查询完成多表关联；</li><li>可通过批量查询再在内存组装数据。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> MyBatis 一级缓存和二级缓存区别？</p><p><strong>答案</strong>：</p><table><thead><tr><th>特性</th><th>一级缓存</th><th>二级缓存</th></tr></thead><tbody><tr><td>范围</td><td>SqlSession</td><td>Mapper&#x2F;namespace</td></tr><tr><td>生命周期</td><td>SqlSession 级别</td><td>Mapper 级别，可跨 SqlSession</td></tr><tr><td>默认开启</td><td>是</td><td>需配置 <code>&lt;cache/&gt;</code></td></tr></tbody></table><hr><p>好的，我们继续生成 <strong>模块 7：分布式</strong> 的完整面试题库，每个小要点至少三题（基础题、场景题、考点延伸题），并给出详细解答。</p><hr><h2 id="模块-7：分布式"><a href="#模块-7：分布式" class="headerlink" title="模块 7：分布式"></a>模块 7：分布式</h2><h3 id="7-1-Spring-Cloud（服务注册发现、负载均衡、网关、熔断限流）"><a href="#7-1-Spring-Cloud（服务注册发现、负载均衡、网关、熔断限流）" class="headerlink" title="7.1 Spring Cloud（服务注册发现、负载均衡、网关、熔断限流）"></a>7.1 Spring Cloud（服务注册发现、负载均衡、网关、熔断限流）</h3><p><strong>题目 1（基础）</strong>：<br> Spring Cloud 的服务注册与发现机制是什么？</p><p><strong>答案</strong>：</p><ul><li>使用 Eureka 或 Nacos 作为注册中心；</li><li>服务启动时注册自身信息（IP、端口、元数据）；</li><li>客户端通过服务名称查询可用实例，实现服务调用；</li><li>支持心跳检测，保证服务可用性。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 微服务调用经常出现实例不可用或延迟，如何优化？</p><p><strong>答案</strong>：</p><ul><li>使用 Ribbon 或 Feign 实现客户端负载均衡；</li><li>引入 Hystrix 或 Sentinel 实现熔断、降级、限流；</li><li>结合 Spring Cloud Gateway 做统一路由、限流；</li><li>监控服务健康状态，剔除不可用实例。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 负载均衡策略有哪些？</p><p><strong>答案</strong>：</p><ul><li>轮询（Round Robin）；</li><li>随机（Random）；</li><li>最小并发请求（Least Connections）；</li><li>权重轮询（Weighted Round Robin）；</li><li>Ribbon 默认支持多种策略，可自定义。</li></ul><hr><h3 id="7-2-分布式核心要点（雪花算法、JWT-OAuth2、Redis、MQ、分布式事务、CAP-BASE、一致性协调、可观测性）"><a href="#7-2-分布式核心要点（雪花算法、JWT-OAuth2、Redis、MQ、分布式事务、CAP-BASE、一致性协调、可观测性）" class="headerlink" title="7.2 分布式核心要点（雪花算法、JWT&#x2F;OAuth2、Redis、MQ、分布式事务、CAP&#x2F;BASE、一致性协调、可观测性）"></a>7.2 分布式核心要点（雪花算法、JWT&#x2F;OAuth2、Redis、MQ、分布式事务、CAP&#x2F;BASE、一致性协调、可观测性）</h3><h4 id="雪花算法（分布式唯一-ID）"><a href="#雪花算法（分布式唯一-ID）" class="headerlink" title="雪花算法（分布式唯一 ID）"></a>雪花算法（分布式唯一 ID）</h4><p><strong>题目 1（基础）</strong>：<br> 雪花算法生成 ID 原理是什么？</p><p><strong>答案</strong>：</p><ul><li>64 位二进制结构：1 位符号 + 41 位时间戳 + 10 位机器 ID + 12 位序列号；</li><li>高性能生成唯一、递增 ID，避免数据库瓶颈；</li><li>可支持分布式系统多节点生成。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 为什么需要雪花算法而不是自增 ID？</p><p><strong>答案</strong>：</p><ul><li>自增 ID 在多节点下会冲突，需要数据库集中管理；</li><li>雪花算法分布式生成，无需依赖中心 DB，性能高；</li><li>支持水平扩展。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 雪花算法生成的 ID 可能存在问题吗？</p><p><strong>答案</strong>：</p><ul><li>系统时间回退可能导致重复 ID；</li><li>序列号溢出需等待下一毫秒；</li><li>需保证机器 ID 唯一，否则可能重复。</li></ul><hr><h4 id="JWT-OAuth2（无状态认证）"><a href="#JWT-OAuth2（无状态认证）" class="headerlink" title="JWT &#x2F; OAuth2（无状态认证）"></a>JWT &#x2F; OAuth2（无状态认证）</h4><p><strong>题目 1（基础）</strong>：<br> JWT 有哪三个部分？</p><p><strong>答案</strong>：</p><ul><li>Header：算法类型、Token 类型；</li><li>Payload：用户信息、过期时间等；</li><li>Signature：签名，保证数据完整性。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 前后端分离项目如何使用 JWT 实现登录？</p><p><strong>答案</strong>：</p><ul><li>登录成功生成 JWT，返回给前端；</li><li>前端每次请求携带 Token；</li><li>服务端通过验证签名和过期时间确认身份，无需存储会话。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> JWT 的安全问题及解决方法？</p><p><strong>答案</strong>：</p><ul><li>不可存储敏感信息（如密码）；</li><li>使用 HTTPS 避免中间人攻击；</li><li>过期时间控制 Token 生命周期；</li><li>可使用刷新 Token 机制。</li></ul><hr><h4 id="Redis（数据结构、持久化、集群、分布式锁、缓存问题）"><a href="#Redis（数据结构、持久化、集群、分布式锁、缓存问题）" class="headerlink" title="Redis（数据结构、持久化、集群、分布式锁、缓存问题）"></a>Redis（数据结构、持久化、集群、分布式锁、缓存问题）</h4><p><strong>题目 1（基础）</strong>：<br> Redis 常用数据结构有哪些？</p><p><strong>答案</strong>：</p><ul><li>String、Hash、List、Set、ZSet（有序集合）；</li><li>支持快速读写、计数、排行榜、缓存。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 高并发下如何实现 Redis 分布式锁？</p><p><strong>答案</strong>：</p><ul><li>使用 <code>SETNX key value NX PX 10000</code> 原子操作；</li><li>使用 Redisson 客户端封装安全的分布式锁；</li><li>确保过期时间防止死锁。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 缓存问题（穿透、击穿、雪崩）如何解决？</p><p><strong>答案</strong>：</p><ul><li>穿透：请求不存在数据，可缓存空对象；</li><li>击穿：热点 key 过期并发请求，可加互斥锁；</li><li>雪崩：大量 key 同时过期，分散过期时间或使用随机过期；</li><li>使用合理 TTL、双级缓存策略。</li></ul><hr><h4 id="MQ（削峰填谷、解耦、异步、消费语义）"><a href="#MQ（削峰填谷、解耦、异步、消费语义）" class="headerlink" title="MQ（削峰填谷、解耦、异步、消费语义）"></a>MQ（削峰填谷、解耦、异步、消费语义）</h4><p><strong>题目 1（基础）</strong>：<br> 消息队列常用场景？</p><p><strong>答案</strong>：</p><ul><li>流量削峰填谷；</li><li>系统解耦；</li><li>异步处理；</li><li>异步通知、日志处理、订单系统等。</li></ul><p><strong>题目 2（场景题）</strong>：<br> Kafka、RocketMQ、RabbitMQ 消费语义有何区别？</p><p><strong>答案</strong>：</p><table><thead><tr><th>消费语义</th><th>描述</th></tr></thead><tbody><tr><td>at-most-once</td><td>消息可能丢失，但不会重复</td></tr><tr><td>at-least-once</td><td>消息可能重复，但不丢失</td></tr><tr><td>exactly-once</td><td>消息不丢失也不重复（事务或幂等性实现）</td></tr></tbody></table><p><strong>题目 3（考点延伸）</strong>：<br> 如何保证 MQ 消息顺序消费？</p><p><strong>答案</strong>：</p><ul><li>Kafka 分区顺序消费，保证同一分区内顺序；</li><li>RabbitMQ 使用单队列 + 单消费者；</li><li>避免多线程并行消费同一顺序队列。</li></ul><hr><h4 id="分布式事务（2PC、XA、Saga、补偿、Seata）"><a href="#分布式事务（2PC、XA、Saga、补偿、Seata）" class="headerlink" title="分布式事务（2PC、XA、Saga、补偿、Seata）"></a>分布式事务（2PC、XA、Saga、补偿、Seata）</h4><p><strong>题目 1（基础）</strong>：<br> 2PC（两阶段提交）流程？</p><p><strong>答案</strong>：</p><ol><li>准备阶段：协调者询问各参与者能否提交；</li><li>提交阶段：所有参与者同意提交则正式提交，否则回滚；</li></ol><ul><li>保证原子性，但性能低，阻塞资源。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 电商系统跨服务扣库存和创建订单，如何保证分布式事务？</p><p><strong>答案</strong>：</p><ul><li>方案 1：2PC&#x2F;XA，保证强一致性；</li><li>方案 2：Saga 事务 + 补偿事务，保证最终一致性；</li><li>方案 3：使用 Seata 框架管理分布式事务，简化开发。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 分布式事务与本地事务区别？</p><p><strong>答案</strong>：</p><ul><li>本地事务：单数据库，ACID 保证强一致性；</li><li>分布式事务：跨服务或数据库，需要协调机制，通常追求最终一致性，性能开销大。</li></ul><hr><h4 id="CAP-BASE-理论"><a href="#CAP-BASE-理论" class="headerlink" title="CAP &#x2F; BASE 理论"></a>CAP &#x2F; BASE 理论</h4><p><strong>题目 1（基础）</strong>：<br> CAP 理论是什么？</p><p><strong>答案</strong>：</p><ul><li>Consistency（强一致性）、Availability（可用性）、Partition tolerance（分区容错）；</li><li>分布式系统最多同时保证两项。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 电商秒杀系统为什么选择 AP 系统而非 CP 系统？</p><p><strong>答案</strong>：</p><ul><li>秒杀系统追求高可用和快速响应；</li><li>可接受最终一致性；</li><li>AP 系统保证可用性和分区容错，牺牲短时间一致性。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> BASE 理论如何理解？</p><p><strong>答案</strong>：</p><ul><li>Basically Available（基本可用）、Soft state（软状态）、Eventually consistent（最终一致性）；</li><li>弥补 CAP 理论的实际应用场景，实现高可用分布式系统。</li></ul><hr><h4 id="一致性协调（Zookeeper、etcd）"><a href="#一致性协调（Zookeeper、etcd）" class="headerlink" title="一致性协调（Zookeeper、etcd）"></a>一致性协调（Zookeeper、etcd）</h4><p><strong>题目 1（基础）</strong>：<br> Zookeeper 的主要功能？</p><p><strong>答案</strong>：</p><ul><li>分布式协调服务；</li><li>提供选举、配置管理、命名服务、分布式锁等；</li><li>使用 ZAB 协议保证顺序一致性。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 多个微服务如何利用 Zookeeper 实现分布式锁？</p><p><strong>答案</strong>：</p><ul><li>使用临时顺序节点；</li><li>获取最小序号节点的客户端获得锁；</li><li>锁释放后通知下一个等待客户端。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> etcd 与 Zookeeper 有何区别？</p><p><strong>答案</strong>：</p><ul><li>etcd：使用 Raft 协议，API 简洁，HTTP&#x2F;JSON 接口；</li><li>Zookeeper：ZAB 协议，Java 原生客户端，功能丰富；</li><li>都可实现配置管理、分布式锁、服务注册。</li></ul><hr><h4 id="可观测性（ELK、Prometheus、Grafana、Jaeger）"><a href="#可观测性（ELK、Prometheus、Grafana、Jaeger）" class="headerlink" title="可观测性（ELK、Prometheus、Grafana、Jaeger）"></a>可观测性（ELK、Prometheus、Grafana、Jaeger）</h4><p><strong>题目 1（基础）</strong>：<br> 可观测性三要素？</p><p><strong>答案</strong>：</p><ul><li>Metrics（指标）；</li><li>Logs（日志）；</li><li>Tracing（分布式调用链）。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 服务出现性能瓶颈，如何定位？</p><p><strong>答案</strong>：</p><ul><li>使用 Prometheus 收集指标（CPU、内存、请求延迟）；</li><li>Grafana 可视化监控；</li><li>ELK 分析日志，定位错误或异常；</li><li>Jaeger 查看分布式调用链，找出慢链路。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 为什么微服务系统需要可观测性？</p><p><strong>答案</strong>：</p><ul><li>系统复杂，单点问题难定位；</li><li>提前发现异常，提高可靠性；</li><li>支持容量规划和优化决策。</li></ul><hr><p>好的，我们继续生成 <strong>模块 8：运维&#x2F;容器化</strong> 的完整面试题库，每个小要点至少三题（基础题、场景题、考点延伸题），并附详细解答。</p><hr><h2 id="模块-8：运维-容器化"><a href="#模块-8：运维-容器化" class="headerlink" title="模块 8：运维&#x2F;容器化"></a>模块 8：运维&#x2F;容器化</h2><h3 id="Docker（镜像、容器、Dockerfile）"><a href="#Docker（镜像、容器、Dockerfile）" class="headerlink" title="Docker（镜像、容器、Dockerfile）"></a>Docker（镜像、容器、Dockerfile）</h3><p><strong>题目 1（基础）</strong>：<br> Docker 镜像和容器有什么区别？</p><p><strong>答案</strong>：</p><ul><li>镜像：静态文件，包含应用及运行环境；</li><li>容器：镜像运行后的实例，独立进程环境，可读写文件系统；</li><li>镜像不可修改，容器可写。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 如何构建一个轻量化的 Docker 镜像？</p><p><strong>答案</strong>：</p><ul><li>使用官方基础镜像（Alpine、Debian Slim）；</li><li>多阶段构建减少临时文件；</li><li>清理缓存和不必要文件；</li><li>合理拆分层，减少镜像体积。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> Dockerfile 常用指令有哪些？</p><p><strong>答案</strong>：</p><ul><li>FROM：基础镜像；</li><li>COPY&#x2F;ADD：复制文件到镜像；</li><li>RUN：构建期间执行命令；</li><li>CMD&#x2F;ENTRYPOINT：容器启动命令；</li><li>EXPOSE：暴露端口；</li><li>ENV：设置环境变量；</li><li>WORKDIR：工作目录。</li></ul><hr><h3 id="Kubernetes（Pod、Deployment、Service、Ingress、ConfigMap、Secret、StatefulSet）"><a href="#Kubernetes（Pod、Deployment、Service、Ingress、ConfigMap、Secret、StatefulSet）" class="headerlink" title="Kubernetes（Pod、Deployment、Service、Ingress、ConfigMap、Secret、StatefulSet）"></a>Kubernetes（Pod、Deployment、Service、Ingress、ConfigMap、Secret、StatefulSet）</h3><p><strong>题目 1（基础）</strong>：<br> Kubernetes 中 Pod、Deployment、Service 有何作用？</p><p><strong>答案</strong>：</p><ul><li>Pod：最小调度单元，封装容器及资源；</li><li>Deployment：管理 Pod 副本，保证期望状态；</li><li>Service：提供访问入口，实现负载均衡，暴露 Pod。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 如何在 Kubernetes 中配置应用数据库连接信息？</p><p><strong>答案</strong>：</p><ul><li>ConfigMap：存储非敏感配置；</li><li>Secret：存储敏感信息（密码、Token），支持加密；</li><li>Pod 通过环境变量或挂载卷读取配置。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> StatefulSet 与 Deployment 有何区别？</p><p><strong>答案</strong>：</p><table><thead><tr><th>特性</th><th>Deployment</th><th>StatefulSet</th></tr></thead><tbody><tr><td>Pod 名称</td><td>随机</td><td>稳定，序号递增</td></tr><tr><td>数据持久化</td><td>不保证</td><td>与 Pod 一一对应的持久卷</td></tr><tr><td>场景</td><td>无状态应用</td><td>有状态应用（数据库、缓存）</td></tr></tbody></table><hr><h3 id="部署策略（滚动更新、蓝绿、金丝雀）"><a href="#部署策略（滚动更新、蓝绿、金丝雀）" class="headerlink" title="部署策略（滚动更新、蓝绿、金丝雀）"></a>部署策略（滚动更新、蓝绿、金丝雀）</h3><p><strong>题目 1（基础）</strong>：<br> Kubernetes 中滚动更新是什么？</p><p><strong>答案</strong>：</p><ul><li>Deployment 默认策略；</li><li>逐步替换旧 Pod，保证服务不中断；</li><li>可配置最大不可用和最大超额副本数。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 如何在生产环境中安全发布新版本？</p><p><strong>答案</strong>：</p><ul><li>蓝绿部署：同时保留旧版本和新版本，流量切换后回退简单；</li><li>金丝雀发布：先小部分用户访问新版本，验证稳定后全量切换；</li><li>滚动更新：逐步替换 Pod，减少宕机。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 滚动更新与蓝绿部署优缺点？</p><p><strong>答案</strong>：</p><ul><li>滚动更新：平滑升级，不占用额外资源，但回退复杂；</li><li>蓝绿部署：快速回退，但需要双份资源，成本高。</li></ul><hr><h3 id="CI-CD（Jenkins、GitLab-CI、ArgoCD）"><a href="#CI-CD（Jenkins、GitLab-CI、ArgoCD）" class="headerlink" title="CI&#x2F;CD（Jenkins、GitLab CI、ArgoCD）"></a>CI&#x2F;CD（Jenkins、GitLab CI、ArgoCD）</h3><p><strong>题目 1（基础）</strong>：<br> CI&#x2F;CD 的核心作用是什么？</p><p><strong>答案</strong>：</p><ul><li>持续集成（CI）：自动构建、测试代码，提高开发效率；</li><li>持续交付&#x2F;部署（CD）：自动发布、部署到环境，保证快速、可重复交付；</li><li>提高软件质量和发布速度。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 如何实现微服务应用自动化部署？</p><p><strong>答案</strong>：</p><ul><li>Jenkins&#x2F;GitLab CI 构建镜像、执行测试；</li><li>Docker Push 镜像到 Registry；</li><li>ArgoCD 或 Helm 部署更新 Kubernetes 集群；</li><li>结合监控报警和回滚策略保证安全。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> CI&#x2F;CD 常见挑战有哪些？</p><p><strong>答案</strong>：</p><ul><li>多环境一致性问题；</li><li>构建&#x2F;部署失败回滚处理；</li><li>依赖管理和版本控制；</li><li>流水线安全、权限控制；</li><li>微服务依赖顺序和配置管理。</li></ul><hr><h3 id="高可用（多-AZ、故障切换、自动伸缩）"><a href="#高可用（多-AZ、故障切换、自动伸缩）" class="headerlink" title="高可用（多 AZ、故障切换、自动伸缩）"></a>高可用（多 AZ、故障切换、自动伸缩）</h3><p><strong>题目 1（基础）</strong>：<br> 高可用的核心指标是什么？</p><p><strong>答案</strong>：</p><ul><li>SLA（Service Level Agreement）：服务可用性目标；</li><li>容错能力：单点故障不影响系统整体；</li><li>自动故障切换和自愈能力。</li></ul><p><strong>题目 2（场景题）</strong>：<br> Web 服务在单 AZ 宕机时如何保证可用？</p><p><strong>答案</strong>：</p><ul><li>多可用区部署（Multi-AZ）；</li><li>使用负载均衡器自动切换健康节点；</li><li>自动伸缩（HPA&#x2F;VPA）保证服务压力可控；</li><li>数据库采用主备或集群模式，保证数据可用性。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> Kubernetes 如何实现自动伸缩？</p><p><strong>答案</strong>：</p><ul><li>HPA（Horizontal Pod Autoscaler）：根据 CPU&#x2F;内存或自定义指标自动增加&#x2F;减少 Pod 副本；</li><li>VPA（Vertical Pod Autoscaler）：动态调整 Pod 资源请求；</li><li>Cluster Autoscaler：动态扩缩集群节点。</li></ul><hr><h3 id="监控与告警（SLO-SLI-SLA，Prometheus-Grafana）"><a href="#监控与告警（SLO-SLI-SLA，Prometheus-Grafana）" class="headerlink" title="监控与告警（SLO&#x2F;SLI&#x2F;SLA，Prometheus+Grafana）"></a>监控与告警（SLO&#x2F;SLI&#x2F;SLA，Prometheus+Grafana）</h3><p><strong>题目 1（基础）</strong>：<br> SLO、SLI、SLA 含义？</p><p><strong>答案</strong>：</p><ul><li>SLI（Service Level Indicator）：服务级别指标，如延迟、错误率；</li><li>SLO（Service Level Objective）：服务指标目标值；</li><li>SLA（Service Level Agreement）：与用户约定的服务可用性协议，包含处罚条款。</li></ul><p><strong>题目 2（场景题）</strong>：<br> 如何监控微服务性能并触发告警？</p><p><strong>答案</strong>：</p><ul><li>使用 Prometheus 收集指标（CPU、内存、请求延迟、错误率）；</li><li>Grafana 可视化，创建仪表盘；</li><li>设置 Alertmanager 告警规则，触发短信&#x2F;邮件&#x2F;钉钉通知；</li><li>可结合自动伸缩策略缓解高负载。</li></ul><p><strong>题目 3（考点延伸）</strong>：<br> 微服务可观测性与单体系统有何不同？</p><p><strong>答案</strong>：</p><ul><li>微服务分布式，链路复杂，需要分布式追踪；</li><li>指标、日志、追踪需集中采集；</li><li>故障定位需支持跨服务调用分析；</li><li>SLA&#x2F;SLO 监控粒度更细。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Linux </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点</title>
      <link href="/2025/09/22/java%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2025/09/22/java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="一、网络基础概念"><a href="#一、网络基础概念" class="headerlink" title="一、网络基础概念"></a>一、网络基础概念</h2><ol><li><strong>网络的定义</strong><br> 网络是多个计算机及通信设备通过通信介质互联的系统，用于信息传输、资源共享、协同工作。<ul><li>核心目标：可靠、高效、可扩展的数据传输。</li><li>设计原则：分层、模块化、接口标准化。</li></ul></li><li><strong>数据传输方式</strong><ul><li><strong>单工</strong>：单向传输（电视广播）。</li><li><strong>半双工</strong>：双向传输，但不能同时发送（对讲机）。</li><li><strong>全双工</strong>：双向同时传输（电话、以太网交换机端口）。</li></ul></li><li><strong>通信方式</strong><ul><li><strong>点对点</strong>：两个节点直接通信（PPP）。</li><li><strong>广播</strong>：单点发送，多点接收（Ethernet）。</li><li><strong>组播</strong>：单点发送，特定组接收（IP 多播）。</li></ul></li><li><strong>网络分类</strong><ul><li><strong>按地理范围</strong>：LAN、MAN、WAN。</li><li><strong>按拓扑结构</strong>：星型、总线型、环型、混合型。</li><li><strong>按访问控制方式</strong>：CSMA&#x2F;CD（Ethernet）、令牌环（Token Ring）。</li></ul></li></ol><hr><h2 id="二、OSI-七层模型"><a href="#二、OSI-七层模型" class="headerlink" title="二、OSI 七层模型"></a>二、OSI 七层模型</h2><p>OSI 模型将网络通信划分为七层，每层负责特定功能，确保模块化与互操作性。</p><table><thead><tr><th>层</th><th>功能</th><th>数据单位</th><th>典型协议&#x2F;设备</th><th>面试易问点</th></tr></thead><tbody><tr><td><strong>物理层</strong></td><td>比特流传输，电气&#x2F;光学&#x2F;机械接口</td><td>比特 Bit</td><td>网线、光纤、集线器、网卡物理部分、调制解调器</td><td>电压、传输速率、双工模式、光纤与铜缆区别</td></tr><tr><td><strong>数据链路层</strong></td><td>节点间帧传输，差错控制、流量控制、MAC 地址</td><td>帧 Frame</td><td>以太网、PPP、交换机、网桥</td><td>CSMA&#x2F;CD 工作原理、MAC 地址格式、VLAN</td></tr><tr><td><strong>网络层</strong></td><td>主机到主机传输，逻辑寻址、路由、拥塞控制</td><td>数据包 Packet</td><td>IP、ICMP、IGMP、路由器</td><td>路由选择算法（RIP&#x2F;OSPF&#x2F;BGP）、子网掩码计算、NAT</td></tr><tr><td><strong>传输层</strong></td><td>端到端通信，端口映射、分段重组、流量控制</td><td>报文段 Segment (TCP)、数据报 Datagram (UDP)</td><td>TCP、UDP</td><td>TCP 三次握手、四次挥手、滑动窗口、端口号分类</td></tr><tr><td><strong>会话层</strong></td><td>管理应用会话，数据同步</td><td>会话数据</td><td>NetBIOS、RPC、NFS、SQL</td><td>断点续传、会话保持机制</td></tr><tr><td><strong>表示层</strong></td><td>数据表示、编码、加密压缩</td><td>表示数据</td><td>JPEG、MPEG、ASCII、Unicode、TLS&#x2F;SSL</td><td>大端&#x2F;小端、编码转换、加密&#x2F;解密流程</td></tr><tr><td><strong>应用层</strong></td><td>提供用户服务，直接与应用交互</td><td>应用数据</td><td>HTTP、FTP、SMTP、POP3&#x2F;IMAP、DNS、Telnet、SNMP</td><td>HTTP 请求&#x2F;响应报文结构、DNS 查询流程、FTP 主动&#x2F;被动模式</td></tr></tbody></table><h3 id="1-物理层深度"><a href="#1-物理层深度" class="headerlink" title="1. 物理层深度"></a>1. 物理层深度</h3><ul><li><strong>电气特性</strong>：电压幅值、频率、信号调制。</li><li><strong>传输介质差异</strong>：<ul><li>铜缆（双绞线、同轴）: 成本低、易干扰。</li><li>光纤: 高速、长距离、抗电磁干扰。</li></ul></li><li><strong>面试常问</strong>：光纤单模和多模区别、网卡速率、半双工&#x2F;全双工。</li></ul><h3 id="2-数据链路层深度"><a href="#2-数据链路层深度" class="headerlink" title="2. 数据链路层深度"></a>2. 数据链路层深度</h3><ul><li><strong>MAC 地址</strong>：唯一标识网卡，48 位（前 24 位厂商号，后 24 位设备号）。</li><li><strong>流量控制</strong>：<ul><li>停止等待（Stop-and-Wait）</li><li>滑动窗口（Sliding Window）</li></ul></li><li><strong>差错控制</strong>：CRC 校验、帧校验序列 (FCS)。</li><li><strong>VLAN</strong>：逻辑分隔网络，减少广播风暴。</li></ul><h3 id="3-网络层深度"><a href="#3-网络层深度" class="headerlink" title="3. 网络层深度"></a>3. 网络层深度</h3><ul><li><strong>逻辑寻址</strong>：IPv4&#x2F;IPv6</li><li><strong>子网划分</strong>：CIDR、VLSM。</li><li><strong>路由协议</strong>：<ul><li><strong>RIP</strong>：跳数最短，收敛慢。</li><li><strong>OSPF</strong>：链路状态，快速收敛。</li><li><strong>BGP</strong>：自治系统间，策略路由。</li></ul></li><li><strong>NAT</strong>：私网 IP 转换为公网 IP，节约 IP。</li></ul><h3 id="4-传输层深度"><a href="#4-传输层深度" class="headerlink" title="4. 传输层深度"></a>4. 传输层深度</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li><strong>可靠性机制</strong>：<ul><li>序列号与确认号。</li><li>滑动窗口。</li><li>重传机制（超时&#x2F;快速重传）。</li></ul></li><li><strong>三次握手（建立连接）</strong><ul><li><strong>第一次 (SYN)</strong>：客户端请求，seq&#x3D;client_ISN。</li><li><strong>第二次 (SYN-ACK)</strong>：服务器确认客户端，seq&#x3D;server_ISN, ack&#x3D;client_ISN+1。</li><li><strong>第三次 (ACK)</strong>：客户端确认服务器，ack&#x3D;server_ISN+1。</li></ul></li><li><strong>四次挥手（断开连接）</strong><ul><li>FIN&#x2F;ACK 交替关闭双向。</li><li>TIME_WAIT: 2MSL，保证最后 ACK 到达并避免旧报文干扰。</li></ul></li><li><strong>流量控制</strong>：滑动窗口</li><li><strong>拥塞控制</strong>：慢启动、拥塞避免、快速重传、快速恢复。</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li><strong>特点</strong>：无连接、无序、不保证到达。</li><li><strong>应用</strong>：DNS、VoIP、视频直播。</li><li><strong>优点</strong>：低延迟、开销小。</li></ul><h3 id="5-会话层深度"><a href="#5-会话层深度" class="headerlink" title="5. 会话层深度"></a>5. 会话层深度</h3><ul><li><strong>会话管理</strong>：<ul><li>会话建立、保持、终止。</li><li>数据同步点（断点续传）。</li></ul></li><li><strong>面试点</strong>：HTTP 是无状态协议，如何实现会话保持？（Cookie&#x2F;Session&#x2F;Token）</li></ul><h3 id="6-表示层深度"><a href="#6-表示层深度" class="headerlink" title="6. 表示层深度"></a>6. 表示层深度</h3><ul><li><strong>数据格式化</strong>：ASCII、Unicode、EBCDIC。</li><li><strong>压缩&#x2F;解压</strong>：JPEG、MPEG、ZIP。</li><li><strong>加密&#x2F;解密</strong>：TLS&#x2F;SSL，实现安全通信。</li><li><strong>面试点</strong>：大端小端，Base64 编码。</li></ul><h3 id="7-应用层深度"><a href="#7-应用层深度" class="headerlink" title="7. 应用层深度"></a>7. 应用层深度</h3><ul><li><p><strong>HTTP</strong>：</p><ul><li>请求方法：GET&#x2F;POST&#x2F;PUT&#x2F;DELETE&#x2F;OPTIONS。</li><li>状态码：1xx-5xx。</li></ul></li><li><p><strong>DNS</strong>：</p><ul><li><p>查询类型：A（IPV4）&#x2F;AAAA （IPV6）&#x2F;CNAME（别名）&#x2F;MX（邮箱）。</p></li><li><p>递归&#x2F;迭代查询。</p><hr><h3 id="1-A-记录-Address-Record"><a href="#1-A-记录-Address-Record" class="headerlink" title="1. A 记录 (Address Record)"></a>1. <strong>A 记录 (Address Record)</strong></h3><ul><li><strong>作用</strong>：把域名映射到 <strong>IPv4 地址</strong>。</li><li><strong>特点</strong>：<ul><li>最常用的 DNS 记录类型。</li><li>解析后客户端直接得到 IPv4 地址访问服务器。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com. IN A 192.0.2.1</span><br></pre></td></tr></table></figure><hr><h3 id="2-AAAA-记录-IPv6-Address-Record"><a href="#2-AAAA-记录-IPv6-Address-Record" class="headerlink" title="2. AAAA 记录 (IPv6 Address Record)"></a>2. <strong>AAAA 记录 (IPv6 Address Record)</strong></h3><ul><li><strong>作用</strong>：把域名映射到 <strong>IPv6 地址</strong>。</li><li><strong>特点</strong>：<ul><li>类似 A 记录，但用于 IPv6。</li><li>随着 IPv6 普及越来越重要。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com. IN AAAA 2001:0db8::1</span><br></pre></td></tr></table></figure><hr><h3 id="3-CNAME-记录-Canonical-Name-Record"><a href="#3-CNAME-记录-Canonical-Name-Record" class="headerlink" title="3. CNAME 记录 (Canonical Name Record)"></a>3. <strong>CNAME 记录 (Canonical Name Record)</strong></h3><ul><li><strong>作用</strong>：把一个域名别名映射到另一个域名（<strong>不直接指 IP</strong>）。</li><li><strong>特点</strong>：<ul><li>不能与 A &#x2F; AAAA 等记录共存于同一主机名。</li><li>解析时会先解析 CNAME 指向的域名，再得到 IP。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.example.com. IN CNAME example.com.</span><br></pre></td></tr></table></figure><hr><h3 id="4-MX-记录-Mail-Exchange-Record"><a href="#4-MX-记录-Mail-Exchange-Record" class="headerlink" title="4. MX 记录 (Mail Exchange Record)"></a>4. <strong>MX 记录 (Mail Exchange Record)</strong></h3><ul><li><strong>作用</strong>：指定域名的邮件服务器，用于接收邮件。</li><li><strong>特点</strong>：<ul><li>每条 MX 记录有 <strong>优先级 (Preference)</strong>，数值越小优先级越高。</li><li>可配置多个 MX 记录，实现邮件负载均衡和容错。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">example.com. IN MX 10 mail1.example.com.</span><br><span class="line">example.com. IN MX 20 mail2.example.com.</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>SMTP&#x2F;POP3&#x2F;IMAP</strong>：</p><ul><li>发送与接收流程。</li></ul></li><li><p><strong>面试点</strong>：</p><ul><li>FTP 主动&#x2F;被动模式差异。</li><li>HTTPS 握手流程（证书交换 + 对称密钥）。</li></ul></li></ul><hr><h2 id="三、TCP-IP-协议族"><a href="#三、TCP-IP-协议族" class="headerlink" title="三、TCP&#x2F;IP 协议族"></a>三、TCP&#x2F;IP 协议族</h2><table><thead><tr><th>层</th><th>功能</th><th>协议</th><th>特点</th><th>面试易问点</th></tr></thead><tbody><tr><td>应用层</td><td>用户应用服务</td><td>HTTP、DNS、FTP、SMTP</td><td>与用户交互</td><td>HTTP 状态码、DNS 查询过程</td></tr><tr><td>传输层</td><td>端到端通信</td><td>TCP、UDP</td><td>TCP 可靠、UDP 高效</td><td>三次握手、四次挥手、流量控制</td></tr><tr><td>网络层</td><td>主机到主机</td><td>IP、ICMP、ARP</td><td>IP 无连接、路由选择</td><td>子网划分、NAT、ICMP 报文</td></tr><tr><td>网络接口层</td><td>物理链路传输</td><td>Ethernet、PPP</td><td>比特传输</td><td>MAC 地址、冲突检测</td></tr></tbody></table><hr><h3 id="TCP-三次握手总结"><a href="#TCP-三次握手总结" class="headerlink" title="TCP 三次握手总结"></a>TCP 三次握手总结</h3><ol><li>客户端发送 SYN，告知初始序列号。</li><li>服务器返回 SYN-ACK，确认收到 SYN 并告知自身序列号。</li><li>客户端 ACK 确认，双方 ESTABLISHED。</li></ol><h3 id="TCP-四次挥手总结"><a href="#TCP-四次挥手总结" class="headerlink" title="TCP 四次挥手总结"></a>TCP 四次挥手总结</h3><ol><li>主动方 FIN，关闭发送。</li><li>被动方 ACK，确认。</li><li>被动方 FIN，关闭发送。</li><li>主动方 ACK，进入 TIME_WAIT，等待 2MSL。</li></ol><hr><h3 id="一、TCP-与-UDP-区别"><a href="#一、TCP-与-UDP-区别" class="headerlink" title="一、TCP 与 UDP 区别"></a>一、TCP 与 UDP 区别</h3><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td><strong>连接方式</strong></td><td>面向连接，需要三次握手建立连接</td><td>无连接，直接发送数据报</td></tr><tr><td><strong>可靠性</strong></td><td>可靠传输，确保数据完整、有序、不丢失</td><td>不可靠传输，不能保证顺序和到达</td></tr><tr><td><strong>数据单位</strong></td><td>报文段 (Segment)</td><td>数据报 (Datagram)</td></tr><tr><td><strong>速度</strong></td><td>较慢，需要建立连接、确认和重传机制</td><td>快，无握手和重传，开销小</td></tr><tr><td><strong>传输顺序</strong></td><td>保证顺序，序列号 + ACK 确认</td><td>不保证顺序，独立发送</td></tr><tr><td><strong>拥塞控制</strong></td><td>有，TCP 拥塞控制算法（慢启动、拥塞避免、快速重传、快速恢复）</td><td>无</td></tr><tr><td><strong>应用场景</strong></td><td>文件传输 (FTP)、网页访问 (HTTP&#x2F;HTTPS)、邮件 (SMTP&#x2F;POP3)</td><td>实时视频&#x2F;语音 (VoIP、直播)、DNS 查询、DHCP</td></tr><tr><td><strong>面试拓展点</strong></td><td>TCP 适合可靠性要求高的场景</td><td>UDP 适合低延迟、可容忍丢包的场景</td></tr></tbody></table><p><strong>面试问法示例：</strong></p><ul><li>“TCP 为什么可靠，UDP 为什么不可靠？”<br> <strong>回答要点</strong>：TCP 使用序列号、ACK 确认、重传机制、流量控制和拥塞控制来保证可靠性；UDP 没有这些机制，直接发送报文，速度快，但不保证到达和顺序。</li></ul><hr><h3 id="二、三次握手"><a href="#二、三次握手" class="headerlink" title="二、三次握手"></a>二、三次握手</h3><p><strong>三次握手步骤复习</strong>：</p><ol><li><strong>客户端 → 服务器</strong>：SYN 报文，请求建立连接，发送 client_ISN。</li><li><strong>服务器 → 客户端</strong>：SYN-ACK 报文，确认客户端 SYN，并发送 server_ISN。</li><li><strong>客户端 → 服务器</strong>：ACK 报文，确认 server_ISN，连接建立。</li></ol><p><strong>为什么需要三次握手？</strong></p><ol><li><strong>防止旧连接报文误建</strong><ul><li>如果只有两次握手，旧的 SYN 报文可能延迟到达，服务器误认为是新连接。</li><li>三次握手确保客户端主动确认，服务器不会因为旧报文进入 ESTABLISHED。</li></ul></li><li><strong>双向确认收发能力</strong><ul><li>第一次握手：客户端告诉服务器它能发。</li><li>第二次握手：服务器告诉客户端它能发，也确认客户端能发。</li><li>第三次握手：客户端确认服务器能收。</li><li><strong>面试常问拓展</strong>：为什么第一次握手服务器不直接进入 ESTABLISHED？<br> <strong>答案</strong>：服务器不能确定客户端已经准备好接收数据，需第三次握手确认。</li></ul></li></ol><hr><h3 id="三、TIME-WAIT-的意义"><a href="#三、TIME-WAIT-的意义" class="headerlink" title="三、TIME_WAIT 的意义"></a>三、TIME_WAIT 的意义</h3><ul><li><strong>TCP 四次挥手后客户端进入 TIME_WAIT</strong></li><li><strong>作用</strong>：<ol><li><strong>确保最后 ACK 能到达服务器</strong><ul><li>如果 ACK 丢失，服务器会重发 FIN，客户端在 TIME_WAIT 状态可以重新响应。</li></ul></li><li><strong>防止旧报文干扰新连接</strong><ul><li>2MSL（Maximum Segment Lifetime）内保证网络中旧报文被清除。</li></ul></li></ol></li><li><strong>典型面试问法</strong>：<ul><li>“为什么客户端主动关闭连接进入 TIME_WAIT，而服务器不进入？”<br> <strong>答案</strong>：主动关闭方需要确保 ACK 能到达被动关闭方并防止旧报文干扰新连接；被动关闭方在收到 ACK 后即可关闭。</li><li>“TIME_WAIT 为什么要等待 2MSL？”<br> <strong>答案</strong>：MSL 是报文在网络中的最大生存时间，等待 2MSL 可以确保所有可能滞留的报文消失。</li></ul></li></ul><hr><h3 id="四、OSI-七层-vs-TCP-IP-模型"><a href="#四、OSI-七层-vs-TCP-IP-模型" class="headerlink" title="四、OSI 七层 vs TCP&#x2F;IP 模型"></a>四、OSI 七层 vs TCP&#x2F;IP 模型</h3><table><thead><tr><th>模型</th><th>层数</th><th>功能</th><th>面试关注点</th></tr></thead><tbody><tr><td><strong>OSI</strong></td><td>7 层：应用、表示、会话、传输、网络、数据链路、物理</td><td>理论模型，描述网络通信的完整功能</td><td>面试常考“每层功能、数据单位、协议、典型设备”</td></tr><tr><td><strong>TCP&#x2F;IP</strong></td><td>4 层：应用、传输、网络、网络接口</td><td>实际互联网使用的模型，简化 OSI，结合实际协议</td><td>面试常考“TCP&#x2F;IP 与 OSI 的对应关系、核心协议、应用场景”</td></tr></tbody></table><p><strong>OSI 与 TCP&#x2F;IP 对应关系</strong>：</p><ul><li>OSI 应用&#x2F;表示&#x2F;会话层 → TCP&#x2F;IP 应用层</li><li>OSI 传输层 → TCP&#x2F;IP 传输层</li><li>OSI 网络层 → TCP&#x2F;IP 网络层</li><li>OSI 数据链路层 + 物理层 → TCP&#x2F;IP 网络接口层</li></ul><p><strong>面试拓展点</strong>：</p><ol><li>TCP&#x2F;IP 为什么只有 4 层？<ul><li>因为实际应用中，表示层与会话层功能通常由应用层实现，硬件设备的物理和链路层可合并。</li></ul></li><li>OSI 模型为什么重要？<ul><li>理论指导，帮助理解网络通信分层设计、模块化、互操作性。</li></ul></li><li>面试常问：OSI 七层模型每层面试问法示例<ul><li><strong>物理层</strong>：双绞线和光纤区别？全双工和半双工区别？</li><li><strong>数据链路层</strong>：MAC 地址格式？交换机与网桥区别？VLAN 原理？</li><li><strong>网络层</strong>：IP 地址分类？子网掩码？RIP vs OSPF？</li><li><strong>传输层</strong>：TCP&#x2F;UDP 区别？三次握手流程？滑动窗口原理？</li><li><strong>会话层</strong>：HTTP 无状态如何实现会话保持？</li><li><strong>表示层</strong>：编码转换？大端小端？TLS 加密流程？</li><li><strong>应用层</strong>：HTTP 状态码？FTP 主动&#x2F;被动模式？DNS 查询过程？</li></ul></li></ol><hr><h4 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1. 物理层"></a>1. 物理层</h4><p><strong>Q1：双绞线和光纤区别？</strong><br> <strong>A1</strong>：</p><table><thead><tr><th>特性</th><th>双绞线</th><th>光纤</th></tr></thead><tbody><tr><td>传输介质</td><td>铜线</td><td>光纤（玻璃或塑料）</td></tr><tr><td>传输方式</td><td>电信号</td><td>光信号</td></tr><tr><td>抗干扰性</td><td>容易受电磁干扰</td><td>抗电磁干扰强</td></tr><tr><td>传输距离</td><td>短（100米左右）</td><td>长（可达数公里）</td></tr><tr><td>传输速率</td><td>10Mbps~10Gbps</td><td>1Gbps~400Gbps</td></tr><tr><td>成本</td><td>低</td><td>高</td></tr><tr><td><strong>面试要点</strong>：光纤适合高速、长距离、数据中心或核心网，双绞线适合局域网。</td><td></td><td></td></tr></tbody></table><p><strong>Q2：全双工和半双工区别？</strong><br> <strong>A2</strong>：</p><ul><li><strong>半双工</strong>：数据双向传输，但同一时间只能一个方向（如对讲机）。</li><li><strong>全双工</strong>：数据双向传输，可同时收发（如现代交换机端口）。<br> <strong>面试要点</strong>：半双工容易冲突，需要 CSMA&#x2F;CD，降低效率；全双工无需冲突检测，速率翻倍。</li></ul><hr><h4 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2. 数据链路层"></a>2. 数据链路层</h4><p><strong>Q1：MAC 地址格式？</strong><br> <strong>A1</strong>：</p><ul><li>48 位二进制，通常写作 6 组十六进制：<code>00:1A:2B:3C:4D:5E</code></li><li>前 24 位：厂商标识（OUI）</li><li>后 24 位：网卡序列号</li><li>唯一标识网卡设备<br> <strong>面试要点</strong>：MAC 地址用于局域网内通信，交换机通过 MAC 表转发帧。</li></ul><p><strong>Q2：交换机与网桥区别？</strong></p><table><thead><tr><th>特性</th><th>网桥 (Bridge)</th><th>交换机 (Switch)</th></tr></thead><tbody><tr><td>端口数</td><td>少</td><td>多</td></tr><tr><td>功能</td><td>转发帧、过滤广播</td><td>转发帧、学习 MAC、分割冲突域</td></tr><tr><td>性能</td><td>较低</td><td>高</td></tr><tr><td><strong>面试要点</strong>：交换机可以理解为多端口网桥，隔离冲突域，效率更高。</td><td></td><td></td></tr></tbody></table><p><strong>Q3：VLAN 原理？</strong><br> <strong>A3</strong>：</p><ul><li>虚拟局域网（Virtual LAN）在同一物理交换机上划分不同逻辑网段。</li><li>通过 <strong>802.1Q 标签</strong> 给帧打标签，实现逻辑隔离。</li><li>优点：隔离广播域，提高安全性和管理性。<br> <strong>面试要点</strong>：同一交换机内不同 VLAN 之间通信需要路由器或三层交换机。</li></ul><hr><h4 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h4><p><strong>Q1：IP 地址分类？</strong></p><table><thead><tr><th>类别</th><th>起始位</th><th>范围</th><th>默认子网掩码</th><th>用途</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1.0.0.0–126.255.255.255</td><td>255.0.0.0</td><td>大型网络</td></tr><tr><td>B</td><td>10</td><td>128.0.0.0–191.255.255.255</td><td>255.255.0.0</td><td>中型网络</td></tr><tr><td>C</td><td>110</td><td>192.0.0.0–223.255.255.255</td><td>255.255.255.0</td><td>小型网络</td></tr><tr><td>D</td><td>1110</td><td>224.0.0.0–239.255.255.255</td><td>N&#x2F;A</td><td>多播</td></tr><tr><td>E</td><td>1111</td><td>240.0.0.0–255.255.255.255</td><td>N&#x2F;A</td><td>实验&#x2F;保留</td></tr></tbody></table><p><strong>Q2：子网掩码作用？</strong></p><ul><li>用于区分网络号和主机号。</li><li>通过按位与运算确定同一网段内主机。</li><li>面试问法：给 IP&#x2F;子网掩码计算可用主机数或广播地址。</li></ul><p><strong>Q3：RIP vs OSPF</strong></p><table><thead><tr><th>特性</th><th>RIP</th><th>OSPF</th></tr></thead><tbody><tr><td>类型</td><td>距离矢量</td><td>链路状态</td></tr><tr><td>收敛速度</td><td>慢</td><td>快</td></tr><tr><td>度量</td><td>跳数</td><td>带宽&#x2F;延迟</td></tr><tr><td>缺点</td><td>路径可能环路</td><td>配置复杂</td></tr><tr><td><strong>面试要点</strong>：RIP 简单、适合小网络；OSPF 复杂、适合大型网络。</td><td></td><td></td></tr></tbody></table><hr><h4 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4. 传输层"></a>4. 传输层</h4><p><strong>Q1：TCP&#x2F;UDP 区别</strong><br> 详见上条回答。</p><p><strong>Q2：三次握手流程</strong><br> 详见上条回答，可画图辅助说明。</p><p><strong>Q3：滑动窗口原理</strong></p><ul><li>TCP 使用滑动窗口进行流量控制。</li><li><strong>发送方</strong>可发送窗口大小内的数据而不必等待 ACK。</li><li><strong>接收方</strong>通过窗口大小告知可接收缓冲区容量。</li><li><strong>好处</strong>：提高链路利用率，避免频繁等待确认。</li><li>面试问法：滑动窗口与停止等待区别？答案：滑动窗口一次可发送多段，停止等待一次只能发送一段。</li></ul><hr><h4 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5. 会话层"></a>5. 会话层</h4><p><strong>Q1：HTTP 无状态如何实现会话保持？</strong></p><ul><li>HTTP 本身无状态，每次请求独立。</li><li><strong>实现方式</strong>：<ol><li><strong>Cookie</strong>：客户端保存会话 ID，随请求发送。</li><li><strong>Session</strong>：服务端保存用户状态，客户端发送标识。</li><li><strong>Token&#x2F;JWT</strong>：无状态方式，将用户信息加密放在客户端。</li></ol></li></ul><hr><h4 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6. 表示层"></a>6. 表示层</h4><p><strong>Q1：编码转换</strong></p><ul><li>ASCII、UTF-8、Unicode 等，用于不同系统间字符表示兼容。</li><li>面试问法：中文 UTF-8 编码占多少字节？<br> <strong>答案</strong>：汉字 3 字节，英文 1 字节。</li></ul><p><strong>Q2：大端小端</strong></p><ul><li><strong>大端</strong>（Big Endian）：高位字节存放在低地址。</li><li><strong>小端</strong>（Little Endian）：低位字节存放在低地址。</li><li>面试问法：网络传输使用哪种？<br> <strong>答案</strong>：大端（网络字节序）。</li></ul><p><strong>Q3：TLS 加密流程</strong></p><ol><li>客户端发送 ClientHello（支持加密算法）。</li><li>服务器返回 ServerHello，发送证书。</li><li>客户端验证证书，生成会话密钥。</li><li>双方用会话密钥加密通信。</li></ol><ul><li>面试要点：讲清楚“证书验证”和“对称密钥加密数据”。</li></ul><hr><h4 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7. 应用层"></a>7. 应用层</h4><p><strong>Q1：HTTP 状态码</strong></p><table><thead><tr><th>类型</th><th>示例</th><th>含义</th></tr></thead><tbody><tr><td>1xx</td><td>100 Continue</td><td>信息性响应</td></tr><tr><td>2xx</td><td>200 OK</td><td>成功</td></tr><tr><td>3xx</td><td>301 Moved Permanently</td><td>重定向</td></tr><tr><td>4xx</td><td>404 Not Found</td><td>客户端错误</td></tr><tr><td>5xx</td><td>500 Internal Server Error</td><td>服务器错误</td></tr></tbody></table><p><strong>Q2：FTP 主动&#x2F;被动模式</strong></p><ul><li><strong>主动模式</strong>：客户端建立控制连接，服务器主动建立数据连接。</li><li><strong>被动模式</strong>：客户端建立控制连接和数据连接，服务器被动监听。</li><li>面试要点：被动模式用于客户端在防火墙后的情况。</li></ul><p><strong>Q3：DNS 查询过程</strong></p><ol><li>客户端向本地 DNS 发起递归查询。</li><li>本地 DNS 如果缓存没有，向根 DNS 查询 → 顶级域 → 权威 DNS。</li><li>权威 DNS 返回解析结果到本地 DNS，本地返回给客户端。</li></ol><ul><li>面试要点：递归查询 vs 迭代查询区别。</li><li></li></ul><hr><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><h3 id="一、前后端交互的基本流程"><a href="#一、前后端交互的基本流程" class="headerlink" title="一、前后端交互的基本流程"></a><strong>一、前后端交互的基本流程</strong></h3><ol><li><strong>前端发起请求</strong><ul><li>用户在浏览器或客户端操作，比如点击按钮、提交表单。</li><li>前端通过 HTTP&#x2F;HTTPS 或 WebSocket 向后端发送请求。</li><li>请求包含：URL、请求方法（GET&#x2F;POST&#x2F;PUT&#x2F;DELETE 等）、请求头（Header）、请求体（Body，POST&#x2F;PUT 时）和参数。</li></ul></li><li><strong>后端接收请求</strong><ul><li>后端服务器（如 Java&#x2F;Spring、Node.js、Python Flask&#x2F;Django）解析请求。</li><li>后端根据 URL 路径、HTTP 方法匹配路由到对应的处理函数（Controller&#x2F;Handler）。</li></ul></li><li><strong>后端处理请求</strong><ul><li>后端进行业务逻辑处理：<ul><li>数据库查询&#x2F;更新（CRUD）</li><li>调用其他服务或 API</li><li>数据验证、权限校验</li></ul></li><li>处理完成后，生成响应数据（通常为 JSON、XML、HTML 或二进制文件）。</li></ul></li><li><strong>后端返回响应</strong><ul><li>响应包含：状态码（HTTP Status Code）、响应头、响应体（Body）。</li><li>状态码示例：<ul><li>200 OK：请求成功</li><li>201 Created：资源创建成功</li><li>400 Bad Request：请求错误</li><li>401 Unauthorized：未授权</li><li>500 Internal Server Error：服务器错误</li></ul></li></ul></li><li><strong>前端接收响应</strong><ul><li>前端根据状态码判断请求结果。</li><li>前端解析响应体并更新界面（UI），例如渲染数据表格、显示提示信息。</li><li>如果是异步请求（AJAX&#x2F;Fetch&#x2F;axios），前端可以在回调或 Promise 中处理响应。</li></ul></li></ol><hr><h3 id="二、前后端交互方式"><a href="#二、前后端交互方式" class="headerlink" title="二、前后端交互方式"></a><strong>二、前后端交互方式</strong></h3><h4 id="1-HTTP-请求-响应模式"><a href="#1-HTTP-请求-响应模式" class="headerlink" title="1. HTTP 请求-响应模式"></a>1. <strong>HTTP 请求-响应模式</strong></h4><ul><li><strong>同步请求</strong>（传统表单提交）：浏览器提交表单，等待响应页面刷新。</li><li><strong>异步请求</strong>（AJAX&#x2F;Fetch&#x2F;axios）：页面不刷新，通过 JavaScript 异步获取数据。</li></ul><h4 id="2-WebSocket-实时通信"><a href="#2-WebSocket-实时通信" class="headerlink" title="2. WebSocket 实时通信"></a>2. <strong>WebSocket 实时通信</strong></h4><ul><li>前端与后端建立长连接。</li><li>可以实时双向通信，不需要每次都发 HTTP 请求。</li><li>适用场景：聊天应用、在线游戏、实时监控。</li></ul><h4 id="3-Server-Sent-Events（SSE）"><a href="#3-Server-Sent-Events（SSE）" class="headerlink" title="3. Server-Sent Events（SSE）"></a>3. <strong>Server-Sent Events（SSE）</strong></h4><ul><li>后端主动向前端推送事件流。</li><li>单向通信（后端 → 前端）。</li><li>适用于消息通知、实时数据更新。</li></ul><h4 id="4-GraphQL"><a href="#4-GraphQL" class="headerlink" title="4. GraphQL"></a>4. <strong>GraphQL</strong></h4><ul><li>前端发送一个查询请求，后端根据查询返回精确的数据。</li><li>相比 REST，可以减少冗余数据传输。</li></ul><hr><h3 id="三、前后端响应示例"><a href="#三、前后端响应示例" class="headerlink" title="三、前后端响应示例"></a><strong>三、前后端响应示例</strong></h3><p><strong>前端（JavaScript fetch）</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/users&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;网络错误&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;用户数据:&quot;</span>, data);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;请求失败:&quot;</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>后端（Node.js&#x2F;Express）</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/users&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> users = [</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(users);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>前端发起 GET 请求 → 后端返回 JSON → 前端解析 JSON 更新页面。</li></ul><hr><h3 id="四、状态码与响应流程"><a href="#四、状态码与响应流程" class="headerlink" title="四、状态码与响应流程"></a><strong>四、状态码与响应流程</strong></h3><hr><table><thead><tr><th>状态码</th><th>含义</th><th>前端处理方式</th></tr></thead><tbody><tr><td><strong>200 OK</strong></td><td>请求成功</td><td>解析数据并更新 UI</td></tr><tr><td><strong>201 Created</strong></td><td>资源创建成功</td><td>可以跳转或提示成功</td></tr><tr><td><strong>202 Accepted</strong></td><td>请求已接受，但尚未处理</td><td>提示用户等待或轮询任务状态</td></tr><tr><td><strong>204 No Content</strong></td><td>请求成功但无返回内容</td><td>不更新 UI，仅提示成功</td></tr><tr><td><strong>301 Moved Permanently</strong></td><td>资源永久重定向</td><td>前端更新接口地址或自动跳转</td></tr><tr><td><strong>302 Found</strong></td><td>临时重定向</td><td>按响应 Location 跳转</td></tr><tr><td><strong>304 Not Modified</strong></td><td>资源未修改</td><td>使用本地缓存数据</td></tr><tr><td><strong>400 Bad Request</strong></td><td>请求参数错误</td><td>提示用户检查输入</td></tr><tr><td><strong>401 Unauthorized</strong></td><td>未授权</td><td>跳转登录页或请求授权</td></tr><tr><td><strong>403 Forbidden</strong></td><td>没有权限访问资源</td><td>显示无权限提示页</td></tr><tr><td><strong>404 Not Found</strong></td><td>资源不存在</td><td>显示 404 页面或提示数据缺失</td></tr><tr><td><strong>408 Request Timeout</strong></td><td>请求超时</td><td>提示用户网络问题，可重试</td></tr><tr><td><strong>429 Too Many Requests</strong></td><td>请求过多（限流）</td><td>提示用户稍后重试或做降级处理</td></tr><tr><td><strong>500 Internal Server Error</strong></td><td>服务器内部错误</td><td>显示错误提示或允许重试</td></tr><tr><td><strong>502 Bad Gateway</strong></td><td>网关错误</td><td>提示服务器异常，可稍后重试</td></tr><tr><td><strong>503 Service Unavailable</strong></td><td>服务不可用</td><td>提示维护中或稍后重试</td></tr><tr><td><strong>504 Gateway Timeout</strong></td><td>网关超时</td><td>提示网络或服务繁忙，可重试</td></tr></tbody></table><hr><h3 id="RESTful-API-前后端交互状态码处理表"><a href="#RESTful-API-前后端交互状态码处理表" class="headerlink" title="RESTful API 前后端交互状态码处理表"></a><strong>RESTful API 前后端交互状态码处理表</strong></h3><hr><h4 id="🔹-1-表单提交-新增资源"><a href="#🔹-1-表单提交-新增资源" class="headerlink" title="🔹 1. 表单提交 &#x2F; 新增资源"></a>🔹 1. 表单提交 &#x2F; 新增资源</h4><table><thead><tr><th>状态码</th><th>含义</th><th>前端处理方式</th></tr></thead><tbody><tr><td><strong>200 OK</strong></td><td>更新成功</td><td>刷新 UI，提示成功</td></tr><tr><td><strong>201 Created</strong></td><td>创建成功</td><td>跳转到详情页 &#x2F; 弹出成功提示</td></tr><tr><td><strong>400 Bad Request</strong></td><td>参数校验失败</td><td>显示具体错误信息（高亮错误字段）</td></tr><tr><td><strong>401 Unauthorized</strong></td><td>用户未登录</td><td>跳转登录页，带上当前页面路径</td></tr><tr><td><strong>403 Forbidden</strong></td><td>无权限操作</td><td>显示权限不足提示</td></tr><tr><td><strong>409 Conflict</strong></td><td>资源冲突（如重复用户名）</td><td>提示冲突原因，让用户修改输入</td></tr></tbody></table><hr><h4 id="🔹-2-查询-列表-分页"><a href="#🔹-2-查询-列表-分页" class="headerlink" title="🔹 2. 查询 &#x2F; 列表 &#x2F; 分页"></a>🔹 2. 查询 &#x2F; 列表 &#x2F; 分页</h4><table><thead><tr><th>状态码</th><th>含义</th><th>前端处理方式</th></tr></thead><tbody><tr><td><strong>200 OK</strong></td><td>获取成功</td><td>渲染数据表格 &#x2F; 列表</td></tr><tr><td><strong>204 No Content</strong></td><td>请求成功但无数据</td><td>显示「暂无数据」占位符</td></tr><tr><td><strong>400 Bad Request</strong></td><td>查询参数错误</td><td>提示输入条件有误</td></tr><tr><td><strong>404 Not Found</strong></td><td>资源不存在</td><td>显示「未找到结果」</td></tr><tr><td><strong>429 Too Many Requests</strong></td><td>请求过多（限流）</td><td>显示限流提示，延时再试</td></tr></tbody></table><hr><h4 id="🔹-3-文件上传-下载"><a href="#🔹-3-文件上传-下载" class="headerlink" title="🔹 3. 文件上传 &#x2F; 下载"></a>🔹 3. 文件上传 &#x2F; 下载</h4><table><thead><tr><th>状态码</th><th>含义</th><th>前端处理方式</th></tr></thead><tbody><tr><td><strong>200 OK</strong></td><td>成功返回文件 &#x2F; 上传完成</td><td>更新进度条 100%，提示完成</td></tr><tr><td><strong>400 Bad Request</strong></td><td>参数错误（如缺少 file 字段）</td><td>提示用户重新选择文件</td></tr><tr><td><strong>401 Unauthorized</strong></td><td>未登录</td><td>跳转登录，重新上传</td></tr><tr><td><strong>413 Payload Too Large</strong></td><td>文件过大</td><td>提示文件超出限制，限制用户上传大小</td></tr><tr><td><strong>415 Unsupported Media Type</strong></td><td>文件类型不支持</td><td>提示允许的文件格式</td></tr><tr><td><strong>500 Internal Server Error</strong></td><td>服务器错误</td><td>提示用户稍后重试</td></tr></tbody></table><hr><h4 id="🔹-4-系统级错误-异常"><a href="#🔹-4-系统级错误-异常" class="headerlink" title="🔹 4. 系统级错误 &#x2F; 异常"></a>🔹 4. 系统级错误 &#x2F; 异常</h4><table><thead><tr><th>状态码</th><th>含义</th><th>前端处理方式</th></tr></thead><tbody><tr><td><strong>500 Internal Server Error</strong></td><td>服务器内部错误</td><td>弹窗提示「系统异常，请稍后重试」</td></tr><tr><td><strong>502 Bad Gateway</strong></td><td>网关错误</td><td>提示服务异常，可重试</td></tr><tr><td><strong>503 Service Unavailable</strong></td><td>服务不可用（维护 &#x2F; 宕机）</td><td>显示维护页面</td></tr><tr><td><strong>504 Gateway Timeout</strong></td><td>请求超时</td><td>提示「请求超时」并提供「重试」按钮</td></tr></tbody></table><hr><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><hr><h2 id="一、基础命令"><a href="#一、基础命令" class="headerlink" title="一、基础命令"></a><strong>一、基础命令</strong></h2><h3 id="1-文件和目录操作"><a href="#1-文件和目录操作" class="headerlink" title="1. 文件和目录操作"></a>1. 文件和目录操作</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>ls</code></td><td>列出目录内容</td></tr><tr><td><code>cd</code></td><td>切换目录</td></tr><tr><td><code>pwd</code></td><td>查看当前路径</td></tr><tr><td><code>mkdir</code></td><td>创建目录</td></tr><tr><td><code>rm</code></td><td>删除文件&#x2F;目录（<code>-r</code>递归）</td></tr><tr><td><code>cp</code></td><td>复制文件&#x2F;目录</td></tr><tr><td><code>mv</code></td><td>移动或重命名</td></tr><tr><td><code>find</code></td><td>查找文件</td></tr><tr><td><code>locate</code></td><td>快速查找文件（需更新索引）</td></tr></tbody></table><h3 id="2-文件查看与编辑"><a href="#2-文件查看与编辑" class="headerlink" title="2. 文件查看与编辑"></a>2. 文件查看与编辑</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>cat</code></td><td>查看文件内容</td></tr><tr><td><code>less</code> &#x2F; <code>more</code></td><td>分页浏览</td></tr><tr><td><code>head</code> &#x2F; <code>tail</code></td><td>查看开头&#x2F;结尾行</td></tr><tr><td><code>grep</code></td><td>文件内容搜索</td></tr><tr><td><code>wc</code></td><td>统计行数、字数、字符数</td></tr><tr><td><code>vim</code> &#x2F; <code>nano</code></td><td>文本编辑</td></tr></tbody></table><hr><h2 id="二、用户与权限管理"><a href="#二、用户与权限管理" class="headerlink" title="二、用户与权限管理"></a><strong>二、用户与权限管理</strong></h2><h3 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1. 用户管理"></a>1. 用户管理</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>useradd</code></td><td>添加用户</td></tr><tr><td><code>usermod</code></td><td>修改用户</td></tr><tr><td><code>passwd</code></td><td>修改用户密码</td></tr><tr><td><code>userdel</code></td><td>删除用户</td></tr><tr><td><code>id</code></td><td>查看用户信息</td></tr></tbody></table><h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2. 权限管理"></a>2. 权限管理</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>chmod</code></td><td>修改文件权限（数字&#x2F;符号模式）</td></tr><tr><td><code>chown</code></td><td>修改文件所有者</td></tr><tr><td><code>chgrp</code></td><td>修改文件所属组</td></tr><tr><td><code>umask</code></td><td>设置默认权限掩码</td></tr><tr><td><code>sudo</code></td><td>提权执行命令</td></tr></tbody></table><hr><h2 id="三、进程管理"><a href="#三、进程管理" class="headerlink" title="三、进程管理"></a><strong>三、进程管理</strong></h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>ps</code></td><td>查看进程</td></tr><tr><td><code>top</code> &#x2F; <code>htop</code></td><td>动态查看进程和资源</td></tr><tr><td><code>kill</code> &#x2F; <code>killall</code></td><td>结束进程</td></tr><tr><td><code>nice</code> &#x2F; <code>renice</code></td><td>设置进程优先级</td></tr><tr><td><code>jobs</code> &#x2F; <code>fg</code> &#x2F; <code>bg</code></td><td>作业控制（后台&#x2F;前台）</td></tr></tbody></table><hr><h2 id="四、网络管理"><a href="#四、网络管理" class="headerlink" title="四、网络管理"></a><strong>四、网络管理</strong></h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>ifconfig</code> &#x2F; <code>ip addr</code></td><td>查看网卡IP信息</td></tr><tr><td><code>ping</code></td><td>测试网络连通性</td></tr><tr><td><code>traceroute</code> &#x2F; <code>tracepath</code></td><td>路由跟踪</td></tr><tr><td><code>netstat</code> &#x2F; <code>ss</code></td><td>查看端口&#x2F;连接信息</td></tr><tr><td><code>curl</code> &#x2F; <code>wget</code></td><td>下载文件或访问URL</td></tr><tr><td><code>scp</code> &#x2F; <code>rsync</code></td><td>远程复制文件</td></tr><tr><td><code>iptables</code> &#x2F; <code>firewalld</code></td><td>防火墙管理</td></tr></tbody></table><hr><h2 id="五、包管理"><a href="#五、包管理" class="headerlink" title="五、包管理"></a><strong>五、包管理</strong></h2><ul><li><strong>Debian&#x2F;Ubuntu 系列</strong>：<ul><li><code>apt update</code> &#x2F; <code>apt upgrade</code></li><li><code>apt install &lt;package&gt;</code> &#x2F; <code>apt remove &lt;package&gt;</code></li></ul></li><li><strong>RedHat&#x2F;CentOS 系列</strong>：<ul><li><code>yum install &lt;package&gt;</code> &#x2F; <code>yum remove &lt;package&gt;</code></li><li><code>dnf</code>（新版本替代 yum）</li></ul></li></ul><hr><h2 id="六、磁盘与文件系统管理"><a href="#六、磁盘与文件系统管理" class="headerlink" title="六、磁盘与文件系统管理"></a><strong>六、磁盘与文件系统管理</strong></h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>df -h</code></td><td>查看磁盘空间</td></tr><tr><td><code>du -h</code></td><td>查看目录&#x2F;文件大小</td></tr><tr><td><code>mount</code> &#x2F; <code>umount</code></td><td>挂载&#x2F;卸载分区</td></tr><tr><td><code>lsblk</code></td><td>查看磁盘分区</td></tr><tr><td><code>fdisk</code> &#x2F; <code>parted</code></td><td>分区管理</td></tr><tr><td><code>mkfs</code></td><td>格式化文件系统</td></tr><tr><td><code>fsck</code></td><td>检查文件系统</td></tr></tbody></table><hr><h2 id="七、日志管理"><a href="#七、日志管理" class="headerlink" title="七、日志管理"></a><strong>七、日志管理</strong></h2><table><thead><tr><th>文件&#x2F;命令</th><th>功能</th></tr></thead><tbody><tr><td><code>/var/log/messages</code></td><td>系统日志</td></tr><tr><td><code>/var/log/syslog</code></td><td>系统事件</td></tr><tr><td><code>/var/log/auth.log</code></td><td>用户登录与认证</td></tr><tr><td><code>journalctl</code></td><td>查看 systemd 日志</td></tr><tr><td><code>dmesg</code></td><td>查看内核启动和硬件日志</td></tr></tbody></table><hr><h2 id="八、系统管理"><a href="#八、系统管理" class="headerlink" title="八、系统管理"></a><strong>八、系统管理</strong></h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>uptime</code></td><td>系统运行时间</td></tr><tr><td><code>uname -a</code></td><td>系统信息</td></tr><tr><td><code>free -h</code></td><td>内存使用</td></tr><tr><td><code>vmstat</code></td><td>系统资源统计</td></tr><tr><td><code>df -h</code></td><td>磁盘使用情况</td></tr><tr><td><code>systemctl</code></td><td>管理服务（启动&#x2F;停止&#x2F;重启）</td></tr><tr><td><code>crontab</code></td><td>定时任务管理</td></tr></tbody></table><hr><h2 id="九、压缩与解压"><a href="#九、压缩与解压" class="headerlink" title="九、压缩与解压"></a><strong>九、压缩与解压</strong></h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>tar -cvf</code> &#x2F; <code>tar -xvf</code></td><td>打包&#x2F;解包</td></tr><tr><td><code>gzip</code> &#x2F; <code>gunzip</code></td><td>压缩&#x2F;解压</td></tr><tr><td><code>zip</code> &#x2F; <code>unzip</code></td><td>压缩&#x2F;解压</td></tr></tbody></table><hr><h2 id="十、Shell-脚本基础（详细版）"><a href="#十、Shell-脚本基础（详细版）" class="headerlink" title="十、Shell 脚本基础（详细版）"></a><strong>十、Shell 脚本基础（详细版）</strong></h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><ul><li><strong>定义变量</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME=<span class="string">&quot;Charlotte&quot;</span></span><br><span class="line">AGE=25</span><br></pre></td></tr></table></figure><ul><li><strong>访问变量</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$NAME</span></span><br></pre></td></tr></table></figure><ul><li><strong>只读变量</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">readonly</span> NAME</span><br></pre></td></tr></table></figure><ul><li><strong>环境变量</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/new/path</span><br></pre></td></tr></table></figure><hr><h3 id="2-条件判断"><a href="#2-条件判断" class="headerlink" title="2. 条件判断"></a>2. 条件判断</h3><ul><li><strong>if 语句</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$AGE</span> -ge 18 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;成年人&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;未成年人&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li><strong>常用条件表达式</strong>：<table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>等于</td></tr><tr><td><code>-ne</code></td><td>不等于</td></tr><tr><td><code>-gt</code></td><td>大于</td></tr><tr><td><code>-lt</code></td><td>小于</td></tr><tr><td><code>-ge</code></td><td>大于等于</td></tr><tr><td><code>-le</code></td><td>小于等于</td></tr><tr><td><code>-f filename</code></td><td>文件存在且为普通文件</td></tr><tr><td><code>-d dirname</code></td><td>目录存在</td></tr><tr><td><code>-x filename</code></td><td>可执行文件</td></tr></tbody></table></li></ul><hr><h3 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3. 循环语句"></a>3. 循环语句</h3><ul><li><strong>for 循环</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 1 2 3 4 5; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第 <span class="variable">$i</span> 次循环&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li><strong>while 循环</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;计数 <span class="variable">$count</span>&quot;</span></span><br><span class="line">    count=$((count+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li><strong>until 循环</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count=1</span><br><span class="line"><span class="keyword">until</span> [ <span class="variable">$count</span> -gt 5 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;计数 <span class="variable">$count</span>&quot;</span></span><br><span class="line">    count=$((count+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">greet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet <span class="string">&quot;Charlotte&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>$1</code> 表示函数传入的第一个参数</li><li><code>$@</code> 表示所有参数</li><li><code>return</code> 返回状态码（0表示成功，非0表示失败）</li></ul><hr><h3 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5. 输入输出"></a>5. 输入输出</h3><ul><li><strong>标准输入&#x2F;输出&#x2F;错误</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span>         <span class="comment"># stdout</span></span><br><span class="line"><span class="built_in">read</span> name            <span class="comment"># stdin</span></span><br><span class="line"><span class="built_in">ls</span> nonexist 2&gt; error.log  <span class="comment"># stderr重定向</span></span><br></pre></td></tr></table></figure><ul><li><strong>管道与重定向</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file.txt | grep <span class="string">&quot;hello&quot;</span> &gt; result.txt</span><br></pre></td></tr></table></figure><hr><h3 id="6-脚本执行权限"><a href="#6-脚本执行权限" class="headerlink" title="6. 脚本执行权限"></a>6. 脚本执行权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x script.sh</span><br><span class="line">./script.sh</span><br></pre></td></tr></table></figure><hr><h3 id="7-实用示例"><a href="#7-实用示例" class="headerlink" title="7. 实用示例"></a>7. 实用示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 统计当前目录下所有文件数</span></span><br><span class="line">count=$(<span class="built_in">ls</span> -l | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前目录文件数量: <span class="variable">$count</span>&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="十一、Linux-面试常问知识点"><a href="#十一、Linux-面试常问知识点" class="headerlink" title="十一、Linux 面试常问知识点"></a><strong>十一、Linux 面试常问知识点</strong></h2><hr><h3 id="1-文件权限与权限管理"><a href="#1-文件权限与权限管理" class="headerlink" title="1. 文件权限与权限管理"></a><strong>1. 文件权限与权限管理</strong></h3><h4 id="核心知识点："><a href="#核心知识点：" class="headerlink" title="核心知识点："></a>核心知识点：</h4><ul><li><strong>权限类型</strong>：读（r）（4）、写（w）（2）、执行（x）（1）</li><li><strong>三类用户</strong>：<ul><li>拥有者（u）</li><li>用户组（g）</li><li>其他用户（o）</li></ul></li><li><strong>权限表示</strong>：<ul><li>符号表示法：<code>rwxr-xr-x</code></li><li>数字表示法：<code>chmod 755 file</code> → 7&#x3D;rw, x; 5&#x3D;r-x; 5&#x3D;r-x</li></ul></li></ul><h4 id="面试常问问题："><a href="#面试常问问题：" class="headerlink" title="面试常问问题："></a>面试常问问题：</h4><ol><li><p><strong>命令 chmod、chown、chgrp 有什么作用？</strong></p><ul><li><code>chmod</code>：修改权限</li><li><code>chown</code>：修改文件所有者</li><li><code>chgrp</code>：修改文件所属组</li></ul></li><li><p><strong>硬链接和软链接区别？</strong></p><table><thead><tr><th>项目</th><th>硬链接</th><th>软链接</th></tr></thead><tbody><tr><td>inode</td><td>相同</td><td>不同</td></tr><tr><td>跨分区</td><td>不行</td><td>可以</td></tr><tr><td>删除原文件</td><td>内容仍存在</td><td>链接失效</td></tr><tr><td>命令</td><td><code>ln source target</code></td><td><code>ln -s source target</code></td></tr></tbody></table></li><li><p><strong>文件描述符和重定向</strong></p><ul><li><code>0</code> stdin, <code>1</code> stdout, <code>2</code> stderr</li><li>示例：<code>command &gt; out.log 2&gt;&amp;1</code> → stdout 和 stderr 都写入 out.log</li></ul></li></ol><hr><h3 id="2-进程与作业管理"><a href="#2-进程与作业管理" class="headerlink" title="2. 进程与作业管理"></a><strong>2. 进程与作业管理</strong></h3><h4 id="核心知识点：-1"><a href="#核心知识点：-1" class="headerlink" title="核心知识点："></a>核心知识点：</h4><ul><li><strong>查看进程</strong>：<ul><li><code>ps aux</code>、<code>top</code>、<code>htop</code></li></ul></li><li><strong>结束进程</strong>：<ul><li><code>kill PID</code>、<code>kill -9 PID</code>、<code>killall process_name</code></li></ul></li><li><strong>后台&#x2F;前台任务</strong>：<ul><li><code>&amp;</code>：后台执行</li><li><code>jobs</code>：查看后台任务</li><li><code>fg %1</code>：切换到前台</li></ul></li><li><strong>优先级</strong>：<ul><li><code>nice</code>、<code>renice</code> 设置 CPU 优先级</li></ul></li></ul><h4 id="面试常问问题：-1"><a href="#面试常问问题：-1" class="headerlink" title="面试常问问题："></a>面试常问问题：</h4><ol><li><p><strong>如何查看端口被哪个进程占用？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :8080</span><br><span class="line">netstat -tulpn | grep 8080</span><br><span class="line">ss -tulpn | grep 8080</span><br></pre></td></tr></table></figure></li><li><p><strong>如何终止占用端口的进程？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="3-文件系统与磁盘管理"><a href="#3-文件系统与磁盘管理" class="headerlink" title="3. 文件系统与磁盘管理"></a><strong>3. 文件系统与磁盘管理</strong></h3><h4 id="核心知识点：-2"><a href="#核心知识点：-2" class="headerlink" title="核心知识点："></a>核心知识点：</h4><ul><li><code>df -h</code> 查看磁盘空间</li><li><code>du -h</code> 查看目录大小</li><li><code>lsblk</code> 查看分区信息</li><li><code>mount / umount</code> 挂载卸载</li><li><code>fdisk / parted</code> 分区</li><li><code>mkfs</code> 格式化文件系统</li><li><code>fsck</code> 检查文件系统</li></ul><h4 id="面试常问问题：-2"><a href="#面试常问问题：-2" class="headerlink" title="面试常问问题："></a>面试常问问题：</h4><ol><li><p><strong>硬链接和软链接在文件系统中有什么区别？</strong></p></li><li><p><strong>如何查看磁盘空间和使用情况？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="built_in">du</span> -sh /path/to/dir</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="4-网络管理"><a href="#4-网络管理" class="headerlink" title="4. 网络管理"></a><strong>4. 网络管理</strong></h3><h4 id="核心知识点：-3"><a href="#核心知识点：-3" class="headerlink" title="核心知识点："></a>核心知识点：</h4><ul><li>查看 IP 地址：<code>ifconfig</code> &#x2F; <code>ip addr</code></li><li>测试连通性：<code>ping</code></li><li>路由追踪：<code>traceroute</code> &#x2F; <code>tracepath</code></li><li>查看端口和连接：<code>netstat</code> &#x2F; <code>ss</code></li><li>下载文件或请求 URL：<code>wget</code> &#x2F; <code>curl</code></li><li>远程文件传输：<code>scp</code> &#x2F; <code>rsync</code></li></ul><h4 id="面试常问问题：-3"><a href="#面试常问问题：-3" class="headerlink" title="面试常问问题："></a>面试常问问题：</h4><ol><li><p><strong>如何查看网卡信息？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure></li><li><p><strong>如何调试网络连通性？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 8.8.8.8</span><br><span class="line">traceroute www.baidu.com</span><br></pre></td></tr></table></figure></li><li><p><strong>如何查看 8080 端口占用？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tulpn | grep 8080</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="5-用户与组管理"><a href="#5-用户与组管理" class="headerlink" title="5. 用户与组管理"></a><strong>5. 用户与组管理</strong></h3><h4 id="核心知识点：-4"><a href="#核心知识点：-4" class="headerlink" title="核心知识点："></a>核心知识点：</h4><ul><li>添加用户：<code>useradd</code></li><li>删除用户：<code>userdel</code></li><li>修改用户：<code>usermod -aG group user</code></li><li>修改密码：<code>passwd user</code></li><li>查看组信息：<code>groups user</code></li><li>提权命令：<code>sudo command</code></li></ul><h4 id="面试常问问题：-4"><a href="#面试常问问题：-4" class="headerlink" title="面试常问问题："></a>面试常问问题：</h4><ol><li><p><strong>如何给用户加入某个组？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG dev user</span><br></pre></td></tr></table></figure></li><li><p><strong>如何限制用户权限？</strong></p><ul><li>使用 <code>chmod</code> 设置文件权限</li><li>使用 <code>sudoers</code> 配置命令权限</li></ul></li></ol><hr><h3 id="6-Shell-脚本基础"><a href="#6-Shell-脚本基础" class="headerlink" title="6. Shell 脚本基础"></a><strong>6. Shell 脚本基础</strong></h3><h4 id="核心知识点：-5"><a href="#核心知识点：-5" class="headerlink" title="核心知识点："></a>核心知识点：</h4><ul><li>变量、条件判断、循环、函数</li><li>管道、重定向、标准输入输出</li><li>常用脚本示例：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *.<span class="built_in">log</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;处理文件: <span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="面试常问问题：-5"><a href="#面试常问问题：-5" class="headerlink" title="面试常问问题："></a>面试常问问题：</h4><ol><li><strong>如何判断文件是否存在？</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;/path/to/file&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件存在&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ol><li><strong>如何统计目录下文件数量？</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count=$(<span class="built_in">ls</span> -l | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$count</span></span><br></pre></td></tr></table></figure><hr><h3 id="7-定时任务（Crontab）"><a href="#7-定时任务（Crontab）" class="headerlink" title="7. 定时任务（Crontab）"></a><strong>7. 定时任务（Crontab）</strong></h3><h4 id="核心知识点：-6"><a href="#核心知识点：-6" class="headerlink" title="核心知识点："></a>核心知识点：</h4><ul><li>查看：<code>crontab -l</code></li><li>编辑：<code>crontab -e</code></li><li>时间格式：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">command</span></span><br><span class="line">分 时 日 月 星期</span><br></pre></td></tr></table></figure><ul><li>示例：每天凌晨 2 点备份</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 * * * /home/user/backup.sh</span><br></pre></td></tr></table></figure><hr><h3 id="8-系统日志"><a href="#8-系统日志" class="headerlink" title="8. 系统日志"></a><strong>8. 系统日志</strong></h3><h4 id="核心知识点：-7"><a href="#核心知识点：-7" class="headerlink" title="核心知识点："></a>核心知识点：</h4><ul><li>常用日志路径：<table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td><code>/var/log/messages</code></td><td>系统事件</td></tr><tr><td><code>/var/log/syslog</code></td><td>系统服务日志</td></tr><tr><td><code>/var/log/auth.log</code></td><td>登录&#x2F;认证日志</td></tr><tr><td><code>/var/log/kern.log</code></td><td>内核日志</td></tr><tr><td><code>journalctl</code></td><td>systemd 日志</td></tr></tbody></table></li><li>查看日志：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/syslog</span><br><span class="line">journalctl -xe</span><br></pre></td></tr></table></figure><hr><h3 id="9-系统管理"><a href="#9-系统管理" class="headerlink" title="9. 系统管理"></a><strong>9. 系统管理</strong></h3><h4 id="核心知识点：-8"><a href="#核心知识点：-8" class="headerlink" title="核心知识点："></a>核心知识点：</h4><ul><li>系统信息：<code>uname -a</code></li><li>内存查看：<code>free -h</code></li><li>CPU&#x2F;资源统计：<code>top</code> &#x2F; <code>vmstat</code></li><li>服务管理：<code>systemctl start/stop/restart/status service</code></li><li>系统启动流程：BIOS → Bootloader → Kernel → init&#x2F;systemd → 多用户模式</li></ul><h4 id="面试常问问题：-6"><a href="#面试常问问题：-6" class="headerlink" title="面试常问问题："></a>面试常问问题：</h4><ol><li><strong>如何查看系统运行时间？</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shelluptime</span><br></pre></td></tr></table></figure><ol><li><strong>如何管理系统服务？</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br><span class="line">systemctl enable nginx</span><br><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><hr><h3 id="10-综合示例（面试题）"><a href="#10-综合示例（面试题）" class="headerlink" title="10. 综合示例（面试题）"></a><strong>10. 综合示例（面试题）</strong></h3><ol><li><strong>如何查找占用 CPU 前 5 的进程？</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux --sort=-%cpu | head -n 6</span><br></pre></td></tr></table></figure><p>   2.<strong>如何查找 1 小时内修改过的文件？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/dir -type f -mmin -60</span><br></pre></td></tr></table></figure><p>   3.<strong>如何将错误日志和输出日志写入同一个文件？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt; all.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>   4.<strong>如何给用户添加 sudo 权限？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG sudo username</span><br></pre></td></tr></table></figure><hr><h1 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h1><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><h3 id="1-DML-Data-Manipulation-Language-—-数据操作"><a href="#1-DML-Data-Manipulation-Language-—-数据操作" class="headerlink" title="1. DML (Data Manipulation Language) — 数据操作"></a>1. DML (Data Manipulation Language) — 数据操作</h3><p>用于操作数据库中的数据。</p><h4 id="1-1-SELECT-查询"><a href="#1-1-SELECT-查询" class="headerlink" title="1.1 SELECT 查询"></a>1.1 SELECT 查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查询指定列，并对结果排序、分页</span><br><span class="line">SELECT column1, column2</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE condition         -- 过滤条件</span><br><span class="line">ORDER BY column DESC    -- 按列排序，可 ASC（升序） 或 DESC （降序）</span><br><span class="line">LIMIT offset, count;    -- 分页查询，offset: 偏移量, count: 返回行数</span><br></pre></td></tr></table></figure><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*), SUM(column), AVG(column), MAX(column), MIN(column)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><h5 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column, COUNT(*)</span><br><span class="line">FROM table_name</span><br><span class="line">GROUP BY column       -- 按 column 分组</span><br><span class="line">HAVING COUNT(*) &gt; 1; -- 分组过滤</span><br></pre></td></tr></table></figure><h5 id="联接查询-JOIN"><a href="#联接查询-JOIN" class="headerlink" title="联接查询 (JOIN)"></a>联接查询 (JOIN)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-- 内连接，只返回两个表中匹配的行</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">INNER JOIN table_b b ON a.id = b.a_id;</span><br><span class="line"></span><br><span class="line">-- 左连接，返回左表所有行及匹配右表的行</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">LEFT JOIN table_b b ON a.id = b.a_id;</span><br><span class="line"></span><br><span class="line">-- 右连接，返回右表所有行及匹配左表的行</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">RIGHT JOIN table_b b ON a.id = b.a_id;</span><br><span class="line"></span><br><span class="line">-- 全连接 (MySQL 不直接支持，用 UNION ALL 模拟)</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">LEFT JOIN table_b b ON a.id = b.a_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">RIGHT JOIN table_b b ON a.id = b.a_id</span><br><span class="line">WHERE a.id IS NULL;</span><br></pre></td></tr></table></figure><p><strong>面试题</strong>：在数据库中null值参与排序的结果？</p><p>​mysql中，作为最小值</p><p>​oracle中，作为最大值</p><p><strong>注意事项</strong>：null值不参与聚合函数</p><p>​_（下划线）：任意<strong>单个</strong>字符</p><p>​%：任意<strong>多个</strong>字符</p><p>between后面跟较小的值，and后面跟较大的值</p><p><strong>面试题</strong>：where和having的区别？</p><p>​where：是分组前过滤，后面不能跟聚合函数</p><p>​having：分组后过滤，后面可以跟聚合函数</p><h4 id="1-2-INSERT-插入"><a href="#1-2-INSERT-插入" class="headerlink" title="1.2 INSERT 插入"></a>1.2 INSERT 插入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 指定列插入</span><br><span class="line">INSERT INTO table_name (column1, column2)</span><br><span class="line">VALUES (value1, value2);</span><br><span class="line"></span><br><span class="line">-- 插入所有列</span><br><span class="line">INSERT INTO table_name</span><br><span class="line">VALUES (value1, value2, ...);</span><br></pre></td></tr></table></figure><hr><h4 id="1-3-UPDATE-更新"><a href="#1-3-UPDATE-更新" class="headerlink" title="1.3 UPDATE 更新"></a>1.3 UPDATE 更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET column1 = value1,</span><br><span class="line">    column2 = value2</span><br><span class="line">WHERE condition;  -- 必须加 WHERE，否则会更新所有行</span><br></pre></td></tr></table></figure><hr><h4 id="1-4-DELETE-删除"><a href="#1-4-DELETE-删除" class="headerlink" title="1.4 DELETE 删除"></a>1.4 DELETE 删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE condition; -- 不加 WHERE 会删除所有行，比 TRUNCATE TABLE 慢</span><br></pre></td></tr></table></figure><hr><h3 id="2-DDL-Data-Definition-Language-—-数据定义"><a href="#2-DDL-Data-Definition-Language-—-数据定义" class="headerlink" title="2. DDL (Data Definition Language) — 数据定义"></a>2. DDL (Data Definition Language) — 数据定义</h3><p>用于创建、修改和删除数据库对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE database_name;</span><br><span class="line"></span><br><span class="line">-- 创建表</span><br><span class="line">CREATE TABLE table_name (</span><br><span class="line">    column1 datatype constraints,</span><br><span class="line">    column2 datatype constraints,</span><br><span class="line">    PRIMARY KEY (column_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 修改表结构</span><br><span class="line">ALTER TABLE table_name ADD column_name datatype;</span><br><span class="line">ALTER TABLE table_name DROP COLUMN column_name;</span><br><span class="line">ALTER TABLE table_name MODIFY COLUMN column_name datatype;</span><br><span class="line"></span><br><span class="line">-- 删除表</span><br><span class="line">DROP TABLE table_name;</span><br><span class="line"></span><br><span class="line">-- 索引操作</span><br><span class="line">CREATE INDEX index_name ON table_name (column_name);</span><br><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><hr><h3 id="3-DCL-Data-Control-Language-—-数据权限控制"><a href="#3-DCL-Data-Control-Language-—-数据权限控制" class="headerlink" title="3. DCL (Data Control Language) — 数据权限控制"></a>3. DCL (Data Control Language) — 数据权限控制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 授权</span><br><span class="line">GRANT privileges ON database.table TO &#x27;user&#x27;@&#x27;host&#x27;;</span><br><span class="line"></span><br><span class="line">GRANT SELECT, INSERT, UPDATE ON db1.table1 TO &#x27;user&#x27;@&#x27;localhost&#x27;;</span><br><span class="line"></span><br><span class="line">-- 举例</span><br><span class="line">-- 给用户 alice 授予对数据库 shop 的所有表的查询权限（只能本机访问）：</span><br><span class="line">GRANT SELECT ON shop.* TO &#x27;alice&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">-- 给用户 bob 授予对所有数据库所有表的全部权限（允许远程访问）：</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;bob&#x27;@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 撤销权限</span><br><span class="line">REVOKE privileges ON database.table FROM &#x27;user&#x27;@&#x27;host&#x27;;</span><br></pre></td></tr></table></figure><hr><h3 id="4-TCL-Transaction-Control-Language-—-事务控制"><a href="#4-TCL-Transaction-Control-Language-—-事务控制" class="headerlink" title="4. TCL (Transaction Control Language) — 事务控制"></a>4. TCL (Transaction Control Language) — 事务控制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION; -- 或 BEGIN;</span><br><span class="line"></span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 回滚事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 设置保存点</span><br><span class="line">SAVEPOINT savepoint_name;</span><br></pre></td></tr></table></figure><hr><h3 id="5-EXPLAIN-查询分析-—-SQL-优化核心工具"><a href="#5-EXPLAIN-查询分析-—-SQL-优化核心工具" class="headerlink" title="5. EXPLAIN 查询分析 — SQL 优化核心工具"></a>5. EXPLAIN 查询分析 — SQL 优化核心工具</h3><p>用于分析 SELECT（或 DML）语句的执行计划，判断是否使用索引，以及优化查询性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM table_name WHERE condition;</span><br></pre></td></tr></table></figure><h4 id="5-1-EXPLAIN-核心字段解析"><a href="#5-1-EXPLAIN-核心字段解析" class="headerlink" title="5.1 EXPLAIN 核心字段解析"></a>5.1 EXPLAIN 核心字段解析</h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>查询序列号，越大优先级越高；相同 id 按顺序执行。</td></tr><tr><td>select_type</td><td>查询类型：SIMPLE, PRIMARY, SUBQUERY, DEPENDENT SUBQUERY, UNION, DERIVED 等。</td></tr><tr><td>table</td><td>正在访问的表名。</td></tr><tr><td>partitions</td><td>匹配的分区信息（如果有分区表）。</td></tr><tr><td>type</td><td>连接类型&#x2F;访问方式，性能从好到差：system → const → eq_ref → ref → range → index → ALL。</td></tr><tr><td>possible_keys</td><td>查询可能使用的索引。</td></tr><tr><td>key</td><td>实际使用的索引，NULL 表示未使用索引。</td></tr><tr><td>key_len</td><td>使用的索引长度（字节），越短越好。</td></tr><tr><td>ref</td><td>表示索引列与哪个列或常量进行比较。</td></tr><tr><td>rows</td><td>MySQL 估计要扫描的行数，越少越好。</td></tr><tr><td>filtered</td><td>WHERE 条件过滤行的百分比，越高越好。</td></tr><tr><td>Extra</td><td>额外信息，重要优化指标：- <code>Using filesort</code>：需要额外排序。- <code>Using temporary</code>：需要临时表处理。- <code>Using index</code>：使用覆盖索引，查询效率高。- <code>Using where</code>：使用 WHERE 条件过滤。- <code>Using index condition</code>：索引条件下推（ICP）。- <code>Using join buffer</code>：连接查询未用索引，使用缓存优化。</td></tr></tbody></table><hr><h4 id="5-2-type-类型说明（访问方式）"><a href="#5-2-type-类型说明（访问方式）" class="headerlink" title="5.2 type 类型说明（访问方式）"></a>5.2 type 类型说明（访问方式）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">system  : 表中只有一行记录，性能极高</span><br><span class="line">const   : 通过主键或唯一索引查找，最多一行</span><br><span class="line">eq_ref   : 对前表每行组合读取一行，用于主键或唯一索引连接</span><br><span class="line">ref      : 非唯一索引等值查找，可能多行</span><br><span class="line">range    : 范围查找，使用索引</span><br><span class="line">index    : 全索引扫描，优于全表扫描</span><br><span class="line">ALL      : 全表扫描，性能最差</span><br></pre></td></tr></table></figure><hr><h4 id="5-3-优化建议"><a href="#5-3-优化建议" class="headerlink" title="5.3 优化建议"></a>5.3 优化建议</h4><ol><li>尽量使用索引，避免 <code>ALL</code> 类型。</li><li>ORDER BY &#x2F; GROUP BY 尽量使用索引列，避免 <code>Using filesort</code> 或 <code>Using temporary</code>。</li><li>覆盖索引（<code>Using index</code>）能显著提高性能。</li><li>对复杂查询，使用 EXPLAIN 分析并调整索引或 SQL 结构。</li><li>对 JOIN 查询，保证连接字段有索引。</li></ol><hr><h3 id="6-DQL-Data-Query-Language"><a href="#6-DQL-Data-Query-Language" class="headerlink" title="6.DQL(Data Query Language)"></a>6.DQL(Data Query Language)</h3><p>它是 SQL 的一个子集，<strong>专门负责数据的查询操作</strong>。</p><hr><h4 id="🔑-特点"><a href="#🔑-特点" class="headerlink" title="🔑 特点"></a>🔑 特点</h4><ul><li>只读，不会修改数据内容</li><li>最核心的语句是 <strong><code>SELECT</code></strong></li><li>结果通常是返回一个 <strong>结果集（Result Set）</strong></li></ul><hr><h4 id="常见-DQL-语句"><a href="#常见-DQL-语句" class="headerlink" title="常见 DQL 语句"></a>常见 DQL 语句</h4><ol><li><p><strong>基本查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>→ 查询表中所有列、所有行的数据。</p></li><li><p><strong>条件查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, salary </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>分组 + 聚合</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure></li><li><p><strong>分页</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>→ 跳过前 20 条，取 10 条。</p></li><li><p><strong>连接查询 (JOIN)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.name, d.dept_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="📚-SQL-分类回顾"><a href="#📚-SQL-分类回顾" class="headerlink" title="📚 SQL 分类回顾"></a>📚 SQL 分类回顾</h3><ul><li><strong>DDL (Data Definition Language)</strong>：定义数据库结构<ul><li><code>CREATE</code>、<code>ALTER</code>、<code>DROP</code></li></ul></li><li><strong>DML (Data Manipulation Language)</strong>：操作数据内容<ul><li><code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code></li></ul></li><li><strong>DQL (Data Query Language)</strong>：查询数据<ul><li><code>SELECT</code></li></ul></li><li><strong>DCL (Data Control Language)</strong>：控制权限<ul><li><code>GRANT</code>、<code>REVOKE</code></li></ul></li><li><strong>TCL (Transaction Control Language)</strong>：事务控制<ul><li><code>COMMIT</code>、<code>ROLLBACK</code>、<code>SAVEPOINT</code></li></ul></li></ul><hr><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><hr><h3 id="🔢-数值函数"><a href="#🔢-数值函数" class="headerlink" title="🔢 数值函数"></a>🔢 数值函数</h3><table><thead><tr><th>函数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>ABS(x)</code></td><td>绝对值</td><td><code>ABS(-10) = 10</code></td></tr><tr><td><code>CEIL(x)</code> &#x2F; <code>CEILING(x)</code></td><td>向上取整</td><td><code>CEIL(4.2) = 5</code></td></tr><tr><td><code>FLOOR(x)</code></td><td>向下取整</td><td><code>FLOOR(4.8) = 4</code></td></tr><tr><td><code>ROUND(x, d)</code></td><td>四舍五入，保留 d 位小数</td><td><code>ROUND(3.14159, 2) = 3.14</code></td></tr><tr><td><code>TRUNCATE(x, d)</code></td><td>截断到 d 位小数</td><td><code>TRUNCATE(3.14159, 2) = 3.14</code></td></tr><tr><td><code>MOD(x, y)</code></td><td>取余</td><td><code>MOD(10, 3) = 1</code></td></tr><tr><td><code>RAND()</code></td><td>随机数 [0,1)</td><td><code>RAND()</code> → 0.1234…</td></tr></tbody></table><hr><h3 id="🔤-字符串函数"><a href="#🔤-字符串函数" class="headerlink" title="🔤 字符串函数"></a>🔤 字符串函数</h3><table><thead><tr><th>函数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>CONCAT(s1, s2, …)</code></td><td>拼接字符串</td><td><code>CONCAT(&#39;My&#39;, &#39;SQL&#39;) = &#39;MySQL&#39;</code></td></tr><tr><td><code>CONCAT_WS(sep, s1, s2, …)</code></td><td>用分隔符拼接</td><td><code>CONCAT_WS(&#39;-&#39;, &#39;2025&#39;,&#39;09&#39;,&#39;23&#39;) = &#39;2025-09-23&#39;</code></td></tr><tr><td><code>LENGTH(s)</code></td><td>字节长度</td><td><code>LENGTH(&#39;abc&#39;) = 3</code></td></tr><tr><td><code>CHAR_LENGTH(s)</code></td><td>字符长度</td><td><code>CHAR_LENGTH(&#39;你好&#39;) = 2</code></td></tr><tr><td><code>UPPER(s)</code> &#x2F; <code>UCASE(s)</code></td><td>转大写</td><td><code>UPPER(&#39;abc&#39;) = &#39;ABC&#39;</code></td></tr><tr><td><code>LOWER(s)</code> &#x2F; <code>LCASE(s)</code></td><td>转小写</td><td><code>LOWER(&#39;ABC&#39;) = &#39;abc&#39;</code></td></tr><tr><td><code>SUBSTRING(s, start, len)</code></td><td>截取子串</td><td><code>SUBSTRING(&#39;abcdef&#39;,2,3) = &#39;bcd&#39;</code></td></tr><tr><td><code>LEFT(s, n)</code></td><td>左 n 个字符</td><td><code>LEFT(&#39;abcdef&#39;,3) = &#39;abc&#39;</code></td></tr><tr><td><code>RIGHT(s, n)</code></td><td>右 n 个字符</td><td><code>RIGHT(&#39;abcdef&#39;,3) = &#39;def&#39;</code></td></tr><tr><td><code>REPLACE(s, a, b)</code></td><td>替换子串</td><td><code>REPLACE(&#39;a-b-c&#39;,&#39;-&#39;,&#39;_&#39;) = &#39;a_b_c&#39;</code></td></tr><tr><td><code>TRIM(s)</code></td><td>去掉首尾空格</td><td><code>TRIM(&#39; abc &#39;) = &#39;abc&#39;</code></td></tr><tr><td><code>LTRIM(s)</code> &#x2F; <code>RTRIM(s)</code></td><td>去掉左&#x2F;右空格</td><td><code>LTRIM(&#39; abc&#39;) = &#39;abc&#39;</code></td></tr></tbody></table><hr><h3 id="📅-日期与时间函数"><a href="#📅-日期与时间函数" class="headerlink" title="📅 日期与时间函数"></a>📅 日期与时间函数</h3><table><thead><tr><th>函数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>NOW()</code></td><td>当前日期时间</td><td><code>2025-09-23 11:25:00</code></td></tr><tr><td><code>CURDATE()</code></td><td>当前日期</td><td><code>2025-09-23</code></td></tr><tr><td><code>CURTIME()</code></td><td>当前时间</td><td><code>11:25:00</code></td></tr><tr><td><code>YEAR(d)</code></td><td>获取年份</td><td><code>YEAR(&#39;2025-09-23&#39;) = 2025</code></td></tr><tr><td><code>MONTH(d)</code></td><td>获取月份</td><td><code>MONTH(&#39;2025-09-23&#39;) = 9</code></td></tr><tr><td><code>DAY(d)</code></td><td>获取日</td><td><code>DAY(&#39;2025-09-23&#39;) = 23</code></td></tr><tr><td><code>DATE_ADD(d, INTERVAL n unit)</code></td><td>日期加减</td><td><code>DATE_ADD(&#39;2025-09-23&#39;, INTERVAL 7 DAY) = &#39;2025-09-30&#39;</code></td></tr><tr><td><code>DATEDIFF(d1, d2)</code></td><td>天数差</td><td><code>DATEDIFF(&#39;2025-10-01&#39;,&#39;2025-09-23&#39;) = 8</code></td></tr><tr><td><code>TIMESTAMPDIFF(unit, d1, d2)</code></td><td>时间差</td><td><code>TIMESTAMPDIFF(HOUR,&#39;2025-09-23 10:00&#39;,&#39;2025-09-23 12:00&#39;) = 2</code></td></tr><tr><td><code>STR_TO_DATE(str, format)</code></td><td>字符串转日期</td><td><code>STR_TO_DATE(&#39;2025-09-23&#39;,&#39;%Y-%m-%d&#39;)</code></td></tr><tr><td><code>DATE_FORMAT(d, format)</code></td><td>日期格式化</td><td><code>DATE_FORMAT(NOW(),&#39;%Y/%m/%d&#39;) = &#39;2025/09/23&#39;</code></td></tr></tbody></table><h4 id="🔹-获取当前日期和时间"><a href="#🔹-获取当前日期和时间" class="headerlink" title="🔹 获取当前日期和时间"></a>🔹 获取当前日期和时间</h4><table><thead><tr><th>函数</th><th>说明</th><th>示例</th><th>结果示例</th></tr></thead><tbody><tr><td><code>NOW()</code></td><td>当前日期时间</td><td><code>SELECT NOW();</code></td><td>2025-09-24 15:30:45</td></tr><tr><td><code>CURDATE()</code></td><td>当前日期</td><td><code>SELECT CURDATE();</code></td><td>2025-09-24</td></tr><tr><td><code>CURTIME()</code></td><td>当前时间</td><td><code>SELECT CURTIME();</code></td><td>15:30:45</td></tr><tr><td><code>SYSDATE()</code></td><td>执行到函数时的系统时间</td><td><code>SELECT SYSDATE();</code></td><td>2025-09-24 15:30:46</td></tr><tr><td><code>UTC_DATE()</code></td><td>当前 UTC 日期</td><td><code>SELECT UTC_DATE();</code></td><td>2025-09-24</td></tr><tr><td><code>UTC_TIME()</code></td><td>当前 UTC 时间</td><td><code>SELECT UTC_TIME();</code></td><td>07:30:45</td></tr></tbody></table><hr><h4 id="🔹-格式化与解析"><a href="#🔹-格式化与解析" class="headerlink" title="🔹 格式化与解析"></a>🔹 格式化与解析</h4><table><thead><tr><th>函数</th><th>说明</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>DATE_FORMAT(date, format)</code></td><td>日期 → 字符串</td><td><code>DATE_FORMAT(NOW(), &#39;%Y-%m-%d %H:%i:%s&#39;)</code></td><td>2025-09-24 15:30:45</td></tr><tr><td><code>STR_TO_DATE(str, format)</code></td><td>字符串 → 日期</td><td><code>STR_TO_DATE(&#39;2025-09-24&#39;,&#39;%Y-%m-%d&#39;)</code></td><td>2025-09-24</td></tr></tbody></table><hr><h4 id="🔹-提取日期-时间部分"><a href="#🔹-提取日期-时间部分" class="headerlink" title="🔹 提取日期&#x2F;时间部分"></a>🔹 提取日期&#x2F;时间部分</h4><table><thead><tr><th>函数</th><th>说明</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>YEAR(date)</code></td><td>年份</td><td><code>YEAR(&#39;2025-09-24&#39;)</code></td><td>2025</td></tr><tr><td><code>MONTH(date)</code></td><td>月份</td><td><code>MONTH(&#39;2025-09-24&#39;)</code></td><td>9</td></tr><tr><td><code>DAY(date)</code></td><td>天</td><td><code>DAY(&#39;2025-09-24&#39;)</code></td><td>24</td></tr><tr><td><code>HOUR(time)</code></td><td>小时</td><td><code>HOUR(&#39;15:30:45&#39;)</code></td><td>15</td></tr><tr><td><code>MINUTE(time)</code></td><td>分钟</td><td><code>MINUTE(&#39;15:30:45&#39;)</code></td><td>30</td></tr><tr><td><code>SECOND(time)</code></td><td>秒</td><td><code>SECOND(&#39;15:30:45&#39;)</code></td><td>45</td></tr><tr><td><code>DAYOFWEEK(date)</code></td><td>星期 (1&#x3D;周日)</td><td><code>DAYOFWEEK(&#39;2025-09-24&#39;)</code></td><td>4</td></tr><tr><td><code>WEEKDAY(date)</code></td><td>星期 (0&#x3D;周一)</td><td><code>WEEKDAY(&#39;2025-09-24&#39;)</code></td><td>2</td></tr><tr><td><code>DAYNAME(date)</code></td><td>星期名</td><td><code>DAYNAME(&#39;2025-09-24&#39;)</code></td><td>Wednesday</td></tr><tr><td><code>MONTHNAME(date)</code></td><td>月份名</td><td><code>MONTHNAME(&#39;2025-09-24&#39;)</code></td><td>September</td></tr><tr><td><code>QUARTER(date)</code></td><td>季度</td><td><code>QUARTER(&#39;2025-09-24&#39;)</code></td><td>3</td></tr><tr><td><code>WEEK(date)</code></td><td>周数</td><td><code>WEEK(&#39;2025-09-24&#39;)</code></td><td>39</td></tr><tr><td><code>DAYOFYEAR(date)</code></td><td>一年中的第几天</td><td><code>DAYOFYEAR(&#39;2025-09-24&#39;)</code></td><td>267</td></tr></tbody></table><hr><h4 id="🔹-日期运算"><a href="#🔹-日期运算" class="headerlink" title="🔹 日期运算"></a>🔹 日期运算</h4><table><thead><tr><th>函数</th><th>说明</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>date ± INTERVAL n unit</code></td><td>日期加减</td><td><code>CURDATE() - INTERVAL 1 MONTH</code></td><td>2025-08-24</td></tr><tr><td><code>DATE_ADD(date, INTERVAL n unit)</code></td><td>加</td><td><code>DATE_ADD(&#39;2025-09-24&#39;, INTERVAL 7 DAY)</code></td><td>2025-10-01</td></tr><tr><td><code>DATE_SUB(date, INTERVAL n unit)</code></td><td>减</td><td><code>DATE_SUB(&#39;2025-09-24&#39;, INTERVAL 7 DAY)</code></td><td>2025-09-17</td></tr></tbody></table><p>👉 常见单位：<code>SECOND</code>、<code>MINUTE</code>、<code>HOUR</code>、<code>DAY</code>、<code>WEEK</code>、<code>MONTH</code>、<code>QUARTER</code>、<code>YEAR</code></p><hr><h4 id="🔹-特殊日期函数"><a href="#🔹-特殊日期函数" class="headerlink" title="🔹 特殊日期函数"></a>🔹 特殊日期函数</h4><table><thead><tr><th>函数</th><th>说明</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>LAST_DAY(date)</code></td><td>当月最后一天</td><td><code>LAST_DAY(&#39;2025-09-10&#39;)</code></td><td>2025-09-30</td></tr><tr><td><code>MAKEDATE(year, dayofyear)</code></td><td>构造日期</td><td><code>MAKEDATE(2025, 60)</code></td><td>2025-03-01</td></tr><tr><td><code>MAKETIME(h,m,s)</code></td><td>构造时间</td><td><code>MAKETIME(12,30,45)</code></td><td>12:30:45</td></tr><tr><td><code>ADDDATE(date, INTERVAL n unit)</code></td><td>同 <code>DATE_ADD</code></td><td><code>ADDDATE(&#39;2025-09-24&#39;, INTERVAL 10 DAY)</code></td><td>2025-10-04</td></tr><tr><td><code>SUBDATE(date, INTERVAL n unit)</code></td><td>同 <code>DATE_SUB</code></td><td><code>SUBDATE(&#39;2025-09-24&#39;, INTERVAL 10 DAY)</code></td><td>2025-09-14</td></tr></tbody></table><hr><h4 id="🔹-日期差值"><a href="#🔹-日期差值" class="headerlink" title="🔹 日期差值"></a>🔹 日期差值</h4><table><thead><tr><th>函数</th><th>说明</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>DATEDIFF(d1,d2)</code></td><td>相差天数</td><td><code>DATEDIFF(&#39;2025-09-24&#39;,&#39;2025-09-01&#39;)</code></td><td>23</td></tr><tr><td><code>TIMEDIFF(t1,t2)</code></td><td>相差时间</td><td><code>TIMEDIFF(&#39;15:30:45&#39;,&#39;12:00:00&#39;)</code></td><td>03:30:45</td></tr><tr><td><code>TIMESTAMPDIFF(unit,d1,d2)</code></td><td>指定单位的差值</td><td><code>TIMESTAMPDIFF(MONTH,&#39;2025-01-01&#39;,&#39;2025-09-24&#39;)</code></td><td>8</td></tr></tbody></table><hr><h4 id="🔹-时间戳相关"><a href="#🔹-时间戳相关" class="headerlink" title="🔹 时间戳相关"></a>🔹 时间戳相关</h4><table><thead><tr><th>函数</th><th>说明</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>UNIX_TIMESTAMP(date)</code></td><td>日期 → 时间戳</td><td><code>UNIX_TIMESTAMP(&#39;2025-09-24 15:30:45&#39;)</code></td><td>1769307045</td></tr><tr><td><code>FROM_UNIXTIME(ts)</code></td><td>时间戳 → 日期</td><td><code>FROM_UNIXTIME(1769307045)</code></td><td>2025-09-24 15:30:45</td></tr></tbody></table><hr><h3 id="🔍-聚合函数（配合-GROUP-BY）"><a href="#🔍-聚合函数（配合-GROUP-BY）" class="headerlink" title="🔍 聚合函数（配合 GROUP BY）"></a>🔍 聚合函数（配合 <code>GROUP BY</code>）</h3><table><thead><tr><th>函数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>COUNT(*)</code></td><td>统计行数</td><td><code>COUNT(*)</code></td></tr><tr><td><code>SUM(x)</code></td><td>求和</td><td><code>SUM(salary)</code></td></tr><tr><td><code>AVG(x)</code></td><td>平均值</td><td><code>AVG(score)</code></td></tr><tr><td><code>MAX(x)</code></td><td>最大值</td><td><code>MAX(price)</code></td></tr><tr><td><code>MIN(x)</code></td><td>最小值</td><td><code>MIN(price)</code></td></tr></tbody></table><hr><h3 id="🧰-其他常用函数"><a href="#🧰-其他常用函数" class="headerlink" title="🧰 其他常用函数"></a>🧰 其他常用函数</h3><table><thead><tr><th>函数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>IF(condition, a, b)</code></td><td>条件判断</td><td><code>IF(1&gt;0,&#39;yes&#39;,&#39;no&#39;) = &#39;yes&#39;</code></td></tr><tr><td><code>IFNULL(x, y)</code></td><td>空值处理</td><td><code>IFNULL(NULL,&#39;default&#39;) = &#39;default&#39;</code></td></tr><tr><td><code>NULLIF(x, y)</code></td><td>相等返回 NULL</td><td><code>NULLIF(5,5) = NULL</code></td></tr><tr><td><code>CASE WHEN ... THEN ... END</code></td><td>多条件判断</td><td><code>CASE WHEN score&gt;=60 THEN &#39;及格&#39; ELSE &#39;不及格&#39; END</code></td></tr></tbody></table><hr><p>📌 总结：</p><ul><li><strong>数值函数</strong> → 数学运算</li><li><strong>字符串函数</strong> → 文本处理</li><li><strong>日期时间函数</strong> → 时间计算</li><li><strong>聚合函数</strong> → 统计分析</li><li><strong>控制函数</strong> → 条件判断</li></ul><hr><h3 id="📌-高频实战题（结合函数使用）"><a href="#📌-高频实战题（结合函数使用）" class="headerlink" title="📌 高频实战题（结合函数使用）"></a>📌 高频实战题（结合函数使用）</h3><h4 id="1-统计某天新增用户数"><a href="#1-统计某天新增用户数" class="headerlink" title="1. 统计某天新增用户数"></a>1. 统计某天新增用户数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> new_users</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">DATE</span>(create_time) <span class="operator">=</span> <span class="string">&#x27;2025-09-23&#x27;</span>;</span><br></pre></td></tr></table></figure><p>👉 用 <code>DATE()</code> 提取日期，配合 <code>COUNT(*)</code>。</p><hr><h4 id="2-提取邮箱后缀（域名部分）"><a href="#2-提取邮箱后缀（域名部分）" class="headerlink" title="2. 提取邮箱后缀（域名部分）"></a>2. 提取邮箱后缀（域名部分）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> email, SUBSTRING_INDEX(email, <span class="string">&#x27;@&#x27;</span>, <span class="number">-1</span>) <span class="keyword">AS</span> domain</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>👉 <code>SUBSTRING_INDEX(str, delim, n)</code>：以分隔符截取，第 <code>-1</code> 表示最后一段。</p><hr><h4 id="3-计算两日期相差月份"><a href="#3-计算两日期相差月份" class="headerlink" title="3. 计算两日期相差月份"></a>3. 计算两日期相差月份</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TIMESTAMPDIFF(<span class="keyword">MONTH</span>, <span class="string">&#x27;2024-01-01&#x27;</span>, <span class="string">&#x27;2025-09-23&#x27;</span>) <span class="keyword">AS</span> diff_months;</span><br></pre></td></tr></table></figure><hr><h4 id="4-获取上个月的第一天和最后一天"><a href="#4-获取上个月的第一天和最后一天" class="headerlink" title="4. 获取上个月的第一天和最后一天"></a>4. 获取上个月的第一天和最后一天</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 上个月第一天</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(CURDATE() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>, <span class="string">&#x27;%Y-%m-01&#x27;</span>) <span class="keyword">AS</span> first_day;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上个月最后一天</span></span><br><span class="line"><span class="keyword">SELECT</span> LAST_DAY(CURDATE() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>) <span class="keyword">AS</span> last_day;</span><br></pre></td></tr></table></figure><hr><h4 id="5-查询成绩等级（CASE）"><a href="#5-查询成绩等级（CASE）" class="headerlink" title="5. 查询成绩等级（CASE）"></a>5. 查询成绩等级（CASE）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, score,</span><br><span class="line">  <span class="keyword">CASE</span> </span><br><span class="line">    <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">THEN</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">75</span> <span class="keyword">THEN</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line">    <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">THEN</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line">    <span class="keyword">ELSE</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> grade</span><br><span class="line"><span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><hr><h4 id="6-统计每天订单数（按日分组）"><a href="#6-统计每天订单数（按日分组）" class="headerlink" title="6. 统计每天订单数（按日分组）"></a>6. 统计每天订单数（按日分组）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">DATE</span>(order_time) <span class="keyword">AS</span> <span class="keyword">day</span>, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="type">DATE</span>(order_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">day</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="7-模拟分页查询（LIMIT）"><a href="#7-模拟分页查询（LIMIT）" class="headerlink" title="7. 模拟分页查询（LIMIT）"></a>7. 模拟分页查询（<code>LIMIT</code>）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> product</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">10</span>, <span class="number">10</span>;  <span class="comment">-- 第 2 页，每页 10 条</span></span><br></pre></td></tr></table></figure><hr><h4 id="8-去重后统计数量（COUNT-DISTINCT-）"><a href="#8-去重后统计数量（COUNT-DISTINCT-）" class="headerlink" title="8. 去重后统计数量（COUNT(DISTINCT)）"></a>8. 去重后统计数量（<code>COUNT(DISTINCT)</code>）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_id) <span class="keyword">AS</span> active_users</span><br><span class="line"><span class="keyword">FROM</span> login_log</span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">DATE</span>(login_time) <span class="operator">=</span> CURDATE();</span><br></pre></td></tr></table></figure><hr><h4 id="9-生成固定长度字符串（左侧补零）"><a href="#9-生成固定长度字符串（左侧补零）" class="headerlink" title="9. 生成固定长度字符串（左侧补零）"></a>9. 生成固定长度字符串（左侧补零）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LPAD(<span class="number">7</span>, <span class="number">5</span>, <span class="string">&#x27;0&#x27;</span>) <span class="keyword">AS</span> padded;  <span class="comment">-- 00007</span></span><br></pre></td></tr></table></figure><hr><h4 id="10-替换手机号中间四位为"><a href="#10-替换手机号中间四位为" class="headerlink" title="10. 替换手机号中间四位为 ****"></a>10. 替换手机号中间四位为 <code>****</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="keyword">LEFT</span>(phone,<span class="number">3</span>), <span class="string">&#x27;****&#x27;</span>, <span class="keyword">RIGHT</span>(phone,<span class="number">4</span>)) <span class="keyword">AS</span> safe_phone</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>面试官喜欢考的往往是 <strong>函数 + 业务场景</strong>，比如：</p><ul><li>“统计近 7 天日活用户数”</li><li>“提取网址的顶级域名”</li><li>“计算下单到发货的平均时间”</li></ul><hr><h2 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务 (Transaction)"></a>事务 (Transaction)</h2><p>事务是一组操作的集合，这些操作要么全部成功，要么全部失败。它具有四大特性 (ACID)。</p><ul><li><strong>ACID 特性：</strong><ol><li><strong>原子性 (Atomicity)</strong>: 事务是最小的执行单位，不可再分割。事务中的所有操作要么全部成功提交，要么全部失败回滚到事务开始前的状态。</li><li><strong>一致性 (Consistency)</strong>: 事务执行前后，数据库的完整性约束 (如主键唯一性、外键约束、检查约束、自定义业务规则 ) 没有被破坏，数据从一个一致性状态转换到另一个一致性状态。</li><li><strong>隔离性 (Isolation)</strong>: 并发执行的事务之间是隔离的，一个事务的执行不应影响其他事务的执行，反之亦然。事务的中间状态对其他事务是不可见的。</li><li><strong>持久性 (Durability)</strong>: 一旦事务提交，它对数据库中数据的改变就是永久性的，即使系统崩溃也不会丢失。</li></ol></li><li><strong>并发事务带来的问题：</strong><ol><li><strong>脏读 (Dirty Read)</strong>: 一个事务读取了另一个未提交事务的数据。如果这个未提交事务最终回滚，那么之前读取的数据就是“脏数据”。</li><li><strong>不可重复读 (Non-Repeatable Read)</strong>：一个事务在两次相同的查询中，读取到了不同的数据。通常是因为另一个已提交事务对这些数据进行了 UPDATE 或 DELETE 操作。</li><li><strong>幻读 (Phantom Read)</strong>：一个事务在两次相同的查询中，读取到了不同数量的行。通常是因为另一个已提交事务对数据进行了 INSERT 操作，导致第二次查询出现了之前没有的行。</li></ol></li><li><strong>事务隔离级别 (从低到高)：</strong><ol><li><strong>READ UNCOMMITTED (读未提交)：</strong><ul><li>最低的隔离级别。</li><li>允许脏读、不可重复读和幻读。</li><li>性能最高，但数据一致性最差。</li></ul></li><li><strong>READ COMMITTED (读已提交)：</strong><ul><li>解决了脏读问题。一个事务只能看到其他事务已经提交的数据。</li><li>仍然存在不可重复读和幻读问题。</li><li>多数数据库 (如 Oracle, SQL Server) 的默认隔离级别。</li></ul></li><li><strong>REPEATABLE READ (可重复读)：</strong><ul><li>MySQL (InnoDB 存储引擎) 的默认隔离级别。</li><li>解决了脏读和不可重复读问题。在同一个事务中，多次读取同一数据会得到相同的结果 (通过 MVCC - 多版本并发控制)。</li><li>仍然可能存在幻读问题 (但在 InnoDB 默认隔离级别下，通过间隙锁解决了大部分幻读问题)。</li></ul></li><li><strong>SERIALIZABLE (串行化):</strong><ul><li>最高的隔离级别。</li><li>完全解决了脏读、不可重复读和幻读问题。</li><li>强制事务串行执行，避免所有并发问题。</li><li>性能最低，因为它牺牲了并发性。</li></ul></li></ol></li></ul><hr><h2 id="索引-Index"><a href="#索引-Index" class="headerlink" title="索引 (Index)"></a>索引 (Index)</h2><p>索引是帮助 MySQL 高效获取数据的数据结构。它类似于书籍的目录，可以快速定位所需数据，而无需扫描整个表。</p><hr><h3 id="1-索引的优缺点"><a href="#1-索引的优缺点" class="headerlink" title="1. 索引的优缺点"></a>1. 索引的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>加快数据检索速度</strong>：通过索引可以直接定位到数据，避免全表扫描。</li><li><strong>减少 I&#x2F;O 次数</strong>：索引结构比数据表小，减少磁盘访问。</li><li><strong>优化分组和排序</strong>：在 <code>GROUP BY</code> 和 <code>ORDER BY</code> 中，可减少 CPU 消耗。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>维护成本</strong>：数据增加、更新或删除时，索引也需要更新。</li><li><strong>占用存储空间</strong>：索引本身也需要占用磁盘。</li><li><strong>写入性能影响</strong>：虽然查询快，但对 <code>INSERT/UPDATE/DELETE</code> 有一定性能开销。</li></ul><hr><h3 id="2-索引底层实现-—-B-树"><a href="#2-索引底层实现-—-B-树" class="headerlink" title="2. 索引底层实现 — B+ 树"></a>2. 索引底层实现 — B+ 树</h3><h4 id="B-树特点"><a href="#B-树特点" class="headerlink" title="B+ 树特点"></a>B+ 树特点</h4><ul><li><strong>数据存储</strong>：所有数据都存储在叶子节点，非叶子节点仅存储键值用于导航。</li><li><strong>叶子节点链表</strong>：方便范围查询和顺序遍历。</li><li><strong>树层高低</strong>：非叶子节点不存储数据，一个节点可存储更多索引键，降低树高度，减少磁盘 I&#x2F;O。</li><li><strong>适合磁盘存储</strong>：节点大小匹配磁盘块大小，最大限度减少磁盘寻道次数。</li></ul><h4 id="常见查找树对比"><a href="#常见查找树对比" class="headerlink" title="常见查找树对比"></a>常见查找树对比</h4><table><thead><tr><th>数据结构</th><th>子节点数</th><th>节点存储内容</th><th>平衡性</th><th>查询复杂度</th><th>范围查询效率</th><th>典型应用场景</th></tr></thead><tbody><tr><td><strong>BST（二叉查找树）</strong></td><td>≤ 2</td><td>一个 key</td><td>不保证平衡，可能退化成链表</td><td>O(log n) ~ O(n)</td><td>一般，需要中序遍历</td><td>基础算法教学，少量数据</td></tr><tr><td><strong>红黑树（RBT）</strong></td><td>≤ 2</td><td>一个 key</td><td>近似平衡（二叉平衡树的一种）</td><td>O(log n)</td><td>一般</td><td>Java HashMap、TreeMap，C++ STL map&#x2F;set</td></tr><tr><td><strong>B 树</strong></td><td>≤ m 个（m 阶 B 树）</td><td>多个 key + 数据</td><td>平衡（所有叶子在同一层）</td><td>O(log n)</td><td>较好，但需要遍历节点内 key</td><td>数据库&#x2F;文件系统索引</td></tr><tr><td><strong>B+ 树</strong></td><td>≤ m 个</td><td>非叶子：索引键；叶子：所有数据</td><td>平衡</td><td>O(log n)</td><td><strong>高效，叶子链表支持顺序扫描</strong></td><td><strong>数据库索引（MySQL InnoDB）、文件系统</strong></td></tr></tbody></table><hr><h4 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h4><ul><li><strong>BST</strong>：结构简单，但可能退化。</li><li><strong>红黑树</strong>：自平衡二叉树，常用于内存数据结构（语言库）。</li><li><strong>B 树</strong>：多路平衡查找树，降低树高，适合磁盘存储。</li><li><strong>B+ 树</strong>：B 树优化版，所有数据在叶子节点，叶子有序链表，范围查询最强 → <strong>数据库最爱</strong>。</li></ul><hr><h4 id="1-为什么不用二叉树（BST）"><a href="#1-为什么不用二叉树（BST）" class="headerlink" title="1. 为什么不用二叉树（BST）"></a>1. 为什么不用二叉树（BST）</h4><ul><li><strong>树高太高</strong>：二叉树每个节点只能存一个 key，1000 万条数据大概需要 23 层，磁盘 I&#x2F;O 次数多。</li><li><strong>容易退化</strong>：如果数据顺序插入，BST 可能退化成链表，最坏情况查找复杂度 O(n)。</li><li><strong>范围查询效率差</strong>：二叉树做范围查询需要递归中序遍历，效率低。</li></ul><p>👉 所以：<strong>二叉树不适合海量数据 + 磁盘存储</strong>。</p><hr><h4 id="2-为什么不用-B-树"><a href="#2-为什么不用-B-树" class="headerlink" title="2. 为什么不用 B 树"></a>2. 为什么不用 B 树</h4><ul><li><strong>数据存储位置问题</strong>：<ul><li>B 树的非叶子节点既存索引，又存数据。</li><li>查找时可能在非叶子节点就结束，也可能到叶子节点，查询路径不稳定。</li></ul></li><li><strong>范围查询效率低</strong>：<ul><li>B 树的数据分散在所有节点上，范围查询需要多次遍历不同节点。</li><li>不能像 B+ 树一样顺着叶子链表扫过去。</li></ul></li></ul><p>👉 所以：<strong>B 树范围查询效率不如 B+ 树</strong>。</p><hr><h4 id="3-为什么选-B-树"><a href="#3-为什么选-B-树" class="headerlink" title="3. 为什么选 B+ 树"></a>3. 为什么选 B+ 树</h4><ul><li><strong>所有数据在叶子节点</strong>：查询路径统一，复杂度稳定 O(log n)。</li><li><strong>非叶子节点只存索引键</strong>：节点更“轻量”，能容纳更多索引键 → 树更矮 → 磁盘 I&#x2F;O 更少。</li><li><strong>叶子节点链表</strong>：支持顺序扫描和范围查询，非常适合数据库的 <code>BETWEEN</code>、排序、聚合操作。</li><li><strong>磁盘友好</strong>：节点大小一般设计成和磁盘页大小一致（如 4KB），一次 I&#x2F;O 就能读出一整块索引，大幅提升效率。</li></ul><p>👉 所以：<strong>B+ 树是数据库索引的最佳选择</strong>。</p><hr><p>✅ <strong>总结速答版</strong>：</p><ul><li>不用二叉树 → 树太高，容易退化，范围查询差。</li><li>不用 B 树 → 数据分散在各层，查询路径不稳定，范围查询差。</li><li>用 B+ 树 → 树矮、查询稳定、范围查询高效、磁盘 I&#x2F;O 少。</li></ul><hr><h3 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3. 索引分类"></a>3. 索引分类</h3><h4 id="3-1-主键索引-Primary-Key-Index"><a href="#3-1-主键索引-Primary-Key-Index" class="headerlink" title="3.1 主键索引 (Primary Key Index)"></a>3.1 主键索引 (Primary Key Index)</h4><ul><li>特殊的唯一索引，一个表只能有一个主键。</li><li>不允许 <code>NULL</code> 值。</li><li>通常是 <strong>聚集索引</strong> (InnoDB 存储引擎)。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> pk_name <span class="keyword">PRIMARY KEY</span> (column_name);</span><br></pre></td></tr></table></figure><h4 id="3-2-唯一索引-Unique-Index"><a href="#3-2-唯一索引-Unique-Index" class="headerlink" title="3.2 唯一索引 (Unique Index)"></a>3.2 唯一索引 (Unique Index)</h4><ul><li>列值必须唯一，但允许多个 <code>NULL</code> 值。</li><li>SQL 示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX idx_name ON table_name (column_name);</span><br></pre></td></tr></table></figure><h4 id="3-3-普通索引-Normal-Index-Non-Unique-Index"><a href="#3-3-普通索引-Normal-Index-Non-Unique-Index" class="headerlink" title="3.3 普通索引 (Normal Index &#x2F; Non-Unique Index)"></a>3.3 普通索引 (Normal Index &#x2F; Non-Unique Index)</h4><ul><li>最基本索引，没有唯一性限制。</li><li>SQL 示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON table_name (column_name);</span><br></pre></td></tr></table></figure><h4 id="3-4-全文索引-Fulltext-Index"><a href="#3-4-全文索引-Fulltext-Index" class="headerlink" title="3.4 全文索引 (Fulltext Index)"></a>3.4 全文索引 (Fulltext Index)</h4><ul><li>用于大文本字段的模糊搜索。</li><li>仅支持 MyISAM 和 InnoDB。</li><li>SQL 示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX idx_name ON table_name (column_name);</span><br></pre></td></tr></table></figure><h4 id="3-5-复合索引-Composite-Multi-Column-Index"><a href="#3-5-复合索引-Composite-Multi-Column-Index" class="headerlink" title="3.5 复合索引 (Composite &#x2F; Multi-Column Index)"></a>3.5 复合索引 (Composite &#x2F; Multi-Column Index)</h4><ul><li>在多列上创建的索引。</li><li><strong>最左前缀原则</strong>：<ul><li>查询条件使用复合索引的第一列，则整个索引可用。</li><li>仅使用非首列，则索引可能无法完全使用。</li></ul></li><li>SQL 示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON table_name (column1, column2, column3);</span><br></pre></td></tr></table></figure><blockquote><p>需要尽量覆盖索引</p></blockquote><hr><h3 id="4-聚集索引与非聚集索引"><a href="#4-聚集索引与非聚集索引" class="headerlink" title="4. 聚集索引与非聚集索引"></a>4. 聚集索引与非聚集索引</h3><h4 id="4-1-聚集索引-Clustered-Index"><a href="#4-1-聚集索引-Clustered-Index" class="headerlink" title="4.1 聚集索引 (Clustered Index)"></a>4.1 聚集索引 (Clustered Index)</h4><ul><li><strong>叶子节点存储完整数据行</strong>。</li><li>一个表只能有一个聚集索引（通常是主键）。</li><li>数据物理顺序与索引逻辑顺序一致。</li><li>查询效率高，无需回表。</li><li>写入影响：插入、更新、删除需要维护物理顺序。</li><li><strong>InnoDB 实现</strong>：<ul><li>主键索引即聚集索引。</li><li>若未定义主键，选择唯一非空索引作为聚集索引；若无，则创建隐藏 6 字节 <code>row_id</code> 作为聚集索引。</li></ul></li></ul><h4 id="4-2-非聚集索引-Non-Clustered-Index"><a href="#4-2-非聚集索引-Non-Clustered-Index" class="headerlink" title="4.2 非聚集索引 (Non-Clustered Index)"></a>4.2 非聚集索引 (Non-Clustered Index)</h4><ul><li><strong>叶子节点存储主键或指向数据行的指针</strong>。</li><li>表可有多个非聚集索引。</li><li>数据物理顺序与索引逻辑顺序无关。</li><li>查询需回表：若查询列不在索引中，需要通过索引找到主键，再通过聚集索引获取完整数据。</li><li><strong>InnoDB 实现</strong>：所有非主键索引都是非聚集索引。</li></ul><hr><h3 id="5-索引优化策略"><a href="#5-索引优化策略" class="headerlink" title="5. 索引优化策略"></a>5. 索引优化策略</h3><h4 id="5-1-创建索引的列选择"><a href="#5-1-创建索引的列选择" class="headerlink" title="5.1 创建索引的列选择"></a>5.1 创建索引的列选择</h4><ul><li><strong>常用列</strong>：<code>WHERE</code>、<code>JOIN</code>、<code>ORDER BY</code> 中频繁使用的列。</li><li><strong>高区分度列</strong>：唯一值多的列更适合建立索引。</li><li><strong>避免</strong>：<ul><li>小表或频繁更新表上的索引。</li><li>重复值多的列上建索引。</li></ul></li></ul><h4 id="5-2-遵循最左前缀原则"><a href="#5-2-遵循最左前缀原则" class="headerlink" title="5.2 遵循最左前缀原则"></a>5.2 遵循最左前缀原则</h4><ul><li>对复合索引 <code>(a, b, c)</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHERE a = 1                -&gt; 索引可用</span><br><span class="line">WHERE a = 1 AND b = 2      -&gt; 索引可用</span><br><span class="line">WHERE b = 2                 -&gt; 索引无法完全利用</span><br><span class="line">WHERE c = 3                 -&gt; 索引无法完全利用</span><br></pre></td></tr></table></figure><h4 id="5-3-避免索引失效"><a href="#5-3-避免索引失效" class="headerlink" title="5.3 避免索引失效"></a>5.3 避免索引失效</h4><ul><li><strong>函数或表达式</strong>：如 <code>WHERE YEAR(date_column) = 2023</code></li><li><strong>隐式类型转换</strong>：索引列类型不同于查询值类型</li><li><strong>OR 条件</strong>：除非两边都有索引，且优化器决定合并索引</li><li><strong>左模糊匹配</strong>：<code>LIKE &#39;%keyword&#39;</code></li><li><strong>不等&#x2F;非 IN</strong>：<code>!=</code> 或 <code>NOT IN</code></li></ul><h4 id="5-4-覆盖索引-Covering-Index"><a href="#5-4-覆盖索引-Covering-Index" class="headerlink" title="5.4 覆盖索引 (Covering Index)"></a>5.4 覆盖索引 (Covering Index)</h4><ul><li>查询所需列都在索引中，无需回表：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_in_index</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE indexed_column = value;</span><br></pre></td></tr></table></figure><h4 id="5-5-防止回表"><a href="#5-5-防止回表" class="headerlink" title="5.5 防止回表"></a>5.5 防止回表</h4><ul><li>尽量让 SELECT 列被索引覆盖，或只查询主键。</li></ul><h4 id="5-6-定期维护索引"><a href="#5-6-定期维护索引" class="headerlink" title="5.6 定期维护索引"></a>5.6 定期维护索引</h4><ul><li>重建索引或优化碎片化索引，保持性能稳定。</li></ul><hr><h3 id="📚-MySQL-索引面试题大全"><a href="#📚-MySQL-索引面试题大全" class="headerlink" title="📚 MySQL 索引面试题大全"></a>📚 MySQL 索引面试题大全</h3><h4 id="一、索引基础"><a href="#一、索引基础" class="headerlink" title="一、索引基础"></a>一、索引基础</h4><p><strong>1. 索引的作用是什么？</strong></p><ul><li>索引是帮助数据库高效获取数据的数据结构。</li><li>核心价值：减少磁盘 I&#x2F;O、加快数据检索速度。</li><li>类似书的目录，能快速定位，而不是全本翻。<br> 👉 面试延伸：索引也会带来额外的空间和维护开销。</li></ul><hr><p><strong>2. 聚簇索引和非聚簇索引区别？</strong></p><ul><li>聚簇索引（Clustered Index）：索引和数据存储在一起，叶子节点存储的是<strong>整行数据</strong>。InnoDB 的主键索引就是聚簇索引。</li><li>非聚簇索引（Secondary Index）：叶子节点存储的是主键值，需要回表再查一次主键索引获取数据。<br> 👉 面试延伸：为什么 InnoDB 推荐使用自增主键？因为聚簇索引要求物理数据和主键有序，自增可以减少页分裂。</li></ul><hr><p><strong>3. 覆盖索引是什么？</strong></p><ul><li>定义：索引包含了查询所需的所有字段，避免了回表。</li><li>优点：减少 I&#x2F;O，提高性能。<br> 👉 示例：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>如果有索引 <code>(id, name)</code>，就不用回表。</p><hr><p><strong>4. 最左前缀原则？</strong></p><ul><li>MySQL 的联合索引会优先匹配最左边的列，遇到范围查询就停止。<br> 👉 示例：索引 <code>(a, b, c)</code></li><li>可用 <code>(a)</code>、<code>(a, b)</code>、<code>(a, b, c)</code></li><li>但如果只查 <code>b</code> 或 <code>(b, c)</code>，索引失效。</li></ul><hr><p><strong>5. 索引类型有哪些？</strong></p><ul><li>主键索引（PRIMARY KEY）</li><li>唯一索引（UNIQUE）</li><li>普通索引（INDEX）</li><li>联合索引（组合索引）</li><li>全文索引（FULLTEXT，支持分词检索）</li><li>前缀索引（对长字段取前 N 个字符建立索引）</li></ul><hr><h4 id="二、索引实现原理"><a href="#二、索引实现原理" class="headerlink" title="二、索引实现原理"></a>二、索引实现原理</h4><p><strong>6. 为什么 MySQL 选择 B+ 树实现索引？</strong></p><ul><li>B+ 树高度低，一般 3~4 层即可存百万级数据。</li><li>非叶子节点只存键值，不存数据，能存更多索引键，减少高度。</li><li>叶子节点有链表，方便范围查询和排序。<br> 👉 相比二叉树：二叉树太高，磁盘 I&#x2F;O 过多；相比哈希索引：哈希不支持范围和排序。</li></ul><hr><p><strong>7. B 树和 B+ 树区别？</strong></p><ul><li>B 树：数据存储在叶子节点和非叶子节点，范围查询效率低。</li><li>B+ 树：数据只存叶子节点，非叶子只存键，支持顺序、范围查询。<br> 👉 面试延伸：数据库更看重范围查询性能，因此普遍采用 B+ 树。</li></ul><hr><p><strong>8. 为什么不用二叉树？</strong></p><ul><li>二叉树高度过高，磁盘 I&#x2F;O 次数多。</li><li>插入容易退化成链表。<br> 👉 延伸：即便是平衡二叉树（AVL 树），树高也比 B+ 树高，I&#x2F;O 成本更大。</li></ul><hr><p><strong>9. 为什么不用哈希索引？</strong></p><ul><li>哈希索引只支持等值查询，不支持范围查询、排序。</li><li>哈希冲突处理复杂，分布式扩展性差。<br> 👉 MySQL InnoDB 默认没有哈希索引，但有 <strong>自适应哈希索引 AHI</strong> 来优化热点数据。</li></ul><hr><h4 id="三、索引优化与失效"><a href="#三、索引优化与失效" class="headerlink" title="三、索引优化与失效"></a>三、索引优化与失效</h4><p><strong>10. 哪些情况会导致索引失效？</strong></p><ol><li>条件中对索引字段使用函数或计算，例如 <code>WHERE YEAR(create_time) = 2024</code>。</li><li>使用 <code>%xxx</code> 的模糊匹配（前模糊），<code>LIKE &#39;abc%&#39;</code> 能用，<code>LIKE &#39;%abc&#39;</code> 不能用。</li><li>联合索引未遵守最左前缀原则。</li><li>OR 条件中部分字段无索引。</li><li>数据分布不均，优化器认为全表扫描更快。</li></ol><hr><p><strong>11. 回表是什么？</strong></p><ul><li>使用二级索引时，先定位主键，再去聚簇索引取数据。<br> 👉 代价：多一次磁盘 I&#x2F;O。</li></ul><hr><p><strong>12. 如何避免回表？</strong></p><ul><li>使用覆盖索引。</li><li>在查询中只查索引字段。</li></ul><hr><p><strong>13. 索引下推优化（Index Condition Pushdown, ICP）？</strong></p><ul><li>MySQL 5.6 引入。</li><li>优化器将部分 WHERE 条件下推到存储引擎层，用索引先过滤，减少回表次数。</li></ul><hr><h4 id="四、设计与应用"><a href="#四、设计与应用" class="headerlink" title="四、设计与应用"></a>四、设计与应用</h4><p><strong>14. 主键索引和唯一索引区别？</strong></p><ul><li>主键索引：唯一且不允许 NULL，一个表只能有一个。</li><li>唯一索引：允许多个 NULL，可以存在多个。<br> 👉 面试延伸：性能几乎一致，唯一索引写入时需要额外做唯一性检查。</li></ul><hr><p><strong>15. 多个单列索引和联合索引如何选择？</strong></p><ul><li>单列索引：只能在单一字段上生效。</li><li>联合索引：支持组合查询，更适合实际业务。<br> 👉 MySQL 优化器会尝试索引合并，但性能通常不如联合索引。</li></ul><hr><p><strong>16. 为什么不能给所有字段建索引？</strong></p><ul><li>空间占用大。</li><li>插入、更新、删除代价高（需要维护索引）。</li><li>可能导致优化器选择错误索引，性能下降。</li></ul><hr><p><strong>17. 前缀索引是什么？</strong></p><ul><li>针对长字符串字段（如 URL、邮箱），取前 N 个字符建索引。</li><li>优点：节省存储空间。</li><li>缺点：可能降低选择性，增加重复值。</li></ul><hr><p><strong>18. 索引在 ORDER BY 和 GROUP BY 中的作用？</strong></p><ul><li>如果排序字段和索引顺序一致，可以避免额外排序。</li><li>GROUP BY 同理，索引可以直接支持分组。</li></ul><hr><p><strong>19. Explain 中如何看索引是否生效？</strong></p><ul><li><code>key</code>：实际使用的索引。</li><li><code>possible_keys</code>：可能使用的索引。</li><li><code>rows</code>：扫描的行数，越少越好。</li><li><code>Extra</code>：<ul><li><code>Using index</code> → 覆盖索引。</li><li><code>Using index condition</code> → 索引下推。</li><li><code>Using filesort</code> → 未走索引，需要排序。</li></ul></li></ul><hr><h4 id="五、进阶"><a href="#五、进阶" class="headerlink" title="五、进阶"></a>五、进阶</h4><p><strong>20. 唯一索引 vs 普通索引查询性能差异？</strong></p><ul><li>查询性能几乎一致。</li><li>插入&#x2F;更新时唯一索引要多做一次唯一性检查，代价略高。</li></ul><hr><p><strong>21. 主键设计原则？</strong></p><ul><li>尽量短：减少索引存储开销。</li><li>自增或顺序：避免随机主键造成页分裂。</li><li>稳定：不要使用会变的字段做主键。</li></ul><hr><p><strong>22. 什么是自适应哈希索引（AHI）？</strong></p><ul><li>InnoDB 在热点页上自动构建哈希索引。</li><li>提高频繁访问相同数据的效率。</li><li>无需开发者手动干预。</li></ul><hr><p><strong>23. 什么是索引合并？</strong></p><ul><li>MySQL 优化器可以同时使用多个单列索引，例如 <code>WHERE a=1 OR b=2</code>。</li><li>但通常性能不如联合索引。</li></ul><hr><p><strong>24. Explain 中出现 Using index condition？</strong></p><ul><li>表示启用了索引下推（ICP），部分条件在存储引擎层过滤。</li><li>比只在 Server 层过滤更高效。</li></ul><hr><p><strong>25. Hash 索引 vs B+ 树索引对比？</strong></p><ul><li>Hash 索引：等值查询快，不支持范围查询、排序。</li><li>B+ 树索引：支持等值、范围、排序，适合通用场景。<br> 👉 InnoDB 默认用 B+ 树，但有自适应哈希优化。</li></ul><hr><h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><h5 id="📌-什么是回表？"><a href="#📌-什么是回表？" class="headerlink" title="📌 什么是回表？"></a>📌 什么是回表？</h5><p>在 <strong>InnoDB</strong> 里，只有 <strong>聚簇索引（主键索引）</strong> 的叶子节点存放完整的行数据；<br> <strong>二级索引（普通索引&#x2F;唯一索引等）</strong> 的叶子节点只存放了 <strong>主键值</strong>。</p><p>所以：</p><ul><li>如果查询只涉及到索引里的字段 → 可以直接返回结果（覆盖索引）。</li><li>如果查询涉及到索引中没有的字段 → 就必须根据索引里存的主键值，回到 <strong>聚簇索引</strong> 中再查一次完整数据，这个过程就是 <strong>回表</strong>。</li></ul><hr><h5 id="📖-举例"><a href="#📖-举例" class="headerlink" title="📖 举例"></a>📖 举例</h5><p>假设表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    INDEX idx_name(name)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p>现在有查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>MySQL 会先用 <strong>二级索引 <code>idx_name(name)</code></strong> 定位到满足条件的记录，但此索引只保存了 <code>name</code> 和对应的 <code>id</code>。</li><li>因为 <code>age</code> 不在 <code>idx_name</code> 索引中，所以需要根据 <code>id</code> 去主键索引（聚簇索引）里取整行数据。<br> 👉 这个“二次查询”的过程就是 <strong>回表</strong>。</li></ol><hr><h5 id="⚖️-回表的优缺点"><a href="#⚖️-回表的优缺点" class="headerlink" title="⚖️ 回表的优缺点"></a>⚖️ 回表的优缺点</h5><ul><li><strong>优点</strong>：二级索引存储空间小、层高低，能加速定位。</li><li><strong>缺点</strong>：需要额外一次 I&#x2F;O，性能比不上覆盖索引。</li></ul><hr><h5 id="✅-如何避免回表？"><a href="#✅-如何避免回表？" class="headerlink" title="✅ 如何避免回表？"></a>✅ 如何避免回表？</h5><ul><li><p>使用 <strong>覆盖索引</strong>（即查询字段都在索引中）。</p></li><li><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure><p>就不需要回表了，因为 <code>id</code> 和 <code>name</code> 已经在 <code>idx_name</code> 索引里。</p></li></ul><hr><h3 id="索引怎么实现精确定位"><a href="#索引怎么实现精确定位" class="headerlink" title="索引怎么实现精确定位"></a>索引怎么实现精确定位</h3><h4 id="一、B-树的结构特点"><a href="#一、B-树的结构特点" class="headerlink" title="一、B+树的结构特点"></a>一、B+树的结构特点</h4><ol><li><strong>多路平衡查找树</strong>：MySQL（InnoDB）使用的是 <strong>B+树索引</strong>，不同于二叉树，一个节点能存储大量 key。</li><li><strong>非叶子节点</strong>：只存储 <strong>索引键值 + 子节点指针</strong>，不存放真实数据。</li><li><strong>叶子节点</strong>：存放 <strong>完整的数据行（聚簇索引）</strong> 或 <strong>主键值（辅助索引）</strong>，并且通过 <strong>双向链表</strong> 相连，便于范围查询。</li><li><strong>有序性</strong>：索引键在节点内是有序存储的，适合二分查找。</li></ol><hr><h4 id="二、定位过程（精确查找某条记录）"><a href="#二、定位过程（精确查找某条记录）" class="headerlink" title="二、定位过程（精确查找某条记录）"></a>二、定位过程（精确查找某条记录）</h4><p>假设有一张表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY,   -- 聚簇索引</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>索引类型：</p><ul><li><strong>聚簇索引（Clustered Index）</strong>：叶子节点存储整行记录。</li><li><strong>辅助索引（Secondary Index）</strong>：叶子节点存储主键值，再回表查询整行。</li></ul><hr><h5 id="1-精确查找（主键查找）"><a href="#1-精确查找（主键查找）" class="headerlink" title="1. 精确查找（主键查找）"></a>1. 精确查找（主键查找）</h5><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE id = 25;</span><br></pre></td></tr></table></figure><p>定位步骤：</p><ol><li>从 <strong>根节点</strong> 开始，根据 <code>id</code> 值进行二分查找，找到对应的子节点指针。</li><li>进入 <strong>中间节点</strong>，重复二分查找，继续向下。</li><li>进入 <strong>叶子节点</strong>，找到键值 &#x3D; 25 的位置。</li><li>因为是 <strong>聚簇索引</strong>，叶子节点存放了完整行记录，直接返回。</li></ol><hr><h5 id="2-辅助索引查找（非主键查找）"><a href="#2-辅助索引查找（非主键查找）" class="headerlink" title="2. 辅助索引查找（非主键查找）"></a>2. 辅助索引查找（非主键查找）</h5><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE name = &#x27;Tom&#x27;;</span><br></pre></td></tr></table></figure><p>定位步骤：</p><ol><li>进入 <strong>辅助索引 B+树</strong>，从根 → 中间节点 → 叶子节点，找到 <code>name = &#39;Tom&#39;</code> 对应的记录。</li><li>叶子节点存放的不是整行数据，而是 <strong>主键值（id）</strong>。</li><li>根据主键值，再回到 <strong>聚簇索引 B+树</strong> 中，走一次查找过程，定位到整行数据。</li></ol><p>这就是所谓的 <strong>回表</strong>。</p><hr><h4 id="三、为什么能“精确定位”"><a href="#三、为什么能“精确定位”" class="headerlink" title="三、为什么能“精确定位”"></a>三、为什么能“精确定位”</h4><ol><li><strong>有序存储</strong> → 节点内可以二分查找，快速缩小范围。</li><li><strong>树高较低</strong> → InnoDB 一般 3<del>4 层就能存下百万级数据，每次查找只需磁盘 I&#x2F;O 3</del>4 次。</li><li><strong>聚簇索引</strong> → 直接在叶子节点找到完整行，避免额外跳转。</li><li><strong>辅助索引 + 主键索引</strong> → 通过两次 B+树查找，依然能精确定位。</li></ol><hr><h4 id="四、类比理解"><a href="#四、类比理解" class="headerlink" title="四、类比理解"></a>四、类比理解</h4><p>B+树就像一个“图书馆目录”：</p><ul><li><strong>根节点</strong> &#x3D; 图书馆的“目录索引页”</li><li><strong>中间节点</strong> &#x3D; 分区目录</li><li><strong>叶子节点</strong> &#x3D; 书架（放书或者书的编号）</li><li><strong>聚簇索引</strong> &#x3D; 直接找到书本</li><li><strong>辅助索引</strong> &#x3D; 先找到书的编号，再去另一个书架找书</li></ul><hr><p>👉 总结一句：<br> <strong>MySQL 通过 B+树的有序性和分层查找机制，从根节点到叶子节点逐级定位，最终在叶子节点找到目标记录（主键索引直接拿数据，辅助索引还需回表）。</strong></p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/bfe55c106fb1ceb9316542c424cecf9f.png" alt="图片"> </p><hr><h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><p>MySQL 支持多种存储引擎，每种存储引擎在事务支持、锁机制、索引类型、适用场景等方面有所不同。</p><table><thead><tr><th>存储引擎</th><th>特性</th><th>锁机制</th><th>事务支持</th><th>索引类型</th><th>崩溃恢复</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>InnoDB (默认)</strong></td><td>- 支持事务（ACID）- 支持行级锁- 支持外键约束- 支持崩溃恢复- 默认聚集索引- MVCC（多版本并发控制）</td><td>行级锁</td><td>支持</td><td>聚集索引（叶子节点存储数据行）</td><td>支持 redo log &#x2F; undo log</td><td>事务性应用、高并发读写、数据完整性要求高的场景（如电商、金融）</td></tr><tr><td><strong>MyISAM</strong></td><td>- 不支持事务- 不支持外键- 非聚集索引- SELECT COUNT(*) 快</td><td>表级锁</td><td>不支持</td><td>非聚集索引（叶子节点存储数据地址）</td><td>不支持</td><td>只读或读多写少、对事务性要求不高，需要频繁 COUNT(*) 的应用（如日志、数据仓库）</td></tr><tr><td><strong>Memory (HEAP)</strong></td><td>- 数据存储在内存中，速度快- 重启数据丢失</td><td>表级锁</td><td>不支持</td><td>哈希索引（默认，可用 BTREE）</td><td>不支持</td><td>临时表、缓存、快速计算</td></tr><tr><td><strong>Archive</strong></td><td>- 高度压缩，节省空间- 支持高速插入和查询- 不支持更新和删除</td><td>表级锁</td><td>不支持</td><td>非聚集索引</td><td>不支持</td><td>存储历史数据、不常访问的数据仓库</td></tr><tr><td><strong>CSV</strong></td><td>- 数据以 CSV 文件格式存储- 易于与其他应用交换</td><td>表级锁</td><td>不支持</td><td>无索引或简单索引</td><td>不支持</td><td>数据导入导出、交换数据文件</td></tr></tbody></table><hr><h3 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h3><ol><li><strong>InnoDB 逐渐成为默认引擎</strong>：MySQL 5.5 之后，InnoDB 取代 MyISAM，成为事务型应用首选。</li><li><strong>索引和锁机制区别</strong>：<ul><li>行级锁：并发性能高，锁粒度小。</li><li>表级锁：并发性能低，适合读多写少场景。</li></ul></li><li><strong>崩溃恢复</strong>：<ul><li>InnoDB 通过 <strong>redo log</strong> 和 <strong>undo log</strong> 保证数据持久性和事务回滚。</li><li>MyISAM 和 Memory 不支持事务或崩溃恢复。</li></ul></li><li><strong>存储优化选择</strong>：<ul><li>高并发、事务性应用 → <strong>InnoDB</strong></li><li>只读或日志分析 → <strong>MyISAM</strong></li><li>临时计算&#x2F;缓存 → <strong>Memory</strong></li><li>历史归档数据 → <strong>Archive</strong></li><li>数据交换 → <strong>CSV</strong></li></ul></li></ol><h2 id="MVCC（多版本并发控制）："><a href="#MVCC（多版本并发控制）：" class="headerlink" title="MVCC（多版本并发控制）："></a>MVCC（多版本并发控制）：</h2><hr><h3 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a><strong>什么是 MVCC？</strong></h3><p><strong>MVCC</strong>，即<strong>多版本并发控制</strong>，是一种在数据库中用于解决并发访问问题的方法。它不是通过加锁的方式来控制并发，而是通过<strong>为每个事务生成一个数据快照</strong>，让读操作在快照上进行。</p><p>你可以把它想象成一个“时光机”。当一个事务开始时，数据库会为它“拍一张照片”，也就是生成一个数据快照。这个事务的所有读操作都只会看到这个快照里的数据，而不会受到其他并发事务修改的影响。这样，读操作就不需要等待写锁释放，从而实现了<strong>读写分离</strong>，大大提高了并发性能。</p><p>简而言之，MVCC 的核心思想是：</p><ul><li><strong>读不加锁</strong>：读取数据时，直接从数据的历史版本中读取，不需要等待其他事务的写锁。</li><li><strong>写不阻塞读</strong>：写操作修改数据时，会创建一个新的版本，而旧版本依然保留，供其他读事务使用。</li></ul><hr><h3 id="MVCC-的实现原理"><a href="#MVCC-的实现原理" class="headerlink" title="MVCC 的实现原理"></a><strong>MVCC 的实现原理</strong></h3><hr><h4 id="一、MVCC-的概念"><a href="#一、MVCC-的概念" class="headerlink" title="一、MVCC 的概念"></a>一、MVCC 的概念</h4><p><strong>MVCC</strong> 是数据库的一种并发控制方法，它允许多个事务并发读取数据而不会相互阻塞，通过 <strong>保存数据的多个版本</strong> 来实现：</p><ul><li><strong>读操作</strong> 不加锁（<strong>快照读</strong>），可以读取某个时间点的数据。</li><li><strong>写操作</strong> 通过版本号或者 undo log 实现 <strong>写时检测冲突</strong>。</li></ul><p>MVCC 的核心目标是：</p><ol><li>提高 <strong>并发性能</strong>，避免读写操作互相阻塞。</li><li>实现 <strong>事务隔离</strong>，通常用于支持 <strong>可重复读（Repeatable Read）</strong> 或 <strong>读已提交（Read Committed）</strong>。</li></ol><hr><h4 id="二、MVCC-的原理"><a href="#二、MVCC-的原理" class="headerlink" title="二、MVCC 的原理"></a>二、MVCC 的原理</h4><p>MVCC 的核心机制依赖以下几个要点：</p><ol><li><strong>数据版本（version）</strong><ul><li>数据行在更新或删除时不会立即覆盖原数据，而是生成一个新的版本。</li><li>旧版本用于并发事务的快照读取。</li></ul></li><li><strong>事务版本号 &#x2F; 时间戳</strong><ul><li>每个事务都有一个 <strong>开始时间戳</strong> 或 <strong>事务ID</strong>。</li><li>数据行上会记录 <strong>创建版本号（trx_id）</strong> 和 <strong>删除版本号（roll pointer &#x2F; delete_id）</strong>。</li><li>事务读取数据时，会根据版本号判断该版本是否对自己可见。</li></ul></li><li><strong>Undo Log</strong><ul><li>MVCC 在 MySQL&#x2F;InnoDB 中是通过 <strong>undo log</strong> 来存储旧版本数据的。</li><li>当事务需要读取快照数据时，MySQL 会根据 undo log 回溯旧版本。</li></ul></li><li><strong>可见性规则</strong><ul><li>一个事务 T 能看到某条记录，当且仅当：<ol><li>记录的创建时间 &lt;&#x3D; T 的开始时间。</li><li>记录的删除时间 &gt; T 的开始时间（即未被删除，或者删除发生在 T 开始之后）。</li></ol></li></ul></li></ol><hr><h4 id="三、MVCC-的实现（以-MySQL-InnoDB-为例）"><a href="#三、MVCC-的实现（以-MySQL-InnoDB-为例）" class="headerlink" title="三、MVCC 的实现（以 MySQL InnoDB 为例）"></a>三、MVCC 的实现（以 MySQL InnoDB 为例）</h4><h5 id="1-读操作"><a href="#1-读操作" class="headerlink" title="1. 读操作"></a>1. 读操作</h5><h6 id="快照读（Snapshot-Read）"><a href="#快照读（Snapshot-Read）" class="headerlink" title="快照读（Snapshot Read）"></a>快照读（Snapshot Read）</h6><ul><li>不加锁，不阻塞其他事务。</li><li>事务读取的是 <strong>创建时间小于事务启动时间，删除时间大于事务启动时间</strong> 的行版本。</li><li>典型 SQL：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>实际上 InnoDB 会根据 undo log 回溯到事务启动时的数据快照。</li></ul><h6 id="当前读（Current-Read）"><a href="#当前读（Current-Read）" class="headerlink" title="当前读（Current Read）"></a>当前读（Current Read）</h6><ul><li>会读取最新数据，可能加行锁。</li><li>常用于：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><hr><h5 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2. 写操作"></a>2. 写操作</h5><ul><li><strong>写入时会检测冲突</strong>：<ul><li>插入（INSERT）：直接写新版本。</li><li>更新（UPDATE）：创建新版本，同时旧版本保存到 undo log。</li><li>删除（DELETE）：标记删除时间，旧版本留在 undo log。</li></ul></li><li><strong>事务冲突检测</strong><ul><li>InnoDB 的 <strong>重复更新检测</strong>：如果两个事务修改同一行数据，后提交的事务会被阻塞或回滚，保证一致性。</li></ul></li></ul><hr><h5 id="3-版本链（Version-Chain）"><a href="#3-版本链（Version-Chain）" class="headerlink" title="3. 版本链（Version Chain）"></a>3. 版本链（Version Chain）</h5><ul><li>每行数据有一个 <strong>隐藏字段</strong>：<ul><li><code>DB_TRX_ID</code>：记录创建该版本的事务ID</li><li><code>DB_ROLL_PTR</code>：指向 undo log 的上一版本</li></ul></li><li>MVCC 通过版本链回溯，实现 <strong>快照读</strong>。</li></ul><p>示意图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Version3 (最新)  &lt;- trx_id=3</span><br><span class="line">Version2          &lt;- trx_id=2</span><br><span class="line">Version1 (旧)     &lt;- trx_id=1</span><br></pre></td></tr></table></figure><p>事务 2 启动后：</p><ul><li>能看到 Version1</li><li>Version2&#x2F;Version3 对它不可见</li></ul><hr><h4 id="四、事务隔离与-MVCC"><a href="#四、事务隔离与-MVCC" class="headerlink" title="四、事务隔离与 MVCC"></a>四、事务隔离与 MVCC</h4><table><thead><tr><th>隔离级别</th><th>读类型</th><th>可能问题</th><th>MVCC 实现方式</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>当前读</td><td>脏读</td><td>不常用</td></tr><tr><td>READ COMMITTED</td><td>快照读+当前读</td><td>不可重复读</td><td>每次查询创建新快照</td></tr><tr><td>REPEATABLE READ</td><td>快照读</td><td>幻读</td><td>InnoDB 使用 <strong>Next-Key Lock</strong> 避免幻读</td></tr><tr><td>SERIALIZABLE</td><td>当前读</td><td>并发几乎被阻塞</td><td>MVCC + 行锁</td></tr></tbody></table><p><strong>重点</strong>：InnoDB 默认 <strong>可重复读</strong>，MVCC 允许读不阻塞写，提高性能，同时使用 <strong>锁</strong> 避免幻读。</p><hr><h4 id="五、MVCC-的优缺点"><a href="#五、MVCC-的优缺点" class="headerlink" title="五、MVCC 的优缺点"></a>五、MVCC 的优缺点</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ol><li><strong>读不阻塞写，写不阻塞读</strong>，高并发性能好。</li><li>提供事务隔离的快照机制。</li><li>避免死锁的概率比传统两段锁低。</li></ol><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ol><li>需要维护 <strong>undo log</strong> 和 <strong>版本链</strong>，占用额外空间。</li><li>写冲突时仍可能阻塞或回滚。</li><li>回溯版本增加了复杂性和读取成本。</li></ol><hr><h4 id="六、MySQL-中-MVCC-的具体应用"><a href="#六、MySQL-中-MVCC-的具体应用" class="headerlink" title="六、MySQL 中 MVCC 的具体应用"></a>六、MySQL 中 MVCC 的具体应用</h4><ul><li><strong>InnoDB 默认存储引擎</strong> 使用 MVCC。</li><li><strong>Read Committed</strong>：每次查询生成新快照。</li><li><strong>Repeatable Read</strong>：事务启动时生成快照，保证可重复读。</li><li><strong>索引选择</strong>：MVCC 快照读取结合 <strong>聚簇索引</strong> 进行版本回溯。</li><li><strong>优化点</strong>：<ul><li>避免长事务：长事务占用 undo log，会影响版本回溯。</li><li>适当使用 <strong>FOR UPDATE &#x2F; LOCK IN SHARE MODE</strong> 控制写操作。</li></ul></li></ul><hr><h4 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h4><ul><li>MVCC 是通过 <strong>多版本数据</strong> 来解决数据库并发问题的一种机制。</li><li>核心思想：<strong>读不阻塞写，写不阻塞读</strong>。</li><li>MySQL&#x2F;InnoDB 实现主要依赖：<ol><li><code>trx_id</code> + <code>roll pointer</code></li><li><code>undo log</code></li><li>版本链回溯</li></ol></li><li>对事务隔离、性能优化至关重要。</li></ul><hr><h5 id="一、隐藏字段概念"><a href="#一、隐藏字段概念" class="headerlink" title="一、隐藏字段概念"></a>一、隐藏字段概念</h5><p>在 InnoDB 中，为了实现 <strong>MVCC</strong>，每一行数据都会在物理存储中额外维护几个 <strong>隐藏字段（hidden columns）</strong>，用户在 SQL 查询中看不到这些字段，但它们对于事务控制和版本管理至关重要。</p><h5 id="主要隐藏字段："><a href="#主要隐藏字段：" class="headerlink" title="主要隐藏字段："></a>主要隐藏字段：</h5><table><thead><tr><th>字段名</th><th>作用</th></tr></thead><tbody><tr><td><strong>DB_TRX_ID</strong></td><td>记录创建该行版本的事务ID（Transaction ID）</td></tr><tr><td><strong>DB_ROLL_PTR</strong></td><td>指向 undo log 的指针，用于回滚或快照读取旧版本</td></tr><tr><td><strong>DB_ROW_ID</strong> (可选)</td><td>用于唯一标识一行，尤其在没有主键的表中生成的聚簇索引</td></tr></tbody></table><hr><h5 id="二、字段作用详解"><a href="#二、字段作用详解" class="headerlink" title="二、字段作用详解"></a>二、字段作用详解</h5><h6 id="1-DB-TRX-ID"><a href="#1-DB-TRX-ID" class="headerlink" title="1. DB_TRX_ID"></a>1. DB_TRX_ID</h6><ul><li><strong>含义</strong>：创建这条记录的事务 ID。</li><li><strong>类型</strong>：事务 ID（InnoDB 内部自增）。</li><li><strong>作用</strong>：<ul><li>决定这条记录对于某个事务是否可见。</li><li>快照读时会比较事务 ID 与当前事务的开始时间点，判断是否可见。</li></ul></li></ul><p><strong>可见性判断：</strong></p><ul><li>对于事务 T，读取行 R：<ul><li>如果 R.DB_TRX_ID &lt; T.start_trx_id → 可见。</li><li>如果 R.DB_TRX_ID &gt;&#x3D; T.start_trx_id → 不可见（未来事务创建）。</li></ul></li></ul><hr><h6 id="2-DB-ROLL-PTR"><a href="#2-DB-ROLL-PTR" class="headerlink" title="2. DB_ROLL_PTR"></a>2. DB_ROLL_PTR</h6><ul><li><strong>含义</strong>：Undo log 的指针。</li><li><strong>类型</strong>：内存指针或物理 offset。</li><li><strong>作用</strong>：<ul><li>指向上一版本数据，用于生成快照或回滚。</li><li>当事务需要读取某个版本但它已经被修改时，通过 DB_ROLL_PTR 找到旧版本。</li></ul></li></ul><p><strong>示意</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前版本（R） → DB_ROLL_PTR → 上一版本（R_old）</span><br></pre></td></tr></table></figure><ul><li>旧版本存储在 <strong>undo log</strong> 中，不会立即删除。</li></ul><hr><h6 id="3-DB-ROW-ID"><a href="#3-DB-ROW-ID" class="headerlink" title="3. DB_ROW_ID"></a>3. DB_ROW_ID</h6><ul><li><strong>含义</strong>：唯一标识行。</li><li><strong>作用</strong>：<ul><li>如果表没有主键，InnoDB 会自动生成一个 6 字节的隐藏 ROW_ID。</li><li>用于聚簇索引组织和行定位。</li></ul></li></ul><hr><h5 id="三、MVCC-如何利用隐藏字段"><a href="#三、MVCC-如何利用隐藏字段" class="headerlink" title="三、MVCC 如何利用隐藏字段"></a>三、MVCC 如何利用隐藏字段</h5><p>假设有事务 T1 和 T2：</p><ol><li>T1 开始，读取表快照。</li><li>T2 更新一行 R：<ul><li>创建新版本 R_new。</li><li>旧版本 R_old 保存在 undo log。</li><li>R_new.DB_TRX_ID &#x3D; T2 ID</li><li>R_new.DB_ROLL_PTR &#x3D; 指向 R_old</li></ul></li><li>T1 读取同一行：<ul><li>T1 的事务 ID &lt; R_new.DB_TRX_ID → R_new 对 T1 不可见</li><li>使用 DB_ROLL_PTR 找到 R_old → T1 读取旧版本成功</li></ul></li></ol><p><strong>示意图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R_old (trx_id=1)</span><br><span class="line">    ↑</span><br><span class="line"> DB_ROLL_PTR</span><br><span class="line">    |</span><br><span class="line">R_new (trx_id=2)</span><br></pre></td></tr></table></figure><hr><h5 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h5><ul><li><strong>隐藏字段是 MVCC 的核心基础</strong>：<ul><li><code>DB_TRX_ID</code> → 判断可见性</li><li><code>DB_ROLL_PTR</code> → 回溯版本</li><li><code>DB_ROW_ID</code> → 行唯一标识（没有主键时）</li></ul></li><li>用户在 SQL 查询中看不到，但它保证了 <strong>快照读、版本回溯和事务隔离</strong> 的实现。</li></ul><hr><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><h5 id="1️⃣-Read-View-的定义"><a href="#1️⃣-Read-View-的定义" class="headerlink" title="1️⃣ Read View 的定义"></a>1️⃣ Read View 的定义</h5><p><strong>Read View</strong> 是 InnoDB 在执行 <strong>事务的快照读（Snapshot Read）</strong> 时生成的一个“事务可见性快照”，它决定了当前事务在执行查询时 <strong>能看到哪些数据版本</strong>。</p><p>它主要用于 <strong>支持事务隔离级别为 REPEATABLE READ 或 READ COMMITTED 时的多版本并发控制（MVCC）</strong>。</p><p>简单来说：</p><blockquote><p>Read View 就像一副“当前事务看到的数据地图”，告诉事务哪些行是可见的，哪些是不可见的。</p></blockquote><hr><h5 id="2️⃣-Read-View-的生成时机"><a href="#2️⃣-Read-View-的生成时机" class="headerlink" title="2️⃣ Read View 的生成时机"></a>2️⃣ Read View 的生成时机</h5><ul><li><strong>快照读（SELECT …）</strong>：事务在开始执行查询时生成 Read View。</li><li><strong>事务隔离级别 REPEATABLE READ（可重复读）</strong>：<ul><li>第一次读操作生成 Read View。</li><li>在整个事务生命周期内，该 Read View 保持不变，确保 <strong>可重复读</strong>。</li></ul></li><li><strong>事务隔离级别 READ COMMITTED（读已提交）</strong>：<ul><li>每次查询都会生成新的 Read View，确保 <strong>读取的是最新提交的数据</strong>。</li></ul></li></ul><hr><h5 id="3️⃣-Read-View-包含哪些信息"><a href="#3️⃣-Read-View-包含哪些信息" class="headerlink" title="3️⃣ Read View 包含哪些信息"></a>3️⃣ Read View 包含哪些信息</h5><p>一个 Read View 结构体包含以下重要信息（InnoDB 源码 <code>read_view_t</code>）：</p><ol><li><strong>creator_trx_id</strong><ul><li>创建该 Read View 的事务 ID。</li><li>表示哪个事务创建了这个视图。</li></ul></li><li><strong>up_limit_trx_id</strong>（<code>max_trx_id</code>）<ul><li>在创建 Read View 时已知的最大事务 ID。</li><li>所有 <strong>大于等于这个 ID 的事务</strong> 都是不可见的。</li></ul></li><li><strong>low_limit_trx_id</strong>（<code>min_trx_id</code>）<ul><li>在创建 Read View 时仍未提交的最小事务 ID。</li><li>小于该 ID 的事务 <strong>已提交</strong>，可见。</li></ul></li><li><strong>active_trx_ids[]</strong><ul><li>事务创建 Read View 时处于活动状态的事务列表（尚未提交的事务）。</li><li>用于判断某个版本是否属于活跃事务。</li></ul></li></ol><hr><h5 id="4️⃣-Read-View-的工作原理"><a href="#4️⃣-Read-View-的工作原理" class="headerlink" title="4️⃣ Read View 的工作原理"></a>4️⃣ Read View 的工作原理</h5><p>在 InnoDB 中，每行记录都有 <strong>隐藏列</strong> <code>_trx_id</code>（记录创建该行的事务）和 <code>_roll_pointer</code>（指向 undo log 的回滚信息）。</p><p>当一个事务 T1 读取一行记录时，Read View 会判断这个版本是否可见：</p><ol><li><strong>当前事务创建的记录总是可见</strong>。</li><li><strong>已提交事务创建的记录可见</strong>：<ul><li><code>_trx_id &lt; low_limit_trx_id</code> → 已提交 → 可见</li></ul></li><li><strong>未提交事务的记录不可见</strong>：<ul><li><code>_trx_id &gt;= up_limit_trx_id</code> → 未来事务 → 不可见</li><li><code>_trx_id</code> 在 <code>active_trx_ids[]</code> 中 → 活动事务 → 不可见</li></ul></li><li><strong>回滚旧版本</strong>：<ul><li>如果记录当前版本不可见，InnoDB 会通过 <code>_roll_pointer</code> 找到 undo log 中的历史版本，直到找到对当前事务可见的版本。</li></ul></li></ol><hr><h3 id="⚡-示例图解"><a href="#⚡-示例图解" class="headerlink" title="⚡ 示例图解"></a>⚡ 示例图解</h3><p>假设事务 T1 创建了 Read View：</p><table><thead><tr><th>trx_id</th><th>状态</th><th>可见性</th></tr></thead><tbody><tr><td>100</td><td>已提交</td><td>✅ 可见</td></tr><tr><td>101</td><td>活跃中</td><td>❌ 不可见</td></tr><tr><td>102</td><td>已提交</td><td>✅ 可见</td></tr><tr><td>103</td><td>活跃中</td><td>❌ 不可见</td></tr><tr><td>104</td><td>未来事务</td><td>❌ 不可见</td></tr></tbody></table><p>当 T1 执行查询时：</p><ul><li>T1 看到 trx_id 100、102 的数据。</li><li>对于 101、103、104 的数据，需要回滚到历史版本或者不可见。</li></ul><hr><h5 id="5️⃣-Read-View-与-MVCC-的关系"><a href="#5️⃣-Read-View-与-MVCC-的关系" class="headerlink" title="5️⃣ Read View 与 MVCC 的关系"></a>5️⃣ Read View 与 MVCC 的关系</h5><ul><li><strong>MVCC 原理</strong>：通过版本链 + Read View，实现 <strong>非锁定读取</strong>。</li><li><strong>Read View 决定事务可见性</strong>：<ul><li>REPEATABLE READ：保证事务期间读取一致（同一 Read View）。</li><li>READ COMMITTED：每次读创建新 Read View，读取最新已提交数据。</li></ul></li></ul><p><strong>总结</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Read View = 当前事务看到的“历史快照”</span><br><span class="line">每条记录都有 trx_id，Read View 判断可见性</span><br><span class="line">不可见的记录通过 undo log 回滚到可见版本</span><br></pre></td></tr></table></figure><hr><h5 id="6️⃣-小结"><a href="#6️⃣-小结" class="headerlink" title="6️⃣ 小结"></a>6️⃣ 小结</h5><ol><li>Read View 是 InnoDB 支持 MVCC 的核心机制。</li><li>它决定了事务查询时 <strong>哪些行对当前事务可见</strong>。</li><li>包含：<ul><li>创建事务 ID</li><li>活动事务列表</li><li>上下限事务 ID</li></ul></li><li>REPEATABLE READ 与 READ COMMITTED 的差别：<ul><li>REPEATABLE READ → 事务只生成一次 Read View → 可重复读</li><li>READ COMMITTED → 每次查询生成新 Read View → 读取最新数据</li></ul></li><li>不可见版本通过 <strong>undo log</strong> 回滚，保证事务隔离。</li></ol><hr><h3 id="面试题分析"><a href="#面试题分析" class="headerlink" title="面试题分析"></a><strong>面试题分析</strong></h3><h4 id="1-什么是-MVCC？它解决了什么问题？"><a href="#1-什么是-MVCC？它解决了什么问题？" class="headerlink" title="1. 什么是 MVCC？它解决了什么问题？"></a><strong>1. 什么是 MVCC？它解决了什么问题？</strong></h4><p><strong>回答要点：</strong></p><ul><li><strong>概念</strong>：多版本并发控制，通过维护数据历史版本实现并发。</li><li><strong>解决问题</strong>：在数据库隔离级别为**读已提交（RC）<strong>和</strong>可重复读（RR）**时，实现了读写不冲突。它解决了 <strong>读写锁冲突</strong> 和 <strong>脏读</strong> 问题，但无法完全解决幻读。</li><li><strong>核心思想</strong>：读操作读取数据快照，写操作创建新版本。</li></ul><h4 id="2-MVCC-是如何实现可重复读（Repeatable-Read）的？"><a href="#2-MVCC-是如何实现可重复读（Repeatable-Read）的？" class="headerlink" title="2. MVCC 是如何实现可重复读（Repeatable Read）的？"></a><strong>2. MVCC 是如何实现可重复读（Repeatable Read）的？</strong></h4><p><strong>回答要点：</strong></p><ul><li><strong>核心</strong>：<code>Read View</code> 的创建时机。</li><li><strong>可重复读</strong>：事务在第一次读操作时创建 <code>Read View</code>，并且在<strong>整个事务的生命周期内都使用这个 Read View</strong>。这意味着无论事务中执行多少次读，看到的都是同一个数据快照，所以能保证多次读取结果一致。</li><li><strong>读已提交</strong>：相比之下，读已提交的隔离级别是<strong>每次执行读操作时都重新生成一个 Read View</strong>。因此，如果其他事务在两次读操作之间提交了修改，第二次读就能看到新数据，导致不可重复读。</li></ul><h4 id="3-MVCC-能解决幻读吗？"><a href="#3-MVCC-能解决幻读吗？" class="headerlink" title="3. MVCC 能解决幻读吗？"></a><strong>3. MVCC 能解决幻读吗？</strong></h4><p><strong>回答要点：</strong></p><ul><li><strong>部分解决，但不能完全解决。</strong></li><li><strong>幻读（Phantom Read）</strong>：当一个事务在两次查询之间，另一个事务插入了新的数据，导致第一次查询不存在的数据，第二次查询却出现了。</li><li><strong>MVCC 的作用</strong>：MVCC 可以防止<strong>更新幻读</strong>（即一个事务在两次查询之间，另一个事务更新了数据），因为它总是读取事务启动时的快照。</li><li><strong>无法解决</strong>：MVCC 无法完全解决<strong>插入幻读</strong>。例如，事务 A 两次查询 <code>WHERE id &gt; 10</code>，但在两次查询之间，事务 B 插入了一条 <code>id=11</code> 的记录并提交。虽然事务 A 的 <code>Read View</code> 看不到这条新记录，但如果事务 A 执行 <code>UPDATE ... WHERE id &gt; 10</code> 时，它会发现这条新记录并对其加锁，从而更新成功。这会打破可重复读的承诺。</li><li><strong>InnoDB 的解决方案</strong>：InnoDB 数据库在 <code>可重复读</code> 隔离级别下，除了 MVCC，还会结合**间隙锁（Gap Lock）**来彻底解决幻读问题。</li></ul><h4 id="4-Undo-Log-和-Redo-Log-有什么区别？"><a href="#4-Undo-Log-和-Redo-Log-有什么区别？" class="headerlink" title="4. Undo Log 和 Redo Log 有什么区别？"></a><strong>4. Undo Log 和 Redo Log 有什么区别？</strong></h4><p><strong>回答要点：</strong></p><ul><li><strong>Undo Log (回滚日志)</strong>：<ul><li><strong>作用</strong>：用于<strong>回滚事务</strong>和实现 <strong>MVCC</strong>。</li><li><strong>记录内容</strong>：记录的是<strong>数据修改前</strong>的版本。</li><li><strong>生命周期</strong>：在事务提交后，如果数据有其他事务在使用（用于 MVCC），<code>Undo Log</code> 依然保留；如果没有，<code>Undo Log</code> 会被清除。</li></ul></li><li><strong>Redo Log (重做日志)</strong>：<ul><li><strong>作用</strong>：用于保证事务的<strong>持久性</strong>。</li><li><strong>记录内容</strong>：记录的是<strong>数据修改后</strong>的日志，比如“某某页的某某偏移量改成了某某值”。</li><li><strong>生命周期</strong>：在数据同步到磁盘后，<code>Redo Log</code> 就会被清除。</li><li><strong>作用点</strong>：<code>Redo Log</code> 作用于<strong>崩溃恢复</strong>。当数据库发生宕机时，可以根据 <code>Redo Log</code> 将已提交但尚未写入磁盘的数据重新写入，以保证数据不丢失。</li></ul></li></ul><h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><h3 id="1-错误日志-Error-Log"><a href="#1-错误日志-Error-Log" class="headerlink" title="1. 错误日志(Error Log)"></a>1. 错误日志(Error Log)</h3><p>错误日志是MySQL中最基础的日志之一，它记录了mysqld服务器启动、运行和关闭过程中遇到的所有严重错误和警告。</p><ul><li>主要内容：<ul><li>服务器启动和关闭的详细信息。</li><li>运行过程中发生的错误，例如表损坏、无法访问特定文件等。</li><li>事件调度器运行出错时的信息。</li><li>在主从复制架构中，从服务器上启动和关闭复制线程，连接主服务器时发生的错误等。</li></ul></li><li>作用：错误日志是诊断和解决MySQL服务器问题的首要工具。当数据库无法启动或运行异常时，应首先检查此日志。</li><li>配置：默认情况下，错误日志是开启的。其文件名通常为<hostname>.err，位于数据目录(datadir)下。可以通过在my.cnf或my.ini配置文件中设置log_error变量来指定其路径。</li></ul><h3 id="2-查询日志-Query-Log-通用查询日志-General-Query-Log"><a href="#2-查询日志-Query-Log-通用查询日志-General-Query-Log" class="headerlink" title="2. 查询日志(Query Log)&#x2F;通用查询日志(General Query Log)"></a>2. 查询日志(Query Log)&#x2F;通用查询日志(General Query Log)</h3><p>通用查询日志记录了MySQL服务器接收到的每一个客户端连接和执行的每一条SQL语句。</p><ul><li>主要内容：<ul><li>客户端的连接信息，包括连接时间、用户名和主机。</li><li>客户端发送给服务器的所有SQL语句，无论其是否正确执行。</li></ul></li><li>作用：该日志对于数据库的审计和问题排查非常有用，可以精确复现用户的操作序列。然而，由于它会记录所有操作，对系统性能会产生显著影响，并会迅速占用大量磁盘空间。因此，不建议在生产环境中长期开启。</li><li>配置：默认关闭。可以通过设置general_log为ON来启用，并使用general_log_file指定日志文件路径。</li></ul><h3 id="3-慢查询日志-Slow-Query-Log"><a href="#3-慢查询日志-Slow-Query-Log" class="headerlink" title="3. 慢查询日志(Slow Query Log)"></a>3. 慢查询日志(Slow Query Log)</h3><p>慢查询日志用于记录执行时间超过指定阈值的SQL查询语句，是数据库性能优化的关键工具。</p><ul><li>主要内容：<ul><li>执行时间超过long_query_time阈值的SQL语句。</li><li>查询执行时的相关信息，如执行时间、锁定时间、扫描的行数、返回的行数以及执行该查询的用户和主机。</li></ul></li><li>作用：通过分析慢查询日志，开发者和数据库管理员(DBA)可以定位到效率低下的SQL语句，并针对性地进行优化，例如添加索引、改写查询等。</li><li>配置：默认关闭。需在配置文件中设置slow_query_log为ON开启。long_query_time参数用于设定慢查询的时间阈值(单位：秒)，slow_query_log_file用于指定日志文件位置。log_queries_not_using_indexes参数还可以记录未使用索引的查询。</li></ul><h3 id="4-事务日志-Transaction-Log"><a href="#4-事务日志-Transaction-Log" class="headerlink" title="4. 事务日志(Transaction Log)"></a>4. 事务日志(Transaction Log)</h3><hr><p>在 InnoDB 存储引擎中，用户提到的“事务日志”主要由 <strong>重做日志（Redo Log）</strong> 和 <strong>回滚日志（Undo Log）</strong> 两部分组成，它们共同确保事务的 <strong>ACID 特性</strong>（原子性、一致性、隔离性、持久性）。</p><ul><li><strong>重做日志（Redo Log）</strong>：<ul><li><strong>作用</strong>：保障事务的持久性。**Redo Log 记录的是数据修改后的物理变化。**即使事务提交时数据尚未写入磁盘，只要 Redo Log 已经持久化，当数据库发生崩溃时，可以通过重放 Redo Log 来恢复已提交的事务，保证数据不丢失。这一机制被称为 <strong>预写日志（Write-Ahead Logging, WAL）</strong>。</li><li><strong>特点</strong>：Redo Log 以循环写入的方式存储在固定大小的连续物理文件中，写入效率高，便于快速恢复。</li></ul></li><li><strong>回滚日志（Undo Log）</strong>：<ul><li><strong>作用</strong>：保证事务的原子性，同时支持 <strong>多版本并发控制（MVCC）</strong>。Undo Log 记录数据修改前的旧版本信息。当事务需要回滚时，可以利用 Undo Log 将数据恢复到修改前的状态。此外，在 <strong>读已提交（Read Committed）</strong> 或 <strong>可重复读（Repeatable Read）</strong> 隔离级别下，当事务读取被其他未提交事务修改的数据时，也会通过 Undo Log 获取该数据的旧版本，从而实现 <strong>非锁定读</strong>。</li><li><strong>特点</strong>：Undo Log 本质上是<strong>每次修改的“逆操作”记录，逻辑上保留了操作的历史版本。</strong></li></ul></li></ul><hr><h4 id="1️⃣-Redo-Log-文件结构"><a href="#1️⃣-Redo-Log-文件结构" class="headerlink" title="1️⃣ Redo Log 文件结构"></a>1️⃣ Redo Log 文件结构</h4><ul><li>Redo Log 存储在 <strong>日志文件（ib_logfile0、ib_logfile1 等）</strong> 中，通常称为 <strong>循环日志文件</strong>。</li><li>这些日志文件的大小是 <strong>可配置的</strong>（参数 <code>innodb_log_file_size</code>），比如 512MB、1GB，而不是固定 16KB。</li><li>日志写入是顺序追加的，<strong>日志被分成连续的段（Log Block）写入</strong>，然后循环覆盖最老的日志。</li></ul><blockquote><p>⚠️ Redo Log 的“固定大小”指的是整个日志文件固定，而不是单条记录或内部页固定 16KB。</p></blockquote><hr><h4 id="2️⃣-Redo-Log-内部的页（Log-Block）"><a href="#2️⃣-Redo-Log-内部的页（Log-Block）" class="headerlink" title="2️⃣ Redo Log 内部的页（Log Block）"></a>2️⃣ Redo Log 内部的页（Log Block）</h4><ul><li>虽然 InnoDB 内部会把 Redo Log 切分成 <strong>Redo Log Block（一般 512B~1KB）</strong> 作为写入单位，但它 <strong>不是数据页（Data Page）</strong>。</li><li>数据页是 16KB，存储表的数据和索引；而 Redo Log Block 存储 <strong>redo record（操作日志）</strong>。</li></ul><hr><h4 id="3️⃣-Undo-Log-与物理页的关系"><a href="#3️⃣-Undo-Log-与物理页的关系" class="headerlink" title="3️⃣ Undo Log 与物理页的关系"></a>3️⃣ Undo Log 与物理页的关系</h4><ul><li>Undo Log 存储在 <strong>系统表空间或独立表空间</strong> 中，以 <strong>数据页（16KB）</strong> 为基本存储单元。</li><li>因此 Undo Log 与数据页概念一致，可以通过页读写和 Buffer Pool 缓存；而 Redo Log 是顺序写入日志文件，不经过 Buffer Pool。</li></ul><hr><h4 id="✅-总结对比"><a href="#✅-总结对比" class="headerlink" title="✅ 总结对比"></a>✅ 总结对比</h4><table><thead><tr><th>特性</th><th>Redo Log</th><th>Undo Log &#x2F; 数据页</th></tr></thead><tbody><tr><td>存储位置</td><td>日志文件（ib_logfile0&#x2F;1）</td><td>系统表空间 &#x2F; 独立表空间</td></tr><tr><td>写入方式</td><td>顺序写入，循环覆盖</td><td>按页写入 Buffer Pool</td></tr><tr><td>基本单位</td><td>Redo Log Block (~1KB)</td><td>数据页（16KB）</td></tr><tr><td>用途</td><td>持久化事务提交，Crash Recovery</td><td>回滚事务，支持 MVCC</td></tr></tbody></table><hr><p>所以，<strong>Redo Log 文件的“固定大小连续文件”不是 16KB 的物理页</strong>，它是一个大文件，内部有小的写入块（Log Block），而数据页的 16KB 主要是 Undo Log 和表数据使用的。</p><hr><p>是的，在 <strong>InnoDB 存储引擎</strong> 中，<strong>16KB 的数据页（page）通常就是数据库 I&#x2F;O 的最小单位</strong>，但这里有几个关键细节需要注意：</p><hr><h4 id="1️⃣-数据页（Page）概念"><a href="#1️⃣-数据页（Page）概念" class="headerlink" title="1️⃣ 数据页（Page）概念"></a>1️⃣ 数据页（Page）概念</h4><ul><li>InnoDB 将表数据、索引、Undo Log 等组织成 <strong>固定大小的数据页</strong>，默认大小是 <strong>16KB</strong>（可通过 <code>innodb_page_size</code> 配置修改）。</li><li>每个页是数据库读写操作的最小单位。</li></ul><hr><h4 id="2️⃣-数据页与-Buffer-Pool"><a href="#2️⃣-数据页与-Buffer-Pool" class="headerlink" title="2️⃣ 数据页与 Buffer Pool"></a>2️⃣ 数据页与 Buffer Pool</h4><ul><li><strong>Buffer Pool</strong> 是内存中的缓存页池，每次读写操作都基于页进行：<ol><li>读操作：先在 Buffer Pool 查找，如果不在内存，就 <strong>从磁盘读取整页（16KB）</strong> 到内存。</li><li>写操作：先修改 Buffer Pool 中的页，然后通过 <strong>脏页刷新（Flush）</strong> 写回磁盘，刷新粒度也是页。</li></ol></li></ul><blockquote><p>因此，即使只修改了一条 1KB 的记录，InnoDB 也会把包含该记录的 <strong>整个 16KB 页</strong> 作为 I&#x2F;O 单位读写。</p></blockquote><hr><h4 id="3️⃣-数据页与事务日志"><a href="#3️⃣-数据页与事务日志" class="headerlink" title="3️⃣ 数据页与事务日志"></a>3️⃣ 数据页与事务日志</h4><ul><li><strong>Redo Log</strong>：不是按 16KB 页写入，而是 <strong>顺序日志块（Log Block）</strong>，通常 512B~1KB。</li><li><strong>Undo Log</strong>：存储在数据页中（16KB），受 Buffer Pool 管理。</li></ul><hr><h4 id="4️⃣-总结"><a href="#4️⃣-总结" class="headerlink" title="4️⃣ 总结"></a>4️⃣ 总结</h4><ul><li><strong>数据库 I&#x2F;O 的最小单位</strong>：在 InnoDB 中，是 <strong>数据页（16KB）</strong>。</li><li><strong>读操作</strong>：整页读入内存（Buffer Pool）。</li><li><strong>写操作</strong>：修改 Buffer Pool 页 → 脏页 → 写回磁盘。</li><li><strong>Redo Log 写入</strong>：按小日志块顺序写，不受页限制。</li></ul><h3 id="5-二进制日志-Binary-Log-Binlog"><a href="#5-二进制日志-Binary-Log-Binlog" class="headerlink" title="5. 二进制日志(Binary Log&#x2F;Binlog)"></a>5. 二进制日志(Binary Log&#x2F;Binlog)</h3><p>二进制日志是MySQL中功能最强大、用途最广泛的日志之一。它以二进制格式记录了所有修改数据库数据的操作(DML)以及数据定义语言(DDL)的操作，但不包括SELECT和SHOW等不修改数据的查询。</p><ul><li>主要内容：记录了导致数据发生更改的所有事件。根据格式不同，可以记录为SQL语句(STATEMENT格式)、行的变更(ROW格式)或两者的混合(MIXED格式)。</li><li>主要作用：<ul><li>数据恢复(Point-in-Time Recovery)：通过备份的数据文件和之后的二进制日志，可以将数据库恢复到过去的任意一个时间点。</li><li>主从复制(Replication)：在主从架构中，主服务器将二进制日志传送给从服务器，从服务器重放这些日志中的事件，从而实现与主服务器的数据同步。</li></ul></li><li>配置：默认情况下可能关闭，需要通过配置文件中的log_bin选项来启用。启用后，会生成一个索引文件(默认为<hostname>-bin.index)和一系列的二进制日志文件。</li></ul><h3 id="扩展：中继日志-Relay-Log"><a href="#扩展：中继日志-Relay-Log" class="headerlink" title="扩展：中继日志(Relay Log)"></a>扩展：中继日志(Relay Log)</h3><p>在主从复制环境中，还有一个重要的日志类型——中继日志。</p><ul><li>作用：从服务器的I&#x2F;O线程从主服务器获取二进制日志，并将其写入本地的中继日志中。然后，从服务器的SQL线程读取中继日志中的事件，并在从服务器上执行，以实现数据同步。</li><li>特点：中继日志的格式与二进制日志完全相同。它的存在使得从服务器的I&#x2F;O和SQL执行可以解耦，即使在网络不稳定的情况下，只要I&#x2F;O线程将日志拉到本地，SQL线程就可以持续执行。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>日志类型</th><th>主要作用</th><th>生产环境建议</th></tr></thead><tbody><tr><td>错误日志</td><td>记录服务器启停和运行错误</td><td>始终开启</td></tr><tr><td>查询日志</td><td>记录所有连接和SQL语句，用于审计</td><td>默认关闭，仅在调试时短期开启</td></tr><tr><td>慢查询日志</td><td>记录执行缓慢的SQL，用于性能优化</td><td>建议开启</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Redo Log</td><td>保证事务持久性，用于崩溃恢复</td><td>InnoDB引擎核心组件，始终开启</td></tr><tr><td>Undo Log</td><td>保证事务原子性，支持MVCC</td><td>InnoDB引擎核心组件，始终开启</td></tr><tr><td>二进制日志</td><td>数据恢复、主从复制</td><td>强烈建议开启，尤其是需要数据恢复和复制的场景</td></tr><tr><td>中继日志</td><td>主从复制中，从库用于暂存主库的二进制日志</td><td>在从服务器上自动创建和管理</td></tr></tbody></table><h2 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h2><h3 id="1-锁的分类体系"><a href="#1-锁的分类体系" class="headerlink" title="1. 锁的分类体系"></a>1. 锁的分类体系</h3><h4 id="1-1-按锁粒度的层次分类"><a href="#1-1-按锁粒度的层次分类" class="headerlink" title="1.1 按锁粒度的层次分类"></a>1.1 按锁粒度的层次分类</h4><p><strong>表级锁（Table-Level Lock）</strong> 表级锁是最粗粒度的锁机制，一次锁定整个表的所有数据。MyISAM存储引擎主要使用表级锁，其内部维护一个全局的表锁列表。当线程需要访问表时，首先检查表锁状态，如果表已被其他线程以不兼容模式锁定，则当前线程进入等待队列。表级锁的优势在于锁管理开销极小，只需要维护少量的锁对象；缺点是并发度极低，即使访问不同行的操作也会相互阻塞。</p><p><strong>页级锁（Page-Level Lock）</strong> 页级锁锁定数据页，是表级锁和行级锁的折中方案。BDB存储引擎使用页级锁，每个数据页通常包含多条记录。页级锁的实现需要在页头维护锁信息，包括锁模式、持有者信息等。这种锁粒度在空间局部性较好的应用中表现优秀，因为相关的数据通常存储在相邻的页面中。</p><p><strong>行级锁（Row-Level Lock）</strong> 行级锁是最细粒度的锁机制，InnoDB存储引擎的核心特性。行锁的实现依赖于索引结构，实际上锁定的是索引记录而不是数据行本身。当查询没有使用索引时，InnoDB会扫描整个表并对所有记录加锁，退化为类似表锁的行为。行级锁提供最高的并发度，但也带来最大的管理开销。</p><h4 id="1-2-按锁模式的功能分类"><a href="#1-2-按锁模式的功能分类" class="headerlink" title="1.2 按锁模式的功能分类"></a>1.2 按锁模式的功能分类</h4><p><strong>共享锁（Shared Lock, S锁）</strong> 共享锁允许多个事务同时读取同一资源，但阻止任何事务修改该资源。在InnoDB中，共享锁通过在锁对象的type_mode字段中设置LOCK_S标志位来标识。多个共享锁可以并存，这是通过锁兼容性矩阵来判断的。共享锁的获取相对简单，只需要检查是否存在冲突的排他锁。</p><p><strong>排他锁（Exclusive Lock, X锁）</strong> 排他锁提供独占访问，同一时间只能有一个事务持有资源的排他锁。排他锁与任何其他锁都不兼容，包括共享锁和其他排他锁。在InnoDB实现中，排他锁的获取需要等待所有现有的锁释放，这通过等待队列机制来实现。</p><p><strong>意向锁（Intention Lock）</strong> 意向锁是一种表级锁，用于表明事务在表的某些行上持有或即将请求某种类型的锁。意向共享锁（IS）表示事务意图在某些行上获取共享锁，意向排他锁（IX）表示事务意图在某些行上获取排他锁。意向锁的引入大大简化了表级操作的锁冲突检测，避免了遍历所有行锁的开销。</p><h4 id="1-3-按锁算法的实现分类"><a href="#1-3-按锁算法的实现分类" class="headerlink" title="1.3 按锁算法的实现分类"></a>1.3 按锁算法的实现分类</h4><p><strong>记录锁（Record Lock）</strong> 记录锁锁定索引中的一条具体记录，是最基本的行级锁形式。在InnoDB的实现中，记录锁通过在B+树的叶子节点记录上设置锁标记来实现。锁对象中的heap_no字段精确标识被锁定的记录在页面中的位置。记录锁只能防止其他事务修改或删除该记录，但不能防止在该记录前后插入新记录。</p><p><strong>间隙锁（Gap Lock）</strong> 间隙锁锁定索引记录之间的间隙，防止其他事务在该间隙中插入新记录。间隙锁的范围是开区间，不包含边界记录本身。InnoDB通过比较索引键值来确定间隙的边界，对于复合索引，间隙的比较需要考虑所有键值列的组合。间隙锁之间不冲突，多个事务可以同时持有相同间隙的间隙锁。</p><p><strong>临键锁（Next-Key Lock）</strong> 临键锁是记录锁和间隙锁的组合，锁定一个记录以及该记录前面的间隙。这是InnoDB在可重复读隔离级别下的默认锁算法。临键锁有效解决了幻读问题，因为它不仅锁定已存在的记录，还锁定了可能插入新记录的位置。临键锁的范围是左开右闭区间。</p><h3 id="2-InnoDB锁系统的深层实现"><a href="#2-InnoDB锁系统的深层实现" class="headerlink" title="2. InnoDB锁系统的深层实现"></a>2. InnoDB锁系统的深层实现</h3><h4 id="2-1-锁对象的数据结构设计"><a href="#2-1-锁对象的数据结构设计" class="headerlink" title="2.1 锁对象的数据结构设计"></a>2.1 锁对象的数据结构设计</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="type">trx_t</span>* trx;           <span class="comment">// 拥有该锁的事务</span></span><br><span class="line">    UT_LIST_NODE_T(<span class="type">lock_t</span>) trx_locks; <span class="comment">// 事务锁链表节点</span></span><br><span class="line">    <span class="type">dict_table_t</span>* tab_lock; <span class="comment">// 表锁信息</span></span><br><span class="line">    <span class="type">dict_index_t</span>* index;    <span class="comment">// 索引信息</span></span><br><span class="line">    <span class="type">hash_node_t</span> hash;       <span class="comment">// 哈希表节点</span></span><br><span class="line">    ulint type_mode;        <span class="comment">// 锁类型和模式</span></span><br><span class="line">    ulint n_bits;          <span class="comment">// 位图大小</span></span><br><span class="line">    ulint n_granted_locks; <span class="comment">// 已授予的锁数量</span></span><br><span class="line">    ulint n_waiting_locks; <span class="comment">// 等待的锁数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>锁哈希表的设计：</strong> InnoDB使用一个全局的锁哈希表来管理所有的锁对象，哈希函数基于space_id和page_no计算。每个哈希桶包含一个锁对象链表，相同页面的所有锁对象都链接在同一个桶中。这种设计支持快速的锁查找和冲突检测，时间复杂度接近O(1)。</p><p><strong>锁位图的精巧设计：</strong> 对于页面级别的锁管理，InnoDB使用位图来标识页面中哪些记录被锁定。每个记录对应位图中的一位，设置为1表示该记录被锁定。这种压缩表示法大大节省了内存空间，特别是在锁定大量记录时。位图操作使用高效的位运算指令，支持快速的锁状态查询和更新。</p><h4 id="2-2-死锁检测的高级算法"><a href="#2-2-死锁检测的高级算法" class="headerlink" title="2.2 死锁检测的高级算法"></a>2.2 死锁检测的高级算法</h4><p><strong>增量式死锁检测：</strong> InnoDB不是每次都重新构建整个等待图，而是采用增量式检测。当新的等待关系建立时，算法只检查从新等待者开始的路径是否形成环。这种优化大大减少了检测的计算开销，特别是在高并发场景下效果显著。</p><p><strong>死锁检测的优先级调度：</strong> 死锁检测器运行在独立的后台线程中，具有较高的调度优先级。检测频率根据系统负载动态调整：在高并发时增加检测频率，在低负载时降低频率以节省CPU资源。检测器还会维护统计信息，包括死锁发生频率、平均解决时间等，用于系统调优。</p><p><strong>复杂死锁场景的处理：</strong> 实际生产环境中可能出现涉及多个资源类型的复杂死锁，比如同时涉及行锁、表锁、和外键约束锁的死锁。InnoDB的死锁检测器需要构建一个多层次的等待图，包含不同类型的资源节点和等待边。解决这类死锁时，需要考虑不同锁类型的回滚代价。</p><h4 id="2-3-MVCC与锁的深度集成"><a href="#2-3-MVCC与锁的深度集成" class="headerlink" title="2.3 MVCC与锁的深度集成"></a>2.3 MVCC与锁的深度集成</h4><p><strong>ReadView的内部结构：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReadView</span> &#123;</span></span><br><span class="line">    <span class="type">trx_id_t</span> low_limit_id;    <span class="comment">// 生成ReadView时的下一个事务ID</span></span><br><span class="line">    <span class="type">trx_id_t</span> up_limit_id;     <span class="comment">// 生成ReadView时最小的活跃事务ID</span></span><br><span class="line">    <span class="type">trx_id_t</span> creator_trx_id;  <span class="comment">// 创建ReadView的事务ID</span></span><br><span class="line">    <span class="type">trx_ids_t</span> m_ids;          <span class="comment">// 生成ReadView时的活跃事务ID列表</span></span><br><span class="line">    m_low_limit_no;           <span class="comment">// 最大的事务编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>版本可见性的判断算法：</strong> 当事务读取记录时，需要判断记录的某个版本是否对当前事务可见。判断逻辑基于记录的DB_TRX_ID字段和ReadView的信息：如果DB_TRX_ID小于up_limit_id，则该版本对所有事务可见；如果DB_TRX_ID大于等于low_limit_id，则该版本对当前事务不可见；如果DB_TRX_ID在两者之间，则需要检查是否在活跃事务列表中。</p><p><strong>undo log的链式结构：</strong> 每个事务的undo log形成一个链式结构，记录了该事务的所有修改操作。undo log不仅用于事务回滚，还用于MVCC的版本构建。当需要构建某个历史版本时，InnoDB会从当前版本开始，沿着undo log链向前回溯，逐步应用逆向操作直到达到目标版本。</p><h3 id="3-数据库锁的性能优化策略"><a href="#3-数据库锁的性能优化策略" class="headerlink" title="3. 数据库锁的性能优化策略"></a>3. 数据库锁的性能优化策略</h3><h4 id="3-1-锁等待的自适应策略"><a href="#3-1-锁等待的自适应策略" class="headerlink" title="3.1 锁等待的自适应策略"></a>3.1 锁等待的自适应策略</h4><p><strong>等待时间的动态调整：</strong> InnoDB实现了自适应的锁等待策略，根据系统负载和锁竞争情况动态调整等待超时时间。在低负载时延长等待时间以减少不必要的回滚，在高负载时缩短等待时间以快速释放资源。这种策略通过维护系统级的统计信息来实现，包括平均锁持有时间、锁竞争频率等。</p><p><strong>等待队列的优先级管理：</strong> 对于同一资源的多个等待者，InnoDB可以根据事务的重要性、等待时间、资源消耗等因素进行优先级排序。高优先级的事务可以优先获得锁，这对于关键业务操作特别重要。优先级的计算考虑多个维度，包括事务的年龄、修改的数据量、是否为只读事务等。</p><h4 id="3-2-索引设计对锁性能的影响"><a href="#3-2-索引设计对锁性能的影响" class="headerlink" title="3.2 索引设计对锁性能的影响"></a>3.2 索引设计对锁性能的影响</h4><p><strong>覆盖索引与锁范围优化：</strong> 当查询能够通过覆盖索引获取所有需要的数据时，InnoDB只需要在二级索引上加锁，而不需要回表访问聚簇索引。这大大减少了锁的数量和范围，提高了并发性能。覆盖索引的设计需要仔细分析查询模式，将经常一起访问的列组合成复合索引。</p><p><strong>索引前缀长度对锁粒度的影响：</strong> 对于字符串类型的索引，前缀长度的选择直接影响锁的粒度。较短的前缀可能导致多个不同的值映射到相同的索引前缀，从而扩大锁的范围；较长的前缀提供更精确的锁定，但增加了索引的存储开销。最优前缀长度需要在锁粒度和存储效率之间平衡。</p><h4 id="3-3-事务设计对锁性能的优化"><a href="#3-3-事务设计对锁性能的优化" class="headerlink" title="3.3 事务设计对锁性能的优化"></a>3.3 事务设计对锁性能的优化</h4><p><strong>事务边界的精细控制：</strong> 事务边界的设计直接影响锁的持有时间。长事务会长时间持有锁，阻塞其他事务的执行。优化策略包括：将大事务拆分为多个小事务，减少每个事务的锁持有时间；将只读操作和写操作分离，只读操作使用快照读避免加锁；在事务中优先执行可能失败的操作，减少无效锁持有。</p><p><strong>批量操作的锁优化：</strong> 对于批量插入、更新、删除操作，可以采用特殊的锁策略。比如批量插入时可以使用INSERT … ON DUPLICATE KEY UPDATE语法，减少锁冲突；批量更新时可以按照索引顺序进行，避免死锁；批量删除时可以分批进行，避免长时间持有大量锁。</p><h3 id="行锁（Row-Lock）"><a href="#行锁（Row-Lock）" class="headerlink" title="行锁（Row Lock）"></a>行锁（Row Lock）</h3><blockquote><p>InnoDB是MySQL中支持行锁的主要存储引擎：</p><ol><li>当事务需要锁定某行时，InnoDB会在该行对应的索引记录上加锁</li><li>如果没有索引，会锁定整个表（实际是锁定所有行）</li><li>锁信息存储在内存中的哈希表结构中</li></ol></blockquote><h3 id="表锁（Table-Lock）"><a href="#表锁（Table-Lock）" class="headerlink" title="表锁（Table Lock）"></a>表锁（Table Lock）</h3><blockquote><p>MyISAM只支持表级锁</p><ol><li>维护一个全局的表锁队列</li><li>写锁具有更高优先级</li><li>锁信息存储在服务器层面</li></ol></blockquote><h3 id="14、数据库设计的三大范式"><a href="#14、数据库设计的三大范式" class="headerlink" title="14、数据库设计的三大范式"></a>14、数据库设计的三大范式</h3><ol><li><strong>第一范式（1NF）</strong>：字段不可再分。</li><li><strong>第二范式（2NF）</strong>：在 1NF 基础上，非主属性完全依赖于主键。</li><li><strong>第三范式（3NF）</strong>：在 2NF 基础上，非主属性不依赖于其他非主属性。</li></ol><p>11、switch 小括号里的表达式可以是哪些数据类型**</p><ul><li><strong>允许</strong>：<code>byte, short, int, char, enum, String</code>（JDK7+）。</li><li><strong>不允许</strong>：<code>long, float, double, boolean</code>。</li></ul><hr><p><strong>12、数组的特点</strong></p><ul><li>长度固定，不可变。</li><li>元素类型相同，内存连续。</li><li>支持随机访问（下标 O(1)）。</li></ul><hr><p><strong>13、数组的动态创建方式和静态创建方式的区别</strong></p><ul><li>静态初始化：<code>int[] a = &#123;1, 2, 3&#125;;</code>（定义+赋值同时进行）。</li><li>动态初始化：<code>int[] a = new int[3];</code>（只分配空间，值为默认值）。</li></ul><hr><p><strong>14、Java 中的内存划分</strong></p><ul><li><strong>栈</strong>：方法调用、局部变量。</li><li><strong>堆</strong>：对象实例、数组。</li><li><strong>方法区（元空间）</strong>：类信息、常量池、静态变量。</li><li><strong>程序计数器</strong>：线程执行位置。</li><li><strong>本地方法栈</strong>：JNI 调用。</li></ul><p>18、成员变量和局部变量的区别**</p><table><thead><tr><th>对比项</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>定义位置</td><td>类中，方法外</td><td>方法内、参数列表中</td></tr><tr><td>生命周期</td><td>随对象存在</td><td>随方法执行</td></tr><tr><td>默认值</td><td>有默认值</td><td>没有默认值，必须赋值</td></tr><tr><td>修饰符</td><td>可加权限修饰符</td><td>不可加权限修饰符</td></tr></tbody></table><h1 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><hr><h3 id="八个基本数据类型（Primitive-Data-Types）"><a href="#八个基本数据类型（Primitive-Data-Types）" class="headerlink" title="八个基本数据类型（Primitive Data Types）"></a><strong>八个基本数据类型（Primitive Data Types）</strong></h3><p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/image-20250921165944473.png" alt="image-20250921165944473"></p><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a><strong>1. 整型</strong></h4><p>整型用于存储不带小数的整数。Java 提供了四种整型，它们的区别在于所占内存空间的大小，从而影响可存储的数值范围。</p><ul><li><strong>byte</strong><ul><li>大小：1 字节（8 位）</li><li>范围：−128 到 127</li><li>用途：主要用于节省内存，尤其是在处理大量数据时，例如在文件或网络传输中。</li></ul></li><li><strong>short</strong><ul><li>大小：2 字节（16 位）</li><li>范围：−32768 到 32767</li><li>用途：同样用于节省内存，比 <code>byte</code> 的范围更大。</li></ul></li><li><strong>int</strong><ul><li>大小：4 字节（32 位）</li><li>范围：约 −2.1×109 到 2.1×109</li><li>用途：这是<strong>最常用</strong>的整型，通常用来表示普通的整数。</li></ul></li><li><strong>long</strong><ul><li>大小：8 字节（64 位）</li><li>范围：约 −9.2×1018 到 9.2×1018</li><li>用途：当 <code>int</code> 类型的范围不足以存储一个大数时使用，例如处理时间戳、文件大小等。在数值后面需要加上 <code>L</code> 或 <code>l</code> 来表示，例如 <code>long myLong = 100L;</code>。</li></ul></li></ul><h4 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2. 浮点型"></a><strong>2. 浮点型</strong></h4><p>浮点型用于存储带有小数点的数值。</p><ul><li><strong>float</strong><ul><li>大小：4 字节（32 位）</li><li>用途：单精度浮点数，有效位数为 6-7 位。在数值后面需要加上 <code>F</code> 或 <code>f</code> 来表示，例如 <code>float myFloat = 3.14f;</code>。</li></ul></li><li><strong>double</strong><ul><li>大小：8 字节（64 位）</li><li>用途：双精度浮点数，有效位数为 15-16 位。这是<strong>最常用</strong>的浮点型，Java 默认的浮点数类型就是 <code>double</code>。</li></ul></li></ul><blockquote><p><strong>注意</strong>：浮点数存在精度问题，不适合用于精确的金融计算。如果需要精确计算，应使用 <code>java.math.BigDecimal</code> 类。</p></blockquote><h4 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3. 字符型"></a><strong>3. 字符型</strong></h4><ul><li><strong>char</strong><ul><li>大小：2 字节（16 位）</li><li>用途：存储单个字符。在 Java 中，<code>char</code> 采用 Unicode 编码，可以表示包括中文在内的所有字符。它可以用单引号 <code>&#39;</code> 括起来，例如 <code>char myChar = &#39;A&#39;;</code>。</li></ul></li></ul><h4 id="4-布尔型"><a href="#4-布尔型" class="headerlink" title="4. 布尔型"></a><strong>4. 布尔型</strong></h4><ul><li><strong>boolean</strong><ul><li>大小：在内存中通常被视为 1 位，但在数组中会占用 1 字节。</li><li>用途：用于存储 <code>true</code> 或 <code>false</code>，表示逻辑值。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/image-20250915211633091.png" alt="image-20250915211633091"></p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><h4 id="一、引用类型的定义"><a href="#一、引用类型的定义" class="headerlink" title="一、引用类型的定义"></a>一、引用类型的定义</h4><ul><li><strong>引用类型</strong> 并不直接存储数据本身，而是存储“对象在堆内存中的地址（引用）”。</li><li>当你操作一个引用类型变量时，实际是通过它指向的地址去访问堆上的对象。</li></ul><hr><h4 id="二、Java-中的引用类型分类"><a href="#二、Java-中的引用类型分类" class="headerlink" title="二、Java 中的引用类型分类"></a>二、Java 中的引用类型分类</h4><h5 id="1-类（Class）"><a href="#1-类（Class）" class="headerlink" title="1. 类（Class）"></a>1. 类（Class）</h5><ul><li>自定义类、Java 内置类都是引用类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;   <span class="comment">// String 是引用类型</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// Date 也是引用类型</span></span><br></pre></td></tr></table></figure><h5 id="2-接口（Interface）"><a href="#2-接口（Interface）" class="headerlink" title="2. 接口（Interface）"></a>2. 接口（Interface）</h5><ul><li>接口变量也属于引用类型，只能指向实现该接口的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(); <span class="comment">// Runnable 是接口，Thread 实现了它</span></span><br></pre></td></tr></table></figure><h5 id="3-数组（Array）"><a href="#3-数组（Array）" class="headerlink" title="3. 数组（Array）"></a>3. 数组（Array）</h5><ul><li>Java 中数组本质上是对象，所以也是引用类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h5 id="4-枚举（Enum）"><a href="#4-枚举（Enum）" class="headerlink" title="4. 枚举（Enum）"></a>4. 枚举（Enum）</h5><ul><li>枚举在 Java 中是特殊的类，也属于引用类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;</span><br><span class="line"><span class="type">Color</span> <span class="variable">c</span> <span class="operator">=</span> Color.RED;</span><br></pre></td></tr></table></figure><hr><h4 id="三、引用类型的特点"><a href="#三、引用类型的特点" class="headerlink" title="三、引用类型的特点"></a>三、引用类型的特点</h4><ol><li><p><strong>存储位置</strong></p><ul><li>引用变量存储在 <strong>栈</strong> 上，保存的是对象在堆内存中的地址。</li><li>实际对象（new 出来的）存放在 <strong>堆</strong> 上。</li><li>常量池中的对象（如字符串字面量 <code>&quot;Hello&quot;</code>）存放在方法区（JDK 8 以后在 Metaspace）。</li></ul></li><li><p><strong>默认值</strong></p><ul><li>未初始化的引用类型默认值是 <strong>null</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s; </span><br><span class="line">System.out.println(s); <span class="comment">// 编译报错：未初始化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="literal">null</span>;      <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure></li><li><p><strong>可以为 null</strong></p><ul><li>引用类型变量可以指向 null，表示不指向任何对象。</li><li>这就是为什么会出现 <strong>NullPointerException</strong>。</li></ul></li><li><p><strong>对象操作方式</strong></p><ul><li>通过“引用”去调用对象的方法或访问成员。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">p.sayHello();  <span class="comment">// 实际是通过 p 这个引用找到堆里的对象，再执行方法</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="四、扩展：引用的级别（java-lang-ref-包）"><a href="#四、扩展：引用的级别（java-lang-ref-包）" class="headerlink" title="四、扩展：引用的级别（java.lang.ref 包）"></a>四、扩展：引用的级别（java.lang.ref 包）</h4><p>Java 提供了 4 种不同“强度”的引用，用于 GC（垃圾回收）的管理：</p><ol><li><strong>强引用（Strong Reference）</strong>：最常见的形式，如 <code>Object obj = new Object();</code>，不会被 GC 回收。</li><li><strong>软引用（SoftReference）</strong>：内存不足时才会被回收，用于缓存。</li><li><strong>弱引用（WeakReference）</strong>：只要发生 GC，就会被回收。</li><li><strong>虚引用（PhantomReference）</strong>：不能通过它访问对象本身，主要用于跟踪对象被回收的状态。</li></ol><h3 id="自动拆装箱的本质"><a href="#自动拆装箱的本质" class="headerlink" title="自动拆装箱的本质"></a>自动拆装箱的本质</h3><hr><p><strong>自动拆装箱</strong>是 Java 编译器在编译时期，根据代码的语法，<strong>自动</strong>将基本数据类型和其对应的包装类型之间进行转换的一种机制。这在 Java 5 之后被引入，大大简化了代码，让开发者可以像操作基本类型一样操作包装类型。</p><ul><li><strong>装箱（Boxing）</strong>：将基本数据类型（如 <code>int</code>）转换为对应的包装类型（<code>Integer</code>）。</li><li><strong>拆箱（Unboxing）</strong>：将包装类型（<code>Integer</code>）转换为对应的基本数据类型（<code>int</code>）。</li></ul><h3 id="自动拆装箱的底层原理"><a href="#自动拆装箱的底层原理" class="headerlink" title="自动拆装箱的底层原理"></a>自动拆装箱的底层原理</h3><hr><p>这并非 JVM 的特性，而是<strong>编译器</strong>的“障眼法”。当你在 Java 代码中使用自动拆装箱时，编译器会在你看不见的地方，自动插入对应的 <code>valueOf()</code> 和 <code>xxxValue()</code> 方法。</p><h4 id="1-自动装箱的原理"><a href="#1-自动装箱的原理" class="headerlink" title="1. 自动装箱的原理"></a>1. 自动装箱的原理</h4><p>当你写下 <code>Integer a = 100;</code> 这样的代码时，编译器会将其自动转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这就是自动装箱的本质。它调用了包装类的静态方法 <strong>valueOf()</strong>。</p><p><strong>Integer.valueOf() 的特殊之处</strong>：</p><p>为了节省内存并提高性能，<code>Integer</code> 类内部维护了一个 <strong>缓存</strong>。这个缓存的范围通常是 <strong>-128 到 127</strong>。</p><p>当 <code>valueOf()</code> 方法传入的值在这个范围内时，它会直接从缓存中返回对应的 <code>Integer</code> 对象，而不是创建一个新的对象。</p><p>所以，当你执行以下代码时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);</span><br></pre></td></tr></table></figure><p>结果是 <code>true</code>，因为 <code>a</code> 和 <code>b</code> 都指向了缓存中的同一个对象。</p><p>但如果值超出这个范围：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(c == d);</span><br></pre></td></tr></table></figure><p>结果就是 <code>false</code>，因为每次都会创建新的 <code>Integer</code> 对象。这个缓存优化机制也存在于 <code>Byte</code>, <code>Short</code>, <code>Long</code> 和 <code>Character</code> 类型中。</p><h4 id="2-自动拆箱的原理"><a href="#2-自动拆箱的原理" class="headerlink" title="2. 自动拆箱的原理"></a>2. 自动拆箱的原理</h4><p>当你写下 <code>int i = a;</code> 这样的代码（其中 <code>a</code> 是一个 <code>Integer</code> 对象）时，编译器会将其自动转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.intValue();</span><br></pre></td></tr></table></figure><p>这就是自动拆箱的本质。它调用了包装类的实例方法 <strong>xxxValue()</strong>（如 <code>intValue()</code>, <code>doubleValue()</code> 等）。</p><hr><h3 id="注意事项与潜在问题"><a href="#注意事项与潜在问题" class="headerlink" title="注意事项与潜在问题"></a>注意事项与潜在问题</h3><p>虽然自动拆装箱让代码更简洁，但如果不了解其原理，可能会引发一些问题：</p><ul><li><p><strong>NullPointerException</strong>：如果一个包装类型为 <code>null</code>，在进行自动拆箱时，会调用 <code>null</code> 对象的 <code>intValue()</code> 方法，从而抛出 <code>NullPointerException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; <span class="comment">// 这里会抛出 NullPointerException</span></span><br></pre></td></tr></table></figure></li><li><p><strong>性能问题</strong>：在循环中频繁地进行自动装箱和拆箱，会不断地创建和销毁对象，这会增加垃圾回收（GC）的负担，影响程序性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 糟糕的写法</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++) &#123;</span><br><span class="line">    sum += k; <span class="comment">// 每次循环都会进行一次拆箱和一次装箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该使用基本数据类型来避免这种开销：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更好的写法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++) &#123;</span><br><span class="line">    sum += k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>在 Java 中，静态变量（Static Variable），也称为类变量（Class Variable），是使用 <strong>static 关键字</strong> 修饰的变量。它属于 <strong>类</strong>，而不是类的任何一个 <strong>实例对象</strong>。</p><p>这意味着，不管你创建了多少个类的对象，静态变量在内存中都只有<strong>一份</strong>，并且这唯一的一份数据被该类的所有对象共享。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">company</span> <span class="operator">=</span> <span class="string">&quot;Google&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>name</code> 是一个<strong>实例变量</strong>。每个 <code>User</code> 对象都有自己独立的 <code>name</code> 属性，<code>user1</code> 的 <code>name</code> 和 <code>user2</code> 的 <code>name</code> 互不影响。</li><li><code>company</code> 是一个<strong>静态变量</strong>。无论你创建多少个 <code>User</code> 对象，它们共享同一个 <code>company</code> 变量。如果你修改了 <code>company</code> 的值，所有 <code>User</code> 对象的 <code>company</code> 属性都会跟着改变。</li></ul><hr><h3 id="静态变量的内存分配与生命周期"><a href="#静态变量的内存分配与生命周期" class="headerlink" title="静态变量的内存分配与生命周期"></a>静态变量的内存分配与生命周期</h3><ul><li><strong>内存分配</strong>：静态变量在类加载时，被分配到 <strong>方法区（Method Area）</strong> 的 <strong>静态区</strong> 中。这与实例变量不同，实例变量是在创建对象时，随着对象一起分配在 <strong>堆（Heap）</strong> 中。</li><li><strong>生命周期</strong>：静态变量的生命周期与类的生命周期相同。当类被加载时，静态变量被创建；当类被卸载时，静态变量才会被销毁。</li></ul><p>因为它的生命周期贯穿整个程序运行过程，所以也常常被称为“全局变量”。</p><hr><h3 id="如何访问静态变量？"><a href="#如何访问静态变量？" class="headerlink" title="如何访问静态变量？"></a>如何访问静态变量？</h3><p>访问静态变量有两种方式，但推荐使用第一种，因为它更符合静态变量“属于类”的特性。</p><ol><li><p>通过类名访问（推荐）</p><p>这是最常见、最规范的访问方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(User.company); <span class="comment">// 输出: Google</span></span><br></pre></td></tr></table></figure></li><li><p>通过对象实例访问（不推荐）</p><p>虽然可以通过对象实例来访问静态变量，但编译器会发出警告，因为它可能会造成混淆，让人误以为静态变量是实例特有的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">System.out.println(user1.company); <span class="comment">// 输出: Google</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="静态变量的应用场景"><a href="#静态变量的应用场景" class="headerlink" title="静态变量的应用场景"></a>静态变量的应用场景</h3><p>静态变量因其“全局唯一”的特性，非常适合以下场景：</p><ol><li><p><strong>计数器</strong>：需要统计某个类被创建了多少次，可以使用一个静态变量作为计数器。每次创建对象时，就在构造函数中对该静态变量进行自增操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>共享配置</strong>：当某些数据是所有对象共有的，比如公司名称、项目名称、数据库连接池等，可以将它们定义为静态变量，方便所有对象共享和访问。</p></li><li><p><strong>常量</strong>：定义程序中不会改变的常量，通常结合 <code>final</code> 关键字一起使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVER_URL</span> <span class="operator">=</span> <span class="string">&quot;http://api.example.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>这样定义的常量可以在整个程序中被安全地访问。</p></li></ol><hr><h3 id="静态变量的缺点与注意事项"><a href="#静态变量的缺点与注意事项" class="headerlink" title="静态变量的缺点与注意事项"></a>静态变量的缺点与注意事项</h3><ul><li><strong>线程安全问题</strong>：由于静态变量是所有线程共享的，当多个线程同时修改它时，可能会发生数据不一致的问题。因此，在使用静态变量时，需要特别注意<strong>线程安全</strong>，可以考虑使用同步锁或原子类（如 <code>AtomicInteger</code>）来保证并发安全。</li><li><strong>过度使用问题</strong>：滥用静态变量可能会导致程序耦合度过高，不利于单元测试和代码维护。因为静态变量无法通过依赖注入进行替换，测试时难以模拟或隔离其状态。</li></ul><h3 id="New关键字"><a href="#New关键字" class="headerlink" title="New关键字"></a>New关键字</h3><p><code>new</code> 关键字在 Java 中是用来<strong>创建对象实例</strong>的。当你在代码中使用 <code>new</code> 关键字时，它会执行以下三个关键步骤：</p><h3 id="1-分配内存"><a href="#1-分配内存" class="headerlink" title="1. 分配内存"></a>1. 分配内存</h3><p><code>new</code> 关键字会计算新创建对象所需的内存大小，并在 <strong>堆（Heap）</strong> 上为这个对象分配一块内存空间。这块内存包含了所有实例变量，以及指向该类信息的指针（例如，该类的<strong>方法区</strong>中的类元信息）。</p><h3 id="2-初始化实例变量"><a href="#2-初始化实例变量" class="headerlink" title="2. 初始化实例变量"></a>2. 初始化实例变量</h3><p>内存分配完成后，Java 会对实例变量进行初始化。</p><ul><li>如果在定义时给变量赋了初始值，那么它们会按照代码中的值进行初始化。</li><li>如果没有明确赋值，那么它们会被赋予默认值：<code>int</code> 为 0，<code>boolean</code> 为 <code>false</code>，引用类型为 <code>null</code> 等。</li></ul><h3 id="3-调用构造方法"><a href="#3-调用构造方法" class="headerlink" title="3. 调用构造方法"></a>3. 调用构造方法</h3><p>初始化实例变量之后，<code>new</code> 关键字会调用类的<strong>构造方法</strong>。构造方法的主要作用是完成对象的最终初始化工作，例如为实例变量赋上更具体的值。</p><hr><h3 id="new-关键字与构造方法的关系"><a href="#new-关键字与构造方法的关系" class="headerlink" title="new 关键字与构造方法的关系"></a><code>new</code> 关键字与构造方法的关系</h3><p>很多人会把 <code>new</code> 关键字和构造方法混为一谈，但它们是两个不同的概念。</p><ul><li><strong>new 关键字</strong> 是一个<strong>操作符</strong>，负责<strong>创建对象</strong>并<strong>分配内存</strong>。</li><li><strong>构造方法</strong> 是一个<strong>特殊方法</strong>，负责<strong>初始化对象</strong>。</li></ul><p>你可以把它们想象成这样：</p><ul><li><code>new</code> 就像是工厂的流水线，负责制造一个空壳产品（对象）。</li><li>构造方法就像是流水线上的工人，负责给这个产品填充内容（初始化）。</li></ul><p><code>new</code> 关键字的作用是<strong>实例化</strong>，而构造方法的作用是<strong>初始化</strong>。只有通过 <code>new</code> 关键字，你才能调用构造方法来创建一个新的对象。</p><h3 id="new-关键字的局限性"><a href="#new-关键字的局限性" class="headerlink" title="new 关键字的局限性"></a><code>new</code> 关键字的局限性</h3><p>虽然 <code>new</code> 是最常见的对象创建方式，但它也有一些局限性：</p><ul><li><strong>强耦合</strong>：直接使用 <code>new</code> 会在代码中创建对具体类的依赖，不利于代码解耦和单元测试。</li><li><strong>无法灵活创建</strong>：你无法通过 <code>new</code> 关键字来动态地决定创建哪个类的实例，也无法在创建对象时进行一些额外的逻辑处理。</li></ul><p>因此，在很多设计模式和框架中，会使用其他方式来代替 <code>new</code>，比如：</p><ul><li><strong>反射</strong>：通过 <code>Class.forName().newInstance()</code> 来创建对象。</li><li><strong>工厂模式</strong>：通过工厂方法或抽象工厂来创建对象。</li><li><strong>依赖注入（DI）框架</strong>：如 Spring 框架，通过配置文件或注解自动创建和管理对象。</li></ul><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ul><li><pre><code class="language-java"> /**  * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。  */ public final native Class&lt;?&gt; getClass() /**  * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。  */ public native int hashCode() /**  * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。  */ public boolean equals(Object obj) /**  * native 方法，用于创建并返回当前对象的一份拷贝。  */ protected native Object clone() throws CloneNotSupportedException /**  * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。  */ public String toString() /**  * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。  */ public final native void notify() /**  * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。  */ public final native void notifyAll() /**  * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。  */ public final native void wait(long timeout) throws InterruptedException /**  * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。  */ public final void wait(long timeout, int nanos) throws InterruptedException /**  * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念  */ public final void wait() throws InterruptedException /**  * 实例被垃圾回收器回收的时候触发的操作  */ protected void finalize() throws Throwable &#123; &#125; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    ------</span><br><span class="line"></span><br><span class="line">    ## `Object` 类的所有方法</span><br><span class="line"></span><br><span class="line">    #### 1. `public final native Class&lt;?&gt; getClass()`</span><br><span class="line"></span><br><span class="line">    返回当前正在运行的对象的 **Class** 对象。这个方法是 **final** 的，这意味着你不能重写它。它通常用于反射（Reflection），让你在运行时获取对象的类型信息。</span><br><span class="line"></span><br><span class="line">    #### 2. `public native int hashCode()`</span><br><span class="line"></span><br><span class="line">    返回对象的 **哈希码** 值。这个哈希值通常用于基于哈希的集合，如 `HashMap`、`HashSet` 和 `HashTable`。**hashCode() 和 equals() 必须保持一致**：如果两个对象 `equals()` 返回 `true`，那么它们的 `hashCode()` 也必须相等。</span><br><span class="line"></span><br><span class="line">    #### 3. `public boolean equals(Object obj)`</span><br><span class="line"></span><br><span class="line">    比较两个对象是否相等。**Object** 类的默认实现是比较两个对象的**内存地址**。通常情况下，为了比较对象的内容，你需要根据业务逻辑**重写**这个方法。</span><br><span class="line"></span><br><span class="line">    #### 4. `protected native Object clone() throws CloneNotSupportedException`</span><br><span class="line"></span><br><span class="line">    创建并返回当前对象的**浅拷贝**。要使用 `clone()` 方法，你的类必须实现**`Cloneable`**接口，否则会抛出 `CloneNotSupportedException` 异常。</span><br><span class="line"></span><br><span class="line">    #### 5. `public String toString()`</span><br><span class="line"></span><br><span class="line">    返回对象的字符串表示。默认返回 `“类名@对象的哈希码的无符号十六进制表示”`。为了提供有意义的字符串描述，通常需要**重写**这个方法。</span><br><span class="line"></span><br><span class="line">    #### 6. `public final native void notify()`</span><br><span class="line"></span><br><span class="line">    唤醒在此对象监视器（monitor）上等待的**一个**线程。这个方法必须在 `synchronized` 代码块中调用，否则会抛出 `IllegalMonitorStateException`。</span><br><span class="line"></span><br><span class="line">    #### 7. `public final native void notifyAll()`</span><br><span class="line"></span><br><span class="line">    唤醒在此对象监视器上等待的**所有**线程。与 `notify()` 一样，它也必须在 `synchronized` 代码块中调用。</span><br><span class="line"></span><br><span class="line">    #### 8. `public final native void wait(long timeout) throws InterruptedException`</span><br><span class="line"></span><br><span class="line">    让当前线程进入等待状态，并释放它所持有的锁，直到其他线程调用 `notify()` 或 `notifyAll()`，或者等待时间超时。</span><br><span class="line"></span><br><span class="line">    #### 9. `public final void wait() throws InterruptedException`</span><br><span class="line"></span><br><span class="line">    与 `wait(long timeout)` 类似，但它会**无限期**地等待，直到被唤醒。</span><br><span class="line"></span><br><span class="line">    #### 10. `public final void wait(long timeout, int nanos) throws InterruptedException`</span><br><span class="line"></span><br><span class="line">    更精确的 `wait()` 方法，允许以毫秒和纳秒为单位指定等待时间。</span><br><span class="line"></span><br><span class="line">    #### 11. `protected void finalize() throws Throwable`</span><br><span class="line"></span><br><span class="line">    当垃圾回收器确定没有对该对象的引用时，垃圾回收器会在该对象上调用此方法。这个方法用于在对象被销毁前执行一些清理工作。**不推荐**使用 `finalize()`，因为它不保证何时执行，甚至可能不执行，并且会影响垃圾回收性能。现代 Java 中应使用 `try-with-resources` 或其他资源管理方式。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">## **String 类型**</span><br><span class="line"></span><br><span class="line">### 1. 字节和字符的区别？</span><br><span class="line"></span><br><span class="line">字节是存储容量的基本单位；字符是数字、字母、汉字以及其他语言的各种符号；1 字节 = 8 个二进制单位，一个字符由一个字节或多个字节的二进制单位组成。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 2. String 为什么要设计为不可变类？</span><br><span class="line"></span><br><span class="line">在 Java 中将 String 设计成不可变的是综合考虑到各种因素的结果。主要的原因主要有以下三点：</span><br><span class="line"></span><br><span class="line">- **字符串常量池的需要**：字符串常量池是 Java 堆内存中一个特殊的存储区域, 当创建一个 String 对象时，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象；</span><br><span class="line">- **允许 String 对象缓存 HashCode**：Java 中 String 对象的哈希码被频繁地使用, 比如在 HashMap 等容器中。字符串不变性保证了 hash 码的唯一性，因此可以放心地进行缓存。这也是一种性能优化手段，意味着不必每次都去计算新的哈希码；</span><br><span class="line">- **String 被许多的 Java 类(库)用来当做参数**，例如：网络连接地址 URL、文件路径 path、还有反射机制所需要的 String 参数等, 假若 String 不是固定不变的，将会引起各种安全隐患。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 3. String、StringBuilder、StringBuffer 的区别？</span><br><span class="line"></span><br><span class="line">string类不能被继承，因为被final修饰</span><br><span class="line"></span><br><span class="line">- **String**：用于字符串操作，属于不可变类；【补充：String 不是基本数据类型，是引用类型，底层用 char 数组实现的】</span><br><span class="line">- **StringBuilder**：与 StringBuffer 类似，都是字符串缓冲区，但线程不安全；</span><br><span class="line">- **StringBuffer**：也用于字符串操作，不同之处是 StringBuffer 属于可变类，对方法加了同步锁，线程安全</span><br><span class="line"></span><br><span class="line">StringBuffer的补充说明：StringBuffer 中并不是所有方法都使用了 Synchronized 修饰来实现同步：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Override public StringBuffer insert(int dstOffset, CharSequence s) &#123; // Note, synchronization achieved via invocations of other StringBuffer methods // after narrowing of s to specific type // Ditto for toStringCache clearing super.insert(dstOffset, s); return this; &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>执行效率：StringBuilder &gt; StringBuffer &gt; String</p><hr><h3 id="4-String-字符串修改实现的原理？"><a href="#4-String-字符串修改实现的原理？" class="headerlink" title="4. String 字符串修改实现的原理？"></a>4. String 字符串修改实现的原理？</h3><p>当用 String 类型来对字符串进行修改时，其实现方法是首先创建一个 StringBuffer，其次调用 StringBuffer 的 <code>append()</code> 方法，最后调用 StringBuffer 的 <code>toString()</code> 方法把结果返回。</p><hr><h3 id="5-String-str-“i”-与-String-str-new-String-“i”-一样吗？"><a href="#5-String-str-“i”-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="5. String str &#x3D; “i” 与 String str &#x3D; new String(“i”) 一样吗？"></a>5. String str &#x3D; “i” 与 String str &#x3D; new String(“i”) 一样吗？</h3><p>不一样，因为内存的分配方式不一样。<code>String str = &quot;i&quot;</code> 的方式，Java 虚拟机会将其分配到常量池中；而 <code>String str = new String(&quot;i&quot;)</code> 则会被分到堆内存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(str1 == str2);</span><br><span class="line">        System.out.println(str1 == str3);</span><br><span class="line">        System.out.println(str3 == str4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(str3.equals(str4)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在执行 <code>String str1 = &quot;abc&quot;</code> 的时候，JVM 会首先检查字符串常量池中是否已经存在该字符串对象，如果已经存在，那么就不会再创建了，直接返回该字符串在字符串常量池中的内存地址；如果该字符串还不存在字符串常量池中，那么就会在字符串常量池中创建该字符串对象，然后再返回。所以在执行 <code>String str2 = &quot;abc&quot;</code> 的时候，因为字符串常量池中已经存在“abc”字符串对象了，就不会在字符串常量池中再次创建了，所以栈内存中 str1 和 str2 的内存地址都是指向 “abc” 在字符串常量池中的位置，所以 <code>str1 = str2</code> 的运行结果为 true。</p><p>而在执行 <code>String str3 = new String(&quot;abc&quot;)</code> 的时候，JVM 会首先检查字符串常量池中是否已经存在“abc”字符串，如果已经存在，则不会在字符串常量池中再创建了；如果不存在，则就会在字符串常量池中创建 “abc” 字符串对象，然后再到堆内存中再创建一份字符串对象，把字符串常量池中的 “abc” 字符串内容拷贝到内存中的字符串对象中，然后返回堆内存中该字符串的内存地址，即栈内存中存储的地址是堆内存中对象的内存地址。<code>String str4 = new String(&quot;abc&quot;)</code> 是在堆内存中又创建了一个对象，所以 <code>str3 == str4</code> 运行的结果是 false。str1、str2、str3、str4 在内存中的存储状况如下图所示：</p><hr><h3 id="6-String-类的常用方法都有那些？"><a href="#6-String-类的常用方法都有那些？" class="headerlink" title="6. String 类的常用方法都有那些？"></a>6. String 类的常用方法都有那些？</h3><ul><li><code>indexOf()</code>：返回指定字符的索引。</li><li><code>charAt()</code>：返回指定索引处的字符。</li><li><code>replace()</code>：字符串替换。</li><li><code>trim()</code>：去除字符串两端空白。</li><li><code>split()</code>：分割字符串，返回一个分割后的字符串数组。</li><li><code>getBytes()</code>：返回字符串的 byte 类型数组。</li><li><code>length()</code>：返回字符串长度。</li><li><code>toLowerCase()</code>：将字符串转成小写字母。</li><li><code>toUpperCase()</code>：将字符串转成大写字符。</li><li><code>substring()</code>：截取字符串。</li><li><code>equals()</code>：字符串比较。</li></ul><hr><h3 id="7-final-修饰-StringBuffer-后还可以-append-吗？"><a href="#7-final-修饰-StringBuffer-后还可以-append-吗？" class="headerlink" title="7. final 修饰 StringBuffer 后还可以 append 吗？"></a>7. final 修饰 StringBuffer 后还可以 append 吗？</h3><p>可以。<code>final</code> 修饰的是一个引用变量，那么这个引用始终只能指向这个对象，但是这个对象内部的属性是可以变化的。</p><p>官方文档解释：<code>once a final variable has been assigned, it always contains the same value. If a final variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object.</code></p><p><code>String</code> 是一个非常特殊的类型，它<strong>不是基本数据类型</strong>，而是一个<strong>引用数据类型（Reference Data Type）</strong>。</p><h4 id="String-的核心特性"><a href="#String-的核心特性" class="headerlink" title="String 的核心特性"></a><strong>String 的核心特性</strong></h4><ol><li><strong>不可变性（Immutability）</strong><ul><li><code>String</code> 对象一旦被创建，它的值就不能被改变。</li><li>当你对 <code>String</code> 进行修改操作时，比如拼接字符串，实际上是<strong>创建了一个新的 String 对象</strong>，而原始对象没有改变。</li><li>这种不可变性使得 <code>String</code> 对象是线程安全的，可以在多线程环境中被安全地共享。</li></ul></li><li><strong>String 的创建</strong><ul><li><strong>字面量方式</strong>：<code>String s = &quot;hello&quot;;</code><ul><li>这种方式创建的字符串会被存储在**字符串常量池（String Pool）**中。</li><li>当创建第二个值为 <code>&quot;hello&quot;</code> 的字符串时，JVM 会直接从常量池中返回已存在的对象引用，而不会创建新的对象。这是一种重要的内存优化。</li></ul></li><li><strong>new 关键字方式</strong>：<code>String s = new String(&quot;hello&quot;);</code><ul><li>这种方式会创建一个新的 <code>String</code> 对象在堆（Heap）中。即使常量池中已经存在 <code>&quot;hello&quot;</code>，也会在堆中再创建一个新的对象。</li></ul></li></ul></li></ol><h4 id="String-的常用方法"><a href="#String-的常用方法" class="headerlink" title="String 的常用方法"></a><strong>String 的常用方法</strong></h4><ul><li><strong>拼接</strong>：<ul><li>使用 <code>+</code> 运算符：<code>String s3 = s1 + s2;</code></li><li>使用 <code>concat()</code> 方法：<code>s1.concat(s2);</code></li><li>推荐使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 进行大量字符串拼接，因为它们是可变的，效率更高。</li></ul></li><li><strong>比较</strong>：<ul><li><code>equals()</code>：比较字符串的内容，返回 <code>boolean</code> 类型。</li><li><code>equalsIgnoreCase()</code>：忽略大小写比较字符串内容。</li><li><code>==</code>：比较的是<strong>对象的引用地址</strong>，只有当两个引用指向同一个对象时才为 <code>true</code>。</li></ul></li><li><strong>查找</strong>：<ul><li><code>indexOf(char)</code>：查找字符第一次出现的索引。</li><li><code>contains(String)</code>：判断是否包含某个子字符串。</li></ul></li><li><strong>修改</strong>：<ul><li><code>replace(oldChar, newChar)</code>：替换字符串中的字符。</li><li><code>substring(beginIndex, endIndex)</code>：截取子字符串。</li></ul></li></ul><h4 id="为什么不用-char-数组代替-String？"><a href="#为什么不用-char-数组代替-String？" class="headerlink" title="为什么不用 char 数组代替 String？"></a><strong>为什么不用 char 数组代替 String？</strong></h4><p>虽然 <code>String</code> 内部也是用 <code>char</code> 数组实现的，但 <code>String</code> 的不可变性提供了很多优势：</p><ul><li><strong>安全性</strong>：作为方法参数时，可以防止方法内部修改原始字符串。</li><li><strong>线程安全</strong>：可以在多线程环境下共享。</li><li><strong>哈希码缓存</strong>：<code>String</code> 的哈希码会被缓存，在作为 <code>HashMap</code> 的键时，性能更好。</li></ul><hr><h3 id="基本类型与-String-的转换"><a href="#基本类型与-String-的转换" class="headerlink" title="基本类型与 String 的转换"></a><strong>基本类型与 String 的转换</strong></h3><ul><li><strong>基本类型转 String</strong>：<ul><li><code>String.valueOf(int i)</code></li><li><code>Integer.toString(int i)</code></li><li><code>&quot;&quot; + i</code></li></ul></li><li><strong>String 转基本类型</strong>：<ul><li><code>Integer.parseInt(&quot;123&quot;)</code></li><li><code>Double.parseDouble(&quot;3.14&quot;)</code></li><li><code>Float.parseFloat(&quot;1.23&quot;)</code></li><li>等等。</li></ul></li></ul><blockquote><p><strong>注意</strong>：<code>String</code> 转基本类型时，如果字符串格式不正确，会抛出 <code>NumberFormatException</code>。</p></blockquote><p><code>&amp;</code> 和 <code>&amp;&amp;</code> 在 Java 中都是逻辑与运算符，但它们之间有一个至关重要的区别：<strong>短路特性</strong>。</p><hr><h3 id="（逻辑与-按位与）"><a href="#（逻辑与-按位与）" class="headerlink" title="&amp;（逻辑与 &#x2F; 按位与）"></a><code>&amp;</code>（逻辑与 &#x2F; 按位与）</h3><p><code>&amp;</code> 运算符有两种不同的用途，取决于它的操作数类型。</p><p><strong>1. 逻辑与（当操作数为 boolean 类型时）</strong></p><p>当 <code>&amp;</code> 的两边是布尔表达式时，它执行<strong>非短路逻辑与</strong>。这意味着无论第一个表达式的结果是 <code>true</code> 还是 <code>false</code>，它都会<strong>继续计算</strong>第二个表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> &amp; (++a &gt; <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="comment">// 即使第一个表达式是 true，第二个表达式 (++a &gt; 10) 也会被执行。</span></span><br><span class="line">    <span class="comment">// a 的值会变为 11。</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a); <span class="comment">// 输出 11</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>++a</code> 总是会被执行，<code>a</code> 的值最终会增加。</p><p><strong>2. 按位与（当操作数为整数类型时）</strong></p><p>当 <code>&amp;</code> 的两边是整数类型（如 <code>int</code>, <code>long</code> 等）时，它执行<strong>按位与运算</strong>。它将两个数的二进制位进行比较，如果对应的位都是 <code>1</code>，则结果位是 <code>1</code>，否则是 <code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 二进制 0101</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">// 二进制 0011</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x &amp; y; <span class="comment">// 二进制 0001</span></span><br><span class="line">System.out.println(result); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><h3 id="（短路逻辑与）"><a href="#（短路逻辑与）" class="headerlink" title="&amp;&amp;（短路逻辑与）"></a><code>&amp;&amp;</code>（短路逻辑与）</h3><p><code>&amp;&amp;</code> 运算符只用于布尔类型的操作，它执行<strong>短路逻辑与</strong>。</p><p>**短路（Short-circuiting）**是 <code>&amp;&amp;</code> 最重要的特性。如果第一个表达式的结果是 <code>false</code>，那么整个表达式的结果必定是 <code>false</code>，因此 <code>&amp;&amp;</code> 会立即停止计算，<strong>不再执行</strong>第二个表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span> &amp;&amp; (++a &gt; <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="comment">// 第一个表达式是 false，整个条件已确定为 false。</span></span><br><span class="line">    <span class="comment">// 第二个表达式 (++a &gt; 10) 不会被执行。</span></span><br><span class="line">    <span class="comment">// a 的值保持不变。</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a); <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>++a</code> 永远不会被执行，因为它位于短路操作的右侧。</p><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th><code>&amp;</code></th><th><code>&amp;&amp;</code></th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>逻辑与、按位与</td><td>仅为逻辑与</td></tr><tr><td><strong>短路</strong></td><td>不短路</td><td>短路</td></tr><tr><td><strong>计算</strong></td><td>始终计算第二个表达式</td><td>当第一个表达式为 <code>false</code> 时，不计算第二个表达式</td></tr><tr><td><strong>适用类型</strong></td><td><code>boolean</code> 和整数类型</td><td>仅 <code>boolean</code></td></tr><tr><td><strong>性能</strong></td><td>可能比 <code>&amp;&amp;</code> 慢（如果第一个表达式为 <code>false</code>）</td><td>通常比 <code>&amp;</code> 快（当第一个表达式为 <code>false</code> 时）</td></tr></tbody></table><p>在日常开发中，<strong>优先使用 &amp;&amp;</strong>。因为它能提高代码效率，并在避免 <code>NullPointerException</code> 等问题时非常有用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 &amp;&amp; 避免空指针异常</span></span><br><span class="line"><span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 list 为 null，第二个表达式不会被执行，程序不会报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>&amp;</code> 通常只在需要<strong>两个表达式都必须执行</strong>的特定场景下使用，或者用于按位运算。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="C:\Users\19501\Desktop\types-of-exceptions-in-java.png" alt="types-of-exceptions-in-java"></p><h3 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a><a href="#exception-%E5%92%8C-error-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Exception 和 Error 有什么区别？</a></h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong>Exception</strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong>Error</strong>：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h3 id="⭐️Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#⭐️Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="⭐️Checked Exception 和 Unchecked Exception 有什么区别？"></a><a href="#%E2%AD%90%EF%B8%8Fchecked-exception-%E5%92%8C-unchecked-exception-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">⭐️Checked Exception 和 Unchecked Exception 有什么区别？</a></h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。 </p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul><hr><h3 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a><a href="#throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">Throwable 类常用方法有哪些？</a></h3><ul><li><code>String getMessage()</code>: 返回异常发生时的详细信息</li><li><code>String toString()</code>: 返回异常发生时的简要描述</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h3 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a><a href="#try-catch-finally-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">try-catch-finally 如何使用？</a></h3><hr><p><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</p><p><code>catch</code>块：用于处理 try 捕获到的异常。</p><p><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p><h3 id="5-Error-和-Exception-的区别？"><a href="#5-Error-和-Exception-的区别？" class="headerlink" title="5. Error 和 Exception 的区别？"></a>5. Error 和 Exception 的区别？</h3><p>Error 类和 Exception 类的父类都是 Throwable 类。主要区别如下：</p><ul><li><strong>Error 类</strong>：一般是指与虚拟机相关的问题，如：系统崩溃、虚拟机错误、内存空间不足、方法调用栈溢出等。这类错误将会导致应用程序中断，仅靠程序本身无法恢复和预防；</li><li><strong>Exception 类</strong>：分为运行时异常和受检查的异常。</li></ul><hr><h3 id="6-运行时异常与受检异常有何异同？"><a href="#6-运行时异常与受检异常有何异同？" class="headerlink" title="6. 运行时异常与受检异常有何异同？"></a>6. 运行时异常与受检异常有何异同？</h3><ul><li><strong>运行时异常</strong>：如：空指针异常、指定的类找不到、数组越界、方法传递参数错误、数据类型转换错误。可以编译通过，但是一运行就停止了，程序不会自己处理；</li><li><strong>受检查异常</strong>：要么用 <code>try ... catch...</code> 捕获，要么用 <code>throws</code> 声明抛出，交给父类处理。</li></ul><hr><h3 id="7-throw-和-throws-的区别？"><a href="#7-throw-和-throws-的区别？" class="headerlink" title="7. throw 和 throws 的区别？"></a>7. throw 和 throws 的区别？</h3><ul><li><strong>throw</strong>：在方法体内部，表示抛出异常，由方法体内部的语句处理；<code>throw</code> 是具体向外抛出异常的动作，所以它抛出一个异常实例；</li><li><strong>throws</strong>：在方法声明后面，表示如果抛出异常，由该方法的调用者来处理；表示出现异常的可能性，并不一定会发生这种异常。</li></ul><hr><h3 id="8-常见的异常类有哪些？"><a href="#8-常见的异常类有哪些？" class="headerlink" title="8. 常见的异常类有哪些？"></a>8. 常见的异常类有哪些？</h3><ul><li><strong>NullPointerException</strong>：当应用程序试图访问空对象时，则抛出该异常。</li><li><strong>SQLException</strong>：提供关于数据库访问错误或其他错误信息的异常。</li><li><strong>IndexOutOfBoundsException</strong>：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li><li><strong>FileNotFoundException</strong>：当试图打开指定路径名表示的文件失败时，抛出此异常。</li><li><strong>IOException</strong>：当发生某种 I&#x2F;O 异常时，抛出此异常。此类是失败或中断的 I&#x2F;O 操作生成的异常的通用类。</li><li><strong>ClassCastException</strong>：当试图将对象强制转换为不是实例的子类时，抛出该异常。</li><li><strong>IllegalArgumentException</strong>：抛出的异常表明向方法传递了一个不合法或不正确的参数。</li></ul><hr><h3 id="9-主线程可以捕获到子线程的异常吗？"><a href="#9-主线程可以捕获到子线程的异常吗？" class="headerlink" title="9. 主线程可以捕获到子线程的异常吗？"></a>9. 主线程可以捕获到子线程的异常吗？</h3><p>线程设计的理念：“线程的问题应该线程它自己本身来解决，而不要委托到外部”。</p><p>正常情况下，如果不做特殊的处理，在主线程中是不能够捕获到子线程中的异常的。如果想要在主线程中捕获子线程的异常，我们可以用如下的方式进行处理，使用 <code>Thread</code> 的静态方法 <code>Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandle());</code>通常情况下，主线程<strong>不能直接</strong>捕获到子线程中抛出的异常。这是因为线程是独立的执行流，每个线程都有自己的调用栈。当子线程中发生异常时，如果该异常没有被子线程内部的 <code>try-catch</code> 块捕获，它会沿着子线程的调用栈向上冒泡，最终导致子线程终止。这个异常不会传递到主线程的调用栈中，因此主线程无法感知或捕获它。</p><p>这个设计理念被称为“线程的问题应该由线程自己本身来解决，而不是委托到外部”。</p><hr><h3 id="捕获子线程异常的方法"><a href="#捕获子线程异常的方法" class="headerlink" title="捕获子线程异常的方法"></a>捕获子线程异常的方法</h3><p>虽然主线程无法直接捕获子线程异常，但 Java 提供了两种机制来处理这种情况，允许你在主线程或其他线程中对子线程的异常进行处理：</p><h4 id="1-使用-try-catch-在子线程内部处理"><a href="#1-使用-try-catch-在子线程内部处理" class="headerlink" title="1. 使用 try-catch 在子线程内部处理"></a>1. 使用 <code>try-catch</code> 在子线程内部处理</h4><p>这是最直接也最推荐的方式。在子线程的 <code>run()</code> 方法中，用 <code>try-catch</code> 块将可能抛出异常的代码包围起来。这样，异常就会在子线程内部被捕获并处理，你可以选择记录日志、发送通知，或者执行其他恢复操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能会抛出异常的代码</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception from child thread&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 在子线程中捕获并处理异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;子线程捕获到异常: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-设置未捕获异常处理器-UncaughtExceptionHandler"><a href="#2-设置未捕获异常处理器-UncaughtExceptionHandler" class="headerlink" title="2. 设置未捕获异常处理器 (UncaughtExceptionHandler)"></a>2. 设置未捕获异常处理器 (<code>UncaughtExceptionHandler</code>)</h4><p>当你无法在子线程内部处理所有异常时，可以使用 <code>UncaughtExceptionHandler</code>。这是一个在线程因未捕获异常而突然终止时被调用的回调接口。你可以为每个线程或所有线程设置一个默认的处理器。</p><p><strong>A. 为单个线程设置处理器</strong></p><p>你可以为特定的 <code>Thread</code> 实例设置一个 <code>UncaughtExceptionHandler</code>。当该线程发生未捕获异常时，JVM 会调用你提供的处理器的 <code>uncaughtException()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception from child thread!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;在主线程中捕获到子线程 [&quot;</span> + t.getName() + <span class="string">&quot;] 的异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p><strong>B. 为所有线程设置默认处理器</strong></p><p>如果你想为所有线程（包括线程池中的线程）设置一个通用的异常处理逻辑，可以使用 <code>Thread.setDefaultUncaughtExceptionHandler()</code>。这个处理器会在没有任何特定处理器的线程上被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主线程中设置全局默认处理器</span></span><br><span class="line">Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;全局处理器捕获到线程 [&quot;</span> + t.getName() + <span class="string">&quot;] 的异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程中抛出未处理的异常</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Global uncaught exception&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>主线程</strong>不能直接捕获<strong>子线程</strong>的异常，因为它们是独立的执行流。</li><li>要处理子线程的异常，最简单的方法是<strong>在子线程内部使用 try-catch 块</strong>。</li><li>如果需要在主线程中感知和处理子线程的异常，可以使用 <code>Thread</code> 提供的**<code>UncaughtExceptionHandler</code>**机制。你可以为特定线程或所有线程设置一个处理器，当线程因未捕获异常而终止时，这个处理器会被调用。</li></ul><hr><h2 id="创建对象："><a href="#创建对象：" class="headerlink" title="创建对象："></a>创建对象：</h2><hr><h3 id="1-使用-new-关键字"><a href="#1-使用-new-关键字" class="headerlink" title="1. 使用 new 关键字"></a>1. 使用 <code>new</code> 关键字</h3><p>这是最常见、最直接的创建对象方式。当你使用 <code>new</code> 关键字时，它会调用类的<strong>构造器</strong>来初始化对象。</p><p><strong>原理：</strong></p><ol><li><strong>分配内存：</strong> JVM 在堆（Heap）上为新对象分配所需的内存空间。</li><li><strong>默认初始化：</strong> 成员变量会被赋予默认值（例如，<code>int</code> 为 <code>0</code>，<code>boolean</code> 为 <code>false</code>，引用类型为 <code>null</code>）。</li><li><strong>调用构造器：</strong> JVM 调用指定的构造器来执行初始化代码。构造器中的代码会覆盖之前的默认值。</li><li><strong>返回引用：</strong> 对象创建完成后，<code>new</code> 表达式会返回该对象在内存中的引用。</li></ol><p><strong>优点：</strong></p><ul><li>简单直观，代码可读性好。</li><li>可以调用任何可访问的构造器（包括有参和无参）。</li></ul><p><strong>缺点：</strong></p><ul><li>每次调用 <code>new</code> 都会创建一个新对象，开销较大。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 new 关键字创建对象</span></span><br><span class="line"><span class="type">MyObject</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line"><span class="type">MyObject</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="2-使用-Class-类的-newInstance-方法（反射）"><a href="#2-使用-Class-类的-newInstance-方法（反射）" class="headerlink" title="2. 使用 Class 类的 newInstance() 方法（反射）"></a>2. 使用 <code>Class</code> 类的 <code>newInstance()</code> 方法（反射）</h3><p><code>Class.forName().newInstance()</code> 是通过<strong>反射</strong>来创建对象的方式。</p><p><strong>原理：</strong></p><ol><li><strong>加载类：</strong> <code>Class.forName()</code> 方法根据类的全限定名（如 <code>&quot;com.example.MyObject&quot;</code>）加载类，并返回对应的 <code>Class</code> 对象。</li><li><strong>创建实例：</strong> <code>newInstance()</code> 方法会调用该类的<strong>无参构造器</strong>来创建对象。</li></ol><p><strong>注意：</strong></p><ul><li><code>newInstance()</code> 要求类必须有一个无参的构造器，且该构造器必须是可见的（<code>public</code>）。</li><li>Java 9 之后，<code>Class.newInstance()</code> 被标记为<strong>过时（deprecated）</strong>。</li><li>在现代 Java 中，更推荐使用 <code>Constructor</code> 类的 <code>newInstance()</code> 方法，因为它能够调用<strong>有参</strong>构造器，并且可以处理构造器抛出的异常。</li></ul><p><strong>优点：</strong></p><ul><li>可以在运行时动态地创建对象，非常灵活。</li><li>适用于工厂模式、依赖注入（如 Spring）等场景。</li></ul><p><strong>缺点：</strong></p><ul><li>性能比 <code>new</code> 关键字差，因为涉及反射机制。</li><li>如果类没有无参构造器或构造器不可访问，会抛出异常。</li><li>没有编译时检查，错误只能在运行时发现。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Class.forName().newInstance() 创建对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyObject&quot;</span>);</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">obj</span> <span class="operator">=</span> (MyObject) clazz.newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-使用-clone-方法"><a href="#3-使用-clone-方法" class="headerlink" title="3. 使用 clone() 方法"></a>3. 使用 <code>clone()</code> 方法</h3><p><code>clone()</code> 方法通过<strong>复制</strong>现有对象来创建新对象，而不是重新构造。它属于 <code>Object</code> 类的一个 <code>protected</code> 方法。</p><p><strong>原理：</strong></p><ol><li><strong>实现接口：</strong> 要使用 <code>clone()</code> 方法，你的类必须实现 <code>Cloneable</code> 接口。这个接口是一个<strong>标记接口</strong>，本身没有任何方法，但它告诉 JVM 这个类可以被克隆。</li><li><strong>重写方法：</strong> 你需要重写 <code>Object</code> 类的 <code>clone()</code> 方法，并将其访问修饰符改为 <code>public</code>。</li><li><strong>执行克隆：</strong> <code>clone()</code> 方法会创建一个新对象，并将现有对象的字段值<strong>逐一复制</strong>到新对象中。这是一种<strong>浅拷贝（shallow copy）</strong>。如果你的对象包含引用类型的成员，那么新对象和旧对象将共享同一个引用。</li></ol><p><strong>优点：</strong></p><ul><li>克隆一个对象比使用 <code>new</code> 关键字创建对象更快，因为它跳过了构造器的初始化过程。</li><li>在需要大量创建相同或相似对象时，是一种有效的性能优化手段。</li></ul><p><strong>缺点：</strong></p><ul><li><code>clone()</code> 方法默认是浅拷贝，如果需要深拷贝（deep copy），需要手动实现。</li><li><code>Cloneable</code> 接口和 <code>clone()</code> 方法的设计有些“反直觉”，容易出现问题。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类需要实现 Cloneable 接口并重写 clone() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 clone() 方法创建对象</span></span><br><span class="line"><span class="type">MyObject</span> <span class="variable">original</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyObject) original.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-反序列化（Deserialization）"><a href="#4-反序列化（Deserialization）" class="headerlink" title="4. 反序列化（Deserialization）"></a>4. 反序列化（Deserialization）</h3><p>反序列化是指将字节流<strong>恢复成</strong> Java 对象的过程。</p><p><strong>原理：</strong></p><ol><li><strong>序列化：</strong> 首先，一个对象必须是**可序列化（<code>Serializable</code>）**的，即它实现了 <code>Serializable</code> 接口。</li><li><strong>写入流：</strong> 序列化就是将对象的状态（成员变量的值）写入一个字节流中（例如，写入文件或网络）。</li><li><strong>反序列化：</strong> 反序列化则是从字节流中读取数据，并重建（re-create）原始对象。这个过程<strong>不会调用构造器</strong>。</li></ol><p><strong>优点：</strong></p><ul><li>可以将对象持久化到磁盘或在网络中传输，这对于分布式系统和缓存非常重要。</li><li>可以跨进程甚至跨机器传输对象。</li></ul><p><strong>缺点：</strong></p><ul><li>只有实现了 <code>Serializable</code> 接口的类才能进行序列化和反序列化。</li><li>如果对象的版本不兼容，反序列化可能会失败。</li><li>存在安全风险，因为它能够绕过构造器，如果设计不当可能导致不一致的状态。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象必须实现 Serializable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>))) &#123;</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> <span class="title class_">MyObject</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">obj</span> <span class="operator">=</span> (MyObject) ois.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>这四种创建对象的方式各有优劣和适用场景：</p><ul><li><strong>new</strong>：最常用，用于<strong>常规</strong>的对象创建。</li><li><strong>反射</strong>：用于<strong>运行时动态</strong>创建对象，常用于框架开发。</li><li><strong>clone()</strong>：用于<strong>快速复制</strong>现有对象，以提高性能。</li><li><strong>反序列化</strong>：用于将对象<strong>持久化</strong>或在<strong>网络传输</strong>中重建。</li></ul><p>理解这些创建对象的方式，可以让你在不同的编程场景中做出更明智的选择。</p><p>深拷贝和浅拷贝是 Java 对象复制时需要理解的两个重要概念。它们主要通过 <code>clone()</code> 方法或序列化来实现。</p><h3 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h3><p><strong>浅拷贝</strong>只复制对象本身，以及其基本数据类型的字段。对于引用类型的字段，它<strong>只复制引用地址</strong>，新旧对象会共享同一块内存中的引用数据。</p><h4 id="实现方式：clone-方法"><a href="#实现方式：clone-方法" class="headerlink" title="实现方式：clone() 方法"></a>实现方式：<code>clone()</code> 方法</h4><p>Java 中的浅拷贝通常通过实现 <code>Cloneable</code> 接口并重写 <code>Object</code> 类的 <code>clone()</code> 方法来实现。</p><p><strong>步骤：</strong></p><ol><li>让你的类实现 <code>java.lang.Cloneable</code> 接口。这是一个标记接口，告诉 JVM 这个类的实例可以被克隆。</li><li>重写 <code>Object</code> 类的 <code>clone()</code> 方法，并将其可见性改为 <code>public</code>。</li><li>在重写的方法中调用 <code>super.clone()</code>。</li></ol><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address; <span class="comment">// 引用类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 这是浅拷贝的实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShallowCopyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">originalStudent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Zhangsan&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用浅拷贝</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStudent</span> <span class="operator">=</span> (Student) originalStudent.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 浅拷贝前 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改克隆对象的引用类型字段</span></span><br><span class="line">        clonedStudent.address.city = <span class="string">&quot;Shanghai&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 浅拷贝后 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city); <span class="comment">// 原始对象的地址也变了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- 浅拷贝前 ---</span><br><span class="line">原始学生地址: Beijing</span><br><span class="line">克隆学生地址: Beijing</span><br><span class="line"></span><br><span class="line">--- 浅拷贝后 ---</span><br><span class="line">原始学生地址: Shanghai</span><br><span class="line">克隆学生地址: Shanghai</span><br></pre></td></tr></table></figure><p>可以看到，修改克隆对象的地址，原始对象的地址也随之改变，这正是浅拷贝的特点。</p><hr><h3 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h3><p><strong>深拷贝</strong>会创建一个完全独立的新对象，不仅复制基本数据类型，还会<strong>递归地复制</strong>所有引用类型字段指向的对象。新旧对象之间互不影响。</p><h4 id="实现方式一：手动实现递归复制"><a href="#实现方式一：手动实现递归复制" class="headerlink" title="实现方式一：手动实现递归复制"></a>实现方式一：手动实现递归复制</h4><p>在重写的 <code>clone()</code> 方法中，对引用类型的字段进行<strong>单独的克隆</strong>。</p><p>示例：</p><p>修改上面的 Student 类，实现深拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Address 类也必须重写 clone()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 先进行浅拷贝</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStudent</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">// 然后对引用类型的字段进行深层拷贝</span></span><br><span class="line">        clonedStudent.address = (Address) <span class="built_in">this</span>.address.clone();</span><br><span class="line">        <span class="keyword">return</span> clonedStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCopyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">originalStudent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Zhangsan&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用深拷贝</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStudent</span> <span class="operator">=</span> (Student) originalStudent.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 深拷贝前 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改克隆对象的引用类型字段</span></span><br><span class="line">        clonedStudent.address.city = <span class="string">&quot;Shanghai&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 深拷贝后 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city); <span class="comment">// 原始对象没有改变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- 深拷贝前 ---</span><br><span class="line">原始学生地址: Beijing</span><br><span class="line">克隆学生地址: Beijing</span><br><span class="line"></span><br><span class="line">--- 深拷贝后 ---</span><br><span class="line">原始学生地址: Beijing</span><br><span class="line">克隆学生地址: Shanghai</span><br></pre></td></tr></table></figure><p>这次，修改克隆对象的地址，原始对象没有受到影响。</p><h4 id="实现方式二：序列化与反序列化"><a href="#实现方式二：序列化与反序列化" class="headerlink" title="实现方式二：序列化与反序列化"></a>实现方式二：序列化与反序列化</h4><p>这是一种更简单、通用的深拷贝方法，特别适用于对象结构复杂的情况。</p><p><strong>步骤：</strong></p><ol><li>让所有相关类（包括引用类型）都实现 <code>java.io.Serializable</code> 接口。</li><li>将对象写入一个字节流中（序列化）。</li><li>再从字节流中读出新的对象（反序列化）。</li></ol><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializationDeepCopyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">originalStudent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Zhangsan&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化和反序列化实现深拷贝</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(originalStudent);</span><br><span class="line">        oos.close();</span><br><span class="line">        </span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStudent</span> <span class="operator">=</span> (Student) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 深拷贝前 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改克隆对象的引用类型字段</span></span><br><span class="line">        clonedStudent.address.city = <span class="string">&quot;Shanghai&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 深拷贝后 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法代码虽然多，但对于复杂的对象图来说，它比手动递归实现要简单得多，因为它会自动处理所有嵌套对象的拷贝。</p><h2 id="接口和抽象类："><a href="#接口和抽象类：" class="headerlink" title="接口和抽象类："></a>接口和抽象类：</h2><p>在软件开发中，<strong>抽象类（abstract class）和接口（interface）都是用于实现多态</strong>的重要概念，它们允许你定义一个通用的契约，然后让具体的类去实现这个契约。虽然它们的目的相似，但在用途、设计和实现上存在一些关键区别。</p><hr><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一个不能被实例化的类，它通常包含<strong>抽象方法</strong>（没有具体实现的方法）和<strong>具体方法</strong>（有具体实现的方法）。</p><p><strong>主要特点：</strong></p><ul><li><strong>语法：</strong> 使用 <code>abstract</code> 关键字来声明类和抽象方法。</li><li><strong>方法：</strong> 可以同时包含抽象方法和具体方法。抽象方法必须在子类中被实现，具体方法则可以选择性地被重写。</li><li><strong>成员变量：</strong> 可以包含成员变量，包括 <code>private</code>、<code>protected</code> 和 <code>public</code> 等修饰符。</li><li><strong>继承：</strong> 一个子类<strong>只能继承一个</strong>抽象类。如果子类不是抽象类，它必须实现所有父抽象类中的抽象方法。</li><li><strong>构造器：</strong> 抽象类可以有构造器，但不能直接用 <code>new</code> 关键字来创建实例。它的构造器主要用于在子类中通过 <code>super</code> 关键字调用，以初始化父类的成员。</li><li><strong>目的：</strong> 通常用于定义一类事物共同的<strong>属性和行为</strong>。它代表一种“is-a”（是一种）的关系，比如“猫是一种动物”，<code>Cat</code> 类继承 <code>Animal</code> 抽象类。</li></ul><p>使用场景：</p><p>当你需要定义一个模板，其中一些方法是通用的（已实现），而另一些方法是需要子类根据自身特点去实现的，抽象类是理想选择。例如，一个 Shape 抽象类可以定义一个通用的 draw() 抽象方法，但每个具体的形状（Circle，Rectangle）都有自己独特的绘制方式。同时，它还可以有一个具体的 getColor() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 示例</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法，所有子类都可以直接使用或重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zzz...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof woof&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一个完全抽象的“类”，它定义了一组<strong>契约或规范</strong>，其中只包含抽象方法和常量。自 Java 8 之后，接口也可以包含默认方法（default method）和静态方法。</p><p><strong>主要特点：</strong></p><ul><li><strong>语法：</strong> 使用 <code>interface</code> 关键字声明。</li><li><strong>方法：</strong> 在 Java 8 之前，接口中的方法默认都是 <code>public abstract</code> 的，可以省略这两个关键字。自 Java 8 之后，可以有 <code>default</code> 和 <code>static</code> 方法。自 Java 9 之后，还可以有 <code>private</code> 方法。</li><li><strong>成员变量：</strong> 接口中的成员变量默认是 <code>public static final</code> 的，也即常量。</li><li><strong>实现：</strong> 一个类可以<strong>实现（implements）多个</strong>接口，从而克服了单继承的限制。</li><li><strong>目的：</strong> 主要用于定义一个<strong>能力或行为</strong>。它代表一种“can-do”（能做）的关系，比如一个 <code>Car</code> 类可以实现 <code>Driveable</code> 接口，一个 <code>Bird</code> 类可以实现 <code>Flyable</code> 接口。它是一种对行为的抽象。</li></ul><p>使用场景：</p><p>当你需要定义一种能力，而这种能力可以被不同类别的对象共享时，接口非常有用。例如，Flyable 接口可以被 Airplane、Bird 或 Superman 等完全不相关的类实现，因为它们都具有“飞行”的能力。</p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，默认 public abstract</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java 8 之后允许的默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">glide</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Gliding through the air...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Flapping wings to fly.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="核心区别总结"><a href="#核心区别总结" class="headerlink" title="核心区别总结"></a>核心区别总结</h3><table><thead><tr><th>特性</th><th>抽象类（Abstract Class）</th><th>接口（Interface）</th></tr></thead><tbody><tr><td><strong>继承&#x2F;实现</strong></td><td><code>extends</code>，单继承</td><td><code>implements</code>，多实现</td></tr><tr><td><strong>方法</strong></td><td>可包含抽象方法和具体方法</td><td>仅包含抽象方法（Java 8+ 可有 <code>default</code>、<code>static</code> 方法）</td></tr><tr><td><strong>成员变量</strong></td><td>各种类型变量，包括常量和非常量</td><td>只能是 <code>public static final</code> 常量</td></tr><tr><td><strong>构造器</strong></td><td>可以有</td><td>不能有</td></tr><tr><td><strong>可访问性</strong></td><td>成员可以是 <code>private</code>, <code>protected</code> 或 <code>public</code></td><td>方法默认是 <code>public</code>，变量默认是 <code>public static final</code></td></tr><tr><td><strong>目的</strong></td><td>定义一类事物的<strong>共同特征和行为</strong>，代表“is-a”关系</td><td>定义一种<strong>能力或行为</strong>，代表“can-do”关系</td></tr></tbody></table><p>10、抽象类和接口有什么区别？</p><p>（1）抽象类中可以定义构造函数，接口不能定义构造函数； </p><p>（2）抽象类中可以有抽象方法和具体⽅方法，而接口中只能有抽象方法（public abstract）； </p><p>（3）抽象类中的成员权限可以是 public、默认、protected（抽象类中抽象方法就是为了重写，所以不能被 private 修饰），而接口中的成员只可以是 public（方法默认：public abstrat、成员变量默认：public static final）；</p><p> （4）抽象类中可以包含静态方法，而接口中不不可以包含静态方法；</p><p> JDK 8 中的改变：</p><p>1、在 JDK1.8中，允许在接⼝口中包含带有具体实现的⽅方法，使用 default 修饰，这类⽅方法就是默认方法。 2、抽象类中可以包含静态方法，在 JDK1.8 之前接口中不不能包含静态方法，JDK1.8 以后可以包含。之前不能包含是因为，接口不可以实现方法，只可以定义方法，所以不能使用静态方法（因为静态方法必须实现）。现在可以包 含了，只能直接用接口调用静态⽅方法。JDK1.8 仍然不可以包含静态代码块。 </p><h3 id="面试官可能会问的深入问题"><a href="#面试官可能会问的深入问题" class="headerlink" title="面试官可能会问的深入问题"></a>面试官可能会问的深入问题</h3><ul><li><strong>为什么 Java 要同时保留抽象类和接口？</strong><ul><li>抽象类侧重于<strong>代码复用</strong>，通过具体方法减少子类的重复代码，并强制子类实现某些特定行为。</li><li>接口侧重于<strong>功能扩展和解耦</strong>，允许不相关的类拥有相同的行为，实现更灵活的设计，同时避免多继承带来的复杂性。</li></ul></li><li><strong>什么时候用抽象类，什么时候用接口？</strong><ul><li>如果你想在类层次结构中<strong>共享代码</strong>，并且这种关系是一种**“is-a”关系**，使用抽象类。</li><li>如果你想为不相关的类<strong>定义通用的行为</strong>，并且希望一个类能拥有多种能力，使用接口。</li></ul></li><li><strong>Java 8 的默认方法对接口和抽象类的区别有什么影响？</strong><ul><li>默认方法的引入模糊了两者的一些界限，接口现在也可以提供方法的默认实现，使得接口的能力更强。</li><li>但是，本质区别仍然存在：<strong>抽象类可以有状态（非 final 成员变量），而接口不能。</strong> 抽象类可以共享状态和具体实现，接口则更关注行为的契约。</li></ul></li></ul><p>简单来说，抽象类是<strong>模板</strong>，提供了骨架和部分实现；接口是<strong>契约</strong>，只规定了行为。理解了这一点，就能很好地应对这类面试题。</p><hr><h2 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h2><p>代理模式是一种 <strong>结构型设计模式</strong>，其核心思想是：<strong>为其他对象提供一种代理以控制对这个对象的访问</strong>。<br> 代理对象（Proxy）充当真实对象（Real Subject）的替身，客户端通过代理访问真实对象，而代理可以在访问前后进行增强操作（如权限校验、延迟加载、日志记录等）。</p><hr><h3 id="1-代理模式的组成"><a href="#1-代理模式的组成" class="headerlink" title="1. 代理模式的组成"></a>1. 代理模式的组成</h3><ol><li><strong>Subject（抽象主题）</strong><ul><li>定义真实对象和代理对象的公共接口，客户端通过这个接口访问对象。</li></ul></li><li><strong>RealSubject（真实主题）</strong><ul><li>真正的业务逻辑对象，实现 Subject 接口。</li></ul></li><li><strong>Proxy（代理类）</strong><ul><li>通过实现 Subject 接口，内部持有 RealSubject 的引用。</li><li>可在调用真实对象方法前后添加额外功能。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真实对象处理请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxySubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject real;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxySubject</span><span class="params">(RealSubject real)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.real = real;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理前处理&quot;</span>);</span><br><span class="line">        real.request(); <span class="comment">// 调用真实对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理后处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RealSubject</span> <span class="variable">real</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        <span class="type">ProxySubject</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxySubject</span>(real);</span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-代理模式的几种类型及特点"><a href="#2-代理模式的几种类型及特点" class="headerlink" title="2. 代理模式的几种类型及特点"></a>2. 代理模式的几种类型及特点</h3><table><thead><tr><th>类型</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>静态代理（Static Proxy）</strong></td><td>- 代理类在编译时就确定- 代理类与真实对象实现相同接口- 优点：简单易懂，编译时检查安全- 缺点：每一个真实对象都需要对应代理类，代理类数量多，扩展性差</td><td>权限控制、日志记录等固定功能的增强</td></tr><tr><td><strong>动态代理（Dynamic Proxy）</strong></td><td>- 运行时创建代理类- Java 提供 <strong>JDK 动态代理</strong>（接口）和 <strong>CGLIB 动态代理</strong>（继承子类）- 优点：减少代理类数量，增强可扩展性- 缺点：运行时生成字节码，性能稍低</td><td>AOP、事务管理、日志记录、RPC 调用</td></tr><tr><td><strong>强制代理（Force Proxy）</strong></td><td>- 真实对象只能通过代理访问- 客户端无法直接访问真实对象</td><td>需要严格控制访问权限的场景</td></tr><tr><td><strong>远程代理（Remote Proxy）</strong></td><td>- 为远程对象提供本地代理，隐藏网络通信细节</td><td>RPC 调用、分布式系统</td></tr><tr><td><strong>虚拟代理（Virtual Proxy）</strong></td><td>- 延迟创建或加载真实对象- 代理对象在需要时才创建真实对象</td><td>大对象延迟加载、懒加载场景</td></tr><tr><td><strong>保护代理（Protection Proxy）</strong></td><td>- 控制真实对象的访问权限- 根据不同用户权限返回不同结果</td><td>权限控制、安全管理</td></tr><tr><td><strong>缓存代理（Cache Proxy）</strong></td><td>- 对结果进行缓存，减少真实对象重复计算</td><td>频繁查询、计算量大的场景</td></tr></tbody></table><hr><ol start="3"><li>代理模式的优缺点</li></ol><p><strong>优点</strong>：</p><ol><li>客户端与真实对象解耦，通过代理可以灵活增强功能。</li><li>可以控制访问、延迟加载、记录日志等。</li><li>增强对象功能而不修改原始类。</li></ol><p><strong>缺点</strong>：</p><ol><li>增加系统复杂性，代理类可能增加额外层次。</li><li>对性能有一定影响（尤其是动态代理或远程代理）。</li></ol><hr><h2 id="如何实现动态代理？"><a href="#如何实现动态代理？" class="headerlink" title="如何实现动态代理？"></a>如何实现动态代理？</h2><p>动态代理的核心思想是在<strong>运行时</strong>创建一个代理对象，用于在不修改原始类代码的情况下，为对象添加额外的功能（如日志记录、性能监控、事务管理等）。Java 提供了两种主要的动态代理实现方式：<strong>JDK 动态代理</strong>和 <strong>CGLIB 动态代理</strong>。</p><p>这里我们重点解析 JDK 动态代理的实现，它依赖于接口。</p><hr><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>JDK 动态代理的实现主要依赖于以下三个核心组件：</p><ol><li><strong>接口 (Interface)</strong>：代理对象和被代理对象必须实现同一个或一组接口。这是 JDK 动态代理的基础，它强制代理对象和被代理对象具有相同的公共行为。</li><li><strong>InvocationHandler</strong>：这是动态代理的<strong>核心处理逻辑</strong>。你需要在其中实现 <code>invoke</code> 方法，这个方法包含了代理对象被调用时要执行的所有逻辑。</li><li><strong>Proxy</strong>：这是一个工具类，用于动态生成代理对象。你不能直接创建代理对象，而是通过 <code>Proxy</code> 类的静态方法来完成。</li></ol><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>动态代理的整个过程可以分为以下几步：</p><ol><li><strong>定义接口</strong>：首先，你需要定义一个接口，声明被代理对象和代理对象共同拥有的方法。</li><li><strong>创建被代理对象（目标对象）</strong>：创建一个类，实现上一步定义的接口，这就是我们真正要代理的对象。</li><li><strong>编写 InvocationHandler</strong>：创建一个处理类，它实现 <code>InvocationHandler</code> 接口，并重写 <code>invoke</code> 方法。在这个方法中，你将：<ul><li>接收被代理对象的实例。</li><li>在调用原始方法<strong>之前</strong>执行一些预处理逻辑。</li><li>通过 <code>method.invoke(目标对象, args)</code> 调用被代理对象的原始方法。</li><li>在调用原始方法<strong>之后</strong>执行一些后处理逻辑。</li></ul></li><li><strong>使用 Proxy 类生成代理对象</strong>：调用 <code>Proxy</code> 类的静态方法 <code>newProxyInstance()</code> 来创建代理对象。这个方法需要三个参数：<ul><li><strong>ClassLoader loader</strong>：用于加载代理类的类加载器。通常使用被代理对象的类加载器。</li><li><strong>Class&lt;?&gt;[] interfaces</strong>：一个接口数组，代理对象需要实现的接口。</li><li><strong>InvocationHandler handler</strong>：实现了 <code>InvocationHandler</code> 的对象，它包含了代理的逻辑。</li></ul></li></ol><hr><h4 id="invoke-方法的参数解析"><a href="#invoke-方法的参数解析" class="headerlink" title="invoke() 方法的参数解析"></a><code>invoke()</code> 方法的参数解析</h4><p><code>InvocationHandler</code> 接口的 <code>invoke()</code> 方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure><ul><li><strong>proxy</strong>：这个参数是<strong>代理对象本身</strong>的引用。在 <code>invoke</code> 方法内部，你应该避免直接调用 <code>proxy</code> 的方法，否则可能导致无限递归调用。</li><li><strong>method</strong>：代表正在被调用的方法，它是 <code>java.lang.reflect.Method</code> 类型的对象。你可以通过它获取方法名、参数类型、返回值类型等信息。</li><li><strong>args</strong>：一个 <code>Object</code> 数组，包含了调用原始方法时传递的所有参数。</li></ul><p>通过以上步骤，JVM 会在运行时动态生成一个实现了指定接口、并继承自 <code>Proxy</code> 类的字节码，将其加载到内存中，并最终返回一个代理对象实例。所有对代理对象方法的调用都会被自动转发到 <code>InvocationHandler</code> 的 <code>invoke</code> 方法中，从而实现了对原始方法的增强和控制。</p><p>Proxy 类的作用是动态创建一个代理对象的类。它提供了许多的方法，但是我们用得最多的就是 <code>newProxyInstance</code> 这个方法：</p><p><code>public static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler handler) throws IllegalArgumentException</code></p><ul><li><code>loader</code>：一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载；</li><li><code>interfaces</code>：一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了。</li><li><code>handler</code>：一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上。</li></ul><p>通过 <code>Proxy.newProxyInstance</code> 创建的代理对象是在 Jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行时动态生成的一个对象。</p><h2 id="成员类："><a href="#成员类：" class="headerlink" title="成员类："></a>成员类：</h2><p>我已经为您将之前关于<strong>成员类分类</strong>的详细解析和表格总结进行了合并，以提供一个更全面、更易于理解的回答。</p><hr><p>在 Java 中，一个类可以定义在另一个类的内部，这种类被称为<strong>成员类（Member Class）</strong>，也被称为<strong>嵌套类（Nested Class）</strong>。根据其定义方式和特性，成员类主要分为以下四种类型：</p><h3 id="1-静态成员类（Static-Member-Class）"><a href="#1-静态成员类（Static-Member-Class）" class="headerlink" title="1. 静态成员类（Static Member Class）"></a>1. 静态成员类（Static Member Class）</h3><p><strong>静态成员类</strong>是使用 <code>static</code> 关键字修饰的内部类。它与外部类的实例没有关联，可以像访问静态变量一样，直接通过外部类名来创建它的实例。</p><ul><li><strong>特点</strong>:<ul><li>无法直接访问外部类的非静态成员，但可以访问外部类的静态成员。</li></ul></li><li><strong>适用场景</strong>:<ul><li>当一个类与外部类逻辑上紧密相关，但又不需要访问外部类的实例成员时，使用静态成员类。它常用于作为外部类的辅助工具类，比如在一个 <code>LinkedList</code> 类中定义一个 <code>Node</code> 静态成员类来表示链表节点。</li></ul></li></ul><h3 id="2-内部类（Inner-Class）"><a href="#2-内部类（Inner-Class）" class="headerlink" title="2. 内部类（Inner Class）"></a>2. 内部类（Inner Class）</h3><p><strong>内部类</strong>是没有被 <code>static</code> 关键字修饰的嵌套类。它与外部类的实例紧密相连，必须依附于一个外部类的实例才能被创建。</p><ul><li><strong>特点</strong>:<ul><li>可以直接访问外部类的<strong>所有成员</strong>，包括私有成员。这是内部类最强大的特性。</li></ul></li><li><strong>适用场景</strong>:<ul><li>当一个类的实例需要直接访问外部类的私有状态时，使用内部类。它常用于实现某些特定功能的回调接口。</li></ul></li></ul><h3 id="3-局部内部类（Local-Inner-Class）"><a href="#3-局部内部类（Local-Inner-Class）" class="headerlink" title="3. 局部内部类（Local Inner Class）"></a>3. 局部内部类（Local Inner Class）</h3><p><strong>局部内部类</strong>是定义在方法或代码块内部的类。它只能在定义它的方法或代码块内部被访问和实例化。</p><ul><li><strong>特点</strong>:<ul><li>无法使用访问修饰符（如 <code>public</code>）。</li><li>可以访问外部类的所有成员，但只能访问其所在方法中的 <strong>final 或事实上的 final</strong> 局部变量。</li></ul></li><li><strong>适用场景</strong>:<ul><li>当某个方法中需要一个只用一次的复杂对象或工具类时，可以使用局部内部类，以避免在类级别创建不必要的成员。</li></ul></li></ul><h3 id="4-匿名内部类（Anonymous-Inner-Class）"><a href="#4-匿名内部类（Anonymous-Inner-Class）" class="headerlink" title="4. 匿名内部类（Anonymous Inner Class）"></a>4. 匿名内部类（Anonymous Inner Class）</h3><p><strong>匿名内部类</strong>是一种没有名字的局部内部类，通常用于创建一个只使用一次的类的实例。</p><ul><li><strong>特点</strong>:<ul><li>没有名字，因此无法被复用。</li><li>必须在<strong>创建实例</strong>的同时定义类的实现。</li><li>无法定义构造器。</li><li>可以实现一个接口或继承一个类。</li></ul></li><li><strong>适用场景</strong>:<ul><li>最常用于实现事件监听器或创建线程，尤其是在需要简洁地实现某个接口的单个方法时。</li></ul></li></ul><hr><h3 id="匿名内部类中的局部变量为什么只能用-final？"><a href="#匿名内部类中的局部变量为什么只能用-final？" class="headerlink" title="匿名内部类中的局部变量为什么只能用 final？"></a>匿名内部类中的局部变量为什么只能用 <code>final</code>？</h3><p>这个限制的根本原因在于<strong>生命周期（Lifecycle）</strong>。</p><ol><li><strong>局部变量的生命周期</strong>：局部变量（如方法中的参数或变量）是在方法被调用时创建的，存储在**栈（Stack）**上。当方法执行完毕，这些变量就会被销毁。</li><li><strong>匿名内部类的生命周期</strong>：匿名内部类的实例通常会作为一个对象被传递或保存，它的生命周期可能<strong>比创建它的方法更长</strong>。例如，你可能会将一个实现了事件监听器的匿名内部类实例作为参数传递给一个 UI 组件，当方法返回后，这个监听器对象可能仍然存在并等待事件触发。</li></ol><p><strong>问题出现：</strong></p><p>如果匿名内部类可以访问和修改一个非 <code>final</code> 的局部变量，那么当创建它的方法执行完毕、局部变量被销毁后，匿名内部类的实例仍然存在。当它试图访问这个已经不存在的变量时，就会引发一个**悬空引用（Dangling Reference）**的错误。</p><p>为了解决这个问题，Java 编译器采取了以下策略：</p><ul><li><strong>将局部变量复制一份</strong>：当匿名内部类访问一个局部变量时，编译器会为它在<strong>堆（Heap）上创建一个副本</strong>。这个副本会和匿名内部类实例一起存储，从而确保匿名内部类在任何时候都能访问到这个值。</li><li><strong>强制 final 保证一致性</strong>：如果允许修改原始的局部变量，而匿名内部类使用的是它的副本，那么就会导致原始变量和副本之间的数据不一致。为了避免这种混乱，Java 强制要求被匿名内部类访问的局部变量必须是 <code>final</code> 的，以确保其值不可变。<code>final</code> 关键字保证了原始变量和副本的值始终相同。</li></ul><h3 id="Java-8-之后的改变：“事实上的-final”（Effectively-Final）"><a href="#Java-8-之后的改变：“事实上的-final”（Effectively-Final）" class="headerlink" title="Java 8 之后的改变：“事实上的 final”（Effectively Final）"></a>Java 8 之后的改变：“事实上的 <code>final</code>”（Effectively Final）</h3><p>在 Java 8 之后，为了简化代码，这个规则有了一些放松。你不再需要显式地使用 <code>final</code> 关键字。只要一个局部变量在定义后<strong>没有被重新赋值</strong>，它就会被编译器自动视为“<strong>事实上的 final</strong>”。</p><p>这使得代码看起来更简洁，但<strong>本质上的限制并没有改变</strong>：匿名内部类仍然只能访问那些值在方法执行期间不会改变的局部变量。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>; <span class="comment">// 事实上的 final</span></span><br><span class="line">    <span class="comment">// name = &quot;Bob&quot;; // 如果在这里重新赋值，则会编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 匿名内部类访问局部变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>name</code> 变量没有被 <code>final</code> 修饰，但在它被匿名内部类访问后没有被修改，所以编译器会将其视为事实上的 <code>final</code>，代码可以正常编译和运行。但如果你尝试在 <code>doSomething</code> 方法的 <code>new Thread</code> 之后修改 <code>name</code>，编译器就会报错。</p><hr><h3 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h3><table><thead><tr><th>类型</th><th>关键字</th><th>定义位置</th><th>访问外部类成员</th><th>创建方式</th></tr></thead><tbody><tr><td><strong>静态成员类</strong></td><td><code>static</code></td><td>在外部类内部</td><td>只能访问外部类的 <strong>静态成员</strong></td><td><code>new Outer.StaticInner();</code></td></tr><tr><td><strong>内部类</strong></td><td>无</td><td>在外部类内部</td><td>可访问外部类的<strong>所有成员</strong></td><td><code>new Outer().new Inner();</code></td></tr><tr><td><strong>局部内部类</strong></td><td>无</td><td>在方法或代码块内部</td><td>可访问外部成员和 <strong>final 局部变量</strong></td><td>只能在定义它的方法内部创建</td></tr><tr><td><strong>匿名内部类</strong></td><td>无</td><td>在方法或代码块内部</td><td>同局部内部类</td><td><code>new Interface/Class() &#123; ... &#125;;</code></td></tr></tbody></table><p>匿名内部类、函数式接口和 Lambda 表达式是 Java 语言在不断演进过程中，为了简化代码和支持函数式编程而引入的重要特性。它们经常在面试中被一起考察，因为它们之间存在演变和替代的关系。</p><hr><h3 id="1-匿名内部类-Anonymous-Inner-Class"><a href="#1-匿名内部类-Anonymous-Inner-Class" class="headerlink" title="1. 匿名内部类 (Anonymous Inner Class)"></a>1. 匿名内部类 (Anonymous Inner Class)</h3><p><strong>匿名内部类</strong>是一种没有名字的局部内部类，通常用于创建一个只使用一次的类的实例。</p><ul><li><strong>核心特点</strong>:<ul><li><strong>没有名字</strong>: 无法被复用。</li><li><strong>创建时定义</strong>: 必须在创建实例的同时定义类的实现。</li><li><strong>只能实现一个</strong>: 它可以实现一个接口或继承一个类，但不能两者都做。</li></ul></li><li><strong>用途</strong>:<ul><li>主要用于简化代码，特别是当一个类只被使用一次，且其实现非常简单时。</li><li>常见的应用场景是事件监听器（<code>ActionListener</code>）、线程（<code>Runnable</code>）等。</li></ul></li></ul><p>示例:</p><p>创建一个线程，实现 Runnable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from an anonymous inner class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><hr><h3 id="2-函数式接口-Functional-Interface"><a href="#2-函数式接口-Functional-Interface" class="headerlink" title="2. 函数式接口 (Functional Interface)"></a>2. 函数式接口 (Functional Interface)</h3><p><strong>函数式接口</strong>是指<strong>只包含一个抽象方法</strong>的接口。它可以包含其他默认方法（<code>default</code>）、静态方法（<code>static</code>）和来自 <code>Object</code> 类的方法（如 <code>equals</code>）。</p><ul><li><strong>核心特点</strong>:<ul><li><strong>一个抽象方法</strong>: 这是函数式接口的唯一强制要求。</li><li><strong>@FunctionalInterface 注解</strong>: 这是一个可选的注解，但强烈推荐使用。它会帮助编译器检查该接口是否满足函数式接口的定义，如果违反了规则，就会报错。</li></ul></li></ul><p><strong>用途</strong>:</p><ul><li>它为 Lambda 表达式提供了一个<strong>目标类型</strong>。Lambda 表达式的本质就是函数式接口的一个匿名实现。</li><li><code>java.util.function</code> 包中定义了大量的函数式接口，如 <code>Predicate</code>、<code>Consumer</code>、<code>Function</code> 和 <code>Supplier</code>，它们是 Java 8 Stream API 的基础。</li></ul><p>示例:</p><p>一个自定义的函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-Lambda-表达式-Lambda-Expression"><a href="#3-Lambda-表达式-Lambda-Expression" class="headerlink" title="3. Lambda 表达式 (Lambda Expression)"></a>3. Lambda 表达式 (Lambda Expression)</h3><p><strong>Lambda 表达式</strong>是 Java 8 引入的一个新特性，它提供了一种简洁的方式来表示<strong>函数式接口的实现</strong>。Lambda 表达式可以被看作是匿名内部类的<strong>简化版本</strong>，用于实现只有一个抽象方法的接口。</p><ul><li><strong>语法</strong>: <code>(参数列表) -&gt; &#123; 方法体 &#125;</code></li><li><strong>核心特点</strong>:<ul><li><strong>简洁</strong>: 极大地减少了代码量，省去了匿名内部类的许多样板代码。</li><li><strong>函数式编程</strong>: 使得 Java 能够更方便地支持函数式编程范式，如将函数作为参数传递。</li><li><strong>类型推断</strong>: 编译器可以根据上下文自动推断参数类型。</li></ul></li></ul><p>示例:</p><p>使用 Lambda 表达式实现上面的 Runnable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello from a Lambda expression!&quot;</span>));</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><hr><h3 id="常见的面试问题"><a href="#常见的面试问题" class="headerlink" title="常见的面试问题"></a>常见的面试问题</h3><h4 id="1-匿名内部类、Lambda-表达式和函数式接口之间的关系是什么？"><a href="#1-匿名内部类、Lambda-表达式和函数式接口之间的关系是什么？" class="headerlink" title="1. 匿名内部类、Lambda 表达式和函数式接口之间的关系是什么？"></a>1. 匿名内部类、Lambda 表达式和函数式接口之间的关系是什么？</h4><ul><li><strong>演变关系</strong>: 匿名内部类是 Java 早期用于实现接口或抽象类的单一方法的笨重方式。函数式接口的出现，为 Lambda 表达式提供了一个<strong>目标类型</strong>。Lambda 表达式就是对只有一个抽象方法的匿名内部类的一种<strong>语法糖</strong>，它极大地简化了代码。</li><li><strong>本质</strong>: Lambda 表达式是函数式接口的一个<strong>匿名实现</strong>。</li></ul><h4 id="2-为什么-Lambda-表达式只能实现函数式接口？"><a href="#2-为什么-Lambda-表达式只能实现函数式接口？" class="headerlink" title="2. 为什么 Lambda 表达式只能实现函数式接口？"></a>2. 为什么 Lambda 表达式只能实现函数式接口？</h4><p>Lambda 表达式的语法（<code>(参数) -&gt; &#123;方法体&#125;</code>）本身就只适用于实现<strong>一个方法</strong>。如果一个接口有两个抽象方法，编译器无法确定 Lambda 表达式的 <code>()</code> 和 <code>&#123;&#125;</code> 对应的是哪个方法，因此会报错。</p><h4 id="3-Lambda-表达式和匿名内部类在使用-this-关键字时有什么区别？"><a href="#3-Lambda-表达式和匿名内部类在使用-this-关键字时有什么区别？" class="headerlink" title="3. Lambda 表达式和匿名内部类在使用 this 关键字时有什么区别？"></a>3. Lambda 表达式和匿名内部类在使用 <code>this</code> 关键字时有什么区别？</h4><ul><li><strong>匿名内部类</strong>: 匿名内部类有自己的作用域。它内部的 <code>this</code> 关键字指向的是<strong>匿名内部类自身的实例</strong>。</li><li><strong>Lambda 表达式</strong>: Lambda 表达式没有自己的作用域。它内部的 <code>this</code> 关键字指向的是<strong>其定义所在类的实例</strong>。</li></ul><p><strong>示例</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private String name = &quot;Outer&quot;;</span><br><span class="line"></span><br><span class="line">    public void testLambda() &#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(this.name); // 这里的 this 指向 OuterClass 实例</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void testAnonymous() &#123;</span><br><span class="line">        Runnable r = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // System.out.println(this.name); // 编译错误，匿名内部类没有 name 字段</span><br><span class="line">                System.out.println(OuterClass.this.name); // 必须用 OuterClass.this</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Lambda-表达式捕获的局部变量为什么必须是-final-的？"><a href="#4-Lambda-表达式捕获的局部变量为什么必须是-final-的？" class="headerlink" title="4. Lambda 表达式捕获的局部变量为什么必须是 final 的？"></a>4. Lambda 表达式捕获的局部变量为什么必须是 <code>final</code> 的？</h4><p>和匿名内部类一样，Lambda 表达式会<strong>捕获</strong>其外部作用域的局部变量。这些变量在 Lambda 表达式的生命周期中是不可变的，因为它们被复制到了堆中。在 Java 8 之前，你需要显式地用 <code>final</code> 修饰；自 Java 8 之后，只要变量没有被重新赋值，它就是**“事实上的 <code>final</code>”**，可以省略 <code>final</code> 关键字。</p><h2 id="Lambda表达式："><a href="#Lambda表达式：" class="headerlink" title="Lambda表达式："></a>Lambda表达式：</h2><p>Lambda 表达式是 Java 8 引入的语法糖，它让你可以用更简洁的方式实现<strong>函数式接口</strong>。它的底层实现机制比你想象的要复杂，但核心思想是利用了新的字节码指令和方法。</p><hr><h3 id="Lambda-表达式的底层实现"><a href="#Lambda-表达式的底层实现" class="headerlink" title="Lambda 表达式的底层实现"></a>Lambda 表达式的底层实现</h3><p>Lambda 表达式的底层实现依赖于两个关键技术：</p><ol><li><strong>invokedynamic 指令</strong></li><li><strong>方法句柄（Method Handle）</strong></li></ol><p>在 Java 7 之前，JVM 中只有四种调用方法的指令：<code>invokevirtual</code>、<code>invokeinterface</code>、<code>invokespecial</code> 和 <code>invokestatic</code>。这些指令都是<strong>静态</strong>绑定的，意味着在编译时就确定了调用的目标方法。</p><p>然而，Lambda 表达式的调用是<strong>动态</strong>的。编译器在处理 Lambda 表达式时，并不知道它会具体调用哪个方法。因此，Java 7 引入了 <strong>invokedynamic</strong> 指令，它允许在运行时动态地解析和绑定方法调用。</p><hr><h4 id="编译时：生成-invokedynamic-指令"><a href="#编译时：生成-invokedynamic-指令" class="headerlink" title="编译时：生成 invokedynamic 指令"></a>编译时：生成 <code>invokedynamic</code> 指令</h4><p>当你编写一个 Lambda 表达式时，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>Java 编译器在编译时并不会直接生成一个匿名内部类。相反，它会做以下事情：</p><ol><li><strong>将 Lambda 表达式体转换为一个私有方法</strong>：编译器会把 <code>System.out.println(&quot;Hello&quot;)</code> 这段代码提取出来，生成一个<strong>新的私有方法</strong>，通常是 <code>private static</code> 或 <code>private</code> 类型，并带有特殊的命名规则（比如 <code>lambda$main$0</code>）。这个新方法包含了 Lambda 表达式的实际逻辑。</li><li><strong>生成 invokedynamic 指令</strong>：在 Lambda 表达式出现的地方，编译器会生成一条 <code>invokedynamic</code> 指令。这条指令不会直接调用上一步生成的私有方法。相反，它指向一个<strong>引导方法（Bootstrap Method）</strong>。</li></ol><p><code>invokedynamic</code> 指令的结构大致如下：</p><p><code>invokedynamic #0:run:()Ljava/lang/Runnable;</code></p><ul><li><code>#0</code> 是一个常量池索引，指向引导方法（通常是 <code>java.lang.invoke.LambdaMetafactory.metafactory</code>）。</li><li><code>run</code> 是函数式接口中抽象方法的名称。</li><li><code>()Ljava/lang/Runnable;</code> 是函数式接口的签名。</li></ul><h4 id="运行时：动态绑定"><a href="#运行时：动态绑定" class="headerlink" title="运行时：动态绑定"></a>运行时：动态绑定</h4><p>当 JVM 执行到 <code>invokedynamic</code> 指令时，它会执行以下步骤：</p><ol><li><strong>调用引导方法</strong>：JVM 会调用 <code>LambdaMetafactory.metafactory</code> 引导方法。这个方法是 Lambda 表达式的**“工厂”<strong>，它负责生成一个</strong>方法句柄（Method Handle）**。</li><li><strong>生成方法句柄</strong>：方法句柄是一个轻量级的、类似于 <code>java.lang.reflect.Method</code> 的引用，但它更高效，可以直接调用。它指向编译时生成的那个私有方法（即 Lambda 表达式的实际逻辑）。</li><li><strong>生成调用点对象</strong>：<code>LambdaMetafactory.metafactory</code> 返回一个**<code>CallSite</code>**对象，这个对象持有一个指向方法句柄的引用。这个 <code>CallSite</code> 会被缓存起来。</li><li><strong>执行方法调用</strong>：<code>invokedynamic</code> 指令会直接跳转到 <code>CallSite</code> 对象中的方法句柄，然后执行实际的 Lambda 表达式代码。</li></ol><h3 id="Lambda-表达式与匿名内部类的区别"><a href="#Lambda-表达式与匿名内部类的区别" class="headerlink" title="Lambda 表达式与匿名内部类的区别"></a>Lambda 表达式与匿名内部类的区别</h3><p>理解底层实现后，两者在性能和设计上有一些关键区别：</p><table><thead><tr><th>特性</th><th>Lambda 表达式</th><th>匿名内部类</th></tr></thead><tbody><tr><td><strong>生成方式</strong></td><td>动态生成私有方法和 <code>invokedynamic</code> 指令</td><td>编译时生成独立的 <code>.class</code> 文件</td></tr><tr><td><strong>性能</strong></td><td>通常更快。<strong>invokedynamic 优化了性能</strong>，避免了每次都创建新对象和执行 <code>invokespecial</code> 指令。</td><td>每次使用都会创建一个新的对象实例，并生成一个额外的类文件。</td></tr><tr><td><strong>作用域</strong></td><td>没有自己的作用域，<code>this</code> 关键字指向外部类的实例。</td><td>有自己的作用域，<code>this</code> 关键字指向匿名内部类实例本身。</td></tr><tr><td><strong>内存开销</strong></td><td><strong>更小</strong>。由于采用了方法句柄，避免了为每个 Lambda 表达式创建独立的匿名类对象。</td><td>会产生额外的 <code>.class</code> 文件和对象实例，内存开销更大。</td></tr></tbody></table><p>总结来说，Lambda 表达式的底层实现是一种<strong>延迟创建</strong>和<strong>动态绑定</strong>的机制。编译器在编译时只留下一个调用指令，将真正的实现工作推迟到运行时。这种设计使得 Lambda 表达式在保持代码简洁的同时，也带来了更高的性能。</p><h2 id="七大设计原则"><a href="#七大设计原则" class="headerlink" title="七大设计原则"></a>七大设计原则</h2><p>面向对象的设计模式有七大基本原则：</p><ul><li>开闭原则（Open Closed Principle，OCP）</li><li>单一职责原则（Single Responsibility Principle, SRP）</li><li>里氏代换原则（Liskov Substitution Principle，LSP）</li><li>依赖倒转原则（Dependency Inversion Principle，DIP）</li><li>接口隔离原则（Interface Segregation Principle，ISP）</li><li>合成&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle，CARP）</li><li>最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of  Demeter，LOD）</li></ul><table><thead><tr><th align="left">标记</th><th align="left">设计模式原则名称</th><th align="left">简单定义</th></tr></thead><tbody><tr><td align="left">OCP</td><td align="left">开闭原则</td><td align="left">对扩展开放，对修改关闭</td></tr><tr><td align="left">SRP</td><td align="left">单一职责原则</td><td align="left">一个类只负责一个功能领域中的相应职责</td></tr><tr><td align="left">LSP</td><td align="left">里氏代换原则</td><td align="left">所有引用基类的地方必须能透明地使用其子类的对象</td></tr><tr><td align="left">DIP</td><td align="left">依赖倒转原则</td><td align="left">依赖于抽象，不能依赖于具体实现</td></tr><tr><td align="left">ISP</td><td align="left">接口隔离原则</td><td align="left">类之间的依赖关系应该建立在最小的接口上</td></tr><tr><td align="left">CARP</td><td align="left">合成&#x2F;聚合复用原则</td><td align="left">尽量使用合成&#x2F;聚合，而不是通过继承达到复用的目的</td></tr><tr><td align="left">LOD</td><td align="left">迪米特法则</td><td align="left">一个软件实体应当尽可能少的与其他实体发生相互作用</td></tr></tbody></table><p>其中，单一职责原则、开闭原则、迪米特法则、里氏代换原则和接口隔离原则就是我们平常熟知的<strong>SOLID</strong>。</p><h2 id="switch语句支持的数据类型："><a href="#switch语句支持的数据类型：" class="headerlink" title="switch语句支持的数据类型："></a>switch语句支持的数据类型：</h2><p><code>switch</code> 语句是 Java 中一个非常实用的控制流语句，它能够根据变量的值来选择不同的执行路径。从 Java 7 开始，<code>switch</code> 语句支持的数据类型有了显著的扩展。</p><p><code>switch</code> 语句作用的数据类型包括：</p><hr><h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a><strong>1. 基本数据类型</strong></h3><ul><li><strong>byte</strong></li><li><strong>short</strong></li><li><strong>char</strong></li><li><strong>int</strong></li></ul><p><strong>注意：</strong></p><ul><li><code>switch</code> 语句不支持 <code>long</code>、<code>float</code>、<code>double</code> 或 <code>boolean</code> 类型。</li><li>如果你的变量是 <code>long</code> 类型，你需要将其强制转换为 <code>int</code> 类型才能在 <code>switch</code> 中使用，但这可能导致数据丢失，通常不推荐。</li></ul><hr><h3 id="2-包装类"><a href="#2-包装类" class="headerlink" title="2. 包装类"></a><strong>2. 包装类</strong></h3><ul><li><strong>Byte</strong></li><li><strong>Short</strong></li><li><strong>Character</strong></li><li><strong>Integer</strong></li></ul><p>这是因为 Java 编译器在编译时会进行<strong>自动拆箱（autounboxing）</strong>，将包装类对象自动转换为对应的基本数据类型。</p><hr><h3 id="3-枚举类型-enum"><a href="#3-枚举类型-enum" class="headerlink" title="3. 枚举类型 (enum)"></a><strong>3. 枚举类型 (enum)</strong></h3><ul><li><strong>从 Java 5 开始</strong>，<code>switch</code> 语句开始支持枚举类型。</li><li>使用枚举可以使代码更具可读性和安全性，因为编译器会检查所有 <code>case</code> 标签是否对应了枚举中的有效常量。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Day</span> <span class="variable">day</span> <span class="operator">=</span> Day.MONDAY;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s Monday.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s Sunday.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s a weekday.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-String-类型"><a href="#4-String-类型" class="headerlink" title="4. String 类型"></a><strong>4. String 类型</strong></h3><ul><li><strong>从 Java 7 开始</strong>，<code>switch</code> 语句开始支持 <code>String</code> 类型。</li><li>这个特性极大地简化了基于字符串的条件判断代码，避免了大量的 <code>if-else if-else</code> 链。</li><li>在底层，编译器通过 <code>String</code> 对象的 <code>hashCode()</code> 和 <code>equals()</code> 方法来执行 <code>switch</code> 逻辑。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;You chose an apple.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;orange&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;You chose an orange.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown fruit.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><table><thead><tr><th>支持类型</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td><code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code></td><td>所有版本</td><td><code>switch</code> 的基础类型。</td></tr><tr><td><code>Byte</code>, <code>Short</code>, <code>Character</code>, <code>Integer</code></td><td>所有版本</td><td>自动拆箱机制使其可用。</td></tr><tr><td><code>enum</code></td><td>Java 5+</td><td>增强代码的可读性和安全性。</td></tr><tr><td><code>String</code></td><td>Java 7+</td><td>极大地简化了字符串判断逻辑。</td></tr></tbody></table><p>记住，无论使用哪种类型，<code>case</code> 标签后面的值都必须是<strong>编译时常量</strong>。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="1-内置锁：synchronized-关键字"><a href="#1-内置锁：synchronized-关键字" class="headerlink" title="1. 内置锁：synchronized 关键字"></a>1. 内置锁：<code>synchronized</code> 关键字</h3><p><code>synchronized</code>是Java语言层面的同步机制，使用起来相对简单。它可以修饰方法或代码块，由JVM负责加锁和释放锁，开发者不需要手动管理。</p><ul><li><strong>同步方法：</strong> 当你用<code>synchronized</code>修饰一个非静态方法时，锁对象是这个方法的实例对象（<code>this</code>）。当一个线程进入这个同步方法时，它会获得该实例的锁，其他线程就无法进入这个实例的任何同步方法，直到它释放锁。</li><li><strong>同步静态方法：</strong> 当<code>synchronized</code>修饰一个静态方法时，锁对象是该类的<code>Class</code>对象。这意味着所有线程在访问这个类的任何同步静态方法时都会争抢同一把锁，无论有多少个实例。</li><li><strong>同步代码块：</strong> <code>synchronized (object)</code>。这是最灵活的使用方式，你可以指定任何对象作为锁。通过缩小同步范围，可以减少锁的持有时间，从而提高程序的并发性能。</li></ul><p><strong>synchronized的特点：</strong></p><ul><li><strong>可重入性（Reentrant）：</strong> 一个线程可以重复获取它已经持有的锁，避免死锁。</li><li><strong>非公平性（Unfair）：</strong> 默认情况下，线程获取锁的顺序是不确定的，先来的不一定先得到。</li><li><strong>锁的升级：</strong> 为了优化性能，<code>synchronized</code>锁的实现经历了从<strong>偏向锁</strong>、<strong>轻量级锁</strong>到<strong>重量级锁</strong>的升级过程。这使得在竞争不激烈的情况下，加锁的开销非常小。</li><li><strong>内存可见性（Visibility）：</strong> <code>synchronized</code>可以保证当一个线程释放锁时，它对共享变量所做的修改会立即刷新到主内存，而当另一个线程获取锁时，它会从主内存中读取最新的变量值。这是由Java内存模型（JMM）的<code>happens-before</code>规则保证的。</li></ul><h3 id="底层实现机制"><a href="#底层实现机制" class="headerlink" title="底层实现机制"></a>底层实现机制</h3><p>synchronized本质上是基于JVM的**内置锁（Intrinsic Lock）**实现的。每个Java对象都天生具备一个监视器锁（Monitor），这是JVM级别的原生支持。</p><p><strong>监视器的工作原理：</strong></p><ul><li>当线程进入synchronized代码块时，会执行monitorenter指令获取对象的监视器</li><li>当线程退出时，执行monitorexit指令释放监视器</li><li>如果获取失败，线程会被阻塞在操作系统级别</li></ul><h3 id="锁升级的演进过程"><a href="#锁升级的演进过程" class="headerlink" title="锁升级的演进过程"></a>锁升级的演进过程</h3><p>synchronized的性能优化经历了一个复杂的演进过程，从最初的重量级锁逐步优化：</p><p><strong>偏向锁阶段：</strong><br>当只有一个线程反复进入同步块时，JVM会将锁偏向于这个线程。此时的开销极低，几乎等同于无锁操作。对象头中会记录偏向的线程ID，后续该线程进入时直接通过简单的比较就能获取锁。</p><p><strong>轻量级锁阶段：</strong><br>当有其他线程开始竞争时，偏向锁会升级为轻量级锁。JVM在当前线程的栈帧中创建锁记录（Lock Record），通过CAS操作尝试将对象头的Mark Word替换为指向锁记录的指针。这个过程避免了操作系统层面的阻塞。</p><p><strong>重量级锁阶段：</strong><br>当CAS操作失败次数过多或者有多个线程同时竞争时，锁会膨胀为重量级锁。此时会创建Monitor对象，利用操作系统的互斥量（Mutex）来实现同步，涉及用户态和内核态的切换。</p><hr><h4 id="JVM-锁的升级过程"><a href="#JVM-锁的升级过程" class="headerlink" title="JVM 锁的升级过程"></a>JVM 锁的升级过程</h4><p>JVM 的对象锁在多线程访问时会经历 <strong>偏向锁 → 轻量级锁 → 重量级锁</strong> 的升级过程。下面详细说明每一步。</p><hr><h5 id="1-普通对象（无锁状态）"><a href="#1-普通对象（无锁状态）" class="headerlink" title="1. 普通对象（无锁状态）"></a>1. 普通对象（无锁状态）</h5><ul><li>对象未被任何线程持有锁时：<ul><li>Mark Word 中记录 <strong>对象的 HashCode</strong>。</li><li>锁标志位：<code>01</code>（表示无锁）。</li><li>是否偏向锁位：<code>0</code>。</li></ul></li></ul><blockquote><p>此时对象只是普通对象，没有同步锁。</p></blockquote><hr><h5 id="2-偏向锁初始化（第一次加锁）"><a href="#2-偏向锁初始化（第一次加锁）" class="headerlink" title="2. 偏向锁初始化（第一次加锁）"></a>2. 偏向锁初始化（第一次加锁）</h5><ul><li>线程 <strong>A</strong> 获取锁：<ul><li>锁标志位仍为 <code>01</code>（无锁标志）。</li><li>偏向锁标志位改为 <code>1</code>，表示对象进入 <strong>偏向锁状态</strong>。</li><li>Mark Word 的前 23 bit 保存 <strong>线程 A 的线程 ID</strong>。</li></ul></li></ul><blockquote><p>偏向锁用于优化单线程访问锁的性能，减少同步开销。</p></blockquote><hr><h5 id="3-偏向锁重入（线程-A-再次获取锁）"><a href="#3-偏向锁重入（线程-A-再次获取锁）" class="headerlink" title="3. 偏向锁重入（线程 A 再次获取锁）"></a>3. 偏向锁重入（线程 A 再次获取锁）</h5><ul><li>线程 <strong>A</strong> 再次尝试获取锁：<ul><li>JVM 检查对象标志位：<ul><li>锁标志位 <code>01</code></li><li>偏向锁位 <code>1</code></li><li>Mark Word 中线程 ID &#x3D; A 的 ID</li></ul></li><li>由于线程 A 已持有偏向锁，直接进入同步代码，无需 CAS 操作。</li></ul></li></ul><blockquote><p>偏向锁允许线程重复获取锁，性能开销极低。</p></blockquote><hr><h5 id="4-偏向锁竞争（线程-B-尝试获取锁）"><a href="#4-偏向锁竞争（线程-B-尝试获取锁）" class="headerlink" title="4. 偏向锁竞争（线程 B 尝试获取锁）"></a>4. 偏向锁竞争（线程 B 尝试获取锁）</h5><ul><li>线程 <strong>B</strong> 尝试获取锁：<ul><li>JVM 检查对象偏向锁：<ul><li>锁标志位 <code>01</code></li><li>偏向锁位 <code>1</code></li><li>Mark Word 中线程 ID ≠ B</li></ul></li><li>线程 B <strong>尝试通过 CAS 抢锁</strong>：<ul><li>成功：偏向锁切换到线程 B，Mark Word 更新为 B 的线程 ID</li><li>失败：表示竞争存在，进入下一步升级轻量级锁</li></ul></li></ul></li></ul><blockquote><p>偏向锁竞争失败时，说明锁开始有多线程访问，需要升级锁状态。</p></blockquote><hr><h5 id="5-轻量级锁（Lightweight-Lock）"><a href="#5-轻量级锁（Lightweight-Lock）" class="headerlink" title="5. 轻量级锁（Lightweight Lock）"></a>5. 轻量级锁（Lightweight Lock）</h5><ul><li>JVM 为当前线程在 <strong>栈帧</strong>中分配一块空间，称为 <strong>锁记录区（Lock Record）</strong>：<ul><li>保存指向对象 Mark Word 的指针</li></ul></li><li>对象 Mark Word 保存指向锁记录区的指针</li><li>CAS 操作同时更新两处指针：<ul><li>成功：线程获得轻量级锁，执行同步代码，锁标志位改为 <code>00</code>（轻量级锁状态）</li><li>失败：竞争激烈，进入自旋阶段</li></ul></li></ul><blockquote><p>轻量级锁适合 <strong>多线程少量竞争</strong> 场景，性能较好。</p></blockquote><hr><h5 id="6-自旋锁（Spin-Lock）"><a href="#6-自旋锁（Spin-Lock）" class="headerlink" title="6. 自旋锁（Spin Lock）"></a>6. 自旋锁（Spin Lock）</h5><ul><li>线程尝试获取轻量级锁失败：<ul><li>JVM <strong>自旋重试</strong>（循环尝试抢锁）</li><li>自旋次数由 JVM 决定（JDK 1.7 默认启用）</li><li>成功：执行同步代码</li><li>失败：锁升级为重量级锁</li></ul></li></ul><blockquote><p>自旋锁适合锁竞争短暂的情况，避免线程阻塞带来的开销。</p></blockquote><hr><h5 id="7-重量级锁（Heavyweight-Lock）"><a href="#7-重量级锁（Heavyweight-Lock）" class="headerlink" title="7. 重量级锁（Heavyweight Lock）"></a>7. 重量级锁（Heavyweight Lock）</h5><ul><li>自旋失败后，锁升级为 <strong>重量级锁</strong>：<ul><li>锁标志位改为 <code>10</code></li><li>线程未抢到锁的会被阻塞（挂起）</li><li>系统线程调度负责唤醒等待线程</li></ul></li></ul><blockquote><p>重量级锁性能开销较大，使用操作系统互斥机制。<br> 只有当轻量级锁和自旋锁都无法满足需求时才会升级。</p></blockquote><hr><h5 id="🔑-总结锁升级过程"><a href="#🔑-总结锁升级过程" class="headerlink" title="🔑 总结锁升级过程"></a>🔑 总结锁升级过程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">无锁状态（01 + 偏向位0）</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">偏向锁（01 + 偏向位1 + 线程ID）</span><br><span class="line">       │</span><br><span class="line">       ▼   线程竞争</span><br><span class="line">轻量级锁（00 + 指向栈帧锁记录区）</span><br><span class="line">       │</span><br><span class="line">       ▼   CAS 失败 / 高竞争</span><br><span class="line">自旋锁（不断自旋尝试抢锁）</span><br><span class="line">       │</span><br><span class="line">       ▼   自旋失败</span><br><span class="line">重量级锁（10 + 阻塞等待）</span><br></pre></td></tr></table></figure><blockquote><p>JVM 通过 <strong>锁膨胀机制</strong>（Lock Inflation）逐步升级锁，尽量在多线程争用情况下保证性能。</p></blockquote><h5 id="自动化的特点"><a href="#自动化的特点" class="headerlink" title="自动化的特点"></a>自动化的特点</h5><p>synchronized的最大特点是<strong>完全自动化</strong>。程序员无需关心锁的获取和释放时机，JVM会自动处理所有细节。即使在异常情况下，JVM也能保证锁的正确释放，这大大降低了死锁和资源泄露的风险。</p><h3 id="2-显式锁：java-util-concurrent-locks-Lock"><a href="#2-显式锁：java-util-concurrent-locks-Lock" class="headerlink" title="2. 显式锁：java.util.concurrent.locks.Lock"></a>2. 显式锁：<code>java.util.concurrent.locks.Lock</code></h3><p>从JDK 1.5开始，<code>java.util.concurrent.locks</code>包提供了更灵活、更强大的锁机制，其核心是<code>Lock</code>接口。最常用的实现类是**<code>ReentrantLock</code>**。</p><p>使用<code>Lock</code>需要手动进行加锁和解锁操作，通常是在<code>try...finally</code>块中进行，以确保锁在任何情况下都能被释放，防止死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 访问共享资源的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Lock相比synchronized的优势：</strong></p><ul><li><strong>中断锁（Interruptibly）：</strong> <code>Lock</code>提供了<code>lockInterruptibly()</code>方法，允许在等待锁的过程中响应中断。而<code>synchronized</code>的线程如果陷入等待锁的状态，是无法被中断的。</li><li><strong>尝试获取锁（tryLock）：</strong> <code>Lock</code>提供了<code>tryLock()</code>和<code>tryLock(long timeout, TimeUnit unit)</code>方法，可以尝试获取锁，如果失败则立即返回或在指定时间内放弃，避免无限等待。</li><li><strong>公平锁与非公平锁：</strong> <code>ReentrantLock</code>可以创建公平锁（Fair Lock）。公平锁会按照线程请求锁的顺序来分配锁，虽然这可能会带来一些性能开销。而<code>synchronized</code>只能是非公平锁。</li><li><strong>绑定多个条件（Condition）：</strong> <code>Lock</code>配合<code>Condition</code>接口，可以实现更灵活的线程等待和唤醒机制，类似<code>Object</code>的<code>wait()</code>和<code>notify()</code>，但功能更强大，一个锁可以有多个等待队列。</li><li><strong>读写锁（ReadWriteLock）：</strong> <code>ReadWriteLock</code>是<code>Lock</code>的另一个重要实现，它维护了一对锁：一个用于读操作，一个用于写操作。在读多写少的场景下，多个线程可以同时获取读锁，大大提高了并发性能，只有写操作才需要获取独占的写锁。<code>ReentrantReadWriteLock</code>是其具体实现。</li></ul><h3 id="Lock接口的设计理念"><a href="#Lock接口的设计理念" class="headerlink" title="Lock接口的设计理念"></a>Lock接口的设计理念</h3><h3 id="显式锁机制"><a href="#显式锁机制" class="headerlink" title="显式锁机制"></a>显式锁机制</h3><p>Lock接口代表了Java并发包中<strong>显式锁</strong>的设计思想。与synchronized的隐式锁不同，Lock要求程序员明确控制锁的生命周期，这带来了更大的灵活性，同时也增加了使用的复杂性。</p><h3 id="AQS框架的核心思想"><a href="#AQS框架的核心思想" class="headerlink" title="AQS框架的核心思想"></a>AQS框架的核心思想</h3><p>Lock接口的实现基于AbstractQueuedSynchronizer（AQS）框架，这是Doug Lea设计的一个并发框架的杰作。</p><p><strong>同步状态的抽象：</strong><br>AQS使用一个int值来表示同步状态，不同的锁实现可以赋予这个状态不同的含义。比如ReentrantLock用它表示重入次数，Semaphore用它表示许可证数量。</p><p><strong>队列化的等待机制：</strong><br>当线程无法获取锁时，AQS会将其包装成节点加入到一个FIFO队列中。这个队列使用双向链表实现，每个节点都包含了线程引用和等待状态信息。</p><p><strong>自旋与阻塞的平衡：</strong><br>AQS巧妙地结合了自旋和阻塞两种等待策略。线程在入队后会先进行有限次数的自旋尝试，只有在确定无法获取锁时才会调用LockSupport.park()进入阻塞状态。</p><h3 id="3-volatile-关键字"><a href="#3-volatile-关键字" class="headerlink" title="3. volatile 关键字"></a>3. <code>volatile</code> 关键字</h3><p><code>volatile</code>关键字并不是一个锁，它是一种轻量级的同步机制，主要用于保证共享变量的<strong>可见性</strong>和<strong>有序性</strong>。</p><ul><li><strong>可见性（Visibility）：</strong> 当一个变量被<code>volatile</code>修饰后，一个线程对它的修改会立即被其他线程可见。这是通过在写操作后添加内存屏障，强制将修改后的值刷新到主内存，并在读操作前添加内存屏障，强制从主内存中读取最新值来实现的。</li><li><strong>有序性（Ordering）：</strong> <code>volatile</code>可以禁止指令重排序，确保代码的执行顺序不会被打乱。</li><li><strong>无法保证原子性（Atomicity）：</strong> <code>volatile</code>无法保证复合操作（如<code>i++</code>）的原子性，因为<code>i++</code>实际上是读、加、写三个操作的组合，这三个操作并非一次完成。如果要保证原子性，需要使用<code>synchronized</code>、<code>Lock</code>或<code>java.util.concurrent.atomic</code>包下的原子类。</li></ul><p><strong>总结一下：</strong></p><table><thead><tr><th>特性</th><th><code>synchronized</code></th><th><code>Lock</code> (如<code>ReentrantLock</code>)</th><th><code>volatile</code></th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>独占锁，保证原子性、可见性、有序性</td><td>独占锁，功能更强大，保证原子性、可见性、有序性</td><td>轻量级同步，只保证可见性和有序性</td></tr><tr><td><strong>使用方式</strong></td><td>关键字，自动加锁和解锁</td><td>接口，需要手动加锁和解锁，必须在<code>finally</code>块中释放</td><td>关键字，修饰变量</td></tr><tr><td><strong>灵活性</strong></td><td>较差，功能固定</td><td>强，提供了更多高级功能，如可中断、超时、公平锁等</td><td>较差，只针对变量</td></tr><tr><td><strong>性能</strong></td><td>JVM优化后性能较高，开销相对较小</td><td>高性能，在竞争激烈时通常优于<code>synchronized</code></td><td>非常高，几乎没有开销</td></tr><tr><td><strong>适用场景</strong></td><td>简单的同步需求，大部分情况都适用</td><td>高级同步需求，需要灵活控制锁的获取和释放</td><td>变量的写操作不依赖于当前值，需要保证变量的可见性。</td></tr></tbody></table><h3 id="4-乐观锁-Optimistic-Locking"><a href="#4-乐观锁-Optimistic-Locking" class="headerlink" title="4. 乐观锁 (Optimistic Locking)"></a>4. 乐观锁 (Optimistic Locking)</h3><p>与之前讨论的<strong>悲观锁</strong>（<code>synchronized</code>和<code>Lock</code>）不同，乐观锁并非一个具体的Java关键字或类，而是一种<strong>并发控制的思想和策略</strong>。悲观锁认为“总会有其他线程来修改数据”，所以在访问共享资源前，先对资源加锁，确保独占访问。而乐观锁则认为“数据冲突发生的概率很小”，所以它<strong>不加锁</strong>，而是假设所有线程都能正常执行，只有在数据更新提交时，才去检查在此期间数据是否被其他线程修改过。</p><p>如果检查到数据没有被修改，则更新成功。如果发现数据已经被修改，则更新失败。处理失败的方式通常有两种：</p><ol><li><strong>重试：</strong> 循环尝试，直到更新成功为止。</li><li><strong>放弃：</strong> 抛出异常或直接返回失败，由调用方处理。</li></ol><p><strong>乐观锁的实现方式：</strong></p><p>乐观锁的核心在于如何“检查数据是否被修改”。在Java中，常见的实现方式有两种：</p><ul><li><p>版本号（Version Number）：</p><p>在数据表中增加一个version字段。每次读取数据时，也把version字段读出来。当要进行数据更新时，带上之前读取的version值，在更新语句中加入WHERE version &#x3D; &lt;当前版本号&gt;的条件。如果更新成功，同时把version值加1。</p><ul><li><p><strong>SQL示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE products <span class="type">SET</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">100</span>, version = version + <span class="number">1</span></span><br><span class="line"><span class="type">WHERE</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">123</span> <span class="type">AND</span> <span class="variable">version</span> <span class="operator">=</span> &lt;之前读取的版本号&gt;;</span><br></pre></td></tr></table></figure></li><li><p><strong>原理：</strong> 如果在更新时，其他线程已经修改了这条数据，那么<code>version</code>值已经改变，上述<code>UPDATE</code>语句的<code>WHERE</code>条件将不成立，导致更新失败，影响行数为0。此时，你可以选择重试或放弃。</p></li></ul></li><li><p>CAS (Compare-And-Swap) 算法：</p><p>这是乐观锁在硬件层面的支持，也是Java中实现乐观锁的核心机制。CAS是一种原子操作，它包含三个操作数：</p><ul><li><strong>V (Value)：</strong> 内存地址中存放的旧值。</li><li><strong>A (Expected)：</strong> 预期的旧值。</li><li><strong>B (New)：</strong> 想要写入的新值。</li></ul><p>CAS的操作逻辑是：</p><p>如果内存地址V中的值等于预期值A，那么就将V的值更新为新值B。否则，什么都不做。整个操作是原子性的，由CPU指令直接完成。</p><p>Java中<code>java.util.concurrent.atomic</code>包下的所有原子类，如<code>AtomicInteger</code>、<code>AtomicLong</code>等，都是基于CAS实现的。</p><p><strong>AtomicInteger示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="comment">// 假设多个线程同时执行以下操作</span></span><br><span class="line">count.incrementAndGet(); <span class="comment">// 内部就是CAS操作</span></span><br></pre></td></tr></table></figure><p><code>incrementAndGet()</code>方法的内部实现类似于一个自旋重试的循环：</p><ol><li>获取当前值<code>current</code>。</li><li>计算新值<code>next = current + 1</code>。</li><li>使用CAS尝试将<code>current</code>更新为<code>next</code>。</li><li>如果更新失败（说明<code>current</code>已经被其他线程修改），则重新回到第一步，再次获取最新值并尝试更新。</li></ol></li></ul><p><strong>悲观锁与乐观锁的比较：</strong></p><table><thead><tr><th>特性</th><th>悲观锁 (<code>synchronized</code>, <code>Lock</code>)</th><th>乐观锁 (CAS, 版本号)</th></tr></thead><tbody><tr><td><strong>加锁方式</strong></td><td>独占资源时先加锁，阻止其他线程访问</td><td>不加锁，只在提交时进行冲突检测</td></tr><tr><td><strong>冲突处理</strong></td><td>线程排队等待锁，串行执行</td><td>线程失败后重试或放弃，并发执行</td></tr><tr><td><strong>适用场景</strong></td><td><strong>写操作多、竞争激烈</strong>的场景。数据冲突概率高。</td><td><strong>读操作多、写操作少</strong>的场景。数据冲突概率低。</td></tr><tr><td><strong>性能</strong></td><td>在高竞争环境下，线程切换和上下文开销大，性能下降。</td><td>在低竞争环境下，无锁开销，性能极高。在高竞争环境下，大量重试可能导致CPU开销增加。</td></tr></tbody></table><p><strong>总结：</strong></p><p>在Java中，<strong>悲观锁</strong>和<strong>乐观锁</strong>是两种截然不同的并发控制策略。悲观锁（<code>synchronized</code>, <code>Lock</code>）适合<strong>写多读少</strong>的场景，能够保证数据的一致性，但会牺牲一定的性能。而乐观锁（<strong>CAS</strong>、<strong>版本号</strong>）则适合<strong>读多写少</strong>的场景，通过无锁的并发操作提高了性能，但在高竞争下可能导致频繁重试，反而降低效率。理解这两种锁的思想，可以帮助你根据具体的业务场景选择最合适的并发控制方案。</p><hr><h3 id="5-死锁-Deadlock"><a href="#5-死锁-Deadlock" class="headerlink" title="5. 死锁 (Deadlock)"></a>5. 死锁 (Deadlock)</h3><p><strong>死锁</strong>是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法继续执行。</p><p><strong>死锁的产生</strong>是一个非常经典的多线程问题，通常发生在线程需要同时持有多个锁的场景中。一个简单的死锁场景是：线程A持有锁1，想获取锁2；而线程B持有锁2，想获取锁1。此时两个线程都无法继续执行，从而进入死锁状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h4><p>死锁的发生需要同时满足以下四个条件，缺一不可：</p><ol><li><strong>互斥条件（Mutual Exclusion）：</strong> 至少有一个资源是独占的，即一次只能被一个线程使用。这是锁本身的基本特性。</li><li><strong>请求与保持条件（Hold and Wait）：</strong> 一个线程因请求资源而阻塞时，它对自己已获得的资源保持不放。</li><li><strong>不剥夺条件（No Preemption）：</strong> 线程已获得的资源在未使用完之前，不能被强行剥夺，只能由该线程自己释放。</li><li><strong>循环等待条件（Circular Wait）：</strong> 存在一个线程等待链，其中每个线程都持有下一个线程所需的资源。例如：线程A等待线程B，线程B等待线程C，线程C又等待线程A。</li></ol><h4 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h4><p>解决死锁的根本思想是<strong>破坏上述四个必要条件之一或多个</strong>。通常，我们无法破坏互斥条件（因为资源就是独占的），因此主要从其他三个条件入手。</p><ol><li><strong>破坏“请求与保持”条件：</strong><ul><li><strong>一次性获取所有锁：</strong> 线程在开始执行时，就一次性获取所有需要的锁。如果获取不成功，则释放所有已获得的锁，然后等待一段时间后再次尝试。</li><li><strong>优点：</strong> 简单有效。</li><li><strong>缺点：</strong> 可能会降低并发性，因为线程在很早就持有了锁，即使这些锁在后面才被使用。</li></ul></li><li><strong>破坏“不剥夺”条件：</strong><ul><li><strong>使用可中断的锁：</strong> 使用<code>Lock</code>接口提供的<code>tryLock()</code>方法。当一个线程尝试获取锁失败时，它可以选择放弃并释放已持有的锁，而不是一直等待。<code>Lock.tryLock(long time, TimeUnit unit)</code>方法可以在指定时间内尝试获取锁，超时后会放弃。</li><li><strong>优点：</strong> 提高了灵活性，线程可以响应中断或超时，避免无限等待。</li><li><strong>缺点：</strong> 实现起来相对复杂，需要开发者手动处理获取锁失败的情况。</li></ul></li><li><strong>破坏“循环等待”条件：</strong><ul><li><strong>按顺序获取锁：</strong> 对所有的锁进行排序，并强制所有线程都按照相同的顺序获取锁。</li><li><strong>示例：</strong> 如果线程A和线程B都需要<code>lock1</code>和<code>lock2</code>，那么它们都必须先获取<code>lock1</code>，再获取<code>lock2</code>。这样就杜绝了线程A持有<code>lock1</code>等待<code>lock2</code>，同时线程B持有<code>lock2</code>等待<code>lock1</code>的循环。</li><li><strong>优点：</strong> 这是最常用、最有效的死锁解决方案，实现起来也相对简单。</li><li><strong>缺点：</strong> 有时很难对所有锁进行全局排序，特别是在代码模块化程度较高、依赖关系复杂的情况下。</li></ul></li></ol><p><strong>总结：</strong></p><p>在实际开发中，预防死锁的最佳实践通常是<strong>破坏循环等待条件</strong>，即<strong>统一锁的获取顺序</strong>。这是最简单且最有效的方案。如果业务场景需要更灵活的控制，可以考虑使用<code>Lock</code>接口，利用<code>tryLock()</code>方法来破坏“不剥夺”条件，实现更复杂的死锁处理逻辑。</p><hr><h3 id="银行家算法概述"><a href="#银行家算法概述" class="headerlink" title="银行家算法概述"></a>银行家算法概述</h3><p>银行家算法是一种著名的<strong>死锁避免算法</strong>，由荷兰计算机科学家Dijkstra在1965年提出。它的核心思想是：在每次分配资源之前，先进行一次<strong>安全性检查</strong>。如果分配后系统仍然处于<strong>安全状态</strong>，则分配资源；否则，不予分配，线程需要等待。</p><ul><li>优点：比死锁预防更灵活，能提高资源利用率。</li><li>缺点：算法复杂，需要预知进程的最大资源需求，并且系统开销大。</li></ul><p>之所以叫“银行家算法”，是因为它的工作原理类似于银行管理贷款。银行家在发放贷款时，会先确保这笔贷款发放后，自己还有足够的资金来满足所有客户可能提出的最大取款需求，从而避免因无法支付而破产的风险。</p><p>简单来说，银行家算法通过以下两个步骤来避免死锁：</p><ol><li><strong>安全状态的定义：</strong> 系统能够找到一个<strong>安全序列</strong>，使得所有线程都能按照这个序列执行完毕。</li><li><strong>资源分配策略：</strong> 当一个线程请求资源时，算法会先假设分配成功，然后检查系统是否仍处于安全状态。如果安全，就真的分配；如果不安全，就拒绝分配。</li></ol><hr><h3 id="银行家算法中的几个重要数据结构"><a href="#银行家算法中的几个重要数据结构" class="headerlink" title="银行家算法中的几个重要数据结构"></a>银行家算法中的几个重要数据结构</h3><p>为了实现算法，需要维护以下几个关键数据结构，假设系统中有<code>n</code>个线程和<code>m</code>种资源：</p><ul><li><strong>Available (可用资源矩阵)：</strong> 一个长度为<code>m</code>的向量。<code>Available[j]</code>表示第<code>j</code>种资源目前可用的数量。</li><li><strong>Max (最大需求矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Max[i, j]</code>表示线程<code>i</code>最多需要第<code>j</code>种资源多少个。</li><li><strong>Allocation (已分配资源矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Allocation[i, j]</code>表示线程<code>i</code>目前已拥有第<code>j</code>种资源多少个。</li><li><strong>Need (需求矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Need[i, j]</code>表示线程<code>i</code>还需要第<code>j</code>种资源多少个才能完成任务。<ul><li><code>Need[i, j] = Max[i, j] - Allocation[i, j]</code></li></ul></li></ul><hr><h3 id="银行家算法的核心：安全状态的判断"><a href="#银行家算法的核心：安全状态的判断" class="headerlink" title="银行家算法的核心：安全状态的判断"></a>银行家算法的核心：安全状态的判断</h3><p>判断系统是否处于安全状态是银行家算法的核心。一个系统处于<strong>安全状态</strong>，当且仅当存在一个<strong>安全序列</strong><code>&lt;P1, P2, ..., Pn&gt;</code>。这个序列满足：对于序列中每一个线程<code>Pi</code>，它所需要的资源都能由系统中当前可用的资源，以及前面所有已完成的线程释放的资源来满足。</p><p><strong>安全性检查算法的步骤：</strong></p><ol><li><strong>初始化：</strong><ul><li>创建一个<code>Work</code>向量，初始化为<code>Available</code>（即当前可用资源）。</li><li>创建一个<code>Finish</code>向量，初始化为<code>false</code>，表示所有线程都未完成。</li></ul></li><li><strong>寻找安全线程：</strong><ul><li>从所有线程中找到一个线程<code>i</code>，满足以下两个条件：<ul><li><code>Finish[i]</code>为<code>false</code>。</li><li><code>Need[i]</code>向量中的每一个值都小于或等于<code>Work</code>向量中对应的值。</li><li>换句话说，线程<code>i</code>所需要的资源小于或等于当前可用的资源。</li></ul></li></ul></li><li><strong>释放资源：</strong><ul><li>如果找到了这样的线程<code>i</code>，则认为它可以顺利执行完毕。</li><li>模拟该线程执行完毕并释放资源，更新<code>Work</code>向量：<code>Work = Work + Allocation[i]</code>。</li><li>将<code>Finish[i]</code>设置为<code>true</code>。</li></ul></li><li><strong>循环检查：</strong><ul><li>重复步骤2和步骤3，直到找不到满足条件的线程。</li></ul></li><li><strong>判断结果：</strong><ul><li>如果最终所有线程的<code>Finish</code>都为<code>true</code>，则说明找到了一个安全序列，系统处于<strong>安全状态</strong>。</li><li>如果还有线程的<code>Finish</code>为<code>false</code>，则说明系统处于<strong>不安全状态</strong>，可能存在死锁。</li></ul></li></ol><hr><h3 id="银行家算法的流程：资源分配"><a href="#银行家算法的流程：资源分配" class="headerlink" title="银行家算法的流程：资源分配"></a>银行家算法的流程：资源分配</h3><p>当一个线程<code>P</code>请求资源时，银行家算法会执行以下步骤：</p><ol><li><strong>请求检查：</strong> 检查线程<code>P</code>请求的资源数量是否小于或等于其<code>Need</code>向量中的需求量。如果不是，说明线程<code>P</code>的请求不合理，拒绝分配。</li><li><strong>可用性检查：</strong> 检查线程<code>P</code>请求的资源数量是否小于或等于当前<code>Available</code>中的资源数量。如果不是，说明资源不足，线程<code>P</code>需要等待。</li><li><strong>预分配并进行安全性检查：</strong><ul><li>假设资源可以分配，<strong>临时</strong>进行以下操作：<ul><li><code>Available = Available - Request</code></li><li><code>Allocation[P] = Allocation[P] + Request</code></li><li><code>Need[P] = Need[P] - Request</code></li></ul></li><li>调用上面的<strong>安全性检查算法</strong>，判断系统是否处于安全状态。</li></ul></li><li><strong>正式分配或拒绝：</strong><ul><li>如果安全性检查的结果是<strong>安全</strong>，则正式分配资源，并保留步骤3中的修改。</li><li>如果安全性检查的结果是<strong>不安全</strong>，则回滚步骤3中的所有临时修改，拒绝分配资源，线程<code>P</code>需要等待。</li></ul></li></ol><h3 id="银行家算法的优缺点"><a href="#银行家算法的优缺点" class="headerlink" title="银行家算法的优缺点"></a>银行家算法的优缺点</h3><ul><li><strong>优点：</strong><ul><li>可以有效地避免死锁的发生，保证系统的安全性。</li><li>通过提前检查，可以最大化地利用资源，提高系统的并发性。</li></ul></li><li><strong>缺点：</strong><ul><li><strong>计算开销大：</strong> 每次分配资源都需要运行安全性检查算法，增加了系统的开销。</li><li><strong>过于保守：</strong> 安全状态不等于无死锁，不安全状态也不等于一定发生死锁。算法为了确保安全，可能会拒绝一些本可以成功分配的请求，从而降低了系统的吞吐量。</li><li><strong>条件苛刻：</strong> 算法要求线程在开始前就声明其所需的最大资源量，这在实际应用中很难做到。</li><li><strong>资源数量固定：</strong> 算法假设系统中资源的数量是固定的，不能动态增减。</li></ul></li></ul><p>因此，银行家算法虽然在理论上非常完美，但在实际操作系统中很少被直接完整地实现。然而，它的核心思想——<strong>通过安全性检查来避免死锁</strong>——仍然是许多并发控制策略的重要理论基础。                                     </p><h3 id="实际应用中的死锁处理"><a href="#实际应用中的死锁处理" class="headerlink" title="实际应用中的死锁处理"></a>实际应用中的死锁处理</h3><p>在实际的并发编程和数据库系统中，最常见的死锁处理方式是：</p><ul><li><p>死锁预防(通过编程规范)：</p><ul><li>加锁顺序一致：规定所有线程在获取多个锁时，必须按照相同的顺序。这是最有效的预防死锁的编程实践。</li><li>使用超时锁：尝试获取锁时设置一个超时时间，如果超时未获取到锁，则放弃本次操作并释放已持有的锁，然后重试。这破坏了”请求与保持”条件。例如Java的ReentrantLocktryLock(timeout)。</li><li>避免嵌套锁：尽量减少持有多个锁的情况。</li></ul></li><li><p>死锁检测与恢复(数据库系统)：</p><ul><li>大多数关系型数据库(如MySQL InnoDB)都实现了死锁检测机制。当检测到死锁时，数据库会自动选择一个成本较低的事务(“牺牲品”)进行回滚，从而解除死锁。客户端应用会收到相应的错误码(例如MySQL中的Deadlock found when trying to get lock; try restarting transaction)。应用程序通常需要捕获这个错误并重试事务。理解死锁的四个必要条件是关键，因为解决死锁的根本方法就是破坏其中一个或多个条件。</li></ul></li></ul><h2 id="锁扩展："><a href="#锁扩展：" class="headerlink" title="锁扩展："></a>锁扩展：</h2><h3 id="18-谈谈-synchronized-和-ReentrantLock-的区别？"><a href="#18-谈谈-synchronized-和-ReentrantLock-的区别？" class="headerlink" title="18. 谈谈 synchronized 和 ReentrantLock 的区别？"></a>18. 谈谈 synchronized 和 ReentrantLock 的区别？</h3><ol><li><code>synchronized</code> 是和 <code>for</code>、<code>while</code> 一样的关键字，<code>ReentrantLock</code> 是类，这是二者的本质区别。既然 <code>ReentrantLock</code> 是类，那么它就提供了比 <code>synchronized</code> 更多更灵活的特性：等待可中断、可实现公平锁、可实现选择性通知（锁可以绑定多个条件）、性能已不是选择标准。</li><li><code>synchronized</code> 依赖于 JVM 而 <code>ReenTrantLock</code> 依赖于 API。<code>synchronized</code> 是依赖于 JVM 实现的，JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReenTrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock</code> 方法配合 <code>try/finally</code> 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li></ol><hr><h3 id="19-synchronized-和-volatile-的区别是什么？"><a href="#19-synchronized-和-volatile-的区别是什么？" class="headerlink" title="19. synchronized 和 volatile 的区别是什么？"></a>19. synchronized 和 volatile 的区别是什么？</h3><ol><li><code>volatile</code> 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；<code>synchronized</code> 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li><code>volatile</code> 仅能使用在变量级别；<code>synchronized</code> 则可以使用在变量、方法、和类级别的。</li><li><code>volatile</code> 仅能实现变量的修改可见性，不能保证原子性；而 <code>synchronized</code> 则可以保证变量的修改可见性和原子性。</li><li><code>volatile</code> 不会造成线程的阻塞；<code>synchronized</code> 可能会造成线程的阻塞。</li><li><code>volatile</code> 标记的变量不会被编译器优化；<code>synchronized</code> 标记的变量可以被编译器优化。</li></ol><hr><h3 id="20-谈一下你对-volatile-关键字的理解？"><a href="#20-谈一下你对-volatile-关键字的理解？" class="headerlink" title="20. 谈一下你对 volatile 关键字的理解？"></a>20. 谈一下你对 volatile 关键字的理解？</h3><p><code>volatile</code> 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，这样做是为了减少流水线阻塞，提高 CPU 的执行效率。这就需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知道对不对了，所以有 <code>happens-before</code> 规则，其中有条就是 <code>volatile</code> 变量规则：对一个变量的写操作先行发生于后面面对这个变量的读操作、有序性实现的是通过插入内存屏障来保证的。</p><p>被 <code>volatile</code> 修饰的共享变量，就具有了以下两点特性：</p><ol><li>保证了不同线程对该变量操作的内存可见性;</li><li>禁止指令重排序。</li></ol><p>备注：这个题如果扩展了答，可以从 Java 的内存模型入手，下一篇 Java 虚拟机高频面试题中会讲到，这里不做过多赘述。</p><hr><h3 id="21-说下对-ReentrantReadWriteLock-的理解？"><a href="#21-说下对-ReentrantReadWriteLock-的理解？" class="headerlink" title="21. 说下对 ReentrantReadWriteLock 的理解？"></a>21. 说下对 ReentrantReadWriteLock 的理解？</h3><p><code>ReentrantReadWriteLock</code> 允许多个读线程同时访问，但是不允许写线程和读线程、写线程和写线程同时访问。读写锁内部维护了两个锁：一个是用于读操作的 <code>ReadLock</code>，一个是用于写操作的 <code>WriteLock</code>。读写锁 <code>ReentrantReadWriteLock</code> 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p><p><code>ReentrantReadWriteLock</code> 基于 <code>AQS</code> 实现，它的自定义同步器（继承 <code>AQS</code>）需要在同步状态 <code>state</code> 上维护多个读线程和一个写线程，该状态的设计成为实现读写锁的关键。<code>ReentrantReadWriteLock</code> 很好的利用了高低位。来实现一个整型控制两种状态的功能，读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写。</p><p><strong>ReentrantReadWriteLock 的特点</strong>：</p><ol><li>写锁可以降级为读锁，但是读锁不能升级为写锁；</li><li>不管是 <code>ReadLock</code> 还是 <code>WriteLock</code> 都支持 <code>Interrupt</code>，语义与 <code>ReentrantLock</code> 一致；</li><li><code>WriteLock</code> 支持 <code>Condition</code> 并且与 <code>ReentrantLock</code> 语义一致，而 <code>ReadLock</code> 则不能使用 <code>Condition</code>，否则抛出 <code>UnsupportedOperationException</code> 异常；</li><li>默认构造方法为非公平模式 ，开发者也可以通过指定 <code>fair</code> 为 <code>true</code> 设置为公平模式 。</li></ol><p><strong>升级&#x2F;降级</strong></p><ol><li>读锁里面加写锁，会导致死锁；</li><li>写锁里面是可以加读锁的，这就是锁的降级。</li></ol><h2 id="多线程与线程池"><a href="#多线程与线程池" class="headerlink" title="多线程与线程池"></a>多线程与线程池</h2><p>在 Java 中，多线程是实现并发编程的关键技术，它允许程序同时执行多个任务。线程池则是管理和复用线程的重要机制，能有效提升系统性能和资源利用率。</p><h3 id="⭐️什么是线程和进程"><a href="#⭐️什么是线程和进程" class="headerlink" title="⭐️什么是线程和进程?"></a><a href="#%E2%AD%90%EF%B8%8F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B">⭐️什么是线程和进程?</a></h3><h4 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a><a href="#%E4%BD%95%E4%B8%BA%E8%BF%9B%E7%A8%8B">何为进程?</a></h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><h4 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a><a href="#%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B">何为线程?</a></h4><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><hr><p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><p><strong>总结：</strong> 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><hr><h4 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84">程序计数器为什么是私有的?</a></h4><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h4 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84">虚拟机栈和本地方法栈为什么是私有的?</a></h4><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h4 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a><a href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA">一句话简单了解堆和方法区</a></h4><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><hr><h3 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h3><p>在 Java 中，<strong>Thread</strong> 类是多线程编程的核心。它代表了一个线程，并提供了丰富的 API 来创建、控制和管理线程的生命周期。理解 <code>Thread</code> 类及其方法对于编写高效、并发的 Java 应用程序至关重要。</p><hr><h4 id="1️⃣-进程（Process）"><a href="#1️⃣-进程（Process）" class="headerlink" title="1️⃣ 进程（Process）"></a>1️⃣ 进程（Process）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul><li><strong>进程</strong>是操作系统分配资源的最小单位，是程序运行的实例。</li><li>每个进程有 <strong>独立的地址空间</strong>、<strong>数据栈</strong> 和 <strong>堆</strong>，拥有自己的 <strong>文件描述符</strong> 和 <strong>系统资源</strong>。</li></ul><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>独立性强，互相隔离，安全性高。</li><li>进程切换代价大，需要操作系统保存和恢复上下文（寄存器、程序计数器、内存映射等）。</li><li>每个进程至少有一个主线程。</li></ol><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul><li>打开两个浏览器窗口，每个窗口是一个独立进程。</li><li>数据库服务、Web 服务器等也是独立进程。</li></ul><hr><h4 id="2️⃣-线程（Thread）"><a href="#2️⃣-线程（Thread）" class="headerlink" title="2️⃣ 线程（Thread）"></a>2️⃣ 线程（Thread）</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><ul><li><strong>线程</strong>是进程中的一个执行单元，是 CPU 调度的最小单位。</li><li>同一进程的线程共享进程的 <strong>地址空间、全局变量和文件描述符</strong>，但有 <strong>自己的栈和寄存器上下文</strong>。</li></ul><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ol><li>轻量级，相比进程切换开销小。</li><li>多线程可以共享进程资源，提高 CPU 利用率。</li><li>线程切换仍由操作系统调度完成（内核线程），属于抢占式多任务。</li></ol><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><ul><li>浏览器的主线程用于渲染页面，另一个线程用于下载文件。</li><li>Java 中 <code>Thread</code> 类或实现 <code>Runnable</code> 接口创建线程。</li></ul><hr><h4 id="3️⃣-协程（Coroutine）"><a href="#3️⃣-协程（Coroutine）" class="headerlink" title="3️⃣ 协程（Coroutine）"></a>3️⃣ 协程（Coroutine）</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><ul><li><strong>协程</strong>是一种用户态的轻量级线程，也叫微线程或纤程。</li><li>协程由 <strong>程序自身调度</strong>，不依赖操作系统线程切换。</li><li>同一线程内可以运行多个协程，通过 <strong>挂起（yield）和恢复（resume）</strong> 实现切换。</li></ul><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ol><li><strong>极轻量</strong>：内存占用小，可以成千上万个协程在一个线程内运行。</li><li><strong>非抢占式</strong>：协程切换由程序控制（主动让出），不会被操作系统抢占。</li><li><strong>共享线程资源</strong>：同一线程内的协程共享栈空间，可以避免线程上下文切换开销。</li><li>适合 I&#x2F;O 密集型任务，因为在等待 I&#x2F;O 时可以挂起切换其他协程。</li></ol><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><ul><li>Python 的 <code>asyncio</code>、Java 的 Project Loom、Go 的 goroutine。</li><li>游戏服务器或高并发网络服务常用协程处理大量连接。</li></ul><hr><h5 id="4️⃣-对比总结"><a href="#4️⃣-对比总结" class="headerlink" title="4️⃣ 对比总结"></a>4️⃣ 对比总结</h5><table><thead><tr><th>特性</th><th>进程 (Process)</th><th>线程 (Thread)</th><th>协程 (Coroutine)</th></tr></thead><tbody><tr><td>调度</td><td>OS 内核调度</td><td>OS 内核调度</td><td>用户态调度</td></tr><tr><td>内存空间</td><td>独立</td><td>共享进程地址空间</td><td>共享线程栈空间</td></tr><tr><td>切换开销</td><td>大（上下文切换）</td><td>较大（寄存器 + 栈切换）</td><td>小（只保存寄存器&#x2F;状态）</td></tr><tr><td>数量</td><td>较少</td><td>较多</td><td>成千上万</td></tr><tr><td>使用场景</td><td>独立程序、隔离资源</td><td>并行计算、CPU 密集任务</td><td>高并发 I&#x2F;O、轻量任务</td></tr><tr><td>切换方式</td><td>抢占式</td><td>抢占式</td><td>非抢占式</td></tr></tbody></table><hr><h5 id="5️⃣-关系与理解"><a href="#5️⃣-关系与理解" class="headerlink" title="5️⃣ 关系与理解"></a>5️⃣ 关系与理解</h5><ul><li><strong>进程包含线程</strong>：线程是进程的一部分，进程可以有多个线程。</li><li><strong>线程包含协程</strong>：协程运行在线程内部，是比线程更轻量的执行单元。</li><li><strong>层次关系</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程 &gt; 线程 &gt; 协程</span><br></pre></td></tr></table></figure><ul><li><strong>场景选择</strong>：<ul><li>CPU 密集型：多进程或多线程。</li><li>I&#x2F;O 密集型：协程更高效。</li></ul></li></ul><hr><h3 id="1-THREAD-类的基本概念"><a href="#1-THREAD-类的基本概念" class="headerlink" title="1. THREAD 类的基本概念"></a>1. THREAD 类的基本概念</h3><p><code>Thread</code> 类位于 <code>java.lang</code> 包中。每个 <code>Thread</code> 类的实例都代表一个独立的线程，这个线程能够并行执行代码。有两种主要方式可以创建一个线程：</p><ol><li><strong>继承 Thread 类</strong>：创建一个新的类并继承 <code>Thread</code>，然后重写其 <strong>run()</strong> 方法来定义线程的执行逻辑。</li><li><strong>实现 Runnable 接口</strong>：创建一个实现了 <code>Runnable</code> 接口的类，并将其实例作为参数传递给 <code>Thread</code> 构造器。这种方式更灵活，因为它允许你的类继承其他类。</li></ol><hr><h3 id="2-THREAD-类的主要方法详解"><a href="#2-THREAD-类的主要方法详解" class="headerlink" title="2. THREAD 类的主要方法详解"></a>2. THREAD 类的主要方法详解</h3><p>下面详细介绍 <code>Thread</code> 类中的常用和重要方法，并按其功能进行分类。</p><h4 id="线程生命周期控制"><a href="#线程生命周期控制" class="headerlink" title="线程生命周期控制"></a><strong>线程生命周期控制</strong></h4><p>这些方法用于启动、中断和协调线程的执行。</p><ul><li><strong>start()</strong>: <strong>启动</strong>线程。此方法会创建一个新的线程，并使它进入<strong>可运行 (Runnable)</strong> 状态。一旦操作系统调度这个线程，它的 <strong>run()</strong> 方法就会被调用。</li><li><strong>run()</strong>: 线程的<strong>执行体</strong>。当你调用 <code>start()</code> 方法时，JVM 会自动调用这个方法。如果你直接调用 <code>run()</code>，它只会被当作一个普通方法在当前线程中执行，而不会创建新线程。</li><li><strong>interrupt()</strong>: 向线程发送一个<strong>中断信号</strong>。此方法并不会立即停止线程。它只是设置一个<strong>中断标志</strong>。线程需要自己检查这个标志并决定如何响应。对于在 <code>sleep()</code>, <code>join()</code>, 或 <code>wait()</code> 等方法中阻塞的线程，这个方法会抛出 <code>InterruptedException</code>。</li><li><strong>join()</strong>: <strong>等待</strong>线程终止。调用此方法的线程（通常是主线程）会<strong>阻塞</strong>，直到被调用 <code>join()</code> 的线程执行结束。<ul><li><strong>join()</strong>: 永远等待，直到线程终止。</li><li><strong>join(long millis)</strong>: 最多等待指定的毫秒数。</li></ul></li></ul><h4 id="线程属性和状态查询"><a href="#线程属性和状态查询" class="headerlink" title="线程属性和状态查询"></a><strong>线程属性和状态查询</strong></h4><p>这些方法用于获取线程的当前状态或设置其属性。</p><ul><li><strong>getName()</strong>: 返回线程的名称。线程可以有一个自定义的名称，如果没有指定，则会有一个默认的名称，如 “Thread-0”。</li><li><strong>setName(String name)</strong>: 设置线程的名称。</li><li><strong>getState()</strong>: 返回线程的当前<strong>状态</strong>。返回值是一个枚举类型 <code>Thread.State</code>，包括 <code>NEW</code>, <code>RUNNABLE</code>, <code>BLOCKED</code>, <code>WAITING</code>, <code>TIMED_WAITING</code>, <code>TERMINATED</code>。</li><li><strong>isAlive()</strong>: 判断线程是否<strong>存活</strong>。如果线程已经启动但尚未终止，则返回 <code>true</code>。</li><li><strong>isDaemon()</strong>: 判断线程是否为<strong>守护线程</strong>。守护线程在所有非守护线程终止时会自动终止。例如，JVM 的垃圾回收线程就是一个守护线程。</li><li><strong>setDaemon(boolean on)</strong>: 将线程设置为守护线程或非守护线程。这个方法必须在线程启动前调用。</li><li><strong>getPriority()</strong>: 返回线程的<strong>优先级</strong>。优先级是一个整数，范围从 <code>MIN_PRIORITY</code> (1) 到 <code>MAX_PRIORITY</code> (10)。</li><li><strong>setPriority(int newPriority)</strong>: 设置线程的优先级。</li></ul><h4 id="静态方法-影响当前线程"><a href="#静态方法-影响当前线程" class="headerlink" title="静态方法 (影响当前线程)"></a><strong>静态方法 (影响当前线程)</strong></h4><p>这些方法直接作用于正在执行的线程。</p><ul><li><strong>Thread.currentThread()</strong>: 返回对<strong>当前正在执行</strong>的线程对象的引用。这是获取当前线程信息最常用的方法。</li><li><strong>Thread.sleep(long millis)</strong>: 使<strong>当前线程</strong>暂停执行指定的毫秒数。它会释放 CPU 资源，但不会释放锁。</li><li><strong>Thread.yield()</strong>: 提示调度器，<strong>当前线程</strong>愿意放弃当前的 CPU 使用权，让其他线程有机会运行。这是一个<strong>提示</strong>，不能保证一定生效。</li><li><strong>Thread.interrupted()</strong>: 测试<strong>当前线程</strong>是否被中断。此方法会<strong>清除</strong>中断标志。如果线程在调用时中断标志为 <code>true</code>，则返回 <code>true</code>，然后将中断标志重置为 <code>false</code>。</li></ul><hr><h3 id="3-THREAD-类方法使用示例"><a href="#3-THREAD-类方法使用示例" class="headerlink" title="3. THREAD 类方法使用示例"></a>3. THREAD 类方法使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethodsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建并启动线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行。状态：&quot;</span> + Thread.currentThread().getState());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 模拟耗时操作，并演示 sleep()</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 休眠 2 秒...&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 检查中断标志</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被中断了！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 捕获到 InterruptedException，线程被中断。&quot;</span>);</span><br><span class="line">                <span class="comment">// 捕获异常后重新设置中断标志</span></span><br><span class="line">                Thread.currentThread().interrupt(); </span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行结束。&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;WorkerThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程优先级和守护状态（必须在启动前）</span></span><br><span class="line">        worker.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        worker.setDaemon(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并打印线程信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程创建后，名称：&quot;</span> + worker.getName() + <span class="string">&quot;，优先级：&quot;</span> + worker.getPriority());</span><br><span class="line">        System.out.println(<span class="string">&quot;线程创建后，状态：&quot;</span> + worker.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        worker.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 使用 join() 等待 worker 线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待 WorkerThread 结束...&quot;</span>);</span><br><span class="line">        <span class="comment">// worker.join(1000); // 只等待 1 秒</span></span><br><span class="line">        worker.join(); <span class="comment">// 无限等待</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行。WorkerThread 的最终状态：&quot;</span> + worker.getState());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 再次检查是否存活</span></span><br><span class="line">        System.out.println(<span class="string">&quot;WorkerThread 是否存活：&quot;</span> + worker.isAlive());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 演示 interrupt()</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">interruptibleThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程在这里阻塞</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;interruptibleThread 被中断，捕获到异常。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        interruptibleThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="comment">// 确保线程进入休眠</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程中断 interruptibleThread...&quot;</span>);</span><br><span class="line">        interruptibleThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="一、守护线程-Daemon-Thread"><a href="#一、守护线程-Daemon-Thread" class="headerlink" title="一、守护线程 (Daemon Thread)"></a>一、守护线程 (Daemon Thread)</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul><li><strong>守护线程</strong>：是一种特殊的线程，它为其他线程（非守护线程）提供服务。</li><li><strong>特点</strong>：如果 JVM 中<strong>只剩下守护线程</strong>，那么 JVM 会自动退出。换句话说，守护线程的生命周期不依赖于自己，而是依赖于其他非守护线程。</li></ul><h4 id="2-与普通线程的区别"><a href="#2-与普通线程的区别" class="headerlink" title="2. 与普通线程的区别"></a>2. 与普通线程的区别</h4><ul><li><strong>普通线程（User Thread）</strong>：又称用户线程。如果 JVM 中还有一个用户线程在运行，JVM 就不会退出。</li><li><strong>守护线程</strong>：当所有用户线程都执行完毕后，JVM 会忽略仍在运行的守护线程，并直接终止。</li></ul><h4 id="3-常见用途"><a href="#3-常见用途" class="headerlink" title="3. 常见用途"></a>3. 常见用途</h4><ul><li>守护线程常用于执行一些后台任务，例如：<ul><li><strong>垃圾回收器 (Garbage Collector)</strong>：JVM 的垃圾回收线程就是典型的守护线程。它负责回收内存，但不会阻止 JVM 的退出。</li><li><strong>JIT (Just-In-Time) 编译器</strong>：同样是后台服务线程。</li><li><strong>日志记录</strong>：一些日志框架的异步日志线程可以设置为守护线程。</li></ul></li></ul><h4 id="4-如何创建和判断"><a href="#4-如何创建和判断" class="headerlink" title="4. 如何创建和判断"></a>4. 如何创建和判断</h4><ul><li><strong>创建</strong>：在线程启动前，调用 <code>setDaemon(true)</code> 方法。<ul><li><strong>注意</strong>：必须在 <code>start()</code> 方法调用之前设置，否则会抛出 <code>IllegalThreadStateException</code>。</li></ul></li><li><strong>判断</strong>：<code>isDaemon()</code> 方法可以判断一个线程是否为守护线程。</li></ul><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonThreadExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个用户线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">userThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;用户线程正在运行...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户线程执行完毕。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个守护线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;守护线程正在运行...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置为守护线程，必须在 start() 之前</span></span><br><span class="line">        daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        userThread.start();</span><br><span class="line">        daemonThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 观察结果：当用户线程执行完毕后，守护线程也会立即终止。</span></span><br><span class="line">        <span class="comment">// 如果把 setDaemon(true) 移除，守护线程会一直运行，导致程序不退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、join-方法"><a href="#二、join-方法" class="headerlink" title="二、join() 方法"></a>二、<code>join()</code> 方法</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul><li><code>join()</code> 方法的作用是<strong>等待调用该方法的线程执行完毕</strong>。</li><li><strong>比喻</strong>：主线程 A 调用了线程 B 的 <code>B.join()</code> 方法，那么主线程 A 会<strong>进入等待状态</strong>，直到线程 B 执行结束，主线程 A 才会继续执行。</li></ul><h4 id="2-主要用途"><a href="#2-主要用途" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h4><ul><li>确保线程间的执行顺序。当一个线程的执行依赖于另一个线程的执行结果时，<code>join()</code> 方法非常有用。</li></ul><h4 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1执行完毕。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2执行完毕。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待 thread1 和 thread2 执行完毕</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待线程1执行完毕...&quot;</span>);</span><br><span class="line">        thread1.join(); <span class="comment">// 主线程阻塞在这里，直到 thread1 结束</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待线程2执行完毕...&quot;</span>);</span><br><span class="line">        thread2.join(); <span class="comment">// 主线程阻塞在这里，直到 thread2 结束</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程都执行完毕，主线程继续执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、yield-方法"><a href="#三、yield-方法" class="headerlink" title="三、yield() 方法"></a>三、<code>yield()</code> 方法</h3><h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul><li><code>yield()</code> 方法的作用是<strong>让出当前 CPU 的执行权</strong>。</li><li><strong>比喻</strong>：一个线程调用了 <code>yield()</code>，它告诉调度器：“我愿意暂时放弃 CPU，你可以让其他同等优先级的线程先执行。”</li></ul><h4 id="2-主要用途-1"><a href="#2-主要用途-1" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h4><ul><li><strong>提示</strong>：<code>yield()</code> 只是一个<strong>提示</strong>，调度器<strong>不一定会采纳</strong>。它可能让出 CPU 给其他线程，也可能立即重新获得 CPU 的执行权。</li><li><strong>与其他方法的区别</strong>：<ul><li><code>sleep()</code>：让线程进入<strong>休眠状态</strong>，<strong>强制</strong>让出 CPU。</li><li><code>wait()</code>：让线程进入<strong>等待状态</strong>，<strong>必须</strong>通过 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒。</li></ul></li><li><strong>yield() 不会释放锁</strong>。</li></ul><h4 id="3-代码示例-1"><a href="#3-代码示例-1" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YieldExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在运行：&quot;</span> + i);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 放弃CPU执行权。&quot;</span>);</span><br><span class="line">                    Thread.<span class="keyword">yield</span>(); <span class="comment">// 让出 CPU</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>观察结果</strong>：在输出到 “放弃CPU执行权” 后，你可能会看到另一个线程的输出先出现。但这并不绝对，因为 <code>yield()</code> 只是一个建议。</p><p>在Java多线程编程中，<code>yield()</code>、<code>join()</code>、<code>setDaemon()</code> 这些方法都有严格的<strong>设置时机</strong>，如果使用不当，可能会导致异常或行为不符合预期。</p><p>让我们来详细解释一下每个方法的设置时机。</p><hr><h3 id="1-setDaemon-boolean-on-方法"><a href="#1-setDaemon-boolean-on-方法" class="headerlink" title="1. setDaemon(boolean on) 方法"></a>1. <code>setDaemon(boolean on)</code> 方法</h3><ul><li><p><strong>作用</strong>：将一个线程设置为守护线程或用户线程。</p></li><li><p><strong>设置时机</strong>：<strong>必须在线程启动前调用</strong>，即在 <code>thread.start()</code> 方法之前。</p></li><li><p><strong>为什么？</strong>：</p><ul><li>线程一旦启动，其类型（用户线程或守护线程）就已经确定，并且不能在运行时改变。</li><li>如果在 <code>start()</code> 方法之后调用 <code>setDaemon(true)</code>，会抛出 <code>IllegalThreadStateException</code> 运行时异常。</li></ul></li><li><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 守护线程的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例：先启动再设置</span></span><br><span class="line"><span class="comment">// daemonThread.start();</span></span><br><span class="line"><span class="comment">// daemonThread.setDaemon(true); // 这里会抛出 IllegalThreadStateException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例：先设置再启动</span></span><br><span class="line">daemonThread.setDaemon(<span class="literal">true</span>); </span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-join-方法"><a href="#2-join-方法" class="headerlink" title="2. join() 方法"></a>2. <code>join()</code> 方法</h3><ul><li><p><strong>作用</strong>：让当前线程等待另一个线程执行完毕。</p></li><li><p><strong>设置时机</strong>：<strong>必须在被等待的线程启动后调用</strong>。</p></li><li><p><strong>为什么？</strong>：</p><ul><li><code>join()</code> 的目的是让一个线程等待另一个线程。如果被等待的线程还没有启动，那么等待它结束是没有意义的。</li><li>尽管在启动前调用不会抛出异常，但它也不会有任何效果，因为目标线程根本没有开始运行。</li></ul></li><li><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 工作线程的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例：在工作线程启动前调用 join()</span></span><br><span class="line"><span class="comment">// workerThread.join(); // 无效，因为 workerThread 还没有运行</span></span><br><span class="line"><span class="comment">// workerThread.start(); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例：在工作线程启动后调用 join()</span></span><br><span class="line">workerThread.start();</span><br><span class="line">workerThread.join(); <span class="comment">// 主线程将等待 workerThread 运行完毕</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-yield-方法"><a href="#3-yield-方法" class="headerlink" title="3. yield() 方法"></a>3. <code>yield()</code> 方法</h3><ul><li><p><strong>作用</strong>：向线程调度器发出提示，当前线程愿意放弃 CPU 执行权。</p></li><li><p><strong>设置时机</strong>：<strong>可以在线程生命周期的任何阶段调用</strong>，但通常在线程的 <code>run()</code> 方法中调用。</p></li><li><p><strong>为什么？</strong>：</p><ul><li><code>yield()</code> 是一个<strong>动态的行为</strong>，它发生在线程正在执行其任务的过程中。</li><li>它的目的是在任务执行过程中，在某个点上主动让出 CPU，让其他线程有机会运行。</li></ul></li><li><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我正在运行...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">// 在任务执行到一半时，让出 CPU</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>方法</th><th>作用</th><th>设置时机</th><th>备注</th></tr></thead><tbody><tr><td><strong>setDaemon()</strong></td><td>设定线程类型（守护&#x2F;用户）</td><td><strong>thread.start() 之前</strong></td><td>启动后设置会抛出异常</td></tr><tr><td><strong>join()</strong></td><td>等待线程执行结束</td><td><strong>thread.start() 之后</strong></td><td>在启动前调用是无效的</td></tr><tr><td><strong>yield()</strong></td><td>提示线程调度器让出 CPU</td><td><strong>线程运行期间的任何时刻</strong></td><td>只是一个建议，不保证生效</td></tr></tbody></table><h3 id="1-深度解析"><a href="#1-深度解析" class="headerlink" title="1. 深度解析"></a>1. 深度解析</h3><h4 id="1-Thread-sleep-long-millis"><a href="#1-Thread-sleep-long-millis" class="headerlink" title="1. Thread.sleep(long millis)"></a>1. <code>Thread.sleep(long millis)</code></h4><p><strong>功能:</strong> <code>sleep()</code> 方法是 <code>Thread</code> 类的静态方法，作用是让<strong>当前正在执行的线程</strong>暂停指定的时间。</p><p><strong>核心机制:</strong></p><ul><li><code>sleep()</code> 方法会使线程进入<strong>阻塞状态（Timed Waiting）</strong>。</li><li>它<strong>不会释放</strong>任何持有的<strong>锁（monitor）</strong>。</li><li>当指定的时间过后，线程会回到<strong>可运行状态（Runnable）</strong>，等待 CPU 调度。</li><li>如果线程在休眠期间被其他线程调用 <code>interrupt()</code> 方法，<code>sleep()</code> 会立即抛出 <code>InterruptedException</code>。</li><li><code>sleep()</code> 的实现依赖于操作系统的调度器，实际暂停的时间可能比指定的时间长。</li></ul><p><strong>源码解析 (伪代码):</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查中断标志</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用本地方法，通知操作系统挂起当前线程</span></span><br><span class="line">    VM.nativeSleep(millis);</span><br><span class="line">    <span class="comment">// 唤醒后再次检查中断标志</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>VM.nativeSleep</strong> 是一个本地方法，它将线程挂起的任务交给操作系统内核来完成。</p><h4 id="2-Thread-yield"><a href="#2-Thread-yield" class="headerlink" title="2. Thread.yield()"></a>2. <code>Thread.yield()</code></h4><p><strong>功能:</strong> <code>yield()</code> 方法是 <code>Thread</code> 类的静态方法，作用是让<strong>当前正在执行的线程</strong>放弃其 CPU 时间片，回到<strong>可运行状态（Runnable）</strong>。</p><p><strong>核心机制:</strong></p><ul><li><code>yield()</code> 的目的是给其他线程一个执行的机会，但它<strong>不保证</strong>其他线程会立即运行。</li><li>它<strong>不会</strong>使线程进入阻塞或等待状态，线程只是从“正在运行”的状态切换到“可运行”队列的末尾。</li><li>调度器可能会选择立即重新调度刚才调用 <code>yield()</code> 的线程。</li><li>它<strong>不会</strong>释放任何锁。</li><li><code>yield()</code> 主要用于<strong>调试</strong>或<strong>优化</strong>，通常不应用于核心业务逻辑。因为它依赖于调度器的实现，其行为不可预测。</li></ul><p><strong>源码解析 (伪代码):</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用本地方法，向操作系统调度器发出“让步”信号</span></span><br><span class="line">    nativeYield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nativeYield</strong> 同样是一个本地方法，它向操作系统调度器发出一个提示，表示当前线程愿意让出 CPU。</p><h4 id="3-obj-wait"><a href="#3-obj-wait" class="headerlink" title="3. obj.wait()"></a>3. <code>obj.wait()</code></h4><p><strong>功能:</strong> <code>wait()</code> 方法是 <code>Object</code> 类的方法，作用是让<strong>当前线程</strong>进入<strong>等待状态（Waiting）</strong>，并<strong>释放</strong>它所持有的对象的锁。</p><p><strong>核心机制:</strong></p><ul><li><code>wait()</code> 必须在**同步块（synchronized block）**内部调用，否则会抛出 <code>IllegalMonitorStateException</code>。</li><li>当线程调用 <code>wait()</code> 后，它会<strong>释放</strong>该同步块所关联的对象的锁，进入等待队列。</li><li>线程需要等待其他线程调用<strong>同一对象的</strong> <code>notify()</code> 或 <code>notifyAll()</code> 方法才能被唤醒。</li><li>被唤醒后，线程需要<strong>重新竞争</strong>对象的锁，才能继续执行。</li></ul><p><strong>源码解析 (伪代码):</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    wait(<span class="number">0</span>); <span class="comment">// 内部调用带超时参数的 wait 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 必须持有对象的锁</span></span><br><span class="line">    <span class="keyword">if</span> (!Thread.holdsLock(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知虚拟机，当前线程进入等待状态，并释放锁</span></span><br><span class="line">    VM.nativeWait(<span class="built_in">this</span>, timeout);</span><br><span class="line">    <span class="comment">// 线程被唤醒后，重新竞争锁</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wait()</code> 是线程间<strong>通信和协作</strong>的关键，通常与 <code>notify()</code> 或 <code>notifyAll()</code> 配合使用，实现生产者-消费者等设计模式。</p><h4 id="4-Thread-join"><a href="#4-Thread-join" class="headerlink" title="4. Thread.join()"></a>4. <code>Thread.join()</code></h4><p><strong>功能:</strong> <code>join()</code> 方法是 <code>Thread</code> 类的方法，作用是让<strong>当前线程</strong>（例如主线程）<strong>等待</strong>调用 <code>join()</code> 的线程（例如子线程）执行完毕。</p><p><strong>核心机制:</strong></p><ul><li><code>join()</code> 的本质是调用 <code>wait()</code> 方法。它在内部使用一个<strong>隐式的锁</strong>来同步。</li><li>当一个线程调用 <code>t.join()</code> 时，当前线程（调用者）会<strong>阻塞</strong>，直到线程 <code>t</code> 终止。</li><li>如果线程 <code>t</code> 终止（无论是正常结束还是异常终止），JVM 会调用 <code>t.notifyAll()</code> 来唤醒所有在 <code>t.join()</code> 上等待的线程。</li></ul><p><strong>源码解析 (简化版):</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 必须在同步方法中，使用this作为锁</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果线程已经结束，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="comment">// 进入等待</span></span><br><span class="line">        wait(millis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>join()</code> 的实现巧妙地利用了 <code>wait()</code> 和 <code>notifyAll()</code> 的机制。当一个线程的 <code>run()</code> 方法执行完毕时，JVM 会自动调用其 <code>notifyAll()</code> 方法，从而唤醒所有等待它的线程。</p><hr><h3 id="2-区别与使用场景总结"><a href="#2-区别与使用场景总结" class="headerlink" title="2. 区别与使用场景总结"></a>2. 区别与使用场景总结</h3><table><thead><tr><th>特性&#x2F;方法</th><th><code>Thread.sleep()</code></th><th><code>Thread.yield()</code></th><th><code>obj.wait()</code></th><th><code>Thread.join()</code></th></tr></thead><tbody><tr><td><strong>类&#x2F;接口</strong></td><td><code>java.lang.Thread</code> (静态)</td><td><code>java.lang.Thread</code> (静态)</td><td><code>java.lang.Object</code></td><td><code>java.lang.Thread</code></td></tr><tr><td><strong>是否释放锁</strong></td><td><strong>不释放</strong></td><td><strong>不释放</strong></td><td><strong>释放</strong></td><td><strong>不释放</strong> (但其内部实现会释放)</td></tr><tr><td><strong>状态转换</strong></td><td><code>RUNNING</code> -&gt; <code>TIMED_WAITING</code></td><td><code>RUNNING</code> -&gt; <code>RUNNABLE</code></td><td><code>RUNNING</code> -&gt; <code>WAITING</code></td><td><code>RUNNING</code> -&gt; <code>WAITING</code>&#x2F;<code>TIMED_WAITING</code></td></tr><tr><td><strong>唤醒方式</strong></td><td>时间到了自动唤醒 或 <code>interrupt()</code></td><td>依赖于操作系统调度器，立即或稍后被重新调度</td><td>必须由其他线程调用 <code>notify()</code>&#x2F;<code>notifyAll()</code></td><td>目标线程执行结束时自动唤醒 或 <code>interrupt()</code></td></tr><tr><td><strong>使用场景</strong></td><td>模拟耗时操作，或让出 CPU 资源（但不释放锁）</td><td>提示调度器给其他线程机会，通常用于调试或低优先级的任务</td><td>线程间的<strong>协作和通信</strong>，实现生产者-消费者模式</td><td><strong>等待</strong>一个线程执行结束，实现线程间的<strong>顺序执行</strong></td></tr><tr><td><strong>是否需要同步块</strong></td><td>否</td><td>否</td><td><strong>是</strong> (必须在 <code>synchronized</code> 块内)</td><td>否 (但其内部实现依赖于同步机制)</td></tr></tbody></table><h3 id="3-使用场景示例"><a href="#3-使用场景示例" class="headerlink" title="3. 使用场景示例"></a>3. 使用场景示例</h3><ul><li><p><strong>sleep()</strong>: 你需要一个定时任务，比如每隔一秒钟打印一次日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 暂停一秒</span></span><br><span class="line">    System.out.println(<span class="string">&quot;等待了 &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; 秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>yield()</strong>: 你有一个 CPU 密集型任务，希望在每次循环中给其他线程一个运行的机会，以避免饥饿。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 执行一些计算</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        Thread.<span class="keyword">yield</span>(); <span class="comment">// 让出 CPU</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>wait()</strong>: 你有一个共享队列，当队列为空时，消费者线程需要等待，当生产者放入新元素时，消费者被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (sharedQueue) &#123;</span><br><span class="line">    <span class="keyword">while</span> (sharedQueue.isEmpty()) &#123;</span><br><span class="line">        sharedQueue.wait(); <span class="comment">// 队列为空，等待并释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费元素...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>join()</strong>: 你需要确保子线程的数据处理完成后，主线程才能继续使用这个数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">dataProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="comment">/* 处理数据 */</span> &#125;);</span><br><span class="line">dataProcessor.start();</span><br><span class="line">dataProcessor.join(); <span class="comment">// 主线程等待数据处理完成</span></span><br><span class="line">System.out.println(<span class="string">&quot;数据处理完成，主线程可以继续了。&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>理解这些方法的细微差别是编写健壮、高效并发代码的基础。特别是 <code>wait()</code> 和 <code>sleep()</code>，它们最大的区别在于是否释放锁，这直接影响着线程间的同步和协作方式。</p><h3 id="线程（Thread）的概念与生命周期"><a href="#线程（Thread）的概念与生命周期" class="headerlink" title="线程（Thread）的概念与生命周期"></a>线程（Thread）的概念与生命周期</h3><p>线程是操作系统调度的最小单位，是进程中的一个执行路径。一个进程可以包含多个线程，这些线程共享进程的内存空间。</p><p>线程的生命周期通常包含以下六种状态（定义在 java.lang.Thread.State 枚举中）：</p><ul><li><p>NEW（新建）：线程被创建但尚未启动。当使用 new Thread() 创建一个线程实例后，它就处于此状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello from a new thread!&quot;</span>));</span><br><span class="line"><span class="comment">// 此时 myThread 处于 NEW 状态，尚未执行 start()</span></span><br></pre></td></tr></table></figure></li><li><p>RUNNABLE（可运行）：线程已调用 start() 方法，正在 JVM 中运行（可能正在执行，也可能在等待 CPU 调度）。一个 RUNNABLE 状态的线程可能正在运行，也可能并没有运行，它仅仅是具备了运行的资格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myThread.start();</span><br><span class="line"><span class="comment">// 此时 myThread 进入 RUNNABLE 状态，等待 CPU 调度执行 run() 方法</span></span><br></pre></td></tr></table></figure></li><li><p>BLOCKED (阻塞)：线程正在等待获取一个监视器锁(例如，进入 synchronized 块或方法)。当一个线程试图访问被其他线程锁定的资源时，它会进入此状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 线程已经持有 lock 对象的锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// ... 线程 A 正在执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程 B 尝试获取 lock 对象的锁，但被线程 A 占用，会进入 BLOCKED 状态</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>WAITING (等待)：线程无限制地等待另一个线程执行特定操作。例如，调用 Object.wait(), Thread.join() (无参数) 或 LockSupport.park().这些方法会使线程放弃 CPU 使用权，并进入无限制等待，直到被其他线程 notify(), notifyAll() 或 unpark() 唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">sharedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 线程 A:</span></span><br><span class="line"><span class="keyword">synchronized</span> (sharedObject) &#123;</span><br><span class="line">    sharedObject.wait(); <span class="comment">// 线程 A 进入 WAITING 状态，并释放 sharedObject 的锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程 B:</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line">threadA.start();</span><br><span class="line">threadA.join(); <span class="comment">// 线程 B 等待 threadA 执行完毕，进入 WAITING 状态</span></span><br></pre></td></tr></table></figure></li><li><p>TIMED_WAITING (有时限等待)：线程在指定的时间内等待另一个线程执行特定操作，或者休眠。例如，调用 Thread.sleep(long millis)、Object.wait(long timeout)、Thread.join(long millis)、LockSupport.parkNanos() 或 LockSupport.parkUntil()。一旦超时间到达，线程会自动从等待状态唤醒，并尝试重新进入 RUNNABLE 状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 线程进入 TIMED_WAITING 状态 1 秒</span></span><br></pre></td></tr></table></figure></li><li><p>TERMINATED (终止): 线程已执行完毕其 run() 方法, 或者因未捕获的异常退出。线程一旦进入此状态, 就不能再被重新启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程的 run() 方法执行完毕</span></span><br><span class="line"><span class="comment">// 线程在执行过程中抛出未捕获的异常</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="什么是线程上下文切换"><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换?"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">什么是线程上下文切换?</a></h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h3 id="Thread-sleep-方法和-Object-wait-方法对比"><a href="#Thread-sleep-方法和-Object-wait-方法对比" class="headerlink" title="Thread#sleep() 方法和 Object#wait() 方法对比"></a><a href="#thread-sleep-%E6%96%B9%E6%B3%95%E5%92%8C-object-wait-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94">Thread#sleep() 方法和 Object#wait() 方法对比</a></h3><hr><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p><p><strong>区别</strong>：</p><ul><li><strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong> 。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？下一个问题就会聊到。</li></ul><hr><h3 id="为什么-wait-方法不定义在-Thread-中？"><a href="#为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%9C%A8-thread-%E4%B8%AD">为什么 wait() 方法不定义在 Thread 中？</a></h3><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p><p>类似的问题：<strong>为什么 sleep() 方法定义在 Thread 中？</strong></p><p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p><hr><h3 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a><a href="#%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-thread-%E7%B1%BB%E7%9A%84-run-%E6%96%B9%E6%B3%95%E5%90%97">可以直接调用 Thread 类的 run 方法吗？</a></h3><p>这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结：调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类:"></a>继承 Thread 类:</h4><ul><li>通过创建 Thread 类的子类, 并重写其 run() 方法, 在该方法中定义线程执行的任务。</li><li>创建 Thread 子类的实例, 并调用其 start() 方法来启动线程。调用 start() 方法会使线程进入 RUNNABLE 状态, 并由 JVM 调度执行 run() 方法; 直接调用 run() 方法则只是在当前线程中执行普通方法, 不会启动新线程。</li><li>优点: 实现简单直观, 代码结构清晰。</li><li>缺点: Java 是单继承的, 如果你的类已经继承了其他类, 就不能再继承 Thread 类。这限制了类的灵活性。此外, 任务 (run() 方法中的逻辑 ) 与线程本身 (Thread 对象) 紧密耦合, 不利于任务的复用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyThread.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + threadName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running via extending Thread.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread: &quot;</span> + threadName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">                <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + threadName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> + threadName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadCreationDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCreationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread started.&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;MyThread-1&quot;</span>);</span><br><span class="line">        thread1.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;MyThread-2&quot;</span>);</span><br><span class="line">        thread2.start(); <span class="comment">// 启动另一个新线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished starting other threads.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现-Runnable-接口："><a href="#实现-Runnable-接口：" class="headerlink" title="实现 Runnable 接口："></a>实现 <strong>Runnable</strong> 接口：</h4><ul><li>定义一个类实现 <strong>Runnable</strong> 接口，并实现其抽象方法 public void run()。run() 方法中包含线程执行的具体任务。</li><li>创建 <strong>Runnable</strong> 实现类的实例，然后将其作为参数传入 Thread 类的构造器 (new Thread(Runnable target))，再调用 Thread 实例的 start() 方法。</li><li>优点：<ul><li>推荐方式：避免了 Java 单继承的限制，你的类可以同时继承其他类来实现 <strong>Runnable</strong> 接口。</li><li>任务与线程解耦：Runnable 对象只负责定义任务，而 Thread 对象负责执行任务。这意味着同一个 <strong>Runnable</strong> 对象可以被多个 Thread 实例共享执行，从而更好地实现资源的共享和任务的复用。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyRunnable.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + taskName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running via implementing Runnable.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task: &quot;</span> + taskName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task &quot;</span> + taskName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task &quot;</span> + taskName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadCreationDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCreationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread started.&quot;</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;Runnable-Task-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable1);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;Runnable-Task-2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable2, <span class="string">&quot;Custom-Thread-Name&quot;</span>); <span class="comment">// 可以给线程命名</span></span><br><span class="line">        thread4.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished starting runnable threads.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><p><code>Callable</code> 是 Java 并发编程中一个非常重要的接口，它与 <code>Runnable</code> 类似，都用于定义一个可在线程中执行的任务。但 <code>Callable</code> 提供了更强大的功能，主要体现在两个方面：</p><ol><li><strong>可以返回结果：</strong> <code>Callable</code> 的 <code>call()</code> 方法可以返回一个泛型类型的结果。</li><li><strong>可以抛出异常：</strong> <code>Callable</code> 的 <code>call()</code> 方法可以声明抛出任何 <code>Exception</code>。</li></ol><p>这与 <code>Runnable</code> 接口形成了鲜明对比，<code>Runnable</code> 的 <code>run()</code> 方法没有返回值，也不能抛出受检异常（checked exception）。</p><ul><li><h3 id="Callable-的基本结构"><a href="#Callable-的基本结构" class="headerlink" title="Callable 的基本结构"></a><code>Callable</code> 的基本结构</h3></li></ul><p><code>Callable</code> 接口是一个泛型接口，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算并返回结果，或在无法做到时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 如果无法计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;V&gt;</code>：泛型参数，代表 <code>call()</code> 方法将要返回的结果类型。</p></li><li><p><code>V call()</code>：<code>call()</code> 方法的签名，它返回一个 <code>V</code> 类型的结果，并且可以抛出异常。</p></li><li><h3 id="如何使用-Callable"><a href="#如何使用-Callable" class="headerlink" title="如何使用 Callable"></a>如何使用 <code>Callable</code></h3></li></ul><p><code>Callable</code> 接口本身并不能直接作为 <code>Thread</code> 的构造参数。它需要配合 <code>ExecutorService</code> 线程池和 <code>Future</code> 接口一起使用。</p><p><strong>典型使用流程：</strong></p><ol><li><p><strong>创建 Callable 任务：</strong> 实现 <code>Callable</code> 接口，并在 <code>call()</code> 方法中编写具体的业务逻辑，返回一个结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务执行完毕，返回结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建 ExecutorService 线程池：</strong> 使用 <code>Executors</code> 工厂类创建线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>提交 Callable 任务：</strong> 使用 <code>ExecutorService</code> 的 <code>submit()</code> 方法提交任务。<code>submit()</code> 方法会返回一个 <code>Future</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">MyCallableTask</span>();</span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br></pre></td></tr></table></figure></li><li><p><strong>获取任务结果：</strong> 通过 <code>Future</code> 对象的 <code>get()</code> 方法来获取 <code>Callable</code> 任务的执行结果。</p><ul><li><code>future.get()</code> 是一个<strong>阻塞</strong>方法，它会一直等待，直到任务执行完毕并返回结果。</li><li>如果任务执行过程中抛出了异常，<code>get()</code> 方法也会将这个异常包装在 <code>ExecutionException</code> 中重新抛出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 阻塞等待结果</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 线程被中断</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 任务执行过程中抛出的异常</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><h3 id="Callable-与-Runnable-的区别"><a href="#Callable-与-Runnable-的区别" class="headerlink" title="Callable 与 Runnable 的区别"></a><code>Callable</code> 与 <code>Runnable</code> 的区别</h3></li></ul><table><thead><tr><th>特性</th><th><code>Callable</code></th><th><code>Runnable</code></th></tr></thead><tbody><tr><td><strong>返回值</strong></td><td><code>call()</code> 方法有返回值（泛型 <code>V</code>）</td><td><code>run()</code> 方法没有返回值（<code>void</code>）</td></tr><tr><td><strong>异常处理</strong></td><td><code>call()</code> 方法可以抛出受检异常</td><td><code>run()</code> 方法不能直接抛出受检异常</td></tr><tr><td><strong>执行方式</strong></td><td>必须配合 <code>ExecutorService.submit()</code> 执行</td><td>可以直接作为 <code>Thread</code> 构造函数的参数，也可以通过 <code>ExecutorService.execute()</code> 或 <code>submit()</code> 执行</td></tr><tr><td><strong>功能</strong></td><td>适用于需要返回计算结果或可能抛出异常的异步任务</td><td>适用于简单的异步任务，不需要返回结果</td></tr></tbody></table><hr><ul><li><h3 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a><code>Future</code> 接口</h3></li></ul><p><code>Future</code> 接口是 <code>Callable</code> 的重要伴侣，它代表一个<strong>异步计算的结果</strong>。它提供了检查任务是否完成、等待任务完成以及获取任务结果的方法。</p><p><code>Future</code> 接口的主要方法：</p><ul><li><p><code>V get()</code>: 阻塞式地等待任务完成，并返回结果。</p></li><li><p><code>V get(long timeout, TimeUnit unit)</code>: 在指定时间内等待任务完成，超时则抛出 <code>TimeoutException</code>。</p></li><li><p><code>boolean isDone()</code>: 检查任务是否已经完成。</p></li><li><p><code>boolean cancel(boolean mayInterruptIfRunning)</code>: 尝试取消任务。</p></li><li><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3></li></ul><p><code>Callable</code> 是 Java 并发编程中一个更高级的任务抽象，它解决了 <code>Runnable</code> 接口无法返回结果和处理受检异常的痛点。通过与 <code>ExecutorService</code> 和 <code>Future</code> 接口的组合使用，<code>Callable</code> 使得异步编程变得更加简单和灵活，非常适合那些需要耗时计算并返回结果的场景，比如网络请求、数据处理等。</p><h4 id="线程池-Thread-Pool"><a href="#线程池-Thread-Pool" class="headerlink" title="线程池 (Thread Pool)"></a>线程池 (Thread Pool)</h4><p>线程池是一种基于池化思想的线程管理机制，用于管理和复用线程，而不是在每次需要执行任务时都创建新线程。</p><ul><li><p><strong>为什么使用线程池？</strong></p><ul><li>降低资源消耗:通过重复利用已创建的线程，降低线程创建和销毁的开销。</li><li>提高响应速度:当任务到达时，任务可以直接执行，无需等待线程创建。</li><li>提高线程的可管理性:线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配、调优和监控。</li><li>提供更多功能:如定时执行、周期执行、单线程化等。</li></ul></li><li><p><strong>线程池的核心参数 (ThreadPoolExecutor 构造方法)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">    TimeUnit unit,</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><ul><li><p>corePoolSize: 核心线程数。线程池中始终保持的线程数量，即使它们处于空闲状态，除非设置了 allowCoreThreadTimeOut(true)。</p></li><li><p>maximumPoolSize: 最大线程数。线程池中允许存在的最大线程数量。当工作队列已满且核心线程都在忙碌时，线程池会创建新的非核心线程，直到达到这个数量。</p></li><li><p>keepAliveTime: 当线程池中的线程数量超过 corePoolSize 时，这些空闲的非核心线程在终止之前等待新任务的最长时间。</p></li><li><p>unit: keepAliveTime 参数的时间单位。</p></li><li><p>workQueue: 任务队列 (阻塞队列)。用于存放等待执行的任务。</p><ul><li>ArrayBlockingQueue: 基于数组的有界阻塞队列，需要指定容量。</li><li>LinkedBlockingQueue: 基于链表的阻塞队列，容量可以指定，也可以是无界的（默认）。如果使用无界队列，maximumPoolSize 参数将失效。</li><li>SynchronousQueue: 一个不存储元素的阻塞队列。每个插入操作必须等待一个对应的移除操作，反之亦然。</li><li>PriorityBlockingQueue: 支持优先级的无界阻塞队列，按照自然顺序或自定义比较器排序。</li></ul></li><li><p>threadFactory: 线程工厂。用于创建新线程，可以自定义线程的命名、优先级等。</p></li><li><p>handler: 拒绝策略 (当线程池和工作队列都已满时，新的任务到来时的处理方式)。</p><ul><li><p>ThreadPoolExecutor.AbortPolicy (默认): 直接抛出 RejectedExecutionException 异常。</p></li><li><p>ThreadPoolExecutor.CallerRunsPolicy: 由调用线程 (提交任务的线程) 执行任务。</p></li><li><p>ThreadPoolExecutor.DiscardOldestPolicy: 丢弃队列中最老的任务，然后尝试提交当前任务。</p></li><li><p>ThreadPoolExecutor.DiscardPolicy: 直接丢弃当前新提交的任务。</p></li><li><p>因为<code>CallerRunsPolicy</code>这个拒绝策略，导致耗时的任务用了主线程执行，导致线程池阻塞，进而导致后续任务无法及时执行，严重的情况下很可能导致 OOM。</p><p>我们从问题的本质入手，调用者采用<code>CallerRunsPolicy</code>是希望所有的任务都能够被执行，暂时无法处理的任务又被保存在阻塞队列<code>BlockingQueue</code>中。这样的话，在内存允许的情况下，我们可以增加阻塞队列<code>BlockingQueue</code>的大小并调整堆内存以容纳更多的任务，确保任务能够被准确执行。</p><p>为了充分利用 CPU，我们还可以调整线程池的<code>maximumPoolSize</code> （最大线程数）参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</p></li></ul></li></ul></li><li><p><strong>线程池的执行流程</strong></p><ol><li>当一个任务提交到线程池时，如果当前运行的线程数小于 corePoolSize，即使有空闲线程，也会创建并启动一个新线程来执行任务。</li><li>如果当前运行的线程数大于或等于 corePoolSize，但任务队列 workQueue 未满，任务会被添加到 workQueue 中等待执行。</li><li>如果 workQueue 已满，但当前运行的线程数小于 maximumPoolSize，线程池会创建新的非核心线程来执行任务。</li><li>如果当前运行的线程数等于 maximumPoolSize 且 workQueue 已满，线程池会根据拒绝策略来处理新提交的任务。</li></ol></li><li><p><strong>Java 内置的四种常用线程池 (通过 Executors 工厂类创建)</strong></p><ul><li>FixedThreadPool (固定大小线程池)<ul><li>Executors.newFixedThreadPool(int nThreads)</li><li>corePoolSize &#x3D; maximumPoolSize &#x3D; nThreads</li><li>使用无界 LinkedBlockingQueue。</li><li>特点：可控制并发的线程数，超出的任务会在队列中等待。</li><li>问题：当任务提交速度远大于处理速度时，队列会不断增长，可能导致 OOM。</li></ul></li><li>SingleThreadExecutor (单线程线程池)<ul><li>Executors.newSingleThreadExecutor()</li><li>corePoolSize &#x3D; maximumPoolSize &#x3D; 1</li><li>使用无界 LinkedBlockingQueue。</li><li>特点：保证所有任务都在一个线程中按顺序执行。</li><li>问题：同 FixedThreadPool，队列无限增长可能导致 OOM。</li></ul></li><li>CachedThreadPool（可缓存线程池）<ul><li>Executors.newCachedThreadPool()</li><li>corePoolSize &#x3D; 0, maximumPoolSize &#x3D; Integer.MAX_VALUE</li><li>使用 SynchronousQueue。</li><li>keepAliveTime &#x3D; 60s</li><li>特点：当任务到来时，有空闲线程则复用，无空闲线程则创建新线程。适用于大量短时任务。</li><li>问题：maximumPoolSize 过大，当任务并发量极高时，可能创建大量线程，导致系统资源耗尽 (OOM)。</li></ul></li><li>ScheduledThreadPool（定时任务线程池）<ul><li>Executors.newScheduledThreadPool(int corePoolSize)</li><li>特点：支持定时及周期性任务执行。</li><li>内部使用 DelayedWorkQueue，一个无界队列，可以按时间进行排序。</li></ul></li></ul></li><li><p><strong>阿里巴巴开发手册建议：不推荐使用 Executors 创建线程池，而是手动通过 ThreadPoolExecutor 的构造方法创建，以明确线程池的运行规则，避免资源耗尽的风险。</strong></p></li></ul><hr><h3 id="一、线程池的创建-ThreadPoolExecutor"><a href="#一、线程池的创建-ThreadPoolExecutor" class="headerlink" title="一、线程池的创建 (ThreadPoolExecutor)"></a>一、线程池的创建 (ThreadPoolExecutor)</h3><p>Java 中，线程池的核心是 <code>java.util.concurrent.ThreadPoolExecutor</code> 类。创建线程池最推荐的方式是直接使用它的构造函数，而不是使用 <code>Executors</code> 工厂类，因为这能让你更清楚地了解线程池的运行参数。</p><p><code>ThreadPoolExecutor</code> 的构造函数有多个参数，理解它们是掌握线程池的关键：</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(</span><br><span class="line">    int corePoolSize,      // 核心线程数</span><br><span class="line">    int maximumPoolSize,   // 最大线程数</span><br><span class="line">    long keepAliveTime,    // 线程空闲存活时间</span><br><span class="line">    TimeUnit unit,         // 时间单位</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列</span><br><span class="line">    ThreadFactory threadFactory,   // 线程工厂</span><br><span class="line">    RejectedExecutionHandler handler // 拒绝策略</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="各参数详解："><a href="#各参数详解：" class="headerlink" title="各参数详解："></a>各参数详解：</h4><ol><li><strong>corePoolSize (核心线程数)</strong>：<ul><li><strong>作用</strong>：线程池中<strong>常驻</strong>的线程数量。即使这些线程处于空闲状态，它们也不会被销毁。</li><li><strong>用途</strong>：当有新任务提交时，如果核心线程数未达到 <code>corePoolSize</code>，线程池会创建新线程来处理任务，直到核心线程数达到上限。</li></ul></li><li><strong>maximumPoolSize (最大线程数)</strong>：<ul><li><strong>作用</strong>：线程池中允许存在的<strong>最大</strong>线程数量。</li><li><strong>用途</strong>：当任务队列已满，且核心线程数已满时，线程池会创建新的线程（非核心线程）来处理任务，直到总线程数达到 <code>maximumPoolSize</code>。</li></ul></li><li><strong>keepAliveTime (线程空闲存活时间)</strong>：<ul><li><strong>作用</strong>：非核心线程的空闲存活时间。</li><li><strong>用途</strong>：当线程池中的线程数量超过 <code>corePoolSize</code> 时，如果一个非核心线程空闲时间超过 <code>keepAliveTime</code>，它就会被回收。</li></ul></li><li><strong>unit (时间单位)</strong>：<ul><li><strong>作用</strong>：<code>keepAliveTime</code> 的时间单位，如秒、分钟、毫秒。</li></ul></li><li><strong>workQueue (任务队列)</strong>：<ul><li><strong>作用</strong>：用于<strong>存放等待执行的任务</strong>。当核心线程都在忙碌时，新提交的任务会进入这个队列。</li><li><strong>常见类型</strong>：<ul><li><code>ArrayBlockingQueue</code>：基于数组，有界的阻塞队列。</li><li><code>LinkedBlockingQueue</code>：基于链表，通常是无界的，也可以指定容量。</li><li><code>SynchronousQueue</code>：不存储任务，每个任务提交都会立即被一个线程执行。</li></ul></li></ul></li><li><strong>ThreadFactory (线程工厂)</strong>：<ul><li><strong>作用</strong>：用于创建线程。可以自定义工厂来为线程命名、设置守护状态等。</li></ul></li><li><strong>RejectedExecutionHandler (拒绝策略)</strong>：<ul><li><strong>作用</strong>：当任务队列已满，且线程数达到 <code>maximumPoolSize</code> 时，线程池会根据拒绝策略来处理新提交的任务。</li><li><strong>常见策略</strong>：<ul><li><code>AbortPolicy</code> (默认)：直接抛出 <code>RejectedExecutionException</code> 异常。</li><li><code>CallerRunsPolicy</code>：由提交任务的线程（caller）自己来执行任务。</li><li><code>DiscardOldestPolicy</code>：丢弃任务队列中最老的任务，然后尝试将当前任务加入队列。</li><li><code>DiscardPolicy</code>：直接丢弃当前任务，不抛出异常。</li></ul></li></ul></li></ol><h3 id="二、线程池的生命周期"><a href="#二、线程池的生命周期" class="headerlink" title="二、线程池的生命周期"></a>二、线程池的生命周期</h3><p>线程池有五种状态，这些状态通过内部的 <code>ctl</code> 变量控制，它包含线程池的运行状态和线程数。</p><ol><li><strong>RUNNING (运行中)</strong>：<ul><li><strong>状态</strong>：接受新任务，并处理阻塞队列中的任务。</li><li><strong>转换</strong>：创建线程池时处于此状态。</li></ul></li><li><strong>SHUTDOWN (关闭)</strong>：<ul><li><strong>状态</strong>：不接受新任务，但会处理阻塞队列中的已有任务。</li><li><strong>转换</strong>：调用 <code>shutdown()</code> 方法后进入此状态。</li></ul></li><li><strong>STOP (停止)</strong>：<ul><li><strong>状态</strong>：不接受新任务，也不处理阻塞队列中的已有任务，会中断所有正在执行的任务。</li><li><strong>转换</strong>：调用 <code>shutdownNow()</code> 方法后进入此状态。</li></ul></li><li><strong>TIDYING (整理)</strong>：<ul><li><strong>状态</strong>：所有任务都已终止，线程数为 0。</li><li><strong>转换</strong>：当线程池处于 <code>SHUTDOWN</code> 或 <code>STOP</code> 状态，且所有任务都已完成、线程都已销毁时，进入此状态。</li></ul></li><li><strong>TERMINATED (终止)</strong>：<ul><li><strong>状态</strong>：彻底终止，可以安全地进行回收。</li><li><strong>转换</strong>：<code>TIDYING</code> 状态下，<code>terminated()</code> 方法执行完毕后进入此状态。</li></ul></li></ol><h3 id="三、线程池的启动流程-任务提交过程"><a href="#三、线程池的启动流程-任务提交过程" class="headerlink" title="三、线程池的启动流程 (任务提交过程)"></a>三、线程池的启动流程 (任务提交过程)</h3><p>当调用 <code>executor.execute(Runnable task)</code> 方法提交一个新任务时，线程池会按照以下严格的流程来决定如何处理任务：</p><ol><li><strong>核心线程检查</strong>：<ul><li>如果当前线程池中的线程数量<strong>小于</strong> <code>corePoolSize</code>，则创建并启动一个新线程来执行任务。即使有空闲的线程，也会创建新线程直到达到核心线程数。</li></ul></li><li><strong>任务队列检查</strong>：<ul><li>如果当前线程池中的线程数量<strong>等于或大于</strong> <code>corePoolSize</code>，则将任务放入任务队列 <code>workQueue</code> 中等待。</li></ul></li><li><strong>最大线程数检查</strong>：<ul><li>如果任务队列已满，线程池会再次检查当前线程数。</li><li>如果当前线程数量<strong>小于</strong> <code>maximumPoolSize</code>，则创建并启动一个新线程（非核心线程）来执行任务。</li></ul></li><li><strong>拒绝策略</strong>：<ul><li>如果任务队列已满，且当前线程数已达到 <code>maximumPoolSize</code>，则根据线程池的<strong>拒绝策略</strong>来处理这个新任务。</li></ul></li></ol><p><strong>总结</strong>：线程池的运行是一个复杂的、多阶段的过程。它优先使用核心线程，然后将任务放入队列，最后才考虑创建非核心线程。这个流程设计旨在最大限度地利用现有线程，减少线程创建和销毁的开销，从而提高性能和资源利用率。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal-是什么？"><a href="#ThreadLocal-是什么？" class="headerlink" title="ThreadLocal 是什么？"></a><code>ThreadLocal</code> 是什么？</h3><p><code>ThreadLocal</code>（线程本地变量）并不是用来解决线程间共享数据问题的，它的核心作用是<strong>为每个使用该变量的线程都提供一个独立的、隔离的副本</strong>。</p><p>你可以把 <code>ThreadLocal</code> 想象成一个“线程专属的储物柜”。每个线程都可以往这个储物柜里存东西（通过 <code>set()</code> 方法），取东西（通过 <code>get()</code> 方法），但它只能看到自己储物柜里的东西，无法访问其他线程的。</p><p><code>ThreadLocal</code> 内部其实是通过一个 <code>ThreadLocalMap</code> 来实现的。这个 Map 的键是 <code>ThreadLocal</code> 对象本身，值就是你存入的那个变量。每个线程都有一个属于自己的 <code>ThreadLocalMap</code>。</p><hr><h3 id="为什么需要-ThreadLocal？"><a href="#为什么需要-ThreadLocal？" class="headerlink" title="为什么需要 ThreadLocal？"></a>为什么需要 <code>ThreadLocal</code>？</h3><p>我们通常在开发中会遇到两种数据共享问题：</p><ol><li><strong>多个线程共享一个变量</strong>：这种情况下，需要通过 <code>synchronized</code>、<code>volatile</code> 或 <code>Lock</code> 来保证线程安全。</li><li><strong>每个线程需要一个独立的变量</strong>：这是 <code>ThreadLocal</code> 的主要应用场景。</li></ol><p>如果不用 <code>ThreadLocal</code>，我们可能需要自己手动维护一个 <code>Map&lt;Thread, Object&gt;</code>，每次存取数据时都以当前线程作为键。这样不仅麻烦，还容易出错。<code>ThreadLocal</code> 帮我们封装了这些细节，让使用变得非常简单。</p><hr><h3 id="ThreadLocal-的常见应用场景"><a href="#ThreadLocal-的常见应用场景" class="headerlink" title="ThreadLocal 的常见应用场景"></a><code>ThreadLocal</code> 的常见应用场景</h3><p><code>ThreadLocal</code> 最常见的应用场景是在 Web 开发中，用于<strong>存储与当前请求相关的上下文信息</strong>。</p><p>例如，一个 HTTP 请求从进入服务器到返回响应，可能由多个方法或组件来处理，但它们都属于同一个线程。如果需要传递一些请求相关的状态（比如用户身份、事务 ID、数据库连接），我们有很多种做法：</p><ul><li><strong>参数传递</strong>：将这些信息作为参数层层传递。这会导致方法签名变得臃肿，并且增加了代码的耦合性。</li><li><strong>静态变量</strong>：如果用静态变量，多个请求同时到达时会互相覆盖，导致线程不安全。</li><li><strong>ThreadLocal</strong>：这是最优雅的解决方案。你可以把这些信息存入 <code>ThreadLocal</code>，然后在任何需要的地方直接通过 <code>get()</code> 方法获取，无需在方法间显式传递。</li></ul><p><strong>典型的例子：</strong></p><ul><li><strong>Spring 的事务管理</strong>：Spring 框架在处理事务时，会使用 <code>ThreadLocal</code> 来保存每个线程的数据库连接，确保在同一个事务中的所有操作都使用同一个连接。</li><li><strong>上下文信息</strong>：例如，在请求处理链中，将用户登录信息、语言偏好等数据存入 <code>ThreadLocal</code>，下游的业务逻辑可以随时获取。</li></ul><hr><h3 id="ThreadLocal-可能带来的问题"><a href="#ThreadLocal-可能带来的问题" class="headerlink" title="ThreadLocal 可能带来的问题"></a><code>ThreadLocal</code> 可能带来的问题</h3><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><strong>内存泄漏</strong></h4><p><code>ThreadLocal</code> 可能会导致<strong>内存泄漏</strong>。这是一个非常重要的问题。</p><p><code>ThreadLocalMap</code> 使用的是<strong>弱引用（Weak Reference）</strong> 作为键。这意味着，当 <code>ThreadLocal</code> 对象没有其他强引用时，即使它还在 <code>ThreadLocalMap</code> 中，垃圾回收器也会回收它。</p><p>但是，<code>ThreadLocalMap</code> 的值（也就是你存入的对象）是<strong>强引用</strong>。如果线程一直存活，但你不再使用 <code>ThreadLocal</code> 对象，<code>ThreadLocalMap</code> 中的键就会变成 <code>null</code>，但值还在。这样，值对象就无法被回收，导致内存泄漏。</p><p>如何避免？</p><p>解决这个问题的关键在于：在 ThreadLocal 使用完毕后，务必调用 remove() 方法。</p><p>在 Web 应用中，请求处理结束后，线程会被放回线程池。如果 <code>ThreadLocal</code> 没有被清除，那么下一次其他请求再拿到这个线程时，它会读取到上一个请求残留的数据，导致业务逻辑出错。因此，<strong>正确使用模式</strong>通常是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;My Data&quot;</span>);</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 确保在任何情况下都执行清理操作</span></span><br><span class="line">    threadLocal.remove(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code> 使用弱引用作为键，但使用强引用作为值，这样做主要是为了优化内存管理并处理由 <code>ThreadLocal</code> 引起的潜在内存泄漏问题。这种设计虽然能解决一些问题，但也引入了新的挑战。</p><h3 id="为什么键是弱引用？"><a href="#为什么键是弱引用？" class="headerlink" title="为什么键是弱引用？"></a>为什么键是弱引用？</h3><p><code>ThreadLocalMap</code> 的键是 <code>ThreadLocal</code> 对象的弱引用。当一个 <code>ThreadLocal</code> 对象没有其他地方（比如一个变量）引用它时，它就会被垃圾回收器回收。</p><ul><li><strong>避免键的内存泄漏：</strong> 如果键是强引用，即使 <code>ThreadLocal</code> 对象在程序中不再被使用，只要线程还活着，这个 <code>ThreadLocalMap</code> 实例就会一直持有对它的强引用，导致 <code>ThreadLocal</code> 对象本身无法被回收，从而引起内存泄漏。通过使用弱引用，当 <code>ThreadLocal</code> 变量超出作用域后，即使线程依然存活，<code>ThreadLocalMap</code> 中的键也会被自动回收。</li></ul><h3 id="为什么值是强引用？"><a href="#为什么值是强引用？" class="headerlink" title="为什么值是强引用？"></a>为什么值是强引用？</h3><p>与键不同，<code>ThreadLocalMap</code> 的值（也就是你通过 <code>set</code> 方法存入的对象）是强引用。</p><ul><li><strong>确保值的可用性：</strong> 如果值也是弱引用，那么当 <code>ThreadLocal</code> 变量超出作用域后，值也可能随时被垃圾回收器回收。这样一来，当你再次通过 <code>get</code> 方法访问时，就会得到 <code>null</code>，这与 <code>ThreadLocal</code> 的使用初衷相悖。<code>ThreadLocal</code> 的目的是为每个线程提供独立的、可以持续访问的变量副本。</li></ul><h3 id="这种设计带来的内存泄漏问题"><a href="#这种设计带来的内存泄漏问题" class="headerlink" title="这种设计带来的内存泄漏问题"></a>这种设计带来的内存泄漏问题</h3><p>虽然键的弱引用设计解决了 <code>ThreadLocal</code> 对象的内存泄漏，但如果开发者没有正确地处理，仍然会导致值的内存泄漏。</p><p>考虑以下场景：</p><ol><li>你在一个线程中创建了一个 <code>ThreadLocal</code> 对象，并设置了一个值。</li><li><code>ThreadLocalMap</code> 中会有一个键值对，键是 <code>ThreadLocal</code> 对象的弱引用，值是你设置的对象。</li><li><code>ThreadLocal</code> 对象在外部不再被强引用，被垃圾回收器回收。</li><li>此时 <code>ThreadLocalMap</code> 中的键变为 <code>null</code>，但值依然存在，因为它是一个强引用。</li></ol><p>如果线程一直存活（比如在线程池中），而你没有手动调用 <code>ThreadLocal.remove()</code>，那么这个值为 <code>null</code> 的键值对就会一直占用内存，导致内存泄漏。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了解决这个问题，Java 社区推荐的<strong>最佳实践</strong>是：<strong>无论何时使用完 ThreadLocal 变量，都应该显式地调用 ThreadLocal.remove() 方法。</strong></p><p><code>ThreadLocal.remove()</code> 会从 <code>ThreadLocalMap</code> 中移除对应的键值对，从而释放内存，避免内存泄漏。这个操作通常应该放在 <code>finally</code> 块中，以确保即使发生异常，也能执行清理工作。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;MyObject&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(<span class="keyword">new</span> <span class="title class_">MyObject</span>());</span><br><span class="line">    <span class="comment">// 业务逻辑...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>总而言之，<code>ThreadLocalMap</code> 的设计是一种<strong>平衡</strong>。它利用弱引用来自动处理 <code>ThreadLocal</code> 对象的回收，从而减轻了开发者的负担。但与此同时，它把值的清理责任留给了开发者，要求我们通过 <code>remove()</code> 方法来显式地释放内存，从而避免因长期存活的线程而导致的值的内存泄漏。</p><h4 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a><strong>继承问题</strong></h4><p><code>ThreadLocal</code> 的值不会自动传递给子线程。如果你需要父线程创建子线程时，让子线程也能访问父线程的 <code>ThreadLocal</code> 值，你需要使用 <code>InheritableThreadLocal</code>。不过，<code>InheritableThreadLocal</code> 同样需要注意内存泄漏问题，并且在线程池环境下使用时可能会有意外行为，需要格外小心。</p><h2 id="Collection-集合框架"><a href="#Collection-集合框架" class="headerlink" title="Collection (集合框架):"></a>Collection (集合框架):</h2><ul><li>核心接口: Collection (父接口), List, Set, Map。</li><li>Iterable 接口: Collection 接口继承了 Iterable 接口,使得所有集合都可以通过增强for 循环(foreach)进行遍历。</li></ul><h4 id="A-List-接口及其实现类"><a href="#A-List-接口及其实现类" class="headerlink" title="A. List 接口及其实现类"></a>A. List 接口及其实现类</h4><p>List 是一种有序集合,可以包含重复元素。</p><hr><h5 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h5><h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><ul><li>基于动态数组 <code>Object[] elementData</code> 实现。</li></ul><h6 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h6><ul><li><strong>有序</strong>：元素按照插入顺序存储，可通过索引访问 (<code>get(index)</code>)。</li><li><strong>可重复</strong>：允许存储重复元素。</li><li><strong>随机访问效率高</strong>：<ul><li>通过索引访问元素速度非常快，时间复杂度为 <strong>O(1)</strong>。</li><li>原因：数组在内存中连续存储，可通过基地址和偏移量直接计算元素地址。</li></ul></li><li><strong>插入和删除效率低</strong>：<ul><li>在数组末尾添加或删除元素效率较高，平均 <strong>O(1)</strong>。</li><li>在数组中间插入或删除元素时，需要使用 <code>System.arraycopy()</code> 移动后续元素，时间复杂度 <strong>O(n)</strong>。</li></ul></li><li><strong>线程不安全</strong>：<ul><li>多线程环境下，一个线程修改 ArrayList，另一个线程读取或修改可能导致数据不一致或抛出 <code>ConcurrentModificationException</code>（迭代器遍历时）。</li></ul></li></ul><h6 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h6><ul><li><p><strong>初始容量</strong>：</p><ul><li>无参构造：内部数组为空 (<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，即 <code>new Object[0]</code>)。</li><li>首次添加元素时，数组初始化为默认容量 <code>DEFAULT_CAPACITY</code>（JDK8 为 10）。</li><li>指定容量构造：<code>new ArrayList&lt;&gt;(capacity)</code>，初始容量为指定值。</li></ul></li><li><p><strong>扩容时机</strong>：</p><ul><li>当当前元素个数 <code>size</code> 等于数组容量 <code>elementData.length</code> 时触发扩容。</li></ul></li><li><p><strong>扩容方式</strong>（位于 <code>grow()</code> 方法中）：</p><ol><li><p>计算新容量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>)  <span class="comment">// 即旧容量的1.5倍</span></span><br></pre></td></tr></table></figure></li><li><p>如果新容量仍小于所需最小容量 <code>minCapacity</code>（即 <code>size + 1</code>），直接使用 <code>minCapacity</code>。</p></li><li><p>如果新容量超出 <code>MAX_ARRAY_SIZE</code>（通常为 <code>Integer.MAX_VALUE - 8</code>），尝试使用 <code>Integer.MAX_VALUE</code>，仍不足则抛出 <code>OutOfMemoryError</code>。</p></li><li><p>创建新数组，并将旧数组元素复制过去 (<code>Arrays.copyOf()</code> 内部使用 <code>System.arraycopy()</code>)。</p></li></ol></li><li><p><strong>为什么扩容 1.5 倍</strong>：</p><ul><li><strong>平衡空间与时间</strong>：<ul><li>相比每次只增加 1 个元素，1.5 倍减少扩容次数，降低数组复制开销（O(n)）。</li><li>相比 2 倍扩容，1.5 倍在空间利用率上更优，避免浪费过多内存。</li></ul></li><li>总体是 <strong>时间和空间的折中选择</strong>，实现高效且内存友好的动态数组。</li></ul></li></ul><h6 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h6><ul><li><strong>ConcurrentModificationException</strong>：<ul><li>多线程环境中，一个线程遍历 ArrayList（迭代器或增强 <code>for</code> 循环），另一个线程进行结构性修改（添加&#x2F;删除元素），迭代器会快速失败（fail-fast）检测 <code>modCount</code>，若不一致抛出异常。</li></ul></li><li><strong>内存开销</strong>：<ul><li>预估容量不准确时，频繁扩容增加 CPU 和内存开销。</li></ul></li><li><strong>内存浪费</strong>：<ul><li>初始容量设置过大，而实际元素很少，会浪费内存。</li></ul></li></ul><h6 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h6><ul><li><p><code>add(E e)</code>：在末尾添加元素。</p></li><li><p><code>add(int index, E e)</code>：在指定位置插入元素。</p></li><li><p><code>remove(int index)</code> &#x2F; <code>remove(Object o)</code>：删除指定位置或第一个匹配元素。</p></li><li><p><code>get(int index)</code>：获取指定位置元素。</p></li><li><p><code>set(int index, E e)</code>：替换指定位置元素。</p></li><li><p><code>size()</code>：返回元素个数。</p></li><li><p><code>indexOf(Object o)</code> &#x2F; <code>lastIndexOf(Object o)</code>：返回元素第一次&#x2F;最后一次出现的索引。</p></li><li><p><code>contains(Object o)</code>：判断是否包含某个元素。</p></li><li><p><code>clear()</code>：清空列表。</p></li><li><p>遍历方式:</p><ol><li><p>传统 for 循环:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增强 for 循环(foreach):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (E element: list) &#123; <span class="comment">//内部使用迭代器</span></span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代器(Iterator):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">    <span class="comment">// 如果需要删除元素,必须使用 it.remove(),否则会抛出</span></span><br><span class="line">    <span class="comment">// ConcurrentModificationException</span></span><br><span class="line">    <span class="comment">// it.remove();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Java 8 Stream API:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">list.stream().forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ul><p><code>RandomAccess</code> 是 Java 集合框架中的一个<strong>标记接口</strong>，它本身不包含任何方法。它的主要作用是告诉 Java 虚拟机（JVM）和开发者，实现了这个接口的 <code>List</code> 集合<strong>支持快速随机访问</strong>，即通过索引访问元素时，性能是恒定的，通常为 O(1)。</p><hr><h6 id="ArrayList-实现-RandomAccess-的作用"><a href="#ArrayList-实现-RandomAccess-的作用" class="headerlink" title="ArrayList 实现 RandomAccess 的作用"></a><code>ArrayList</code> 实现 <code>RandomAccess</code> 的作用</h6><p><code>ArrayList</code> 的底层是<strong>数组</strong>。通过索引访问数组元素（如 <code>list.get(i)</code>）是一个非常高效的操作，因为它直接通过内存地址偏移量来查找，耗时是固定的。</p><p><code>RandomAccess</code> 接口的作用就是为这种特性提供一个<strong>标记</strong>。在某些算法或方法中（比如 <code>Collections.binarySearch()</code>），程序会先检查一个 <code>List</code> 是否实现了 <code>RandomAccess</code>。</p><ul><li>如果实现了，就说明它是 <code>ArrayList</code> 这类基于数组的列表，此时会选择<strong>基于索引的 for 循环</strong>进行遍历，因为这种方式最快。</li><li>如果没实现，就说明它是 <code>LinkedList</code> 这类基于链表的列表，此时会选择<strong>迭代器</strong>进行遍历，以避免低效的随机访问。</li></ul><p>因此，<code>RandomAccess</code> 就像一个性能提示标签，帮助 JVM 和算法选择最合适的遍历或查找策略，从而优化性能。</p><hr><h6 id="为什么-LinkedList-没有实现-RandomAccess？"><a href="#为什么-LinkedList-没有实现-RandomAccess？" class="headerlink" title="为什么 LinkedList 没有实现 RandomAccess？"></a>为什么 <code>LinkedList</code> 没有实现 <code>RandomAccess</code>？</h6><p><code>LinkedList</code> 的底层是<strong>双向链表</strong>。要通过索引访问链表中的一个元素（如 <code>list.get(i)</code>），需要从头节点或尾节点开始，逐个遍历到目标位置。这个操作的耗时与索引值 <code>i</code> 成正比，时间复杂度为 O(n)。</p><p>因为 <code>LinkedList</code> 不支持快速随机访问，所以它没有实现 <code>RandomAccess</code> 接口。如果用 for 循环来遍历 <code>LinkedList</code>，每次 <code>get(i)</code> 调用都会导致一次从头到尾的遍历，效率极低。相反，使用迭代器则能确保每次只移动到下一个元素，效率更高。</p><table><thead><tr><th>类型</th><th>底层数据结构</th><th>随机访问性能 (<code>get(i)</code>)</th><th>遍历方式</th><th>是否实现 <code>RandomAccess</code></th></tr></thead><tbody><tr><td><strong>ArrayList</strong></td><td>数组</td><td>O(1)</td><td><strong>for 循环</strong></td><td>是</td></tr><tr><td><strong>LinkedList</strong></td><td>双向链表</td><td>O(n)</td><td><strong>迭代器</strong></td><td>否</td></tr></tbody></table><p>总而言之，<code>RandomAccess</code> 接口是一个重要的设计模式，它利用多态性来指导程序为不同的 <code>List</code> 实现选择最优的算法，从而在不修改代码逻辑的前提下提升了性能。</p><h5 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h5><h6 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h6><ul><li>基于 <strong>双向链表 (Doubly Linked List)</strong> 实现。</li><li>每个节点包含：<ul><li>数据 (<code>data</code>)</li><li>指向前一个节点的引用 (<code>prev</code>)</li><li>指向后一个节点的引用 (<code>next</code>)</li></ul></li></ul><h6 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h6><ul><li><strong>有序</strong>：元素按照插入顺序存储。</li><li><strong>可重复</strong>：允许存储重复元素。</li><li><strong>插入和删除效率高</strong>：<ul><li>在链表任意位置插入或删除，只需修改前后节点的引用，时间复杂度 <strong>O(1)</strong>。</li></ul></li><li><strong>随机访问效率低</strong>：<ul><li><code>get(index)</code> 需要从头或尾遍历链表到目标索引，时间复杂度 <strong>O(n)</strong>。</li></ul></li><li><strong>内存开销大</strong>：<ul><li>每个节点除了存储数据，还需要两个指针 (<code>prev</code> 和 <code>next</code>)，相比 ArrayList 内存占用更多。</li></ul></li><li><strong>线程不安全</strong>：<ul><li>多线程环境下不安全，迭代器遍历修改可能抛出 <code>ConcurrentModificationException</code>。</li></ul></li></ul><h6 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h6><ul><li><strong>无需扩容</strong>：<ul><li>LinkedList 基于链表实现，没有固定容量，每次添加元素都是创建新节点并连接到链表中。</li><li>不存在 ArrayList 那样的数组复制开销。</li></ul></li></ul><h6 id="可能出现的问题-1"><a href="#可能出现的问题-1" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h6><ul><li><strong>ConcurrentModificationException</strong>：<ul><li>多线程环境下使用迭代器修改时可能发生。</li></ul></li><li><strong>内存碎片&#x2F;开销</strong>：<ul><li>节点频繁创建和销毁，以及每个节点额外的指针开销，可能导致内存碎片和较高内存占用。</li></ul></li></ul><h6 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h6><ul><li><p><strong>添加元素</strong></p><ul><li><code>add(E e)</code> &#x2F; <code>addFirst(E e)</code> &#x2F; <code>addLast(E e)</code></li></ul></li><li><p><strong>删除元素</strong></p><ul><li><code>remove()</code> &#x2F; <code>removeFirst()</code> &#x2F; <code>removeLast()</code></li></ul></li><li><p><strong>获取元素</strong></p><ul><li><code>get(int index)</code> &#x2F; <code>getFirst()</code> &#x2F; <code>getLast()</code>（注意：<code>get(int index)</code> 效率低）</li></ul></li><li><p><strong>队列&#x2F;双端队列操作</strong></p><ul><li><code>peek()</code> &#x2F; <code>peekFirst()</code> &#x2F; <code>peekLast()</code>：获取但不移除头部&#x2F;尾部元素</li><li><code>offer(E e)</code> &#x2F; <code>offerFirst(E e)</code> &#x2F; <code>offerLast(E e)</code>：添加元素（通常不抛异常）</li><li><code>poll()</code> &#x2F; <code>pollFirst()</code> &#x2F; <code>pollLast()</code>：获取并移除头部&#x2F;尾部元素（为空返回 <code>null</code>）</li></ul></li><li><p><strong>栈操作</strong></p><ul><li><code>push(E e)</code> &#x2F; <code>pop()</code>：实现入栈和出栈</li></ul></li><li><p><strong>其他常用方法</strong></p><ul><li><code>size()</code>, <code>isEmpty()</code>, <code>contains(Object o)</code>, <code>clear()</code></li></ul></li><li><p>遍历方式:</p><ol><li><p>传统 for 循环: <code>for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125;</code>(不推荐,效率低)</p></li><li><p>增强 for 循环(foreach): <code>for (E element: list) &#123; System.out.println(element); &#125;</code>(推荐)</p></li><li><p>迭代器(Iterator):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Java 8 Stream API: <code>list.forEach(System.out::println);</code></p></li></ol></li></ul><h5 id="3-Vector"><a href="#3-Vector" class="headerlink" title="3. Vector"></a>3. Vector</h5><ul><li>底层实现:基于动态数组实现,与ArrayList 类似。</li><li>特点:<ul><li>线程安全:所有公共方法都使用了synchronized 关键字进行同步,因此是线程安全的。</li><li>效率低:因为所有操作都被同步,在单线程或并发读多写少的场景下,性能比 ArrayList 差。</li><li>扩容机制: Vector 的扩容策略与 ArrayList 类似,但默认是翻倍扩容(即新容量是旧容量的2倍)。可以通过构造函数指定扩容增量。</li></ul></li><li>可能出现的问题:<ul><li>性能瓶颈:全局锁导致并发性能差。</li></ul></li><li>使用场景:已经被 java.util.concurrent 包中的并发集合(如 CopyOnWriteArrayList)取代,基本不再推荐使用。</li></ul><h5 id="4-Stack"><a href="#4-Stack" class="headerlink" title="4. Stack"></a>4. Stack</h5><ul><li>底层实现:继承自Vector,因此也是基于数组实现,并具有Vector 的线程安全性。</li><li>特点:实现了后进先出(LIFO)的栈结构。</li><li>常用方法:<ul><li>push(E item):元素入栈。</li><li>pop():元素出栈。</li><li>peek(): 查看栈顶元素但不移除。</li><li>empty(): 判断栈是否为空。</li><li>search(Object o): 查找元素并返回离栈顶的距离。</li></ul></li><li>使用场景:不推荐使用,因为Stack 继承了Vector,而 Vector 本身有很多不适合栈操作的方法。通常使用 Deque 接口的实现类(如ArrayDeque 或 LinkedList)来代替栈,它们更灵活高效。</li></ul><h5 id="小结-List"><a href="#小结-List" class="headerlink" title="小结 List:"></a>小结 List:</h5><ul><li>ArrayList: 随机访问多,插入删除少(尤其末尾操作)的场景。</li><li>LinkedList: 插入删除多,随机访问少的场景;或需要作为队列&#x2F;栈使用的场景。</li><li>Vector &#x2F; Stack:不推荐在现代Java开发中使用,除非有特殊历史兼容需求。</li></ul><table><thead><tr><th>特性 &#x2F; 类型</th><th>ArrayList</th><th>LinkedList</th><th>Vector</th></tr></thead><tbody><tr><td><strong>底层实现</strong></td><td>动态数组 (<code>Object[] elementData</code>)</td><td>双向链表 (<code>Node</code> 双向链表结构)</td><td>动态数组 (<code>Object[] elementData</code>)</td></tr><tr><td><strong>有序性</strong></td><td>有序（按插入顺序）</td><td>有序（按插入顺序）</td><td>有序（按插入顺序）</td></tr><tr><td><strong>可重复性</strong></td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td><strong>随机访问效率</strong></td><td>高，<code>get(index)</code> O(1)</td><td>低，O(n)，需要从头或尾遍历节点</td><td>高，<code>get(index)</code> O(1)</td></tr><tr><td><strong>插入&#x2F;删除效率</strong></td><td>末尾添加&#x2F;删除 O(1)，中间插入&#x2F;删除 O(n)</td><td>任意位置插入&#x2F;删除 O(1)（通过节点指针操作）</td><td>同 ArrayList，末尾 O(1)，中间 O(n)</td></tr><tr><td><strong>线程安全</strong></td><td>非线程安全</td><td>非线程安全</td><td>线程安全（方法加 <code>synchronized</code>）</td></tr><tr><td><strong>扩容策略</strong></td><td>容量不足时，<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code> 约 1.5 倍</td><td>不涉及数组扩容</td><td>容量不足时，默认扩容为 2 倍</td></tr><tr><td><strong>内存开销</strong></td><td>较低，但数组可能产生浪费</td><td>每个节点需要存储前后指针，内存开销较高</td><td>与 ArrayList 类似，但因为线程安全方法开销略高</td></tr><tr><td><strong>适用场景</strong></td><td>随机访问多、插入删除少</td><td>插入删除多、遍历访问多</td><td>线程安全环境下使用，随机访问需求多</td></tr><tr><td><strong>常用方法</strong></td><td><code>add()</code>, <code>get()</code>, <code>remove()</code>, <code>set()</code>, <code>size()</code></td><td><code>add()</code>, <code>addFirst()</code>, <code>addLast()</code>, <code>remove()</code>, <code>get()</code></td><td>与 ArrayList 方法一致，但所有方法加 <code>synchronized</code></td></tr></tbody></table><h5 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h5><ol><li><strong>ArrayList</strong><ul><li>优势：随机访问快、内存连续。</li><li>劣势：中间插入&#x2F;删除慢。</li></ul></li><li><strong>LinkedList</strong><ul><li>优势：插入&#x2F;删除任意位置快。</li><li>劣势：随机访问慢、内存开销大。</li></ul></li><li><strong>Vector</strong><ul><li>优势：线程安全，随机访问快。</li><li>劣势：所有方法加锁，性能略低于 ArrayList，扩容更大可能浪费空间。</li></ul></li></ol><h4 id="B-Set-接口及其实现类"><a href="#B-Set-接口及其实现类" class="headerlink" title="B. Set 接口及其实现类"></a>B. Set 接口及其实现类</h4><p>Set 是一种无序集合,不允许重复元素。</p><h5 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h5><h6 id="底层实现-2"><a href="#底层实现-2" class="headerlink" title="底层实现"></a>底层实现</h6><ul><li>基于 <strong>HashMap</strong> 实现。</li><li>内部使用一个 HashMap 实例存储元素：<ul><li><strong>元素本身</strong> 作为 HashMap 的 <strong>键（Key）</strong></li><li><strong>值（Value）</strong> 为固定的、无关紧要的静态对象 <code>PRESENT</code></li></ul></li></ul><h6 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h6><ul><li><strong>无序</strong>：不保证元素的存储顺序和迭代顺序。</li><li><strong>不可重复</strong>：元素唯一性由 <code>hashCode()</code> 和 <code>equals()</code> 方法决定。<ul><li>添加元素时：<ol><li>计算元素的 <code>hashCode()</code></li><li>找到对应的“桶”</li><li>遍历桶中元素，如果存在 <code>equals()</code> 为 <code>true</code> 的元素，则不添加</li></ol></li></ul></li><li><strong>允许 null 元素</strong>：最多只能存储一个 <code>null</code></li><li><strong>操作效率高</strong>：<ul><li>查询、添加、删除平均时间复杂度 <strong>O(1)</strong>（哈希冲突少的情况下）</li><li>最坏情况（所有元素哈希冲突到同一个桶）退化为 <strong>O(n)</strong></li></ul></li><li><strong>线程不安全</strong>：与 HashMap 类似，非同步</li></ul><h6 id="扩容机制-2"><a href="#扩容机制-2" class="headerlink" title="扩容机制"></a>扩容机制</h6><ul><li><strong>容量和负载因子</strong>：<ul><li>默认初始容量：16</li><li>默认负载因子：0.75</li></ul></li><li><strong>扩容时机</strong>：当元素数量达到 <code>容量 × 负载因子</code> 时触发</li><li><strong>扩容过程</strong>：<ol><li>创建新容量为旧容量 <strong>2 倍</strong> 的数组</li><li>遍历旧数组元素，重新计算哈希值</li><li>将元素放入新数组正确位置</li></ol></li></ul><h6 id="可能出现的问题-2"><a href="#可能出现的问题-2" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h6><ul><li><strong>性能下降</strong>：<ul><li>如果自定义类未正确重写 <code>hashCode()</code> 和 <code>equals()</code>，可能出现重复元素或哈希冲突严重，性能急剧下降</li></ul></li><li><strong>ConcurrentModificationException</strong>：<ul><li>多线程环境下使用迭代器修改集合时可能抛出</li></ul></li></ul><h6 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h6><ul><li><code>add(E e)</code>：添加元素</li><li><code>remove(Object o)</code>：删除元素</li><li><code>contains(Object o)</code>：判断是否包含某元素</li><li><code>size()</code>：返回元素数量</li><li><code>isEmpty()</code> &#x2F; <code>clear()</code>：判断是否为空 &#x2F; 清空集合</li></ul><h6 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h6><ol><li><p>增强 for 循环 (foreach): <code>for (E element : set) &#123; System.out.println(element); &#125;</code></p></li><li><p>迭代器 (Iterator):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Java 8 Stream API: <code>set.forEach(System.out::println);</code></p></li></ol><h5 id="2-LinkedHashSet"><a href="#2-LinkedHashSet" class="headerlink" title="2. LinkedHashSet"></a>2. LinkedHashSet</h5><ul><li>底层实现: 继承自 HashSet，内部使用 LinkedHashMap 实现。</li><li>特点:<ul><li>除了具备 HashSet 的所有特性外，最大的特点是保持元素的插入顺序（或者访问顺序，如果配置为 LRU 缓存）。这意味着遍历 LinkedHashSet时，元素的顺序与它们被添加到集合中的顺序一致。</li><li>维护了一个双向链表，用于维护元素的插入顺序。</li></ul></li><li>扩容机制: 与 HashSet 和 HashMap 相同。</li><li>使用场景: 需要去重，同时又需要保持元素插入顺序的场景。</li></ul><h5 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3. TreeSet"></a>3. TreeSet</h5><ul><li>底层实现: 基于 TreeMap 实现。TreeSet 内部使用一个 TreeMap 实例来存储元素，TreeSet 的元素作为 TreeMap 的键，而值则是一个固定的 Object。</li><li>特点:<ul><li>有序: 元素会根据其自然排序（元素必须实现 Comparable 接口）或者在创建 TreeSet 时提供的 Comparator 进行排序。</li><li>不可重复: 元素唯一，唯一性通过比较结果判断（compareTo() 或 compare() 方法返回 0）。</li><li>不允许 null 元素: 不允许存储 null 元素（因为 null 无法进行比较）。</li><li>查询、添加、删除的时间复杂度为 O(log n)，因为底层是红黑树。</li><li>线程不安全: 非同步。</li></ul></li><li>扩容机制:<ul><li>由于底层是红黑树，没有传统意义上的扩容机制。每次添加元素就是增加一个节点，并根据红黑树的平衡规则进行调整（旋转和变色）来保持树的平衡。</li></ul></li><li>可能出现的问题:<ul><li>性能: 相比 HashSet，性能略低，因为涉及比较和树的平衡操作。</li><li>元素必须可比较: 如果存储的元素没有实现 Comparable 接口，或者创建 TreeSet 时没有提供 Comparator，则会抛出 ClassCastException。</li><li>ConcurrentModicationException: 同步性问题。</li></ul></li><li>常用方法:<ul><li>与 HashSet 类似，但额外提供了与排序相关的方法，如 rst(), last(), headSet(), tailSet(), subSet() 等。</li></ul></li></ul><h5 id="小结-Set"><a href="#小结-Set" class="headerlink" title="小结 Set:"></a>小结 Set:</h5><ul><li>HashSet: 最常用，需要快速查找、去重，不关心元素顺序的场景。</li><li>LinkedHashSet: 需要去重，同时又需要保持元素插入顺序的场景。</li><li>TreeSet: 需要去重，并且希望元素自动按照自然顺序或自定义顺序排序的场景。</li></ul><h4 id="C-Map-接口及其实现类"><a href="#C-Map-接口及其实现类" class="headerlink" title="C. Map 接口及其实现类"></a>C. Map 接口及其实现类</h4><p>Map 存储键值对，键是唯一的，值可以重复。</p><hr><h5 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h5><h6 id="底层实现-3"><a href="#底层实现-3" class="headerlink" title="底层实现"></a>底层实现</h6><ul><li>基于 <strong>哈希表 (Hash Table)</strong> 实现。</li><li>JDK 8 及以后结构：<strong>数组 + 链表 + 红黑树</strong><ul><li><strong>数组 (Node[])</strong>：存储桶，数组下标通过哈希值计算得到</li><li><strong>链表</strong>：用于解决哈希冲突，将哈希到同一索引的键值对以链表形式存储</li><li><strong>红黑树</strong>：当链表长度达到阈值（默认 8）时，链表转换为红黑树，提高查找效率；节点数少于阈值（默认 6）时退化为链表</li></ul></li></ul><h6 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h6><ul><li><strong>无序</strong>：不保证键值对存储顺序和迭代顺序</li><li><strong>键唯一，值可重复</strong>：键由 <code>hashCode()</code> 和 <code>equals()</code> 确定唯一性</li><li><strong>允许 null 键和 null 值</strong>：<ul><li>仅允许一个 <code>null</code> 键（存储在索引 0）</li><li>可有多个 <code>null</code> 值</li></ul></li><li><strong>操作效率高</strong>：<ul><li>查询、添加、删除平均时间复杂度 <strong>O(1)</strong></li><li>最坏情况：链表退化 <strong>O(n)</strong>，红黑树 <strong>O(log n)</strong></li></ul></li></ul><h6 id="扩容机制-3"><a href="#扩容机制-3" class="headerlink" title="扩容机制"></a>扩容机制</h6><ul><li><p><strong>初始容量</strong> (<code>initialCapacity</code>)：默认 16</p></li><li><p><strong>负载因子</strong> (<code>loadFactor</code>)：默认 0.75</p></li><li><p><strong>扩容时机</strong>：当元素数量达到 <code>容量 × 负载因子</code>（threshold）触发</p></li><li><p><strong>扩容方式</strong> (<code>resize()</code>)：</p><ol><li>创建新数组，容量为旧数组的 <strong>2 倍</strong></li><li>遍历旧数组中的所有键值对</li><li>重新计算每个键的哈希值，根据新容量放入正确位置（称为再哈希 <code>rehash</code>）</li></ol><ul><li><strong>JDK 8 优化</strong>：链表转换为红黑树时避免每个节点重新计算哈希值，而是通过原索引和新容量关系直接确定位置，提高效率</li></ul></li></ul><h6 id="扩容策略说明"><a href="#扩容策略说明" class="headerlink" title="扩容策略说明"></a>扩容策略说明</h6><ul><li><strong>为什么扩容为 2 倍</strong><ul><li>利用位运算 <code>(h &amp; (length - 1))</code> 替代取模 <code>(h % length)</code>，提高索引计算效率</li><li>减少哈希冲突，使键分布更均匀，链表&#x2F;红黑树长度更短，保持平均 O(1) 性能</li></ul></li><li><strong>为什么负载因子为 0.75</strong><ul><li>平衡空间利用率和查询效率</li><li>过小：频繁扩容，浪费空间</li><li>过大：哈希冲突多，链表&#x2F;红黑树变长，查询效率下降</li><li>0.75 是实践中性能较优的平衡点</li></ul></li></ul><h6 id="可能出现的问题-3"><a href="#可能出现的问题-3" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h6><ul><li><strong>性能下降</strong>：自定义类作为键未重写 <code>hashCode()</code> 或 <code>equals()</code>，可能导致重复元素或严重哈希冲突</li><li><strong>多线程问题</strong>：多线程修改可能导致数据丢失、死循环（JDK 7 及以前）或 <code>ConcurrentModificationException</code></li><li><strong>内存开销</strong>：频繁扩容需要数组复制</li></ul><h6 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h6><ul><li><code>put(K key, V value)</code>：关联键值对</li><li><code>get(Object key)</code>：根据键获取值</li></ul><h6 id="遍历方式-1"><a href="#遍历方式-1" class="headerlink" title="遍历方式"></a>遍历方式</h6><ol><li><strong>遍历键集 (keySet)</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (K key : map.keySet()) &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>遍历键值对集 (entrySet) - 推荐，效率最高</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>遍历值集 (values)</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (V value : map.values()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Value: &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>迭代器 (Iterator)</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = it.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>Java 8 Stream API</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br></pre></td></tr></table></figure><hr><h5 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2. LinkedHashMap"></a>2. LinkedHashMap</h5><ul><li>底层实现: 继承自 HashMap，额外维护了一个双向链表，用于维护插入顺序或访问顺序。</li><li>特点:<ul><li>除了具备 HashMap 的所有特性外，最大的特点是保持键值对的插入顺序（或访问顺序）。这意味着遍历 LinkedHashMap 时，元素的顺序与它们被添加到 Map 中的顺序一致。</li><li>可以用于实现 LRU (Least Recently Used) 缓存策略，通过覆盖 removeEldestEntry 方法并设置访问顺序为 true。</li></ul></li><li>扩容机制: 与 HashMap 相同。</li><li>使用场景: 需要快速查找，同时又需要保持插入顺序的场景。</li></ul><h5 id="3-TreeMap"><a href="#3-TreeMap" class="headerlink" title="3. TreeMap"></a>3. TreeMap</h5><ul><li>底层实现: 基于红黑树（Red-Black Tree）实现。</li><li>特点:<ul><li>有序: 键会根据其自然排序（键的类型必须实现 Comparable 接口）或者在创建 TreeMap 时提供的 Comparator 进行排序。</li><li>键唯一，值可重复: 唯一性判断依赖于键的比较结果（compareTo() 或 compare() 方法返回 0）。</li><li>不允许 null 键: 不允许存储 null 键（因为 null 无法进行比较），但允许 null 值。</li><li>查询、添加、删除的时间复杂度为 O(log n)，因为底层是红黑树。</li><li>线程不安全: 非同步。</li></ul></li><li>扩容机制:<ul><li>由于底层是红黑树，没有传统意义上的扩容机制。每次添加键值对就是增加一个节点，并根据红黑树的平衡规则进行调整（旋转和变色）来保持树的平衡。</li></ul></li><li>可能出现的问题:<ul><li>性能: 相比 HashMap，性能略低，因为涉及比较和树的平衡操作。</li><li>键必须可比较: 如果键没有实现 Comparable 接口，或者创建 TreeMap 时没有提供 Comparator，则会抛出 ClassCastException。</li><li>ConcurrentModicationException: 同步性问题。</li></ul></li><li>常用方法:<ul><li>与 HashMap 类似，但额外提供了与排序相关的方法，如 rstKey(), lastKey(), ceilingEntry(), oorEntry() 等。</li></ul></li></ul><h5 id="4-Hashtable"><a href="#4-Hashtable" class="headerlink" title="4. Hashtable"></a>4. Hashtable</h5><ul><li>底层实现: 基于哈希表实现，与 HashMap 类似，但所有方法都使用了 synchronized 关键字。</li><li>特点:<ul><li>线程安全: 所有公共方法都进行了同步处理。</li><li>效率低: 全局锁导致并发性能差。</li><li>不允许 null 键和 null 值。</li><li>初始容量和扩容机制: 默认初始容量 11，负载因子 0.75。扩容时新容量是旧容量的 2 倍 + 1。</li></ul></li><li>使用场景: 已被 ConcurrentHashMap 取代，基本不再推荐使用。</li></ul><h5 id="5-ConcurrentHashMap-JUC-包中的并发集合"><a href="#5-ConcurrentHashMap-JUC-包中的并发集合" class="headerlink" title="5. ConcurrentHashMap (JUC 包中的并发集合)"></a>5. ConcurrentHashMap (JUC 包中的并发集合)</h5><ul><li><p>底层实现:</p><ul><li>JDK 7 及以前: 采用分段锁 (Segment) 的方式，将 HashMap 内部数据分成多个段（Segment），每个段是一个独立的 ReentrantLock。锁住某个段时，不影响其他段的操作。</li><li>JDK 8 及以后: 放弃了分段锁，改为使用 CAS (Compare-And-Swap) 操作和 synchronized 关键字（只在链表&#x2F;红黑树头节点发生竞争时才使用，锁住的范围更小）来保证线程安全。</li></ul></li><li><p>特点:</p><ul><li>线程安全: 高并发环境下性能优异。</li><li>不允许 null 键和 null 值。</li><li>读操作基本无锁。</li></ul></li><li><p>扩容机制: 与 HashMap 类似，JDK 8 中，每个 Node 数组的扩容是独立的，通过 transfer 方法实现。</p></li><li><p>使用场景: 高并发场景下替代 HashMap 和 Hashtable 的首选。</p></li><li><p><code>java.util.concurrent</code> (JUC) 包是 Java 并发编程的高级工具包，它提供了比传统 <code>synchronized</code> 关键字和 <code>wait/notify</code> 机制更强大、更灵活的并发控制手段。</p></li></ul><h5 id="小结-Map"><a href="#小结-Map" class="headerlink" title="小结 Map:"></a>小结 Map:</h5><ul><li>HashMap: 最常用，需要快速查找，不关心键值对顺序，且在单线程或由外部同步机制保证线程安全的场景。</li><li>LinkedHashMap: 需要快速查找，同时需要保持插入顺序或访问顺序的场景（如实现 LRU 缓存）。</li><li>TreeMap: 需要根据键的自然顺序或自定义顺序排序的场景。</li><li>ConcurrentHashMap: 高并发场景下对 Map 进行读写操作的首选。</li><li>Hashtable: 已被淘汰，不推荐使用。</li></ul><h4 id="集合总结："><a href="#集合总结：" class="headerlink" title="集合总结："></a>集合总结：</h4><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>遍历 Java 集合有多种方式，每种方式都有其优缺点。选择哪种方式取决于你正在使用的集合类型和具体需求。以下是对几种常见遍历方式的优劣分析和推荐。</p><hr><h6 id="1-迭代器-Iterator"><a href="#1-迭代器-Iterator" class="headerlink" title="1. 迭代器 (Iterator)"></a>1. 迭代器 (Iterator)</h6><p>这是最通用的遍历方式，适用于所有实现了 <code>Iterable</code> 接口的集合。</p><ul><li><strong>优点</strong>：<ul><li><strong>通用性强</strong>：它适用于所有集合，包括 <code>List</code>、<code>Set</code> 和 <code>Queue</code>。</li><li><strong>安全</strong>：在使用 <code>Iterator</code> 遍历时，可以安全地调用 <code>iterator.remove()</code> 方法移除元素，不会引发 <code>ConcurrentModificationException</code>。</li><li><strong>性能优越</strong>：对于 <code>LinkedList</code> 这类链式存储的集合，迭代器的遍历效率最高。</li></ul></li><li><strong>缺点</strong>：<ul><li>语法相对繁琐，需要手动调用 <code>hasNext()</code> 和 <code>next()</code>。</li></ul></li><li><strong>推荐</strong>：<ul><li>当需要<strong>在遍历过程中删除元素</strong>时，必须使用迭代器。</li><li>作为<strong>通用</strong>且安全的遍历首选。</li></ul></li></ul><h6 id="2-增强-for-循环-For-Each-Loop"><a href="#2-增强-for-循环-For-Each-Loop" class="headerlink" title="2. 增强 for 循环 (For-Each Loop)"></a>2. 增强 for 循环 (For-Each Loop)</h6><p>增强 for 循环是基于迭代器的一种语法糖，它使遍历代码更简洁易读。</p><ul><li><strong>优点</strong>：<ul><li><strong>代码简洁</strong>：语法简单直观，可读性强。</li><li><strong>不易出错</strong>：无需手动管理索引或迭代器。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>不支持删除</strong>：在遍历过程中直接调用集合的 <code>remove()</code> 方法会抛出 <code>ConcurrentModificationException</code>。</li><li><strong>性能</strong>：对于 <code>LinkedList</code> 来说，它的底层仍然是迭代器，性能很好。但对于 <code>ArrayList</code>，它的性能不如传统的 <code>for</code> 循环，因为每次迭代都需要调用 <code>next()</code> 方法。</li></ul></li><li><strong>推荐</strong>：<ul><li>当你只需要<strong>读取集合中的元素</strong>，且代码简洁性比性能更重要时。</li></ul></li></ul><hr><h6 id="3-传统-for-循环-Indexed-For-Loop"><a href="#3-传统-for-循环-Indexed-For-Loop" class="headerlink" title="3. 传统 for 循环 (Indexed For Loop)"></a>3. 传统 for 循环 (Indexed For Loop)</h6><p>这种方式只适用于支持通过索引访问的集合，如 <code>ArrayList</code> 和 <code>Vector</code>。</p><ul><li><strong>优点</strong>：<ul><li><strong>性能最高</strong>：对于 <code>ArrayList</code>，它通过索引直接访问元素，效率极高，性能优于迭代器。</li><li><strong>灵活</strong>：可以按需向前或向后遍历，也可以跳过元素。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>不通用</strong>：不适用于 <code>Set</code> 或 <code>Map</code> 等不按索引存储的集合。</li><li><strong>效率低下</strong>：对于 <code>LinkedList</code>，每次 <code>get(i)</code> 调用都会从头开始遍历，导致性能极差，时间复杂度为 O(n²)。</li></ul></li><li><strong>推荐</strong>：<ul><li>当遍历 <strong>ArrayList</strong> 并需要<strong>高性能</strong>时。</li></ul></li></ul><hr><h6 id="4-Lambda-表达式与-Stream-API"><a href="#4-Lambda-表达式与-Stream-API" class="headerlink" title="4. Lambda 表达式与 Stream API"></a>4. Lambda 表达式与 Stream API</h6><p>Java 8 引入的 Stream API 提供了非常强大的函数式编程能力，可以用于遍历和处理集合。</p><ul><li><strong>优点</strong>：<ul><li><strong>简洁优雅</strong>：代码非常简洁，表达力强。</li><li><strong>功能强大</strong>：支持过滤、映射、排序等各种操作，能以声明式的方式处理数据。</li><li><strong>支持并行</strong>：可以通过 <code>parallelStream()</code> 开启并行处理，利用多核优势。</li></ul></li><li><strong>缺点</strong>：<ul><li>性能开销：通常比传统的 <code>for</code> 循环略高，特别是在处理小规模数据时。</li></ul></li><li><strong>推荐</strong>：<ul><li>当你需要对集合进行<strong>复杂的操作</strong>（如过滤、转换、聚合）时。</li><li>需要利用<strong>并行处理</strong>来提高性能时。</li></ul></li></ul><hr><h6 id="总结与最佳实践"><a href="#总结与最佳实践" class="headerlink" title="总结与最佳实践"></a>总结与最佳实践</h6><table><thead><tr><th>方式</th><th>适用集合</th><th>优劣</th><th>推荐场景</th></tr></thead><tbody><tr><td><strong>迭代器</strong></td><td>所有集合</td><td>通用、安全（可删除），对 <code>LinkedList</code> 性能好。</td><td>需要在遍历中删除元素，或作为通用选择。</td></tr><tr><td><strong>增强 for</strong></td><td>所有集合</td><td>语法简洁，可读性高。不能在遍历中删除。</td><td>仅需读取元素，且追求代码简洁。</td></tr><tr><td><strong>传统 for</strong></td><td><code>ArrayList</code> 等</td><td><code>ArrayList</code> 性能最高，灵活。对 <code>LinkedList</code> 性能极差。</td><td><code>ArrayList</code> 的高性能遍历，或需要控制索引。</td></tr><tr><td><strong>Stream API</strong></td><td>所有集合</td><td>功能强大，代码优雅，支持并行。</td><td>复杂数据处理、并行计算。</td></tr></tbody></table><p><strong>简单概括</strong>：</p><ul><li><strong>读取</strong> <code>ArrayList</code>：首选<strong>传统 for 循环</strong>。</li><li><strong>读取</strong> <code>LinkedList</code>、<code>Set</code>：首选<strong>增强 for 循环</strong>。</li><li><strong>删除</strong>元素：必须使用<strong>迭代器</strong>。</li><li><strong>复杂操作</strong>：使用 <strong>Stream API</strong>。</li></ul><p>通常来说，在 Java 中反向遍历并删除元素时，使用传统的 <strong>for 循环</strong>并从列表的末尾开始向前遍历是最安全和高效的方法。</p><h5 id="为什么推荐反向遍历？"><a href="#为什么推荐反向遍历？" class="headerlink" title="为什么推荐反向遍历？"></a>为什么推荐反向遍历？</h5><p>当你使用正向遍历（从索引 0 开始）并删除元素时，会遇到一个常见问题：</p><ul><li>当你删除一个元素后，它后面的所有元素的索引都会向前移动一位。</li><li>这会导致在下一次循环迭代时，你可能会跳过紧跟在被删除元素后面的那个元素，因为它现在占据了被删除元素原来的位置，而你的循环索引已经增到了下一个位置。</li></ul><p><strong>反向遍历</strong>完美地解决了这个问题。当你从列表末尾开始向前遍历时，删除一个元素<strong>不会影响</strong>你尚未遍历到的任何元素的索引，因为你正在处理的元素及其索引都位于列表的“后半部分”。</p><hr><h6 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h6><h6 id="1-传统的-for-循环（推荐）"><a href="#1-传统的-for-循环（推荐）" class="headerlink" title="1. 传统的 for 循环（推荐）"></a>1. 传统的 <code>for</code> 循环（推荐）</h6><p>这是反向遍历并删除最直接、最安全、最高效的方式，尤其适用于 <code>ArrayList</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseRemoveExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后往前遍历，并删除元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 假设我们要删除所有元素</span></span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的列表: &quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-迭代器（Iterator）"><a href="#2-迭代器（Iterator）" class="headerlink" title="2. 迭代器（Iterator）"></a>2. 迭代器（Iterator）</h6><p>虽然迭代器通常用于正向遍历，但你也可以使用它来从后向前遍历并删除。不过，这种方式的实现相对复杂，并且对于 <code>LinkedList</code> 之外的集合性能并不好。对于 <code>ArrayList</code>，它仍然需要从末尾开始遍历，性能不如传统 <code>for</code> 循环。</p><p><strong>注意</strong>：<code>ListIterator</code> 提供了双向遍历功能，但其 <code>previous()</code> 方法在 <code>Iterator</code> 接口中并不存在。因此，在通用性上，传统 <code>for</code> 循环依然是首选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个使用 ListIterator 的例子，只适用于 List</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteratorExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从列表末尾获取 ListIterator</span></span><br><span class="line">        ListIterator&lt;String&gt; it = list.listIterator(list.size());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> it.previous();</span><br><span class="line">            <span class="comment">// 假设我们删除元素 &quot;b&quot; 和 &quot;c&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (element.equals(<span class="string">&quot;b&quot;</span>) || element.equals(<span class="string">&quot;c&quot;</span>)) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的列表: &quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h5><ul><li><strong>推荐</strong>：对于 <code>ArrayList</code> 或任何基于数组的列表，使用<strong>传统的 for 循环反向遍历</strong>是最简单、最安全、最高效的删除方式。</li><li><strong>避免</strong>：避免在正向遍历时直接使用 <code>remove()</code> 方法，因为它可能导致跳过元素或引发 <code>ConcurrentModificationException</code>。</li><li><strong>通用性</strong>：如果你需要编写一个通用的删除方法，考虑到所有 <code>List</code> 实现，那么 <code>ListIterator</code> 是一个选择，但它的双向遍历特性仅限于 <code>List</code> 接口。</li></ul><h4 id="多线程下的hashmap死循环问题："><a href="#多线程下的hashmap死循环问题：" class="headerlink" title="多线程下的hashmap死循环问题："></a>多线程下的hashmap死循环问题：</h4><p>当多个线程同时对一个 <strong>HashMap</strong> 进行操作时，尤其是在涉及扩容（resizing）的情况下，可能会导致死循环。这个问题主要出现在 Java 7 及以前的版本，由于其底层数据结构和扩容机制的设计缺陷。</p><hr><h5 id="HashMap-的死循环问题"><a href="#HashMap-的死循环问题" class="headerlink" title="HashMap 的死循环问题"></a>HashMap 的死循环问题</h5><p>在 Java 7 中，<code>HashMap</code> 采用<strong>数组 + 链表</strong>的方式存储数据。当链表上的元素数量过多时，为了提高性能，<code>HashMap</code> 会进行扩容。扩容的步骤大致如下：</p><ol><li>创建一个新的、更大的数组。</li><li>遍历旧数组中的所有元素。</li><li>将每个元素重新计算哈希值，并放入新数组的正确位置。</li></ol><p>问题就出在第三步：<strong>将链表上的元素从旧数组转移到新数组时，如果多个线程同时进行此操作，就可能导致链表中的节点顺序颠倒，形成闭环。</strong></p><h6 id="扩容时的死循环过程"><a href="#扩容时的死循环过程" class="headerlink" title="扩容时的死循环过程"></a>扩容时的死循环过程</h6><p>假设有两个线程 <strong>Thread1</strong> 和 <strong>Thread2</strong> 同时对一个 <code>HashMap</code> 进行扩容。</p><ol><li><strong>初始状态</strong>：<code>HashMap</code> 扩容前，一个桶位上有一个链表，比如 <code>NodeA</code> -&gt; <code>NodeB</code>。</li><li><strong>Thread1 执行到一半</strong>：<code>Thread1</code> 遍历到 <code>NodeA</code>，准备将其移动到新数组。此时 <code>Thread1</code> 被挂起。<code>NodeA</code> 的 <code>next</code> 引用仍然指向 <code>NodeB</code>。</li><li><strong>Thread2 开始执行</strong>：<code>Thread2</code> 完整地完成了扩容过程。它将链表 <code>NodeA</code> -&gt; <code>NodeB</code> 转移到了新数组。但由于是单线程操作，转移后链表顺序保持不变，仍是 <code>NodeA</code> -&gt; <code>NodeB</code>。</li><li><strong>Thread1 恢复执行</strong>：<code>Thread1</code> 恢复执行，但它不知道 <code>Thread2</code> 已经完成了扩容。它仍然使用旧的 <code>next</code> 引用信息。<ul><li><code>Thread1</code> 取出 <code>NodeA</code>，将其放入新数组。</li><li><code>Thread1</code> 接着处理 <code>NodeB</code>（因为在 <code>Thread1</code> 的视角，<code>NodeA</code> 的 <code>next</code> 还是 <code>NodeB</code>）。它将 <code>NodeB</code> 放入新数组。此时，<strong>由于哈希冲突，NodeB 被放在了 NodeA 的前面，导致链表变成了 NodeB -&gt; NodeA。</strong></li><li><code>NodeA</code> 的 <code>next</code> 引用（在 <code>Thread1</code> 的视角）仍然指向 <code>NodeB</code>。现在，<code>NodeB</code> 的 <code>next</code> 指向 <code>NodeA</code>，而 <code>NodeA</code> 的 <code>next</code> 指向 <code>NodeB</code>，<strong>形成了一个闭环</strong>。</li></ul></li></ol><p>当后续线程在这个闭环链表上进行查找时，就会陷入无限循环，导致 CPU 100% 占用。</p><hr><h6 id="如何解决这个问题？"><a href="#如何解决这个问题？" class="headerlink" title="如何解决这个问题？"></a>如何解决这个问题？</h6><p>Java 提供了多种线程安全的替代方案来解决 <code>HashMap</code> 的多线程问题：</p><ol><li><strong>Collections.synchronizedMap()</strong>：<ul><li>这个方法可以创建一个线程安全的 <code>Map</code> 包装器。</li><li>它通过在每个方法调用上加锁来实现线程安全。</li><li><strong>优点</strong>：简单易用。</li><li><strong>缺点</strong>：每次访问都需要加锁，并发性能较差。</li></ul></li><li><strong>Hashtable</strong>：<ul><li>一个早期的线程安全 <code>Map</code> 实现，所有公共方法都用 <code>synchronized</code> 修饰。</li><li><strong>优点</strong>：线程安全。</li><li><strong>缺点</strong>：性能差，几乎所有操作都锁住整个表，已被 <code>ConcurrentHashMap</code> 取代。</li></ul></li><li><strong>ConcurrentHashMap</strong>：<ul><li>这是 <strong>Java 推荐的线程安全 Map 实现</strong>。</li><li>在 Java 7 中，它使用了<strong>分段锁（Segment Lock）</strong>，将数据分成多个段，每个段独立加锁。</li><li>在 Java 8 中，它进一步优化，采用**CAS（Compare-And-Swap）**和 <strong>synchronized</strong> 关键字，锁的粒度更细，只锁住当前操作的桶，从而大大提高了并发性能。</li></ul></li></ol><p>因此，在多线程环境下，<strong>永远不要使用 HashMap</strong>。你应该根据需求，选择 <code>ConcurrentHashMap</code> 或 <code>Collections.synchronizedMap()</code> 来保证线程安全。</p><hr><h2 id="Java-集合-迭代器详解"><a href="#Java-集合-迭代器详解" class="headerlink" title="Java 集合 &amp; 迭代器详解"></a><strong>Java 集合 &amp; 迭代器详解</strong></h2><hr><h3 id="一、HashMap-HashSet-LinkedHashMap-ConcurrentHashMap"><a href="#一、HashMap-HashSet-LinkedHashMap-ConcurrentHashMap" class="headerlink" title="一、HashMap &#x2F; HashSet &#x2F; LinkedHashMap &#x2F; ConcurrentHashMap"></a><strong>一、HashMap &#x2F; HashSet &#x2F; LinkedHashMap &#x2F; ConcurrentHashMap</strong></h3><h4 id="1-HashMap-1"><a href="#1-HashMap-1" class="headerlink" title="1. HashMap"></a>1. HashMap</h4><h5 id="底层实现-4"><a href="#底层实现-4" class="headerlink" title="底层实现"></a>底层实现</h5><ul><li><strong>JDK 8 及以后</strong>：数组 + 链表 + 红黑树<ul><li><strong>数组 (Node[])</strong>：存储桶</li><li><strong>链表</strong>：解决哈希冲突</li><li><strong>红黑树</strong>：当链表长度 ≥ 8 转为红黑树，提高查找效率（长度 &lt; 6 时退化为链表）</li></ul></li></ul><h5 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h5><ul><li>无序，不保证迭代顺序</li><li>键唯一（hashCode + equals），值可重复</li><li>允许一个 null 键，多个 null 值</li><li>查询&#x2F;添加&#x2F;删除平均 O(1)，最坏 O(n)（链表）或 O(log n)（红黑树）</li><li>非线程安全</li></ul><h5 id="扩容机制-4"><a href="#扩容机制-4" class="headerlink" title="扩容机制"></a>扩容机制</h5><ul><li>默认容量：16</li><li>默认负载因子：0.75</li><li>扩容触发：<code>size &gt;= capacity * loadFactor</code></li><li>扩容方式：容量 <strong>2 倍</strong> → 遍历旧数组 → 重新哈希放入新数组</li></ul><h5 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">put(K key, V value) <span class="comment">// 添加</span></span><br><span class="line">get(Object key)     <span class="comment">// 获取</span></span><br><span class="line">containsKey(Object key) <span class="comment">// 判断 key 是否存在</span></span><br><span class="line">remove(Object key)  <span class="comment">// 删除</span></span><br><span class="line">size(), isEmpty(), clear()</span><br></pre></td></tr></table></figure><h5 id="遍历方式-2"><a href="#遍历方式-2" class="headerlink" title="遍历方式"></a>遍历方式</h5><ol><li>keySet：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (K key : map.keySet()) &#123; <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key); &#125;</span><br></pre></td></tr></table></figure><ol><li>entrySet（推荐）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;K,V&gt; e : map.entrySet()) &#123; ... &#125;</span><br></pre></td></tr></table></figure><ol><li>values：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (V value : map.values()) &#123; ... &#125;</span><br></pre></td></tr></table></figure><ol><li>Iterator：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = map.entrySet().iterator();</span><br></pre></td></tr></table></figure><ol><li>Java 8 Lambda：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((k,v)-&gt;System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br></pre></td></tr></table></figure><hr><h4 id="2-HashSet"><a href="#2-HashSet" class="headerlink" title="2. HashSet"></a>2. HashSet</h4><h5 id="底层实现-5"><a href="#底层实现-5" class="headerlink" title="底层实现"></a>底层实现</h5><ul><li>基于 <strong>HashMap</strong> 实现</li><li>元素作为 key，value 为固定占位对象 <code>PRESENT</code></li></ul><h5 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h5><ul><li>无序</li><li>元素唯一</li><li>允许一个 null</li><li>查询&#x2F;添加&#x2F;删除平均 O(1)</li></ul><h5 id="保证元素不重复的原理"><a href="#保证元素不重复的原理" class="headerlink" title="保证元素不重复的原理"></a>保证元素不重复的原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123; <span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>; &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-LinkedHashMap"><a href="#3-LinkedHashMap" class="headerlink" title="3. LinkedHashMap"></a>3. LinkedHashMap</h4><ul><li>基于 HashMap + 双向链表实现</li><li>保留 <strong>插入顺序或访问顺序</strong></li><li>通过 <code>accessOrder</code> 控制顺序：<ul><li>true → 按访问顺序</li><li>false → 按插入顺序</li></ul></li><li>Entry 节点额外增加 <code>before</code> 和 <code>after</code> 指针，组成链表</li></ul><hr><h4 id="4-ConcurrentHashMap"><a href="#4-ConcurrentHashMap" class="headerlink" title="4. ConcurrentHashMap"></a>4. ConcurrentHashMap</h4><h5 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h5><ul><li>JDK 7：Segment 分段锁</li><li>JDK 8：去掉 Segment → CAS + synchronized（桶级别锁）</li></ul><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ul><li>JDK7：Segment[] + HashEntry[] + 链表</li><li>JDK8：Node[] + 链表 + 红黑树（类似 HashMap）</li></ul><h5 id="null-支持"><a href="#null-支持" class="headerlink" title="null 支持"></a>null 支持</h5><ul><li>不允许 null key &#x2F; null value（多线程情况下无法区分 key 不存在和 value 为 null）</li></ul><h5 id="遍历方式-3"><a href="#遍历方式-3" class="headerlink" title="遍历方式"></a>遍历方式</h5><ul><li>弱一致性迭代器（不会抛 ConcurrentModificationException，可读到新增&#x2F;修改数据）</li></ul><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><ul><li>高并发场景优于 <code>synchronizedMap</code> 或 Hashtable</li></ul><hr><h4 id="5-HashMap-vs-Hashtable-vs-ConcurrentHashMap"><a href="#5-HashMap-vs-Hashtable-vs-ConcurrentHashMap" class="headerlink" title="5. HashMap vs Hashtable vs ConcurrentHashMap"></a>5. HashMap vs Hashtable vs ConcurrentHashMap</h4><table><thead><tr><th>特性</th><th>HashMap</th><th>Hashtable</th><th>ConcurrentHashMap</th></tr></thead><tbody><tr><td>线程安全</td><td>否</td><td>是（方法加锁）</td><td>是（JDK8 桶级锁 + CAS）</td></tr><tr><td>null key&#x2F;value</td><td>1 个 null key，多 null value</td><td>不允许</td><td>不允许</td></tr><tr><td>遍历方式</td><td>Iterator fail-fast</td><td>Enumeration</td><td>弱一致性迭代器</td></tr><tr><td>性能</td><td>高（单线程）</td><td>低</td><td>高（多线程）</td></tr><tr><td>数据结构</td><td>数组+链表+红黑树</td><td>数组+链表</td><td>JDK7: Segment+HashEntry，JDK8: Node+链表+红黑树</td></tr></tbody></table><hr><h4 id="6-HashMap-get-方法能否判断-key-是否存在？"><a href="#6-HashMap-get-方法能否判断-key-是否存在？" class="headerlink" title="6. HashMap get 方法能否判断 key 是否存在？"></a>6. HashMap get 方法能否判断 key 是否存在？</h4><ul><li><strong>不能直接判断</strong>，因为 get 返回 null 有两种情况：<ol><li>key 不存在</li><li>key 对应的 value 为 null</li></ol></li><li>正确方式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.containsKey(key);</span><br></pre></td></tr></table></figure><hr><h3 id="二、迭代器相关"><a href="#二、迭代器相关" class="headerlink" title="二、迭代器相关"></a><strong>二、迭代器相关</strong></h3><h4 id="1-Iterator"><a href="#1-Iterator" class="headerlink" title="1. Iterator"></a>1. Iterator</h4><ul><li>轻量级对象，用于遍历集合</li><li>方法：<ul><li><code>iterator()</code> → 获取 Iterator 对象</li><li><code>hasNext()</code> → 是否还有元素</li><li><code>next()</code> → 返回下一个元素</li><li><code>remove()</code> → 删除刚返回的元素</li></ul></li></ul><hr><h4 id="2-Iterator-vs-ListIterator"><a href="#2-Iterator-vs-ListIterator" class="headerlink" title="2. Iterator vs ListIterator"></a>2. Iterator vs ListIterator</h4><table><thead><tr><th>特性</th><th>Iterator</th><th>ListIterator</th></tr></thead><tbody><tr><td>支持集合类型</td><td>Set &#x2F; List</td><td>List</td></tr><tr><td>遍历方向</td><td>前向</td><td>前向 + 后向</td></tr><tr><td>额外功能</td><td>删除</td><td>添加 &#x2F; 替换 &#x2F; 获取索引</td></tr></tbody></table><hr><h4 id="3-Iterator-vs-Enumeration"><a href="#3-Iterator-vs-Enumeration" class="headerlink" title="3. Iterator vs Enumeration"></a>3. Iterator vs Enumeration</h4><table><thead><tr><th>特性</th><th>Iterator</th><th>Enumeration</th></tr></thead><tbody><tr><td>方法命名</td><td>next(), hasNext(), remove()</td><td>nextElement(), hasMoreElements()</td></tr><tr><td>安全性</td><td>fail-fast</td><td>不 fail-fast</td></tr><tr><td>删除功能</td><td>支持</td><td>不支持</td></tr></tbody></table><hr><h4 id="4-fail-fast-vs-fail-safe"><a href="#4-fail-fast-vs-fail-safe" class="headerlink" title="4. fail-fast vs fail-safe"></a>4. fail-fast vs fail-safe</h4><hr><h5 id="1-Fail-Fast"><a href="#1-Fail-Fast" class="headerlink" title="1. Fail-Fast"></a><strong>1. Fail-Fast</strong></h5><h6 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h6><ul><li><strong>fail-fast 迭代器</strong>：在迭代过程中，如果集合被结构性修改（增加或删除元素），会立即抛出 <strong>ConcurrentModificationException</strong>。</li><li><strong>目的</strong>：防止在迭代过程中集合状态不一致。</li></ul><h6 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h6><ol><li><strong>直接抛异常</strong>：迭代器发现集合被修改立即失败</li><li><strong>使用场景</strong>：<code>java.util</code> 包下的集合（ArrayList、HashMap、HashSet 等）</li><li><strong>性能高</strong>：因为不需要复制集合，直接在原集合上操作</li></ol><h6 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h6><ul><li>集合类维护一个 <strong>modCount</strong>（修改计数器）</li><li>迭代器创建时保存 <strong>expectedModCount &#x3D; modCount</strong></li><li>每次调用 <code>next()</code> 或 <code>hasNext()</code> 时，迭代器检查 <code>modCount == expectedModCount</code></li><li>若不相等，说明集合被修改 → 抛出 <strong>ConcurrentModificationException</strong></li></ul><h6 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        list.remove(i); <span class="comment">// 修改了集合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时会抛：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentModificationException</span><br></pre></td></tr></table></figure><hr><h5 id="2-Fail-Safe"><a href="#2-Fail-Safe" class="headerlink" title="2. Fail-Safe"></a><strong>2. Fail-Safe</strong></h5><h6 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h6><ul><li><strong>fail-safe 迭代器</strong>：在迭代过程中修改集合，不会抛出异常，而是在迭代器的一个 <strong>副本</strong> 上操作，原集合可能被修改，但迭代器安全</li><li><strong>目的</strong>：保证在并发环境下迭代不会失败</li></ul><h6 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h6><ol><li><strong>不会抛异常</strong>：迭代器在副本上遍历，允许并发修改</li><li><strong>使用场景</strong>：<code>java.util.concurrent</code> 包下的集合（ConcurrentHashMap、CopyOnWriteArrayList 等）</li><li><strong>性能开销</strong>：需要复制集合或特殊数据结构，内存和性能开销较大</li></ol><h6 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h6><ul><li><strong>CopyOnWriteArrayList</strong>：<ul><li>迭代器遍历的是数组的一个 <strong>快照</strong></li><li>在迭代时，修改集合不会影响快照</li></ul></li><li><strong>ConcurrentHashMap</strong>：<ul><li>迭代器是弱一致性（weakly consistent）</li><li>可以迭代到迭代开始时或之后插入的元素，但不保证顺序</li></ul></li></ul><h6 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        list.remove(i); <span class="comment">// 不会抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list); <span class="comment">// 输出 [1, 3]</span></span><br></pre></td></tr></table></figure><hr><h5 id="3-Fail-Fast-vs-Fail-Safe-对比表"><a href="#3-Fail-Fast-vs-Fail-Safe-对比表" class="headerlink" title="3. Fail-Fast vs Fail-Safe 对比表"></a><strong>3. Fail-Fast vs Fail-Safe 对比表</strong></h5><table><thead><tr><th>特性</th><th>Fail-Fast</th><th>Fail-Safe</th></tr></thead><tbody><tr><td>迭代器类型</td><td>java.util 包集合迭代器</td><td>java.util.concurrent 包集合迭代器</td></tr><tr><td>并发修改行为</td><td>抛出 ConcurrentModificationException</td><td>不抛异常，安全迭代</td></tr><tr><td>工作方式</td><td>直接在原集合上迭代</td><td>在集合的副本或特殊数据结构上迭代</td></tr><tr><td>线程安全</td><td>否</td><td>是（支持并发迭代）</td></tr><tr><td>内存开销</td><td>低</td><td>较高（复制或特殊结构）</td></tr><tr><td>示例集合</td><td>ArrayList, HashMap, HashSet</td><td>CopyOnWriteArrayList, ConcurrentHashMap</td></tr><tr><td>适用场景</td><td>单线程或迭代时不修改集合</td><td>多线程并发场景</td></tr></tbody></table><hr><h5 id="4-关键概念总结"><a href="#4-关键概念总结" class="headerlink" title="4. 关键概念总结"></a><strong>4. 关键概念总结</strong></h5><ol><li><strong>Fail-Fast &#x3D; 快速失败</strong><ul><li>优点：性能高，避免数据不一致</li><li>缺点：迭代过程中修改集合会抛异常</li></ul></li><li><strong>Fail-Safe &#x3D; 安全失败</strong><ul><li>优点：并发安全，不抛异常</li><li>缺点：内存开销大，可能看到的集合状态不是最新的</li></ul></li><li><strong>实践经验</strong><ul><li>单线程或迭代时不修改集合 → 使用 fail-fast</li><li>多线程并发迭代 → 使用 fail-safe</li></ul></li></ol><hr><h3 id="三、Collection-与-Collections"><a href="#三、Collection-与-Collections" class="headerlink" title="三、Collection 与 Collections"></a><strong>三、Collection 与 Collections</strong></h3><ul><li><strong>Collection</strong>：最基本的集合接口（List, Set, Queue 的父接口），表示一组对象</li><li><strong>Collections</strong>：集合工具类，提供静态方法，如排序、搜索、线程安全包装等</li></ul><hr><h2 id="🧩-ConcurrentHashMap"><a href="#🧩-ConcurrentHashMap" class="headerlink" title="🧩 ConcurrentHashMap"></a>🧩 ConcurrentHashMap</h2><hr><h3 id="一、背景与设计动机"><a href="#一、背景与设计动机" class="headerlink" title="一、背景与设计动机"></a>一、背景与设计动机</h3><p>在并发场景下：</p><ul><li><code>HashMap</code> 线程不安全，可能出现死循环、数据丢失。</li><li><code>Hashtable</code> 与 <code>Collections.synchronizedMap</code> 使用 <strong>全表锁</strong>，吞吐量极差。</li></ul><p><strong>ConcurrentHashMap（CHM）</strong>：</p><ul><li><strong>线程安全</strong>：保证多线程同时访问时数据一致性。</li><li><strong>高性能</strong>：通过 <strong>分桶锁 + CAS + volatile</strong> 提升并发度。</li><li><strong>弱一致性迭代器</strong>：遍历过程中允许修改，不会抛 <code>ConcurrentModificationException</code>。</li></ul><hr><h3 id="二、实现演变（JDK7-vs-JDK8）"><a href="#二、实现演变（JDK7-vs-JDK8）" class="headerlink" title="二、实现演变（JDK7 vs JDK8）"></a>二、实现演变（JDK7 vs JDK8）</h3><h3 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h3><ul><li>数据结构：<code>Segment[]</code> + <code>HashEntry[]</code>。</li><li>Segment：类似小型 HashMap，每个 Segment 有独立的 ReentrantLock。</li><li>并发度：由 Segment 数量决定（默认 16）。</li></ul><p>缺点：</p><ul><li>锁粒度仍然较大；</li><li>扩容需要锁定整个 Segment。</li></ul><hr><h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><ul><li>数据结构：<code>Node[]</code> + 链表&#x2F;红黑树。</li><li>锁机制：<strong>CAS + synchronized（桶锁）</strong>，比 Segment 更细。</li><li>改进点：<ol><li>无 Segment，更细粒度控制。</li><li>链表冲突过长时转化为 <strong>红黑树</strong>（树化）。</li><li>扩容为 <strong>渐进式 + 多线程协助</strong>。</li><li>使用 <strong>ForwardingNode</strong> 路由迁移。</li></ol></li></ul><hr><h3 id="三、核心数据结构"><a href="#三、核心数据结构" class="headerlink" title="三、核心数据结构"></a>三、核心数据结构</h3><h3 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    volatile V val;</span><br><span class="line">    volatile Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>val</code> 和 <code>next</code> 是 <code>volatile</code>，保证可见性。</li></ul><h3 id="TreeNode（红黑树节点）"><a href="#TreeNode（红黑树节点）" class="headerlink" title="TreeNode（红黑树节点）"></a>TreeNode（红黑树节点）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent, left, right, prev;</span><br><span class="line">    boolean red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当链表长度 &gt; 8 且容量 ≥ 64 时转化为红黑树。</li></ul><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><ul><li>扩容时的占位符，用于标记桶已迁移，引导线程访问新表。</li></ul><hr><h3 id="四、核心操作流程"><a href="#四、核心操作流程" class="headerlink" title="四、核心操作流程"></a>四、核心操作流程</h3><h3 id="1-get-——-无锁读"><a href="#1-get-——-无锁读" class="headerlink" title="1. get() —— 无锁读"></a>1. get() —— 无锁读</h3><ul><li>直接计算 hash 定位桶。</li><li>如果是链表 → 遍历；</li><li>如果是红黑树 → 按树查找；</li><li>如果是 ForwardingNode → 去新表查。</li></ul><p><strong>特点</strong>：无锁，只依赖 volatile 保证可见性。</p><hr><h3 id="2-put-——-写时加锁"><a href="#2-put-——-写时加锁" class="headerlink" title="2. put() —— 写时加锁"></a>2. put() —— 写时加锁</h3><ol><li>计算索引位置；</li><li>桶为空 → CAS 插入；</li><li>桶非空：<ul><li>ForwardingNode → 协助扩容；</li><li>链表&#x2F;树 → synchronized 锁住桶头，再插入；</li></ul></li><li>插入后：<ul><li>如果链表长度 &gt; 8 且容量 ≥ 64 → 树化；</li><li>如果总数超过阈值 → 触发扩容。</li></ul></li></ol><hr><h3 id="3-扩容机制（Transfer）"><a href="#3-扩容机制（Transfer）" class="headerlink" title="3. 扩容机制（Transfer）"></a>3. 扩容机制（Transfer）</h3><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><ul><li>size 超过 <code>threshold = capacity * loadFactor</code>（默认 0.75）。</li></ul><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li><strong>新建数组</strong>：容量翻倍。</li><li><strong>迁移桶</strong>：<ul><li>遍历旧桶，将节点分为 <strong>低位链（loHead）</strong> 和 <strong>高位链（hiHead）</strong>。</li><li><code>hash &amp; oldCap == 0</code> → 留在原位置；</li><li>否则 → 放到 <code>i+oldCap</code>。</li></ul></li><li><strong>标记迁移完成</strong>：<ul><li>旧桶置为 ForwardingNode。</li><li>之后读&#x2F;写遇到它时，会路由到新表。</li></ul></li><li><strong>多线程协助</strong>：<ul><li>其他线程写入时若发现正在扩容 → 调用 <code>helpTransfer()</code> → 一起分桶迁移。</li></ul></li><li><strong>渐进式扩容</strong>：<ul><li>一次只迁移一个桶，避免阻塞。</li></ul></li></ol><hr><h3 id="五、并发控制机制"><a href="#五、并发控制机制" class="headerlink" title="五、并发控制机制"></a>五、并发控制机制</h3><ol><li><strong>CAS</strong>：初始化 table、插入第一个节点时。</li><li><strong>volatile</strong>：保证 val 和 next 的可见性。</li><li><strong>synchronized</strong>：写操作时锁定单个桶。</li><li><strong>ForwardingNode</strong>：保证扩容过程数据一致性。</li></ol><hr><h3 id="六、性能特性"><a href="#六、性能特性" class="headerlink" title="六、性能特性"></a>六、性能特性</h3><ul><li>读操作几乎无锁 → 高性能。</li><li>写操作局部锁定 → 粒度小，冲突概率低。</li><li>扩容支持并行迁移 → 避免长时间卡顿。</li><li>树化避免链表退化 O(n)。</li></ul><hr><h3 id="七、常见高频面试题"><a href="#七、常见高频面试题" class="headerlink" title="七、常见高频面试题"></a>七、常见高频面试题</h3><h3 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h3><ol><li><strong>ConcurrentHashMap 和 HashMap 的区别？</strong><ul><li>HashMap：线程不安全；</li><li>ConcurrentHashMap：线程安全，CAS+桶锁；</li><li>数据结构都支持链表+红黑树。</li></ul></li><li><strong>JDK7 和 JDK8 的区别？</strong><ul><li>JDK7：Segment 分段锁；</li><li>JDK8：CAS + synchronized，锁粒度更细。</li></ul></li><li><strong>为什么 synchronized 而不是 ReentrantLock？</strong><ul><li>JDK8 之后对 synchronized 优化（偏向锁、轻量级锁）；</li><li>实现简洁，不需手动释放锁。</li></ul></li></ol><hr><h3 id="进阶题"><a href="#进阶题" class="headerlink" title="进阶题"></a>进阶题</h3><ol><li><strong>为什么 get 无需加锁？</strong><ul><li>Node 的 val、next 是 volatile，可见性足够；</li><li>get 只读，不会修改结构。</li></ul></li><li><strong>为什么需要红黑树？</strong><ul><li>避免哈希冲突严重时链表退化为 O(n)。</li><li>树化后查询 O(log n)。</li></ul></li><li><strong>红黑树什么时候转化&#x2F;退化？</strong><ul><li>链表长度 &gt; 8 且容量 ≥ 64 → 树化；</li><li>树节点数 &lt; 6 → 退化为链表。</li></ul></li></ol><hr><h3 id="扩容相关题"><a href="#扩容相关题" class="headerlink" title="扩容相关题"></a>扩容相关题</h3><ol><li><strong>ConcurrentHashMap 扩容过程？为什么说是渐进式？</strong><ul><li>桶级迁移，每次只迁移一个桶；</li><li>旧桶置为 ForwardingNode；</li><li>多线程可协助迁移；</li><li>不会一次性迁移整个表 → 避免卡顿。</li></ul></li><li><strong>扩容时，get 如何保证正确性？</strong><ul><li>遇到 ForwardingNode → 跳转新表继续查；</li><li>保证读到的是最新数据。</li></ul></li><li><strong>为什么不允许 key 或 value 为 null？</strong><ul><li>无法区分「null 表示没有值」还是「值本身就是 null」，容易歧义。</li></ul></li><li><strong>为什么迭代器是弱一致性的？</strong></li></ol><ul><li>遍历时允许并发修改；</li><li>不抛异常，但可能漏数据或读到旧值。</li></ul><ol><li><strong>size() 如何实现？为什么不精确？</strong></li></ol><ul><li>分段计数，多次尝试累加；</li><li>并发下不保证强一致性，只保证大致准确。</li></ul><hr><h3 id="高阶题"><a href="#高阶题" class="headerlink" title="高阶题"></a>高阶题</h3><ol><li><strong>为什么扩容时使用 ForwardingNode？</strong></li></ol><ul><li>防止重复迁移；</li><li>读写遇到它能路由到新表。</li></ul><ol><li><strong>ConcurrentHashMap 会死锁吗？</strong></li></ol><ul><li>不会。每次只锁单个桶，不存在跨桶死锁。</li></ul><ol><li><strong>ConcurrentHashMap 与 CopyOnWriteMap 区别？</strong></li></ol><ul><li>CHM：适合读多写多，分桶锁+CAS；</li><li>COW：适合读多写少，写时复制，读完全无锁。</li></ul><hr><h3 id="八、答题模板（面试框架）"><a href="#八、答题模板（面试框架）" class="headerlink" title="八、答题模板（面试框架）"></a>八、答题模板（面试框架）</h3><p>当被问到「ConcurrentHashMap」时，可以这样答：</p><ol><li><strong>整体实现</strong>：<ul><li>JDK7：Segment 分段锁；</li><li>JDK8：Node 数组 + CAS + synchronized（桶锁）。</li></ul></li><li><strong>核心思想</strong>：<ul><li>读操作无锁；</li><li>写操作锁单个桶；</li><li>扩容渐进式+多线程协助；</li><li>冲突过长时树化。</li></ul></li><li><strong>扩容机制</strong>：<ul><li>懒扩容，阈值触发；</li><li>ForwardingNode 标记已迁移桶；</li><li>多线程 helpTransfer；</li><li>渐进式迁移，避免阻塞。</li></ul></li><li><strong>常见问题</strong>：<ul><li>不允许 null key&#x2F;value；</li><li>弱一致性迭代器；</li><li>size() 不精确。</li></ul></li></ol><hr><p>📌 <strong>一句话总结口诀</strong>：<br> 👉 <strong>JDK7 Segment 分段锁，JDK8 CAS+桶锁；读无锁，写锁桶，扩容多线程协助；链表转树，弱一致迭代。</strong></p><hr><h2 id="集合面试题"><a href="#集合面试题" class="headerlink" title="集合面试题"></a>集合面试题</h2><hr><h3 id="一、ArrayList-LinkedList"><a href="#一、ArrayList-LinkedList" class="headerlink" title="一、ArrayList &#x2F; LinkedList"></a><strong>一、ArrayList &#x2F; LinkedList</strong></h3><ol><li><p><strong>ArrayList 和 LinkedList 的区别？</strong></p><table><thead><tr><th>特性</th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>底层结构</td><td>动态数组</td><td>双向链表</td></tr><tr><td>随机访问效率</td><td>高 O(1)</td><td>低 O(n)</td></tr><tr><td>插入删除效率</td><td>尾部高，中间低 O(n)</td><td>任意位置高 O(1)</td></tr><tr><td>内存开销</td><td>较小</td><td>较大（节点指针 prev&#x2F;next）</td></tr><tr><td>线程安全</td><td>否</td><td>否</td></tr></tbody></table></li><li><p><strong>ArrayList 扩容机制？</strong></p><ul><li>默认容量：10</li><li>扩容策略：<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code> → 1.5 倍</li><li>扩容原因：平衡空间与时间，减少频繁复制</li></ul></li><li><p><strong>LinkedList 为什么随机访问慢？</strong></p><ul><li>get(index) 需要从头或尾节点遍历 → O(n)</li></ul></li><li><p><strong>什么时候用 ArrayList？什么时候用 LinkedList？</strong></p><ul><li><strong>ArrayList</strong>：随机访问频繁、插入删除少</li><li><strong>LinkedList</strong>：插入删除频繁、随机访问少</li></ul></li></ol><hr><h3 id="二、HashMap-HashSet-LinkedHashMap"><a href="#二、HashMap-HashSet-LinkedHashMap" class="headerlink" title="二、HashMap &#x2F; HashSet &#x2F; LinkedHashMap"></a><strong>二、HashMap &#x2F; HashSet &#x2F; LinkedHashMap</strong></h3><ol><li><p><strong>HashMap 与 HashTable 的区别？</strong></p><table><thead><tr><th>特性</th><th>HashMap</th><th>Hashtable</th></tr></thead><tbody><tr><td>线程安全</td><td>否</td><td>是（方法 synchronized）</td></tr><tr><td>null key&#x2F;value</td><td>1 个 null key，多 null value</td><td>不允许</td></tr><tr><td>性能</td><td>高</td><td>低</td></tr><tr><td>遍历方式</td><td>Iterator</td><td>Enumeration</td></tr><tr><td>引入版本</td><td>JDK 1.2</td><td>JDK 1.0</td></tr></tbody></table></li><li><p><strong>HashMap 与 ConcurrentHashMap 的区别？</strong></p><ul><li><strong>HashMap</strong>：非线程安全，允许 null key&#x2F;value</li><li><strong>ConcurrentHashMap</strong>：线程安全，不允许 null，JDK8 使用 CAS + synchronized 桶锁，弱一致性迭代器</li></ul></li><li><p><strong>HashSet 如何保证元素不重复？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>元素作为 HashMap key → key 不重复 → 元素不重复</li></ul></li><li><p><strong>LinkedHashMap 的实现原理？</strong></p><ul><li>基于 HashMap + 双向链表</li><li>保证插入顺序或访问顺序（accessOrder）</li></ul></li><li><p><strong>HashMap 扩容机制？</strong></p><ul><li>初始容量：16</li><li>负载因子：0.75</li><li>扩容触发：<code>size &gt;= capacity * loadFactor</code></li><li>扩容方式：容量 2 倍 → 重新哈希</li></ul></li></ol><hr><h3 id="三、ConcurrentHashMap"><a href="#三、ConcurrentHashMap" class="headerlink" title="三、ConcurrentHashMap"></a><strong>三、ConcurrentHashMap</strong></h3><ol><li><p><strong>JDK7 vs JDK8 实现区别？</strong></p><table><thead><tr><th>特性</th><th>JDK7</th><th>JDK8</th></tr></thead><tbody><tr><td>数据结构</td><td>Segment[] + HashEntry[] + 链表</td><td>Node[] + 链表 + 红黑树</td></tr><tr><td>并发控制</td><td>Segment 级别锁</td><td>CAS + synchronized（桶级别锁）</td></tr><tr><td>扩容</td><td>Segment 扩容</td><td>table 扩容，多线程协助</td></tr><tr><td>哈希定位</td><td>两次 hash（先 Segment，再链表）</td><td>一次 hash（直接定位桶）</td></tr></tbody></table></li><li><p><strong>特点</strong></p><ul><li>线程安全，高并发下性能高</li><li>弱一致性迭代器，不抛 ConcurrentModificationException</li><li>不允许 null key&#x2F;value</li></ul></li></ol><hr><h3 id="四、Iterator-ListIterator-Enumeration"><a href="#四、Iterator-ListIterator-Enumeration" class="headerlink" title="四、Iterator &#x2F; ListIterator &#x2F; Enumeration"></a><strong>四、Iterator &#x2F; ListIterator &#x2F; Enumeration</strong></h3><ol><li><p><strong>Iterator 与 ListIterator 的区别</strong></p><table><thead><tr><th>特性</th><th>Iterator</th><th>ListIterator</th></tr></thead><tbody><tr><td>支持集合类型</td><td>Set&#x2F;List</td><td>List</td></tr><tr><td>遍历方向</td><td>前向</td><td>前向 + 后向</td></tr><tr><td>额外功能</td><td>remove()</td><td>add(), set(), 前后索引获取</td></tr></tbody></table></li><li><p><strong>Iterator 与 Enumeration 的区别</strong></p><ul><li>Iterator 方法名更规范</li><li>Iterator 支持 fail-fast（安全）</li><li>Iterator 可以删除元素，Enumeration 不行</li></ul></li><li><p><strong>Fail-Fast vs Fail-Safe</strong></p><table><thead><tr><th>特性</th><th>Fail-Fast</th><th>Fail-Safe</th></tr></thead><tbody><tr><td>迭代器类型</td><td>java.util 集合</td><td>java.util.concurrent 集合</td></tr><tr><td>并发修改行为</td><td>抛 ConcurrentModificationException</td><td>不抛异常</td></tr><tr><td>工作方式</td><td>原集合上迭代</td><td>副本或特殊结构上迭代</td></tr><tr><td>线程安全</td><td>否</td><td>是</td></tr><tr><td>内存开销</td><td>低</td><td>高</td></tr><tr><td>示例集合</td><td>ArrayList, HashMap, HashSet</td><td>CopyOnWriteArrayList, ConcurrentHashMap</td></tr></tbody></table></li></ol><hr><h3 id="五、Collection-与-Collections"><a href="#五、Collection-与-Collections" class="headerlink" title="五、Collection 与 Collections"></a><strong>五、Collection 与 Collections</strong></h3><ol><li><strong>Collection</strong><ul><li>接口，表示一组元素</li><li>List &#x2F; Set &#x2F; Queue 的父接口</li></ul></li><li><strong>Collections</strong><ul><li>工具类，提供排序、搜索、线程安全包装等静态方法</li><li>不能实例化</li></ul></li></ol><hr><h3 id="六、常见面试题总结"><a href="#六、常见面试题总结" class="headerlink" title="六、常见面试题总结"></a><strong>六、常见面试题总结</strong></h3><ol><li>ArrayList 和 LinkedList 的底层结构与区别</li><li>ArrayList 扩容机制及时间复杂度分析</li><li>HashMap 扩容机制、负载因子、hash 冲突处理</li><li>HashMap 与 Hashtable &#x2F; ConcurrentHashMap 的区别</li><li>HashSet 如何保证元素不重复</li><li>LinkedHashMap 的访问顺序与实现原理</li><li>ConcurrentHashMap JDK7 与 JDK8 的实现原理</li><li>Iterator &#x2F; ListIterator &#x2F; Enumeration 的区别</li><li>Fail-Fast 与 Fail-Safe 的区别及实现原理</li><li>Collection 与 Collections 的区别</li><li>HashMap 的 get() 能否判断 key 是否存在？（答：不能，用 containsKey()）</li></ol><p>对的，这道题经常出现在面试中，需要注意 <strong>细节</strong>：</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h3><p><strong>HashMap 的 <code>get(key)</code> 能否判断某个 key 是否存在？</strong></p><hr><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h4><ul><li><code>HashMap</code> 中允许：<ul><li><strong>key 为 null</strong>（最多 1 个）</li><li><strong>value 为 null</strong>（可以多个）</li></ul></li><li><code>get(key)</code> 返回：<ul><li>对应 key 的 value</li><li>如果 key 不存在 → 返回 null</li><li>如果 key 存在，但 value 为 null → 也返回 null</li></ul></li></ul><p><strong>结论</strong>：</p><ul><li>仅通过 <code>get(key)</code> 返回值 <strong>不能准确判断 key 是否存在</strong></li><li>因为 <code>null</code> 既可能表示“key 不存在”，也可能表示“key 存在但 value 为 null”</li></ul><hr><h4 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a><strong>正确做法</strong></h4><p>使用 <strong><code>containsKey(key)</code></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(map.get(<span class="string">&quot;a&quot;</span>));        <span class="comment">// 输出 null</span></span><br><span class="line">System.out.println(map.containsKey(<span class="string">&quot;a&quot;</span>)); <span class="comment">// 输出 true</span></span><br><span class="line">System.out.println(map.containsKey(<span class="string">&quot;b&quot;</span>)); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure><ul><li><code>containsKey(key)</code>：<ul><li>返回 <code>true</code> → key 存在</li><li>返回 <code>false</code> → key 不存在</li></ul></li></ul><hr><p>✅ <strong>面试提醒</strong></p><ul><li>面试官问 “HashMap 的 get 能否判断 key 是否存在？”<ul><li>答案：不能，get 可能返回 null</li><li>推荐使用 <code>containsKey()</code> 判断</li></ul></li></ul><h2 id="🧩-一、并发工具类（协作类）"><a href="#🧩-一、并发工具类（协作类）" class="headerlink" title="🧩 一、并发工具类（协作类）"></a>🧩 一、并发工具类（协作类）</h2><hr><h3 id="1-CountDownLatch（倒计时器）"><a href="#1-CountDownLatch（倒计时器）" class="headerlink" title="1. CountDownLatch（倒计时器）"></a>1. CountDownLatch（倒计时器）</h3><h3 id="📝-定义"><a href="#📝-定义" class="headerlink" title="📝 定义"></a>📝 定义</h3><ul><li>一个或多个线程等待 <strong>其他线程完成操作</strong> 后再继续。</li><li>内部维护一个 <code>state</code>（计数），初始值设定好，每调用一次 <code>countDown()</code>，<code>state--</code>。</li><li>当 <code>state=0</code> 时，<code>await()</code> 的线程全部唤醒。</li></ul><h3 id="⚙️-底层实现"><a href="#⚙️-底层实现" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul><li>基于 <strong>AQS（AbstractQueuedSynchronizer）</strong> 的共享锁实现。</li><li><code>await()</code> 会阻塞线程，直到 <code>state==0</code>；</li><li><code>countDown()</code> 是非阻塞的，只是原子性地减 1。</li></ul><h3 id="📌-使用场景"><a href="#📌-使用场景" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul><li>主线程等待多个子线程完成（<strong>一等多</strong>）。</li><li>例如：并行加载多个配置文件，等都加载完再合并处理。</li></ul><h3 id="🎯-面试考点"><a href="#🎯-面试考点" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul><li><strong>能否重用？</strong> → <strong>不能</strong>，计数归零后不能重置。</li><li>和 <code>CyclicBarrier</code> 的区别？→ <code>CountDownLatch</code> 是「一等多」，<code>CyclicBarrier</code> 是「多等多」。</li></ul><hr><h3 id="2-CyclicBarrier（循环屏障）"><a href="#2-CyclicBarrier（循环屏障）" class="headerlink" title="2. CyclicBarrier（循环屏障）"></a>2. CyclicBarrier（循环屏障）</h3><h3 id="📝-定义-1"><a href="#📝-定义-1" class="headerlink" title="📝 定义"></a>📝 定义</h3><ul><li>一组线程互相等待，直到所有线程都到达屏障点，再统一出发。</li><li>支持 <strong>循环使用</strong>（计数归零后可重置）。</li></ul><h3 id="⚙️-底层实现-1"><a href="#⚙️-底层实现-1" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul><li>基于 <strong>ReentrantLock + Condition</strong>。</li><li>每个线程调用 <code>await()</code> → 计数 -1 → 当计数 &#x3D; 0 → 唤醒所有线程。</li><li>还可以指定一个 <strong>barrierAction</strong>（所有线程到达后执行的回调）。</li></ul><h3 id="📌-使用场景-1"><a href="#📌-使用场景-1" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul><li>多线程分阶段计算，再统一合并结果。</li><li>例如：并行计算矩阵的每一行，所有线程到齐后汇总。</li></ul><h3 id="🎯-面试考点-1"><a href="#🎯-面试考点-1" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul><li>与 <code>CountDownLatch</code> 的区别？→ 可循环，且是「多等多」。</li><li><code>BrokenBarrierException</code> 什么时候抛？→ 线程中断或超时导致 barrier 破坏。</li></ul><hr><h3 id="3-Semaphore（信号量）"><a href="#3-Semaphore（信号量）" class="headerlink" title="3. Semaphore（信号量）"></a>3. Semaphore（信号量）</h3><h3 id="📝-定义-2"><a href="#📝-定义-2" class="headerlink" title="📝 定义"></a>📝 定义</h3><ul><li>控制同时访问某资源的线程数，像 <strong>限流器&#x2F;许可证</strong>。</li></ul><h3 id="⚙️-底层实现-2"><a href="#⚙️-底层实现-2" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul><li>基于 <strong>AQS</strong> 的共享锁实现。</li><li>内部维护一个 <code>permits</code>（许可证数）。</li><li><code>acquire()</code> 获取许可证（permits–，不足则阻塞）；</li><li><code>release()</code> 归还许可证（permits++）。</li></ul><h3 id="📌-使用场景-2"><a href="#📌-使用场景-2" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul><li>控制并发数：数据库连接池、接口限流。</li><li>例子：停车场有 3 个车位 → 最多只能停 3 辆车。</li></ul><h3 id="🎯-面试考点-2"><a href="#🎯-面试考点-2" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul><li>公平模式 vs 非公平模式？<ul><li>公平：FIFO 获取许可证。</li><li>非公平：可能插队，吞吐量更高。</li></ul></li><li>和 <code>Lock</code> 的区别？→ <code>Semaphore</code> 控制的是 <strong>并发数量</strong>，而 <code>Lock</code> 是 <strong>互斥（只能 1 个线程）</strong>。</li></ul><hr><h3 id="4-Exchanger（交换器）"><a href="#4-Exchanger（交换器）" class="headerlink" title="4. Exchanger（交换器）"></a>4. Exchanger（交换器）</h3><h3 id="📝-定义-3"><a href="#📝-定义-3" class="headerlink" title="📝 定义"></a>📝 定义</h3><ul><li>让 <strong>两个线程</strong> 在同步点交换数据。</li></ul><h3 id="⚙️-底层实现-3"><a href="#⚙️-底层实现-3" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul><li>基于 <strong>自旋 + CAS</strong>。</li><li>一个线程调用 <code>exchange()</code> 会等待，直到另一个线程也调用 <code>exchange()</code>，然后两者交换数据。</li></ul><h3 id="📌-使用场景-3"><a href="#📌-使用场景-3" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul><li>双线程协作：生产者和消费者之间成对交换数据块。</li><li>比如：一个线程生成数据，另一个线程写入磁盘。</li></ul><h3 id="🎯-面试考点-3"><a href="#🎯-面试考点-3" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul><li>如果只有一个线程调用 <code>exchange()</code> 会怎样？→ 会阻塞，直到另一方到来。</li><li>与队列（BlockingQueue）的区别？→ <code>Exchanger</code> 是 <strong>一对一交换</strong>，而队列可以一对多。</li></ul><hr><h2 id="🧩-二、原子类（Atomic-系列）"><a href="#🧩-二、原子类（Atomic-系列）" class="headerlink" title="🧩 二、原子类（Atomic 系列）"></a>🧩 二、原子类（Atomic 系列）</h2><p>这些类在 <code>java.util.concurrent.atomic</code> 包下，提供了 <strong>无锁化的线程安全操作</strong>。</p><hr><h3 id="1-基础原子类"><a href="#1-基础原子类" class="headerlink" title="1. 基础原子类"></a>1. 基础原子类</h3><h3 id="AtomicInteger-AtomicLong-AtomicBoolean"><a href="#AtomicInteger-AtomicLong-AtomicBoolean" class="headerlink" title="AtomicInteger &#x2F; AtomicLong &#x2F; AtomicBoolean"></a>AtomicInteger &#x2F; AtomicLong &#x2F; AtomicBoolean</h3><ul><li>作用：对单个 <code>int</code>&#x2F;<code>long</code>&#x2F;<code>boolean</code> 变量的原子操作。</li><li>典型方法：<ul><li><code>getAndIncrement()</code> → 自增（原子性 i++）。</li><li><code>compareAndSet(expect, update)</code> → CAS 更新。</li></ul></li></ul><h3 id="⚙️-底层实现-4"><a href="#⚙️-底层实现-4" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul><li>基于 <strong>CAS（Compare-And-Swap） + volatile</strong>。</li><li>内部调用 <strong>Unsafe 类</strong> 的 <code>compareAndSwapInt</code> 等方法。</li></ul><h3 id="📌-使用场景-4"><a href="#📌-使用场景-4" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul><li>高并发计数器：网站访问量统计、ID 生成器。</li></ul><h3 id="🎯-面试考点-4"><a href="#🎯-面试考点-4" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul><li>CAS 的缺点？<ol><li>ABA 问题（可用 <code>AtomicStampedReference</code> 解决）。</li><li>自旋开销大。</li><li>只能保证单变量原子性，不能保证复合操作。</li></ol></li></ul><hr><h3 id="2-数组原子类"><a href="#2-数组原子类" class="headerlink" title="2. 数组原子类"></a>2. 数组原子类</h3><h3 id="AtomicIntegerArray-AtomicLongArray-AtomicReferenceArray"><a href="#AtomicIntegerArray-AtomicLongArray-AtomicReferenceArray" class="headerlink" title="AtomicIntegerArray &#x2F; AtomicLongArray &#x2F; AtomicReferenceArray"></a>AtomicIntegerArray &#x2F; AtomicLongArray &#x2F; AtomicReferenceArray</h3><ul><li>保证数组中的每个元素的原子操作。</li><li>例如：统计分片数据时，避免锁整个数组。</li></ul><hr><h3 id="3-引用原子类"><a href="#3-引用原子类" class="headerlink" title="3. 引用原子类"></a>3. 引用原子类</h3><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><ul><li>保证对象引用的原子更新。</li></ul><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><ul><li>解决 <strong>ABA 问题</strong>，给引用加一个版本号（stamp）。</li></ul><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><ul><li>给引用加一个 <strong>boolean 标记</strong>。</li></ul><hr><h3 id="4-累加器类"><a href="#4-累加器类" class="headerlink" title="4. 累加器类"></a>4. 累加器类</h3><h3 id="LongAdder-DoubleAdder"><a href="#LongAdder-DoubleAdder" class="headerlink" title="LongAdder &#x2F; DoubleAdder"></a>LongAdder &#x2F; DoubleAdder</h3><ul><li>对 <code>AtomicLong</code> 的优化：高并发下热点分离。</li><li>内部维护一个 <strong>base 值 + 分片 cell 数组</strong>。</li><li>多线程写时分散到不同的 cell，最后求和。</li></ul><h3 id="📌-使用场景-5"><a href="#📌-使用场景-5" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul><li>高并发计数，如 QPS 统计、热点计数。</li></ul><h3 id="🎯-面试考点-5"><a href="#🎯-面试考点-5" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul><li>为什么 <code>LongAdder</code> 比 <code>AtomicLong</code> 性能好？<ul><li>AtomicLong 所有线程 CAS 同一个值，形成热点；</li><li>LongAdder 分散冲突到多个 cell，降低竞争。</li></ul></li></ul><hr><h2 id="🧠-三、工具类-原子类对比总结"><a href="#🧠-三、工具类-原子类对比总结" class="headerlink" title="🧠 三、工具类 &amp; 原子类对比总结"></a>🧠 三、工具类 &amp; 原子类对比总结</h2><table><thead><tr><th>工具类 &#x2F; 原子类</th><th>功能</th><th>实现原理</th><th>典型场景</th></tr></thead><tbody><tr><td>CountDownLatch</td><td>一等多</td><td>AQS 共享锁</td><td>主线程等子线程完成</td></tr><tr><td>CyclicBarrier</td><td>多等多，可循环</td><td>ReentrantLock + Condition</td><td>分阶段同步，多线程汇总计算</td></tr><tr><td>Semaphore</td><td>控制并发数（许可证）</td><td>AQS 共享锁</td><td>限流、连接池、资源池</td></tr><tr><td>Exchanger</td><td>两线程数据交换</td><td>CAS + 自旋</td><td>双线程协作，数据块交换</td></tr><tr><td>AtomicInteger&#x2F;Long</td><td>单变量原子操作</td><td>CAS + volatile</td><td>高并发计数器，ID 生成</td></tr><tr><td>AtomicReference</td><td>原子更新引用</td><td>CAS</td><td>无锁更新对象引用</td></tr><tr><td>AtomicStampedReference</td><td>带版本号引用，防止 ABA</td><td>CAS</td><td>解决 ABA 问题</td></tr><tr><td>LongAdder&#x2F;DoubleAdder</td><td>高并发累加优化</td><td>分片 + CAS</td><td>高并发计数，性能优于 AtomicLong</td></tr></tbody></table><hr><h2 id="🎯-四、面试答题模板（可套用）"><a href="#🎯-四、面试答题模板（可套用）" class="headerlink" title="🎯 四、面试答题模板（可套用）"></a>🎯 四、面试答题模板（可套用）</h2><ol><li><strong>总体分类</strong><ul><li>JUC 里提供了 <strong>协作类工具（CountDownLatch、CyclicBarrier、Semaphore、Exchanger）</strong> 和 <strong>原子类（AtomicInteger、LongAdder 等）</strong>。</li></ul></li><li><strong>逐个解释</strong><ul><li><code>CountDownLatch</code>：一等多，主线程等子线程。</li><li><code>CyclicBarrier</code>：多等多，可循环。</li><li><code>Semaphore</code>：控制并发数，限流。</li><li><code>Exchanger</code>：两线程交换数据。</li><li><code>AtomicInteger/Long</code>：单变量原子操作，基于 CAS。</li><li><code>LongAdder</code>：高并发下比 AtomicLong 更高效。</li></ul></li><li><strong>原理补充</strong><ul><li>工具类大多基于 <strong>AQS</strong> 实现；</li><li>原子类基于 <strong>CAS + volatile</strong>；</li><li>LongAdder 用 <strong>分段累加</strong> 优化热点。</li></ul></li><li><strong>总结</strong><br> 👉 <strong>工具类解决线程协作，原子类解决无锁更新，都是 JUC 的核心。</strong></li></ol><h2 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO 流"></a>Java IO 流</h2><p>Java IO (Input&#x2F;Output) 流是用于处理计算机与外部设备之间数据传输的抽象概念。它将数据抽象为流 (Stream)，通过流可以实现数据的输入和输出。</p><h3 id="IO-流的分类"><a href="#IO-流的分类" class="headerlink" title="IO 流的分类"></a>IO 流的分类</h3><p>Java IO 流根据不同的标准有多种分类方式：</p><ul><li>按数据类型分：<ul><li>字节流：处理字节数据，所有文件类型（文本、图片、音视频等）都可以用字节流处理。<ul><li>抽象基类：InputStream（输入流）、OutputStream（输出流）。</li><li>常用实现：FileInputStream&#x2F;FileOutputStream（文件操作），BufferedInputStream&#x2F;BufferedOutputStream（带缓冲），ObjectInputStream&#x2F;ObjectOutputStream（对象序列化），ByteArrayInputStream&#x2F;ByteArrayOutputStream（内存操作），DataInputStream&#x2F;DataOutputStream（基本数据类型操作）。</li></ul></li><li>字符流：处理字符数据，专门用于处理文本文件。<ul><li>抽象基类：Reader（输入流）、Writer（输出流）。</li><li>常用实现：FileReader&#x2F;FileWriter（文件操作），BufferedReader&#x2F;BufferedWriter（带缓冲），InputStreamReader&#x2F;OutputStreamWriter（字节流与字符流的转换）。</li></ul></li></ul></li><li>按流向分：<ul><li>输入流：从数据源读取数据到程序中。</li><li>输出流：从程序中写入数据到目的地。</li></ul></li><li>按功能分：<ul><li>节点流（或源头流）：直接与数据源（如文件、内存、网络连接）连接的流。例如FileInputStream、FileReader。</li><li>处理流（或包装流）：对已存在的节点流进行包装，增加新的功能或提升性能。例如BufferedInputStream、BufferedReader。</li></ul></li></ul><h3 id="常用-IO-操作"><a href="#常用-IO-操作" class="headerlink" title="常用 IO 操作"></a>常用 IO 操作</h3><ul><li><p>文件读写（字节流）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    fos.write(<span class="string">&quot;Hello, World!&quot;</span>.getBytes());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">while</span> ((data = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件读写（字符流）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output_char.txt&quot;</span>)) &#123;</span><br><span class="line">    fw.write(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;output_char.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">while</span> ((data = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>缓冲流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用缓冲字节流复制文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.txt&quot;</span>));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;destination.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个可序列化的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 序列化版本UID</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">transient</span> String password; <span class="comment">// transient 关键字修饰的字段不参与序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User(name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, password=&quot;</span> + password + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    oos.writeObject(user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;user.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">deserializedUser</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">    System.out.println(deserializedUser); <span class="comment">// password 字段将为 null</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="NIO-New-Input-Output"><a href="#NIO-New-Input-Output" class="headerlink" title="NIO (New Input&#x2F;Output)"></a>NIO (New Input&#x2F;Output)</h3><p>Java NIO (New I&#x2F;O) 是在 JDK 1.4 中引入的一套新的 I&#x2F;O API，它提供了非阻塞 I&#x2F;O 的能力，并引入了“通道 (Channel)”和“缓冲区 (Buffer)”的概念，与传统的基于流 (Stream) 的 I&#x2F;O 相比，NIO 更加高效。</p><p><strong>核心组件：</strong></p><ul><li>Channel (通道): 类似于传统 IO 中的流，但可以双向读写。数据总是通过通道读入缓冲区或从缓冲区写入通道。<ul><li>常用实现: FileChannel (文件), SocketChannel (TCP 客户端), ServerSocketChannel (TCP 服务器), DatagramChannel (UDP)。</li></ul></li><li>Buffer (缓冲区): 用于存储数据 (字节数组)，与通道进行交互。所有数据读写都是通过缓冲区完成的。缓冲区有多种类型，如 ByteBuffer、CharBuffer、IntBuffer 等。<ul><li>核心属性：<ul><li>capacity: 缓冲区可容纳的最大数据量。一旦创建，容量不可变。</li><li>limit: 缓冲区中可读或可写的上限。</li><li>position: 下一个读或写的位置。</li><li>mark: 标记当前 position，可以通过 reset() 恢复到 mark 的位置。</li></ul></li><li>主要方法：<ul><li>put(): 向缓冲区写入数据。</li><li>get(): 从缓冲区读取数据。</li><li>flip(): 将缓冲区从写模式切换到读模式。limit 会设置为当前的 position, position 会重置为 0。</li><li>clear(): 清空缓冲区，为新的写入做准备。position 设为 0, limit 设为 capacity。</li><li>compact(): 压缩缓冲区，将未读的数据移到缓冲区开头，position 设为未读数据数量，limit 设为 capacity。</li><li>rewind(): 将 position 设为 0，可以重复读取缓冲区中的数据。</li></ul></li></ul></li><li>Selector (选择器): 用于监听多个通道上的事件 (如连接就绪、读就绪、写就绪等)。一个单线程可以管理多个通道，从而实现非阻塞 I&#x2F;O。</li></ul><p><strong>NIO 与传统 IO 的区别：</strong></p><ul><li>I&#x2F;O 模式:传统 IO 是阻塞式 I&#x2F;O, NIO 是非阻塞式 I&#x2F;O。</li><li>流与缓冲区:传统 IO 基于流(单向), NIO 基于通道和缓冲区(双向)。</li><li>同步与异步:传统 IO 是同步阻塞的, NIO 是同步非阻塞的(在多路复用模型下)。</li></ul><p><strong>NIO 文件复制示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">     <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;destination_nio.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> fos.getChannel()) &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (inChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buffer.flip(); <span class="comment">// 切换到读模式</span></span><br><span class="line">        outChannel.write(buffer); <span class="comment">// 从缓冲区写入通道</span></span><br><span class="line">        buffer.clear(); <span class="comment">// 清空缓冲区, 为下次写入做准备</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AIO-Asynchronous-Input-Output"><a href="#AIO-Asynchronous-Input-Output" class="headerlink" title="AIO (Asynchronous Input&#x2F;Output)"></a>AIO (Asynchronous Input&#x2F;Output)</h3><p>Java AIO (Asynchronous I&#x2F;O) 是在 JDK 7 中引入的，也称为 NIO 2.0。它提供了真正的异步非阻塞 I&#x2F;O，通过回调机制来处理 I&#x2F;O 操作的结果。与 NIO 的同步非阻塞不同，AIO 在 I&#x2F;O 操作完成后会主动通知应用程序。</p><ul><li><p><strong>核心概念:</strong></p><ul><li>AsynchronousFileChannel:异步文件通道。</li><li>AsynchronousSocketChannel:异步 Socket 通道。</li><li>AsynchronousServerSocketChannel:异步 Server Socket 通道。</li><li>CompletionHandler:回调处理器接口，定义了 completed() (操作成功) 和 failed() (操作失败) 方法。</li><li>Future:也可以通过返回 Future 对象来获取异步操作的结果。</li></ul></li><li><p>**工作原理:**当发起一个 I&#x2F;O 操作时，不再需要等待操作完成，而是立即返回。I&#x2F;O 操作由操作系统在后台完成，完成后通过回调函数通知应用程序。</p></li><li><p><strong>AIO 优势:</strong></p><ul><li>真正的异步非阻塞:应用程序不需要等待 I&#x2F;O 操作，可以将 CPU 资源用于其他任务。</li><li>提高并发性:特别适合高并发、长连接的网络应用。</li></ul></li><li><p><strong>AIO 劣势:</strong></p><ul><li>复杂性:编程模型相对于 NIO 更复杂，需要处理回调逻辑。</li><li>适用场景:对于连接数较多且连接时间长的应用，如聊天服务器，AIO 表现优异。对于短连接、高并发的场景，NIO（基于 Selector）可能表现更好。</li></ul></li><li><p><strong>AIO 读文件示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">file</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;async_read.txt&quot;</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(file, StandardOpenOption.READ)) &#123;</span><br><span class="line">    fileChannel.read(buffer, <span class="number">0</span>, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Read &quot;</span> + result + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">            attachment.flip();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[attachment.remaining()];</span><br><span class="line">            attachment.get(data);</span><br><span class="line">            System.out.println(<span class="string">&quot;Content: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Read failed: &quot;</span> + exc.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 为了让主线程不立即退出，等待异步操作完成</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-Java-IO-流的分类？请说出几个你熟悉的实现类。"><a href="#1-Java-IO-流的分类？请说出几个你熟悉的实现类。" class="headerlink" title="1. Java IO 流的分类？请说出几个你熟悉的实现类。"></a>1. Java IO 流的分类？请说出几个你熟悉的实现类。</h3><p>Java IO 流根据不同的标准可以进行分类：</p><ul><li><strong>按数据流向</strong>：<ul><li><strong>输入流（InputStream &#x2F; Reader）</strong>：从外部源（如文件、网络）读取数据到程序中。</li><li><strong>输出流（OutputStream &#x2F; Writer）</strong>：将数据从程序写入到外部目标。</li></ul></li><li><strong>按数据类型</strong>：<ul><li><strong>字节流（InputStream &#x2F; OutputStream）</strong>：以 8 位字节为单位处理数据，适用于所有类型的文件，包括图片、视频、音频等二进制文件。<ul><li><strong>实现类</strong>：<code>FileInputStream</code>, <code>FileOutputStream</code>, <code>BufferedInputStream</code>, <code>BufferedOutputStream</code>。</li></ul></li><li><strong>字符流（Reader &#x2F; Writer）</strong>：以 16 位字符为单位处理数据，适用于文本文件，能处理各种字符编码。<ul><li><strong>实现类</strong>：<code>FileReader</code>, <code>FileWriter</code>, <code>BufferedReader</code>, <code>BufferedWriter</code>。</li></ul></li></ul></li></ul><h3 id="2-字节流和字符流有什么区别？"><a href="#2-字节流和字符流有什么区别？" class="headerlink" title="2. 字节流和字符流有什么区别？"></a>2. 字节流和字符流有什么区别？</h3><p>字节流和字符流的主要区别在于处理数据的单位和适用场景：</p><ul><li><strong>数据单位</strong>：字节流以 8 位字节为单位进行读写，而字符流以 16 位字符为单位。</li><li><strong>编码转换</strong>：字符流是字节流的封装，它在内部处理了字节和字符之间的编码转换。当处理文本文件时，字符流可以根据指定的字符集（如 UTF-8）自动进行编码和解码，避免了乱码问题。字节流不进行编码转换，直接处理原始字节。</li><li><strong>最小存储单元</strong>：尽管字符流以字符为单位，但文件或网络传输的最小存储单元依然是字节。字符流在底层仍依赖于字节流来完成数据的传输。</li><li><strong>适用场景</strong>：<ul><li><strong>字节流</strong>：适用于所有文件类型，尤其是处理<strong>非文本文件</strong>（如图片、视频、音频等），因为这些文件不需要进行字符编码转换。</li><li><strong>字符流</strong>：专门用于处理<strong>文本文件</strong>，可以避免手动处理字符编码的复杂性。</li></ul></li></ul><h3 id="3-BIO、NIO-和-AIO-有什么区别？"><a href="#3-BIO、NIO-和-AIO-有什么区别？" class="headerlink" title="3. BIO、NIO 和 AIO 有什么区别？"></a>3. BIO、NIO 和 AIO 有什么区别？</h3><p>这是 Java IO 发展历程中的三种不同模型，主要区别在于处理 IO 操作的方式（阻塞&#x2F;非阻塞、同步&#x2F;异步）和并发能力。</p><ul><li><strong>BIO (Blocking I&#x2F;O)</strong><ul><li><strong>特点</strong>：<strong>同步阻塞</strong>。当一个线程发起 IO 操作（如 <code>read</code> 或 <code>accept</code>），它会一直阻塞，直到数据读写完成或连接建立。</li><li><strong>模型</strong>：采用“一对一”的连接模型，即一个客户端连接对应一个处理线程。</li><li><strong>优点</strong>：编程模型简单直观，适用于连接数较少、并发量不高的场景。</li><li><strong>缺点</strong>：在高并发场景下，每个连接都需要一个线程，会消耗大量系统资源，导致性能瓶颈。</li></ul></li><li><strong>NIO (Non-blocking I&#x2F;O)</strong><ul><li><strong>特点</strong>：<strong>同步非阻塞</strong>。一个线程可以同时处理多个连接。当线程发起 IO 操作时，如果数据没有准备好，它不会阻塞，而是立即返回，去做其他事情，稍后再次检查。</li><li><strong>模型</strong>：采用<strong>多路复用</strong>模型。通过一个 <code>Selector</code>（选择器），一个或少数几个线程可以监听多个 <code>Channel</code>（通道）上的 IO 事件（如连接就绪、数据可读），从而高效地处理大量并发连接。</li><li><strong>优点</strong>：解决了 BIO 的高并发问题，大大提高了系统的吞吐量，适用于高并发的网络应用。</li><li><strong>缺点</strong>：编程模型相对复杂。尽管 IO 操作是非阻塞的，但数据读写本身仍然是同步的，即线程在进行读写时仍需等待。</li></ul></li><li><strong>AIO (Asynchronous I&#x2F;O)</strong><ul><li><strong>特点</strong>：<strong>异步非阻塞</strong>。应用程序发起 IO 操作后，会立即返回，而不会等待数据读写。操作系统会在后台完成 IO 操作，并在完成后通过<strong>回调</strong>或事件通知应用程序。</li><li><strong>模型</strong>：基于<strong>事件和回调</strong>机制。</li><li><strong>优点</strong>：进一步提高了并发性能，彻底释放了线程资源，适用于连接数巨大且连接时间长的应用。</li><li><strong>缺点</strong>：目前在实际应用中，特别是在网络编程方面，使用不如 NIO 广泛，因为其复杂性和对操作系统的依赖性较高。</li></ul></li></ul><h2 id="Java-反射-Reflection"><a href="#Java-反射-Reflection" class="headerlink" title="Java 反射 (Reflection)"></a>Java 反射 (Reflection)</h2><p>Java 反射机制是指在程序运行时，能够动态地获取类的信息（包括类的属性、方法、构造器等），并能够动态地操作类或对象（如创建对象、调用方法、修改属性）。</p><ul><li><p><strong>核心类与接口：</strong></p><ul><li>Class 类：代表类的字节码文件，是反射的入口。</li><li>Constructor 类：代表类的构造器。</li><li>Method 类：代表类的方法。</li><li>Field 类：代表类的成员变量（属性）。</li><li>AccessibleObject：Field, Method, Constructor 的共同父类，提供了 setAccessible(true) 方法，用于抑制 Java 语言访问检查，从而访问私有成员。</li></ul></li><li><p><strong>获取 Class 对象的三种方式：</strong></p><ol><li><p>Class.forName(“全限定类名”)：最常用，动态加载类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>类名.class：已知具体类名时使用，编译时加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = String.class;</span><br></pre></td></tr></table></figure></li><li><p>对象.getClass()：通过对象实例获取，运行时获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Class&lt;?&gt; clazz = s.getClass();</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>反射的应用：</strong></p><ul><li><p>动态创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance(); <span class="comment">// 调用无参构造器</span></span><br><span class="line"><span class="comment">// 或者调用指定构造器</span></span><br><span class="line">Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person2</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure></li><li><p>动态调用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">setNameMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">setNameMethod.invoke(person, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// 调用 setName 方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getNameMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) getNameMethod.invoke(person); <span class="comment">// 调用 getName 方法</span></span><br></pre></td></tr></table></figure></li><li><p>动态操作属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance();</span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">// 获取私有属性</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>); <span class="comment">// 允许访问私有属性</span></span><br><span class="line">nameField.set(person, <span class="string">&quot;Charlie&quot;</span>); <span class="comment">// 设置属性值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) nameField.get(person); <span class="comment">// 获取属性值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>反射的优缺点：</strong></p><ul><li>优点：<ul><li>灵活性和动态性:在运行时动态获取类信息和操作对象,大大增强了程序的灵活性,是许多框架(如Spring、ORM框架)和工具(如JSON解析库)的基础。</li><li>解耦:允许代码在编译时不知道具体的类,只在运行时加载和使用,实现高度解耦。</li></ul></li><li>缺点:<ul><li>性能开销:反射操作比直接调用有更高的性能开销,因为涉及到动态解析和查找。</li><li>安全性问题:setAccessible(true)可以绕过Java的访问控制,可能破坏封装性。</li><li>可维护性差:反射代码通常比直接调用更复杂,更难调试和维护。</li><li>编译时检查缺失:反射操作在编译时无法检查类型错误,只能在运行时发现。</li></ul></li></ul></li></ul><h2 id="JVM内存结构与垃圾收集器"><a href="#JVM内存结构与垃圾收集器" class="headerlink" title="JVM内存结构与垃圾收集器"></a>JVM内存结构与垃圾收集器</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><h3 id="JVM-简单介绍"><a href="#JVM-简单介绍" class="headerlink" title="JVM 简单介绍"></a>JVM 简单介绍</h3><p>Java 虚拟机（JVM）是 Java 语言跨平台能力的核心。它是一个抽象的计算机，负责将 Java 字节码 (<code>.class</code> 文件) 转换成特定平台的机器指令。下面通过表格的形式，简单介绍 JVM 的主要组成部分、功能和工作流程。</p><hr><table><thead><tr><th>模块名称</th><th>核心功能</th><th>主要组成部分</th><th>简要说明</th></tr></thead><tbody><tr><td><strong>类加载子系统</strong></td><td>加载、链接、初始化 <code>.class</code> 文件</td><td>类加载器 (ClassLoader)</td><td>负责从文件系统、网络等来源加载 <code>.class</code> 文件到内存，并进行验证、准备和解析。</td></tr><tr><td><strong>运行时数据区</strong></td><td>存放程序运行时的各种数据</td><td><strong>方法区</strong><br><strong>堆</strong><br><strong>虚拟机栈</strong><br><strong>本地方法栈</strong><br><strong>程序计数器</strong></td><td>线程共享：<br>- <strong>方法区</strong>: 存储已加载的类信息、常量、静态变量等。<br>- <strong>堆</strong>: 存储所有对象实例和数组。<br><br>线程私有：<br>- <strong>虚拟机栈</strong>: 存储方法调用的局部变量、操作数栈等。<br>- <strong>本地方法栈</strong>: 存储 Native 方法的调用信息。<br>- <strong>程序计数器</strong>: 记录当前线程正在执行的字节码指令地址。</td></tr><tr><td><strong>执行引擎</strong></td><td>执行字节码指令</td><td><strong>解释器</strong><br><strong>即时编译器 (JIT)</strong><br><strong>垃圾收集器 (GC)</strong></td><td>负责将字节码翻译成机器指令并执行。<br>- <strong>解释器</strong>: 逐行解释执行字节码。<br>- <strong>JIT</strong>: 将热点代码编译成高效的本地机器码。<br>- <strong>GC</strong>: 自动回收堆中不再使用的对象内存。</td></tr><tr><td><strong>本地方法接口</strong></td><td>调用 Native 方法</td><td>JNI (Java Native Interface)</td><td>允许 Java 代码与其他语言（如 C&#x2F;C++）编写的代码进行交互。</td></tr><tr><td><strong>本地方法库</strong></td><td>支持 Native 方法</td><td>一系列本地方法库</td><td>提供了执行引擎调用本地方法所需的库文件。</td></tr></tbody></table><p>JVM(Java Virtual Machine)在执行Java程序时,会将内存划分为几个不同的区域,这些区域有各自的用途和生命周期。</p><ul><li><p><strong>程序计数器 (Program Counter Register)</strong></p><ul><li>功能:一块较小的内存空间,用于存储当前线程所执行的字节码的行号指示器。</li><li>特点:<ul><li>每个线程私有,生命周期与线程一致。</li><li>JVM规范中唯一没有规定任何OutOfMemoryError情况的区域。</li><li>在多线程切换时,程序计数器记录了当前线程的执行位置,使得线程切换回来后能够知道从哪里继续执行。</li></ul></li></ul></li><li><p><strong>Java虚拟机栈 (Java Virtual Machine Stacks)</strong></p><ul><li>功能:每个线程私有的内存区域,用于存储栈帧(Stack Frame)。每个方法被执行时都会创建一个栈帧,用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li><li>特点:<ul><li>生命周期与线程一致。</li><li>局部变量表:存储方法参数和方法内部定义的局部变量。</li><li>操作数栈:用于存放方法执行时的操作数和中间结果。</li><li>动态链接:指向运行时常量池中该栈帧所属方法的引用。</li><li>方法出口:记录方法执行完后回到哪里。</li><li>可能抛出StackOverflowError(栈深度超过虚拟机允许的深度)或OutOfMemoryError(栈扩展时无法申请到足够的内存)。</li></ul></li></ul></li><li><p><strong>本地方法栈 (Native Method Stacks)</strong></p><ul><li>功能:与虚拟机栈类似,但是为JVM执行Native方法(即用C&#x2F;C++等语言实现的方法)服务。</li><li>特点：<ul><li>每个线程私有。</li><li>可能抛出 StackOverflowError 或 OutOfMemoryError。</li></ul></li></ul></li><li><p><strong>Java 堆 (Java Heap)</strong></p><ul><li><p>功能:JVM 管理的最大一块内存区域，被所有线程共享，用于存放对象实例和数组。</p></li><li><p>特点：</p><ul><li><p>是垃圾收集器管理的主要区域 (GC 堆)。</p></li><li><p>是 Java 应用程序对象存放的“老家”。</p></li><li><p>根据垃圾回收的特性，可以分为新生代 (Young Generation) 和老年代 (Old Generation)。</p></li><li><p>新生代:通常分为 Eden 空间和两个 Survivor 空间 (From 和 To)。新创建的对象优先在 Eden 区分配，经过 Minor GC 后存活的对象进入 Survivor 区，多次 GC 后仍存活的对象进入老年代。</p></li><li><p>老年代:存放生命周期较长的对象。</p></li><li><p>在 JVM 内存模型中，新生代被划分为三个区域，默认的比例通常是 <strong>8:1:1</strong>。</p><ul><li><strong>Eden 区</strong>：占比 <strong>80%</strong>。这是新创建对象的主要分配区域。</li><li><strong>Survivor S0 区</strong>：占比 <strong>10%</strong>。</li><li><strong>Survivor S1 区</strong>：占比 <strong>10%</strong>。</li></ul><hr><h3 id="为什么要这样划分？"><a href="#为什么要这样划分？" class="headerlink" title="为什么要这样划分？"></a><strong>为什么要这样划分？</strong></h3><p>这种划分是为了配合 Minor GC 的垃圾回收流程，从而提高垃圾回收的效率。</p><h4 id="新生代的垃圾回收流程"><a href="#新生代的垃圾回收流程" class="headerlink" title="新生代的垃圾回收流程"></a><strong>新生代的垃圾回收流程</strong></h4><ol><li><strong>对象创建</strong>：新创建的对象首先在 <strong>Eden 区</strong> 分配。</li><li><strong>Minor GC</strong>：当 <strong>Eden 区</strong> 满了之后，会触发一次 Minor GC（也叫 Young GC）。</li><li><strong>存活对象转移</strong>：<ul><li>在 Eden 区和其中一个 Survivor 区（比如 S0）中，所有存活的对象会被复制到另一个空的 Survivor 区（比如 S1）。</li><li>同时，对象的年龄（age）会加一。</li></ul></li><li><strong>清空 Eden 和 S0</strong>：垃圾回收后，Eden 区和 S0 区都会被清空。</li><li><strong>角色互换</strong>：下一次 Minor GC 时，Eden 区和 S1 区中存活的对象会被复制到 S0 区。S0 和 S1 两个 Survivor 区会不断地进行角色互换。</li><li><strong>晋升老年代</strong>：<ul><li>当对象的年龄达到一个设定的阈值（默认为 15），或者 Survivor 区中同一年龄段的对象大小超过了一定比例，这些对象就会被移动到<strong>老年代</strong>。</li><li>这种设计也被称为<strong>复制算法（Copying Algorithm）</strong>，它在新生代存活对象较少的情况下，效率非常高。</li></ul></li></ol><hr><h3 id="为什么是-8-1-1？"><a href="#为什么是-8-1-1？" class="headerlink" title="为什么是 8:1:1？"></a><strong>为什么是 8:1:1？</strong></h3><p>这个比例是一个经验值，基于大多数 Java 应用的特点：</p><ul><li><strong>大多数对象都是朝生夕灭的</strong>。因此，将 Eden 区设置得更大，可以容纳更多的新对象，减少 Minor GC 的频率。</li><li>两个 Survivor 区只需要用来暂存存活的对象，因此不需要太大。10% 的空间通常足以容纳一次 Minor GC 后存活的对象。</li></ul><p>当然，这个比例不是固定的。在某些特殊情况下，如果新生代存活对象较多，导致 Survivor 区无法容纳所有存活对象，JVM 会发生<strong>空间分配担保</strong>，将这些对象直接晋升到老年代。</p><p>你可以通过 JVM 参数来调整这个比例，例如： <code>java -Xmn100m -XX:SurvivorRatio=8</code></p><p>这个命令设置新生代总大小为 100MB，Eden 区和 Survivor 区的比例为 8:1:1。</p></li><li><p>可能抛出 OutOfMemoryError。</p></li></ul></li></ul></li><li><p><strong>方法区 (Method Area)</strong></p><ul><li>功能:被所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>特点：<ul><li>在 JDK 1.7 及之前，方法区被称为“永久代 (Permanent Generation)”，它属于堆内存的一部分。</li><li>在 JDK 1.8 及之后，永久代被移除，方法区的实现改为“元空间 (Metaspace)”，并且元空间不使用 JVM 内存，而是直接使用本地内存 (Native Memory)。</li><li>可能抛出 OutOfMemoryError。</li></ul></li></ul></li><li><p><strong>运行时常量池 (Runtime Constant Pool)</strong></p><ul><li>功能:方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</li><li>特点：<ul><li>动态性:Java 语言并不要求常量池在编译期就全部确定，运行时也可以将新的常量放入池中 (如 String.intern())。</li><li>可能抛出 OutOfMemoryError。</li></ul></li></ul></li></ul><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>程序计数器（Program Counter Register）：是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。程序的分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的命令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储，我们程这块内存区域为“线程私有”的内存。</p><p>此区域是唯一一个虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><hr><h3 id="2-Java-虚拟机栈"><a href="#2-Java-虚拟机栈" class="headerlink" title="2. Java 虚拟机栈"></a>2. Java 虚拟机栈</h3><p>Java 虚拟机栈（Java Virtual Machine Stacks）：描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个帧栈（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。它的线程也是私有的，生命周期与线程相同。</p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和 returnAddress 类型（指向了一条字节码指令的地址）。</p><p>Java 虚拟机栈的局部变量表的空间单位是槽（Slot），其中 64 位长度的 double 和 long 类型会占用两个 Slot。局部变量表所需内存空间在编译期完成分配，当进入一个方法时，该方法需要在帧中分配多大的局部变量是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>Java虚拟机栈有两种异常状况：如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出 <code>StackOverflowError</code> 异常；如果扩展时无法申请到足够的内存，就会抛出 <code>OutOfMemoryError</code> 异常。</p><hr><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>本地方法栈（Native Method Stack）：与虚拟机栈所发的作用是非常相似的，它们之间的区别只不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p><p>Java 虚拟机规范没有对本地方法栈中方法使用的语言、使用的方式和数据结构做出强制规定，因此具体的虚拟机可以自由地实现它。比如：Sun HotSpot 虚拟机直接把Java虚拟机栈和本地方法栈合二为一。</p><p>与Java虚拟机栈一样，本地方法栈也会抛出<code>StackOverflowError</code>和 <code>OutOfMemoryError</code> 异常。</p><hr><h3 id="4-Java-堆"><a href="#4-Java-堆" class="headerlink" title="4. Java 堆"></a>4. Java 堆</h3><p>Java堆（Java Heap）：是被所有线程所共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是：存放对象实例，几乎所有的对象实例都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC”堆（Garbage Collected Heap）。从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代。从内存分配角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）。不过无论如何划分，都与存放的内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p><p>Java 虚拟机规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，可以是固定大小的，也可以是可扩展的。如果在堆中没有完成实例分配。并且堆也无法扩展时，将会抛出 <code>OutOfMemoryError</code> 异常。</p><hr><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>方法区（Method Area）：与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），其目的应该就是与 Java 堆区分开来。</p><p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</p><p>根据Java虚拟机规范规定，当方法区无法满足内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p><p><strong>运行时常量池</strong>：运行时常量池（Runtime Constant Pool）：是方法区的一部分。<code>Class</code> 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一些信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>Java 虚拟机对 Class 文件每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行。</p><p><strong>直接内存</strong>：直接内存（Direct Memory）：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也频繁地使用，而且也可能导致 <code>OutOfMemoryError</code> 异常。</p><p>本地直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存大小以及处理器寻址空间的限制。如果各个内存区域总和大于物理内存限制，从而导致动态扩展时出现 <code>OutOfMemoryError</code> 异常。</p><hr><h3 id="3-堆和栈的区别是什么？"><a href="#3-堆和栈的区别是什么？" class="headerlink" title="3. 堆和栈的区别是什么？"></a>3. 堆和栈的区别是什么？</h3><p>堆和栈（虚拟机栈）是完全不同的两块内存区域，一个是线程独享的，一个是线程共享的。二者之间最大的区别就是存储的内容不同：堆中主要存放对象实例。栈（局部变量表）中主要存放各种基本数据类型、对象的引用。</p><p>从作用来说，栈是运行时的单位，而堆是存储的单位。栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。在 Java 中一个线程就会相应有一个线程栈与之对应，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。</p><hr><h3 id="4-堆中存什么？栈中存什么？"><a href="#4-堆中存什么？栈中存什么？" class="headerlink" title="4. 堆中存什么？栈中存什么？"></a>4. 堆中存什么？栈中存什么？</h3><p>堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个 4btye 的引用（堆栈分离的好处）。</p><p>为什么不把基本类型放堆中呢？</p><p>因为基本数据类型占用的空间一般是1~8个字节，需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况，长度固定，因此栈中存储就够了。如果把它存在堆中是没有什么意义的。基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，它们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java 中参数传递时的问题。</p><hr><h3 id="5-为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"><a href="#5-为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？" class="headerlink" title="5. 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"></a>5. 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</h3><ol><li>从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</li><li>堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li><li>栈因为运行时的需要，比如：保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</li></ol><hr><h3 id="6-Java-中的参数传递时传值呢？还是传引用？"><a href="#6-Java-中的参数传递时传值呢？还是传引用？" class="headerlink" title="6. Java 中的参数传递时传值呢？还是传引用？"></a>6. Java 中的参数传递时传值呢？还是传引用？</h3><p>要说明这个问题，先要明确两点：</p><ol><li>不要试图与 C 进行类比，Java 中没有指针的概念。</li><li>程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。</li></ol><p>Java 在方法调用传递参数时，因为没有指针，所以它都是进行传值调用。但是传引用的错觉是如何造成的呢？在运行栈中，基本类型和引用的处理是一样的，都是传值。所以，如果是传引用的方法调用，也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。但是当进入被调用方法时，被传递的这个引用的值，被程序解释到堆中的对象，这个时候才对应到真正的对象。如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是堆中的数据。所以这个修改是可以保持的了。</p><p>对象，从某种意义上说，是由基本类型组成的。可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树（即非叶子节点），基本类型则为树的叶子节点。程序参数传递时，被传递的值本身都是不能进行修改的，但是，如果这个值是一个非叶子节点（即一个对象引用），则可以修改这个节点下面的所有内容。</p><hr><h3 id="7-Java-对象的大小是怎么计算的？"><a href="#7-Java-对象的大小是怎么计算的？" class="headerlink" title="7. Java 对象的大小是怎么计算的？"></a>7. Java 对象的大小是怎么计算的？</h3><p>基本数据类型的大小是固定的。对于非基本类型的 Java 对象，其大小就值得商榷。在 Java 中，一个空 <code>Object</code> 对象的大小是 8 byte，这个大小只是保存堆中一个没有任何属性的对象的<code>大小。看下面语句： </code>Object ob &#x3D; new Object();<code> 这样在程序中完成了一个 Java 对象的生命，但是它所占的空间为：</code>4 byte + 8 byte<code>。</code>4 byte<code>是上面部分所说的 Java 栈中保存引用的所需要的空间。而那</code>8 byte<code>则是 Java 堆中对象的信息。因为所有的 Java 非基本类型的对象都需要默认继承</code>Object<code>对象，因此不论什么样的 Java 对象，其大小都必须是大于</code>8 byte<code>。有了 </code>Object&#96; 对象的大小，我们就可以计算其他对象的大小了。</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class MaNong &#123;</span><br><span class="line">    int count;</span><br><span class="line">    boolean flag;</span><br><span class="line">    Object obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MaNong</code> 的大小为：空对象大小(8 byte) + <code>int</code> 大小(4 byte) + <code>Boolean</code> 大小(1 byte) + 空 <code>Object</code> 引用的<code>大小（4 byte）</code> &#x3D; 17byte。但是因为 Java 在对对象内存分配时都是以 8 的整数倍来分，因此大于 17 byte 的最接近 8 的整数倍的是 24，因此此对象的大小为 24 byte。</p><p>这里需要注意一下基本类型的包装类型的大小。因为这种包装类型已经成为对象了，因此需要把它们作为对象来看待。包装类型的大小至少是12 byte（声明一个空 <code>Object</code> 至少需要的空间），而且 12 byte 没有包含任何有效信息，同时，因为 Java 对象大小是 8 的整数倍，因此一个基本类型包装类的大小至少是 16 byte。这个内存占用是很恐怖的，它是使用基本类型的 N 倍（N &gt; 2），有些类型的内存占用更是夸张（随便想下就知道了）。因此，可能的话应尽量少使用包装类。在 JDK5 以后，因为加入了自动类型装换，因此，Java 虚拟机会在存储方面进行相应的优化。</p><hr><h3 id="8-对象的访问定位的两种方式？"><a href="#8-对象的访问定位的两种方式？" class="headerlink" title="8. 对象的访问定位的两种方式？"></a>8. 对象的访问定位的两种方式？</h3><p>Java 程序通过栈上的引用数据来操作堆上的具体对象。目前主流的对象访问方式有：句柄 和 直接指针。</p><ol><li><p>使用句柄</p><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p></li><li><p>直接指针</p><p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何防止访问类型数据的相关信息，reference 中存储的直接就是对象的地址。</p></li><li><p><strong>各自的优点</strong></p></li><li><p>使用句柄来访问的最大好处是引用中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而引用本身不需要修改；</p></li><li><p>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p></li></ol><h3 id="JVM-调优参数"><a href="#JVM-调优参数" class="headerlink" title="JVM 调优参数"></a>JVM 调优参数</h3><ul><li><strong>堆内存大小设置:</strong><ul><li>-Xms<size>:设置 JVM 堆的初始内存大小。</li><li>-Xmx<size>:设置 JVM 堆的最大内存大小。</li><li>最佳实践:通常建议 -Xms 和 -Xmx 设置为相同值，以避免 JVM 在运行时动态调整堆大小带来的额外开销和 GC 停顿。例如 -Xms4g -Xmx4g。</li></ul></li><li><strong>新生代大小设置:</strong><ul><li>-Xmn<size>:设置新生代内存大小。</li><li>-XX:NewRatio&#x3D;<ratio>:设置老年代与新生代的比例，例如 -XX:NewRatio&#x3D;2 表示老年代:新生代 &#x3D; 2:1。</li><li>考量:<ul><li>新生代过小:频繁 Minor GC, 导致对象过早进入老年代。</li><li>新生代过大:Minor GC 间隔长, 但每次 GC 耗时可能长。</li></ul></li></ul></li><li><strong>元空间大小设置 (JDK 1.8+):</strong><ul><li>-XX:MetaspaceSize&#x3D;<size>:设置元空间的初始大小。</li><li>-XX:MaxMetaspaceSize&#x3D;<size>:设置元空间的最大大小。</li><li>考量:如果应用加载大量类或使用动态代码生成, 可能需要调大。</li></ul></li><li><strong>选择垃圾收集器:</strong><ul><li>-XX:+UseG1GC:启用 G1 垃圾收集器。这是 JDK 9+ 的默认收集器。</li><li>-XX:MaxGCPauseMillis&#x3D;<ms>:设置 G1 收集器可接受的最大停顿时间(G1 会尽量接近这个目标, 但不保证完全达到)。例如 -XX:MaxGCPauseMillis&#x3D;200。</li></ul></li></ul><h3 id="10-垃圾回收是从哪里开始的呢？"><a href="#10-垃圾回收是从哪里开始的呢？" class="headerlink" title="10. 垃圾回收是从哪里开始的呢？"></a>10. 垃圾回收是从哪里开始的呢？</h3><p>垃圾回收从查找哪些对象是正在被当前系统使用的开始。上面分析的堆和栈的区别，其中栈是真正进行程序执行的地方，所以要获取哪些对象正在被使用，则需要从 Java 栈开始。同时，一个栈是与一个线程对应的，因此，如果有多个线程的话，则必须对这些线程对应的所有的栈进行检查。</p><p>同时，除了栈外，还有系统运行时的寄存器等，也是存储程序运行数据的。这样，以栈或寄存器中的引用为起点，我们可以找到堆中的对象，又从这些对象找到对堆中其他对象的引用，这种引用逐步扩展，最终以 <code>null</code> 引用或者基本类型结束，这样就形成了一棵以 Java 栈中引用所对应的对象为根节点的一棵对象树。如果栈中有多个引用，则最终会形成多棵对象树。在这些对象树上的对象，都是当前系统运行所需要的对象，不能被垃圾回收。而其他剩余对象，则可以视为无法被引用到的对象，可以被当做垃圾进行回收。</p><hr><h3 id="11-被标记为垃圾的对象一定会被回收吗？"><a href="#11-被标记为垃圾的对象一定会被回收吗？" class="headerlink" title="11. 被标记为垃圾的对象一定会被回收吗？"></a>11. 被标记为垃圾的对象一定会被回收吗？</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。</p><ul><li><strong>第一次标记</strong>：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记；</li><li><strong>第二次标记</strong>：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize()</code> 方法。在 <code>finalize()</code> 方法中没有重新与引用链建立关联关系的，将被进行第二次标记。第二次标记成功的对象将真的会被回收，如果对象在 <code>finalize()</code> 方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。</li></ul><hr><h3 id="12-谈谈对-Java-中引用的了解？"><a href="#12-谈谈对-Java-中引用的了解？" class="headerlink" title="12. 谈谈对 Java 中引用的了解？"></a>12. 谈谈对 Java 中引用的了解？</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在Java语言中，将引用又分为强引用、软引用、弱引用、虚引用 4 种，这四种引用强度依次逐渐减弱。</p><ol><li><p>强引用</p><p>在程序代码中普遍存在的，类似 Object obj &#x3D; new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p></li><li><p>软引用</p><p>用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内</p></li><li><p>弱引用</p><p>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p></li><li><p>虚引用</p><p>也叫幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。</p></li></ol><hr><h3 id="13-谈谈对内存泄漏的理解？"><a href="#13-谈谈对内存泄漏的理解？" class="headerlink" title="13. 谈谈对内存泄漏的理解？"></a>13. 谈谈对内存泄漏的理解？</h3><p>内存泄露的基本概念</p><p>在 Java 中，内存泄漏就是存在一些不会再被使用却没有被回收的对象，这些对象有下面两个特点：</p><ol><li><p>这些对象是可达的，即在有向图中，存在通路可以与其相连；</p></li><li><p>这些对象是无用的，即程序以后不会再使用这些对象。</p><p>如果对象满足这两个条件，这些对象就可以判定为 Java 中的内存泄漏，这些对象不会被 GC 所回收，然而它却占用内存。</p></li></ol><hr><h3 id="14-内存泄露的根本原因是什么？"><a href="#14-内存泄露的根本原因是什么？" class="headerlink" title="14. 内存泄露的根本原因是什么？"></a>14. 内存泄露的根本原因是什么？</h3><p>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是 Java 中内存泄漏的发生场景。</p><hr><h3 id="15-举几个可能发生内存泄漏的情况？"><a href="#15-举几个可能发生内存泄漏的情况？" class="headerlink" title="15. 举几个可能发生内存泄漏的情况？"></a>15. 举几个可能发生内存泄漏的情况？</h3><ol><li>静态集合类引起的内存泄漏；</li><li>当集合里面的对象属性被修改后，再调用 <code>remove()</code> 方法时不起作用；</li><li>监听器：释放对象的时候没有删除监听器；</li><li>各种连接：比如数据库连接（<code>dataSourse.getConnection()</code>），网络连接(<code>socket</code>) 和 IO 连接，除非其显式的调用了其 <code>close()</code> 方法将其连接关闭，否则是不会自动被 GC 回收的；</li><li>内部类：内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放；</li><li>单例模式：单例对象在初始化后将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏。</li></ol><hr><h3 id="16-尽量避免内存泄漏的方法？"><a href="#16-尽量避免内存泄漏的方法？" class="headerlink" title="16. 尽量避免内存泄漏的方法？"></a>16. 尽量避免内存泄漏的方法？</h3><ol><li>尽量不要使用 <code>static</code> 成员变量，减少生命周期；</li><li>及时关闭资源；</li><li>不用的对象，可以手动设置为 <code>null</code>。</li></ol><h3 id="垃圾收集器-Garbage-Collector"><a href="#垃圾收集器-Garbage-Collector" class="headerlink" title="垃圾收集器 (Garbage Collector)"></a>垃圾收集器 (Garbage Collector)</h3><p>垃圾收集器是 JVM 的一个重要组成部分, 负责自动管理 Java 堆内存中的对象的生命周期, 回收不再使用的对象所占用的内存。</p><h4 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法:"></a><strong>垃圾判断算法:</strong></h4><ul><li>引用计数算法:当一个对象被引用一次, 计数器加1;引用失效, 计数器减1。当计数器为0时, 对象被判定为可回收。<ul><li>缺点:难以解决对象之间的循环引用问题。Java 虚拟机不采用此算法。</li></ul></li><li>可达性分析算法 (Root Tracing):通过一系列称为 “GC Roots” 的对象作为起始点, 从这些节点向下搜索, 搜索所走过的路径称为引用链 (Reference Chain)。当一个对象到 GC Roots 没有任何引用链相连时, 则证明此对象是不可用的。<ul><li>可作为 GC Roots 的对象:<ul><li>虚拟机栈 (栈帧中的局部变量表) 中引用的对象。</li><li>本地方法栈 (Native 方法) 中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>被同步锁持有的对象。</li><li>JVM 内部的引用 (如基本数据类型对应的 Class 对象)。</li></ul></li></ul></li></ul><h4 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器:"></a><strong>常见垃圾收集器:</strong></h4><ul><li><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器:"></a>Serial 收集器:</h5><ul><li>特点:单线程, 工作时需要停止所有用户线程 (“Stop The World”, STW)。简单高效, 适用于单核 CPU 或内存较小的客户端应用。</li><li>新生代使用:复制算法。</li><li>老年代使用:标记-整理算法。</li></ul></li><li><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器:"></a>ParNew 收集器:</h5><ul><li>特点:Serial 收集器的多线程版本, 用于新生代。并行收集时也需要 STW。</li><li>新生代使用:复制算法。</li><li>常与 CMS 收集器配合使用。</li></ul></li><li><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器:"></a>Parallel Scavenge 收集器:</h5><ul><li>特点：关注吞吐量（Throughput &#x3D; 用户代码执行时间 &#x2F; (用户代码执行时间 + GC 时间)），可以设置最大吞吐量或最大 GC 停顿时间。</li><li>新生代使用：复制算法。</li><li>老年代使用：与 Parallel Old 配合使用，使用标记-整理算法。</li></ul></li><li><h5 id="CMS-Concurrent-Mark-Sweep-收集器："><a href="#CMS-Concurrent-Mark-Sweep-收集器：" class="headerlink" title="CMS (Concurrent Mark Sweep) 收集器："></a>CMS (Concurrent Mark Sweep) 收集器：</h5><ul><li>特点：以获取最短回收停顿时间为目标，并发收集（与用户线程一起执行）。适用于对响应时间要求高的应用（如 Web 服务器）。</li><li>工作步骤：<ol><li>初始标记 (Initial Mark)：STW，标记 GC Roots 能直接关联到的对象，速度快。</li><li>并发标记 (Concurrent Mark)：与用户线程并发执行，进行 GC Roots Tracing 过程，耗时最长。</li><li>重新标记 (Remark)：STW，修正并发标记期间因用户程序继续运行而导致标记产生变动的对象，比初始标记耗时长，但远比并发标记短。</li><li>并发清除 (Concurrent Sweep)：与用户线程并发执行，清除已标记为垃圾的对象。</li></ol></li><li>缺点：<ul><li>对 CPU 资源敏感：并发阶段会占用一部分 CPU。</li><li>无法处理浮动垃圾：并发清除阶段产生的垃圾（新生成的对象）只能下次 GC 再处理。</li><li>可能产生大量空间碎片：采用“标记-清除”算法，不进行整理，可能导致大对象无法分配空间而提前触发 Full GC。</li></ul></li></ul></li><li><h5 id="G1-Garbage-First-收集器："><a href="#G1-Garbage-First-收集器：" class="headerlink" title="G1 (Garbage-First) 收集器："></a>G1 (Garbage-First) 收集器：</h5><ul><li>特点：JDK 9+ 的默认垃圾收集器。面向服务端应用，分区（将 Java 堆划分为多个独立区域 Region)，可预测的停顿时间模型。</li><li>工作原理：<ul><li>将堆内存划分为多个大小相等的 Region。</li><li>G1 跟踪每个 Region 的垃圾回收价值 (Garbage-First)，优先回收垃圾最多的 Region。</li><li>年轻化和老年代不再是物理隔离，而是逻辑上的概念，Region 可以动态地成为 Eden、Survivor 或 Old 区域。</li><li>并发与并行兼容：并发标记，但回收阶段并行。</li><li>基本无碎片：采用复制和标记-整理算法结合。</li></ul></li><li>工作步骤：<ol><li>初始标记 (Initial Mark)：STW，标记 GC Roots 能直接关联的对象。</li><li>并发标记 (Concurrent Mark)：与用户线程并发，遍历对象图。</li><li>最终标记 (Final Mark)：STW，处理并发标记阶段结束后仍然存活的对象。</li><li>筛选回收 (Evacuation)：STW，对各个 Region 的回收价值进行排序，根据预期停顿时间来回收 Region，采用复制算法将存活对象复制到新的 Region。</li></ol></li><li>优势：在保持高吞吐量的同时，降低了 GC 停顿时间，适合大内存、多核处理器场景。</li></ul></li><li><h5 id="zGC-Z-Garbage-Collector-和-Shenandoah-收集器："><a href="#zGC-Z-Garbage-Collector-和-Shenandoah-收集器：" class="headerlink" title="zGC (Z Garbage Collector) 和 Shenandoah 收集器："></a>zGC (Z Garbage Collector) 和 Shenandoah 收集器：</h5><ul><li>特点：低延迟、并发 GC 收集器，旨在实现毫秒级的 GC 停顿。</li><li>ZGC: JDK 11 引入，支持 TB 级别的堆内存，停顿时间与堆大小无关。</li><li>Shenandoah: JDK 12 引入，与 G1 类似，但能进一步降低停顿时间。</li><li>应用场景：对延迟要求极高的应用</li></ul></li></ul><h2 id="类加载机制-Class-Loading-Mechanism"><a href="#类加载机制-Class-Loading-Mechanism" class="headerlink" title="类加载机制 (Class Loading Mechanism)"></a>类加载机制 (Class Loading Mechanism)</h2><ul><li><p><strong>作用</strong>: 将 .class 文件中的字节码加载到 JVM 内存中，并转换为运行时数据结构。  </p></li><li><p><strong>生命周期</strong>: 加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载。  </p></li><li><p><strong>主要阶段</strong>:  </p><ul><li><strong>加载 (Loading)</strong>:  <ul><li>通过类的全限定名获取该类的二进制字节流。  </li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  </li><li>在内存中生成一个代表该类的 java.lang.Class 对象。</li></ul></li><li><strong>验证 (Verification)</strong>: 确保 Class 文件的字节流符合 JVM 规范，没有安全问题。  </li><li><strong>准备 (Preparation)</strong>: 为类的静态变量（static fields）分配内存并初始化为默认值（如 int 变量为 0，引用类型为 null）。  </li><li><strong>解析 (Resolution)</strong>: 将常量池中的符号引用替换为直接引用。  </li><li><strong>初始化 (Initialization)</strong>: 执行类的构造器 <code>&lt;clinit&gt;()</code> 方法，真正开始执行类中定义的 Java 程序代码（为静态变量赋予初始值，执行静态代码块）。</li></ul></li><li><p>类加载是 Java 虚拟机（JVM）将 <code>Class</code> 文件中的二进制数据读取到内存中，并将其转换为可用的 <code>java.lang.Class</code> 对象的过程。这个过程是所有 Java 程序运行的基础。</p><p>类加载的整个生命周期包括以下 7 个阶段：</p><ol><li><strong>加载（Loading）</strong></li><li><strong>验证（Verification）</strong></li><li><strong>准备（Preparation）</strong></li><li><strong>解析（Resolution）</strong></li><li><strong>初始化（Initialization）</strong></li><li>使用（Using）</li><li>卸载（Unloading）</li></ol><p>其中，前五个阶段是类加载的核心过程，后面两个阶段是类生命周期的延伸。下面我们详细解析前五个核心阶段。</p><hr><h3 id="1-加载（Loading）"><a href="#1-加载（Loading）" class="headerlink" title="1. 加载（Loading）"></a>1. 加载（Loading）</h3><p>这是类加载过程的第一个阶段，主要任务是查找并导入 <code>Class</code> 文件中的二进制数据。这个阶段主要完成三件事：</p><ul><li><strong>通过类的全限定名获取定义此类的二进制字节流</strong>：JVM 可以从文件系统、网络、压缩包（JAR&#x2F;WAR&#x2F;EAR）甚至数据库中获取字节流。</li><li><strong>将字节流中的静态存储结构转换为方法区的运行时数据结构</strong>：JVM 会将二进制数据按照虚拟机规范的要求，转化为方法区中可用的数据结构。</li><li><strong>在内存中生成一个代表该类的 java.lang.Class 对象</strong>：这个对象是访问方法区中该类各种数据（如方法、字段）的入口，也是反射机制的基石。</li></ul><hr><h3 id="2-验证（Verification）"><a href="#2-验证（Verification）" class="headerlink" title="2. 验证（Verification）"></a>2. 验证（Verification）</h3><p>验证阶段的目的是确保 <code>Class</code> 文件的字节流符合 JVM 规范，并且不会危害到虚拟机的安全。这个阶段非常重要，因为 <code>Class</code> 文件不一定是由 Java 源码编译而来，它可以是任何来源。验证通常包括以下几个检查：</p><ul><li><strong>文件格式验证</strong>：检查字节流是否符合 <code>Class</code> 文件格式的规范，例如魔数（<code>0xCAFEBABE</code>）、版本号等。</li><li><strong>元数据验证</strong>：对类的元数据进行语义分析，确保其符合 Java 语言规范，例如是否继承了不允许继承的 <code>final</code> 类、字段和方法签名是否合理等。</li><li><strong>字节码验证</strong>：这是验证阶段最复杂的一步，通过数据流和控制流分析，确保程序语义是合法的、符合逻辑的。例如，保证类型转换是有效的、方法调用的参数是正确的。</li><li><strong>符号引用验证</strong>：在解析阶段发生，确保解析出来的类、字段、方法是真实存在的，并且具有足够的访问权限。</li></ul><hr><h3 id="3-准备（Preparation）"><a href="#3-准备（Preparation）" class="headerlink" title="3. 准备（Preparation）"></a>3. 准备（Preparation）</h3><p>准备阶段是为类的<strong>静态变量</strong>分配内存并设置<strong>初始值</strong>的阶段。</p><ul><li><strong>只为静态变量分配内存</strong>：在这个阶段，JVM 只为 <code>static</code> 变量（类变量）分配内存，而不包括实例变量。实例变量会在对象实例化时随着对象一起分配在堆中。</li><li><strong>设置初始值</strong>：这里的初始值通常是该数据类型的<strong>零值</strong>（例如 <code>int</code> 的初始值为 <code>0</code>，<code>boolean</code> 为 <code>false</code>，<code>String</code> 为 <code>null</code>）。</li></ul><p><strong>注意</strong>：如果静态变量被 <code>final</code> 修饰，并且是基本数据类型或字符串字面量，那么在准备阶段就会直接赋值为它在代码中定义的值。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备阶段：value 的初始值为 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备阶段：finalValue 的初始值直接为 123</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalValue</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="4-解析（Resolution）"><a href="#4-解析（Resolution）" class="headerlink" title="4. 解析（Resolution）"></a>4. 解析（Resolution）</h3><p>解析阶段是将常量池中的<strong>符号引用</strong>转换为<strong>直接引用</strong>的过程。</p><ul><li><strong>符号引用</strong>：一组符号来描述所引用的目标，可以是任何形式的字面量，只要能定位到目标即可。它不依赖于内存布局。</li><li><strong>直接引用</strong>：直接指向目标的指针、相对偏移量或是一个可以间接定位到目标的句柄。它与内存布局相关。</li></ul><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符七类符号引用进行。这个阶段是动态的，通常会在程序运行时，当符号引用被首次使用时才进行。</p><hr><h3 id="5-初始化（Initialization）"><a href="#5-初始化（Initialization）" class="headerlink" title="5. 初始化（Initialization）"></a>5. 初始化（Initialization）</h3><p>初始化是类加载过程的最后一步，在这个阶段，<strong>真正执行</strong>类中定义的 Java 代码。</p><ul><li><strong>执行 <clinit>() 方法</strong>：初始化阶段会执行类构造器 <code>&lt;clinit&gt;()</code> 方法，这个方法由编译器自动生成，它用于收集类中所有静态变量的赋值动作和静态代码块（<code>static &#123;&#125;</code>）中的语句。</li><li><strong>线程安全</strong>：JVM 会确保 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确地加锁和同步，保证一个类的 <code>&lt;clinit&gt;()</code> 方法只会被执行一次。</li><li><strong>触发时机</strong>：只有在以下几种情况中，一个类才会被“主动”初始化：<ul><li>创建类的实例（<code>new</code>）。</li><li>访问类的静态变量（除了在编译时被 <code>final</code> 化的常量）。</li><li>调用类的静态方法。</li><li>使用 <code>java.lang.reflect</code> 包的方法进行反射调用。</li><li>初始化一个子类时，其父类尚未初始化。</li><li>虚拟机启动时，被指定为启动类的类（如包含 <code>main()</code> 方法的类）。</li></ul></li></ul><p>理解这五个阶段对于深入掌握 JVM 的工作原理至关重要。</p></li><li><p><strong>类加载器 (Class Loaders)</strong>:  </p><ul><li><p>类加载器的分类：</p><p>（1）Bootstrap class loader （使用C++编写的）</p><p>​    简称：启动类加载器</p><p>​    <strong>加载路径</strong>：JAVA_HOME&#x2F;jre&#x2F;lib</p><p>​    显示形式：null</p><p>（2）Platform class loader（由Java编写的）</p><p>​    简称：扩展类加载器</p><p>​    <strong>加载路径</strong>：JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</p><p>​    显示形式：ExtClassLoader</p><p>（3）System class loader（由Java编写的）</p><p>​    简称：应用程序类加载器</p><p>​    <strong>加载路径</strong>：类路径（src目录）</p><p>​    显示形式：AppClassLoader   &#x2F;&#x2F;sun.misc.Launcher$AppClassLoader@18b4aac2</p><p>（4）自定义类加载器（由Java编写的）</p><p>​    简称：自定义类加载器</p><p>​    加载路径：自定义</p><h4 id="1-启动类加载器-Bootstrap-ClassLoader"><a href="#1-启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="1. 启动类加载器 (Bootstrap ClassLoader)"></a><strong>1. 启动类加载器 (Bootstrap ClassLoader)</strong></h4><ul><li><strong>作用</strong>：它负责加载 Java 核心库，比如 <code>rt.jar</code>（包含 <code>java.lang.*</code>, <code>java.util.*</code> 等核心类）。</li><li><strong>实现</strong>：它不是用 Java 写的，而是由 C++ 实现的，是 JVM 自身的一部分。因此，你无法在 Java 代码中直接获取到它的对象，调用 <code>getClassLoader()</code> 得到的会是 <code>null</code>。</li><li><strong>父加载器</strong>：它没有父加载器。它是类加载器层次结构的顶端。</li></ul><h4 id="2-扩展类加载器-Extension-ClassLoader"><a href="#2-扩展类加载器-Extension-ClassLoader" class="headerlink" title="2. 扩展类加载器 (Extension ClassLoader)"></a><strong>2. 扩展类加载器 (Extension ClassLoader)</strong></h4><ul><li><strong>作用</strong>：它负责加载 JVM 扩展目录中的所有 jar 包，通常是 <code>JRE/lib/ext</code> 目录下的库。</li><li><strong>实现</strong>：它是由 Java 语言实现的。</li><li><strong>父加载器</strong>：它的父加载器是<strong>启动类加载器</strong>。</li></ul><h4 id="3-应用程序类加载器-Application-ClassLoader"><a href="#3-应用程序类加载器-Application-ClassLoader" class="headerlink" title="3. 应用程序类加载器 (Application ClassLoader)"></a><strong>3. 应用程序类加载器 (Application ClassLoader)</strong></h4><ul><li><strong>作用</strong>：它负责加载我们自己编写的 Java 程序中的类，也就是你项目中 <code>classpath</code> 路径下的所有类。</li><li><strong>实现</strong>：它也是由 Java 语言实现的。</li><li><strong>父加载器</strong>：它的父加载器是<strong>扩展类加载器</strong>。</li></ul><hr><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h3><p>除了上面三个，你也可以根据自己的需求创建<strong>自定义类加载器</strong>。</p><ul><li><strong>作用</strong>：当你需要加载一些特定来源的类时（比如从网络下载的类、对字节码进行加密或解密），自定义类加载器就很有用。例如，Web 服务器（如 Tomcat）就是通过自定义类加载器来隔离不同 Web 应用的类。</li><li><strong>如何实现</strong>：通常，你需要继承 <code>java.lang.ClassLoader</code> 类，并重写 <code>findClass()</code> 方法。在 <code>findClass()</code> 方法中，你需要自己定义如何获取类的字节码（比如从文件系统、网络或数据库），然后调用 <code>defineClass()</code> 方法将字节码转换为 <code>Class</code> 对象。</li></ul></li></ul></li></ul><h3 id="33-有哪些类加载器？分别有什么作用？"><a href="#33-有哪些类加载器？分别有什么作用？" class="headerlink" title="33. 有哪些类加载器？分别有什么作用？"></a>33. 有哪些类加载器？分别有什么作用？</h3><ol><li><strong>启动类加载器 (Bootstrap ClassLoader)</strong>：这个类加载器是由 C++ 语言实现的，是虚拟机自身的一部分。负责将存在 <code>\lib</code> 目录中的，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中的类库加载到虚拟机内存中。启动内加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 <code>null</code> 即可；</li><li><strong>其他类加载器</strong>：由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。如扩展类加载器和应用程序类加载器：<ul><li><strong>扩展类加载器 (Extension ClassLoader)</strong>：这个类加载器由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现，它负责加载<code>\lib\ext</code>目录中的，或者被 <code>java.ext.dirs</code> 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li><li><strong>应用程序类加载器 (Application ClassLoader)</strong>：这个类加载器由 <code>sun.misc.Launcher$AppClassLoder</code> 实现。由于个类加载器是 <code>ClassLoader</code> 中的 <code>getSystemClassLoader()</code> 方法的返回值，所以一般也称之为系统类加载器。它负责加载用户路径（ClassPath）所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li></ol><ul><li><p><strong>双亲委派模型 (Parents Delegation Model)</strong>:  </p><ul><li><strong>原理</strong>: 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。  </li><li><strong>优点</strong>: 避免类的重复加载，保证 Java 核心库的类型安全。</li></ul></li></ul><h3 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h3><p>为什么需要四个类加载器，而不是一个？</p><p>这是一个很好的问题。为什么 Java 要设计多个类加载器，而不是用一个大一统的加载器呢？这背后主要有三个核心原因：<strong>隔离性</strong>、<strong>安全性</strong>和<strong>可扩展性</strong>。</p><hr><h4 id="1-隔离性（Isolation）"><a href="#1-隔离性（Isolation）" class="headerlink" title="1. 隔离性（Isolation）"></a>1. 隔离性（Isolation）</h4><p>多类加载器的最大优势就是实现了<strong>类隔离</strong>。</p><p>想象一下，你有一个 Web 服务器，上面部署了两个不同的 Web 应用（比如一个博客系统和一个论坛）。这两个应用可能依赖同一个第三方库的不同版本（例如，博客用的是 Spring 框架的 5.x 版本，而论坛用的是 4.x 版本）。</p><p>如果只有一个类加载器，它会把所有 <code>classpath</code> 上的类都加载到同一个内存空间。这样一来，两个不同版本的 Spring 框架就会产生冲突，JVM 根本无法区分它们，程序就会报错。</p><p>而有了自定义类加载器，服务器就可以为每个 Web 应用创建一个独立的类加载器。每个加载器负责加载自己应用目录下的类，这样两个应用即使使用了同一个库的不同版本，也能在内存中和谐共存，互不干扰。</p><hr><h4 id="2-安全性（Security）"><a href="#2-安全性（Security）" class="headerlink" title="2. 安全性（Security）"></a>2. 安全性（Security）</h4><p>Java 的核心库（如 <code>java.lang</code>, <code>java.util</code> 等）对 JVM 的稳定和安全至关重要。</p><p><strong>双亲委派模型</strong>正是为了保护这些核心库不被恶意代码或普通用户代码所篡改。</p><p>例如，如果你尝试自己写一个 <code>java.lang.String</code> 类并把它放在应用的 <code>classpath</code> 下，双亲委派机制会确保这个类不会被加载。因为当加载请求到达应用程序类加载器时，它会先委派给它的父加载器——扩展类加载器，然后再委派给最顶层的<strong>启动类加载器</strong>。启动类加载器会优先加载 JDK 自带的 <code>java.lang.String</code>，从而你的恶意代码就永远没有机会被执行。</p><hr><h4 id="3-可扩展性（Extensibility）"><a href="#3-可扩展性（Extensibility）" class="headerlink" title="3. 可扩展性（Extensibility）"></a>3. 可扩展性（Extensibility）</h4><p>Java 是一种非常灵活的语言，需要适应各种复杂的运行时环境。</p><p>如果只有一个类加载器，所有的类都必须来自文件系统。但在现实世界中，类可能来自各种地方：</p><ul><li>从网络上下载的字节码。</li><li>通过数据库存储和加载。</li><li>对字节码进行加密和解密。</li></ul><p>自定义类加载器让 Java 能够<strong>动态地加载</strong>和<strong>处理非标准来源的类</strong>。例如，热部署技术（在不重启应用的情况下更新代码）就是通过自定义类加载器实现的。它会创建一个新的加载器来加载新版本的类，而旧的加载器和它的类则可以被垃圾回收。</p><hr><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p>所以，一个大一统的类加载器虽然简单，但它无法解决复杂的<strong>类版本冲突</strong>、<strong>核心库安全</strong>和<strong>动态加载</strong>等问题。通过分层设计和双亲委派模型，Java 的类加载器体系变得既安全又灵活，能够满足从简单的桌面应用到复杂的企业级服务器等各种场景的需求。</p><h2 id="OOM-OutOfMemoryError-和-StackOverflowError"><a href="#OOM-OutOfMemoryError-和-StackOverflowError" class="headerlink" title="OOM (OutOfMemoryError) 和 StackOverflowError"></a>OOM (OutOfMemoryError) 和 StackOverflowError</h2><ul><li><strong>Java heap space</strong>: 堆内存不足，最常见。通常通过调整 JVM 启动参数 <code>-Xms</code> (初始堆大小) 和 <code>-Xmx</code> (最大堆大小) 来解决。  </li><li><strong>StackOverflowError</strong>: 虚拟机栈溢出。通常是递归调用过深导致栈帧不断入栈。  </li><li><strong>PermGen space &#x2F; Metaspace</strong>: 方法区溢出。通常是加载的类过多，或者存在大量字符串常量。通过 <code>-XX:MaxPermSize</code> (JDK 1.7) 或 <code>-XX:MaxMetaspaceSize</code> (JDK 1.8) 调整。  </li><li><strong>Direct buffer memory</strong>: 直接内存溢出。通常是使用了 NIO 或 Netty 等直接操作堆外内存的库。  </li><li><strong>unable to create new native thread</strong>: 无法创建新线程。通常是系统线程数达到上限或内存不足以分配新线程的栈空间。</li></ul><h3 id="OOM常见场景："><a href="#OOM常见场景：" class="headerlink" title="OOM常见场景："></a>OOM常见场景：</h3><hr><h4 id="1-java-lang-OutOfMemoryError-Java-heap-space"><a href="#1-java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="1. java.lang.OutOfMemoryError: Java heap space"></a><strong>1. java.lang.OutOfMemoryError: Java heap space</strong></h4><p>这是最常见、也最广为人知的内存溢出错误。它表示 <strong>Java 堆（Heap）</strong> 中没有足够的空间来分配新的对象。</p><p><strong>常见场景：</strong></p><ul><li><strong>内存泄漏（Memory Leak）</strong>：这是最主要的原因。你的程序中创建了对象，但本应被垃圾回收器（GC）回收的对象却因为某些原因（比如被一个长生命周期的对象引用着）而无法被回收。例如：<ul><li>一个静态的 <code>Map</code> 或 <code>List</code> 集合，不断地往里面添加对象，但从不删除。</li><li>监听器或回调函数没有正确移除，导致被监听的对象无法被回收。</li><li>数据库连接或文件流没有正确关闭，长时间占用资源。</li></ul></li><li><strong>内存使用不当</strong>：一次性加载大量数据到内存中。例如，从数据库查询数百万条记录，并把它们全部加载到一个 <code>List</code> 中；或者处理一个超大的图片或文件，导致瞬间占用大量内存。</li><li><strong>配置问题</strong>：JVM 的堆内存设置得太小，无法满足程序的正常运行需求。这在部署应用时很常见，可以通过调整 <code>-Xmx</code> 参数来解决。</li></ul><hr><h4 id="2-java-lang-StackOverflowError"><a href="#2-java-lang-StackOverflowError" class="headerlink" title="2. java.lang.StackOverflowError"></a><strong>2. java.lang.StackOverflowError</strong></h4><p>这个错误表示 <strong>虚拟机栈（Stack）</strong> 溢出。每个线程都有一个独立的栈，用于存储方法调用的栈帧。当栈的深度超过了 JVM 允许的最大深度时，就会抛出此错误。</p><p><strong>常见场景：</strong></p><ul><li><p><strong>无限递归（Infinite Recursion）</strong>：这是最典型的场景。一个方法不断地调用自身，且没有正确的退出条件。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursiveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 没有退出条件</span></span><br><span class="line">    recursiveMethod(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子是两个方法互相调用，形成循环：A 调用 B，B 又调用 A。</p></li><li><p><strong>递归调用层级过深</strong>：即使递归有正确的退出条件，如果数据量过大，导致递归调用层级非常深，也可能导致栈溢出。例如，处理一个深度非常大的树形结构。</p></li></ul><hr><h4 id="3-java-lang-OutOfMemoryError-PermGen-space-或-Metaspace"><a href="#3-java-lang-OutOfMemoryError-PermGen-space-或-Metaspace" class="headerlink" title="3. java.lang.OutOfMemoryError: PermGen space 或 Metaspace"></a><strong>3. java.lang.OutOfMemoryError: PermGen space 或 Metaspace</strong></h4><p>这个错误发生在 <strong>方法区</strong> 溢出。方法区用于存储类的元数据信息，如类的结构、字段、方法、常量池等。</p><ul><li><strong>JDK 1.7 及之前</strong>：方法区在堆中，被称为<strong>永久代（PermGen）</strong>。溢出错误为 <code>PermGen space</code>。</li><li><strong>JDK 1.8 及之后</strong>：永久代被移除，方法区改为使用<strong>元空间（Metaspace）</strong>，并且默认使用本地内存。溢出错误为 <code>Metaspace</code>。</li></ul><p><strong>常见场景：</strong></p><ul><li><strong>动态生成大量类</strong>：在运行时生成大量新的类。这在一些使用字节码增强技术的框架（如 CGLib）或动态代理的场景中很常见。</li><li><strong>热部署</strong>：在像 Tomcat 这样的 Web 服务器中进行频繁的热部署操作，如果没有正确清理旧的类加载器，会导致旧的类元数据无法被回收，从而逐渐耗尽方法区内存。</li><li><strong>常量池溢出</strong>：在 JDK 1.7 之前，字符串常量池也在永久代中。如果程序创建了大量不同的字符串（例如在循环中不断生成新的字符串），也可能导致永久代溢出。</li></ul><hr><h4 id="4-java-lang-OutOfMemoryError-Direct-buffer-memory"><a href="#4-java-lang-OutOfMemoryError-Direct-buffer-memory" class="headerlink" title="4. java.lang.OutOfMemoryError: Direct buffer memory"></a><strong>4. java.lang.OutOfMemoryError: Direct buffer memory</strong></h4><p>这个错误与 <strong>直接内存（Direct Memory）</strong> 相关，它不是 Java 堆的一部分，而是通过 <code>ByteBuffer.allocateDirect()</code> 在堆外分配的内存。</p><p><strong>常见场景：</strong></p><ul><li><strong>NIO 和网络编程</strong>：在使用 Java NIO、Netty、或者其他依赖堆外内存的库时，如果频繁地分配直接内存但没有及时释放，就可能导致此错误。</li><li><strong>内存泄漏</strong>：直接内存的回收不像堆内存那样由 GC 自动管理。如果程序中没有调用 <code>ByteBuffer</code> 的 <code>cleaner()</code> 方法，或者在没有关闭资源的情况下直接内存泄漏，就会耗尽系统的直接内存。</li></ul><hr><h4 id="5-java-lang-OutOfMemoryError-unable-to-create-new-native-thread"><a href="#5-java-lang-OutOfMemoryError-unable-to-create-new-native-thread" class="headerlink" title="5. java.lang.OutOfMemoryError: unable to create new native thread"></a><strong>5. java.lang.OutOfMemoryError: unable to create new native thread</strong></h4><p>这个错误通常不是因为 Java 堆内存不足，而是因为<strong>系统资源耗尽</strong>。</p><p><strong>常见场景：</strong></p><ul><li><strong>线程创建过多</strong>：程序中创建了大量的线程，导致系统无法为新的线程分配内存空间。每个线程除了 Java 堆中的栈空间外，还需要分配一些本地内存。</li><li><strong>系统限制</strong>：操作系统对单个进程创建的线程数有限制。如果达到了这个上限，JVM 就会抛出此错误。在 Linux 系统中，你可以通过 <code>ulimit -u</code> 命令查看这个限制。</li><li><strong>内存不足</strong>：系统内存（包括堆外内存）已经所剩无几，JVM 无法为新的线程栈分配足够的内存。</li></ul><h3 id="面试题：-1"><a href="#面试题：-1" class="headerlink" title="面试题："></a>面试题：</h3><h4 id="1-简述-Java-堆内存溢出（Java-heap-space）的原因及解决方案。"><a href="#1-简述-Java-堆内存溢出（Java-heap-space）的原因及解决方案。" class="headerlink" title="1. 简述 Java 堆内存溢出（Java heap space）的原因及解决方案。"></a>1. 简述 Java 堆内存溢出（Java heap space）的原因及解决方案。</h4><p><strong>原因：</strong> 最主要的原因是<strong>内存泄漏</strong>，即 GC 无法回收本应被回收的对象。其他常见原因包括：</p><ul><li><strong>内存使用不当</strong>：一次性加载大量数据到内存中，如从数据库查询海量数据。</li><li><strong>配置不当</strong>：JVM 启动参数 <code>-Xmx</code> 设置过小，无法满足应用需求。</li></ul><p><strong>解决方案：</strong></p><ul><li><strong>分析和定位问题</strong>：使用 <code>jmap</code>、<code>jstat</code>、<code>jstack</code> 等 JDK 自带工具或者 <code>Eclipse MAT</code> 等可视化工具分析内存快照（<code>heap dump</code>），找到占用内存最多的对象，并分析是否存在内存泄漏。</li><li><strong>代码层面优化</strong>：<ul><li>检查并解决内存泄漏问题，比如移除不再需要的静态集合引用。</li><li>优化大批量数据处理逻辑，采用分批、分页处理或流式处理，避免一次性加载所有数据。</li><li>及时释放不再使用的资源，如关闭数据库连接、文件流等。</li></ul></li><li><strong>JVM 参数调整</strong>：如果确认没有内存泄漏，只是应用确实需要更多内存，可以适当增大 <code>-Xmx</code> 和 <code>-Xms</code> 参数。</li></ul><hr><h4 id="2-什么是-StackOverflowError？它和-OOM-有什么区别？"><a href="#2-什么是-StackOverflowError？它和-OOM-有什么区别？" class="headerlink" title="2. 什么是 StackOverflowError？它和 OOM 有什么区别？"></a>2. 什么是 StackOverflowError？它和 OOM 有什么区别？</h4><p><strong>StackOverflowError</strong> 表示<strong>虚拟机栈</strong>溢出，通常是由于<strong>无限递归</strong>或<strong>递归调用层级过深</strong>导致栈帧不断入栈而耗尽了栈空间。</p><p><strong>与 OOM 的区别：</strong></p><ul><li><strong>发生位置不同</strong>：<code>StackOverflowError</code> 发生在<strong>虚拟机栈</strong>，而 <code>OutOfMemoryError</code> 发生在<strong>堆</strong>或<strong>方法区</strong>等其他内存区域。</li><li><strong>原因不同</strong>：<code>StackOverflowError</code> 通常是由于<strong>代码逻辑问题</strong>（如无限递归）导致，与程序处理的数据量大小关系不大（除非递归深度过深）。而 <code>OOM</code> 往往与<strong>程序处理的数据量</strong>、<strong>JVM 内存配置</strong>或<strong>内存泄漏</strong>有关。</li><li><strong>解决方式不同</strong>：解决 <code>StackOverflowError</code> 主要需要<strong>修改代码</strong>，比如增加递归的退出条件或采用非递归（迭代）方式重构。而解决 <code>OOM</code> 则需要<strong>定位内存泄漏</strong>、<strong>优化代码</strong>或<strong>调整 JVM 内存参数</strong>。</li></ul><hr><h4 id="3-JDK-8-中-PermGen-space-溢出错误为什么变成了-Metaspace？"><a href="#3-JDK-8-中-PermGen-space-溢出错误为什么变成了-Metaspace？" class="headerlink" title="3. JDK 8 中 PermGen space 溢出错误为什么变成了 Metaspace？"></a>3. JDK 8 中 PermGen space 溢出错误为什么变成了 Metaspace？</h4><ul><li><strong>JDK 1.7 及之前</strong>：方法区被实现为<strong>永久代（PermGen）</strong>，它属于<strong>堆内存的一部分</strong>。因此，它的空间大小受限于 JVM 堆内存的设置，容易发生 <code>PermGen space</code> 溢出。</li><li><strong>JDK 1.8 及之后</strong>：<strong>永久代被移除</strong>，方法区改为<strong>元空间（Metaspace）</strong>。元空间<strong>不在 JVM 堆中</strong>，而是直接使用<strong>本地内存</strong>（Native Memory）。</li></ul><p><strong>变化的好处：</strong></p><ul><li><strong>减少 OOM 可能性</strong>：元空间使用本地内存，其大小只受限于系统可用内存，默认情况下比永久代大得多，从而降低了因方法区过小而引发 OOM 的风险。</li><li><strong>避免 GC 负担</strong>：永久代需要由 GC 进行垃圾回收，而元空间则通过 <code>class loader</code> 引用来管理，当对应的 <code>class loader</code> 被回收时，其加载的类元数据也会被回收。</li><li><strong>更灵活</strong>：元空间的大小可以通过参数 <code>-XX:MaxMetaspaceSize</code> 来设置上限，如果该参数不设置，元空间会根据需要自动扩容。</li></ul><hr><h4 id="4-除了-Java-堆，还有哪些内存区域可能发生-OOM？如何解决？"><a href="#4-除了-Java-堆，还有哪些内存区域可能发生-OOM？如何解决？" class="headerlink" title="4. 除了 Java 堆，还有哪些内存区域可能发生 OOM？如何解决？"></a>4. 除了 Java 堆，还有哪些内存区域可能发生 OOM？如何解决？</h4><ul><li><strong>直接内存（Direct buffer memory）</strong>：<ul><li><strong>原因</strong>：通常是使用 NIO 或 Netty 等框架时，频繁分配堆外内存但没有及时释放。</li><li><strong>解决</strong>：检查代码中堆外内存的使用，确保在不再需要时通过 <code>Buffer.cleaner()</code> 或资源关闭操作来显式释放内存。</li></ul></li><li><strong>无法创建新线程（unable to create new native thread）</strong>：<ul><li><strong>原因</strong>：<ol><li>程序创建了<strong>过多线程</strong>，耗尽了操作系统对单个进程的线程数限制。</li><li>系统<strong>内存不足</strong>，无法为新线程分配栈空间。</li></ol></li><li><strong>解决</strong>：<ol><li><strong>代码优化</strong>：检查业务逻辑，看是否可以减少线程创建数量，或者使用线程池来复用线程。</li><li><strong>系统配置</strong>：<ul><li>在 Linux 系统中，使用 <code>ulimit -u</code> 增加线程数限制。</li><li>检查系统内存，确保有足够的内存空间。</li></ul></li><li><strong>JVM 参数调整</strong>：如果线程确实需要，可以适当减小线程栈的大小（<code>-Xss</code>）来允许创建更多线程，但需要注意防止 StackOverflowError。</li></ol></li></ul></li></ul><hr><h1 id="Java框架核心知识详解"><a href="#Java框架核心知识详解" class="headerlink" title="Java框架核心知识详解"></a>Java框架核心知识详解</h1><h2 id="一、Spring框架深入解析"><a href="#一、Spring框架深入解析" class="headerlink" title="一、Spring框架深入解析"></a>一、Spring框架深入解析</h2><h3 id="1-1-Spring核心概念与原理"><a href="#1-1-Spring核心概念与原理" class="headerlink" title="1.1 Spring核心概念与原理"></a>1.1 Spring核心概念与原理</h3><p>Spring框架是一个分层的企业级应用开发框架，其核心是控制反转（IoC）和面向切面编程（AOP）。</p><h4 id="IoC容器原理深入分析"><a href="#IoC容器原理深入分析" class="headerlink" title="IoC容器原理深入分析"></a>IoC容器原理深入分析</h4><p><strong>IoC（控制反转）的本质：</strong> 传统开发中，对象的创建和依赖关系由程序代码直接控制，而IoC将这个控制权交给了外部容器。Spring通过依赖注入（DI）来实现IoC。</p><p><strong>IoC容器的实现机制：</strong></p><ol><li><strong>BeanFactory</strong>: 基础容器，提供基本的IoC功能</li><li><strong>ApplicationContext</strong>: 高级容器，继承BeanFactory，提供更多企业级功能</li></ol><hr><h4 id="IoC-容器实现机制"><a href="#IoC-容器实现机制" class="headerlink" title="IoC 容器实现机制"></a>IoC 容器实现机制</h4><h5 id="1-BeanFactory-——-基础-IoC-容器"><a href="#1-BeanFactory-——-基础-IoC-容器" class="headerlink" title="1. BeanFactory —— 基础 IoC 容器"></a>1. BeanFactory —— 基础 IoC 容器</h5><p><code>BeanFactory</code> 是 Spring IoC 的最底层容器接口，定义了 <strong>获取 Bean 的基本规则</strong>。</p><h6 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h6><ul><li><strong>懒加载（Lazy loading）</strong><ul><li>只有在调用 <code>getBean()</code> 时，才会去实例化 Bean。</li><li>避免启动时消耗过多资源。</li></ul></li><li><strong>最小依赖</strong><ul><li>只提供 IoC 的基础功能：<ul><li>Bean 的定义（BeanDefinition）管理</li><li>Bean 的生命周期（创建、依赖注入、销毁）</li><li>Bean 的作用域（singleton &#x2F; prototype）</li></ul></li></ul></li><li><strong>轻量级</strong><ul><li>更适合资源受限环境，比如 IoT、移动设备，或 Spring 的底层框架内部。</li></ul></li></ul><h6 id="核心实现机制"><a href="#核心实现机制" class="headerlink" title="核心实现机制"></a>核心实现机制</h6><ol><li><strong>读取 BeanDefinition</strong><ul><li>配置文件(XML)、注解(@Component)、Java Config( @Bean ) → 转换成 <strong>BeanDefinition</strong> 对象。</li><li>BeanDefinition 是 Bean 的抽象描述，包括：<ul><li>Bean 的 class 类型</li><li>是否单例 &#x2F; 原型</li><li>是否懒加载</li><li>构造参数 &#x2F; 依赖属性</li></ul></li></ul></li><li><strong>存储 BeanDefinition</strong><ul><li>存入 <strong>BeanDefinitionRegistry</strong>（通常是 Map 结构）。</li></ul></li><li><strong>按需实例化 Bean</strong><ul><li>调用 <code>getBean(name)</code> → 根据 BeanDefinition 反射创建实例。</li><li>进行依赖注入（构造器注入 &#x2F; setter 注入）。</li></ul></li><li><strong>Bean 生命周期管理</strong><ul><li>初始化前回调（BeanPostProcessor → <code>postProcessBeforeInitialization</code>）</li><li>调用初始化方法（<code>InitializingBean</code> 或 <code>@PostConstruct</code>）</li><li>初始化后回调（BeanPostProcessor → <code>postProcessAfterInitialization</code>）</li><li>销毁前回调（<code>DisposableBean</code> 或 <code>@PreDestroy</code>）</li></ul></li></ol><hr><h3 id="2-ApplicationContext-——-高级-IoC-容器"><a href="#2-ApplicationContext-——-高级-IoC-容器" class="headerlink" title="2. ApplicationContext —— 高级 IoC 容器"></a>2. ApplicationContext —— 高级 IoC 容器</h3><p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口，扩展了很多 <strong>企业级特性</strong>，是我们在项目中最常用的容器。</p><h4 id="核心特性（对比-BeanFactory）"><a href="#核心特性（对比-BeanFactory）" class="headerlink" title="核心特性（对比 BeanFactory）"></a>核心特性（对比 BeanFactory）</h4><ol><li><strong>预实例化（Eager loading）</strong><ul><li>默认在容器启动时，就会实例化所有单例 Bean。</li><li>启动时性能开销更大，但运行时性能更好。</li></ul></li><li><strong>国际化（I18N）支持</strong><ul><li>通过 <code>MessageSource</code> 接口，支持不同语言的消息解析。</li></ul></li><li><strong>事件机制（ApplicationEvent）</strong><ul><li>内置事件发布 &#x2F; 监听机制（观察者模式）。</li><li>开发者可以自定义事件，实现应用内解耦。</li></ul></li><li><strong>资源加载</strong><ul><li>统一的 <code>Resource</code> 抽象，可以加载文件、URL、classpath 下的资源。</li></ul></li><li><strong>与 AOP、事务管理集成</strong><ul><li>自动识别 BeanPostProcessor、BeanFactoryPostProcessor，用于扩展 Bean 生命周期逻辑（例如事务代理、AOP 动态代理）。</li></ul></li><li><strong>Profile 环境支持</strong><ul><li>支持多环境配置（开发、测试、生产），通过 <code>@Profile</code> 注解切换。</li></ul></li></ol><hr><h3 id="3-BeanFactory-vs-ApplicationContext-总结"><a href="#3-BeanFactory-vs-ApplicationContext-总结" class="headerlink" title="3. BeanFactory vs ApplicationContext 总结"></a>3. BeanFactory vs ApplicationContext 总结</h3><table><thead><tr><th>特性</th><th><strong>BeanFactory</strong></th><th><strong>ApplicationContext</strong></th></tr></thead><tbody><tr><td><strong>Bean 加载时机</strong></td><td>懒加载（按需创建）</td><td>预实例化（启动时创建单例 Bean）</td></tr><tr><td><strong>国际化支持</strong></td><td>❌</td><td>✅</td></tr><tr><td><strong>事件机制</strong></td><td>❌</td><td>✅</td></tr><tr><td><strong>AOP &#x2F; 事务</strong></td><td>手动注册 BeanPostProcessor</td><td>自动识别并应用</td></tr><tr><td><strong>资源加载</strong></td><td>基础 API</td><td>更强大的 Resource 抽象</td></tr><tr><td><strong>适用场景</strong></td><td>轻量应用、底层容器</td><td>企业级应用，大部分 Spring 项目</td></tr></tbody></table><hr><h3 id="4-常见-ApplicationContext-实现类"><a href="#4-常见-ApplicationContext-实现类" class="headerlink" title="4. 常见 ApplicationContext 实现类"></a>4. 常见 ApplicationContext 实现类</h3><ul><li><strong>ClassPathXmlApplicationContext</strong><ul><li>从 classpath 下的 XML 加载配置。</li></ul></li><li><strong>FileSystemXmlApplicationContext</strong><ul><li>从文件系统路径下加载 XML 配置。</li></ul></li><li><strong>AnnotationConfigApplicationContext</strong><ul><li>基于注解和 Java Config 的容器。</li></ul></li><li><strong>WebApplicationContext</strong><ul><li>专门为 Web 应用准备的 IoC 容器，整合 ServletContext。</li></ul></li></ul><hr><p>👉 可以这样理解：</p><ul><li><code>BeanFactory</code> 就是 IoC 的“发动机”，提供最基本的动力。</li><li><code>ApplicationContext</code> 就是加了“变速箱、车载娱乐系统、空调、智能导航”的完整汽车，更适合实际企业应用。</li></ul><p><strong>Bean的生命周期详解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例化 → 属性赋值 → 初始化前处理 → 初始化 → 初始化后处理 → 使用 → 销毁前处理 → 销毁</span><br></pre></td></tr></table></figure><p><strong>详细生命周期步骤：</strong></p><ol><li>Bean元数据解析（XML、注解、Java配置）</li><li>调用Bean构造函数实例化</li><li>依赖注入（setter方法、构造函数、字段注入）</li><li>如果实现了BeanNameAware，调用setBeanName()</li><li>如果实现了BeanFactoryAware，调用setBeanFactory()</li><li>如果实现了ApplicationContextAware，调用setApplicationContext()</li><li>如果有BeanPostProcessor，调用postProcessBeforeInitialization()</li><li>如果实现了InitializingBean，调用afterPropertiesSet()</li><li>如果配置了init-method，调用自定义初始化方法</li><li>如果有BeanPostProcessor，调用postProcessAfterInitialization()</li><li>Bean可以被使用</li><li>容器关闭时，如果实现了DisposableBean，调用destroy()</li><li>如果配置了destroy-method，调用自定义销毁方法</li></ol><h4 id="DI的三种注入方式对比"><a href="#DI的三种注入方式对比" class="headerlink" title="DI的三种注入方式对比"></a>DI的三种注入方式对比</h4><ul><li><strong>构造器注入（Constructor Injection）</strong><ul><li><strong>优点</strong>：强制依赖、依赖清晰、不可变性</li><li><strong>缺点</strong>：当依赖项过多时构造函数臃肿</li><li><strong>最佳实践</strong>：官方推荐，特别是当依赖是必需的、不可选的时候</li></ul></li><li><strong>Setter注入（Setter Injection）</strong><ul><li><strong>优点</strong>：可选依赖，灵活性高</li><li><strong>缺点</strong>：对象可能处于不完整状态，无法使用final修饰</li><li><strong>最佳实践</strong>：用于注入可选的依赖项</li></ul></li><li><strong>字段注入（Field Injection）</strong><ul><li><strong>优点</strong>：代码简洁</li><li><strong>缺点</strong>：不推荐使用，隐藏依赖、测试困难、无法使用final修饰</li></ul></li></ul><h4 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h4><p>在传统的 Java 应用中，Bean 的生命周期很简单：使用 <code>new</code> 关键字进行实例化，然后 Bean 就能被使用，不再使用时，由 Java 自动进行垃圾回收。</p><p>相比之下，Spring 管理 Bean 的生命周期就复杂多了，正确理解 Bean 的生命周期非常重要，因为 Spring 对 Bean 的管理可扩展性非常强。以下是一个 Bean 的构造过程：</p><ol><li><strong>Spring 启动</strong>：查找并加载需要被 Spring 管理的 Bean，进行 Bean 的实例化。</li><li><strong>属性注入</strong>：对 Bean 的引用和值注入到 Bean 的属性中。</li><li><strong>BeanNameAware 接口</strong>：如果 Bean 实现了 <code>BeanNameAware</code> 接口，Spring 将 Bean 的 Id 传递给 <code>setBeanName()</code> 方法。</li><li><strong>BeanFactoryAware 接口</strong>：如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，Spring 将调用 <code>setBeanFactory()</code> 方法，将 <code>BeanFactory</code> 容器实例传入。</li><li><strong>ApplicationContextAware 接口</strong>：如果 Bean 实现了 <code>ApplicationContextAware</code> 接口，Spring 将调用 Bean 的 <code>setApplicationContext()</code> 方法，将 Bean 所在的应用上下文引用传入。</li><li><strong>BeanPostProcessor (前)</strong>：如果 Bean 实现了 <code>BeanPostProcessor</code> 接口，Spring 将调用它们的 <code>postProcessBeforeInitialization()</code> 方法。</li><li><strong>InitializingBean 接口与 init-method</strong>：<ul><li>如果 Bean 实现了 <code>InitializingBean</code> 接口，Spring 将调用它们的 <code>afterPropertiesSet()</code> 方法。</li><li>如果 Bean 使用 <code>init-method</code> 声明了初始化方法，该方法也会被调用。</li></ul></li><li><strong>BeanPostProcessor (后)</strong>：如果 Bean 实现了 <code>BeanPostProcessor</code> 接口，Spring 将调用它们的 <code>postProcessAfterInitialization()</code> 方法。</li><li><strong>Bean 准备就绪</strong>：此时，Bean 已经准备就绪，可以被应用程序使用。它们将一直驻留在应用上下文中，直到应用上下文被销毁。</li><li><strong>销毁</strong>：<ul><li>如果 Bean 实现了 <code>DisposableBean</code> 接口，Spring 将调用它的 <code>destory()</code> 接口方法。</li><li>如果 Bean 使用 <code>destory-method</code> 声明了销毁方法，该方法也会被调用。</li></ul></li></ol><hr><h4 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h4><ol><li><strong>singleton</strong>：唯一的 Bean 实例，Spring 中的 Bean 默认都是单例的。</li><li><strong>prototype</strong>：每次请求都会创建一个新的 Bean 实例。</li><li><strong>request</strong>：每一次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong>：每一次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP session 内有效。</li><li><strong>global-session</strong>：全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring 5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ol><hr><h4 id="Spring-中的单例-Bean-的线程安全问题"><a href="#Spring-中的单例-Bean-的线程安全问题" class="headerlink" title="Spring 中的单例 Bean 的线程安全问题"></a>Spring 中的单例 Bean 的线程安全问题</h4><p>大多数时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为：当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。常见的有两种解决办法：</p><ol><li>在 Bean 对象中尽量避免定义可变的成员变量（不太现实）。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><hr><h4 id="对-Spring-中的事务的理解"><a href="#对-Spring-中的事务的理解" class="headerlink" title="对 Spring 中的事务的理解"></a>对 Spring 中的事务的理解</h4><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p><strong>事务特性</strong></p><ul><li><strong>原子性</strong>：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。</li><li><strong>一致性</strong>：执行事务前后，数据保持一致。</li><li><strong>隔离性</strong>：并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的。</li><li><strong>持久性</strong>：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><p><strong>Spring 事务管理接口</strong></p><ol><li><code>PlatformTransactionManager</code>：（平台）事务管理器。</li><li><code>TransactionDefinition</code>：事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）。</li><li><code>TransactionStatus</code>：事务运行状态。</li></ol><p>所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。</p><hr><h4 id="Spring-中的事务隔离级别"><a href="#Spring-中的事务隔离级别" class="headerlink" title="Spring 中的事务隔离级别"></a>Spring 中的事务隔离级别</h4><p><code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</p><ul><li><strong>TransactionDefinition.ISOLATION_DEFAULT</strong>：使用后端数据库默认的隔离级别。MySQL 默认采用 <code>REPEATABLE_READ</code> 隔离级别，Oracle 默认采用 <code>READ_COMMITTED</code> 隔离级别。</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</strong>：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED</strong>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ</strong>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE</strong>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><hr><h4 id="Spring-中的事物传播行为"><a href="#Spring-中的事物传播行为" class="headerlink" title="Spring 中的事物传播行为"></a>Spring 中的事物传播行为</h4><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在 <code>TransactionDefinition</code> 定义中包括了如下几个表示传播行为的常量：</p><p><strong>支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRED</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li><strong>TransactionDefinition.PROPAGATION_SUPPORTS</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><strong>TransactionDefinition.PROPAGATION_MANDATORY</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW</strong>：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</strong>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NEVER</strong>：以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_NESTED</strong>：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 <code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</li></ul><hr><h3 id="一、Spring-事务概念"><a href="#一、Spring-事务概念" class="headerlink" title="一、Spring 事务概念"></a>一、Spring 事务概念</h3><ul><li><strong>事务（Transaction）</strong>：一组操作的集合，要么全部成功提交，要么全部回滚，保证 <strong>ACID</strong> 特性：<ol><li><strong>原子性（Atomicity）</strong>：操作不可分割，要么全部成功，要么全部失败回滚。</li><li><strong>一致性（Consistency）</strong>：事务执行前后数据保持一致。</li><li><strong>隔离性（Isolation）</strong>：事务之间互不干扰。</li><li><strong>持久性（Durability）</strong>：事务一旦提交，数据永久保存。</li></ol></li><li><strong>Spring 事务</strong>：Spring 对事务管理的抽象与封装，可以 <strong>声明式（@Transactional）</strong> 或 <strong>编程式</strong> 管理事务，支持 <strong>JDBC、JPA、Hibernate、MyBatis 等多种事务资源</strong>。</li></ul><hr><h3 id="二、Spring-事务类型"><a href="#二、Spring-事务类型" class="headerlink" title="二、Spring 事务类型"></a>二、Spring 事务类型</h3><h4 id="1️⃣-编程式事务（Programmatic-Transaction）"><a href="#1️⃣-编程式事务（Programmatic-Transaction）" class="headerlink" title="1️⃣ 编程式事务（Programmatic Transaction）"></a>1️⃣ 编程式事务（Programmatic Transaction）</h4><ul><li>通过 <code>TransactionTemplate</code> 或 <code>PlatformTransactionManager</code> 显式控制事务：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TransactionTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(txManager);</span><br><span class="line">template.execute(status -&gt; &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>优点：灵活，可针对单个方法精细控制</li><li>缺点：代码侵入性强</li></ul><h4 id="2️⃣-声明式事务（Declarative-Transaction）"><a href="#2️⃣-声明式事务（Declarative-Transaction）" class="headerlink" title="2️⃣ 声明式事务（Declarative Transaction）"></a>2️⃣ 声明式事务（Declarative Transaction）</h4><ul><li>基于 <strong>AOP</strong>，最常用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userDao.insert(user);</span><br><span class="line">        <span class="comment">// 异常则回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：简单、可复用、与业务逻辑分离</li><li>原理：通过 <strong>代理类（JDK Proxy &#x2F; CGLIB）</strong> 拦截方法调用，在方法前开启事务，方法异常时回滚</li></ul><hr><h3 id="三、Spring-事务传播行为（Propagation）"><a href="#三、Spring-事务传播行为（Propagation）" class="headerlink" title="三、Spring 事务传播行为（Propagation）"></a>三、Spring 事务传播行为（Propagation）</h3><ul><li><p><strong>Propagation</strong> 定义事务方法被调用时的行为：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>REQUIRED</td><td>支持当前事务，没事务则新建</td></tr><tr><td>REQUIRES_NEW</td><td>新建事务，暂停当前事务</td></tr><tr><td>NESTED</td><td>嵌套事务，独立保存点</td></tr><tr><td>SUPPORTS</td><td>支持当前事务，无事务则以非事务执行</td></tr><tr><td>NOT_SUPPORTED</td><td>以非事务方式执行，暂停当前事务</td></tr><tr><td>MANDATORY</td><td>必须在事务中执行，否则抛异常</td></tr><tr><td>NEVER</td><td>不允许事务存在，否则抛异常</td></tr></tbody></table></li><li><p><strong>常用</strong>：<code>REQUIRED</code> 最常用，适合绝大部分业务场景</p></li></ul><hr><h3 id="四、Spring-事务隔离级别（Isolation）"><a href="#四、Spring-事务隔离级别（Isolation）" class="headerlink" title="四、Spring 事务隔离级别（Isolation）"></a>四、Spring 事务隔离级别（Isolation）</h3><ul><li><p><strong>隔离级别</strong>决定事务之间数据的可见性：</p><table><thead><tr><th>隔离级别</th><th>描述</th><th>对应问题</th></tr></thead><tbody><tr><td>DEFAULT</td><td>采用数据库默认隔离级别</td><td>-</td></tr><tr><td>READ_UNCOMMITTED</td><td>读未提交</td><td>脏读（Dirty Read）</td></tr><tr><td>READ_COMMITTED</td><td>读已提交</td><td>防脏读，可能不可重复读（Non-Repeatable Read）</td></tr><tr><td>REPEATABLE_READ</td><td>可重复读</td><td>防脏读和不可重复读，但幻读仍可能</td></tr><tr><td>SERIALIZABLE</td><td>可串行化</td><td>防脏读、不可重复读、幻读；性能最低</td></tr></tbody></table></li><li><p>默认 <strong>MySQL InnoDB</strong> 使用 <code>REPEATABLE_READ</code></p></li></ul><hr><h3 id="五、Spring-事务回滚规则"><a href="#五、Spring-事务回滚规则" class="headerlink" title="五、Spring 事务回滚规则"></a>五、Spring 事务回滚规则</h3><ul><li>默认回滚：<ul><li><strong>RuntimeException</strong> 和 <strong>Error</strong> 类型异常</li></ul></li><li>默认不回滚：<ul><li><strong>Checked Exception</strong>（非 RuntimeException）</li></ul></li><li>可通过 <code>rollbackFor</code> 或 <code>noRollbackFor</code> 自定义：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; ... &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="六、Spring-事务底层实现"><a href="#六、Spring-事务底层实现" class="headerlink" title="六、Spring 事务底层实现"></a>六、Spring 事务底层实现</h3><h4 id="1️⃣-核心接口"><a href="#1️⃣-核心接口" class="headerlink" title="1️⃣ 核心接口"></a>1️⃣ 核心接口</h4><ul><li><strong>PlatformTransactionManager</strong>：统一事务管理接口<ul><li>JDBC → <code>DataSourceTransactionManager</code></li><li>JPA → <code>JpaTransactionManager</code></li><li>Hibernate → <code>HibernateTransactionManager</code></li></ul></li><li><strong>TransactionStatus</strong>：事务状态</li><li><strong>TransactionDefinition</strong>：事务属性（隔离级别、传播行为、超时等）</li></ul><h4 id="2️⃣-声明式事务原理（AOP）"><a href="#2️⃣-声明式事务原理（AOP）" class="headerlink" title="2️⃣ 声明式事务原理（AOP）"></a>2️⃣ 声明式事务原理（AOP）</h4><ol><li>方法被 <code>@Transactional</code> 注解标记</li><li>Spring AOP 拦截方法调用</li><li>在方法执行前：<ul><li>获取事务管理器</li><li>开启事务或挂起已有事务（根据传播行为）</li></ul></li><li>执行目标方法</li><li>方法执行完毕：<ul><li>若无异常，提交事务</li><li>若异常，回滚事务</li></ul></li></ol><h4 id="3️⃣-数据源与事务管理"><a href="#3️⃣-数据源与事务管理" class="headerlink" title="3️⃣ 数据源与事务管理"></a>3️⃣ 数据源与事务管理</h4><ul><li>Spring 事务管理器通过 <strong>连接绑定（Connection绑定到ThreadLocal）</strong> 保证同一线程内操作同一个事务</li><li>多数据源可使用 <strong>ChainedTransactionManager</strong> 或 JTA（分布式事务）</li></ul><hr><h3 id="七、Spring-事务使用注意事项"><a href="#七、Spring-事务使用注意事项" class="headerlink" title="七、Spring 事务使用注意事项"></a>七、Spring 事务使用注意事项</h3><ol><li><p><strong>事务只对 public 方法有效</strong></p><ul><li>private&#x2F;protected 方法调用不会触发 AOP</li></ul></li><li><p><strong>同类内部方法调用不会触发事务</strong></p><ul><li>因为事务是通过代理拦截外部调用实现</li></ul></li><li><p><strong>事务方法异常处理</strong></p><ul><li>捕获异常后需要手动回滚：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br></pre></td></tr></table></figure></li><li><p><strong>事务隔离和数据库支持有关</strong></p><ul><li>MySQL InnoDB 支持多种隔离级别</li><li>Oracle 默认 <code>READ_COMMITTED</code></li></ul></li></ol><hr><h3 id="八、Spring-事务总结"><a href="#八、Spring-事务总结" class="headerlink" title="八、Spring 事务总结"></a>八、Spring 事务总结</h3><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>管理方式</td><td>编程式 &#x2F; 声明式（AOP）</td></tr><tr><td>核心接口</td><td>PlatformTransactionManager</td></tr><tr><td>传播行为</td><td>REQUIRED &#x2F; REQUIRES_NEW &#x2F; NESTED 等</td></tr><tr><td>隔离级别</td><td>DEFAULT &#x2F; READ_COMMITTED &#x2F; REPEATABLE_READ &#x2F; SERIALIZABLE</td></tr><tr><td>回滚规则</td><td>默认 RuntimeException &#x2F; Error，checked exception 可自定义</td></tr><tr><td>注意事项</td><td>同类内部方法调用不生效，private方法不生效，数据源绑定线程</td></tr></tbody></table><hr><p>💡 <strong>核心理解</strong>：</p><ul><li>Spring 事务是 <strong>对底层数据库事务的抽象和封装</strong></li><li>AOP + PlatformTransactionManager 实现 <strong>方法级事务控制</strong></li><li>通过 <strong>传播行为 + 隔离级别 + 回滚策略</strong> 灵活管理事务</li><li>多数据源或分布式场景可结合 JTA&#x2F;Seata 实现全局事务</li></ul><hr><h3 id="Spring-常用注入方式"><a href="#Spring-常用注入方式" class="headerlink" title="Spring 常用注入方式"></a>Spring 常用注入方式</h3><ol><li><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</li><li><strong>Setter 方法注入</strong>：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂方法实例化 bean 之后，调用该 bean 的 Setter 方法，即实现了基于 Setter 的依赖注入。</li><li><strong>基于注解的注入</strong>：最好的解决方案是使用构造器参数实现强制依赖，Setter 方法实现可选依赖。</li></ol><hr><h3 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h3><ol><li><strong>工厂设计模式</strong>：Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong>：Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong>：Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong>：Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 <code>Template</code> 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong>：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式</strong>：Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong>：Spring AOP 的增强或通知（Advice）使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。</li></ol><hr><h3 id="ApplicationContext-通常的实现有哪些？"><a href="#ApplicationContext-通常的实现有哪些？" class="headerlink" title="ApplicationContext 通常的实现有哪些？"></a>ApplicationContext 通常的实现有哪些？</h3><ol><li><strong>FileSystemXmlApplicationContext</strong>：此容器从一个 XML 文件中加载 beans 的定义，XML Bean 配置文件&#96;的全路径名必须提供给它的构造函数。</li><li><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个 XML 文件中加载 beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。</li><li><strong>WebXmlApplicationContext</strong>：此容器加载一个 XML 文件，此文件定义了一个 Web 应用的所有 bean。</li></ol><h4 id="AOP原理深入分析"><a href="#AOP原理深入分析" class="headerlink" title="AOP原理深入分析"></a>AOP原理深入分析</h4><p><strong>AOP实现机制：</strong> Spring AOP基于代理模式实现，支持两种代理方式：</p><ol><li><strong>JDK动态代理</strong>: 针对实现了接口的类</li><li><strong>CGLIB代理</strong>: 针对没有实现接口的类</li></ol><p>我们来系统性地讲解一下 <strong>Spring AOP 的实现机制</strong>，包括：</p><ol><li>JDK 动态代理</li><li>CGLIB 动态代理</li><li>静态代理（对比说明）</li></ol><hr><h3 id="✅-Spring-如何选择代理方式？"><a href="#✅-Spring-如何选择代理方式？" class="headerlink" title="✅ Spring 如何选择代理方式？"></a>✅ Spring 如何选择代理方式？</h3><ul><li>默认使用 JDK 动态代理（如果目标类实现了接口）。</li><li>如果目标类没有接口，Spring 自动切换为 CGLIB。</li><li>可以强制使用 CGLIB：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br></pre></td></tr></table></figure><h5 id="AOP核心概念："><a href="#AOP核心概念：" class="headerlink" title="AOP核心概念："></a><strong>AOP核心概念：</strong></h5><ul><li><strong>切面（Aspect）</strong>: 横切关注点的模块化</li><li><strong>连接点（Joinpoint）</strong>: 程序执行中的特定点</li><li><strong>切点（Pointcut）</strong>: 连接点的集合</li><li><strong>通知（Advice）</strong>: 切面在特定连接点执行的代码</li><li><strong>目标对象（Target）</strong>: 被代理的对象</li><li><strong>代理对象（Proxy）</strong>: AOP框架创建的对象</li></ul><h5 id="AOP通知类型："><a href="#AOP通知类型：" class="headerlink" title="AOP通知类型："></a>AOP通知类型：</h5><p><strong>1. 前置通知（Before advice）</strong>：在某个连接点（JoinPoint）之前执行的通知，但它不能阻止连接点之前的执行。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:before&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p><p><strong>2. 后置通知（After advice）</strong>：当某个连接点退出时执行的通知，无论是正常返回还是异常退出。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:after&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p><p><strong>3. 返回后通知（After return advice）</strong>：在某个连接点正常完成后执行的通知，不包括抛出异常的情况。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:after-returning&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p><p><strong>4. 环绕通知（Around advice）</strong>：包围一个连接点的通知，类似于 Web 中 Servlet 规范中的 <code>Filter</code> 的 <code>doFilter</code> 方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:around&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p><p><strong>5. 抛出异常后通知（After throwing advice）</strong>：在方法抛出异常退出时执行的通知。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:after-throwing&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p><p><strong>JDK动态代理 vs. CGLIB动态代理</strong></p><ul><li><strong>JDK动态代理</strong>：<ul><li>基于接口实现</li><li>使用Proxy.newProxyInstance()创建代理</li><li>只能代理实现了接口的类</li></ul></li><li><strong>CGLIB动态代理</strong>：<ul><li>基于继承实现</li><li>使用Enhancer类创建代理</li><li>可以代理普通类</li><li>不能代理final类和方法</li></ul></li></ul><h3 id="🌟-一、Spring-AOP-实现机制概述"><a href="#🌟-一、Spring-AOP-实现机制概述" class="headerlink" title="🌟 一、Spring AOP 实现机制概述"></a>🌟 一、Spring AOP 实现机制概述</h3><p>Spring AOP（面向切面编程）是基于 <strong>代理模式</strong> 实现的，它通过在目标方法执行前后织入逻辑（增强），实现横切关注点（如日志、安全、事务等）的分离。</p><blockquote><p>Spring AOP 仅支持方法级别的代理（即对方法进行增强），不支持字段、构造器等底层字节码增强（这要用 AspectJ）。</p></blockquote><hr><h3 id="🧩-二、Spring-AOP-的两种动态代理方式"><a href="#🧩-二、Spring-AOP-的两种动态代理方式" class="headerlink" title="🧩 二、Spring AOP 的两种动态代理方式"></a>🧩 二、Spring AOP 的两种动态代理方式</h3><h4 id="1️⃣-JDK-动态代理（基于接口）"><a href="#1️⃣-JDK-动态代理（基于接口）" class="headerlink" title="1️⃣ JDK 动态代理（基于接口）"></a>1️⃣ JDK 动态代理（基于接口）</h4><h4 id="✅-原理："><a href="#✅-原理：" class="headerlink" title="✅ 原理："></a>✅ 原理：</h4><ul><li>基于 Java 的 <code>java.lang.reflect.Proxy</code> 类实现。</li><li>必须要有接口，Spring 会为接口生成代理类。</li><li>代理类在运行时实现接口，并将调用委托给 InvocationHandler。</li></ul><h4 id="📦-示例："><a href="#📦-示例：" class="headerlink" title="📦 示例："></a>📦 示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring AOP 为 <code>UserService</code> 创建代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">    userService.getClass().getClassLoader(),</span><br><span class="line">    userService.getClass().getInterfaces(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="🎯-特点："><a href="#🎯-特点：" class="headerlink" title="🎯 特点："></a>🎯 特点：</h4><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>是否依赖接口</td><td>✅ 是</td></tr><tr><td>性能</td><td>较高（比 CGLIB 略快）</td></tr><tr><td>生成的代理类</td><td>实现接口</td></tr></tbody></table><hr><h4 id="2️⃣-CGLIB-动态代理（基于子类）"><a href="#2️⃣-CGLIB-动态代理（基于子类）" class="headerlink" title="2️⃣ CGLIB 动态代理（基于子类）"></a>2️⃣ CGLIB 动态代理（基于子类）</h4><h5 id="✅-原理：-1"><a href="#✅-原理：-1" class="headerlink" title="✅ 原理："></a>✅ 原理：</h5><ul><li>使用 CGLIB 库在运行时 <strong>生成目标类的子类</strong>，并重写其方法来实现增强。</li><li>适用于 <strong>没有接口</strong> 的类，或者想对类本身增强而非接口。</li></ul><h5 id="🧪-示例："><a href="#🧪-示例：" class="headerlink" title="🧪 示例："></a>🧪 示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 通过 CGLIB 生成子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">enhancer.setSuperclass(UserService.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) enhancer.create();</span><br></pre></td></tr></table></figure><h5 id="🎯-特点：-1"><a href="#🎯-特点：-1" class="headerlink" title="🎯 特点："></a>🎯 特点：</h5><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>是否依赖接口</td><td>❌ 否</td></tr><tr><td>是否可代理 final 类&#x2F;方法</td><td>❌ 否（final 无法被继承&#x2F;重写）</td></tr><tr><td>生成的代理类</td><td>子类</td></tr></tbody></table><hr><h3 id="🏗-三、静态代理（对比动态代理）"><a href="#🏗-三、静态代理（对比动态代理）" class="headerlink" title="🏗 三、静态代理（对比动态代理）"></a>🏗 三、静态代理（对比动态代理）</h3><p>✅ 原理：</p><ul><li>自己写一个代理类，<strong>实现相同接口</strong>，将方法调用委托给目标对象，并在调用前后手动添加增强逻辑。</li></ul><p>🧪 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">        target.addUser();</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🎯 特点：</p><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>是否自动生成</td><td>❌ 需手动编码</td></tr><tr><td>灵活性</td><td>差（每个类都要写一个代理类）</td></tr><tr><td>是否支持 AOP</td><td>❌ 无法动态织入多个切面</td></tr></tbody></table><hr><h3 id="🔚-四、三者对比总结"><a href="#🔚-四、三者对比总结" class="headerlink" title="🔚 四、三者对比总结"></a>🔚 四、三者对比总结</h3><table><thead><tr><th>特性</th><th>静态代理</th><th>JDK 动态代理</th><th>CGLIB 动态代理</th></tr></thead><tbody><tr><td>是否依赖接口</td><td>✅ 是</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>是否自动生成代理类</td><td>❌ 手动编写</td><td>✅ 运行时生成</td><td>✅ 运行时生成</td></tr><tr><td>是否可代理类</td><td>❌ 否（接口为主）</td><td>❌ 否（接口为主）</td><td>✅ 是（类的子类）</td></tr><tr><td>性能</td><td>一般</td><td>较高</td><td>略慢（但可接受）</td></tr><tr><td>是否支持 final 方法</td><td>✅</td><td>✅</td><td>❌ 否</td></tr></tbody></table><hr><h3 id="1-2-Spring核心注解详解"><a href="#1-2-Spring核心注解详解" class="headerlink" title="1.2 Spring核心注解详解"></a>1.2 Spring核心注解详解</h3><h4 id="基础配置注解"><a href="#基础配置注解" class="headerlink" title="基础配置注解"></a>基础配置注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">// 表示这是一个配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span>  <span class="comment">// 组件扫描</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>  <span class="comment">// 启用自动配置</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span>  <span class="comment">// SpringBoot主类注解，包含上述三个</span></span><br><span class="line"><span class="meta">@Import(OtherConfig.class)</span>  <span class="comment">// 导入其他配置类</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span>  <span class="comment">// 加载属性文件</span></span><br></pre></td></tr></table></figure><h4 id="Bean定义注解"><a href="#Bean定义注解" class="headerlink" title="Bean定义注解"></a>Bean定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">// 通用组件</span></span><br><span class="line"><span class="meta">@Service</span>    <span class="comment">// 业务层组件</span></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 数据访问层组件</span></span><br><span class="line"><span class="meta">@Controller</span> <span class="comment">// 控制层组件</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// RESTful控制器，相当于@Controller + @ResponseBody</span></span><br><span class="line"><span class="meta">@Bean</span>       <span class="comment">// 方法级别，定义Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton/prototype/request/session&quot;)</span>  <span class="comment">// Bean作用域</span></span><br><span class="line"><span class="meta">@Lazy</span>       <span class="comment">// 延迟初始化</span></span><br><span class="line"><span class="meta">@Primary</span>    <span class="comment">// 优先注入</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;beanName&quot;)</span>  <span class="comment">// 指定注入的Bean名称</span></span><br></pre></td></tr></table></figure><h4 id="依赖注入注解"><a href="#依赖注入注解" class="headerlink" title="依赖注入注解"></a>依赖注入注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>  <span class="comment">// 自动装配，可用于构造函数、方法、字段</span></span><br><span class="line"><span class="meta">@Resource</span>   <span class="comment">// JSR-250标准，按名称注入</span></span><br><span class="line"><span class="meta">@Inject</span>     <span class="comment">// JSR-330标准</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;property.name&#125;&quot;)</span>  <span class="comment">// 注入配置值</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span>  <span class="comment">// 绑定配置属性</span></span><br></pre></td></tr></table></figure><h4 id="生命周期注解"><a href="#生命周期注解" class="headerlink" title="生命周期注解"></a>生命周期注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span>  <span class="comment">// 初始化方法</span></span><br><span class="line"><span class="meta">@PreDestroy</span>     <span class="comment">// 销毁方法</span></span><br></pre></td></tr></table></figure><h4 id="AOP相关注解"><a href="#AOP相关注解" class="headerlink" title="AOP相关注解"></a>AOP相关注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>         <span class="comment">// 声明切面</span></span><br><span class="line"><span class="meta">@Pointcut</span>       <span class="comment">// 定义切点</span></span><br><span class="line"><span class="meta">@Before</span>         <span class="comment">// 前置通知</span></span><br><span class="line"><span class="meta">@After</span>          <span class="comment">// 后置通知</span></span><br><span class="line"><span class="meta">@AfterReturning</span> <span class="comment">// 返回后通知</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>  <span class="comment">// 异常通知</span></span><br><span class="line"><span class="meta">@Around</span>         <span class="comment">// 环绕通知</span></span><br></pre></td></tr></table></figure><h3 id="1-3-Spring常见使用场景"><a href="#1-3-Spring常见使用场景" class="headerlink" title="1.3 Spring常见使用场景"></a>1.3 Spring常见使用场景</h3><h4 id="场景1：服务层事务管理"><a href="#场景1：服务层事务管理" class="headerlink" title="场景1：服务层事务管理"></a>场景1：服务层事务管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景2：缓存管理"><a href="#场景2：缓存管理" class="headerlink" title="场景2：缓存管理"></a>场景2：缓存管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;products&quot;, key = &quot;#product.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productRepository.save(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-Spring常见面试问题"><a href="#1-4-Spring常见面试问题" class="headerlink" title="1.4 Spring常见面试问题"></a>1.4 Spring常见面试问题</h3><p><strong>Q1: Spring IoC容器的初始化过程是怎样的？</strong></p><p>A: Spring IoC容器初始化分为三个阶段：</p><ol><li><strong>Resource定位</strong>: 定位配置文件</li><li><strong>BeanDefinition载入</strong>: 将配置信息转换为Spring内部数据结构</li><li><strong>BeanDefinition注册</strong>: 将BeanDefinition注册到IoC容器的HashMap中</li></ol><p>具体流程：</p><ul><li>创建ApplicationContext</li><li>加载配置元数据（XML、注解、Java配置）</li><li>解析配置，创建BeanDefinition</li><li>注册BeanDefinition到BeanDefinitionRegistry</li><li>实例化非懒加载的单例Bean</li></ul><p><strong>Q2: Spring中的循环依赖是如何解决的？</strong></p><p>A: Spring通过三级缓存解决循环依赖：</p><ol><li><strong>singletonObjects</strong>: 一级缓存，存放完整的Bean实例</li><li><strong>earlySingletonObjects</strong>: 二级缓存，存放早期的Bean实例</li><li><strong>singletonFactories</strong>: 三级缓存，存放Bean工厂</li></ol><p>解决过程：</p><ul><li>A依赖B，B依赖A</li><li>创建A时，将A的工厂放入三级缓存</li><li>A需要注入B，开始创建B</li><li>B需要注入A，从缓存中获取A的早期实例</li><li>B创建完成，A继续创建完成</li></ul><p><strong>Q3: Spring AOP的实现原理？</strong></p><p>A: Spring AOP基于代理模式实现：</p><ol><li><strong>JDK动态代理</strong>: 目标类实现接口时使用，基于反射机制</li><li><strong>CGLIB代理</strong>: 目标类没有接口时使用，基于字节码技术</li></ol><p>代理创建过程：</p><ul><li>Spring在Bean初始化后，检查是否需要AOP</li><li>如果需要，创建代理对象替换原始Bean</li><li>代理对象拦截方法调用，执行切面逻辑</li></ul><h2 id="二、Spring-Boot深入解析"><a href="#二、Spring-Boot深入解析" class="headerlink" title="二、Spring Boot深入解析"></a>二、Spring Boot深入解析</h2><h3 id="2-1-Spring-Boot核心原理"><a href="#2-1-Spring-Boot核心原理" class="headerlink" title="2.1 Spring Boot核心原理"></a>2.1 Spring Boot核心原理</h3><p><strong>自动配置原理：</strong> Spring Boot通过@EnableAutoConfiguration注解启用自动配置机制。</p><p>核心类分析：</p><ol><li><strong>SpringBootApplication</strong>: 组合注解，包含@Configuration、@EnableAutoConfiguration、@ComponentScan</li><li><strong>AutoConfigurationImportSelector</strong>: 负责导入自动配置类</li><li><strong>spring.factories</strong>: META-INF&#x2F;spring.factories文件定义自动配置类</li></ol><p><strong>自动配置流程：</strong></p><ol><li>SpringBoot启动时扫描所有jar包下的META-INF&#x2F;spring.factories文件</li><li>加载文件中定义的自动配置类</li><li>根据条件注解(@ConditionalOnClass等)判断是否生效</li><li>生效的配置类会创建相应的Bean</li></ol><h3 id="2-2-Spring-Boot启动流程详解"><a href="#2-2-Spring-Boot启动流程详解" class="headerlink" title="2.2 Spring Boot启动流程详解"></a>2.2 Spring Boot启动流程详解</h3><p><strong>SpringApplication.run()方法执行流程：</strong></p><ol><li><strong>准备阶段</strong>：<ul><li>创建SpringApplication实例</li><li>确定应用类型（SERVLET、REACTIVE、NONE）</li><li>加载ApplicationContextInitializer</li><li>加载ApplicationListener</li></ul></li><li><strong>启动阶段</strong>：<ul><li>启动计时器</li><li>配置Headless模式</li><li>获取并启动监听器</li><li>准备环境（Environment）</li><li>打印Banner</li></ul></li><li><strong>容器创建阶段</strong>：<ul><li>创建ApplicationContext</li><li>准备ApplicationContext</li><li>刷新ApplicationContext</li><li>刷新后处理</li></ul></li><li><strong>完成阶段</strong>：<ul><li>停止计时器</li><li>发布启动完成事件</li><li>调用Runners</li></ul></li></ol><h3 id="2-3-Spring-Boot核心注解"><a href="#2-3-Spring-Boot核心注解" class="headerlink" title="2.3 Spring Boot核心注解"></a>2.3 Spring Boot核心注解</h3><h4 id="启动类注解"><a href="#启动类注解" class="headerlink" title="启动类注解"></a>启动类注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 等价于以下三个注解的组合</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span>  <span class="comment">// Spring Boot配置类</span></span><br><span class="line"><span class="meta">@EnableScheduling</span>        <span class="comment">// 启用定时任务</span></span><br><span class="line"><span class="meta">@EnableAsync</span>            <span class="comment">// 启用异步处理</span></span><br><span class="line"><span class="meta">@EnableCaching</span>          <span class="comment">// 启用缓存</span></span><br></pre></td></tr></table></figure><h4 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(DataSource.class)</span>      <span class="comment">// 类路径下存在指定类</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span> <span class="comment">// 容器中不存在指定Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;app.enabled&quot;, havingValue = &quot;true&quot;)</span> <span class="comment">// 属性匹配</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>               <span class="comment">// Web应用环境</span></span><br><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span>            <span class="comment">// 非Web应用环境</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span>                           <span class="comment">// 激活的profile</span></span><br></pre></td></tr></table></figure><h4 id="配置属性注解"><a href="#配置属性注解" class="headerlink" title="配置属性注解"></a>配置属性注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Spring-Boot实际应用场景"><a href="#2-4-Spring-Boot实际应用场景" class="headerlink" title="2.4 Spring Boot实际应用场景"></a>2.4 Spring Boot实际应用场景</h3><h4 id="场景1：微服务架构"><a href="#场景1：微服务架构" class="headerlink" title="场景1：微服务架构"></a>场景1：微服务架构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;order-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/orders/&#123;userId&#125;&quot;)</span></span><br><span class="line">    List&lt;Order&gt; <span class="title function_">getOrdersByUserId</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景2：数据访问层整合"><a href="#场景2：数据访问层整合" class="headerlink" title="场景2：数据访问层整合"></a>场景2：数据访问层整合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource.primary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProperties <span class="title function_">primaryDataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource.secondary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProperties <span class="title function_">secondaryDataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-Spring-Boot面试问题"><a href="#2-5-Spring-Boot面试问题" class="headerlink" title="2.5 Spring Boot面试问题"></a>2.5 Spring Boot面试问题</h3><p><strong>Q1: Spring Boot的启动原理是什么？</strong></p><p>A: Spring Boot启动原理核心在于自动配置：</p><ol><li><strong>@SpringBootApplication</strong>组合了三个注解，其中@EnableAutoConfiguration是关键</li><li><strong>AutoConfigurationImportSelector</strong>会扫描所有引入的jar包，查找其META-INF&#x2F;spring.factories文件中org.springframework.boot.autoconfigure.EnableAutoConfiguration键所对应的配置类全限定名列表</li><li>根据条件注解判断哪些自动配置类生效</li><li>生效的配置类会向容器中注册相应的Bean</li></ol><p><strong>Q2: Spring Boot如何实现自动配置？</strong></p><p>A: 自动配置通过以下机制实现：</p><ol><li><strong>条件注解</strong>: @ConditionalOnClass、@ConditionalOnBean等判断配置是否生效</li><li><strong>配置文件</strong>: spring.factories定义自动配置类列表</li><li><strong>配置属性</strong>: @ConfigurationProperties绑定配置文件中的属性</li><li><strong>默认配置</strong>: 提供合理的默认值，用户可覆盖</li></ol><p><strong>Q3: Spring Boot Starter的工作原理？</strong></p><p>A: Starter是Spring Boot自动配置的载体：</p><ol><li><strong>依赖管理</strong>: 通过Maven&#x2F;Gradle引入相关依赖</li><li><strong>自动配置</strong>: 包含AutoConfiguration类</li><li><strong>属性绑定</strong>: 提供ConfigurationProperties类</li><li><strong>条件装配</strong>: 使用条件注解控制Bean的创建</li></ol><h2 id="三、Spring-MVC深入解析"><a href="#三、Spring-MVC深入解析" class="headerlink" title="三、Spring MVC深入解析"></a>三、Spring MVC深入解析</h2><h3 id="3-1-Spring-MVC核心组件"><a href="#3-1-Spring-MVC核心组件" class="headerlink" title="3.1 Spring MVC核心组件"></a>3.1 Spring MVC核心组件</h3><p><strong>DispatcherServlet处理流程：</strong></p><ol><li><strong>接收请求</strong>: DispatcherServlet接收HTTP请求</li><li><strong>查找Handler</strong>: HandlerMapping查找处理请求的Handler</li><li><strong>获取HandlerAdapter</strong>: 获取能够执行Handler的HandlerAdapter</li><li><strong>执行Handler</strong>: HandlerAdapter执行Handler（Controller方法）</li><li><strong>处理结果</strong>: 返回ModelAndView</li><li><strong>视图解析</strong>: ViewResolver解析视图名称</li><li><strong>渲染视图</strong>: View渲染模型数据</li><li><strong>返回响应</strong>: 响应结果返回给客户端</li></ol><p><strong>核心组件详解：</strong></p><ul><li><strong>DispatcherServlet</strong>: 前端控制器，统一处理请求</li><li><strong>HandlerMapping</strong>: 处理器映射器，URL与Handler的映射</li><li><strong>HandlerAdapter</strong>: 处理器适配器，执行Handler</li><li><strong>Handler</strong>: 处理器，即Controller</li><li><strong>ViewResolver</strong>: 视图解析器</li><li><strong>View</strong>: 视图</li></ul><h3 id="3-2-Spring-MVC核心注解"><a href="#3-2-Spring-MVC核心注解" class="headerlink" title="3.2 Spring MVC核心注解"></a>3.2 Spring MVC核心注解</h3><h4 id="控制器注解"><a href="#控制器注解" class="headerlink" title="控制器注解"></a>控制器注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>             <span class="comment">// 标记控制器类</span></span><br><span class="line"><span class="meta">@RestController</span>        <span class="comment">// RESTful控制器</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span> <span class="comment">// 请求映射</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span>   <span class="comment">// GET请求映射</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span>  <span class="comment">// POST请求映射</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/users/&#123;id&#125;&quot;)</span>    <span class="comment">// PUT请求映射</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;id&#125;&quot;)</span> <span class="comment">// DELETE请求映射</span></span><br><span class="line"><span class="meta">@PatchMapping(&quot;/users/&#123;id&#125;&quot;)</span>  <span class="comment">// PATCH请求映射</span></span><br></pre></td></tr></table></figure><h4 id="参数绑定注解"><a href="#参数绑定注解" class="headerlink" title="参数绑定注解"></a>参数绑定注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam(&quot;name&quot;)</span>           <span class="comment">// 请求参数</span></span><br><span class="line"><span class="meta">@PathVariable(&quot;id&quot;)</span>            <span class="comment">// 路径变量</span></span><br><span class="line"><span class="meta">@RequestBody</span>                   <span class="comment">// 请求体</span></span><br><span class="line"><span class="meta">@RequestHeader(&quot;Content-Type&quot;)</span> <span class="comment">// 请求头</span></span><br><span class="line"><span class="meta">@CookieValue(&quot;sessionId&quot;)</span>      <span class="comment">// Cookie值</span></span><br><span class="line"><span class="meta">@ModelAttribute</span>               <span class="comment">// 模型属性</span></span><br><span class="line"><span class="meta">@SessionAttribute</span>            <span class="comment">// Session属性</span></span><br><span class="line"><span class="meta">@RequestPart</span>                 <span class="comment">// 文件上传</span></span><br></pre></td></tr></table></figure><h4 id="响应处理注解"><a href="#响应处理注解" class="headerlink" title="响应处理注解"></a>响应处理注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>              <span class="comment">// 响应体</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.CREATED)</span> <span class="comment">// 响应状态码</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>         <span class="comment">// 异常处理</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>        <span class="comment">// 全局控制器增强</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span>    <span class="comment">// RESTful全局异常处理</span></span><br></pre></td></tr></table></figure><h3 id="3-3-Spring-MVC实际应用场景"><a href="#3-3-Spring-MVC实际应用场景" class="headerlink" title="3.3 Spring MVC实际应用场景"></a>3.3 Spring MVC实际应用场景</h3><h4 id="场景1：RESTful-API开发"><a href="#场景1：RESTful-API开发" class="headerlink" title="场景1：RESTful API开发"></a>场景1：RESTful API开发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;PageResult&lt;User&gt;&gt; <span class="title function_">getUsers</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class="type">int</span> page,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(required = false)</span> String keyword)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        PageResult&lt;User&gt; result = userService.findUsers(page, size, keyword);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserCreateRequest request)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.createUser(request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).body(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">updateUser</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@PathVariable</span> Long id,</span></span><br><span class="line"><span class="params">            <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserUpdateRequest request)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.updateUser(id, request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        userService.deleteUser(id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景2：全局异常处理"><a href="#场景2：全局异常处理" class="headerlink" title="场景2：全局异常处理"></a>场景2：全局异常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(ValidationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleValidationException</span><span class="params">(ValidationException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorResponse.builder()</span><br><span class="line">                .code(<span class="string">&quot;VALIDATION_ERROR&quot;</span>)</span><br><span class="line">                .message(e.getMessage())</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(EntityNotFoundException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleEntityNotFoundException</span><span class="params">(EntityNotFoundException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorResponse.builder()</span><br><span class="line">                .code(<span class="string">&quot;ENTITY_NOT_FOUND&quot;</span>)</span><br><span class="line">                .message(e.getMessage())</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleGenericException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error occurred&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ErrorResponse.builder()</span><br><span class="line">                .code(<span class="string">&quot;INTERNAL_ERROR&quot;</span>)</span><br><span class="line">                .message(<span class="string">&quot;An unexpected error occurred&quot;</span>)</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景3：文件上传处理"><a href="#场景3：文件上传处理" class="headerlink" title="场景3：文件上传处理"></a>场景3：文件上传处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/files&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;FileUploadResponse&gt; <span class="title function_">uploadFile</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile file,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(required = false)</span> String description)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件类型验证</span></span><br><span class="line">        <span class="keyword">if</span> (!isValidFileType(file.getContentType())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidFileTypeException</span>(<span class="string">&quot;Invalid file type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件大小验证</span></span><br><span class="line">        <span class="keyword">if</span> (file.getSize() &gt; MAX_FILE_SIZE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileSizeExceededException</span>(<span class="string">&quot;File size exceeds limit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> fileService.saveFile(file, description);</span><br><span class="line">        </span><br><span class="line">        <span class="type">FileUploadResponse</span> <span class="variable">response</span> <span class="operator">=</span> FileUploadResponse.builder()</span><br><span class="line">                .fileName(fileName)</span><br><span class="line">                .originalName(file.getOriginalFilename())</span><br><span class="line">                .size(file.getSize())</span><br><span class="line">                .contentType(file.getContentType())</span><br><span class="line">                .uploadTime(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-Spring-MVC面试问题"><a href="#3-4-Spring-MVC面试问题" class="headerlink" title="3.4 Spring MVC面试问题"></a>3.4 Spring MVC面试问题</h3><p><strong>Q1: Spring MVC的执行流程是怎样的？</strong></p><p>A: Spring MVC的执行流程如下：</p><ol><li>用户发送请求到DispatcherServlet</li><li>DispatcherServlet调用HandlerMapping查找Handler</li><li>HandlerMapping返回HandlerExecutionChain（包含Handler和拦截器）</li><li>DispatcherServlet调用HandlerAdapter执行Handler</li><li>Handler执行完成后返回ModelAndView</li><li>DispatcherServlet调用ViewResolver解析视图名称</li><li>ViewResolver返回View对象</li><li>DispatcherServlet调用View的render方法渲染视图</li><li>响应结果返回给用户</li></ol><p><strong>Q2: Spring MVC中的拦截器是如何工作的？</strong></p><p>A: 拦截器基于AOP思想，在Handler执行前后进行处理：</p><ol><li><strong>HandlerInterceptor接口</strong>提供三个方法：<ul><li>preHandle(): 前置处理，返回false则中断请求</li><li>postHandle(): 后置处理，Handler执行后调用</li><li>afterCompletion(): 完成处理，视图渲染后调用</li></ul></li><li><strong>执行顺序</strong>：<ul><li>多个拦截器按配置顺序执行preHandle()</li><li>按相反顺序执行postHandle()和afterCompletion()</li></ul></li></ol><p><strong>Q3: @RequestBody和@ResponseBody的工作原理？</strong></p><p>A: 这两个注解基于HttpMessageConverter工作：</p><ol><li><strong>@RequestBody</strong>:<ul><li>使用HttpMessageConverter将HTTP请求体转换为Java对象</li><li>常用的转换器：MappingJackson2HttpMessageConverter处理JSON</li></ul></li><li><strong>@ResponseBody</strong>:<ul><li>使用HttpMessageConverter将Java对象转换为HTTP响应体</li><li>根据Accept头选择合适的转换器</li></ul></li></ol><h2 id="四、MyBatis深入解析"><a href="#四、MyBatis深入解析" class="headerlink" title="四、MyBatis深入解析"></a>四、MyBatis深入解析</h2><h3 id="4-1-MyBatis核心原理"><a href="#4-1-MyBatis核心原理" class="headerlink" title="4.1 MyBatis核心原理"></a>4.1 MyBatis核心原理</h3><p><strong>MyBatis架构分析：</strong> MyBatis采用分层架构设计：</p><ol><li><strong>API接口层</strong>: 提供给外部使用的接口API</li><li><strong>数据处理层</strong>: 参数映射、SQL解析、结果映射</li><li><strong>基础支撑层</strong>: 连接管理、事务管理、配置加载、缓存处理</li></ol><p><strong>MyBatis核心组件：</strong></p><ul><li><strong>SqlSessionFactory</strong>: 会话工厂，负责创建SqlSession</li><li><strong>SqlSession</strong>: 会话，执行SQL的核心接口</li><li><strong>Executor</strong>: 执行器，实际执行SQL</li><li><strong>StatementHandler</strong>: 语句处理器，处理SQL语句</li><li><strong>ParameterHandler</strong>: 参数处理器，处理SQL参数</li><li><strong>ResultSetHandler</strong>: 结果集处理器，处理查询结果</li><li><strong>MappedStatement</strong>: 映射语句，封装SQL配置信息</li></ul><h3 id="4-2-MyBatis执行流程详解"><a href="#4-2-MyBatis执行流程详解" class="headerlink" title="4.2 MyBatis执行流程详解"></a>4.2 MyBatis执行流程详解</h3><p><strong>SQL执行流程：</strong></p><ol><li><strong>解析配置</strong>: 解析mybatis-config.xml和Mapper XML文件</li><li><strong>创建会话</strong>: 通过SqlSessionFactory创建SqlSession</li><li><strong>获取Mapper</strong>: 通过动态代理创建Mapper接口实例</li><li><strong>执行SQL</strong>: 调用Mapper方法，转换为MappedStatement执行</li><li><strong>参数处理</strong>: ParameterHandler处理输入参数</li><li><strong>执行查询</strong>: StatementHandler执行SQL语句</li><li><strong>结果映射</strong>: ResultSetHandler处理结果集</li><li><strong>返回结果</strong>: 将结果返回给调用方</li></ol><p><strong>动态代理原理：</strong> MyBatis使用JDK动态代理为Mapper接口创建代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperProxy实现InvocationHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据方法签名找到对应的MappedStatement</span></span><br><span class="line">        <span class="comment">// 执行SQL并返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-MyBatis核心注解"><a href="#4-3-MyBatis核心注解" class="headerlink" title="4.3 MyBatis核心注解"></a>4.3 MyBatis核心注解</h3><h4 id="基础映射注解"><a href="#基础映射注解" class="headerlink" title="基础映射注解"></a>基础映射注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">findById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert(&quot;INSERT INTO users(name, email) VALUES(#&#123;name&#125;, #&#123;email&#125;)&quot;)</span></span><br><span class="line"><span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update(&quot;UPDATE users SET name = #&#123;name&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete(&quot;DELETE FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure><h4 id="高级映射注解"><a href="#高级映射注解" class="headerlink" title="高级映射注解"></a>高级映射注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果映射</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;user_id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;user_name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT user_id, user_name, create_time FROM users&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对一映射</span></span><br><span class="line"><span class="meta">@One(select = &quot;findUserById&quot;)</span></span><br><span class="line"><span class="meta">@Result(column = &quot;user_id&quot;, property = &quot;user&quot;)</span></span><br><span class="line">Order <span class="title function_">findOrderById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对多映射</span></span><br><span class="line"><span class="meta">@Many(select = &quot;findOrdersByUserId&quot;)</span></span><br><span class="line"><span class="meta">@Result(column = &quot;id&quot;, property = &quot;orders&quot;)</span></span><br><span class="line">User <span class="title function_">findUserWithOrders</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure><h4 id="动态SQL注解"><a href="#动态SQL注解" class="headerlink" title="动态SQL注解"></a>动态SQL注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;findUsers&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsers</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUsers</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (params.get(<span class="string">&quot;name&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;name LIKE CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (params.get(<span class="string">&quot;email&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;email = #&#123;email&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-MyBatis缓存机制"><a href="#4-4-MyBatis缓存机制" class="headerlink" title="4.4 MyBatis缓存机制"></a>4.4 MyBatis缓存机制</h3><p><strong>一级缓存（默认开启）：</strong></p><ul><li>作用域：SqlSession级别</li><li>生命周期：与SqlSession相同</li><li>存储：HashMap结构，key为CacheKey</li></ul><p><strong>二级缓存（需要配置）：</strong></p><ul><li>作用域：Mapper级别</li><li>生命周期：与应用程序相同</li><li>配置：@CacheNamespace注解或<cache>标签</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace(</span></span><br><span class="line"><span class="meta">    eviction = LRU.class,</span></span><br><span class="line"><span class="meta">    flushInterval = 60000,</span></span><br><span class="line"><span class="meta">    size = 1024,</span></span><br><span class="line"><span class="meta">    readWrite = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">// mapper methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-MyBatis实际应用场景"><a href="#4-5-MyBatis实际应用场景" class="headerlink" title="4.5 MyBatis实际应用场景"></a>4.5 MyBatis实际应用场景</h3><h4 id="场景1：复杂查询场景"><a href="#场景1：复杂查询场景" class="headerlink" title="场景1：复杂查询场景"></a>场景1：复杂查询场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分页查询订单</span></span><br><span class="line">    <span class="meta">@Select(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        SELECT o.*, u.name as user_name, u.email as user_email</span></span><br><span class="line"><span class="meta">        FROM orders o</span></span><br><span class="line"><span class="meta">        LEFT JOIN users u ON o.user_id = u.id</span></span><br><span class="line"><span class="meta">        WHERE o.status = #&#123;status&#125;</span></span><br><span class="line"><span class="meta">        AND o.create_time BETWEEN #&#123;startTime&#125; AND #&#123;endTime&#125;</span></span><br><span class="line"><span class="meta">        ORDER BY o.create_time DESC</span></span><br><span class="line"><span class="meta">        LIMIT #&#123;offset&#125;, #&#123;limit&#125;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;user_id&quot;, property = &quot;userId&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;user_name&quot;, property = &quot;user.name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;user_email&quot;, property = &quot;user.email&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    List&lt;OrderVO&gt; <span class="title function_">findOrdersWithUser</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;status&quot;)</span> String status,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;startTime&quot;)</span> LocalDateTime startTime,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;endTime&quot;)</span> LocalDateTime endTime,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计查询</span></span><br><span class="line">    <span class="meta">@Select(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        SELECT </span></span><br><span class="line"><span class="meta">            COUNT(*) as total_count,</span></span><br><span class="line"><span class="meta">            SUM(amount) as total_amount,</span></span><br><span class="line"><span class="meta">            AVG(amount) as avg_amount</span></span><br><span class="line"><span class="meta">        FROM orders </span></span><br><span class="line"><span class="meta">        WHERE status = #&#123;status&#125;</span></span><br><span class="line"><span class="meta">        AND create_time &gt;= #&#123;startTime&#125;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    OrderStatistics <span class="title function_">getOrderStatistics</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;status&quot;)</span> String status,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;startTime&quot;)</span> LocalDateTime startTime</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景2：批量操作场景"><a href="#场景2：批量操作场景" class="headerlink" title="场景2：批量操作场景"></a>场景2：批量操作场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BatchMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 批量插入</span></span><br><span class="line">    <span class="meta">@Insert(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        &lt;script&gt;</span></span><br><span class="line"><span class="meta">        INSERT INTO users (name, email, create_time) VALUES</span></span><br><span class="line"><span class="meta">        &lt;foreach collection=&quot;users&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="meta">            (#&#123;user.name&#125;, #&#123;user.email&#125;, #&#123;user.createTime&#125;)</span></span><br><span class="line"><span class="meta">        &lt;/foreach&gt;</span></span><br><span class="line"><span class="meta">        &lt;/script&gt;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">batchInsertUsers</span><span class="params">(<span class="meta">@Param(&quot;users&quot;)</span> List&lt;User&gt; users)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 批量更新</span></span><br><span class="line">    <span class="meta">@Update(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        &lt;script&gt;</span></span><br><span class="line"><span class="meta">        &lt;foreach collection=&quot;users&quot; item=&quot;user&quot; separator=&quot;;&quot;&gt;</span></span><br><span class="line"><span class="meta">            UPDATE users SET </span></span><br><span class="line"><span class="meta">                name = #&#123;user.name&#125;,</span></span><br><span class="line"><span class="meta">                email = #&#123;user.email&#125;,</span></span><br><span class="line"><span class="meta">                update_time = NOW()</span></span><br><span class="line"><span class="meta">            WHERE id = #&#123;user.id&#125;</span></span><br><span class="line"><span class="meta">        &lt;/foreach&gt;</span></span><br><span class="line"><span class="meta">        &lt;/script&gt;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">batchUpdateUsers</span><span class="params">(<span class="meta">@Param(&quot;users&quot;)</span> List&lt;User&gt; users)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="场景3：动态SQL场景"><a href="#场景3：动态SQL场景" class="headerlink" title="场景3：动态SQL场景"></a>场景3：动态SQL场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;searchUsers&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">searchUsers</span><span class="params">(UserSearchCriteria criteria)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">searchUsers</span><span class="params">(UserSearchCriteria criteria)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;u.*, p.name as profile_name&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;users u&quot;</span>);</span><br><span class="line">            LEFT_OUTER_JOIN(<span class="string">&quot;user_profiles p ON u.id = p.user_id&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(criteria.getName())) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.name LIKE CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(criteria.getEmail())) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.email = #&#123;email&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getMinAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.age &gt;= #&#123;minAge&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getMaxAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.age &lt;= #&#123;maxAge&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getCreateTimeStart() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.create_time &gt;= #&#123;createTimeStart&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getCreateTimeEnd() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.create_time &lt;= #&#123;createTimeEnd&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(criteria.getStatuses())) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.status IN (&quot;</span> + </span><br><span class="line">                    criteria.getStatuses().stream()</span><br><span class="line">                        .map(s -&gt; <span class="string">&quot;&#x27;&quot;</span> + s + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">                        .collect(Collectors.joining(<span class="string">&quot;,&quot;</span>)) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 排序</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(criteria.getSortField())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;desc&quot;</span>.equalsIgnoreCase(criteria.getSortDirection())) &#123;</span><br><span class="line">                    ORDER_BY(<span class="string">&quot;u.&quot;</span> + criteria.getSortField() + <span class="string">&quot; DESC&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ORDER_BY(<span class="string">&quot;u.&quot;</span> + criteria.getSortField() + <span class="string">&quot; ASC&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ORDER_BY(<span class="string">&quot;u.create_time DESC&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-MyBatis性能优化"><a href="#4-6-MyBatis性能优化" class="headerlink" title="4.6 MyBatis性能优化"></a>4.6 MyBatis性能优化</h3><h4 id="优化策略1：合理使用缓存"><a href="#优化策略1：合理使用缓存" class="headerlink" title="优化策略1：合理使用缓存"></a>优化策略1：合理使用缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启二级缓存，设置合理的缓存策略</span></span><br><span class="line"><span class="meta">@CacheNamespace(</span></span><br><span class="line"><span class="meta">    eviction = LRU.class,        // 缓存回收策略</span></span><br><span class="line"><span class="meta">    flushInterval = 300000,      // 缓存刷新间隔（5分钟）</span></span><br><span class="line"><span class="meta">    size = 1024,                 // 缓存大小</span></span><br><span class="line"><span class="meta">    readWrite = true,            // 读写缓存</span></span><br><span class="line"><span class="meta">    blocking = false             // 非阻塞缓存</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于频繁查询且变化不大的数据使用缓存</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM products WHERE category_id = #&#123;categoryId&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useCache = true)</span></span><br><span class="line">    List&lt;Product&gt; <span class="title function_">findByCategory</span><span class="params">(<span class="meta">@Param(&quot;categoryId&quot;)</span> Long categoryId)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于实时性要求高的数据禁用缓存</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM products WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useCache = false)</span></span><br><span class="line">    Product <span class="title function_">findRealTimeById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化策略2：批量操作"><a href="#优化策略2：批量操作" class="headerlink" title="优化策略2：批量操作"></a>优化策略2：批量操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用批量插入替代循环插入</span></span><br><span class="line"><span class="meta">@Insert(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    &lt;script&gt;</span></span><br><span class="line"><span class="meta">    INSERT INTO order_items (order_id, product_id, quantity, price) VALUES</span></span><br><span class="line"><span class="meta">    &lt;foreach collection=&quot;items&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="meta">        (#&#123;item.orderId&#125;, #&#123;item.productId&#125;, #&#123;item.quantity&#125;, #&#123;item.price&#125;)</span></span><br><span class="line"><span class="meta">    &lt;/foreach&gt;</span></span><br><span class="line"><span class="meta">    &lt;/script&gt;</span></span><br><span class="line"><span class="meta">&quot;&quot;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">batchInsertOrderItems</span><span class="params">(<span class="meta">@Param(&quot;items&quot;)</span> List&lt;OrderItem&gt; items)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量更新优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdateProducts</span><span class="params">(List&lt;Product&gt; products)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH)) &#123;</span><br><span class="line">        <span class="type">ProductMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ProductMapper.class);</span><br><span class="line">        <span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">            mapper.updateProduct(product);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化策略3：延迟加载"><a href="#优化策略3：延迟加载" class="headerlink" title="优化策略3：延迟加载"></a>优化策略3：延迟加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResultMap(&quot;userResultMap&quot;)</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">findUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在ResultMap中配置延迟加载</span></span><br><span class="line">&lt;resultMap id=<span class="string">&quot;userResultMap&quot;</span> type=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span>/&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;name&quot;</span> property=<span class="string">&quot;name&quot;</span>/&gt;</span><br><span class="line">    &lt;collection property=<span class="string">&quot;orders&quot;</span> </span><br><span class="line">                select=<span class="string">&quot;findOrdersByUserId&quot;</span> </span><br><span class="line">                column=<span class="string">&quot;id&quot;</span> </span><br><span class="line">                fetchType=<span class="string">&quot;lazy&quot;</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><h3 id="4-7-MyBatis常见问题与解决方案"><a href="#4-7-MyBatis常见问题与解决方案" class="headerlink" title="4.7 MyBatis常见问题与解决方案"></a>4.7 MyBatis常见问题与解决方案</h3><h4 id="问题1：N-1查询问题"><a href="#问题1：N-1查询问题" class="headerlink" title="问题1：N+1查询问题"></a>问题1：N+1查询问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题：会产生N+1次查询</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findAllUsers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM orders WHERE user_id = #&#123;userId&#125;&quot;)</span></span><br><span class="line">List&lt;Order&gt; <span class="title function_">findOrdersByUserId</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案1：使用联表查询</span></span><br><span class="line"><span class="meta">@Select(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    SELECT u.*, o.id as order_id, o.amount, o.status as order_status</span></span><br><span class="line"><span class="meta">    FROM users u</span></span><br><span class="line"><span class="meta">    LEFT JOIN orders o ON u.id = o.user_id</span></span><br><span class="line"><span class="meta">&quot;&quot;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;order_id&quot;, property = &quot;orders.id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;amount&quot;, property = &quot;orders.amount&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;order_status&quot;, property = &quot;orders.status&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersWithOrders</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案2：使用批量查询</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUsersWithOrdersOptimized</span><span class="params">(List&lt;Long&gt; userIds)</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.findUsersByIds(userIds);</span><br><span class="line">    <span class="keyword">if</span> (!users.isEmpty()) &#123;</span><br><span class="line">        List&lt;Long&gt; ids = users.stream().map(User::getId).collect(Collectors.toList());</span><br><span class="line">        List&lt;Order&gt; orders = orderMapper.findOrdersByUserIds(ids);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手动组装数据</span></span><br><span class="line">        Map&lt;Long, List&lt;Order&gt;&gt; orderMap = orders.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Order::getUserId));</span><br><span class="line">        </span><br><span class="line">        users.forEach(user -&gt; user.setOrders(orderMap.get(user.getId())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题2：大数据量查询内存溢出"><a href="#问题2：大数据量查询内存溢出" class="headerlink" title="问题2：大数据量查询内存溢出"></a>问题2：大数据量查询内存溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题：一次性加载大量数据导致内存溢出</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM large_table&quot;)</span></span><br><span class="line">List&lt;LargeData&gt; <span class="title function_">findAllData</span><span class="params">()</span>; <span class="comment">// 可能导致OOM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案1：分页查询</span></span><br><span class="line"><span class="keyword">public</span> List&lt;LargeData&gt; <span class="title function_">findAllDataWithPaging</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;LargeData&gt; allData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;LargeData&gt; pageData;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        pageData = mapper.findDataWithLimit(offset, pageSize);</span><br><span class="line">        allData.addAll(pageData);</span><br><span class="line">        offset += pageSize;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pageData.size() == pageSize);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> allData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案2：使用游标查询</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM large_table WHERE process_status = &#x27;PENDING&#x27;&quot;)</span></span><br><span class="line"><span class="meta">@Options(resultSetType = ResultSetType.FORWARD_ONLY, fetchSize = 1000)</span></span><br><span class="line">Cursor&lt;LargeData&gt; <span class="title function_">findPendingDataCursor</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processLargeData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (Cursor&lt;LargeData&gt; cursor = mapper.findPendingDataCursor()) &#123;</span><br><span class="line">        cursor.forEach(<span class="built_in">this</span>::processData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题3：SQL注入防护"><a href="#问题3：SQL注入防护" class="headerlink" title="问题3：SQL注入防护"></a>问题3：SQL注入防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险：直接拼接SQL，容易SQL注入</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = &#x27;$&#123;name&#125;&#x27;&quot;)</span> <span class="comment">// 错误示例</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByNameUnsafe</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全：使用参数绑定</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = #&#123;name&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByNameSafe</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态排序的安全处理</span></span><br><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;findUsersWithSort&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersWithSort</span><span class="params">(<span class="meta">@Param(&quot;sortField&quot;)</span> String sortField, </span></span><br><span class="line"><span class="params">                            <span class="meta">@Param(&quot;sortDirection&quot;)</span> String sortDirection)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; ALLOWED_SORT_FIELDS = </span><br><span class="line">        Set.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;create_time&quot;</span>, <span class="string">&quot;update_time&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUsersWithSort</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sortField</span> <span class="operator">=</span> (String) params.get(<span class="string">&quot;sortField&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sortDirection</span> <span class="operator">=</span> (String) params.get(<span class="string">&quot;sortDirection&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 白名单验证</span></span><br><span class="line">        <span class="keyword">if</span> (!ALLOWED_SORT_FIELDS.contains(sortField)) &#123;</span><br><span class="line">            sortField = <span class="string">&quot;id&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;DESC&quot;</span>.equalsIgnoreCase(sortDirection)) &#123;</span><br><span class="line">            sortDirection = <span class="string">&quot;ASC&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SELECT * FROM users ORDER BY &quot;</span> + sortField + <span class="string">&quot; &quot;</span> + sortDirection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-MyBatis面试高频问题"><a href="#4-8-MyBatis面试高频问题" class="headerlink" title="4.8 MyBatis面试高频问题"></a>4.8 MyBatis面试高频问题</h3><p><strong>Q1: MyBatis的执行流程是怎样的？</strong></p><p>A: MyBatis的执行流程包括以下步骤：</p><ol><li><strong>配置解析</strong>: 解析mybatis-config.xml配置文件和Mapper XML文件，创建Configuration对象</li><li><strong>SqlSessionFactory创建</strong>: 根据Configuration创建SqlSessionFactory</li><li><strong>SqlSession创建</strong>: 通过SqlSessionFactory.openSession()创建SqlSession</li><li><strong>Mapper获取</strong>: 通过SqlSession.getMapper()获取Mapper接口的代理对象</li><li><strong>方法调用</strong>: 调用Mapper接口方法，通过动态代理转换为SQL执行</li><li><strong>SQL执行</strong>: 通过Executor执行SQL，包括参数处理、语句执行、结果映射</li><li><strong>结果返回</strong>: 将执行结果返回给调用方</li></ol><p><strong>Q2: MyBatis的一级缓存和二级缓存有什么区别？</strong></p><p>A: 两级缓存的主要区别：</p><p><strong>一级缓存（默认开启）：</strong></p><ul><li>作用域：SqlSession级别</li><li>生命周期：与SqlSession相同，SqlSession关闭时缓存清空</li><li>存储结构：HashMap，key为CacheKey（由SQL、参数、分页等组成）</li><li>失效条件：执行update、insert、delete操作或手动清空</li></ul><p><strong>二级缓存（需要配置）：</strong></p><ul><li>作用域：Mapper级别，多个SqlSession可以共享</li><li>生命周期：与应用程序相同</li><li>存储结构：可配置（HashMap、LRU、FIFO等）</li><li>配置方式：@CacheNamespace注解或<cache>标签</li><li>注意事项：需要序列化，可能存在脏读问题</li></ul><p><strong>Q3: MyBatis如何防止SQL注入？</strong></p><p>A: MyBatis通过以下方式防止SQL注入：</p><ol><li><strong>参数绑定</strong>: 使用#{}而不是${}<ul><li>#{}：预编译处理，参数作为占位符传递</li><li>${}：字符串替换，直接拼接到SQL中（危险）</li></ul></li><li><strong>类型检查</strong>: MyBatis会对参数类型进行检查</li><li><strong>白名单验证</strong>: 对于动态排序等场景，使用白名单验证</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全的写法</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = #&#123;name&#125; AND age &gt; #&#123;age&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsers</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险的写法（避免使用）</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = &#x27;$&#123;name&#125;&#x27;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersUnsafe</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br></pre></td></tr></table></figure><p><strong>Q4: MyBatis中#{}和${}的区别？</strong></p><p>A: 两者的主要区别：</p><p><strong>#{}（推荐使用）：</strong></p><ul><li>预编译处理，生成PreparedStatement</li><li>参数会被处理为占位符?</li><li>可以防止SQL注入</li><li>会进行类型转换</li><li>适用于参数值传递</li></ul><p><strong>${}（谨慎使用）：</strong></p><ul><li>字符串替换，直接拼接到SQL中</li><li>不会进行预编译</li><li>存在SQL注入风险</li><li>不会进行类型转换</li><li>适用于动态表名、列名等场景</li></ul><p><strong>Q5: MyBatis的动态SQL是如何实现的？</strong></p><p>A: MyBatis的动态SQL通过以下标签实现：</p><ol><li><strong>if标签</strong>: 条件判断</li><li><strong>choose&#x2F;when&#x2F;otherwise</strong>: 类似switch-case</li><li><strong>where标签</strong>: 智能处理WHERE条件</li><li><strong>set标签</strong>: 智能处理SET语句</li><li><strong>foreach标签</strong>: 循环处理</li><li><strong>trim标签</strong>: 去除多余的字符</li></ol><p>实现原理：</p><ul><li>使用OGNL表达式进行条件判断</li><li>在SQL解析阶段根据参数值动态生成SQL</li><li>通过SqlNode树结构表示动态SQL</li><li>在执行时遍历SqlNode树生成最终SQL</li></ul><h2 id="五、框架整合与最佳实践"><a href="#五、框架整合与最佳实践" class="headerlink" title="五、框架整合与最佳实践"></a>五、框架整合与最佳实践</h2><h3 id="5-1-Spring-Boot-MyBatis整合"><a href="#5-1-Spring-Boot-MyBatis整合" class="headerlink" title="5.1 Spring Boot + MyBatis整合"></a>5.1 Spring Boot + MyBatis整合</h3><h4 id="完整配置示例"><a href="#完整配置示例" class="headerlink" title="完整配置示例"></a>完整配置示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主启动类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据源配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource.primary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProperties <span class="title function_">primaryDataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">primaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> primaryDataSourceProperties()</span><br><span class="line">                .initializeDataSourceBuilder()</span><br><span class="line">                .type(HikariDataSource.class)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        factory.setDataSource(dataSource);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// MyBatis配置</span></span><br><span class="line">        org.apache.ibatis.session.<span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">org</span>.apache.ibatis.session.Configuration();</span><br><span class="line">        config.setMapUnderscoreToCamelCase(<span class="literal">true</span>);</span><br><span class="line">        config.setLogImpl(Slf4jImpl.class);</span><br><span class="line">        config.setCacheEnabled(<span class="literal">true</span>);</span><br><span class="line">        config.setLazyLoadingEnabled(<span class="literal">true</span>);</span><br><span class="line">        config.setAggressiveLazyLoading(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        factory.setConfiguration(config);</span><br><span class="line">        <span class="keyword">return</span> factory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务管理配置"><a href="#事务管理配置" class="headerlink" title="事务管理配置"></a>事务管理配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderItemMapper orderItemMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductMapper productMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">createOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setUserId(request.getUserId());</span><br><span class="line">        order.setStatus(<span class="string">&quot;PENDING&quot;</span>);</span><br><span class="line">        order.setCreateTime(LocalDateTime.now());</span><br><span class="line">        orderMapper.insert(order);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建订单项</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">totalAmount</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">        List&lt;OrderItem&gt; orderItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (CreateOrderItemRequest itemRequest : request.getItems()) &#123;</span><br><span class="line">            <span class="comment">// 检查库存</span></span><br><span class="line">            <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productMapper.findById(itemRequest.getProductId());</span><br><span class="line">            <span class="keyword">if</span> (product == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ProductNotFoundException</span>(<span class="string">&quot;Product not found: &quot;</span> + itemRequest.getProductId());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (product.getStock() &lt; itemRequest.getQuantity()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientStockException</span>(<span class="string">&quot;Insufficient stock for product: &quot;</span> + product.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 减库存</span></span><br><span class="line">            productMapper.decreaseStock(itemRequest.getProductId(), itemRequest.getQuantity());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建订单项</span></span><br><span class="line">            <span class="type">OrderItem</span> <span class="variable">orderItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderItem</span>();</span><br><span class="line">            orderItem.setOrderId(order.getId());</span><br><span class="line">            orderItem.setProductId(itemRequest.getProductId());</span><br><span class="line">            orderItem.setQuantity(itemRequest.getQuantity());</span><br><span class="line">            orderItem.setPrice(product.getPrice());</span><br><span class="line">            orderItems.add(orderItem);</span><br><span class="line">            </span><br><span class="line">            totalAmount = totalAmount.add(</span><br><span class="line">                product.getPrice().multiply(BigDecimal.valueOf(itemRequest.getQuantity()))</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 批量插入订单项</span></span><br><span class="line">        <span class="keyword">if</span> (!orderItems.isEmpty()) &#123;</span><br><span class="line">            orderItemMapper.batchInsert(orderItems);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 更新订单总金额</span></span><br><span class="line">        order.setTotalAmount(totalAmount);</span><br><span class="line">        orderMapper.updateAmount(order.getId(), totalAmount);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> OrderDetailVO <span class="title function_">getOrderDetail</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">        <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderNotFoundException</span>(<span class="string">&quot;Order not found: &quot;</span> + orderId);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;OrderItem&gt; orderItems = orderItemMapper.findByOrderId(orderId);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> OrderDetailVO.builder()</span><br><span class="line">                .order(order)</span><br><span class="line">                .items(orderItems)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-统一异常处理"><a href="#5-2-统一异常处理" class="headerlink" title="5.2 统一异常处理"></a>5.2 统一异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(ValidationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleValidationException</span><span class="params">(ValidationException e)</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Validation error: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;VALIDATION_ERROR&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleMethodArgumentNotValid</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        List&lt;String&gt; errors = e.getBindingResult()</span><br><span class="line">                .getFieldErrors()</span><br><span class="line">                .stream()</span><br><span class="line">                .map(error -&gt; error.getField() + <span class="string">&quot;: &quot;</span> + error.getDefaultMessage())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;VALIDATION_ERROR&quot;</span>, String.join(<span class="string">&quot;, &quot;</span>, errors));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(DataIntegrityViolationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CONFLICT)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleDataIntegrityViolation</span><span class="params">(DataIntegrityViolationException e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Data integrity violation&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;DATA_CONFLICT&quot;</span>, <span class="string">&quot;Data conflict occurred&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(OptimisticLockingFailureException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CONFLICT)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleOptimisticLockingFailure</span><span class="params">(OptimisticLockingFailureException e)</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Optimistic locking failure: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;OPTIMISTIC_LOCK_ERROR&quot;</span>, <span class="string">&quot;Resource has been modified by another user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleGenericException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error occurred&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;INTERNAL_ERROR&quot;</span>, <span class="string">&quot;An unexpected error occurred&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-接口文档与验证"><a href="#5-3-接口文档与验证" class="headerlink" title="5.3 接口文档与验证"></a>5.3 接口文档与验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统一响应格式</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiResponse</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> success;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Long timestamp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResponse&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.&lt;T&gt;builder()</span><br><span class="line">                .success(<span class="literal">true</span>)</span><br><span class="line">                .code(<span class="string">&quot;SUCCESS&quot;</span>)</span><br><span class="line">                .data(data)</span><br><span class="line">                .timestamp(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResponse&lt;T&gt; <span class="title function_">error</span><span class="params">(String code, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.&lt;T&gt;builder()</span><br><span class="line">                .success(<span class="literal">false</span>)</span><br><span class="line">                .code(code)</span><br><span class="line">                .message(message)</span><br><span class="line">                .timestamp(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求参数验证</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Valid</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateUserRequest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 2, max = 20, message = &quot;用户名长度必须在2-20个字符之间&quot;)</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^[a-zA-Z0-9_\\u4e00-\\u9fa5]+$&quot;, message = &quot;用户名只能包含字母、数字、下划线和中文&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;邮箱不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 8, max = 20, message = &quot;密码长度必须在8-20个字符之间&quot;)</span></span><br><span class="line">    <span class="meta">@Pattern(</span></span><br><span class="line"><span class="meta">        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]+$&quot;,</span></span><br><span class="line"><span class="meta">        message = &quot;密码必须包含大小写字母、数字和特殊字符&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull(message = &quot;年龄不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 1, message = &quot;年龄必须大于0&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 150, message = &quot;年龄不能超过150&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;角色不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="meta">@NotBlank(message = &quot;角色名称不能为空&quot;)</span> String&gt; roles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-性能监控与优化"><a href="#5-4-性能监控与优化" class="headerlink" title="5.4 性能监控与优化"></a>5.4 性能监控与优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能监控切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerformanceMonitorAspect</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(org.springframework.web.bind.annotation.RequestMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.GetMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.PostMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.PutMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.DeleteMapping)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">monitorPerformance</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().toShortString();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">long</span> <span class="variable">executionTime</span> <span class="operator">=</span> endTime - startTime;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (executionTime &gt; <span class="number">1000</span>) &#123; <span class="comment">// 超过1秒记录警告</span></span><br><span class="line">                log.warn(<span class="string">&quot;Slow API detected: &#123;&#125; took &#123;&#125;ms&quot;</span>, methodName, executionTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;API performance: &#123;&#125; took &#123;&#125;ms&quot;</span>, methodName, executionTime);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            log.error(<span class="string">&quot;API error: &#123;&#125; took &#123;&#125;ms, error: &#123;&#125;&quot;</span>, </span><br><span class="line">                     methodName, endTime - startTime, e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库连接池监控</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceHealthIndicator</span> <span class="keyword">implements</span> <span class="title class_">HealthIndicator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Health <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> HikariDataSource) &#123;</span><br><span class="line">                <span class="type">HikariDataSource</span> <span class="variable">hikariDataSource</span> <span class="operator">=</span> (HikariDataSource) dataSource;</span><br><span class="line">                <span class="type">HikariPoolMXBean</span> <span class="variable">poolBean</span> <span class="operator">=</span> hikariDataSource.getHikariPoolMXBean();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> Health.up()</span><br><span class="line">                        .withDetail(<span class="string">&quot;database&quot;</span>, <span class="string">&quot;MySQL&quot;</span>)</span><br><span class="line">                        .withDetail(<span class="string">&quot;activeConnections&quot;</span>, poolBean.getActiveConnections())</span><br><span class="line">                        .withDetail(<span class="string">&quot;idleConnections&quot;</span>, poolBean.getIdleConnections())</span><br><span class="line">                        .withDetail(<span class="string">&quot;totalConnections&quot;</span>, poolBean.getTotalConnections())</span><br><span class="line">                        .withDetail(<span class="string">&quot;threadsAwaitingConnection&quot;</span>, poolBean.getThreadsAwaitingConnection())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection()) &#123;</span><br><span class="line">                <span class="keyword">return</span> Health.up()</span><br><span class="line">                        .withDetail(<span class="string">&quot;database&quot;</span>, connection.getMetaData().getDatabaseProductName())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down()</span><br><span class="line">                    .withDetail(<span class="string">&quot;error&quot;</span>, e.getMessage())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-高频面试综合题"><a href="#5-5-高频面试综合题" class="headerlink" title="5.5 高频面试综合题"></a>5.5 高频面试综合题</h3><p><strong>Q1: 在微服务架构中，如何设计一个高并发的订单系统？</strong></p><p>A: 设计高并发订单系统需要考虑以下几个方面：</p><p><strong>1. 架构设计：</strong></p><ul><li>使用分布式架构，订单服务、库存服务、支付服务分离</li><li>引入消息队列处理异步任务</li><li>使用Redis做缓存和分布式锁</li><li>数据库读写分离，分库分表</li></ul><p><strong>2. 并发控制：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">createOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;order:lock:&quot;</span> + request.getUserId();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分布式锁防止重复下单</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">locked</span> <span class="operator">=</span> redisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(lockKey, <span class="string">&quot;1&quot;</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderCreationException</span>(<span class="string">&quot;Order creation in progress&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 订单创建逻辑</span></span><br><span class="line">            <span class="keyword">return</span> processOrder(request);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redisTemplate.delete(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 性能优化：</strong></p><ul><li>使用批量操作减少数据库交互</li><li>合理使用缓存策略</li><li>异步处理非核心业务逻辑</li><li>数据库连接池优化</li></ul><p><strong>Q2: 如何处理分布式事务？</strong></p><p>A: 分布式事务处理方案：</p><p><strong>1. 2PC&#x2F;3PC协议：</strong></p><ul><li>强一致性，但性能较差</li><li>适用于对一致性要求极高的场景</li></ul><p><strong>2. TCC模式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TccTransaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTccService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryCreateOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// Try阶段：预留资源</span></span><br><span class="line">        orderService.reserveOrder(request);</span><br><span class="line">        stockService.reserveStock(request.getItems());</span><br><span class="line">        paymentService.reservePayment(request.getPaymentInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirmCreateOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// Confirm阶段：确认操作</span></span><br><span class="line">        orderService.confirmOrder(request);</span><br><span class="line">        stockService.confirmStock(request.getItems());</span><br><span class="line">        paymentService.confirmPayment(request.getPaymentInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancelCreateOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// Cancel阶段：回滚操作</span></span><br><span class="line">        orderService.cancelOrder(request);</span><br><span class="line">        stockService.cancelStock(request.getItems());</span><br><span class="line">        paymentService.cancelPayment(request.getPaymentInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 消息队列最终一致性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEventService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleOrderCreated</span><span class="params">(OrderCreatedEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 异步处理订单相关业务</span></span><br><span class="line">        notificationService.sendOrderNotification(event.getOrder());</span><br><span class="line">        inventoryService.updateInventory(event.getOrderItems());</span><br><span class="line">        pointsService.addPoints(event.getUserId(), event.getAmount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Q3: Spring Boot应用如何优化启动速度？</strong></p><p>A: Spring Boot启动优化策略：</p><p><strong>1. 依赖优化：</strong></p><ul><li>移除不必要的依赖</li><li>使用spring-boot-starter-web替代完整的spring-web</li><li>避免引入大量自动配置类</li></ul><p><strong>2. 配置优化：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">lazy-initialization:</span> <span class="literal">true</span>  <span class="comment"># 启用懒加载</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">none</span>           <span class="comment"># 禁用DDL自动生成</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">false</span>            <span class="comment"># 禁用SQL日志</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span>           <span class="comment"># 生产环境禁用热重启</span></span><br></pre></td></tr></table></figure><p><strong>3. JVM优化：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockExperimentalVMOptions </span><br><span class="line">     -XX:+UseZGC </span><br><span class="line">     -XX:+UseTransparentHugePages</span><br><span class="line">     -XX:MaxMetaspaceSize=256m</span><br><span class="line">     -Xms512m -Xmx1024m</span><br><span class="line">     -jar application.jar</span><br></pre></td></tr></table></figure><p><strong>4. 代码优化：</strong></p><ul><li>使用@Lazy注解延迟Bean初始化</li><li>避免在@PostConstruct中执行耗时操作</li><li>合理使用@ConditionalOn*注解</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -XX:+UseTransparentHugePages -XX:MaxMetaspaceSize=256m -Xms512m -Xmx1024m -jar application.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>java</code>: 这是启动 Java 程序的命令。</li></ul><hr><h3 id="内存管理和垃圾回收"><a href="#内存管理和垃圾回收" class="headerlink" title="内存管理和垃圾回收"></a>内存管理和垃圾回收</h3><p>这部分参数主要用于优化 JVM 的内存使用和垃圾回收机制，以获得更好的性能。</p><ul><li><code>-XX:+UnlockExperimentalVMOptions</code>: 这个参数是用来<strong>解锁实验性（experimental）的 JVM 选项</strong>。ZGC 曾经是实验性功能，所以需要这个参数才能使用。</li><li><code>-XX:+UseZGC</code>: 这条命令是启用 <strong>Z 垃圾回收器（Z Garbage Collector）</strong>。ZGC 是一种为<strong>超大堆内存</strong>（从几GB到几十TB）设计的、<strong>低延迟</strong>的垃圾回收器。它的主要目标是在垃圾回收时，尽量减少应用程序的停顿时间，这对于需要极低延迟的应用程序非常重要。</li><li><code>-XX:+UseTransparentHugePages</code>: 这个参数开启了<strong>透明大页（Transparent Huge Pages）的支持。在操作系统层面，通常内存是以 4KB 的小页来管理的。而大页（通常是 2MB 或 1GB）可以减少 CPU 在内存管理上的开销，从而提升性能，尤其对于内存占用较大</strong>的应用效果更明显。</li><li><code>-XX:MaxMetaspaceSize=256m</code>: 这个参数设置了<strong>元空间（Metaspace）的最大大小为 256MB</strong>。元空间是 JVM 存储类的元数据（如类的名称、方法、字段等信息）的地方。在 Java 8 之后，它取代了之前的“永久代”（PermGen）。</li><li><code>-Xms512m</code>: 这条命令设定了 <strong>JVM 堆的初始内存为 512MB</strong>。堆是用来存放 Java 对象的地方。<code>-Xms</code> 决定了 JVM 启动时会申请的最小内存。</li><li><code>-Xmx1024m</code>: 这条命令设定了 <strong>JVM 堆的最大内存为 1024MB（即 1GB）</strong>。这是 JVM 运行时可以使用的最大内存。当堆内存用尽时，JVM 会触发垃圾回收，如果依然不足，就会抛出 <code>OutOfMemoryError</code>。</li></ul><hr><h3 id="堆内存的传统分代结构"><a href="#堆内存的传统分代结构" class="headerlink" title="堆内存的传统分代结构"></a>堆内存的传统分代结构</h3><p>在绝大多数的垃圾回收器中（例如 CMS、G1 之前的串行和并行 GC），堆内存被分为以下几个代（Generation）：</p><h4 id="1-年轻代（Young-Generation）"><a href="#1-年轻代（Young-Generation）" class="headerlink" title="1. 年轻代（Young Generation）"></a>1. 年轻代（Young Generation）</h4><p><strong>年轻代是新对象的诞生地。</strong> 绝大多数对象，比如局部变量创建的临时对象，都会在年轻代被创建。年轻代被设计成较小且垃圾回收频率高的区域。</p><ul><li><strong>Eden 区</strong>：这是年轻代的主要部分，新创建的对象首先被分配到这里。</li><li><strong>Survivor 区（幸存者区）</strong>：有两个大小相等的 Survivor 区，通常命名为 <strong>S0</strong> 和 <strong>S1</strong>。它们的作用是保存每次垃圾回收后，还存活的对象。</li></ul><p><strong>划分比例</strong></p><p>在默认情况下，年轻代内部的划分比例通常是：</p><ul><li><strong>Eden 区 : S0 区 : S1 区 &#x3D; 8 : 1 : 1</strong></li></ul><p>这个比例可以通过 JVM 参数进行调整，比如使用 <code>-XX:SurvivorRatio=8</code>。这意味着 Eden 区的大小是单个 Survivor 区的 8 倍。</p><h4 id="2-老年代（Old-Generation）"><a href="#2-老年代（Old-Generation）" class="headerlink" title="2. 老年代（Old Generation）"></a>2. 老年代（Old Generation）</h4><p><strong>老年代用于存放生命周期较长的对象。</strong> 当一个对象在年轻代经过多次垃圾回收（通常是 15 次，这个次数也可以通过 <code>-XX:MaxTenuringThreshold</code> 参数调整）后仍然存活，或者年轻代放不下的大对象，就会被“晋升”到老年代。</p><p>老年代的垃圾回收频率远低于年轻代，但每次回收的开销更大。</p><p><strong>划分比例</strong></p><p>堆内存中，年轻代和老年代的默认划分比例通常是：</p><ul><li><strong>年轻代 : 老年代 &#x3D; 1 : 2</strong></li></ul><p>例如，如果你设置 <code>-Xms1200m -Xmx1200m</code>，那么年轻代大约是 400MB，老年代大约是 800MB。这个比例可以通过 <code>-XX:NewRatio</code> 参数来调整。例如，<code>-XX:NewRatio=2</code> 表示老年代与年轻代的大小比值为 2:1。</p><hr><h3 id="垃圾回收过程（以-Minor-GC-为例）"><a href="#垃圾回收过程（以-Minor-GC-为例）" class="headerlink" title="垃圾回收过程（以 Minor GC 为例）"></a>垃圾回收过程（以 Minor GC 为例）</h3><p>理解了这些区域，我们再来看看垃圾回收是怎么进行的：</p><ol><li>当 <strong>Eden 区</strong>满了，会触发一次 <strong>Minor GC</strong>。</li><li>Minor GC 会检查 Eden 区和其中一个 Survivor 区（比如 S0）。</li><li>它会将所有还<strong>存活的对象</strong>复制到另一个空的 Survivor 区（比如 S1）。</li><li>同时，那些<strong>不再被引用的对象</strong>则会被清理。</li><li>所有被复制到 S1 区的对象，它们的年龄（<code>age</code>）会加一。</li><li>下一次 Minor GC 发生时，同样会扫描 Eden 区和 S1 区，将存活对象复制到 S0 区，清空 Eden 和 S1 区，并增加对象的年龄。</li><li>当对象的年龄达到某个阈值时，它就会被<strong>晋升</strong>到老年代。</li></ol><h3 id="现代垃圾回收器（如-G1-和-ZGC）"><a href="#现代垃圾回收器（如-G1-和-ZGC）" class="headerlink" title="现代垃圾回收器（如 G1 和 ZGC）"></a>现代垃圾回收器（如 G1 和 ZGC）</h3><p>值得注意的是，像 <strong>G1 垃圾回收器</strong>已经打破了这种严格的分代比例。它将堆划分为一个个大小相等的<strong>区域（Region）</strong>，每个区域都可以是 Eden、Survivor 或者老年代。G1 能够更智能地选择要回收的区域，从而在保证低停顿的同时，提高吞吐量。</p><p>而 <strong>ZGC</strong> 则更进一步，如我之前所说，它<strong>完全没有年轻代、老年代的概念</strong>，而是通过着色指针和读屏障技术，在不中断应用程序的情况下并发地进行垃圾回收，实现了更低的停顿。</p><p>因此，当你使用 ZGC 时，传统的分代比例就不适用了。不过，了解传统的分代结构对于理解 Java 内存管理的基础依然非常重要。</p><p>以下是针对Spring Cloud Alibaba及其他分布式技术的深度补充，包含实现原理和核心组件的详细说明：</p><hr><h2 id="六、Spring-Security"><a href="#六、Spring-Security" class="headerlink" title="六、Spring Security"></a>六、Spring Security</h2><h3 id="Spring-Security-是什么？"><a href="#Spring-Security-是什么？" class="headerlink" title="Spring Security 是什么？**"></a>Spring Security 是什么？**</h3><ul><li>Spring Security 是一个提供认证（Authentication）与授权&#x2F;访问控制（Authorization）的企业级安全框架，功能包括：登录&#x2F;登出、权限控制、方法级安全、会话管理、CSRF 防护、加密密码、集成 OAuth2 &#x2F; OIDC &#x2F; SSO 等。</li><li>主要组件：<code>SecurityFilterChain</code>（一系列 Filter 拦截与安全处理）、<code>AuthenticationManager</code>、<code>UserDetailsService</code>（加载用户信息）、<code>GrantedAuthority</code>（权限）、密码编码器（如 <code>BCryptPasswordEncoder</code>）、<code>MethodSecurity</code>（<code>@Secured</code>、<code>@PreAuthorize</code>）等。</li><li>集成点：与 Spring MVC &#x2F; WebFlux 无缝集成，常用配置有基于 DSL 的 Java Config（Spring Security 5+ 风格）以及注解式方法安全。</li></ul><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h4 id="1-Spring-Cloud-体系"><a href="#1-Spring-Cloud-体系" class="headerlink" title="1. Spring Cloud 体系"></a><strong>1. Spring Cloud 体系</strong></h4><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h5><p>Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的<strong>规范和解决方案的集合</strong>。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。</p><p> Spring Cloud 是一套构建分布式系统的工具集合，包含很多子项目。常见模块（并非全部）：</p><ul><li><strong>Spring Cloud Config</strong>：集中式配置管理（server + client）。</li><li><strong>Spring Cloud Netflix</strong>（整合 Netflix OSS）：Eureka（服务发现）、Ribbon（客户端负载均衡，已在新版本逐步被 <code>Spring Cloud LoadBalancer</code> 取代）、Hystrix（断路器，已进入维护&#x2F;弃用，替代方案 <code>Resilience4j</code>）。</li><li><strong>Spring Cloud Gateway</strong>：API 网关&#x2F;路由。</li><li><strong>OpenFeign &#x2F; Spring Cloud OpenFeign</strong>：声明式 HTTP 客户端。</li><li><strong>Spring Cloud LoadBalancer</strong>：客户端负载均衡（替代 Ribbon）。</li><li><strong>Spring Cloud CircuitBreaker</strong>：抽象断路器，支持 Resilience4j 等实现。</li><li><strong>Spring Cloud Stream</strong>：事件&#x2F;消息驱动（Kafka&#x2F;RabbitMQ 绑定）。</li><li><strong>Spring Cloud Bus</strong>：消息总线（广播配置刷新等）。</li><li><strong>Spring Cloud Sleuth &#x2F; Zipkin &#x2F; Micrometer</strong>：分布式追踪与监控。</li><li><strong>Spring Cloud Gateway &#x2F; Zuul（老）</strong>：API 路由&#x2F;网关实现。</li><li><strong>Spring Cloud Contract</strong>：契约测试。</li><li><strong>Spring Cloud Kubernetes &#x2F; Consul &#x2F; Zookeeper</strong>：与 k8s、Consul、ZK 的整合。</li></ul><h5 id="Netflix-OSS-常用组件（部分进入维护模式）"><a href="#Netflix-OSS-常用组件（部分进入维护模式）" class="headerlink" title="Netflix OSS 常用组件（部分进入维护模式）"></a><strong>Netflix OSS 常用组件（部分进入维护模式）</strong></h5><ul><li><strong>服务注册与发现 (Service Discovery): Eureka</strong><ul><li><strong>作用</strong>: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。</li><li><strong>使用</strong>: 服务端添加 <code>spring-cloud-starter-netflix-eureka-server</code> 依赖，并使用 <code>@EnableEurekaServer</code> 注解。客户端添加 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖，并配置 Eureka Server 地址。</li></ul></li><li><strong>服务调用与负载均衡 (RPC &amp; Load Balancing): OpenFeign + Ribbon</strong><ul><li><strong>作用</strong>: Feign 让远程服务调用变得像调用本地方法一样简单。开发者只需定义一个接口，并使用 <code>@FeignClient</code> 注解，即可完成对远程服务的调用。Ribbon（现已被 Spring Cloud LoadBalancer 替代）则提供了客户端负载均衡能力，当从 Eureka 获取到多个服务实例地址时，Ribbon 会根据配置的策略（如轮询、随机）选择一个实例进行调用。</li><li><strong>使用</strong>: 添加 <code>spring-cloud-starter-openfeign</code> 依赖，在启动类上加 <code>@EnableFeignClients</code>，创建接口并使用 <code>@FeignClient(&quot;service-name&quot;)</code> 注解。</li></ul></li><li><strong>熔断与降级 (Circuit Breaker): Hystrix</strong><ul><li><strong>作用</strong>: 当某个下游服务出现故障或响应缓慢时，为了防止故障在系统中蔓延（即“服务雪崩”），熔断器会快速失败，暂时切断对该服务的调用。同时，可以执行一个预定义的降级逻辑（Fallback），例如返回一个缓存的、默认的或友好的提示信息。</li><li><strong>状态</strong>: Hystrix 已进入维护模式，官方推荐使用 Resilience4j 或其他替代方案。</li></ul></li><li><strong>API 网关 (API Gateway): Zuul</strong><ul><li><strong>作用</strong>: 作为系统的统一入口，API 网关负责请求路由、协议转换、权限校验、流量控制、日志监控等。所有外部请求都先经过网关，再由网关分发到后端的各个微服务。</li><li><strong>状态</strong>: Zuul 1.x 已进入维护模式，官方推荐使用 Spring Cloud Gateway。</li></ul></li></ul><hr><h5 id="Spring-Cloud-Alibaba-详解"><a href="#Spring-Cloud-Alibaba-详解" class="headerlink" title="Spring Cloud Alibaba 详解"></a><strong>Spring Cloud Alibaba 详解</strong></h5><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案，是 Spring Cloud 体系的重要实现。它集成了阿里巴巴开源的优秀组件，为开发者提供了更符合国内技术生态的选择。</p><ul><li><strong>服务注册与发现 &amp; 分布式配置中心: Nacos</strong><ul><li><strong>作用</strong>: Nacos (Naming and Configuration Service) 是一个功能丰富的平台，完美整合了<strong>服务注册发现</strong>和<strong>配置管理</strong>两大核心功能。<ul><li><strong>服务发现</strong>: 与 Eureka 类似，提供服务注册、发现和健康检查。但 Nacos 支持基于 DNS 和 RPC 的服务发现，并提供更实时的健康检查机制。</li><li><strong>配置管理</strong>: 可以作为分布式配置中心，对所有微服务的配置进行集中化管理。支持配置的热更新，即修改配置后无需重启服务即可生效。还支持配置的版本管理、灰度发布等高级功能。</li></ul></li><li><strong>使用</strong>:<ol><li>引入 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 和 <code>spring-cloud-starter-alibaba-nacos-config</code> 依赖。</li><li>在 <code>bootstrap.properties</code> (或 <code>.yml</code>) 文件中配置 Nacos 服务器地址和应用名。</li><li>使用 <code>@Value</code> 或 <code>@ConfigurationProperties</code> 注解即可动态获取和刷新配置。</li></ol></li></ul></li><li><strong>熔断、降级与流量控制: Sentinel</strong><ul><li><strong>作用</strong>: Sentinel 是面向分布式服务架构的“流量的守护者”，以流量为切入点，从<strong>流量控制、熔断降级、系统负载保护</strong>等多个维度保护服务的稳定性。相较于 Hystrix，Sentinel 功能更强大，提供了可视化的监控和配置平台，并且支持热点参数限流等精细化控制。</li><li><strong>核心概念</strong>:<ul><li><strong>资源 (Resource)</strong>: Sentinel 中一切皆资源，可以是一个方法、一段代码或一个服务 URL。</li><li><strong>规则 (Rule)</strong>: 定义如何保护资源，包括流控规则、降级规则、系统保护规则等。</li></ul></li><li><strong>使用</strong>:<ol><li>引入 <code>spring-cloud-starter-alibaba-sentinel</code> 依赖。</li><li>配置 Sentinel 控制台地址。</li><li>通过 <code>@SentinelResource</code> 注解来定义资源，并指定 Fallback (降级逻辑) 和 BlockHandler (流控&#x2F;熔断逻辑)。</li></ol></li></ul></li><li><strong>分布式事务解决方案: Seata</strong><ul><li><strong>作用</strong>: Seata 是一个开源的分布式事务解决方案，提供了高性能且易于使用的分布式事务服务。它支持多种事务模式，包括 AT（自动补偿）、TCC、Saga 和 XA 模式，旨在解决微服务架构下的数据一致性问题。</li><li><strong>使用</strong>: 引入 <code>spring-cloud-starter-alibaba-seata</code> 依赖，配置 Seata Server 地址，并使用 <code>@GlobalTransactional</code> 注解开启全局事务。</li></ul></li></ul><p>当然可以，我帮你做一个更深入、系统化的解析，把 <strong>Spring Cloud</strong> 和 <strong>Spring Cloud Alibaba</strong> 的架构、原理、模块功能、使用细节以及对比全部展开，甚至涉及内部原理和选型思路。</p><hr><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h2 id="1️⃣-核心目标"><a href="#1️⃣-核心目标" class="headerlink" title="1️⃣ 核心目标"></a>1️⃣ 核心目标</h2><p>Spring Cloud 的核心目标是 <strong>解决分布式微服务系统的通用基础问题</strong>，包括：</p><ol><li><strong>服务注册与发现（Service Discovery）</strong></li><li><strong>服务调用（Service Invocation）</strong></li><li><strong>负载均衡（Load Balancing）</strong></li><li><strong>断路器&#x2F;熔断（Circuit Breaker）</strong></li><li><strong>分布式配置（Configuration Management）</strong></li><li><strong>消息总线（Event Bus &#x2F; Messaging）</strong></li><li><strong>分布式链路追踪（Distributed Tracing）</strong></li></ol><hr><h2 id="2️⃣-核心模块解析"><a href="#2️⃣-核心模块解析" class="headerlink" title="2️⃣ 核心模块解析"></a>2️⃣ 核心模块解析</h2><h3 id="1-服务注册与发现"><a href="#1-服务注册与发现" class="headerlink" title="(1) 服务注册与发现"></a>(1) 服务注册与发现</h3><ul><li><strong>Eureka &#x2F; Consul &#x2F; Zookeeper</strong></li><li>功能：<ul><li>服务实例上线&#x2F;下线管理</li><li>客户端心跳维护</li><li>动态服务列表获取</li></ul></li><li>内部原理：<ul><li>Eureka 使用 <strong>心跳 + 自我保护机制</strong>，保证高可用</li><li>客户端从注册中心拉取服务列表缓存到本地，<strong>避免每次调用都访问注册中心</strong></li></ul></li></ul><h3 id="2-客户端负载均衡"><a href="#2-客户端负载均衡" class="headerlink" title="(2) 客户端负载均衡"></a>(2) 客户端负载均衡</h3><ul><li><strong>Ribbon</strong></li><li>功能：<ul><li>基于服务列表的客户端负载均衡</li><li>支持轮询、随机、加权轮询等策略</li></ul></li><li>原理：<ul><li>客户端维护服务列表缓存 → 调用前选择一个实例</li><li>与服务调用框架（如 Feign）结合使用</li></ul></li></ul><h3 id="3-声明式-REST-客户端"><a href="#3-声明式-REST-客户端" class="headerlink" title="(3) 声明式 REST 客户端"></a>(3) 声明式 REST 客户端</h3><ul><li><strong>Feign</strong></li><li>功能：<ul><li>声明式接口调用，像调用本地方法一样调用远程服务</li><li>支持集成 Ribbon 做客户端负载均衡</li></ul></li><li>内部：<ul><li>Feign 通过 <strong>动态代理 + 注解解析</strong>，生成 REST 调用实现类</li></ul></li></ul><h3 id="4-熔断与容错"><a href="#4-熔断与容错" class="headerlink" title="(4) 熔断与容错"></a>(4) 熔断与容错</h3><ul><li><strong>Hystrix &#x2F; Resilience4j</strong></li><li>功能：<ul><li>熔断（Circuit Breaker）避免级联故障</li><li>降级策略、超时控制、线程隔离</li></ul></li><li>原理：<ul><li>Hystrix 通过线程池隔离或信号量隔离调用</li><li>监控失败率，达到阈值自动打开熔断器</li><li>Resilience4j 更轻量、函数式 API，适合 Java 8+</li></ul></li></ul><h3 id="5-分布式配置管理"><a href="#5-分布式配置管理" class="headerlink" title="(5) 分布式配置管理"></a>(5) 分布式配置管理</h3><ul><li><strong>Spring Cloud Config</strong></li><li>功能：<ul><li>集中化管理配置（YAML&#x2F;Properties）</li><li>支持环境隔离、动态刷新</li></ul></li><li>原理：<ul><li>配置服务器拉取 Git&#x2F;本地文件</li><li>客户端通过 &#x2F;refresh 或 Spring Cloud Bus 自动刷新配置</li></ul></li></ul><h3 id="6-消息总线"><a href="#6-消息总线" class="headerlink" title="(6) 消息总线"></a>(6) 消息总线</h3><ul><li><strong>Spring Cloud Bus</strong></li><li>功能：<ul><li>配置刷新广播</li><li>微服务间事件传递</li></ul></li><li>原理：<ul><li>依赖消息中间件（RabbitMQ&#x2F;Kafka）</li><li>将事件广播到所有节点，实现实时通知</li></ul></li></ul><h3 id="7-分布式链路追踪"><a href="#7-分布式链路追踪" class="headerlink" title="(7) 分布式链路追踪"></a>(7) 分布式链路追踪</h3><ul><li><strong>Sleuth + Zipkin</strong></li><li>功能：<ul><li>为微服务请求生成 <strong>TraceId</strong>，跟踪跨服务调用</li><li>收集延迟、调用链等信息</li></ul></li><li>原理：<ul><li>Sleuth 在每次请求入口生成 TraceId</li><li>Zipkin 收集和可视化调用链</li></ul></li></ul><hr><h2 id="3️⃣-优势与局限"><a href="#3️⃣-优势与局限" class="headerlink" title="3️⃣ 优势与局限"></a>3️⃣ 优势与局限</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>完全与 Spring Boot 集成</li><li>模块化，按需组合</li><li>丰富的社区生态和文档</li></ul><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><ul><li>Netflix 组件部分逐步弃用（如 Hystrix）</li><li>对高并发和国内中间件支持不够友好</li><li>分布式事务、限流、消息可靠性需额外集成</li></ul><hr><h1 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h1><h2 id="1️⃣-核心目标-1"><a href="#1️⃣-核心目标-1" class="headerlink" title="1️⃣ 核心目标"></a>1️⃣ 核心目标</h2><p>在 Spring Cloud 的基础上，<strong>解决国内互联网常见中间件和业务需求</strong>：</p><ul><li><strong>服务注册与发现</strong> → Nacos</li><li><strong>配置管理</strong> → Nacos Config</li><li><strong>流量治理</strong> → Sentinel</li><li><strong>高性能 RPC</strong> → Dubbo</li><li><strong>分布式事务</strong> → Seata</li><li><strong>消息队列</strong> → RocketMQ</li></ul><hr><h2 id="2️⃣-核心组件"><a href="#2️⃣-核心组件" class="headerlink" title="2️⃣ 核心组件"></a>2️⃣ 核心组件</h2><h3 id="1-Nacos"><a href="#1-Nacos" class="headerlink" title="(1) Nacos"></a>(1) Nacos</h3><ul><li>功能：<ul><li>注册中心</li><li>配置中心</li><li>动态 DNS 解析</li></ul></li><li>原理：<ul><li>使用 <strong>长轮询 + 内存缓存</strong>，减少注册中心访问</li><li>支持集群高可用</li></ul></li><li>特点：<ul><li>配置和注册发现统一管理</li><li>支持灰度发布和动态刷新</li></ul></li></ul><h3 id="2-Sentinel"><a href="#2-Sentinel" class="headerlink" title="(2) Sentinel"></a>(2) Sentinel</h3><ul><li>功能：<ul><li>流量控制（QPS&#x2F;线程数）</li><li>降级（响应时间&#x2F;异常比例）</li><li>热点参数限流</li></ul></li><li>原理：<ul><li>使用 <strong>拦截器 + 令牌桶&#x2F;计数器算法</strong>，在 JVM 内核级限流</li></ul></li><li>优点：<ul><li>非常适合高并发场景</li><li>与 Nacos&#x2F;配置中心结合，实现动态策略更新</li></ul></li></ul><h3 id="3-Seata（分布式事务）"><a href="#3-Seata（分布式事务）" class="headerlink" title="(3) Seata（分布式事务）"></a>(3) Seata（分布式事务）</h3><ul><li>功能：<ul><li>TCC、AT、SAGA 模式分布式事务</li><li>保证跨微服务事务一致性</li></ul></li><li>原理：<ul><li>全局事务协调器（TC）</li><li>各微服务事务管理器（RM）执行本地事务并提交&#x2F;回滚</li><li>通过 Undo Log 回滚数据，确保原子性</li></ul></li></ul><h3 id="4-RocketMQ"><a href="#4-RocketMQ" class="headerlink" title="(4) RocketMQ"></a>(4) RocketMQ</h3><ul><li>功能：<ul><li>高性能消息队列</li><li>支持顺序消息、事务消息</li></ul></li><li>原理：<ul><li>Producer 写消息到 Broker</li><li>Consumer 异步拉取或订阅</li><li>分布式可靠投递</li></ul></li></ul><h3 id="5-Dubbo"><a href="#5-Dubbo" class="headerlink" title="(5) Dubbo"></a>(5) Dubbo</h3><ul><li>功能：<ul><li>高性能 RPC</li><li>服务治理、负载均衡、容错</li></ul></li><li>内部：<ul><li>使用代理 + 网络传输优化调用</li><li>支持多协议、多注册中心</li></ul></li></ul><hr><h2 id="3️⃣-Spring-Cloud-vs-Spring-Cloud-Alibaba-深度对比"><a href="#3️⃣-Spring-Cloud-vs-Spring-Cloud-Alibaba-深度对比" class="headerlink" title="3️⃣ Spring Cloud vs Spring Cloud Alibaba 深度对比"></a>3️⃣ Spring Cloud vs Spring Cloud Alibaba 深度对比</h2><table><thead><tr><th>特性</th><th>Spring Cloud</th><th>Spring Cloud Alibaba</th></tr></thead><tbody><tr><td>注册中心</td><td>Eureka&#x2F;Consul&#x2F;Zookeeper</td><td>Nacos</td></tr><tr><td>配置中心</td><td>Config Server</td><td>Nacos Config</td></tr><tr><td>流量控制</td><td>Hystrix&#x2F;Resilience4j</td><td>Sentinel</td></tr><tr><td>RPC 框架</td><td>Feign (HTTP REST)</td><td>Dubbo (高性能 RPC)</td></tr><tr><td>消息队列</td><td>RabbitMQ &#x2F; Kafka</td><td>RocketMQ</td></tr><tr><td>分布式事务</td><td>需自行集成</td><td>Seata（原生支持）</td></tr><tr><td>高并发适配</td><td>中等</td><td>优秀，国内实践丰富</td></tr><tr><td>灰度 &amp; 动态配置</td><td>Spring Cloud Bus</td><td>Nacos + Sentinel 动态策略</td></tr><tr><td>云环境</td><td>通用</td><td>阿里云生态优化</td></tr></tbody></table><hr><h2 id="4️⃣-深入理解与选型原则"><a href="#4️⃣-深入理解与选型原则" class="headerlink" title="4️⃣ 深入理解与选型原则"></a>4️⃣ 深入理解与选型原则</h2><ol><li><strong>小型或全球化微服务系统</strong>：<ul><li>Spring Cloud 即可</li><li>注重跨云、跨平台兼容性</li></ul></li><li><strong>国内互联网、大流量微服务</strong>：<ul><li>Spring Cloud Alibaba 更合适</li><li>自带 Nacos、Sentinel、Seata</li><li>性能、可靠性、动态策略更强</li></ul></li><li><strong>高并发 + 分布式事务场景</strong>：<ul><li>结合 Sentinel + Seata + Nacos 动态治理</li></ul></li><li><strong>RPC 性能要求高</strong>：<ul><li>Dubbo 高性能 RPC 替代 Feign</li><li>与 Spring Cloud Alibaba 集成，替代 HTTP REST</li></ul></li></ol><hr><h2 id="5️⃣-内部机制深入"><a href="#5️⃣-内部机制深入" class="headerlink" title="5️⃣ 内部机制深入"></a>5️⃣ 内部机制深入</h2><h3 id="1-服务注册与发现机制"><a href="#1-服务注册与发现机制" class="headerlink" title="(1) 服务注册与发现机制"></a>(1) 服务注册与发现机制</h3><ul><li><strong>Spring Cloud Eureka</strong><ul><li>客户端周期性心跳</li><li>注册中心保存服务实例元数据</li></ul></li><li><strong>Spring Cloud Alibaba Nacos</strong><ul><li>内存缓存 + 异步推送</li><li>心跳 + 长轮询机制</li><li>支持 DNS 查询和 HTTP API 查询</li></ul></li></ul><h3 id="2-流量控制机制"><a href="#2-流量控制机制" class="headerlink" title="(2) 流量控制机制"></a>(2) 流量控制机制</h3><ul><li><strong>Hystrix</strong><ul><li>线程池隔离 &#x2F; 信号量隔离</li><li>自动熔断，降级回调</li></ul></li><li><strong>Sentinel</strong><ul><li>JVM 内核限流</li><li>可按 QPS、响应时间、异常比例限流</li><li>支持参数维度限流</li></ul></li></ul><h3 id="3-配置中心刷新机制"><a href="#3-配置中心刷新机制" class="headerlink" title="(3) 配置中心刷新机制"></a>(3) 配置中心刷新机制</h3><ul><li><strong>Spring Cloud Config + Bus</strong><ul><li>配置改变 → 发布事件 → 所有客户端订阅刷新</li></ul></li><li><strong>Nacos + Spring Cloud Alibaba</strong><ul><li>配置变更 → 客户端自动推送 → 动态刷新</li><li>支持灰度发布，服务粒度控制</li></ul></li></ul><hr><h2 id="6️⃣-总结"><a href="#6️⃣-总结" class="headerlink" title="6️⃣ 总结"></a>6️⃣ 总结</h2><ul><li><strong>Spring Cloud</strong> &#x3D; 微服务基础设施 + Netflix 生态</li><li><strong>Spring Cloud Alibaba</strong> &#x3D; Spring Cloud + 国内中间件 + 高并发实践优化</li><li>核心差异：<ul><li>注册中心 → Eureka vs Nacos</li><li>配置中心 → Config vs Nacos Config</li><li>流量控制 → Hystrix vs Sentinel</li><li>RPC → Feign (HTTP) vs Dubbo (高性能)</li><li>分布式事务 → 需自集成 vs Seata 原生支持</li><li>消息队列 → Rabbit&#x2F;Kafka vs RocketMQ</li></ul></li></ul><blockquote><p>简单理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring Cloud = 微服务骨架</span><br><span class="line">Spring Cloud Alibaba = 国内优化版 + 实战组件</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="分布式-1"><a href="#分布式-1" class="headerlink" title="分布式"></a>分布式</h1><h4 id="2-分布式ID：雪花算法（Snowflake）"><a href="#2-分布式ID：雪花算法（Snowflake）" class="headerlink" title="2. 分布式ID：雪花算法（Snowflake）"></a><strong>2. 分布式ID：雪花算法（Snowflake）</strong></h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>Snowflake 是 Twitter 开源的一种分布式 ID 生成算法，它能生成一个 64 位的 <code>long</code> 型数字作为全局唯一 ID。这个 64 位的 ID 由四部分构成：</p><ul><li><strong>1位符号位</strong>: 最高位，固定为0，表示正数，无实际意义。</li><li><strong>41位时间戳 (Timestamp)</strong>: 精确到毫秒级，是 <code>(当前时间戳 - 起始时间戳)</code> 的差值。41位可以表示 (241−1) 毫秒，大约可以使用 69 年。</li><li><strong>10位工作机器ID (Worker ID)</strong>: 这 10 位可以被灵活划分，例如前 5 位代表数据中心 ID (Datacenter ID)，后 5 位代表机器 ID (Machine ID)。这样总共可以支持 210&#x3D;1024 台机器。</li><li><strong>12位序列号 (Sequence)</strong>: 表示在同一毫秒内，同一台机器上生成的 ID 序列号。12位意味着每台机器每毫秒可以生成 212&#x3D;4096 个不同的 ID。</li></ul><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a><strong>优点</strong></h5><ul><li><strong>全局唯一</strong>: 通过时间戳、机器 ID 和序列号的组合，可以保证在分布式环境下的 ID 唯一性。</li><li><strong>趋势递增</strong>: 由于时间戳在高位，所以生成的 ID 整体上是按时间趋势递增的，这对于数据库索引（特别是 B+树）非常友好，可以减少页分裂，提高插入性能。</li><li><strong>高性能</strong>: ID 在本地生成，不依赖任何外部服务（如数据库或 Redis），生成效率极高。</li><li><strong>高可用</strong>: 算法本身不依赖网络，部署简单，具有很高的可用性。</li></ul><h5 id="面试题：“雪花算法有时钟回拨问题，如何解决？”"><a href="#面试题：“雪花算法有时钟回拨问题，如何解决？”" class="headerlink" title="面试题：“雪花算法有时钟回拨问题，如何解决？”"></a><strong>面试题：“雪花算法有时钟回拨问题，如何解决？”</strong></h5><p>回答要点:</p><p>时钟回拨是指服务器时间被同步到一个过去的时间点。如果算法不做处理，可能会生成重复的 ID。解决方案通常是：在生成 ID 时，记录上一次生成 ID 时所使用的时间戳。当发现当前时间戳小于上次记录的时间戳时，就意味着发生了时钟回拨。</p><ul><li><strong>方案一（拒绝服务）</strong>: 直接抛出异常，拒绝生成 ID，等待时钟恢复正常。这种方案简单，但会暂时影响可用性，适合对 ID 连续性要求不高的场景。</li><li><strong>方案二（等待追赶）</strong>: 如果回拨幅度很小（比如几毫秒），程序可以 <code>while(currentTime &lt; lastTimestamp)</code> 这样自旋等待，直到当前时间追赶上上次的时间戳。这会造成短暂的线程阻塞。</li><li><strong>方案三（使用备用位）</strong>: 一些改进版的雪花算法会预留几位作为扩展位，当发生时钟回拨时，在这几位上做自增，从而在短时间回拨内仍能生成不同的 ID。（这种方案实现较为复杂）</li><li><strong>业界实践（美团 Leaf）</strong>: 在发生时钟回拨时，切换到另一种备用 ID 生成策略（如号段模式），或者直接报错。</li></ul><hr><h4 id="3-RBAC（基于角色的访问控制）"><a href="#3-RBAC（基于角色的访问控制）" class="headerlink" title="3. RBAC（基于角色的访问控制）"></a><strong>3. RBAC（基于角色的访问控制）</strong></h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>RBAC (Role-Based Access Control) 是一种主流且灵活的权限管理模型。它的核心思想是在 <strong>用户 (User)</strong> 和 <strong>权限 (Permission)</strong> 之间引入一个中间层——<strong>角色 (Role)</strong>。权限不再直接授予用户，而是授予角色；然后将角色分配给用户。这样，用户与权限实现了解耦，当需要修改大量用户的权限时，只需修改他们共同拥有的角色的权限即可，极大地简化了权限管理和维护。</p><h5 id="核心三要素"><a href="#核心三要素" class="headerlink" title="核心三要素"></a><strong>核心三要素</strong></h5><ul><li><strong>用户 (User)</strong>: 系统操作的主体。</li><li><strong>角色 (Role)</strong>: 权限的集合，代表了一组特定的职责或身份，如“管理员”、“文章编辑”、“普通会员”。</li><li><strong>权限 (Permission)</strong>: 对系统中特定资源进行特定操作的许可。通常用一个字符串表示，如 <code>user:create</code>、<code>order:delete</code>、<code>article:publish</code>。</li></ul><h5 id="面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”"><a href="#面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”" class="headerlink" title="面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”"></a><strong>面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”</strong></h5><p>回答要点:</p><p>一个基础的 RBAC 模型至少需要五张表：</p><ul><li><strong>用户表 (t_user)</strong>: 存储用户信息。<ul><li><code>user_id</code> (主键), <code>username</code>, <code>password</code>, …</li></ul></li><li><strong>角色表 (t_role)</strong>: 存储角色信息。<ul><li><code>role_id</code> (主键), <code>role_name</code> (角色名, 如”管理员”), <code>role_key</code> (角色标识, 如”admin”), …</li></ul></li><li><strong>权限表 (t_permission)</strong>: 存储具体的权限点信息。<ul><li><code>permission_id</code> (主键), <code>permission_name</code> (权限名称, 如“新增用户”), <code>permission_code</code> (权限标识, 如 <code>user:add</code>), <code>parent_id</code> (用于菜单层级), …</li></ul></li><li><strong>用户-角色关联表 (t_user_role)</strong>: 存储用户和角色的多对多关系。<ul><li><code>user_id</code> (外键), <code>role_id</code> (外键)。(主键是 <code>user_id</code> 和 <code>role_id</code> 的联合主键)</li></ul></li><li><strong>角色-权限关联表 (t_role_permission)</strong>: 存储角色和权限的多对多关系。<ul><li><code>role_id</code> (外键), <code>permission_id</code> (外键)。(主键是 <code>role_id</code> 和 <code>permission_id</code> 的联合主键)</li></ul></li></ul><hr><h4 id="4-Redis"><a href="#4-Redis" class="headerlink" title="**4. Redis **"></a>**4. Redis **</h4><h5 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h5><ul><li><strong>基于内存</strong>: Redis 是一个内存数据结构存储系统，所有数据都存放在内存中，因此读写速度极快。</li><li><strong>单线程模型</strong>: Redis 的核心网络模型处理客户端请求是单线程的。这避免了多线程环境下的上下文切换和锁竞争带来的开销。（注意：Redis 6.0 之后引入了多线程来处理 I&#x2F;O，但执行命令的核心仍然是单线程）。</li><li><strong>IO多路复用</strong>: 单线程能实现高性能的关键在于它使用了 IO 多路复用技术（如 Linux 下的 epoll）。该技术允许单个线程同时监听多个网络连接上的 IO 事件，当某个连接准备好读或写时，才去处理它，极大地提高了并发处理能力。</li><li><strong>丰富的数据类型</strong>: 支持 String, Hash, List, Set, Sorted Set, Bitmap, HyperLogLog, GEO 等多种数据结构。</li></ul><h5 id="缓存三大问题与解决方案"><a href="#缓存三大问题与解决方案" class="headerlink" title="缓存三大问题与解决方案"></a><strong>缓存三大问题与解决方案</strong></h5><ul><li><strong>缓存穿透</strong>:<ul><li><strong>问题</strong>: 客户端查询一个数据库和缓存中<strong>都</strong>不存在的数据。这导致每次请求都会绕过缓存，直接打到数据库上，当有大量此类请求时，会给数据库带来巨大压力。</li><li><strong>解决</strong>:<ol><li><strong>缓存空对象</strong>: 当从数据库查询不到数据时，也在缓存中存入一个特殊的空值（如 <code>null</code> 或特定字符串），并设置一个较短的过期时间。</li><li><strong>布隆过滤器 (Bloom Filter)</strong>: 在访问缓存之前，先通过布隆过滤器判断 key 是否<strong>可能</strong>存在。布隆过滤器可以高效地判断一个元素<strong>一定不存在</strong>，从而在第一层就拦截掉大量无效请求。</li></ol></li></ul></li><li><strong>缓存击穿</strong>:<ul><li><strong>问题</strong>: 某个<strong>热点 Key</strong> 在某一时刻突然失效，而此时恰好有大量的并发请求访问这个 Key，这些请求会同时穿透缓存，直接打到数据库上，可能导致数据库瞬间崩溃。</li><li><strong>解决</strong>:<ol><li><strong>设置热点 Key 永不过期</strong>: 对于一些访问极其频繁且数据相对固定的热点数据，可以考虑不设置过期时间，通过后台任务定时更新。</li><li><strong>使用分布式锁</strong>: 在查询数据库之前，先获取一个该 Key 对应的分布式锁。只有第一个获取到锁的线程才能去查询数据库并回写缓存，其他线程则等待或直接返回。</li></ol></li></ul></li><li><strong>缓存雪崩</strong>:<ul><li><strong>问题</strong>: 大量的缓存 Key 在<strong>同一时间集中失效</strong>（例如，在应用启动时缓存了大量数据，并设置了相同的过期时间），导致所有请求都瞬间涌向数据库，造成数据库压力剧增甚至宕机。</li><li><strong>解决</strong>:<ol><li><strong>过期时间加随机值</strong>: 在设置缓存的过期时间时，在一个基础时间上增加一个随机数，使得 Key 的失效时间点尽可能分散。</li><li><strong>多级缓存</strong>: 建立多级缓存体系，如 Nginx 缓存 + Redis 缓存 + JVM 本地缓存（Caffeine&#x2F;Guava Cache）。</li><li><strong>熔断降级</strong>: 使用 Hystrix 或 Sentinel 等组件，当检测到数据库压力过大时，进行熔断或降级处理，暂时不访问数据库，返回一个默认值或提示信息。</li></ol></li></ul></li></ul><hr><h4 id="5-消息队列（MQ）"><a href="#5-消息队列（MQ）" class="headerlink" title="5. 消息队列（MQ）"></a><strong>5. 消息队列（MQ）</strong></h4><h5 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a><strong>核心作用</strong></h5><ul><li><strong>异步 (Asynchronous)</strong>: 将耗时的操作（如发送邮件、生成报表）作为消息放入 MQ，主流程可以立即返回，无需等待这些操作完成，从而提高系统的响应速度和吞吐量。</li><li><strong>解耦 (Decoupling)</strong>: 生产者和消费者之间通过 MQ 进行通信，无需直接相互依赖。任何一方的修改、宕机或升级都不会影响到另一方，增强了系统的灵活性和可维护性。</li><li><strong>削峰 (Peak Shaving)</strong>: 在秒杀、大促等高并发场景下，将瞬时涌入的大量请求暂存在 MQ 中，下游的消费者系统可以按照自己的处理能力，平稳地从 MQ 中拉取并处理请求，避免了流量洪峰直接冲垮下游服务。</li></ul><h5 id="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"><a href="#面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”" class="headerlink" title="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"></a><strong>面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”</strong></h5><p><strong>回答要点</strong>:</p><ul><li><strong>消息丢失 (Message Loss)</strong>:<ul><li><strong>问题</strong>: 消息从生产者发出后，由于网络或 MQ 服务故障，未能成功到达消费者。</li><li><strong>解决</strong>:<ol><li><strong>生产者端</strong>: 开启生产者的 <code>confirm</code> 或 <code>ack</code> 机制，确保消息被 MQ 成功接收。如果发送失败，可以进行重试。</li><li><strong>MQ 服务端</strong>: 对消息进行持久化，防止 MQ 宕机导致消息丢失（如 RabbitMQ 的持久化队列和消息，Kafka 的磁盘存储）。</li><li><strong>消费者端</strong>: 消费者在处理完业务逻辑后，再向 MQ 发送确认应答（<code>ack</code>）。如果处理过程中消费者宕机，MQ 没有收到 <code>ack</code>，会将该消息重新投递给其他消费者。</li></ol></li></ul></li><li><strong>重复消费 (Duplicate Consumption)</strong>:<ul><li><strong>问题</strong>: 由于网络抖动、消费者 <code>ack</code> 超时等原因，MQ 可能会重复投递同一条消息。</li><li><strong>解决</strong>: 核心是保证消费逻辑的<strong>幂等性 (Idempotence)</strong>。即多次执行同一个操作，结果都是相同的。实现方式有：<ol><li>在数据库中为业务操作创建一个<strong>唯一键</strong>，每次操作前先检查该唯一键是否存在。</li><li>使用一个全局唯一的<strong>业务 ID</strong>（如订单号），在处理消息前，先查询这个 ID 是否已经被处理过（例如，存入 Redis Set 或数据库）。</li></ol></li></ul></li><li><strong>消息堆积 (Message Backlog)</strong>:<ul><li><strong>问题</strong>: 生产者的生产速度远大于消费者的消费速度，导致大量消息在 MQ 中积压，占用资源并可能导致消息超时丢失。</li><li><strong>解决</strong>:<ol><li><strong>水平扩展消费者</strong>: 增加消费者实例的数量，并行处理消息。这是最常用的方法。</li><li><strong>优化消费逻辑</strong>: 检查消费者代码，看是否有可以优化的慢操作（如 I&#x2F;O 密集型操作）。</li><li><strong>消息分片&#x2F;分区</strong>: 对 Topic 进行分区（Partitioning），让不同的消费者组处理不同的分区，提高并发度。</li><li><strong>增加预警监控</strong>: 对消息堆积数量设置阈值，达到阈值时及时告警，人工介入。</li></ol></li></ul></li></ul><hr><h4 id="6-分布式锁详解"><a href="#6-分布式锁详解" class="headerlink" title="6. 分布式锁详解"></a><strong>6. 分布式锁详解</strong></h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在分布式系统环境下，多个进程或服务器上的多个线程需要访问同一个共享资源时，为了保证数据的一致性和操作的原子性，需要一种机制来确保在同一时刻，只有一个客户端能够持有锁并访问该资源。</p><h5 id="实现方案对比"><a href="#实现方案对比" class="headerlink" title="实现方案对比"></a><strong>实现方案对比</strong></h5><table><thead><tr><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>基于数据库</strong></td><td>实现简单，直接利用数据库（如唯一索引、悲观锁 <code>for update</code>）。</td><td>性能开销大，有锁库锁表的风险，不可重入，不是阻塞锁，数据库单点故障问题。</td><td>并发度不高的简单场景。</td></tr><tr><td><strong>基于 ZooKeeper</strong></td><td>可靠性高，天然支持阻塞锁和可重入，解决死锁问题（临时节点），无锁过期问题，支持公平锁。</td><td>性能不如 Redis，实现复杂，依赖 ZK 集群。</td><td>对可靠性要求极高，且能容忍一定性能损耗的场景，如分布式协调。</td></tr><tr><td><strong>基于 Redis</strong></td><td>性能极高，实现相对简单，有成熟的框架 (Redisson) 可用。</td><td>可靠性相对 ZK 稍差，需要处理锁过期和业务未执行完的问题，非公平锁。</td><td>互联网高并发、对性能要求高的绝大多数场景。</td></tr></tbody></table><h5 id="基于-Redis-的实现进阶"><a href="#基于-Redis-的实现进阶" class="headerlink" title="基于 Redis 的实现进阶"></a><strong>基于 Redis 的实现进阶</strong></h5><ul><li><p>加锁的正确姿势:</p><p>使用 SET key value NX EX time 命令。</p><ul><li><p><code>SET key value</code>: 设置键值。<code>value</code> 通常是一个唯一的随机字符串（如 UUID），用于标识锁的持有者。</p></li><li><p><code>NX</code>: (if Not eXists)，确保只有在 key 不存在时才能设置成功，实现了“加锁”的原子性。</p></li><li><p>EX time: 设置一个自动过期时间（秒），防止因客户端宕机而导致死锁。</p><p>这三个参数必须在一个命令中执行，保证原子性。</p></li></ul></li><li><p><strong>解锁的正确姿势：Lua 脚本</strong></p><ul><li><p><strong>为什么需要 Lua</strong>: 解锁操作包含“判断”和“删除”两步：1. <code>GET</code> 锁的 <code>value</code>，判断是否与自己加锁时设置的随机字符串相等。2. 如果相等，则 <code>DEL</code> 锁。如果不用 Lua 脚本，在执行完第一步后，若该线程阻塞，此时锁恰好过期，另一个线程获取了锁，那么当原线程恢复执行第二步时，就会<strong>误删掉新线程的锁</strong>。</p></li><li><p><strong>Lua 脚本示例</strong>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本接收两个参数：KEYS[1] 是锁的 key，ARGV[1] 是加锁时设置的唯一值</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><p>Lua 脚本可以确保多个命令在 Redis 服务端被原子性地执行，杜绝了上述问题。</p></li><li><p><strong>Redis 乐观锁：WATCH 命令</strong></p><ul><li><p><strong>作用</strong>: <code>WATCH</code> 命令可以监视一个或多个 key，如果在事务 <code>EXEC</code> 执行之前，任何一个被监视的 key 被其他命令修改了，那么整个事务将被取消，<code>EXEC</code> 返回 <code>nil</code>。</p></li><li><p><strong>原理</strong>: 这是一种<strong>检查后设置 (Check-And-Set, CAS)</strong> 的实现。它不是真正的加锁，而是在更新数据时检查数据是否被修改过。</p></li><li><p><strong>使用场景</strong>: 适用于<strong>读多写少</strong>的并发场景，可以减少锁的开销。例如，更新商品库存。</p><ol><li><p><code>WATCH stock_key</code> &#x2F;&#x2F; 监视库存</p></li><li><p><code>current_stock = GET stock_key</code> &#x2F;&#x2F; 获取当前库存</p></li><li><p>(在客户端代码中判断 <code>current_stock</code> 是否足够)</p></li><li><p><code>MULTI</code> &#x2F;&#x2F; 开启事务</p></li><li><p><code>SET stock_key new_stock</code> &#x2F;&#x2F; 准备更新库存</p></li><li><p>EXEC &#x2F;&#x2F; 执行事务</p><p>如果从 WATCH 到 EXEC 之间 stock_key 被其他客户端修改，EXEC 将失败，此时客户端需要重试整个操作。</p></li></ol></li></ul></li></ul><h5 id="面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”"><a href="#面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”" class="headerlink" title="面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”"></a><strong>面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”</strong></h5><p>回答要点:</p><p>这是分布式锁的一个经典问题，被称为锁的超时续期问题。</p><ul><li><strong>问题根源</strong>: 我们给锁设置了一个过期时间，比如 30 秒，但业务执行了 35 秒。在第 30 秒时锁会自动释放，其他线程就能获取到锁，导致并发问题。</li><li><strong>解决方案：“看门狗”(Watchdog)机制</strong>。<ul><li><strong>原理</strong>: 比如 Java 中的 Redisson 框架就内置了看门狗。当一个线程获取锁成功后，Redisson 会启动一个后台线程（看门狗），定期（例如每 10 秒）检查该线程是否还持有锁。如果持有，并且业务仍在执行，看门狗就会自动为这个锁<strong>延长过期时间</strong>（续期），比如再续 30 秒。这个过程会一直持续，直到业务执行完毕，线程主动释放锁，看门狗才会停止。</li><li><strong>总结</strong>: 看门狗机制通过后台线程自动续期，确保了在业务执行完成之前，锁不会因为超时而提前释放，从而保证了锁的可靠性。</li></ul></li></ul><hr><h4 id="7-分布式事务详解"><a href="#7-分布式事务详解" class="headerlink" title="7. 分布式事务详解"></a><strong>7. 分布式事务详解</strong></h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在微服务架构中，一个业务操作可能需要调用多个独立的服务来共同完成（例如，电商下单操作需要调用订单服务、库存服务、积分服务）。分布式事务旨在保证这些跨服务的数据库操作能够遵循 ACID 原则，要么全部成功，要么全部回滚，以确保数据的<strong>最终一致性</strong>。</p><h5 id="解决方案深入分析"><a href="#解决方案深入分析" class="headerlink" title="解决方案深入分析"></a><strong>解决方案深入分析</strong></h5><ul><li><strong>XA (2PC&#x2F;3PC)</strong>: 两阶段&#x2F;三阶段提交协议。<ul><li><strong>角色</strong>: 事务管理器 (Transaction Manager, TM) 和 资源管理器 (Resource Manager, RM)。</li><li><strong>流程 (2PC)</strong>:<ol><li><strong>准备阶段 (Prepare)</strong>: TM 通知所有 RM 准备提交，RM 执行本地事务并锁定资源，但不提交，然后向 TM 报告准备就绪。</li><li><strong>提交&#x2F;回滚阶段 (Commit&#x2F;Rollback)</strong>: 如果所有 RM 都准备就绪，TM 通知所有 RM 提交；否则，通知所有 RM 回滚。</li></ol></li><li><strong>评价</strong>: 是一种<strong>强一致性</strong>的方案，但协议复杂，性能差，同步阻塞模型会长时间锁定资源，且协调器存在单点故障风险，在互联网高并发场景下<strong>很少使用</strong>。</li></ul></li><li><strong>TCC (Try-Confirm-Cancel)</strong>: 补偿型事务。<ul><li><strong>核心</strong>: 是一种<strong>业务层面</strong>的柔性事务方案，对代码侵入性强。</li><li><strong>流程</strong>:<ol><li><strong>Try</strong>: 对业务资源进行<strong>检查和预留</strong>。例如，扣减库存操作，Try 阶段是冻结库存。</li><li><strong>Confirm</strong>: 如果所有服务的 Try 阶段都成功，则执行所有服务的 <strong>Confirm</strong> 操作，真正完成业务。例如，将冻结的库存真实扣减。</li><li><strong>Cancel</strong>: 如果任何一个服务的 Try 阶段失败，则执行所有已成功服务的 <strong>Cancel</strong> 操作，释放预留的资源。例如，解冻之前被冻结的库存。</li></ol></li><li><strong>评价</strong>: 性能较好，数据一致性高于可靠消息方案。但开发成本极高，需要为每个操作都编写 Try, Confirm, Cancel 三个幂等的方法。</li></ul></li><li><strong>Saga 模式</strong>: 长事务解决方案。<ul><li><strong>核心</strong>: 将一个大的分布式事务拆分成多个<strong>本地事务</strong>，每个本地事务都有一个对应的<strong>补偿操作</strong>。</li><li><strong>流程</strong>:<ul><li><strong>正向执行</strong>: Saga 协调器按顺序调用 T1, T2, T3…Tn。</li><li><strong>反向补偿</strong>: 如果 Ti 失败，Saga 会按相反顺序调用前面已成功事务的补偿操作 C(i-1)…C2, C1，进行回滚。</li></ul></li><li><strong>与 TCC 对比</strong>:<ul><li>TCC 有资源<strong>预留</strong>阶段，锁资源时间长；Saga 没有预留，直接提交本地事务，锁资源时间短。</li><li>TCC 的补偿是<strong>逆向操作</strong> (Cancel)；Saga 的补偿是<strong>反向操作</strong>。</li></ul></li><li><strong>评价</strong>: 适合于业务流程长、需要保证最终一致性的场景。同样对代码有侵入性，需要设计好每个子事务的补偿逻辑。</li></ul></li><li><strong>基于可靠消息的最终一致性 (常用)</strong>:<ul><li><strong>核心</strong>: 这是微服务架构中<strong>最常用</strong>的柔性事务方案。</li><li><strong>原理</strong>: 服务 A 在执行完本地事务后，发送一条消息到 MQ。服务 B 订阅该消息，消费消息并执行自己的本地事务。</li><li><strong>关键问题</strong>: 如何保证<strong>本地事务执行</strong>和<strong>消息发送</strong>的原子性？<ul><li><strong>事务消息 (RocketMQ 支持)</strong>: 生产者先发送一条“半消息”到 MQ，MQ 收到后不投递。然后生产者执行本地事务。如果事务成功，则向 MQ 发送确认，MQ 投递该消息；如果事务失败，则通知 MQ 删除该半消息。</li><li><strong>本地消息表</strong>: 业务操作和“待发送消息”记录在同一本地事务中。一个后台任务定时扫描这张表，将消息发送到 MQ，发送成功后更新表状态。</li></ul></li><li><strong>评价</strong>: 实现了服务间的解耦，性能高，吞吐量大。但它不保证数据的强一致性，只保证<strong>最终一致性</strong>，存在一个短暂的数据不一致状态窗口。需要处理好消息的可靠投递和幂等消费问题。</li></ul></li></ul><h1 id="Lua-脚本详解"><a href="#Lua-脚本详解" class="headerlink" title="Lua 脚本详解"></a><strong>Lua 脚本详解</strong></h1><h4 id="1-Lua-是什么？"><a href="#1-Lua-是什么？" class="headerlink" title="1. Lua 是什么？"></a><strong>1. Lua 是什么？</strong></h4><p>Lua 是一种轻量级、可扩展的脚本语言，被设计用于嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。它以其简洁的语法、高效的执行性能和极小的内存占用而闻名。</p><p>在 Redis 的上下文中，Lua 脚本提供了一种在 Redis 服务器端执行复杂逻辑的强大能力。</p><h4 id="2-为什么-Redis-要支持-Lua-脚本？"><a href="#2-为什么-Redis-要支持-Lua-脚本？" class="headerlink" title="2. 为什么 Redis 要支持 Lua 脚本？"></a><strong>2. 为什么 Redis 要支持 Lua 脚本？</strong></h4><ul><li><strong>原子性 (Atomicity)</strong>: 这是在 Redis 中使用 Lua 最核心的原因。Redis 会将整个 Lua 脚本作为一个单独的命令来执行，<strong>在脚本执行期间，不会有其他客户端的命令被插入执行</strong>。这完美地解决了需要组合多个 Redis 命令才能完成一个业务逻辑时，可能出现的竞态条件问题。例如前面提到的“判断锁并删除锁”的操作，如果分两步执行，就不是原子的，而封装在 Lua 脚本中就是原子的。</li><li><strong>减少网络开销</strong>: 对于需要多次与 Redis 交互的复杂操作，可以将所有逻辑封装在一个 Lua 脚本中，一次性发送给 Redis 服务器。客户端只需发送一次请求，而不是多次，这显著减少了客户端与服务器之间的网络往返时间（RTT），提升了性能。</li><li><strong>代码复用</strong>: 编写好的 Lua 脚本可以被缓存（通过 <code>SCRIPT LOAD</code> 命令生成一个 SHA1 校验和），之后客户端可以通过这个简短的 SHA1 校验和（使用 <code>EVALSHA</code> 命令）来调用脚本，避免了每次都发送完整的脚本内容。</li></ul><h4 id="3-如何在-Redis-中使用-Lua-脚本？"><a href="#3-如何在-Redis-中使用-Lua-脚本？" class="headerlink" title="3. 如何在 Redis 中使用 Lua 脚本？"></a><strong>3. 如何在 Redis 中使用 Lua 脚本？</strong></h4><p>通过 EVAL 或 EVALSHA 命令来执行。</p><p>EVAL script numkeys key [key …] arg [arg …]</p><ul><li><code>script</code>: 要执行的 Lua 脚本字符串。</li><li><code>numkeys</code>: 后面跟的 <code>key</code> 参数的数量。这有助于 Redis 正确地将参数区分为键名（<code>KEYS</code>）和普通参数（<code>ARGV</code>），这对于 Redis Cluster 模式下的路由至关重要。</li><li><code>key [key ...]</code>：脚本中要操作的 Redis 键，在 Lua 脚本中可以通过全局变量 <code>KEYS</code> table（例如 <code>KEYS[1]</code>）来访问。</li><li><code>arg [arg ...]</code>：传递给脚本的额外参数，在 Lua 脚本中可以通过全局变量 <code>ARGV</code> table（例如 <code>ARGV[1]</code>）来访问。</li></ul><p><strong>示例：实现一个安全的库存扣减</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本逻辑：检查库存是否充足，如果充足则扣减并返回1，否则返回0</span></span><br><span class="line"><span class="comment">-- KEYS[1]: 库存的 key，例如 &quot;product:1001:stock&quot;</span></span><br><span class="line"><span class="comment">-- ARGV[1]: 本次要扣减的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">local</span> quantity = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> stock &gt;= quantity <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;decrby&#x27;</span>, KEYS[<span class="number">1</span>], quantity)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个脚本保证了“读取库存”和“扣减库存”两个操作的原子性，避免了在高并发下超卖的问题。</p><hr><h1 id="Token-认证机制详解"><a href="#Token-认证机制详解" class="headerlink" title="Token 认证机制详解"></a><strong>Token 认证机制详解</strong></h1><h4 id="1-Token-是什么？"><a href="#1-Token-是什么？" class="headerlink" title="1. Token 是什么？"></a><strong>1. Token 是什么？</strong></h4><p>Token（令牌）是在服务端生成的一串加密字符串，作为客户端进行请求的一个“凭证”。当用户第一次登录成功后，服务端会生成一个 Token 并返回给客户端。之后，客户端在每次请求需要身份认证的接口时，都需要在请求头（通常是 <code>Authorization</code> 字段）中携带这个 Token。服务端接收到请求后，会验证 Token 的有效性，如果验证通过，则处理该请求；否则，拒绝该请求。</p><p>一个典型的 Token 是 <strong>JWT (JSON Web Token)</strong>，它由三部分组成，用 <code>.</code> 分隔：</p><ul><li><strong>Header (头部)</strong>: 包含了令牌的类型（<code>typ</code>，即 JWT）和所使用的签名算法（<code>alg</code>，如 HMAC SHA256 或 RSA）。</li><li><strong>Payload (负载)</strong>: 包含了“声明 (claims)”，是存放实际需要传递的数据的地方。例如用户ID（<code>sub</code>）、签发时间（<code>iat</code>）、过期时间（<code>exp</code>）以及其他自定义的用户信息。<strong>注意：Payload 部分是 Base64 编码的，并非加密，因此不应存放敏感信息。</strong></li><li><strong>Signature (签名)</strong>: 对前两部分（Header 和 Payload）使用指定的算法和存储在服务端的密钥（secret）进行签名。这个签名的作用是<strong>防止数据被篡改</strong>。服务端收到 Token 后，会用同样的算法和密钥重新计算签名，并与 Token 中的签名进行比对，若一致，则说明 Token 未被篡改且是可信的。</li></ul><h4 id="2-Token-认证原理（工作流程）"><a href="#2-Token-认证原理（工作流程）" class="headerlink" title="2. Token 认证原理（工作流程）"></a><strong>2. Token 认证原理（工作流程）</strong></h4><ol><li><strong>登录</strong>: 用户使用用户名和密码发起登录请求。</li><li><strong>验证</strong>: 服务端验证用户的凭据是否正确。</li><li><strong>签发 Token</strong>: 验证成功后，服务端根据用户ID、角色等信息，结合密钥（secret），生成一个 Token。</li><li><strong>返回 Token</strong>: 服务端将生成的 Token 返回给客户端。</li><li><strong>存储 Token</strong>: 客户端（浏览器、App）将 Token 存储起来，通常放在 <code>localStorage</code>、<code>sessionStorage</code> 或 <code>HttpOnly</code> 的 Cookie 中。</li><li><strong>携带 Token 请求</strong>: 客户端在后续每次请求受保护的 API 时，都会在 HTTP 请求头的 <code>Authorization</code> 字段中附上 Token，格式通常为 <code>Bearer &lt;token&gt;</code>。</li><li><strong>验证 Token</strong>: 服务端收到请求后，从请求头中解析出 Token，然后：<ul><li>验证签名是否正确，确保 Token 未被篡改。</li><li>检查 Token 是否在有效期内（<code>exp</code> 声明）。</li><li>如果验证通过，则从 Payload 中获取用户信息，执行业务逻辑并返回结果。</li><li>如果验证失败，则返回 <code>401 Unauthorized</code> 错误。</li></ul></li></ol><h4 id="3-为什么使用-Token？（与-Session-的区别）"><a href="#3-为什么使用-Token？（与-Session-的区别）" class="headerlink" title="3. 为什么使用 Token？（与 Session 的区别）"></a><strong>3. 为什么使用 Token？（与 Session 的区别）</strong></h4><p>在 Web 开发早期，<code>Session-Cookie</code> 机制是主流。服务端在用户登录后创建一个 Session 对象存储在内存或 Redis 中，并生成一个 Session ID，通过 Cookie 返回给浏览器。浏览器后续请求会自动带上这个 Session ID，服务端根据 ID 找到对应的 Session 信息来识别用户。</p><p><strong>Token 机制相比 Session 机制，核心优势在于“无状态性 (Statelessness)”</strong>，这带来了以下好处：</p><table><thead><tr><th>特性对比</th><th>Session 机制</th><th>Token 机制</th><th>优势说明</th></tr></thead><tbody><tr><td><strong>状态存储</strong></td><td><strong>有状态 (Stateful)</strong>。Session 信息需存储在服务端。</td><td><strong>无状态 (Stateless)</strong>。用户信息包含在 Token 的 Payload 中，服务端无需存储。</td><td><strong>减轻服务端压力</strong>。服务端不需要为每个在线用户维护一个 Session 对象。</td></tr><tr><td><strong>可扩展性</strong></td><td><strong>差</strong>。在分布式或集群环境下，需要解决 Session 共享问题（如 Session Sticky、Session Replication、集中存储）。</td><td><strong>好</strong>。由于服务端不存储状态，任何一台服务器只要有相同的密钥，就能验证 Token，天然适合分布式和微服务架构。</td><td><strong>轻松实现水平扩展</strong>。增加服务器节点无需额外配置 Session 共享。</td></tr><tr><td><strong>跨域支持</strong></td><td><strong>有限</strong>。基于 Cookie 的 Session 机制在跨域（CORS）场景下处理起来比较麻烦。</td><td><strong>优秀</strong>。Token 可以通过 HTTP 请求头发送，不受同源策略限制，非常适合前后端分离和跨域 API 调用。</td><td><strong>适应现代架构</strong>。完美支持 SPA（单页应用）、移动 App 等多种客户端。</td></tr><tr><td><strong>安全性</strong></td><td>依赖 Cookie 机制，可能遭受 CSRF 攻击。</td><td>如果 Token 存储在 <code>localStorage</code>，可能遭受 XSS 攻击。需要综合考虑存储方式。</td><td>两者各有安全风险点，需配合其他安全策略。Token 机制不依赖 Cookie，更灵活。</td></tr><tr><td><strong>适用性</strong></td><td>适合传统的、一体化的 Web 应用。</td><td>适合现代的、分布式的、跨终端的（Web, Mobile, IoT）应用架构。</td><td>Token 更具通用性和前瞻性。</td></tr></tbody></table><h4 id="4-双令牌策略-Access-Token-Refresh-Token"><a href="#4-双令牌策略-Access-Token-Refresh-Token" class="headerlink" title="4. 双令牌策略 (Access Token + Refresh Token)"></a><strong>4. 双令牌策略 (Access Token + Refresh Token)</strong></h4><ul><li><strong>Q: 为什么不用单个 Token？</strong><ul><li><strong>如果 Token 有效期很长（如一个月）</strong>: 安全风险高。一旦 Token 在此期间被窃取，攻击者可以长时间冒充用户身份进行操作。</li><li><strong>如果 Token 有效期很短（如 15 分钟）</strong>: 用户体验差。用户需要频繁地重新登录，这是无法接受的。</li></ul></li><li><strong>A: 双令牌策略应运而生，完美平衡了安全性和用户体验。</strong><ul><li><strong>Access Token (访问令牌)</strong>: 它的有效期<strong>非常短</strong>（如 15 分钟到 1 小时）。它被用于访问受保护的资源，由于其生命周期短，即使被窃取，攻击者能造成的危害也有限。</li><li><strong>Refresh Token (刷新令牌)</strong>: 它的有效期<strong>很长</strong>（如 7 天或 30 天）。它的<strong>唯一作用</strong>是用来获取新的 Access Token。Refresh Token 本身不包含任何权限信息，不能用于直接访问 API。</li></ul></li><li><strong>双令牌工作流程（静默刷新）</strong><ol><li><strong>首次登录</strong>: 用户登录成功，服务端返回一个短期的 <code>Access Token</code> 和一个长期的 <code>Refresh Token</code>。客户端将两者都存储起来。</li><li><strong>正常访问</strong>: 客户端使用 <code>Access Token</code> 访问 API。服务端验证 <code>Access Token</code> 通过，返回数据。</li><li><strong>Access Token 过期</strong>: 客户端再次使用过期的 <code>Access Token</code> 访问 API，服务端返回 <code>401 Unauthorized</code> 错误，并可能带上一个特定错误码，告知客户端是“令牌过期”而非“无效令牌”。</li><li><strong>静默刷新</strong>: 客户端的请求拦截器捕获到这个 <code>401</code> 错误后，<strong>不会立即跳转到登录页</strong>。而是自动发起一个特殊的请求，携带那个长期的 <code>Refresh Token</code> 去访问一个专门的刷新接口（如 <code>/api/token/refresh</code>）。</li><li><strong>签发新令牌</strong>: 服务端验证 <code>Refresh Token</code> 的有效性（通常会将其存储在 Redis 或数据库中进行比对，以实现强制下线功能）。如果验证通过，就生成一个<strong>新的 Access Token</strong>（有时也会生成一个新的 <code>Refresh Token</code>，这被称为刷新令牌滚动策略）并返回给客户端。</li><li><strong>重试请求</strong>: 客户端收到新的 <code>Access Token</code> 后，用它替换掉本地旧的 <code>Access Token</code>，然后<strong>自动重新发送刚才因令牌过期而失败的那个请求</strong>。</li><li><strong>无感体验</strong>: 整个过程对用户是透明的，用户感觉不到令牌已经过期并被刷新，实现了“静默刷新”，体验非常流畅。</li><li><strong>Refresh Token 过期</strong>: 如果 <code>Refresh Token</code> 也过期了，那么刷新接口会返回错误，此时客户端才会真正清除用户凭证并引导用户重新登录。</li></ol></li></ul><h4 id="5-Token-相关场景与面试题"><a href="#5-Token-相关场景与面试题" class="headerlink" title="5. Token 相关场景与面试题"></a><strong>5. Token 相关场景与面试题</strong></h4><ul><li><strong>面试题 1：“Token 应该存储在哪里？localStorage、sessionStorage 还是 Cookie？”</strong><ul><li><p><strong>回答要点</strong>:</p><ul><li><strong>localStorage&#x2F;sessionStorage</strong>:<ul><li><strong>优点</strong>: 方便 JavaScript 直接读写，容量较大（5MB）。</li><li><strong>缺点</strong>: 容易受到 <strong>XSS (跨站脚本攻击)</strong>。如果网站存在 XSS 漏洞，攻击者可以执行 JS 代码直接窃取存储在其中的 Token。</li></ul></li><li><strong>Cookie (HttpOnly)</strong>:<ul><li><strong>优点</strong>: 设置为 <code>HttpOnly</code> 后，JavaScript 将无法读写该 Cookie，可以有效<strong>防御 XSS 攻击</strong>。浏览器会自动在同域请求中携带它。</li><li><strong>缺点</strong>: 容易受到 <strong>CSRF (跨站请求伪造)</strong> 攻击。攻击者可以诱导用户点击恶意链接，浏览器会自动带上用户的 Cookie 去请求你的网站，执行非用户本意的操作。需要配合 Anti-CSRF Token 等机制来防御。容量较小（4KB）。</li></ul></li><li><strong>最佳实践&#x2F;结论</strong>: 没有绝对完美的选择，需要权衡。<ul><li><strong>高安全性方案</strong>: 将 <code>Refresh Token</code> 存储在 <code>HttpOnly</code> 的 Cookie 中（防止 XSS），将 <code>Access Token</code> 存储在内存中（变量里，页面刷新丢失）或 <code>sessionStorage</code> 中。同时，后端接口必须实施 CSRF 防御策略。</li><li><strong>主流实践方案 (前后端分离)</strong>: 将 Token 存储在 <code>localStorage</code> 中，并在 <code>Authorization</code> 请求头中携带。同时，前端必须严格做好输入过滤和内容转义，尽最大努力防止 XSS 漏洞的出现。</li></ul></li></ul><h3 id="1-访问令牌-Access-Token"><a href="#1-访问令牌-Access-Token" class="headerlink" title="1. 访问令牌 (Access Token)"></a>1. 访问令牌 (Access Token)</h3><p>访问令牌是用于<strong>访问受保护资源</strong>的凭证。它通常是一个<strong>有效期很短</strong>的 JWT。</p><ul><li><strong>作用</strong>：携带用户的身份信息和权限，用于后端 API 接口的认证。后端在收到请求时，会验证这个令牌的有效性（签名、有效期）。</li><li><strong>有效期</strong>：<strong>非常短</strong>，通常只有几分钟到几小时。这极大地降低了令牌被盗后造成的损失。</li><li><strong>存储方案</strong>：为了防止 XSS 攻击，访问令牌通常不应该存储在浏览器本地的 <code>localStorage</code> 或 <code>sessionStorage</code> 中，因为这些存储空间可以被恶意脚本访问。<ul><li><strong>推荐方案</strong>：存储在<strong>内存中</strong>。当用户关闭浏览器标签页时，令牌就会被清除。这意味着用户每次打开新标签页都需要重新获取令牌，但这是为了安全牺牲一些便利性。</li><li><strong>次优方案</strong>：存储在<strong>HTTP-only Cookie</strong> 中。这种 Cookie 只能由服务器设置，无法通过 JavaScript 脚本读取，有效防止了 XSS 攻击。但是，它仍然可能受到 CSRF 攻击的风险。</li></ul></li></ul><h3 id="2-刷新令牌-Refresh-Token"><a href="#2-刷新令牌-Refresh-Token" class="headerlink" title="2. 刷新令牌 (Refresh Token)"></a>2. 刷新令牌 (Refresh Token)</h3><p>刷新令牌是用于<strong>获取新的访问令牌</strong>的凭证。它通常是一个<strong>有效期很长</strong>的令牌，可以用于在访问令牌过期后，无感地重新获取一个新的。</p><ul><li><strong>作用</strong>：当访问令牌过期时，客户端携带刷新令牌向认证服务器请求一个新的访问令牌。</li><li><strong>有效期</strong>：<strong>很长</strong>，通常是几天、几周甚至几个月。</li><li><strong>存储方案</strong>：由于刷新令牌是获取访问令牌的关键，它的存储必须<strong>绝对安全</strong>。<ul><li><strong>推荐方案</strong>：存储在<strong>HTTP-only Cookie</strong> 中。HTTP-only 属性可以防止恶意脚本（XSS）读取该令牌。同时，由于刷新令牌只发送给认证服务器，并且不用于访问其他 API，可以采取一些额外的安全措施，如 CSRF 令牌或 SameSite Cookie 属性，来防止 CSRF 攻击。</li><li><strong>注意</strong>：刷新令牌<strong>绝对不应该</strong>存储在 <code>localStorage</code> 中。</li></ul></li></ul><h3 id="双令牌工作流程"><a href="#双令牌工作流程" class="headerlink" title="双令牌工作流程"></a>双令牌工作流程</h3><ol><li><strong>首次登录</strong>：<ul><li>用户通过用户名&#x2F;密码登录。</li><li>认证服务器验证通过后，生成一个<strong>访问令牌（Access Token）和一个刷新令牌（Refresh Token）</strong>。</li><li>服务器将刷新令牌设置到 <strong>HTTP-only Cookie</strong> 中，发送给浏览器。</li><li>服务器将访问令牌返回给前端，前端将其存储在<strong>内存中</strong>。</li></ul></li><li><strong>访问受保护资源</strong>：<ul><li>前端发起 API 请求时，从内存中取出访问令牌，并将其放在请求头（如 <code>Authorization: Bearer &lt;AccessToken&gt;</code>）中发送给后端。</li><li>后端 API 服务器验证访问令牌的有效性，如果有效则返回数据。</li></ul></li><li><strong>访问令牌过期</strong>：<ul><li>一段时间后，访问令牌过期。前端再次发起 API 请求时，后端会返回一个 401 Unauthorized 错误。</li><li>前端捕获到这个错误后，会发起一个<strong>刷新请求</strong>（通常是向一个专门的 <code>/refresh</code> 接口），这个请求会自动带上存储在 HTTP-only Cookie 中的刷新令牌。</li></ul></li><li><strong>刷新令牌工作</strong>：<ul><li>认证服务器收到刷新请求，验证刷新令牌的有效性。</li><li>如果刷新令牌有效，服务器会生成一个新的<strong>访问令牌</strong>和（可选）一个新的<strong>刷新令牌</strong>。</li><li>服务器将新的访问令牌返回给前端，前端更新内存中的令牌。</li><li>服务器将新的刷新令牌设置到 <strong>HTTP-only Cookie</strong> 中。</li><li>前端使用新的访问令牌重新发起之前的 API 请求。</li></ul></li></ol><h3 id="为什么这个方案更安全？"><a href="#为什么这个方案更安全？" class="headerlink" title="为什么这个方案更安全？"></a>为什么这个方案更安全？</h3><ol><li><strong>防止 XSS 攻击</strong>：最敏感的刷新令牌存储在 HTTP-only Cookie 中，脚本无法读取。而访问令牌虽然存储在内存中，但其有效期短，即使被盗，也很快会失效。</li><li><strong>防止 CSRF 攻击</strong>：刷新令牌通常只用于一个特定的 <code>/refresh</code> 接口，并且可以与 CSRF 令牌（或 SameSite Cookie）结合使用，进一步降低风险。同时，由于其他 API 接口不依赖于 Cookie 中的刷新令牌，而是依赖于请求头中的访问令牌，因此无法被 CSRF 攻击者利用。</li><li><strong>提升用户体验</strong>：尽管访问令牌有效期很短，但用户无需频繁登录，因为刷新令牌可以在后台无感地获取新令牌。</li></ol><p>总之，双令牌方案通过将令牌职责分离和采用不同的存储机制，在保证用户体验的同时，显著提升了系统的安全性，是现代 Web 应用中一种非常成熟和推荐的认证模式。</p></li></ul></li><li><strong>面试题 2：“用户点击“退出登录”时，Token 如何失效？”</strong><ul><li><strong>回答要点</strong>:<ul><li><h4 id="核心观点：无状态-JWT-的特性决定了“退出登录”的本质"><a href="#核心观点：无状态-JWT-的特性决定了“退出登录”的本质" class="headerlink" title="核心观点：无状态 JWT 的特性决定了“退出登录”的本质"></a>核心观点：无状态 JWT 的特性决定了“退出登录”的本质</h4><p>首先，要明确指出 JWT 的核心特点是<strong>无状态</strong>。这意味着服务器<strong>无法主动</strong>让一个已经签发出去的令牌失效，这与传统的 Session 机制（服务器可以主动销毁会话）有本质区别。因此，“退出登录”的实现方式也截然不同。</p><h4 id="1-客户端实现（常规退出登录）"><a href="#1-客户端实现（常规退出登录）" class="headerlink" title="1. 客户端实现（常规退出登录）"></a>1. 客户端实现（常规退出登录）</h4><ul><li><strong>实现方式</strong>：这是最简单、最常见的方案，适用于用户主动退出登录的情况。</li><li><strong>具体操作</strong>：<ul><li>前端代码在用户点击“退出登录”时，执行一个简单的操作：<strong>从本地存储（如 localStorage、sessionStorage、内存或 Cookie）中删除 Access Token</strong>。</li><li>一旦令牌被删除，前端后续的请求将无法携带有效的 <code>Authorization</code> 头，服务器会返回 401 错误，从而实现了“退出登录”的效果。</li></ul></li><li><strong>局限性</strong>：这种方法只是一个<strong>客户端行为</strong>。如果令牌被复制或被攻击者截获，它在过期之前仍然是有效的。</li></ul><h4 id="2-服务端实现（强制下线或即时失效）"><a href="#2-服务端实现（强制下线或即时失效）" class="headerlink" title="2. 服务端实现（强制下线或即时失效）"></a>2. 服务端实现（强制下线或即时失效）</h4><ul><li><strong>引入背景</strong>：当需要实现更严格的安全需求时，如“管理员踢人下线”、“用户修改密码后所有设备下线”或“令牌泄露后立即失效”，单纯的客户端清除是不够的。此时，我们必须打破无状态的特性，引入服务端的状态管理。</li><li><strong>方案一：黑名单机制 (Blacklist)</strong><ul><li><strong>工作原理</strong>：<ol><li>服务端维护一个高效、可快速查找的<strong>黑名单列表</strong>（通常使用 <strong>Redis 的 Set 数据结构</strong>，因为它具有 O(1) 的查找效率）。</li><li>在用户退出登录或需要强制下线时，将该 JWT 的唯一标识 <code>jti</code>（或整个令牌本身）添加到这个黑名单中。</li><li>为黑名单中的条目设置一个<strong>过期时间</strong>，该过期时间应与令牌本身的剩余有效期一致。</li><li>在每次验证 JWT 的过程中，除了校验签名和过期时间外，额外增加一步：<strong>检查该令牌的 jti 是否存在于黑名单中</strong>。如果存在，则认证失败。</li></ol></li></ul></li><li><strong>方案二：基于 Refresh Token 的管理</strong><ul><li><strong>工作原理</strong>：这种方案是基于<strong>双令牌模式</strong>设计的，更优雅地解决了问题。<ol><li>服务器在签发 <code>Access Token</code> 和 <code>Refresh Token</code> 时，会将 <code>Refresh Token</code> 存入数据库或 Redis 中。</li><li>当用户点击“退出登录”或需要强制下线时，服务器<strong>删除</strong>或<strong>标记失效</strong>存储在服务器端的 <code>Refresh Token</code>。</li><li>当用户的 <code>Access Token</code> 过期后，它将无法通过 <code>Refresh Token</code> 换取新的 <code>Access Token</code>，因为服务器端的 <code>Refresh Token</code> 已经失效。这样，用户就无法继续保持登录状态。</li></ol></li></ul></li></ul><h3 id="总结与对比"><a href="#总结与对比" class="headerlink" title="总结与对比"></a>总结与对比</h3><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>客户端清除</strong></td><td>实现简单，开销小。</td><td>安全性最低，无法强制下线。</td><td>用户主动退出登录。</td></tr><tr><td><strong>黑名单机制</strong></td><td>能够实现即时下线，安全可控。</td><td>增加了服务端开销（额外的 Redis 存储和查询）。</td><td>强制下线、修改密码、令牌泄露。</td></tr><tr><td><strong>Refresh Token 方案</strong></td><td>既实现了即时下线，又无需频繁查询黑名单，架构更优雅。</td><td>必须采用双令牌模式，实现相对复杂。</td><td>现代前后端分离应用，对安全性要求较高。</td></tr></tbody></table></li></ul></li></ul></li><li><strong>面试题 3：“请你设计一个支持 Web 端和 App 端统一登录的认证系统。”</strong><ul><li><strong>回答要点</strong>:<ul><li>这正是 Token 认证机制的典型应用场景。我会采用基于 <strong>OAuth 2.0&#x2F;OIDC</strong> 或自定义的**双令牌（Access&#x2F;Refresh Token）**方案。</li><li><strong>统一认证中心 (UAC)</strong>: 建立一个独立的认证服务，负责处理所有客户端（Web, iOS, Android）的登录、注册、Token 签发和刷新。</li><li><strong>API 网关</strong>: 所有业务请求都通过 API 网关。网关的核心职责之一就是<strong>统一鉴权</strong>。它会拦截所有请求，解析 <code>Authorization</code> 头中的 <code>Access Token</code>，调用认证中心或自行验证 Token 的有效性。验证通过后，可以将解析出的用户信息（如用户ID）附加到请求头中，再转发给后端的业务微服务。</li><li><strong>业务微服务</strong>: 业务微服务本身<strong>不再关心 Token 的验证细节</strong>，它们信任来自网关的请求，直接从请求头中获取用户信息进行业务处理，实现了业务与认证的解耦。</li><li><strong>流程</strong>:<ol><li>Web&#x2F;App 客户端引导用户到认证中心进行登录。</li><li>登录成功后，认证中心返回 <code>Access Token</code> 和 <code>Refresh Token</code>。</li><li>客户端保存令牌，后续访问业务 API 时，在请求头携带 <code>Access Token</code>。</li><li>API 网关拦截请求，验证 <code>Access Token</code>。</li><li><code>Access Token</code> 过期后，客户端使用 <code>Refresh Token</code> 向认证中心申请新令牌。</li></ol></li><li>这个架构具有高内聚、低耦合、可扩展性强、安全性高的优点。</li></ul></li></ul></li></ul><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis-核心架构与原理"><a href="#Redis-核心架构与原理" class="headerlink" title="Redis 核心架构与原理"></a>Redis 核心架构与原理</h2><h3 id="内存模型与数据结构"><a href="#内存模型与数据结构" class="headerlink" title="内存模型与数据结构"></a>内存模型与数据结构</h3><p>Redis采用基于内存的存储架构，所有数据都保存在RAM中，这是其高性能的根本原因。Redis使用了多种底层数据结构来实现上层的抽象数据类型：</p><p><strong>SDS（Simple Dynamic String）</strong> Redis没有直接使用C语言的字符串，而是构建了SDS。SDS在字符串头部记录了长度信息，避免了strlen的O(n)复杂度，同时预分配空间减少内存重分配次数。</p><p><strong>跳跃表（Skip List）</strong> 有序集合的底层实现之一，是一种随机化的数据结构，通过多层链表实现O(log N)的查找复杂度。相比红黑树，跳跃表实现更简单，且支持范围查询。</p><p><strong>压缩列表（Ziplist）</strong> 当哈希、列表、有序集合元素较少时使用的紧凑存储结构，所有元素存储在一块连续内存中，节省内存但插入删除效率较低。</p><p><strong>字典（Dict）</strong> Redis的核心数据结构，使用开放寻址法解决哈希冲突，支持渐进式rehash。当负载因子过高时，会创建新的哈希表并逐步迁移数据。</p><h3 id="单线程模型与事件循环"><a href="#单线程模型与事件循环" class="headerlink" title="单线程模型与事件循环"></a>单线程模型与事件循环</h3><p>Redis 6.0之前采用单线程模型处理客户端请求，通过I&#x2F;O多路复用（epoll&#x2F;kqueue）实现高并发。单线程避免了线程切换开销和并发控制问题，但也限制了CPU利用率。</p><p><strong>事件循环机制</strong> Redis使用Reactor模式的事件循环，分为文件事件和时间事件：</p><ul><li>文件事件：处理客户端连接、读写请求</li><li>时间事件：处理定时任务，如过期键删除、持久化等</li></ul><p>Redis 6.0引入了多线程I&#x2F;O，但命令执行仍是单线程，多线程只用于网络I&#x2F;O操作的读写，这样既提高了网络处理能力，又保持了数据操作的原子性。</p><h2 id="数据类型详解与应用场景"><a href="#数据类型详解与应用场景" class="headerlink" title="数据类型详解与应用场景"></a>数据类型详解与应用场景</h2><h3 id="Redis-的数据结构详解"><a href="#Redis-的数据结构详解" class="headerlink" title="Redis 的数据结构详解"></a>Redis 的数据结构详解</h3><h4 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1. String (字符串)"></a>1. String (字符串)</h4><ul><li><strong>最基本的数据结构</strong>，可以存储任何类型的数据，比如字符串、数字或二进制数据。一个键最多可以存储 512MB 的值。</li><li><strong>常用命令</strong>:<ul><li><code>SET key value</code>: 设置键值对。</li><li><code>GET key</code>: 获取键对应的值。</li><li><code>INCR key</code>: 将键对应的值加 1，常用于计数器。</li><li><code>MSET key1 value1 key2 value2</code>: 同时设置多个键值对。</li><li><code>MGET key1 key2</code>: 同时获取多个键的值。</li></ul></li><li><strong>应用场景</strong>: 缓存、计数器、分布式锁等。</li></ul><h4 id="2-Hash-哈希"><a href="#2-Hash-哈希" class="headerlink" title="2. Hash (哈希)"></a>2. Hash (哈希)</h4><ul><li><strong>类似于一个键值对的集合</strong>。一个哈希键可以存储多个字段（field）和对应的值（value），非常适合存储对象。</li><li><strong>常用命令</strong>:<ul><li><code>HSET key field value</code>: 设置哈希键中一个字段的值。</li><li><code>HGET key field</code>: 获取哈希键中一个字段的值。</li><li><code>HGETALL key</code>: 获取哈希键中所有的字段和值。</li><li><code>HMSET key field1 value1 field2 value2</code>: 同时设置多个字段。</li><li><code>HDEL key field1 field2</code>: 删除一个或多个字段。</li></ul></li><li><strong>应用场景</strong>: 存储用户信息（如<code>user:100</code>作为键，<code>name</code>、<code>age</code>、<code>city</code>作为字段），商品信息等。</li></ul><h4 id="3-List-列表"><a href="#3-List-列表" class="headerlink" title="3. List (列表)"></a>3. List (列表)</h4><ul><li><strong>一个有序的、可以重复的字符串集合</strong>。可以从列表的头部或尾部添加或删除元素。</li><li><strong>常用命令</strong>:<ul><li><code>LPUSH key value1 value2</code>: 从列表的头部插入一个或多个值。</li><li><code>RPUSH key value1 value2</code>: 从列表的尾部插入一个或多个值。</li><li><code>LPOP key</code>: 从列表的头部移除并返回一个值。</li><li><code>RPOP key</code>: 从列表的尾部移除并返回一个值。</li><li><code>LRANGE key start stop</code>: 获取列表中指定范围的元素。</li></ul></li><li><strong>应用场景</strong>: 消息队列（队列、栈）、最新文章列表、历史记录等。</li></ul><h4 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4. Set (集合)"></a>4. Set (集合)</h4><ul><li><strong>一个无序的、不重复的字符串集合</strong>。集合提供了交集、并集和差集等操作。</li><li><strong>常用命令</strong>:<ul><li><code>SADD key member1 member2</code>: 向集合中添加一个或多个成员。</li><li><code>SMEMBERS key</code>: 获取集合中的所有成员。</li><li><code>SISMEMBER key member</code>: 判断一个成员是否在集合中。</li><li><code>SINTER key1 key2</code>: 求两个集合的交集。</li><li><code>SUNION key1 key2</code>: 求两个集合的并集。</li></ul></li><li><strong>应用场景</strong>: 社交网络中的共同好友、标签系统、去重等。</li></ul><h4 id="5-Sorted-Set-有序集合"><a href="#5-Sorted-Set-有序集合" class="headerlink" title="5. Sorted Set (有序集合)"></a>5. Sorted Set (有序集合)</h4><ul><li><strong>和集合类似，但每个成员都会关联一个分数（score）</strong>。通过这个分数，可以对集合中的成员进行排序。分数可以重复，但成员必须唯一。</li><li><strong>常用命令</strong>:<ul><li><code>ZADD key score1 member1 score2 member2</code>: 向有序集合中添加一个或多个带分数的成员。</li><li><code>ZRANGE key start stop</code>: 按分数从小到大排序，获取指定范围的成员。</li><li><code>ZREVRANGE key start stop</code>: 按分数从大到小排序，获取指定范围的成员。</li><li><code>ZSCORE key member</code>: 获取一个成员的分数。</li><li><code>ZINCRBY key increment member</code>: 给指定成员的分数增加指定值。</li></ul></li><li><strong>应用场景</strong>: 排行榜（游戏分数、热点新闻）、带权重的任务队列等。</li></ul><h3 id="Redis-的持久化机制"><a href="#Redis-的持久化机制" class="headerlink" title="Redis 的持久化机制"></a>Redis 的持久化机制</h3><hr><p>Redis 提供了两种持久化方式，可以将数据从内存保存到硬盘，确保数据不会因为服务重启而丢失。</p><h4 id="1-RDB-Redis-Database"><a href="#1-RDB-Redis-Database" class="headerlink" title="1. RDB (Redis Database)"></a>1. RDB (Redis Database)</h4><ul><li><strong>快照方式</strong>。它会在指定的时间间隔内，将内存中的数据快照写入到磁盘上一个二进制文件中（<code>dump.rdb</code>）。</li><li><strong>优点</strong>: RDB 文件是一个非常紧凑的二进制文件，非常适合备份和灾难恢复。</li><li><strong>缺点</strong>: 每次保存都会丢失从上次快照到现在之间的数据。</li></ul><h4 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2. AOF (Append Only File)"></a>2. AOF (Append Only File)</h4><ul><li><strong>日志方式</strong>。它会记录每一次对 Redis 数据库的写操作命令，并以追加（append）的方式写入到文件中。当 Redis 重启时，会重新执行 AOF 文件中的命令来恢复数据。</li><li><strong>优点</strong>: 数据丢失风险低，可以配置为每秒同步一次，或者每执行一个命令就同步一次。</li><li><strong>缺点</strong>: AOF 文件通常比 RDB 文件大，且恢复速度可能较慢。</li></ul><p>在实际应用中，通常会<strong>同时使用 RDB 和 AOF</strong>，以获得更高的可靠性。</p><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String是Redis最基础的数据类型，底层可以是SDS、整数或浮点数。</p><p><strong>常用命令</strong>：SET、GET、INCR、DECR、APPEND、GETRANGE <strong>应用场景</strong>：</p><ul><li>缓存：存储用户会话、配置信息</li><li>计数器：网站访问量、点赞数（INCR原子性保证）</li><li>分布式锁：SET key value NX EX seconds</li><li>限流：结合EXPIRE实现滑动窗口限流</li></ul><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash类型适合存储对象，避免了将对象序列化为JSON字符串的开销。</p><p><strong>底层实现</strong>：元素较少时使用ziplist，元素较多时使用hashtable <strong>应用场景</strong>：</p><ul><li>存储用户信息：HSET user:1001 name “张三” age 25</li><li>购物车：HSET cart:1001 product:123 2</li><li>配置管理：分类存储不同模块的配置</li></ul><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>List是双向链表实现，支持在两端进行O(1)的插入和删除操作。</p><p><strong>常用命令</strong>：LPUSH、RPUSH、LPOP、RPOP、LRANGE、BLPOP <strong>应用场景</strong>：</p><ul><li>消息队列：生产者LPUSH，消费者BRPOP实现阻塞队列</li><li>最新列表：朋友圈动态、商品评论</li><li>栈和队列：LPUSH+LPOP实现栈，LPUSH+RPOP实现队列</li></ul><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Set是无序集合，元素唯一，底层使用hashtable或intset实现。</p><p><strong>集合运算</strong>：SINTER（交集）、SUNION（并集）、SDIFF（差集） <strong>应用场景</strong>：</p><ul><li>去重：统计网站独立访客</li><li>社交关系：共同好友、推荐用户</li><li>标签系统：用户标签、文章分类</li><li>抽奖系统：SRANDMEMBER随机抽取</li></ul><h3 id="Sorted-Set类型"><a href="#Sorted-Set类型" class="headerlink" title="Sorted Set类型"></a>Sorted Set类型</h3><p>有序集合，每个元素关联一个分数，按分数排序。底层使用跳跃表和哈希表。</p><p><strong>应用场景</strong>：</p><ul><li>排行榜：游戏积分、热搜榜</li><li>延时队列：分数为执行时间戳</li><li>范围查询：按时间、按分数范围获取数据</li></ul><h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB通过fork子进程，将内存数据快照写入磁盘。</p><p><strong>优点</strong>：</p><ul><li>文件紧凑，适合备份和灾难恢复</li><li>恢复速度快</li><li>对Redis性能影响小（子进程操作）</li></ul><p><strong>缺点</strong>：</p><ul><li>数据丢失风险：两次快照间的数据可能丢失</li><li>fork过程会阻塞主进程</li><li>大数据集fork耗时较长</li></ul><p><strong>触发条件</strong>：</p><ul><li>手动执行SAVE或BGSAVE命令</li><li>配置自动触发：save 900 1（900秒内至少1个键改变）</li><li>主从复制时自动生成RDB</li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF记录每个写命令，通过重放命令恢复数据。</p><p><strong>写入时机</strong>：</p><ul><li>always：每个写命令立即同步，安全但性能低</li><li>everysec：每秒同步一次，平衡安全性和性能</li><li>no：由操作系统决定同步时机，性能高但安全性低</li></ul><p><strong>AOF重写</strong>： AOF文件会越来越大，Redis提供重写机制优化：</p><ul><li>遍历内存数据，用最少命令重建AOF文件</li><li>重写期间的新命令写入AOF重写缓冲区</li><li>原子性替换旧AOF文件</li></ul><p><strong>混合持久化</strong>： Redis 4.0引入RDB+AOF混合模式，重写时以RDB格式写入基础数据，增量命令以AOF格式追加，兼顾了恢复速度和数据安全。</p><h2 id="缓存问题与解决方案"><a href="#缓存问题与解决方案" class="headerlink" title="缓存问题与解决方案"></a>缓存问题与解决方案</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在的数据，缓存无法生效，请求直达数据库。</p><p><strong>解决方案</strong>：</p><p><strong>空值缓存</strong>：查询结果为空时也缓存，设置较短过期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">    redis.setex(key, <span class="number">60</span>, <span class="string">&quot;null&quot;</span>);  <span class="comment">// 缓存空值60秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>布隆过滤器</strong>：预先将所有可能存在的数据哈希到位数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BloomFilter&lt;String&gt; filter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()), <span class="number">1000000</span>, <span class="number">0.01</span>);</span><br><span class="line"><span class="comment">// 查询前先检查布隆过滤器</span></span><br><span class="line"><span class="keyword">if</span> (!filter.mightContain(key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 一定不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数校验</strong>：在API层面进行参数合法性校验</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>热点数据过期瞬间，大量并发请求击穿缓存。</p><p><strong>解决方案</strong>：</p><p><strong>互斥锁</strong>：只允许一个线程查询数据库并重建缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span> + key;</span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(lockKey, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>)) &#123;  <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                data = database.query(key);  <span class="comment">// 查询数据库</span></span><br><span class="line">                redis.setex(key, <span class="number">3600</span>, data);  <span class="comment">// 重建缓存</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                redis.del(lockKey);  <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);  <span class="comment">// 等待其他线程重建缓存</span></span><br><span class="line">            <span class="keyword">return</span> getData(key);  <span class="comment">// 递归重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>热点数据永不过期</strong>：逻辑上设置过期时间，物理上不过期，异步更新</li><li><strong>预热机制</strong>：系统启动时预先加载热点数据</li><li><strong>二级缓存</strong>：L1缓存过期后，先返回L2缓存数据，异步更新L1</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量缓存同时过期或Redis宕机，请求涌向数据库。</p><p><strong>解决方案</strong>：</p><p><strong>过期时间随机化</strong>：避免同时过期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> baseExpire + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);  <span class="comment">// 基础时间+随机时间</span></span><br><span class="line">redis.setex(key, randomExpire, data);</span><br></pre></td></tr></table></figure><ol><li><strong>多级缓存架构</strong>：<ul><li>L1：本地缓存（如Caffeine）</li><li>L2：Redis分布式缓存</li><li>L3：数据库</li></ul></li><li><strong>限流降级</strong>：使用Sentinel、Hystrix等组件</li><li><strong>Redis高可用</strong>：主从复制、哨兵模式、集群部署</li></ol><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>系统启动时预先加载热点数据到缓存。</p><p><strong>实现方式</strong>：</p><ol><li><strong>定时任务预热</strong>：凌晨低峰期执行</li><li><strong>手动预热</strong>：管理后台触发预热任务</li><li><strong>实时预热</strong>：监控系统发现热点数据自动预热</li></ol><h2 id="数据一致性保证"><a href="#数据一致性保证" class="headerlink" title="数据一致性保证"></a>数据一致性保证</h2><h3 id="Cache-Aside模式（旁路缓存）"><a href="#Cache-Aside模式（旁路缓存）" class="headerlink" title="Cache Aside模式（旁路缓存）"></a>Cache Aside模式（旁路缓存）</h3><p>应用程序负责维护缓存和数据库的一致性。</p><p><strong>读操作</strong>：</p><ol><li>先读缓存，命中则返回</li><li>缓存不命中，查询数据库</li><li>将数据写入缓存并返回</li></ol><p><strong>写操作</strong>：</p><ol><li>先更新数据库</li><li>删除缓存（让下次读取时重新加载）</li></ol><p><strong>为什么是删除而不是更新缓存？</strong></p><ul><li>更新缓存可能存在并发问题</li><li>复杂查询的缓存更新成本高</li><li>删除缓存更简单可靠</li></ul><h3 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h3><p>解决读写并发导致的数据不一致问题。</p><p><strong>实现步骤</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Object data)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 删除缓存</span></span><br><span class="line">    redis.del(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 更新数据库</span></span><br><span class="line">    database.update(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 延时删除缓存（异步）</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);  <span class="comment">// 延时500ms</span></span><br><span class="line">            redis.del(key);     <span class="comment">// 再次删除缓存</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;延时删除缓存失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>延时时间设置</strong>：通常为主从同步时间 + 读数据库时间 + 几十毫秒</p><h3 id="基于消息队列的最终一致性"><a href="#基于消息队列的最终一致性" class="headerlink" title="基于消息队列的最终一致性"></a>基于消息队列的最终一致性</h3><p>使用消息队列异步处理缓存更新，保证最终一致性。</p><p><strong>实现流程</strong>：</p><ol><li>更新数据库，发送消息到队列</li><li>消息消费者删除相关缓存</li><li>消费失败时重试，保证最终一致性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送缓存删除消息</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    userDao.update(user);  <span class="comment">// 更新数据库</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送缓存删除消息（事务提交后发送）</span></span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TransactionSynchronizationAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCommit</span><span class="params">()</span> &#123;</span><br><span class="line">                cacheDeleteMQ.send(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式事务方案"><a href="#分布式事务方案" class="headerlink" title="分布式事务方案"></a>分布式事务方案</h3><p>对于强一致性要求高的场景，可以使用分布式事务。</p><p><strong>2PC（两阶段提交）</strong>：</p><ul><li>准备阶段：协调者询问参与者是否准备好</li><li>提交阶段：所有参与者都准备好则提交，否则回滚</li></ul><p><strong>TCC（Try-Confirm-Cancel）</strong>：</p><ul><li>Try：尝试执行，预留资源</li><li>Confirm：确认提交</li><li>Cancel：取消执行，释放资源</li></ul><h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><h3 id="基于SET命令的分布式锁"><a href="#基于SET命令的分布式锁" class="headerlink" title="基于SET命令的分布式锁"></a>基于SET命令的分布式锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDistributedLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String lockKey, String requestId, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">releaseLock</span><span class="params">(String lockKey, String requestId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, Collections.singletonList(lockKey),</span><br><span class="line">                                 Collections.singletonList(requestId));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>.equals(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:user:1001&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tryLock(lockKey, requestId, <span class="number">30000</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行业务逻辑</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        releaseLock(lockKey, requestId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h3><p>为了解决单点故障问题，Redis官方提出了Redlock算法。</p><p><strong>算法步骤</strong>：</p><ol><li>获取当前时间戳</li><li>依次向N个Redis实例申请锁</li><li>如果在大多数实例（N&#x2F;2+1）上获取锁成功，且总耗时小于锁超时时间，则认为获取锁成功</li><li>锁的有效时间 &#x3D; 初始有效时间 - 获取锁消耗的时间</li><li>释放锁时，向所有Redis实例发送释放命令</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Redlock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Jedis&gt; jedisInstances;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String resource, <span class="type">int</span> ttl)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">quorum</span> <span class="operator">=</span> jedisInstances.size() / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">successCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Jedis jedis : jedisInstances) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lockInstance(jedis, resource, ttl)) &#123;</span><br><span class="line">                successCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        <span class="keyword">if</span> (successCount &gt;= quorum &amp;&amp; elapsedTime &lt; ttl) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unlock(resource);  <span class="comment">// 释放已获取的锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁的问题与优化"><a href="#锁的问题与优化" class="headerlink" title="锁的问题与优化"></a>锁的问题与优化</h3><p><strong>锁超时问题</strong>： 业务执行时间超过锁超时时间，锁自动释放，可能导致并发问题。</p><p><strong>解决方案</strong>：</p><ol><li><strong>看门狗机制</strong>：定时续期锁的过期时间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatchDog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ScheduledExecutorService</span> <span class="variable">scheduler</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startWatchDog</span><span class="params">(String lockKey, String requestId)</span> &#123;</span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 续期锁</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) else return 0 end&quot;</span>;</span><br><span class="line">            jedis.eval(script, Arrays.asList(lockKey), </span><br><span class="line">                      Arrays.asList(requestId, <span class="string">&quot;30&quot;</span>));</span><br><span class="line">        &#125;, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>合理评估业务执行时间</strong>：设置足够的锁超时时间</li></ol><p><strong>锁竞争激烈问题</strong>： 大量线程竞争同一把锁，导致性能下降。</p><p><strong>解决方案</strong>：</p><ol><li><strong>分段锁</strong>：将资源分段，减少锁竞争</li><li><strong>队列锁</strong>：使用List实现公平锁</li><li><strong>自旋锁优化</strong>：适当的退避算法</li></ol><hr><h2 id="Redisson（Java-分布式锁）"><a href="#Redisson（Java-分布式锁）" class="headerlink" title="Redisson（Java 分布式锁）"></a>Redisson（Java 分布式锁）</h2><h3 id="1-Redisson-简介"><a href="#1-Redisson-简介" class="headerlink" title="1. Redisson 简介"></a>1. Redisson 简介</h3><ul><li><strong>Redisson</strong> 是 Redis 官方推荐的 <strong>Java 客户端</strong>，比 Jedis、Lettuce 更高级。</li><li>除了基本 Redis 操作，它还提供了 <strong>分布式对象、分布式集合、分布式锁、限流器、信号量</strong> 等并发工具。</li><li>最常用的功能就是 <strong>分布式锁</strong>（ReentrantLock、FairLock、ReadWriteLock、Semaphore 等）。</li></ul><hr><h3 id="2-Redisson-分布式锁的核心机制"><a href="#2-Redisson-分布式锁的核心机制" class="headerlink" title="2. Redisson 分布式锁的核心机制"></a>2. Redisson 分布式锁的核心机制</h3><p>Redisson 的分布式锁相比自己写的 <code>SET NX EX</code> 有三大改进：</p><h4 id="2-1-自动续期（看门狗机制）"><a href="#2-1-自动续期（看门狗机制）" class="headerlink" title="2.1 自动续期（看门狗机制）"></a>2.1 自动续期（看门狗机制）</h4><ul><li>加锁时默认过期时间 &#x3D; 30 秒。</li><li>如果业务逻辑未完成，Redisson 内部会有一个 <strong>watchdog 守护线程</strong>，每隔 10 秒自动续期，保证锁不会提前过期。</li><li>如果客户端宕机，守护线程也会停止，锁会在过期时间后自动释放 → <strong>避免死锁</strong>。</li></ul><h4 id="2-2-可重入锁"><a href="#2-2-可重入锁" class="headerlink" title="2.2 可重入锁"></a>2.2 可重入锁</h4><ul><li>和 Java 的 <code>ReentrantLock</code> 一样，Redisson 的 <code>RLock</code> 支持可重入（同一线程多次加锁不会死锁）。</li><li>实现方式：用 Redis <code>Hash</code> 存储锁的持有者（线程 ID + 重入次数）。</li></ul><h4 id="2-3-多种锁类型"><a href="#2-3-多种锁类型" class="headerlink" title="2.3 多种锁类型"></a>2.3 多种锁类型</h4><p>Redisson 提供了丰富的锁实现：</p><ul><li><strong>RLock</strong>：普通可重入锁</li><li><strong>FairLock</strong>：公平锁（FIFO 排队）</li><li><strong>ReadWriteLock</strong>：读写锁（共享读 &#x2F; 独占写）</li><li><strong>MultiLock</strong>：多个 Redis 节点上的联合锁（类似 Redlock）</li><li><strong>RedLock</strong>：实现 Redis 官方的 Redlock 算法</li><li><strong>Semaphore</strong>：分布式信号量</li><li><strong>CountDownLatch</strong>：分布式闭锁</li></ul><hr><h3 id="3-使用示例（Java）"><a href="#3-使用示例（Java）" class="headerlink" title="3. 使用示例（Java）"></a>3. 使用示例（Java）</h3><h4 id="3-1-引入依赖"><a href="#3-1-引入依赖" class="headerlink" title="3.1 引入依赖"></a>3.1 引入依赖</h4><p>Maven：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.27.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-创建-Redisson-客户端"><a href="#3-2-创建-Redisson-客户端" class="headerlink" title="3.2 创建 Redisson 客户端"></a>3.2 创建 Redisson 客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RedissonClient redisson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RedissonClient <span class="title function_">getClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (redisson == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">            config.useSingleServer()</span><br><span class="line">                  .setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>)</span><br><span class="line">                  .setDatabase(<span class="number">0</span>);</span><br><span class="line">            redisson = Redisson.create(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-获取分布式锁"><a href="#3-3-获取分布式锁" class="headerlink" title="3.3 获取分布式锁"></a>3.3 获取分布式锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> RedissonManager.getClient();</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;orderLock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取锁，最多等待 5 秒，拿到锁后 10 秒自动释放</span></span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到锁，开始执行任务...&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟业务逻辑</span></span><br><span class="line">                Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;任务执行完成&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;未获取到锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁（只有持有锁的线程能释放）</span></span><br><span class="line">            <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-多种锁示例"><a href="#4-多种锁示例" class="headerlink" title="4. 多种锁示例"></a>4. 多种锁示例</h3><h4 id="4-1-公平锁（先来先得）"><a href="#4-1-公平锁（先来先得）" class="headerlink" title="4.1 公平锁（先来先得）"></a>4.1 公平锁（先来先得）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> redisson.getFairLock(<span class="string">&quot;fairLock&quot;</span>);</span><br><span class="line">fairLock.lock();</span><br></pre></td></tr></table></figure><h4 id="4-2-读写锁"><a href="#4-2-读写锁" class="headerlink" title="4.2 读写锁"></a>4.2 读写锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;rwLock&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读锁（共享）</span></span><br><span class="line">rwLock.readLock().lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写锁（排他）</span></span><br><span class="line">rwLock.writeLock().lock();</span><br></pre></td></tr></table></figure><h4 id="4-3-信号量"><a href="#4-3-信号量" class="headerlink" title="4.3 信号量"></a>4.3 信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RSemaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> redisson.getSemaphore(<span class="string">&quot;semaphore&quot;</span>);</span><br><span class="line">semaphore.trySetPermits(<span class="number">3</span>); <span class="comment">// 设置许可数</span></span><br><span class="line">semaphore.acquire();  <span class="comment">// 获取许可</span></span><br><span class="line">semaphore.release();  <span class="comment">// 释放许可</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-常见问题与最佳实践"><a href="#5-常见问题与最佳实践" class="headerlink" title="5. 常见问题与最佳实践"></a>5. 常见问题与最佳实践</h3><ol><li><strong>锁过期导致业务未完成</strong><br> Redisson 自带看门狗续期机制（默认 30 秒 + 每 10 秒续期），一般不用担心。</li><li><strong>死锁问题</strong><ul><li>如果用 <code>SETNX</code> 自己实现，可能出现死锁。</li><li>Redisson 通过过期 + 看门狗避免死锁。</li></ul></li><li><strong>性能问题</strong><ul><li>分布式锁毕竟是跨进程的，性能不如本地锁。</li><li>适合关键资源互斥，不要滥用。</li></ul></li><li><strong>高可用 Redis</strong><ul><li>推荐 Redis <strong>哨兵模式 &#x2F; 集群模式</strong>，避免单点问题。</li><li>Redisson 原生支持这些模式，配置简单。</li></ul></li></ol><hr><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><ul><li><strong>如果你只要一个分布式锁</strong>：Redisson 的 <code>RLock</code> + 自动续期足够了。</li><li><strong>如果要公平性&#x2F;可重入&#x2F;读写锁&#x2F;信号量</strong>：Redisson 都提供现成实现。</li><li><strong>如果是核心业务</strong>：用 Redisson + Redis 哨兵&#x2F;集群模式，确保高可用。</li></ul><h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>假设会发生并发冲突，在操作数据前先获取锁。</p><p><strong>Redis实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Redis分布式锁实现悲观锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWithPessimisticLock</span><span class="params">(String userId, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:account:&quot;</span> + userId;</span><br><span class="line">    <span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (tryLock(lockKey, requestId, <span class="number">30000</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 查询账户余额</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> getBalance(userId);</span><br><span class="line">            <span class="keyword">if</span> (balance &gt;= amount) &#123;</span><br><span class="line">                <span class="comment">// 扣减余额</span></span><br><span class="line">                updateBalance(userId, balance - amount);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientBalanceException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            releaseLock(lockKey, requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LockAcquisitionException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>假设不会发生冲突，在更新时检查数据是否被修改。</p><p><strong>基于版本号的乐观锁</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateWithOptimisticLock</span><span class="params">(String userId, <span class="type">int</span> amount, <span class="type">int</span> expectedVersion)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用Lua脚本保证原子性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> </span><br><span class="line">        <span class="string">&quot;local current = redis.call(&#x27;hmget&#x27;, KEYS[1], &#x27;balance&#x27;, &#x27;version&#x27;) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;if current[2] == ARGV[2] then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  if tonumber(current[1]) &gt;= tonumber(ARGV[1]) then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    redis.call(&#x27;hmset&#x27;, KEYS[1], &#x27;balance&#x27;, current[1] - ARGV[1], &#x27;version&#x27;, current[2] + 1) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return 1 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return -1 &quot;</span> +  <span class="comment">// 余额不足</span></span><br><span class="line">        <span class="string">&quot;  end &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  return 0 &quot;</span> +     <span class="comment">// 版本号不匹配</span></span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;account:&quot;</span> + userId;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, Arrays.asList(key), </span><br><span class="line">                              Arrays.asList(String.valueOf(amount), String.valueOf(expectedVersion)));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> ((Long) result).intValue();</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 更新成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockException</span>(<span class="string">&quot;数据已被修改&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientBalanceException</span>(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于CAS的乐观锁</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWithCAS</span><span class="params">(String key, Function&lt;String, String&gt; updater)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">currentValue</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 计算新值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newValue</span> <span class="operator">=</span> updater.apply(currentValue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. CAS更新</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[2]) else return nil end&quot;</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> redis.eval(script, Arrays.asList(key), </span><br><span class="line">                                  Arrays.asList(currentValue, newValue));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 更新成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新失败，重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="悲观锁-vs-乐观锁选择"><a href="#悲观锁-vs-乐观锁选择" class="headerlink" title="悲观锁 vs 乐观锁选择"></a>悲观锁 vs 乐观锁选择</h3><p><strong>悲观锁适用场景</strong>：</p><ul><li>写操作频繁，冲突概率高</li><li>业务逻辑复杂，重试成本高</li><li>对数据一致性要求严格</li></ul><p><strong>乐观锁适用场景</strong>：</p><ul><li>读多写少，冲突概率低</li><li>业务逻辑简单，重试成本低</li><li>对性能要求高</li></ul><h2 id="高可用架构（集群）"><a href="#高可用架构（集群）" class="headerlink" title="高可用架构（集群）"></a>高可用架构（集群）</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Master负责写操作，Slave负责读操作，通过复制实现数据同步。</p><p><strong>复制原理</strong>：</p><ol><li>Slave向Master发送PSYNC命令</li><li>Master执行BGSAVE生成RDB文件</li><li>Master将RDB文件发送给Slave</li><li>Slave载入RDB文件</li><li>Master将缓冲区的写命令发送给Slave</li><li>后续写命令实时同步</li></ol><p><strong>部分重同步</strong>： 网络断连后，Slave只需要同步断连期间的命令，而不是完整重同步。</p><h3 id="哨兵模式（Sentinel）"><a href="#哨兵模式（Sentinel）" class="headerlink" title="哨兵模式（Sentinel）"></a>哨兵模式（Sentinel）</h3><p>哨兵负责监控Master状态，在Master故障时自动进行故障转移。</p><p><strong>哨兵职责</strong>：</p><ul><li>监控：定期ping Master和Slave</li><li>通知：故障时通知管理员和客户端</li><li>故障转移：自动将Slave提升为新Master</li><li>配置管理：为客户端提供服务发现</li></ul><p><strong>故障转移流程</strong>：</p><ol><li>哨兵发现Master下线（主观下线）</li><li>多个哨兵确认Master下线（客观下线）</li><li>选举领导哨兵执行故障转移</li><li>选择合适的Slave作为新Master</li><li>修改其他Slave的配置指向新Master</li><li>通知客户端Master地址变更</li></ol><h3 id="集群模式（Cluster）"><a href="#集群模式（Cluster）" class="headerlink" title="集群模式（Cluster）"></a>集群模式（Cluster）</h3><p>Redis Cluster通过分片实现横向扩展和高可用。</p><p><strong>分片算法</strong>： 使用CRC16算法计算key的哈希值，然后对16384取模得到槽位号。</p><p><strong>节点通信</strong>： 使用Gossip协议在节点间交换状态信息，包括节点上线&#x2F;下线、槽位分配等。</p><p><strong>故障转移</strong>： 当Master节点故障时，其Slave自动提升为新Master，过程对客户端透明。</p><p><strong>数据迁移</strong>： 集群扩容时，需要将部分槽位从现有节点迁移到新节点。</p><h4 id="Redis-哈希槽（Hash-Slot）详解"><a href="#Redis-哈希槽（Hash-Slot）详解" class="headerlink" title="Redis 哈希槽（Hash Slot）详解"></a>Redis 哈希槽（Hash Slot）详解</h4><p>在 Redis Cluster 中，数据不是存储在单个节点上，而是被分散存储在多个节点上。为了实现这种分散存储，Redis 引入了 <strong>哈希槽（hash slot）</strong> 的概念。</p><h4 id="1-什么是哈希槽？"><a href="#1-什么是哈希槽？" class="headerlink" title="1. 什么是哈希槽？"></a>1. 什么是哈希槽？</h4><p>Redis Cluster 一共有 <strong>16384 个哈希槽（slot）</strong>，编号从 0 到 16383。集群中的每个键（key）都会通过一个固定的算法映射到这 16384 个哈希槽中的一个，然后这些哈希槽会被分配给集群中的不同节点。</p><h4 id="2-键如何映射到哈希槽？"><a href="#2-键如何映射到哈希槽？" class="headerlink" title="2. 键如何映射到哈希槽？"></a>2. 键如何映射到哈希槽？</h4><p>Redis 使用一个简单的算法来决定一个键属于哪个哈希槽：<br>$$<br>slot&#x3D;CRC16(key)(mod16384)<br>$$</p><ul><li><strong>CRC16(key)</strong>：对键名执行 CRC16 校验和计算。</li><li><strong>mod 16384</strong>：将 CRC16 校验和的结果对 16384 取模，得到的结果就是这个键所属的哈希槽编号。</li></ul><p>例如，如果你有一个键 <code>mykey</code>，Redis 会计算 <code>CRC16(&#39;mykey&#39;) % 16384</code>，得到一个 0 到 16383 之间的数字。</p><h4 id="3-哈希槽如何分配给节点？"><a href="#3-哈希槽如何分配给节点？" class="headerlink" title="3. 哈希槽如何分配给节点？"></a>3. 哈希槽如何分配给节点？</h4><p>集群中的每个节点负责管理一部分哈希槽。例如，一个三节点的集群可以这样分配哈希槽：</p><ul><li><strong>节点 A</strong>：负责哈希槽 0 到 5460。</li><li><strong>节点 B</strong>：负责哈希槽 5461 到 10922。</li><li><strong>节点 C</strong>：负责哈希槽 10923 到 16383。</li></ul><p>当一个客户端需要操作一个键时，它会首先计算这个键所属的哈希槽，然后根据哈希槽与节点的映射关系，找到负责该哈希槽的节点，并向其发送请求。</p><p>如果客户端请求的键不在当前连接的节点上，这个节点会返回一个 <code>MOVED</code> 重定向错误，告诉客户端正确的节点地址，客户端会根据这个地址重新发起请求。</p><h4 id="4-哈希槽的优势"><a href="#4-哈希槽的优势" class="headerlink" title="4. 哈希槽的优势"></a>4. 哈希槽的优势</h4><ul><li><strong>高可用性</strong>：当一个节点失效时，它所负责的哈希槽可以被其他节点接管，从而保证数据的可用性。</li><li><strong>弹性伸缩</strong>：<ul><li><strong>添加节点</strong>：当需要扩展集群时，可以添加新节点，并从现有节点上迁移一部分哈希槽到新节点上，这个过程是增量的，不需要停机。</li><li><strong>移除节点</strong>：当需要缩减集群时，可以将某个节点上的所有哈希槽迁移到其他节点，然后移除该节点。</li></ul></li></ul><h2 id="性能监控与优化"><a href="#性能监控与优化" class="headerlink" title="性能监控与优化"></a>性能监控与优化</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>Redis提供慢查询日志功能，记录执行时间超过阈值的命令。</p><p><strong>配置参数</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">slowlog-log-slower-than</span> <span class="number">10000</span>  <span class="comment"># 超过10毫秒记录</span></span><br><span class="line"><span class="string">slowlog-max-len</span> <span class="number">128</span>           <span class="comment"># 最多保存128条记录</span></span><br></pre></td></tr></table></figure><p><strong>查看慢查询</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLOWLOG GET 10  <span class="comment"># 获取最近10条慢查询</span></span><br></pre></td></tr></table></figure><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p>使用MEMORY命令分析内存使用情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MEMORY USAGE key         <span class="comment"># 查看key占用内存</span></span><br><span class="line">MEMORY STATS            <span class="comment"># 查看内存统计信息</span></span><br><span class="line">MEMORY DOCTOR           <span class="comment"># 内存使用建议</span></span><br></pre></td></tr></table></figure><h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><p><strong>避免大key</strong>：</p><ul><li>单个key的value不要超过10KB</li><li>集合类型元素数量控制在合理范围</li><li>使用SCAN代替KEYS命令</li></ul><p><strong>合理使用数据结构</strong>：</p><ul><li>小对象使用Hash而不是多个String</li><li>合理设置ziplist等压缩结构的阈值</li><li>使用位图(bitmap)存储布尔类型大数据集</li></ul><p><strong>网络优化</strong>：</p><ul><li>使用Pipeline批量操作</li><li>合理设置客户端连接池</li><li>启用TCP_NODELAY选项</li></ul><p><strong>持久化优化</strong>：</p><ul><li>根据业务需求选择RDB或AOF</li><li>合理配置自动保存条件</li><li>在从节点上进行持久化操作</li></ul><p>这些详细的技术点涵盖了Redis的核心概念、常见问题解决方案和实际应用场景，是Redis技术面试的重要考查内容。掌握这些知识点并能结合实际项目经验进行说明，将大大提高面试通过率。</p><h2 id="内存管理与淘汰机制"><a href="#内存管理与淘汰机制" class="headerlink" title="内存管理与淘汰机制"></a>内存管理与淘汰机制</h2><h3 id="内存淘汰策略详解"><a href="#内存淘汰策略详解" class="headerlink" title="内存淘汰策略详解"></a>内存淘汰策略详解</h3><p>当Redis内存使用达到maxmemory限制时，会根据配置的策略淘汰数据。</p><p><strong>8种淘汰策略</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对所有key</span></span><br><span class="line">noeviction          <span class="comment"># 不淘汰，写入返回错误</span></span><br><span class="line">allkeys-lru         <span class="comment"># 所有key中淘汰最近最少使用</span></span><br><span class="line">allkeys-lfu         <span class="comment"># 所有key中淘汰最少频率使用</span></span><br><span class="line">allkeys-random      <span class="comment"># 所有key中随机淘汰</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对设置了过期时间的key</span></span><br><span class="line">volatile-lru        <span class="comment"># 过期key中淘汰最近最少使用</span></span><br><span class="line">volatile-lfu        <span class="comment"># 过期key中淘汰最少频率使用</span></span><br><span class="line">volatile-random     <span class="comment"># 过期key中随机淘汰</span></span><br><span class="line">volatile-ttl        <span class="comment"># 过期key中淘汰即将过期的</span></span><br></pre></td></tr></table></figure><p><strong>LRU vs LFU 实现细节</strong>： Redis的LRU并非严格的LRU，而是近似LRU算法：</p><ul><li>每个key都有24位的时钟字段记录访问时间</li><li>淘汰时随机采样5个key（可配置），选择时钟值最小的</li></ul><p>LFU算法维护访问频率：</p><ul><li>高16位存储上次访问时间</li><li>低8位存储访问频率计数器</li><li>计数器采用概率性递增，避免频率无限增长</li></ul><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p><strong>产生原因</strong>：</p><ul><li>频繁的数据更新导致内存分配&#x2F;释放</li><li>Redis使用jemalloc内存分配器，存在内存对齐</li><li>删除大key后留下内存空洞</li></ul><p><strong>检测方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"><span class="comment"># 关注 mem_fragmentation_ratio 指标</span></span><br><span class="line"><span class="comment"># 比值 &gt; 1.5 表示碎片较多</span></span><br><span class="line"><span class="comment"># 比值 &lt; 1 表示使用了swap，性能严重下降</span></span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><ol><li><strong>内存整理</strong>（Redis 4.0+）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET activedefrag <span class="built_in">yes</span>        <span class="comment"># 开启自动整理</span></span><br><span class="line">CONFIG SET active-defrag-threshold-lower 10  <span class="comment"># 碎片率超过10%启动</span></span><br><span class="line">MEMORY PURGE                       <span class="comment"># 手动触发整理</span></span><br></pre></td></tr></table></figure><ol><li><strong>重启Redis</strong>：最彻底但影响服务可用性</li><li><strong>优化数据结构</strong>：减少小对象，使用Hash存储相关数据</li></ol><h2 id="过期策略与删除机制"><a href="#过期策略与删除机制" class="headerlink" title="过期策略与删除机制"></a>过期策略与删除机制</h2><h3 id="三种过期删除策略"><a href="#三种过期删除策略" class="headerlink" title="三种过期删除策略"></a>三种过期删除策略</h3><p><strong>定时删除</strong>：设置过期时间时创建定时器，到期立即删除</p><ul><li>优点：及时释放内存</li><li>缺点：消耗CPU资源创建和管理定时器</li></ul><p><strong>惰性删除</strong>：访问key时检查是否过期，过期则删除</p><ul><li>优点：CPU友好，只在必要时删除</li><li>缺点：内存不友好，过期key可能长期占用内存</li></ul><p><strong>定期删除</strong>：定期随机检查部分key，删除过期的</p><ul><li>Redis的实际策略，平衡CPU和内存使用</li></ul><h3 id="Redis过期删除实现"><a href="#Redis过期删除实现" class="headerlink" title="Redis过期删除实现"></a>Redis过期删除实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的过期删除逻辑</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">activeExpireCycle</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">current_db</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">timelimit_exit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">        redisDb *db = server.db + current_db % server.dbnum;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">iteration</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (iteration &lt; <span class="number">20</span>) &#123;  <span class="comment">// 最多检查20个key</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sampled</span> <span class="operator">=</span> <span class="number">0</span>, expired = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 随机选择key检查过期</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                dictEntry *de = dictGetRandomKey(db-&gt;expires);</span><br><span class="line">                <span class="keyword">if</span> (de == NULL) <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                sampled++;</span><br><span class="line">                <span class="keyword">if</span> (keyIsExpired(db, de)) &#123;</span><br><span class="line">                    deleteExpiredKey(db, de);</span><br><span class="line">                    expired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果过期比例超过25%，继续下轮检查</span></span><br><span class="line">            <span class="keyword">if</span> (expired &gt; <span class="number">5</span>) iteration++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current_db++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构底层实现深度解析"><a href="#数据结构底层实现深度解析" class="headerlink" title="数据结构底层实现深度解析"></a>数据结构底层实现深度解析</h2><h3 id="压缩列表（ZipList）演进"><a href="#压缩列表（ZipList）演进" class="headerlink" title="压缩列表（ZipList）演进"></a>压缩列表（ZipList）演进</h3><p>Redis 7.0用ListPack替代了ZipList，解决了级联更新问题。</p><p><strong>ZipList问题</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZipList结构导致的级联更新</span></span><br><span class="line"><span class="comment">// 当插入元素导致某个entry的长度改变时</span></span><br><span class="line"><span class="comment">// 可能引起后续所有entry的重新编码</span></span><br></pre></td></tr></table></figure><p><strong>ListPack优势</strong>：</p><ul><li>每个元素独立编码，避免级联更新</li><li>支持从尾部遍历，提高某些操作效率</li></ul><h3 id="字典扩容与rehash"><a href="#字典扩容与rehash" class="headerlink" title="字典扩容与rehash"></a>字典扩容与rehash</h3><p>Redis字典使用增量式rehash避免阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渐进式rehash实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">empty_visits</span> <span class="operator">=</span> n * <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 跳过空桶</span></span><br><span class="line">        <span class="keyword">while</span> (d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == NULL) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 迁移桶中所有元素</span></span><br><span class="line">        dictEntry *de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            dictEntry *nextde = de-&gt;next;</span><br><span class="line">            unsigned <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = NULL;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络模型与性能优化"><a href="#网络模型与性能优化" class="headerlink" title="网络模型与性能优化"></a>网络模型与性能优化</h2><h3 id="Redis-6-0-多线程I-O"><a href="#Redis-6-0-多线程I-O" class="headerlink" title="Redis 6.0 多线程I&#x2F;O"></a>Redis 6.0 多线程I&#x2F;O</h3><p>多线程只用于网络I&#x2F;O，命令执行仍是单线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程I/O处理流程</span></span><br><span class="line"><span class="keyword">void</span> *IOThreadMain(<span class="keyword">void</span> *myid) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待主线程分配任务</span></span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[id]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (io_threads_list[id] &amp;&amp; io_threads_pending[id] == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;io_threads_cond[id], &amp;io_threads_mutex[id]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理读写任务</span></span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line">        listRewind(io_threads_list[id], &amp;li);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *c = listNodeValue(ln);</span><br><span class="line">            <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                writeToClient(c, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_READ) &#123;</span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        io_threads_pending[id] = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;io_threads_mutex[id]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端连接管理"><a href="#客户端连接管理" class="headerlink" title="客户端连接管理"></a>客户端连接管理</h3><p><strong>连接池配置优化</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Jedis连接池配置</span></span><br><span class="line"><span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">config.setMaxTotal(<span class="number">200</span>);                    <span class="comment">// 最大连接数</span></span><br><span class="line">config.setMaxIdle(<span class="number">50</span>);                      <span class="comment">// 最大空闲连接</span></span><br><span class="line">config.setMinIdle(<span class="number">10</span>);                      <span class="comment">// 最小空闲连接</span></span><br><span class="line">config.setTestOnBorrow(<span class="literal">true</span>);               <span class="comment">// 获取连接时测试</span></span><br><span class="line">config.setTestOnReturn(<span class="literal">true</span>);               <span class="comment">// 归还连接时测试</span></span><br><span class="line">config.setTestWhileIdle(<span class="literal">true</span>);              <span class="comment">// 空闲时测试</span></span><br><span class="line">config.setTimeBetweenEvictionRunsMillis(<span class="number">30000</span>);  <span class="comment">// 检查间隔</span></span><br><span class="line">config.setNumTestsPerEvictionRun(<span class="number">10</span>);       <span class="comment">// 每次检查连接数</span></span><br><span class="line">config.setMinEvictableIdleTimeMillis(<span class="number">60000</span>);     <span class="comment">// 最小空闲时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config, <span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br></pre></td></tr></table></figure><p><strong>Pipeline优化</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pipeline批量操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchSet</span><span class="params">(Map&lt;String, String&gt; data)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource()) &#123;</span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : data.entrySet()) &#123;</span><br><span class="line">            pipeline.set(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Object&gt; results = pipeline.syncAndReturnAll();</span><br><span class="line">        <span class="comment">// 处理结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级数据类型与应用"><a href="#高级数据类型与应用" class="headerlink" title="高级数据类型与应用"></a>高级数据类型与应用</h2><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>用于基数统计，占用内存固定（12KB），误差率0.81%。</p><p><strong>实现原理</strong>：</p><ul><li>基于概率算法，通过观察随机数的最大前导零个数估算基数</li><li>使用调和平均数减少误差</li><li>适用于UV统计等场景</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网站UV统计</span></span><br><span class="line">PFADD uv:20230815 user1 user2 user3</span><br><span class="line">PFCOUNT uv:20230815                    <span class="comment"># 获取UV数量</span></span><br><span class="line">PFMERGE uv:week uv:20230815 uv:20230816  <span class="comment"># 合并多日数据</span></span><br></pre></td></tr></table></figure><h3 id="布隆过滤器（Redis-Module）"><a href="#布隆过滤器（Redis-Module）" class="headerlink" title="布隆过滤器（Redis Module）"></a>布隆过滤器（Redis Module）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis布隆过滤器模块</span></span><br><span class="line">BF.RESERVE myfilter 0.01 1000000       <span class="comment"># 创建过滤器，误报率0.01%，预期元素100万</span></span><br><span class="line">BF.ADD myfilter <span class="string">&quot;user123&quot;</span>              <span class="comment"># 添加元素</span></span><br><span class="line">BF.EXISTS myfilter <span class="string">&quot;user123&quot;</span>           <span class="comment"># 检查元素是否存在</span></span><br><span class="line">BF.MADD myfilter item1 item2 item3     <span class="comment"># 批量添加</span></span><br><span class="line">BF.MEXISTS myfilter item1 item2 item3  <span class="comment"># 批量检查</span></span><br></pre></td></tr></table></figure><h3 id="Geo地理位置"><a href="#Geo地理位置" class="headerlink" title="Geo地理位置"></a>Geo地理位置</h3><p>基于Sorted Set实现，使用GeoHash算法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加地理位置</span></span><br><span class="line">GEOADD cities 116.397128 39.916527 <span class="string">&quot;北京&quot;</span> 121.473701 31.230416 <span class="string">&quot;上海&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算距离</span></span><br><span class="line">GEODIST cities <span class="string">&quot;北京&quot;</span> <span class="string">&quot;上海&quot;</span> km</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范围查询</span></span><br><span class="line">GEORADIUS cities 116.397128 39.916527 1000 km WITHDIST WITHCOORD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据成员查询</span></span><br><span class="line">GEORADIUSBYMEMBER cities <span class="string">&quot;北京&quot;</span> 1000 km</span><br></pre></td></tr></table></figure><h2 id="安全性问题与防护"><a href="#安全性问题与防护" class="headerlink" title="安全性问题与防护"></a>安全性问题与防护</h2><h3 id="常见安全漏洞"><a href="#常见安全漏洞" class="headerlink" title="常见安全漏洞"></a>常见安全漏洞</h3><p><strong>命令注入</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误做法：直接拼接用户输入</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;user:&quot;</span> + userInput;  <span class="comment">// userInput可能包含恶意命令</span></span><br><span class="line">jedis.eval(<span class="string">&quot;return redis.call(&#x27;get&#x27;, &#x27;&quot;</span> + key + <span class="string">&quot;&#x27;)&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法：使用参数化查询</span></span><br><span class="line">jedis.eval(<span class="string">&quot;return redis.call(&#x27;get&#x27;, KEYS[1])&quot;</span>, <span class="number">1</span>, key);</span><br></pre></td></tr></table></figure><p><strong>未授权访问</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis.conf安全配置</span></span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1                        <span class="comment"># 绑定指定IP</span></span><br><span class="line">requirepass your_password              <span class="comment"># 设置密码</span></span><br><span class="line">protected-mode <span class="built_in">yes</span>                     <span class="comment"># 开启保护模式</span></span><br><span class="line">port 0                                <span class="comment"># 禁用默认端口</span></span><br><span class="line">port 6380                             <span class="comment"># 使用非标准端口</span></span><br></pre></td></tr></table></figure><p><strong>危险命令禁用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名危险命令</span></span><br><span class="line">rename-command FLUSHDB <span class="string">&quot;&quot;</span>             <span class="comment"># 禁用FLUSHDB</span></span><br><span class="line">rename-command FLUSHALL <span class="string">&quot;&quot;</span>            <span class="comment"># 禁用FLUSHALL</span></span><br><span class="line">rename-command SHUTDOWN <span class="string">&quot;REDIS_SHUTDOWN&quot;</span>  <span class="comment"># 重命名SHUTDOWN</span></span><br><span class="line">rename-command CONFIG <span class="string">&quot;REDIS_CONFIG&quot;</span>   <span class="comment"># 重命名CONFIG</span></span><br></pre></td></tr></table></figure><h3 id="ACL访问控制（Redis-6-0-）"><a href="#ACL访问控制（Redis-6-0-）" class="headerlink" title="ACL访问控制（Redis 6.0+）"></a>ACL访问控制（Redis 6.0+）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">ACL SETUSER alice on &gt;password123 ~cached:* +get +<span class="built_in">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看用户权限</span></span><br><span class="line">ACL LIST</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">ACL DELUSER alice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查权限</span></span><br><span class="line">AUTH alice password123</span><br></pre></td></tr></table></figure><h2 id="监控与运维"><a href="#监控与运维" class="headerlink" title="监控与运维"></a>监控与运维</h2><h3 id="关键监控指标"><a href="#关键监控指标" class="headerlink" title="关键监控指标"></a>关键监控指标</h3><p><strong>性能指标</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过INFO命令获取</span></span><br><span class="line">INFO stats</span><br><span class="line"><span class="comment"># 关注指标：</span></span><br><span class="line"><span class="comment"># - instantaneous_ops_per_sec: QPS</span></span><br><span class="line"><span class="comment"># - keyspace_hits/keyspace_misses: 命中率</span></span><br><span class="line"><span class="comment"># - used_cpu_sys/used_cpu_user: CPU使用率</span></span><br><span class="line"><span class="comment"># - connected_clients: 连接数</span></span><br><span class="line"><span class="comment"># - blocked_clients: 阻塞连接数</span></span><br></pre></td></tr></table></figure><p><strong>内存指标</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"><span class="comment"># 关注指标：</span></span><br><span class="line"><span class="comment"># - used_memory: 已使用内存</span></span><br><span class="line"><span class="comment"># - used_memory_rss: 物理内存占用</span></span><br><span class="line"><span class="comment"># - mem_fragmentation_ratio: 内存碎片率</span></span><br><span class="line"><span class="comment"># - used_memory_peak: 内存使用峰值</span></span><br></pre></td></tr></table></figure><p><strong>持久化指标</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO persistence</span><br><span class="line"><span class="comment"># 关注指标：</span></span><br><span class="line"><span class="comment"># - rdb_last_save_time: 最后RDB保存时间</span></span><br><span class="line"><span class="comment"># - aof_last_rewrite_time_sec: AOF重写耗时</span></span><br><span class="line"><span class="comment"># - aof_current_size: AOF文件大小</span></span><br></pre></td></tr></table></figure><h3 id="故障排查常用命令"><a href="#故障排查常用命令" class="headerlink" title="故障排查常用命令"></a>故障排查常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端连接信息</span></span><br><span class="line">CLIENT LIST</span><br><span class="line">CLIENT INFO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 慢查询分析</span></span><br><span class="line">SLOWLOG GET 10</span><br><span class="line">CONFIG GET slowlog-log-slower-than</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大key查找</span></span><br><span class="line">MEMORY USAGE keyname</span><br><span class="line">redis-cli --bigkeys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 热点key分析</span></span><br><span class="line">redis-cli --hotkeys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 延迟监控</span></span><br><span class="line">LATENCY HISTORY <span class="built_in">command</span></span><br><span class="line">CONFIG SET latency-monitor-threshold 100</span><br></pre></td></tr></table></figure><h2 id="特殊应用场景"><a href="#特殊应用场景" class="headerlink" title="特殊应用场景"></a>特殊应用场景</h2><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p><strong>固定窗口限流</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAllowed</span><span class="params">(String key, <span class="type">int</span> limit, <span class="type">int</span> window)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span> / window;</span><br><span class="line">        <span class="type">String</span> <span class="variable">windowKey</span> <span class="operator">=</span> key + <span class="string">&quot;:&quot;</span> + current;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> </span><br><span class="line">            <span class="string">&quot;local count = redis.call(&#x27;incr&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;if count == 1 then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;end &quot;</span> +</span><br><span class="line">            <span class="string">&quot;return count&quot;</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> (Long) jedis.eval(script, Arrays.asList(windowKey), </span><br><span class="line">                                      Arrays.asList(String.valueOf(window)));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count &lt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滑动窗口限流</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">slidingWindowLimit</span><span class="params">(String key, <span class="type">int</span> limit, <span class="type">int</span> window)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">windowStart</span> <span class="operator">=</span> now - window * <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> </span><br><span class="line">        <span class="string">&quot;redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;local count = redis.call(&#x27;zcard&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;if count &lt; tonumber(ARGV[2]) then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  redis.call(&#x27;zadd&#x27;, KEYS[1], ARGV[3], ARGV[3]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[4]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  return 1 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  return 0 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> (Long) jedis.eval(script, Arrays.asList(key),</span><br><span class="line">        Arrays.asList(String.valueOf(windowStart), String.valueOf(limit),</span><br><span class="line">                     String.valueOf(now), String.valueOf(window)));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSessionManager</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createSession</span><span class="params">(String sessionId, String userId, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;session:&quot;</span> + sessionId;</span><br><span class="line">        Map&lt;String, Object&gt; sessionData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        sessionData.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">        sessionData.put(<span class="string">&quot;createTime&quot;</span>, System.currentTimeMillis());</span><br><span class="line">        </span><br><span class="line">        redisTemplate.opsForHash().putAll(key, sessionData);</span><br><span class="line">        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSession</span><span class="params">(String sessionId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;session:&quot;</span> + sessionId;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">renewSession</span><span class="params">(String sessionId, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;session:&quot;</span> + sessionId;</span><br><span class="line">        <span class="keyword">if</span> (redisTemplate.hasKey(key)) &#123;</span><br><span class="line">            redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息队列实现"><a href="#消息队列实现" class="headerlink" title="消息队列实现"></a>消息队列实现</h3><p><strong>基于List的简单队列</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(String queue, String message)</span> &#123;</span><br><span class="line">        jedis.lpush(queue, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消费者（阻塞式）</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">consume</span><span class="params">(String queue, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = jedis.brpop(timeout, queue);</span><br><span class="line">        <span class="keyword">return</span> result != <span class="literal">null</span> ? result.get(<span class="number">1</span>) : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于Stream的消息队列</strong>（Redis 5.0+）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产消息</span></span><br><span class="line"><span class="string">XADD</span> <span class="string">mystream</span> <span class="string">*</span> <span class="string">field1</span> <span class="string">value1</span> <span class="string">field2</span> <span class="string">value2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建消费者组</span></span><br><span class="line"><span class="string">XGROUP</span> <span class="string">CREATE</span> <span class="string">mystream</span> <span class="string">mygroup</span> <span class="string">$</span> <span class="string">MKSTREAM</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费消息</span></span><br><span class="line"><span class="string">XREADGROUP</span> <span class="string">GROUP</span> <span class="string">mygroup</span> <span class="string">consumer1</span> <span class="string">COUNT</span> <span class="number">10</span> <span class="string">STREAMS</span> <span class="string">mystream</span> <span class="string">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认消息</span></span><br><span class="line"><span class="string">XACK</span> <span class="string">mystream</span> <span class="string">mygroup</span> <span class="string">message_id</span></span><br></pre></td></tr></table></figure><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDelayQueue</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDelayTask</span><span class="params">(String task, <span class="type">long</span> delayTime)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">executeTime</span> <span class="operator">=</span> System.currentTimeMillis() + delayTime;</span><br><span class="line">        jedis.zadd(<span class="string">&quot;delay_queue&quot;</span>, executeTime, task);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getReadyTasks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Set&lt;String&gt; tasks = jedis.zrangeByScore(<span class="string">&quot;delay_queue&quot;</span>, <span class="number">0</span>, now);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!tasks.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 原子性删除已获取的任务</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> </span><br><span class="line">                <span class="string">&quot;local tasks = redis.call(&#x27;zrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;if #tasks &gt; 0 then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;  redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return tasks&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            List&lt;String&gt; result = (List&lt;String&gt;) jedis.eval(script, </span><br><span class="line">                Arrays.asList(<span class="string">&quot;delay_queue&quot;</span>), Arrays.asList(String.valueOf(now)));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能调优技巧"><a href="#性能调优技巧" class="headerlink" title="性能调优技巧"></a>性能调优技巧</h2><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p><strong>使用Hash存储小对象</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐：为每个用户字段单独设置key</span></span><br><span class="line">jedis.set(<span class="string">&quot;user:1001:name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;user:1001:age&quot;</span>, <span class="string">&quot;25&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;user:1001:email&quot;</span>, <span class="string">&quot;zhang@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：使用Hash存储</span></span><br><span class="line">jedis.hset(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">jedis.hset(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;25&quot;</span>);</span><br><span class="line">jedis.hset(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;zhang@example.com&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>合理设置过期时间</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免同时过期导致雪崩</span></span><br><span class="line"><span class="type">int</span> <span class="variable">baseExpire</span> <span class="operator">=</span> <span class="number">3600</span>;  <span class="comment">// 1小时</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> baseExpire + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);  <span class="comment">// 增加0-5分钟随机时间</span></span><br><span class="line">jedis.setex(key, randomExpire, value);</span><br></pre></td></tr></table></figure><h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p><strong>批量操作优化</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Pipeline</span></span><br><span class="line"><span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    pipeline.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">pipeline.sync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用原生批量命令</span></span><br><span class="line">Map&lt;String, String&gt; batch = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ... 填充数据</span></span><br><span class="line">jedis.mset(flattenMap(batch));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p><strong>Lua脚本减少网络往返</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 原子性增加库存</span><br><span class="line"><span class="type">local</span> <span class="variable">current</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> current == <span class="literal">false</span> then</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  -- key不存在</span><br><span class="line"><span class="type">end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">current</span> <span class="operator">=</span> tonumber(current)</span><br><span class="line"><span class="keyword">if</span> current &gt;= tonumber(ARGV[<span class="number">1</span>]) then</span><br><span class="line">    redis.call(<span class="string">&#x27;decrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> current - tonumber(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">2</span>  -- 库存不足</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Linux </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2025/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2025/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-数组-Array"><a href="#1-数组-Array" class="headerlink" title="1. 数组 (Array)"></a>1. 数组 (Array)</h1><p><strong>特点</strong>：连续内存，随机访问 O(1)，插入&#x2F;删除 O(n)。</p><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找（线性查找）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == target) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（指定位置）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insert(<span class="type">int</span>[] arr, <span class="type">int</span> pos, <span class="type">int</span> val) &#123;</span><br><span class="line">    <span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; newArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == pos) newArr[i] = val;</span><br><span class="line">        <span class="keyword">else</span> newArr[i] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（指定位置）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] delete(<span class="type">int</span>[] arr, <span class="type">int</span> pos) &#123;</span><br><span class="line">    <span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == pos) <span class="keyword">continue</span>;</span><br><span class="line">        newArr[j++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i]; arr[i] = arr[j]; arr[j] = tmp;</span><br><span class="line">        i++; j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-链表-Linked-List"><a href="#2-链表-Linked-List" class="headerlink" title="2. 链表 (Linked List)"></a>2. 链表 (Linked List)</h1><p><strong>特点</strong>：动态存储，插入&#x2F;删除 O(1)，随机访问 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next)</span><br><span class="line">        System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（头插）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">insertHead</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    node.next = head;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（指定节点后）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertAfter</span><span class="params">(ListNode node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    newNode.next = node.next;</span><br><span class="line">    node.next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（按值）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">delete</span><span class="params">(ListNode head, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.val == target) <span class="keyword">return</span> head.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.next.val == target) &#123;</span><br><span class="line">            p.next = p.next.next; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-栈-Stack"><a href="#3-栈-Stack" class="headerlink" title="3. 栈 (Stack)"></a>3. 栈 (Stack)</h1><p><strong>特点</strong>：LIFO，常用数组或链表实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123; list.addLast(val); &#125; <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.removeLast(); &#125;   <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.getLast(); &#125;     <span class="comment">// 查看栈顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.isEmpty(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-队列-Queue"><a href="#4-队列-Queue" class="headerlink" title="4. 队列 (Queue)"></a>4. 队列 (Queue)</h1><p><strong>特点</strong>：FIFO，可以用链表或循环数组实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">int</span> val)</span> &#123; list.addLast(val); &#125; <span class="comment">// 入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.removeFirst(); &#125; <span class="comment">// 出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.getFirst(); &#125;       <span class="comment">// 查看队首</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="keyword">return</span> list.isEmpty(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双端队列 Deque</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">deque.addFirst(<span class="number">1</span>); <span class="comment">// 头插</span></span><br><span class="line">deque.addLast(<span class="number">2</span>);  <span class="comment">// 尾插</span></span><br><span class="line">deque.removeFirst();</span><br><span class="line">deque.removeLast();</span><br></pre></td></tr></table></figure><hr><h1 id="5-树-Tree"><a href="#5-树-Tree" class="headerlink" title="5. 树 (Tree)"></a>5. 树 (Tree)</h1><p>以 <strong>二叉树</strong> 为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历 (根-左-右)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preorder(root.left);</span><br><span class="line">    preorder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历 (左-根-右)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root.left);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inorder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历 (左-右-根)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postorder(root.left);</span><br><span class="line">    postorder(root.right);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历 (BFS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) q.add(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) q.add(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="6-堆-Heap"><a href="#6-堆-Heap" class="headerlink" title="6. 堆 (Heap)"></a>6. 堆 (Heap)</h1><p>常用 <strong>最小堆 &#x2F; 最大堆</strong>，一般用数组实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">minHeap.add(<span class="number">3</span>);</span><br><span class="line">minHeap.add(<span class="number">1</span>);</span><br><span class="line">minHeap.add(<span class="number">5</span>);</span><br><span class="line">System.out.println(minHeap.poll()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">maxHeap.add(<span class="number">3</span>);</span><br><span class="line">maxHeap.add(<span class="number">1</span>);</span><br><span class="line">maxHeap.add(<span class="number">5</span>);</span><br><span class="line">System.out.println(maxHeap.poll()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><hr><h1 id="7-图-Graph"><a href="#7-图-Graph" class="headerlink" title="7. 图 (Graph)"></a>7. 图 (Graph)</h1><p>常见表示：<strong>邻接表</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        adj.computeIfAbsent(u, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(v);</span><br><span class="line">        adj.computeIfAbsent(v, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(u); <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS 遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(start);</span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> nei : adj.getOrDefault(node, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(nei)) &#123;</span><br><span class="line">                    visited.add(nei);</span><br><span class="line">                    q.add(nei);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DFS 遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        dfsHelper(start, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfsHelper</span><span class="params">(<span class="type">int</span> node, Set&lt;Integer&gt; visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(node)) <span class="keyword">return</span>;</span><br><span class="line">        visited.add(node);</span><br><span class="line">        System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nei : adj.getOrDefault(node, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">            dfsHelper(nei, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令大全</title>
      <link href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="📌-一、Linux-常见命令大全"><a href="#📌-一、Linux-常见命令大全" class="headerlink" title="📌 一、Linux 常见命令大全"></a>📌 一、Linux 常见命令大全</h1><h3 id="🔹-文件与目录操作"><a href="#🔹-文件与目录操作" class="headerlink" title="🔹 文件与目录操作"></a>🔹 文件与目录操作</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>ls</code></td><td>列出目录内容</td><td><code>ls -al</code> 显示隐藏文件和详细信息</td></tr><tr><td><code>pwd</code></td><td>显示当前目录</td><td><code>pwd</code></td></tr><tr><td><code>cd</code></td><td>切换目录</td><td><code>cd /usr/local</code></td></tr><tr><td><code>mkdir</code></td><td>创建目录</td><td><code>mkdir -p /data/logs</code></td></tr><tr><td><code>rmdir</code></td><td>删除空目录</td><td><code>rmdir old</code></td></tr><tr><td><code>rm</code></td><td>删除文件&#x2F;目录</td><td><code>rm -rf /tmp/test</code></td></tr><tr><td><code>cp</code></td><td>复制文件&#x2F;目录</td><td><code>cp a.txt /tmp/</code>，<code>cp -r dir1 dir2</code></td></tr><tr><td><code>mv</code></td><td>移动&#x2F;重命名</td><td><code>mv old.txt new.txt</code></td></tr><tr><td><code>find</code></td><td>查找文件</td><td><code>find / -name &quot;*.log&quot;</code></td></tr><tr><td><code>locate</code></td><td>快速查找文件（需 <code>updatedb</code>）</td><td><code>locate nginx.conf</code></td></tr></tbody></table><hr><h3 id="🔹-文件查看与编辑"><a href="#🔹-文件查看与编辑" class="headerlink" title="🔹 文件查看与编辑"></a>🔹 文件查看与编辑</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>cat</code></td><td>查看文件内容</td><td><code>cat file.txt</code></td></tr><tr><td><code>tac</code></td><td>反向输出</td><td><code>tac file.txt</code></td></tr><tr><td><code>less</code></td><td>分页查看</td><td><code>less /var/log/syslog</code></td></tr><tr><td><code>head</code></td><td>查看前 N 行</td><td><code>head -n 20 file.log</code></td></tr><tr><td><code>tail</code></td><td>查看末尾 N 行</td><td><code>tail -f app.log</code> 实时跟踪</td></tr><tr><td><code>wc</code></td><td>统计行、字数、字符数</td><td><code>wc -l file.txt</code></td></tr><tr><td><code>nano/vim</code></td><td>编辑文件</td><td><code>vim nginx.conf</code></td></tr></tbody></table><hr><h3 id="🔹-用户与权限"><a href="#🔹-用户与权限" class="headerlink" title="🔹 用户与权限"></a>🔹 用户与权限</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>whoami</code></td><td>当前用户</td><td><code>whoami</code></td></tr><tr><td><code>id</code></td><td>用户 ID 和组 ID</td><td><code>id root</code></td></tr><tr><td><code>useradd</code></td><td>新建用户</td><td><code>useradd -m testuser</code></td></tr><tr><td><code>passwd</code></td><td>修改密码</td><td><code>passwd testuser</code></td></tr><tr><td><code>su</code></td><td>切换用户</td><td><code>su - testuser</code></td></tr><tr><td><code>sudo</code></td><td>以 root 权限执行</td><td><code>sudo apt update</code></td></tr><tr><td><code>chmod</code></td><td>修改权限</td><td><code>chmod 755 file.sh</code></td></tr><tr><td><code>chown</code></td><td>修改属主</td><td><code>chown user:group file.txt</code></td></tr></tbody></table><hr><h3 id="🔹-系统管理"><a href="#🔹-系统管理" class="headerlink" title="🔹 系统管理"></a>🔹 系统管理</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>ps</code></td><td>查看进程</td><td>&#96;ps -ef</td></tr><tr><td><code>top</code></td><td>实时查看进程</td><td><code>top</code></td></tr><tr><td><code>htop</code></td><td>高级 top（需安装）</td><td><code>htop</code></td></tr><tr><td><code>kill</code></td><td>杀进程</td><td><code>kill -9 1234</code></td></tr><tr><td><code>df -h</code></td><td>查看磁盘使用</td><td><code>df -h</code></td></tr><tr><td><code>du -sh</code></td><td>查看目录大小</td><td><code>du -sh /var/log</code></td></tr><tr><td><code>free -h</code></td><td>查看内存使用</td><td><code>free -h</code></td></tr><tr><td><code>uptime</code></td><td>系统运行时长</td><td><code>uptime</code></td></tr><tr><td><code>uname -a</code></td><td>系统信息</td><td><code>uname -a</code></td></tr><tr><td><code>shutdown -h now</code></td><td>立刻关机</td><td><code>shutdown -r now</code> 重启</td></tr></tbody></table><hr><h3 id="🔹-网络相关"><a href="#🔹-网络相关" class="headerlink" title="🔹 网络相关"></a>🔹 网络相关</h3><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>ping</code></td><td>测试网络连通</td><td><code>ping www.baidu.com</code></td></tr><tr><td><code>curl</code></td><td>请求 URL</td><td><code>curl -I https://www.baidu.com</code></td></tr><tr><td><code>wget</code></td><td>下载文件</td><td><code>wget http://example.com/file.zip</code></td></tr><tr><td><code>netstat -tulnp</code></td><td>查看端口占用</td><td>&#96;netstat -tulnp</td></tr><tr><td><code>ss -lntp</code></td><td>更快的端口查询</td><td><code>ss -lntp</code></td></tr><tr><td><code>scp</code></td><td>远程拷贝文件</td><td><code>scp file.txt user@host:/path/</code></td></tr><tr><td><code>ssh</code></td><td>登录远程主机</td><td><code>ssh user@192.168.1.1</code></td></tr></tbody></table><hr><h1 id="📌-二、MySQL-常见命令大全"><a href="#📌-二、MySQL-常见命令大全" class="headerlink" title="📌 二、MySQL 常见命令大全"></a>📌 二、MySQL 常见命令大全</h1><h3 id="🔹-登录与基本操作"><a href="#🔹-登录与基本操作" class="headerlink" title="🔹 登录与基本操作"></a>🔹 登录与基本操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p               <span class="comment"># 登录 MySQL</span></span><br><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p   <span class="comment"># 指定地址端口</span></span><br><span class="line"><span class="built_in">exit</span>;                          <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><h3 id="🔹-数据库操作"><a href="#🔹-数据库操作" class="headerlink" title="🔹 数据库操作"></a>🔹 数据库操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;                <span class="comment">-- 查看所有数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE testdb;        <span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE testdb;          <span class="comment">-- 删除数据库</span></span><br><span class="line">USE testdb;                    <span class="comment">-- 切换数据库</span></span><br></pre></td></tr></table></figure><h3 id="🔹-表操作"><a href="#🔹-表操作" class="headerlink" title="🔹 表操作"></a>🔹 表操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;                               <span class="comment">-- 查看表</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> users;                            <span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span></span><br><span class="line">);                                         <span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;                          <span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">ADD</span> email <span class="type">VARCHAR</span>(<span class="number">100</span>);  <span class="comment">-- 增加列</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> email;       <span class="comment">-- 删除列</span></span><br></pre></td></tr></table></figure><h3 id="🔹-数据操作-CRUD"><a href="#🔹-数据操作-CRUD" class="headerlink" title="🔹 数据操作 (CRUD)"></a>🔹 数据操作 (CRUD)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users(name, age) <span class="keyword">VALUES</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>);  <span class="comment">-- 插入</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;                             <span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">18</span>;      <span class="comment">-- 条件查询</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">25</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>;    <span class="comment">-- 更新</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>;            <span class="comment">-- 删除</span></span><br></pre></td></tr></table></figure><h3 id="🔹-用户与权限-1"><a href="#🔹-用户与权限-1" class="headerlink" title="🔹 用户与权限"></a>🔹 用户与权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;       <span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> testdb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;      <span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> testdb.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;   <span class="comment">-- 回收权限</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;                                <span class="comment">-- 删除用户</span></span><br><span class="line">FLUSH PRIVILEGES;                                    <span class="comment">-- 刷新权限</span></span><br></pre></td></tr></table></figure><h3 id="🔹-备份与恢复"><a href="#🔹-备份与恢复" class="headerlink" title="🔹 备份与恢复"></a>🔹 备份与恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p testdb &gt; testdb.sql     <span class="comment"># 导出数据库</span></span><br><span class="line">mysqldump -u root -p --all-databases &gt; all.sql</span><br><span class="line">mysql -u root -p testdb &lt; testdb.sql         <span class="comment"># 导入数据库</span></span><br></pre></td></tr></table></figure><hr><h1 id="📌-三、Git-常见命令大全"><a href="#📌-三、Git-常见命令大全" class="headerlink" title="📌 三、Git 常见命令大全"></a>📌 三、Git 常见命令大全</h1><h3 id="🔹-基础配置"><a href="#🔹-基础配置" class="headerlink" title="🔹 基础配置"></a>🔹 基础配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;YourName&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --list       <span class="comment"># 查看配置</span></span><br></pre></td></tr></table></figure><h3 id="🔹-仓库操作"><a href="#🔹-仓库操作" class="headerlink" title="🔹 仓库操作"></a>🔹 仓库操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init                          <span class="comment"># 初始化仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/xxx.git  <span class="comment"># 克隆仓库</span></span><br><span class="line">git remote -v                     <span class="comment"># 查看远程仓库</span></span><br><span class="line">git remote add origin git@github.com:xxx.git  <span class="comment"># 添加远程仓库</span></span><br></pre></td></tr></table></figure><h3 id="🔹-文件操作"><a href="#🔹-文件操作" class="headerlink" title="🔹 文件操作"></a>🔹 文件操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status        <span class="comment"># 查看状态</span></span><br><span class="line">git add file.txt  <span class="comment"># 添加文件</span></span><br><span class="line">git add .         <span class="comment"># 添加所有文件</span></span><br><span class="line">git commit -m <span class="string">&quot;描述&quot;</span>   <span class="comment"># 提交</span></span><br><span class="line">git diff          <span class="comment"># 查看修改</span></span><br><span class="line">git <span class="built_in">log</span>           <span class="comment"># 查看提交历史</span></span><br><span class="line">git reset --hard HEAD^   <span class="comment"># 回退上一个版本</span></span><br></pre></td></tr></table></figure><h3 id="🔹-分支操作"><a href="#🔹-分支操作" class="headerlink" title="🔹 分支操作"></a>🔹 分支操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch                  <span class="comment"># 查看分支</span></span><br><span class="line">git branch new-feature      <span class="comment"># 新建分支</span></span><br><span class="line">git checkout new-feature    <span class="comment"># 切换分支</span></span><br><span class="line">git checkout -b dev         <span class="comment"># 新建并切换</span></span><br><span class="line">git merge dev               <span class="comment"># 合并分支</span></span><br><span class="line">git branch -d dev           <span class="comment"># 删除分支</span></span><br></pre></td></tr></table></figure><h3 id="🔹-远程仓库"><a href="#🔹-远程仓库" class="headerlink" title="🔹 远程仓库"></a>🔹 远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main        <span class="comment"># 拉取代码</span></span><br><span class="line">git push origin main        <span class="comment"># 推送代码</span></span><br><span class="line">git push -u origin main     <span class="comment"># 关联远程分支并推送</span></span><br><span class="line">git fetch origin            <span class="comment"># 获取最新分支信息</span></span><br></pre></td></tr></table></figure><h3 id="🔹-标签管理"><a href="#🔹-标签管理" class="headerlink" title="🔹 标签管理"></a>🔹 标签管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0                        <span class="comment"># 打标签</span></span><br><span class="line">git tag                             <span class="comment"># 查看标签</span></span><br><span class="line">git push origin v1.0                <span class="comment"># 推送标签</span></span><br><span class="line">git push origin --tags              <span class="comment"># 推送所有标签</span></span><br><span class="line">git tag -d v1.0                     <span class="comment"># 删除本地标签</span></span><br><span class="line">git push origin :refs/tags/v1.0     <span class="comment"># 删除远程标签</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web</title>
      <link href="/2025/09/11/web/"/>
      <url>/2025/09/11/web/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="一、HTTP-协议概述"><a href="#一、HTTP-协议概述" class="headerlink" title="一、HTTP 协议概述"></a>一、HTTP 协议概述</h3><p>HTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，它定义了 Web 客户端（如浏览器）和 Web 服务器之间交换数据的规则。它的核心特点是<strong>无状态（Stateless）</strong>，这意味着服务器不会保存客户端的任何信息，每次请求都是独立的。</p><hr><h3 id="二、HTTP-请求（Request）"><a href="#二、HTTP-请求（Request）" class="headerlink" title="二、HTTP 请求（Request）"></a>二、HTTP 请求（Request）</h3><p>一个完整的 HTTP 请求由四部分组成：</p><h4 id="1-请求行（Request-Line）"><a href="#1-请求行（Request-Line）" class="headerlink" title="1. 请求行（Request Line）"></a>1. 请求行（Request Line）</h4><p>这是请求的第一行，它定义了请求的基本信息。</p><ul><li><strong>请求方法（Method）</strong>：如 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 等，表示对资源的操作类型。</li><li><strong>请求 URL (URI)</strong>：资源的地址。</li><li><strong>HTTP 协议版本</strong>：如 <code>HTTP/1.1</code>, <code>HTTP/2.0</code>。</li></ul><p>示例：</p><p>GET &#x2F;index.html HTTP&#x2F;1.1</p><h4 id="2-请求头（Request-Headers）"><a href="#2-请求头（Request-Headers）" class="headerlink" title="2. 请求头（Request Headers）"></a>2. 请求头（Request Headers）</h4><p>请求头提供了关于客户端、请求体和一些其他元数据的信息。它们以键值对的形式存在。</p><ul><li><strong>Host</strong>：指定请求的目标服务器的域名和端口号。</li><li><strong>User-Agent</strong>：客户端的软件类型和版本，如浏览器信息。</li><li><strong>Accept</strong>：客户端能够处理的媒体类型，告诉服务器希望返回什么格式的数据（如 <code>application/json</code>, <code>text/html</code>）。</li><li><strong>Content-Type</strong>：<strong>请求体</strong>中的数据类型，只在有请求体时使用（如 <code>POST</code>）。常见的有：<ul><li><code>application/x-www-form-urlencoded</code>：默认编码，用于提交表单数据。</li><li><code>multipart/form-data</code>：用于上传文件。</li><li><code>application/json</code>：用于前后端分离，提交 JSON 数据。</li></ul></li><li><strong>Content-Length</strong>：请求体的长度（字节）。</li><li><strong>Cookie</strong>：客户端存储的 Cookie 信息，用于会话管理。</li><li><strong>Authorization</strong>：用于身份认证，如携带 Bearer Token。</li><li><strong>Referer</strong>：请求从哪个页面跳转而来。</li></ul><h4 id="3-空行"><a href="#3-空行" class="headerlink" title="3. 空行"></a>3. 空行</h4><p>一个空行用于分隔请求头和请求体。</p><h4 id="4-请求体（Request-Body）"><a href="#4-请求体（Request-Body）" class="headerlink" title="4. 请求体（Request Body）"></a>4. 请求体（Request Body）</h4><p>请求体包含客户端提交给服务器的数据，通常用于 <code>POST</code>、<code>PUT</code> 等请求。GET 请求通常没有请求体。</p><hr><h3 id="三、HTTP-响应（Response）"><a href="#三、HTTP-响应（Response）" class="headerlink" title="三、HTTP 响应（Response）"></a>三、HTTP 响应（Response）</h3><p>一个完整的 HTTP 响应由三部分组成：</p><h4 id="1-状态行（Status-Line）"><a href="#1-状态行（Status-Line）" class="headerlink" title="1. 状态行（Status Line）"></a>1. 状态行（Status Line）</h4><p>这是响应的第一行，定义了响应的基本信息。</p><ul><li><strong>HTTP 协议版本</strong>：如 <code>HTTP/1.1</code>。</li><li><strong>状态码（Status Code）</strong>：三位数字，表示请求结果。</li><li><strong>状态信息（Reason Phrase）</strong>：对状态码的简短描述。</li></ul><p>示例：</p><p>HTTP&#x2F;1.1 200 OK</p><h4 id="2-响应头（Response-Headers）"><a href="#2-响应头（Response-Headers）" class="headerlink" title="2. 响应头（Response Headers）"></a>2. 响应头（Response Headers）</h4><p>响应头提供了关于服务器、响应体和会话的元数据信息。</p><ul><li><strong>Content-Type</strong>：<strong>响应体</strong>的数据类型。</li><li><strong>Content-Length</strong>：响应体的长度。</li><li><strong>Set-Cookie</strong>：服务器向客户端发送 Cookie，用于存储会话 ID 等信息。</li><li><strong>Location</strong>：用于重定向，指定新的 URL。</li><li><strong>Cache-Control</strong>：控制浏览器缓存行为。</li></ul><h4 id="3-空行-1"><a href="#3-空行-1" class="headerlink" title="3. 空行"></a>3. 空行</h4><p>一个空行用于分隔响应头和响应体。</p><h4 id="4-响应体（Response-Body）"><a href="#4-响应体（Response-Body）" class="headerlink" title="4. 响应体（Response Body）"></a>4. 响应体（Response Body）</h4><p>响应体包含了服务器返回给客户端的实际数据，如 HTML 网页内容、JSON 数据或图片等。</p><hr><h3 id="四、HTTP-方法的幂等性与安全性"><a href="#四、HTTP-方法的幂等性与安全性" class="headerlink" title="四、HTTP 方法的幂等性与安全性"></a>四、HTTP 方法的幂等性与安全性</h3><ul><li><strong>安全性</strong>：指请求方法不会对服务器上的资源状态产生修改。<code>GET</code> 和 <code>HEAD</code> 方法是安全的。</li><li><strong>幂等性</strong>：指请求方法重复执行多次，对服务器上的资源状态产生的影响与执行一次的影响相同。<ul><li><strong>幂等方法</strong>：<code>GET</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>。</li><li><strong>非幂等方法</strong>：<code>POST</code>。</li></ul></li></ul><table><thead><tr><th>方法</th><th>安全性</th><th>幂等性</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>是</td><td>是</td><td>获取资源</td></tr><tr><td><strong>POST</strong></td><td>否</td><td>否</td><td>创建资源</td></tr><tr><td><strong>PUT</strong></td><td>否</td><td>是</td><td>更新或替换资源</td></tr><tr><td><strong>DELETE</strong></td><td>否</td><td>是</td><td>删除资源</td></tr></tbody></table><hr><h3 id="五、HTTP-的会话管理：Cookie"><a href="#五、HTTP-的会话管理：Cookie" class="headerlink" title="五、HTTP 的会话管理：Cookie"></a>五、HTTP 的会话管理：Cookie</h3><p>HTTP 本身是无状态的，但为了跟踪用户，引入了 Cookie。</p><ol><li><strong>创建</strong>：服务器通过响应头 <code>Set-Cookie</code> 向客户端发送一个 Cookie。</li><li><strong>存储</strong>：浏览器接收到 <code>Set-Cookie</code> 后，会将其存储在本地。</li><li><strong>携带</strong>：之后，每次对同一域名发起请求时，浏览器都会自动在请求头 <code>Cookie</code> 中带上这个 Cookie。</li></ol><p>通过在 Cookie 中存储一个 SessionID，服务器就可以在后续请求中找到对应的会话数据，从而实现状态管理。</p><hr><h3 id="六、HTTP-1-1-与-HTTP-2-的区别"><a href="#六、HTTP-1-1-与-HTTP-2-的区别" class="headerlink" title="六、HTTP&#x2F;1.1 与 HTTP&#x2F;2 的区别"></a>六、HTTP&#x2F;1.1 与 HTTP&#x2F;2 的区别</h3><ul><li><strong>多路复用（Multiplexing）</strong>：HTTP&#x2F;2 允许在<strong>一个 TCP 连接</strong>上同时发送多个请求和响应，解决了 HTTP&#x2F;1.1 队头阻塞的问题，显著提高了性能。</li><li><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;2 使用 HPACK 算法压缩请求和响应头，减少了数据传输量。</li><li><strong>服务器推送（Server Push）</strong>：服务器可以在客户端请求一个资源时，主动推送其他它认为客户端可能需要的资源，减少了客户端的请求次数。</li><li><strong>二进制分帧（Binary Framing）</strong>：HTTP&#x2F;2 将所有传输信息分割成更小的消息和帧，并采用二进制编码，使得解析更高效。</li></ul><p>好的，我们来详细补充 <strong>HTTP&#x2F;1.0</strong> 的核心概念，并对整个 HTTP 协议族进行全面的对比和深入解析。</p><hr><h3 id="七、HTTP-协议族演变：从-1-0-到-2-0"><a href="#七、HTTP-协议族演变：从-1-0-到-2-0" class="headerlink" title="七、HTTP 协议族演变：从 1.0 到 2.0"></a>七、HTTP 协议族演变：从 1.0 到 2.0</h3><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h4><p>HTTP&#x2F;1.0 是 HTTP 协议的早期版本，它的设计相对简单，主要用于满足基本的网页浏览需求。</p><ul><li><strong>核心特点：</strong><ul><li><strong>非持久连接（Non-persistent Connection）</strong>：这是 HTTP&#x2F;1.0 最显著的特点。每进行一次 HTTP 请求-响应，客户端和服务器之间就会建立一个新的 <strong>TCP 连接</strong>，并在请求完成后立即断开。<ul><li><strong>缺点</strong>：每次请求都需要经过 TCP 三次握手和四次挥手的过程，这带来了巨大的性能开销。如果一个网页包含多个图片、CSS 或 JavaScript 文件，浏览器需要为每个文件单独建立和断开连接，导致页面加载速度慢。</li></ul></li><li><strong>无主机头（No Host Header）</strong>：请求头中没有 <code>Host</code> 字段。这意味着一个 IP 地址只能对应一个域名。如果服务器上有多个网站，就无法通过 IP 地址来区分它们，这在虚拟主机时代是个大问题。</li><li><strong>不支持管线化（Pipelining）</strong>：客户端发送一个请求后，必须等待服务器的响应，才能发送下一个请求。</li></ul></li></ul><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h4><p>HTTP&#x2F;1.1 协议是对 1.0 的重大改进，解决了其大部分性能瓶颈。</p><ul><li><strong>核心特点：</strong><ul><li><strong>持久连接（Persistent Connection）</strong>：默认情况下，HTTP&#x2F;1.1 会在一次请求-响应之后<strong>保持 TCP 连接不断开</strong>。客户端可以继续在这个连接上发送后续请求。<ul><li><strong>优点</strong>：显著减少了 TCP 连接的建立和断开开销，提高了页面加载速度。这个特性也称为“Keep-Alive”。</li></ul></li><li><strong>支持主机头（Host Header）</strong>：请求头中引入了 <code>Host</code> 字段，允许在同一个 IP 地址上部署多个虚拟主机（域名）。</li><li><strong>支持管线化（Pipelining）</strong>：客户端可以在收到上一个响应之前，连续发送多个请求。<ul><li><strong>缺点</strong>：虽然提高了效率，但存在**队头阻塞（Head-of-Line Blocking）**问题。如果第一个请求处理时间很长，后面的请求即使已经处理完成，也必须等待它的响应，导致整个连接的效率降低。</li></ul></li><li><strong>引入缓存机制</strong>：通过 <code>Cache-Control</code>, <code>ETag</code>, <code>If-None-Match</code> 等请求头，HTTP&#x2F;1.1 提供了更完善的缓存机制，减少了不必要的请求。</li></ul></li></ul><h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h4><p>HTTP&#x2F;2.0 是为了解决 HTTP&#x2F;1.1 在移动互联网和高并发场景下的性能问题而设计的。它不是对 HTTP&#x2F;1.1 的简单升级，而是对协议底层进行了重构。</p><ul><li><strong>核心特点：</strong><ul><li><strong>多路复用（Multiplexing）</strong>：这是 HTTP&#x2F;2 的核心。它允许在<strong>一个 TCP 连接</strong>上同时处理多个 HTTP 请求和响应。<ul><li><strong>如何实现？</strong>：HTTP&#x2F;2 将所有数据流（Stream）分割成更小的二进制帧（Frame），每个帧都带有唯一的标识符。这样，客户端和服务器可以在同一个连接上交错发送和接收帧，然后根据标识符重新组装，从而彻底解决了 HTTP&#x2F;1.1 的队头阻塞问题。</li></ul></li><li><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;2 使用 HPACK 算法来压缩请求和响应头，尤其是对于重复发送的字段，大大减少了数据传输量。</li><li><strong>服务器推送（Server Push）</strong>：服务器可以在客户端请求一个资源（如 HTML 页面）时，主动推送其他它认为客户端可能需要的资源（如 CSS 和 JS 文件），而无需客户端显式请求，进一步提高了加载速度。</li><li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议，而不是文本协议，解析更高效、更不容易出错。</li></ul></li></ul><hr><h4 id="HTTP-协议版本对比总结"><a href="#HTTP-协议版本对比总结" class="headerlink" title="HTTP 协议版本对比总结"></a>HTTP 协议版本对比总结</h4><p>理解 HTTP 协议的演变历程，能让你更深刻地体会到 Web 性能优化的方向，以及现代 Web 框架如何利用这些底层协议特性来提供更高效的服务。</p><table><thead><tr><th>特性</th><th>HTTP&#x2F;1.0</th><th>HTTP&#x2F;1.1</th><th>HTTP&#x2F;2.0</th></tr></thead><tbody><tr><td><strong>TCP 连接</strong></td><td>非持久连接</td><td>默认持久连接</td><td>单个 TCP 连接多路复用</td></tr><tr><td><strong>性能瓶颈</strong></td><td>多次握手挥手开销</td><td>队头阻塞</td><td>无</td></tr><tr><td><strong>主机头</strong></td><td>不支持</td><td>支持 (<code>Host</code> Header)</td><td>支持</td></tr><tr><td><strong>并发请求</strong></td><td>串行（一个请求一个连接）</td><td>串行（一个连接一个请求）</td><td>并行（一个连接多个请求）</td></tr><tr><td><strong>数据格式</strong></td><td>文本协议</td><td>文本协议</td><td>二进制协议</td></tr><tr><td><strong>头部</strong></td><td>无压缩</td><td>无压缩</td><td>HPACK 算法压缩</td></tr><tr><td><strong>服务器推送</strong></td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table><hr><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="Servlet-概述：Java-Web-的核心基石"><a href="#Servlet-概述：Java-Web-的核心基石" class="headerlink" title="Servlet 概述：Java Web 的核心基石"></a>Servlet 概述：Java Web 的核心基石</h3><p><strong>Servlet</strong> 是 Java EE 规范中的一个核心组件，它是一个运行在服务器端的 Java 程序，用于处理 HTTP 请求和生成动态响应。你可以把它看作是所有 Java Web 框架（如 Spring MVC）的底层引擎。</p><p><strong>它的核心作用</strong>是作为客户端（浏览器）和 Java 应用程序之间的“桥梁”。Servlet 容器（如 Tomcat、Jetty）负责监听网络请求，然后将请求分发给相应的 Servlet 进行处理。</p><h3 id="Servlet-的生命周期：由容器严格管理"><a href="#Servlet-的生命周期：由容器严格管理" class="headerlink" title="Servlet 的生命周期：由容器严格管理"></a>Servlet 的生命周期：由容器严格管理</h3><p>一个 Servlet 的生命周期由 Servlet 容器严格管理，通常分为三个阶段：</p><ol><li><strong>初始化（Initialization）</strong><ul><li><strong>时机</strong>：当 Servlet 容器第一次加载 Servlet 类并创建其实例后，立即调用 <code>init()</code> 方法。</li><li><strong>特性</strong>：这个方法<strong>只执行一次</strong>，通常用于加载配置文件、建立数据库连接池等一次性、耗时的任务。如果 <code>init()</code> 方法抛出异常，Servlet 将无法提供服务。</li></ul></li><li><strong>服务（Servicing）</strong><ul><li><strong>时机</strong>：每当一个客户端请求到达时，容器会为该请求创建一个新的线程，并调用 <code>service()</code> 方法。</li><li><strong>特性</strong>：<code>service()</code> 方法是 Servlet 的核心，它会根据请求类型（如 GET、POST）自动调用相应的 <code>doGet()</code>、<code>doPost()</code> 等方法。由于此方法会被多个线程并发调用，因此访问共享资源时必须注意<strong>线程安全</strong>。</li></ul></li><li><strong>销毁（Destruction）</strong><ul><li><strong>时机</strong>：当 Servlet 容器关闭或决定卸载某个 Servlet 时，会调用其 <code>destroy()</code> 方法。</li><li><strong>特性</strong>：这个方法也<strong>只执行一次</strong>，用于释放资源，如关闭数据库连接或文件流。</li></ul></li></ol><h3 id="Servlet-的配置和部署：两种主要方式"><a href="#Servlet-的配置和部署：两种主要方式" class="headerlink" title="Servlet 的配置和部署：两种主要方式"></a>Servlet 的配置和部署：两种主要方式</h3><p>为了让容器知道如何加载和映射 Servlet，你需要进行配置。</p><ol><li><strong>web.xml 配置（传统方式）</strong><ul><li>在 <code>web.xml</code> 文件中，使用 <code>&lt;servlet&gt;</code> 标签定义 Servlet 类，并使用 <code>&lt;servlet-mapping&gt;</code> 标签将它映射到一个 URL 路径。</li><li><strong>优点</strong>：配置集中，易于管理。</li><li><strong>缺点</strong>：如果 Servlet 很多，<code>web.xml</code> 文件会变得非常庞大。</li></ul></li><li><strong>注解配置（现代方式）</strong><ul><li>从 Servlet 3.0 规范开始，你可以使用 <code>@WebServlet</code> 注解来简化配置。只需在你的 Servlet 类上添加 <code>@WebServlet(&quot;/path&quot;)</code> 注解，容器就会自动识别和配置它。</li><li><strong>优点</strong>：配置简单，代码和配置在一起，提高了可读性。</li></ul></li></ol><h3 id="Servlet-的核心方法：处理请求和响应"><a href="#Servlet-的核心方法：处理请求和响应" class="headerlink" title="Servlet 的核心方法：处理请求和响应"></a>Servlet 的核心方法：处理请求和响应</h3><p>所有 Servlet 都应该实现 <code>javax.servlet.Servlet</code> 接口。通常，我们更常继承 <code>javax.servlet.http.HttpServlet</code>，因为它提供了更方便的 HTTP 请求处理方法。</p><ul><li><code>service(HttpServletRequest req, HttpServletResponse res)</code>：这是核心服务方法，由容器调用。它会根据请求的 HTTP 方法（GET、POST、PUT 等）来调用相应的 <code>doGet()</code>、<code>doPost()</code> 等方法。</li><li><code>doGet(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 GET 请求。</li><li><code>doPost(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 POST 请求。</li><li><code>doPut(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 PUT 请求。</li><li><code>doDelete(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 DELETE 请求。</li></ul><p>在这些方法中，你可以通过 <code>req</code> (请求) 和 <code>res</code> (响应) 对象来与客户端进行交互。</p><h3 id="Servlet-的请求和响应处理：与客户端交互"><a href="#Servlet-的请求和响应处理：与客户端交互" class="headerlink" title="Servlet 的请求和响应处理：与客户端交互"></a>Servlet 的请求和响应处理：与客户端交互</h3><ul><li><strong>获取请求参数</strong><ul><li><code>req.getParameter(&quot;paramName&quot;)</code>：获取单个参数值。</li><li><code>req.getParameterValues(&quot;paramName&quot;)</code>：获取具有相同名称的多个参数值（如复选框）。</li></ul></li><li><strong>设置响应头</strong><ul><li><code>res.setContentType(&quot;text/html;charset=UTF-8&quot;)</code>：设置响应的内容类型和字符编码。</li><li><code>res.setHeader(&quot;HeaderName&quot;, &quot;HeaderValue&quot;)</code>：设置自定义响应头。</li></ul></li><li><strong>写入响应内容</strong><ul><li><code>res.getWriter()</code>：获取一个 <code>PrintWriter</code>，用于向客户端发送文本响应。</li><li><code>res.getOutputStream()</code>：获取一个 <code>ServletOutputStream</code>，用于向客户端发送二进制响应（如图片、文件）。</li></ul></li></ul><h3 id="Servlet-的核心组件与作用域"><a href="#Servlet-的核心组件与作用域" class="headerlink" title="Servlet 的核心组件与作用域"></a>Servlet 的核心组件与作用域</h3><p>理解 Servlet 规范中的这些组件，能帮助你更合理地管理数据和资源。</p><ol><li><strong>ServletContext (应用上下文)</strong><ul><li><strong>作用</strong>：代表整个 Web 应用，它的生命周期与应用相同。</li><li><strong>作用域</strong>：数据在所有 Servlet、JSP 和 Filter 之间<strong>共享</strong>。</li><li><strong>用途</strong>：存储全局配置和共享数据。</li></ul></li><li><strong>ServletConfig (配置对象)</strong><ul><li><strong>作用</strong>：代表一个 Servlet 独有的配置。</li><li><strong>作用域</strong>：仅在它所关联的 Servlet 内部有效。</li><li><strong>用途</strong>：获取特定 Servlet 的初始化参数。</li></ul></li><li><strong>四大作用域</strong><ul><li><strong>PageContext (页面作用域)</strong>：仅在 JSP 页面内有效。</li><li><strong>HttpServletRequest (请求作用域)</strong>：在一次完整的请求-响应周期内有效，即使请求被转发，数据依然可见。</li><li><strong>HttpSession (会话作用域)</strong>：在同一个浏览器会话中有效，用于存储用户特定数据。</li><li><strong>ServletContext (应用作用域)</strong>：在整个 Web 应用中都有效，用于存储全局数据。</li></ul></li></ol><p>好的，我们来详细、深入地聊聊 Web 开发中至关重要的两个概念：Cookie 和 Session。它们是解决 HTTP 无状态问题的核心方案，但工作机制和应用场景却大不相同。</p><hr><h3 id="Cookie：客户端的“小纸条”"><a href="#Cookie：客户端的“小纸条”" class="headerlink" title="Cookie：客户端的“小纸条”"></a>Cookie：客户端的“小纸条”</h3><p><strong>Cookie</strong> 是服务器发送给浏览器并存储在客户端的一小段文本信息。浏览器在下次访问同一服务器时，会自动将该 Cookie 包含在请求中发送回去。</p><h4 id="核心工作机制"><a href="#核心工作机制" class="headerlink" title="核心工作机制"></a>核心工作机制</h4><ol><li><p>服务器创建 Cookie：</p><p>当用户首次访问网站时，服务器在响应头（Response Header）中添加一个 Set-Cookie 字段。</p><p>比如：Set-Cookie: JSESSIONID&#x3D;abcde12345; Path&#x3D;&#x2F;; HttpOnly</p></li><li><p>浏览器保存 Cookie：</p><p>浏览器接收到响应后，会解析 Set-Cookie 头，并将该信息以键值对的形式存储在本地。</p></li><li><p>浏览器发送 Cookie：</p><p>在后续的请求中，只要请求的域名和路径与 Cookie 的设置相符，浏览器就会自动在请求头（Request Header）中添加 Cookie 字段，将存储的 Cookie 信息发送给服务器。</p><p>比如：Cookie: JSESSIONID&#x3D;abcde12345</p></li></ol><h4 id="Cookie-的优缺点"><a href="#Cookie-的优缺点" class="headerlink" title="Cookie 的优缺点"></a>Cookie 的优缺点</h4><ul><li><strong>优点</strong>：<ul><li><strong>减轻服务器压力</strong>：数据存储在客户端，服务器不需要为每个用户维护状态，适用于大规模访问。</li><li><strong>可扩展性强</strong>：无状态，天然适合分布式架构。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>安全性差</strong>：数据以明文形式存储，容易被窃取和篡改。</li><li><strong>容量限制</strong>：单个 Cookie 的大小通常不超过 4KB，且一个域名下的 Cookie 总数也有限制。</li><li><strong>用户可禁用</strong>：如果用户禁用了浏览器 Cookie 功能，相关功能将无法使用。</li></ul></li></ul><hr><h3 id="Session：服务器的“个人档案”"><a href="#Session：服务器的“个人档案”" class="headerlink" title="Session：服务器的“个人档案”"></a>Session：服务器的“个人档案”</h3><p><strong>Session</strong> 是服务器为每个用户创建的一个对象，用于存储特定用户的会话数据。它将用户的状态信息保存在服务器端，并通过一个唯一的 <strong>Session ID</strong> 来识别不同的用户。</p><h4 id="核心工作机制-1"><a href="#核心工作机制-1" class="headerlink" title="核心工作机制"></a>核心工作机制</h4><ol><li><p>服务器创建 Session：</p><p>当用户首次访问 Web 应用时，服务器会创建一个 HttpSession 对象，并为其分配一个唯一的 Session ID。</p></li><li><p>传递 Session ID：</p><p>服务器将这个 Session ID 以 Cookie 的形式发送给浏览器（这个 Cookie 通常叫 JSESSIONID）。</p><ul><li>如果浏览器禁用了 Cookie，服务器可以通过 <strong>URL 重写</strong>的方式，将 Session ID 附加到每个 URL 的末尾，例如：<code>.../index.jsp;jsessionid=abcde12345</code>。</li></ul></li><li><p>服务器维护 Session：</p><p>Session ID 传递到客户端后，服务器会在内存中或持久化存储中保存这个 HttpSession 对象及其数据。</p></li><li><p>识别用户：</p><p>后续的请求中，浏览器都会带着包含 Session ID 的 Cookie。服务器通过这个 ID 就能从内存中找到对应的 HttpSession 对象，从而获取该用户的状态信息。</p></li></ol><h4 id="Session-的优缺点"><a href="#Session-的优缺点" class="headerlink" title="Session 的优缺点"></a>Session 的优缺点</h4><ul><li><strong>优点</strong>：<ul><li><strong>安全性高</strong>：核心数据存储在服务器，客户端只传递一个无法猜解的 ID。</li><li><strong>容量大</strong>：存储在服务器，理论上没有大小限制。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>占用服务器资源</strong>：每个活跃的 Session 都会占用服务器内存，在高并发场景下可能成为瓶颈。</li><li><strong>分布式挑战</strong>：在多台服务器组成的集群环境中，需要额外的机制（如 Session 共享或粘性会话）来确保用户的请求总是被转发到同一个 Session 所在的服务器，或者所有服务器都能访问到 Session 数据。</li></ul></li></ul><hr><h3 id="Cookie-与-Session-的对比总结"><a href="#Cookie-与-Session-的对比总结" class="headerlink" title="Cookie 与 Session 的对比总结"></a>Cookie 与 Session 的对比总结</h3><table><thead><tr><th>特性</th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td><strong>数据存储位置</strong></td><td>客户端（浏览器）</td><td>服务器端</td></tr><tr><td><strong>安全性</strong></td><td>较低，易被篡改</td><td>较高，数据安全</td></tr><tr><td><strong>数据容量</strong></td><td>较小（~4KB）</td><td>较大，无明显限制</td></tr><tr><td><strong>性能</strong></td><td>轻量，不占用服务器资源</td><td>占用服务器内存，可能影响性能</td></tr><tr><td><strong>可扩展性</strong></td><td>天然无状态，易于扩展</td><td>分布式环境下需要额外配置</td></tr><tr><td><strong>主要用途</strong></td><td>购物车、用户偏好、轻量级状态</td><td>登录状态、权限验证、敏感数据</td></tr></tbody></table><p>好的，我已将 GET 和 POST 请求的所有核心区别整理成一个简洁明了的表格，并补充了更多细节，使其更全面。</p><h3 id="GET-和-POST-请求的全面对比"><a href="#GET-和-POST-请求的全面对比" class="headerlink" title="GET 和 POST 请求的全面对比"></a>GET 和 POST 请求的全面对比</h3><table><thead><tr><th>特性</th><th>GET 请求</th><th>POST 请求</th><th>备注</th></tr></thead><tbody><tr><td><strong>基本作用</strong></td><td>从服务器<strong>获取</strong>资源</td><td>向服务器<strong>提交</strong>数据，通常用于<strong>创建</strong>资源。</td><td>语义不同是所有区别的根本。</td></tr><tr><td><strong>传参方式</strong></td><td>参数附加在 URL 中</td><td>参数放在请求体（Request Body）中</td><td>GET 参数可见，POST 参数隐藏。</td></tr><tr><td><strong>安全性</strong></td><td><strong>不安全</strong>，URL 暴露</td><td><strong>相对安全</strong>，参数隐藏在请求体中</td><td>这里的“安全”指数据不被暴露。</td></tr><tr><td><strong>幂等性</strong></td><td><strong>是</strong>（多次执行结果相同）</td><td><strong>否</strong>（多次执行可能产生新资源）</td><td>幂等性是 RESTful 设计的关键原则。</td></tr><tr><td><strong>浏览器行为</strong></td><td>回退无害，可被记录在历史、收藏为书签。</td><td>回退时通常会提示重新提交，不记录在历史、不可收藏。</td><td>防止意外提交导致数据重复。</td></tr><tr><td><strong>缓存</strong></td><td><strong>可以被缓存</strong></td><td><strong>不会被缓存</strong></td><td>缓存能提高性能，但仅限于只读操作。</td></tr><tr><td><strong>传输数据量</strong></td><td>有长度限制（URL长度限制）</td><td>无长度限制（取决于服务器配置）</td><td>GET 不适合传输大量数据。</td></tr><tr><td><strong>数据编码</strong></td><td>只支持 URL 编码</td><td>支持多种编码（如<code>application/json</code>）</td><td>POST 灵活性高，适合各种数据类型。</td></tr><tr><td><strong>发送文件</strong></td><td>不支持</td><td>支持 (<code>multipart/form-data</code>)</td><td>文件必须通过请求体传输。</td></tr><tr><td><strong>HTTP 报文</strong></td><td>无请求体</td><td>有请求体</td><td>GET 请求报文更小，更轻量。</td></tr><tr><td><strong>TCP&#x2F;IP 协议</strong></td><td>一次性发送所有数据包</td><td>浏览器通常会先发送请求头，服务器响应 100-continue 后再发送请求体</td><td>POST 的分步发送机制可以避免发送不必要的数据。</td></tr></tbody></table><p>好的，我们将以 Servlet 的详细剖析方式，全面、深入地介绍 WebSocket。我们将从它的概念、生命周期、核心 API，到它与 HTTP 的区别以及在现代 Web 中的应用，进行系统性的梳理。</p><hr><h3 id="WebSocket-概述：Web-通信的革命"><a href="#WebSocket-概述：Web-通信的革命" class="headerlink" title="WebSocket 概述：Web 通信的革命"></a>WebSocket 概述：Web 通信的革命</h3><p><strong>WebSocket</strong> 协议是 HTML5 开始提供的一种在单个 TCP 连接上进行<strong>全双工通信</strong>的协议。与传统的 HTTP 协议不同，它打破了请求-响应的单向模式，使得客户端和服务器可以<strong>实时地双向自由传输数据</strong>。</p><p><strong>它的核心作用</strong>是解决 Web 应用中<strong>实时通信</strong>的需求，例如：聊天应用、在线游戏、股票行情、实时协作工具等。它极大地减少了网络开销，提高了通信效率。</p><h3 id="WebSocket-的核心工作原理"><a href="#WebSocket-的核心工作原理" class="headerlink" title="WebSocket 的核心工作原理"></a>WebSocket 的核心工作原理</h3><p>要理解 WebSocket，必须首先理解它与 HTTP 的关系。</p><ol><li><strong>基于 HTTP 的握手（Handshake）</strong>：<ul><li>WebSocket 的连接建立过程是基于 HTTP 协议的。</li><li>客户端发送一个特殊的 HTTP 请求，其中包含 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code> 请求头，向服务器请求将 HTTP 协议升级到 WebSocket 协议。</li><li>这是一个**“握手”**过程。</li></ul></li><li><strong>协议升级与持久连接</strong>：<ul><li>如果服务器支持 WebSocket，它会返回一个特殊的 HTTP 响应（状态码 <code>101 Switching Protocols</code>）。</li><li>握手成功后，客户端和服务器之间的 TCP 连接将<strong>保持打开状态</strong>。</li><li>这时，协议就从 HTTP 升级到了 WebSocket，双方可以在这个<strong>持久的 TCP 连接</strong>上自由地双向发送数据，而无需再进行 HTTP 头部开销。</li></ul></li><li><strong>数据帧传输</strong>：<ul><li>WebSocket 协议定义了**数据帧（Data Frames）**的概念。它将数据分割成更小、更轻量级的帧，而不是像 HTTP 那样发送整个报文。</li><li>这样，即使传输少量数据，也不会有很大的协议开销，非常适合实时通信。</li></ul></li></ol><h3 id="WebSocket-的生命周期：事件驱动模型"><a href="#WebSocket-的生命周期：事件驱动模型" class="headerlink" title="WebSocket 的生命周期：事件驱动模型"></a>WebSocket 的生命周期：事件驱动模型</h3><p>WebSocket 的生命周期由客户端和服务器共同维护，由一系列事件驱动：</p><h4 id="1-连接建立（Connection-Establishment）"><a href="#1-连接建立（Connection-Establishment）" class="headerlink" title="1. 连接建立（Connection Establishment）"></a>1. 连接建立（Connection Establishment）</h4><ul><li><strong>客户端</strong>：通过 <code>new WebSocket(url)</code> 建立连接。</li><li><strong>服务器</strong>：当客户端发送握手请求后，服务器处理并接受连接，此时触发 <code>onopen</code> 事件。</li></ul><h4 id="2-数据传输（Data-Transmission）"><a href="#2-数据传输（Data-Transmission）" class="headerlink" title="2. 数据传输（Data Transmission）"></a>2. 数据传输（Data Transmission）</h4><ul><li><strong>发送</strong>：客户端和服务器都可以通过各自的 <code>send()</code> 方法向对方发送数据。</li><li><strong>接收</strong>：当一方接收到数据时，会触发 <code>onmessage</code> 事件。</li></ul><h4 id="3-连接关闭（Connection-Close）"><a href="#3-连接关闭（Connection-Close）" class="headerlink" title="3. 连接关闭（Connection Close）"></a>3. 连接关闭（Connection Close）</h4><ul><li><strong>主动关闭</strong>：客户端或服务器可以调用 <code>close()</code> 方法主动关闭连接。</li><li><strong>异常关闭</strong>：连接可能因网络故障、心跳超时等原因意外关闭。</li><li><strong>事件</strong>：无论是主动还是被动，连接关闭时都会触发 <code>onclose</code> 事件。</li></ul><h3 id="WebSocket-的核心-API（以-JavaScript-为例）"><a href="#WebSocket-的核心-API（以-JavaScript-为例）" class="headerlink" title="WebSocket 的核心 API（以 JavaScript 为例）"></a>WebSocket 的核心 API（以 JavaScript 为例）</h3><p>WebSocket 的 API 设计非常简洁，主要基于事件监听和方法调用。</p><ul><li><strong>new WebSocket(url)</strong>：创建一个 WebSocket 客户端实例。</li><li><strong>websocket.onopen</strong>：连接成功建立时触发。</li><li><strong>websocket.onmessage &#x3D; function(event)</strong>：接收到服务器数据时触发，数据在 <code>event.data</code> 中。</li><li><strong>websocket.onerror</strong>：连接发生错误时触发。</li><li><strong>websocket.onclose</strong>：连接关闭时触发。</li><li><strong>websocket.send(data)</strong>：向服务器发送数据。</li><li><strong>websocket.close()</strong>：关闭连接。</li></ul><h3 id="WebSocket-与-HTTP-的本质区别"><a href="#WebSocket-与-HTTP-的本质区别" class="headerlink" title="WebSocket 与 HTTP 的本质区别"></a>WebSocket 与 HTTP 的本质区别</h3><table><thead><tr><th>特性</th><th>HTTP</th><th>WebSocket</th><th>备注</th></tr></thead><tbody><tr><td><strong>通信模式</strong></td><td><strong>单向</strong>（请求-响应）</td><td><strong>双向</strong>（全双工）</td><td>HTTP 客户端必须先发请求，服务器才能响应。</td></tr><tr><td><strong>连接状态</strong></td><td><strong>无状态</strong>，短连接</td><td><strong>有状态</strong>，长连接</td><td>HTTP 每次请求都需要重新建立连接。</td></tr><tr><td><strong>协议开销</strong></td><td><strong>大</strong>（每次请求都携带头部）</td><td><strong>小</strong>（握手后只传输数据帧）</td><td>HTTP 适合传输大文件，WebSocket 适合小数据频繁传输。</td></tr><tr><td><strong>服务器主动性</strong></td><td><strong>被动</strong>（无法主动推送）</td><td><strong>主动</strong>（可随时推送数据）</td><td>WebSocket 解决了 HTTP 的“服务器推”难题。</td></tr><tr><td><strong>应用场景</strong></td><td>网页浏览、API 调用、文件下载</td><td>聊天、游戏、实时数据更新</td><td></td></tr></tbody></table><h3 id="WebSocket-在现代-Java-Web-中的应用"><a href="#WebSocket-在现代-Java-Web-中的应用" class="headerlink" title="WebSocket 在现代 Java Web 中的应用"></a>WebSocket 在现代 Java Web 中的应用</h3><p>在 Java 后端，WebSocket 通常由专门的框架或容器来实现，如：</p><ul><li><strong>JavaEE 7+ 的 WebSocket API</strong>：提供了 <code>javax.websocket</code> 包，可以直接在 Servlet 容器中开发 WebSocket 应用。</li><li><strong>Spring Framework</strong>：提供了强大的 WebSocket 支持，集成了 STOMP（Simple Text Oriented Messaging Protocol）协议，简化了消息路由和管理。</li></ul><p>在这些框架中，你通常会定义一个 WebSocket 端点（Endpoint），类似于 Servlet，它负责处理连接的建立、消息的接收和发送、以及连接的关闭。</p><p>总而言之，WebSocket 是 HTTP 协议在实时通信领域的有力补充。它通过一次性的握手建立一个持久的双向通道，极大地提高了 Web 应用的交互性和效率，是现代 Web 架构中不可或缺的一部分。</p><p>好的，为了更好地理解 WebSocket 的工作原理，我将提供几个具体的应用场景和相应的代码示例。这些示例将涵盖客户端（JavaScript）和服务器端（Java&#x2F;Spring Boot）的代码，以便你能够完整地看到双向通信是如何实现的。</p><hr><h3 id="示例一：实时聊天应用"><a href="#示例一：实时聊天应用" class="headerlink" title="示例一：实时聊天应用"></a>示例一：实时聊天应用</h3><p>这是 WebSocket 最经典的用例。</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a><strong>应用场景</strong>：</h4><p>多个用户连接到聊天室，当一个用户发送消息时，服务器将该消息实时广播给所有其他在线用户。</p><h4 id="核心逻辑："><a href="#核心逻辑：" class="headerlink" title="核心逻辑："></a><strong>核心逻辑</strong>：</h4><ul><li><strong>客户端</strong>：当用户在输入框中按下回车，JavaScript 将消息通过 WebSocket 连接发送给服务器。</li><li><strong>服务器</strong>：接收到消息后，遍历所有已连接的 WebSocket 会话，将消息逐一发送给每个会话。</li></ul><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a><strong>代码示例</strong>：</h4><p><strong>1. 客户端 (JavaScript)</strong></p><p>JavaScript</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接 WebSocket 服务器</span></span><br><span class="line"><span class="type">const</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/chat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接成功事件</span></span><br><span class="line">socket.onopen = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket连接已建立&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听接收消息事件</span></span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="variable">message</span> <span class="operator">=</span> event.data;</span><br><span class="line">  <span class="type">const</span> <span class="variable">chatBox</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;chat-box&#x27;</span>);</span><br><span class="line">  chatBox.innerHTML += `&lt;p&gt;$&#123;message&#125;&lt;/p&gt;`; <span class="comment">// 将消息添加到聊天框</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接关闭事件</span></span><br><span class="line">socket.onclose = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket连接已关闭&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听错误事件</span></span><br><span class="line">socket.onerror = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket发生错误:&quot;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息函数</span></span><br><span class="line">function <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="variable">input</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;message-input&#x27;</span>);</span><br><span class="line">  <span class="type">const</span> <span class="variable">message</span> <span class="operator">=</span> input.value;</span><br><span class="line">  <span class="keyword">if</span> (message) &#123;</span><br><span class="line">    socket.send(message); <span class="comment">// 通过 WebSocket 发送消息</span></span><br><span class="line">    input.value = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 清空输入框</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定回车事件</span></span><br><span class="line">document.getElementById(<span class="string">&#x27;message-input&#x27;</span>).addEventListener(<span class="string">&#x27;keypress&#x27;</span>, function(e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.key === <span class="string">&#x27;Enter&#x27;</span>) &#123;</span><br><span class="line">    sendMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>2. 服务器端 (Java&#x2F;Spring Boot)</strong></p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatWebSocketEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储所有连接的客户端会话</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端连接成功时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.add(session); <span class="comment">// 添加新会话</span></span><br><span class="line">        System.out.println(<span class="string">&quot;新连接：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端发送消息时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息：&quot;</span> + message + <span class="string">&quot; 来自：&quot;</span> + session.getId());</span><br><span class="line">        <span class="comment">// 遍历所有会话，广播消息</span></span><br><span class="line">        sessions.forEach(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当连接关闭时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.remove(session); <span class="comment">// 移除会话</span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接关闭：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当发生错误时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接发生错误：&quot;</span> + session.getId());</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="示例二：实时股票行情或数据看板"><a href="#示例二：实时股票行情或数据看板" class="headerlink" title="示例二：实时股票行情或数据看板"></a>示例二：实时股票行情或数据看板</h3><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a><strong>应用场景</strong>：</h4><p>客户端连接到服务器，服务器定期或在数据更新时，向所有连接的客户端推送最新的股票价格或监控数据。</p><h4 id="核心逻辑：-1"><a href="#核心逻辑：-1" class="headerlink" title="核心逻辑："></a><strong>核心逻辑</strong>：</h4><ul><li><strong>客户端</strong>：只监听 <code>onmessage</code> 事件，被动接收服务器推送的数据。</li><li><strong>服务器</strong>：在后台启动一个定时任务或数据监听器。当数据变化时，主动通过 WebSocket 连接将新数据发送给客户端。</li></ul><h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a><strong>代码示例</strong>：</h4><p><strong>1. 客户端 (JavaScript)</strong></p><p>JavaScript</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/stock&#x27;</span>);</span><br><span class="line"></span><br><span class="line">socket.onopen = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;股票行情连接已建立&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">  <span class="comment">// 假设服务器发送的是JSON格式的股票数据</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">stockData</span> <span class="operator">=</span> JSON.parse(event.data);</span><br><span class="line">  <span class="type">const</span> <span class="variable">stockPriceElement</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;stock-price&#x27;</span>);</span><br><span class="line">  stockPriceElement.innerText = `当前价格: $&#123;stockData.price&#125;`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无需 sendMessage 函数，因为是单向被动接收</span></span><br></pre></td></tr></table></figure><p><strong>2. 服务器端 (Java&#x2F;Spring Boot)</strong></p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/stock&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockWebSocketEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.add(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;新股票行情订阅者：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是一个定时任务，每隔5秒向所有客户端推送数据</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushStockData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟获取最新股票价格</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> Math.random() * <span class="number">100</span> + <span class="number">100</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;price\&quot;: &quot;</span> + String.format(<span class="string">&quot;%.2f&quot;</span>, price) + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有会话，推送数据</span></span><br><span class="line">        sessions.forEach(session -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                    session.getBasicRemote().sendText(json);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个例子清楚地展示了 WebSocket 如何通过<strong>持久连接</strong>和<strong>双向通信</strong>来解决实时应用中的核心痛点。</p><p>好的，让我们详细、清晰地解释<strong>静态资源</strong>和<strong>动态资源</strong>的概念，以及为什么某些服务器或工具只能处理静态资源。</p><hr><h3 id="一、静态资源-Static-Resources"><a href="#一、静态资源-Static-Resources" class="headerlink" title="一、静态资源 (Static Resources)"></a>一、静态资源 (Static Resources)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>静态资源</strong>是指在服务器端<strong>不需要经过任何处理或计算</strong>，就能直接返回给客户端的资源。它们的<strong>内容是固定不变</strong>的，无论何时、被谁请求，服务器返回的都是同一个文件。</p><h4 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h4><ul><li><strong>HTML 文件</strong> (<code>.html</code>)：纯 HTML 代码，浏览器直接渲染。</li><li><strong>CSS 样式表</strong> (<code>.css</code>)：定义网页样式。</li><li><strong>JavaScript 脚本</strong> (<code>.js</code>)：用于网页交互。</li><li><strong>图片</strong> (<code>.jpg</code>, <code>.png</code>, <code>.gif</code>)：图像文件。</li><li><strong>字体文件</strong> (<code>.woff</code>, <code>.ttf</code>)：网页字体。</li><li><strong>视频</strong> (<code>.mp4</code>, <code>.webm</code>)：视频文件。</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>客户端向服务器请求一个 URL，例如 <code>http://example.com/styles.css</code>。</li><li>服务器接收到请求，直接从<strong>文件系统</strong>中找到名为 <code>styles.css</code> 的文件。</li><li>服务器将 <code>styles.css</code> 的内容原封不动地返回给客户端。</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>高效</strong>：无需服务器计算，直接读取文件，响应速度极快。</li><li><strong>可缓存</strong>：由于内容不变，浏览器、代理服务器都可以对静态资源进行缓存，进一步减少网络传输。</li><li><strong>部署简单</strong>：只需将文件放在服务器的特定目录下即可。</li></ul><h3 id="二、动态资源-Dynamic-Resources"><a href="#二、动态资源-Dynamic-Resources" class="headerlink" title="二、动态资源 (Dynamic Resources)"></a>二、动态资源 (Dynamic Resources)</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>动态资源</strong>是指服务器端<strong>需要经过处理、计算或查询数据库</strong>，才能生成并返回给客户端的资源。它们的内容是<strong>可变</strong>的，不同的请求、不同的时间，返回的内容可能不同。</p><h4 id="常见类型-1"><a href="#常见类型-1" class="headerlink" title="常见类型"></a>常见类型</h4><ul><li><strong>Servlet&#x2F;JSP</strong>：Java 后端通过 Servlet 或 JSP 动态生成 HTML。</li><li><strong>PHP 脚本</strong> (<code>.php</code>)：PHP 后端生成 HTML。</li><li><strong>Python&#x2F;Django 视图</strong>：Python 后端处理请求并返回数据。</li><li><strong>RESTful API</strong>：返回 JSON、XML 等格式的数据。</li></ul><h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li>客户端向服务器请求一个 URL，例如 <code>http://example.com/user/profile?id=123</code>。</li><li>服务器接收到请求，将请求转发给<strong>后端程序</strong>（如 Servlet 容器）。</li><li>后端程序接收请求，根据请求参数 <code>id=123</code> 查询数据库，获取该用户的信息。</li><li>后端程序将数据渲染到 HTML 模板中，或者将数据封装成 JSON 格式。</li><li>后端程序将<strong>动态生成的内容</strong>作为响应返回给服务器。</li><li>服务器将该响应发送给客户端。</li></ol><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>灵活</strong>：可以根据业务逻辑生成个性化内容。</li><li><strong>消耗资源</strong>：需要消耗 CPU、内存、数据库连接等资源进行计算。</li><li><strong>不可直接缓存</strong>：由于内容可变，通常无法像静态资源那样直接缓存。</li></ul><h3 id="三、是什么东西只能解析静态资源？"><a href="#三、是什么东西只能解析静态资源？" class="headerlink" title="三、是什么东西只能解析静态资源？"></a>三、是什么东西只能解析静态资源？</h3><p>这个问题的核心在于**“解析”<strong>这个词。能“解析”静态资源的，通常指的是</strong>Web 服务器**。</p><ul><li><strong>Web 服务器</strong>：一种软件，它的主要职责是处理 HTTP 请求并返回文件。</li></ul><h4 id="1-纯静态-Web-服务器-Static-Web-Server"><a href="#1-纯静态-Web-服务器-Static-Web-Server" class="headerlink" title="1. 纯静态 Web 服务器 (Static Web Server)"></a>1. 纯静态 Web 服务器 (Static Web Server)</h4><p><strong>这类服务器的核心功能就是提供静态文件服务。</strong> 它们只知道如何根据 URL 路径，去文件系统找到对应的文件，然后返回。</p><ul><li><strong>工作原理</strong>：它们没有内置的后端语言解析器（如 Java 虚拟机、PHP 解释器）。当它们收到一个请求时，只会将 URL 映射到文件目录。如果文件存在，就返回；如果不存在，就返回 404 错误。</li><li><strong>代表</strong>：<strong>Nginx</strong>（作为反向代理或静态文件服务器时）、<strong>Apache HTTP Server</strong>（作为静态文件服务器时）。</li></ul><p><strong>为什么它们不能解析动态资源？</strong></p><p>因为它们<strong>不具备</strong>执行后端代码的能力。例如，当 Nginx 收到一个对 <code>.jsp</code> 文件的请求时，它不知道如何运行 Java 代码来生成 HTML。它只会把 <code>.jsp</code> 文件当作一个普通的文本文件返回给浏览器，浏览器也无法正确地解析。</p><h4 id="2-动态-Web-服务器-Dynamic-Web-Server"><a href="#2-动态-Web-服务器-Dynamic-Web-Server" class="headerlink" title="2. 动态 Web 服务器 (Dynamic Web Server)"></a>2. 动态 Web 服务器 (Dynamic Web Server)</h4><p>这类服务器通常被称为 <strong>“应用服务器”</strong>，它们在 Web 服务器的功能上，<strong>内置了后端语言的运行环境</strong>。</p><ul><li><strong>工作原理</strong>：<ul><li>当它们收到静态资源请求时，行为与静态服务器相同：直接返回文件。</li><li>当它们收到动态资源请求时，会将请求转发给内置的<strong>后端程序运行环境</strong>。例如，Tomcat 会将 <code>.jsp</code> 文件交给 JSP 引擎来编译和执行。</li></ul></li><li><strong>代表</strong>：<strong>Apache Tomcat</strong>、<strong>Jetty</strong>。</li></ul><p>因此，在实际生产环境中，我们经常采用<strong>动静分离</strong>的架构：</p><ul><li><strong>静态资源</strong>（<code>index.html</code>、<code>style.css</code> 等）交给 <strong>Nginx</strong> 这样的高效静态服务器处理。</li><li><strong>动态资源</strong>（<code>api/user</code>, <code>.jsp</code> 等）交给 <strong>Tomcat</strong> 这样的应用服务器处理。</li></ul><p>这样做的目的是，让专业的工具做专业的事：Nginx 擅长高并发的静态文件服务，而 Tomcat 则专注于复杂的动态业务逻辑。</p><p>好的，让我们来系统、全面地梳理前端的核心知识，这不仅是前端工程师的必备技能，也是后端开发者理解整个 Web 应用架构的关键。</p><h3 id="一、基础三剑客：构建网页的基石"><a href="#一、基础三剑客：构建网页的基石" class="headerlink" title="一、基础三剑客：构建网页的基石"></a>一、基础三剑客：构建网页的基石</h3><p>这三者是所有前端技术的基础，就像建筑的钢筋、水泥和水电。</p><h4 id="1-HTML-HyperText-Markup-Language"><a href="#1-HTML-HyperText-Markup-Language" class="headerlink" title="1. HTML (HyperText Markup Language)"></a>1. HTML (HyperText Markup Language)</h4><ul><li><strong>是什么</strong>：超文本标记语言，用于<strong>定义网页的结构和内容</strong>。它由一系列标签（tag）组成，这些标签告诉浏览器如何组织页面内容，如段落、标题、图片、链接等。</li><li><strong>核心概念</strong>：<ul><li><strong>标签（Tags）</strong>：如 <code>&lt;p&gt;</code> (段落), <code>&lt;h1&gt;</code> (一级标题), <code>&lt;img&gt;</code> (图片), <code>&lt;a&gt;</code> (超链接)。</li><li><strong>元素（Elements）</strong>：由开始标签、内容和结束标签组成，例如 <code>&lt;p&gt;这是一个段落。&lt;/p&gt;</code>。</li><li><strong>属性（Attributes）</strong>：提供关于元素的额外信息，如 <code>&lt;img src=&quot;image.jpg&quot; alt=&quot;描述&quot;&gt;</code> 中的 <code>src</code> 和 <code>alt</code>。</li><li><strong>语义化（Semantic HTML）</strong>：使用恰当的标签来表达内容的含义，如 <code>&lt;header&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;footer&gt;</code>，这有助于搜索引擎优化（SEO）和无障碍访问。</li></ul></li></ul><h4 id="2-CSS-Cascading-Style-Sheets"><a href="#2-CSS-Cascading-Style-Sheets" class="headerlink" title="2. CSS (Cascading Style Sheets)"></a>2. CSS (Cascading Style Sheets)</h4><ul><li><strong>是什么</strong>：层叠样式表，用于<strong>定义网页的样式和表现</strong>。它告诉浏览器如何显示 HTML 元素，如颜色、字体、布局、大小等。</li><li><strong>核心概念</strong>：<ul><li><strong>选择器（Selectors）</strong>：用于选中要应用样式的 HTML 元素，如 <code>h1</code> (标签选择器), <code>.my-class</code> (类选择器), <code>#my-id</code> (ID 选择器)。</li><li><strong>盒模型（Box Model）</strong>：每个 HTML 元素都被视为一个矩形盒子，包含 <code>content</code>（内容）、<code>padding</code>（内边距）、<code>border</code>（边框）和 <code>margin</code>（外边距）。</li><li><strong>布局（Layout）</strong>：<ul><li><strong>传统布局</strong>：<code>float</code>, <code>position</code>, <code>display</code>。</li><li><strong>现代布局</strong>：<strong>Flexbox</strong> (弹性盒子，用于一维布局) 和 <strong>Grid</strong> (网格系统，用于二维布局)。这两种是目前最主流的布局方式。</li></ul></li><li><strong>响应式设计（Responsive Design）</strong>：使用 <code>@media</code> 查询来根据设备屏幕大小调整样式，使网页在不同设备上都能良好显示。</li></ul></li></ul><h4 id="3-JavaScript-JS"><a href="#3-JavaScript-JS" class="headerlink" title="3. JavaScript (JS)"></a>3. JavaScript (JS)</h4><ul><li><strong>是什么</strong>：一种高级编程语言，用于<strong>实现网页的动态行为和交互</strong>。它可以操作 HTML 和 CSS，处理用户事件，并与服务器进行通信。</li><li><strong>核心概念</strong>：<ul><li><strong>DOM (Document Object Model) 操作</strong>：通过 <code>document</code> 对象，JS 可以获取、修改、添加或删除页面上的 HTML 元素。例如 <code>document.getElementById(&#39;myId&#39;)</code>。</li><li><strong>事件处理（Event Handling）</strong>：响应用户的行为，如点击、输入、鼠标移动等。例如 <code>element.addEventListener(&#39;click&#39;, function() &#123; ... &#125;)</code>。</li><li><strong>异步编程（Asynchronous Programming）</strong>：处理耗时操作，如网络请求。<ul><li><strong>Callback (回调函数)</strong>：传统方式。</li><li><strong>Promise</strong>：ES6 引入，解决了回调地狱问题。</li><li><strong>async&#x2F;await</strong>：基于 <code>Promise</code> 的语法糖，使异步代码看起来像同步代码，更易读。</li></ul></li><li><strong>AJAX (Asynchronous JavaScript and XML)</strong>：在不重新加载整个页面的情况下，与服务器进行异步通信。现代应用中通常使用 <code>fetch()</code> API 或 <code>Axios</code> 库来发送 JSON 数据。</li></ul></li></ul><hr><h3 id="二、现代前端框架：提升开发效率"><a href="#二、现代前端框架：提升开发效率" class="headerlink" title="二、现代前端框架：提升开发效率"></a>二、现代前端框架：提升开发效率</h3><p>为了处理日益复杂的 Web 应用，开发者通常会使用以下框架。</p><ul><li><strong>React</strong>：由 Facebook 开发，<strong>组件化</strong>、<strong>声明式</strong>的 UI 库。<ul><li><strong>核心</strong>：<strong>组件（Components）</strong>，将 UI 拆分成独立、可复用的部分。</li><li><strong>工作原理</strong>：使用<strong>虚拟 DOM (Virtual DOM)</strong>，在内存中进行计算，然后只更新实际改变的部分，提高了性能。</li><li><strong>生态</strong>：庞大而活跃，有成熟的状态管理（Redux, Zustand）、路由（React Router）等解决方案。</li></ul></li><li><strong>Vue.js</strong>：由尤雨溪开发，易学易用，<strong>渐进式</strong>框架。<ul><li><strong>核心</strong>：<strong>响应式数据绑定</strong>，数据改变，视图自动更新。</li><li><strong>特点</strong>：上手快，文档友好，社区生态完善。</li></ul></li><li><strong>Angular</strong>：由 Google 开发，<strong>全能型</strong>框架。<ul><li><strong>核心</strong>：提供了完整的解决方案，包括路由、依赖注入、状态管理等。</li><li><strong>特点</strong>：适合大型企业级应用，学习曲线相对陡峭。</li></ul></li></ul><hr><h3 id="三、工程化：高效协作和自动化"><a href="#三、工程化：高效协作和自动化" class="headerlink" title="三、工程化：高效协作和自动化"></a>三、工程化：高效协作和自动化</h3><p>现代前端开发已经不仅仅是写代码，还需要使用一系列工具来提高效率。</p><ul><li><strong>包管理器</strong>：<code>npm</code>, <code>yarn</code>, <code>pnpm</code>。用于管理项目依赖。</li><li><strong>构建工具</strong>：<ul><li><strong>Webpack</strong>：将多个模块打包成一个或多个文件，并能处理资源依赖、代码压缩等。</li><li><strong>Vite</strong>：基于 ES Modules 的新一代构建工具，开发模式下速度极快。</li></ul></li><li><strong>转译工具</strong>：<strong>Babel</strong>。将 ES6+ 的代码转译为浏览器兼容的 ES5 代码。</li><li><strong>代码规范</strong>：<strong>ESLint</strong> (代码风格检查), <strong>Prettier</strong> (代码格式化)。</li><li><strong>版本控制</strong>：<strong>Git</strong>。用于团队协作和代码版本管理。</li></ul><p>好的，让我们详细、全面地介绍 CSS 选择器。选择器是 CSS 的核心，掌握它才能精确地控制网页样式。我们将从基础到高级，系统地梳理不同类型的选择器及其用法。</p><hr><h3 id="一、基础选择器-Basic-Selectors"><a href="#一、基础选择器-Basic-Selectors" class="headerlink" title="一、基础选择器 (Basic Selectors)"></a>一、基础选择器 (Basic Selectors)</h3><p>这些是 CSS 中最简单、最常用的选择器，用于直接选中元素。</p><h4 id="1-元素选择器-Type-Selector"><a href="#1-元素选择器-Type-Selector" class="headerlink" title="1. 元素选择器 (Type Selector)"></a>1. 元素选择器 (Type Selector)</h4><ul><li><strong>作用</strong>：根据元素的标签名来选择元素。</li><li><strong>语法</strong>：<code>element_name &#123; ... &#125;</code></li><li><strong>示例</strong>：<ul><li><code>p &#123; color: blue; &#125;</code>：选中所有 <code>&lt;p&gt;</code> 元素。</li><li><code>h1 &#123; font-size: 24px; &#125;</code>：选中所有 <code>&lt;h1&gt;</code> 元素。</li></ul></li></ul><h4 id="2-类选择器-Class-Selector"><a href="#2-类选择器-Class-Selector" class="headerlink" title="2. 类选择器 (Class Selector)"></a>2. 类选择器 (Class Selector)</h4><ul><li><strong>作用</strong>：根据元素的 <code>class</code> 属性来选择元素。</li><li><strong>语法</strong>：<code>.class_name &#123; ... &#125;</code></li><li><strong>特点</strong>：一个元素可以有多个类名，类名可以重复使用，非常灵活。</li><li><strong>示例</strong>：<ul><li><code>.highlight &#123; background-color: yellow; &#125;</code>：选中所有 <code>class</code> 属性中包含 <code>highlight</code> 的元素。</li></ul></li></ul><h4 id="3-ID-选择器-ID-Selector"><a href="#3-ID-选择器-ID-Selector" class="headerlink" title="3. ID 选择器 (ID Selector)"></a>3. ID 选择器 (ID Selector)</h4><ul><li><strong>作用</strong>：根据元素的 <code>id</code> 属性来选择元素。</li><li><strong>语法</strong>：<code>#id_name &#123; ... &#125;</code></li><li><strong>特点</strong>：在 HTML 文档中，一个 <code>id</code> 属性的值必须是<strong>唯一的</strong>。</li><li><strong>示例</strong>：<ul><li><code>#header &#123; height: 100px; &#125;</code>：选中 <code>id</code> 为 <code>header</code> 的唯一元素。</li></ul></li></ul><h4 id="4-通用选择器-Universal-Selector"><a href="#4-通用选择器-Universal-Selector" class="headerlink" title="4. 通用选择器 (Universal Selector)"></a>4. 通用选择器 (Universal Selector)</h4><ul><li><strong>作用</strong>：选择页面上的所有元素。</li><li><strong>语法</strong>：<code>* &#123; ... &#125;</code></li><li><strong>示例</strong>：<ul><li><code>* &#123; margin: 0; padding: 0; &#125;</code>：清除所有元素的默认外边距和内边距，常用于 CSS 重置。</li></ul></li></ul><hr><h3 id="二、组合选择器-Combinators"><a href="#二、组合选择器-Combinators" class="headerlink" title="二、组合选择器 (Combinators)"></a>二、组合选择器 (Combinators)</h3><p>这些选择器用于根据元素之间的关系来选择元素，如父子关系、兄弟关系等。</p><h4 id="1-后代选择器-Descendant-Selector"><a href="#1-后代选择器-Descendant-Selector" class="headerlink" title="1. 后代选择器 (Descendant Selector)"></a>1. 后代选择器 (Descendant Selector)</h4><ul><li><strong>作用</strong>：选择某个元素内部的<strong>所有</strong>后代元素（包括子元素、孙子元素等）。</li><li><strong>语法</strong>：<code>ancestor descendant &#123; ... &#125;</code>，用<strong>空格</strong>分隔。</li><li><strong>示例</strong>：<ul><li><code>ul li &#123; list-style-type: none; &#125;</code>：选中所有 <code>&lt;ul&gt;</code> 内部的 <code>&lt;li&gt;</code> 元素。</li></ul></li></ul><h4 id="2-子选择器-Child-Selector"><a href="#2-子选择器-Child-Selector" class="headerlink" title="2. 子选择器 (Child Selector)"></a>2. 子选择器 (Child Selector)</h4><ul><li><strong>作用</strong>：选择某个元素的<strong>直接子元素</strong>。</li><li><strong>语法</strong>：<code>parent &gt; child &#123; ... &#125;</code>，用 <code>&gt;</code> 分隔。</li><li><strong>示例</strong>：<ul><li><code>ul &gt; li &#123; list-style-type: none; &#125;</code>：只选中 <code>&lt;ul&gt;</code> 的直接子元素 <code>&lt;li&gt;</code>。</li><li><strong>区别</strong>：与后代选择器相比，更加精确，性能也更好。</li></ul></li></ul><h4 id="3-相邻兄弟选择器-Adjacent-Sibling-Selector"><a href="#3-相邻兄弟选择器-Adjacent-Sibling-Selector" class="headerlink" title="3. 相邻兄弟选择器 (Adjacent Sibling Selector)"></a>3. 相邻兄弟选择器 (Adjacent Sibling Selector)</h4><ul><li><strong>作用</strong>：选择紧接在另一个元素后面的<strong>兄弟元素</strong>。</li><li><strong>语法</strong>：<code>element + adjacent_element &#123; ... &#125;</code>，用 <code>+</code> 分隔。</li><li><strong>示例</strong>：<ul><li><code>h1 + p &#123; margin-top: 0; &#125;</code>：选中紧跟在 <code>&lt;h1&gt;</code> 后的第一个 <code>&lt;p&gt;</code> 元素。</li></ul></li></ul><h4 id="4-通用兄弟选择器-General-Sibling-Selector"><a href="#4-通用兄弟选择器-General-Sibling-Selector" class="headerlink" title="4. 通用兄弟选择器 (General Sibling Selector)"></a>4. 通用兄弟选择器 (General Sibling Selector)</h4><ul><li><strong>作用</strong>：选择某个元素后面<strong>所有</strong>的兄弟元素（不限于紧邻的）。</li><li><strong>语法</strong>：<code>element ~ sibling &#123; ... &#125;</code>，用 <code>~</code> 分隔。</li><li><strong>示例</strong>：<ul><li><code>h1 ~ p &#123; margin-top: 0; &#125;</code>：选中 <code>&lt;h1&gt;</code> 后的所有 <code>&lt;p&gt;</code> 元素。</li></ul></li></ul><hr><h3 id="三、属性选择器-Attribute-Selectors"><a href="#三、属性选择器-Attribute-Selectors" class="headerlink" title="三、属性选择器 (Attribute Selectors)"></a>三、属性选择器 (Attribute Selectors)</h3><p>这些选择器根据元素的属性及其值来选择元素。</p><ul><li><strong>[attribute]</strong>：选择具有该属性的元素。<ul><li><code>[title] &#123; ... &#125;</code>：选中所有具有 <code>title</code> 属性的元素。</li></ul></li><li><strong>[attribute&#x3D;”value”]</strong>：选择具有特定属性和值的元素。<ul><li><code>input[type=&quot;text&quot;] &#123; ... &#125;</code>：选中所有 <code>type</code> 属性值为 <code>text</code> 的 <code>&lt;input&gt;</code> 元素。</li></ul></li><li><strong>[attribute~&#x3D;”value”]</strong>：选择属性值中包含特定<strong>独立单词</strong>的元素。<ul><li><code>[class~=&quot;box&quot;] &#123; ... &#125;</code>：选中所有 <code>class</code> 属性中包含 <code>box</code> 这个独立单词的元素（如 <code>class=&quot;card box&quot;</code>）。</li></ul></li><li><strong>[attribute|&#x3D;”value”]</strong>：选择属性值以特定字符串开头（后跟连字符 <code>-</code>）的元素。<ul><li><code>[lang|=&quot;en&quot;] &#123; ... &#125;</code>：选中 <code>lang</code> 属性值为 <code>en</code> 或 <code>en-us</code> 等的元素。</li></ul></li><li><strong>[attribute^&#x3D;”value”]</strong>：选择属性值以特定字符串开头的元素。<ul><li><code>a[href^=&quot;https&quot;] &#123; ... &#125;</code>：选中所有 <code>href</code> 属性以 <code>https</code> 开头的 <code>&lt;a&gt;</code> 元素。</li></ul></li><li><strong>[attribute$&#x3D;”value”]</strong>：选择属性值以特定字符串结尾的元素。<ul><li><code>img[src$=&quot;.png&quot;] &#123; ... &#125;</code>：选中所有 <code>src</code> 属性以 <code>.png</code> 结尾的 <code>&lt;img&gt;</code> 元素。</li></ul></li><li><strong>[attribute*&#x3D;”value”]</strong>：选择属性值中包含特定字符串的元素。<ul><li><code>[title*=&quot;hello&quot;] &#123; ... &#125;</code>：选中所有 <code>title</code> 属性值中包含 <code>hello</code> 的元素。</li></ul></li></ul><hr><h3 id="四、伪类选择器-Pseudo-class-Selectors"><a href="#四、伪类选择器-Pseudo-class-Selectors" class="headerlink" title="四、伪类选择器 (Pseudo-class Selectors)"></a>四、伪类选择器 (Pseudo-class Selectors)</h3><p>伪类用于选择元素的<strong>特定状态</strong>。</p><ul><li><strong>a:link</strong>：未访问的链接。</li><li><strong>a:visited</strong>：已访问的链接。</li><li><strong>a:hover</strong>：鼠标悬停在元素上。</li><li><strong>a:active</strong>：元素被点击时。</li><li><strong>element:focus</strong>：元素获得焦点时（常用于表单）。</li><li><strong>:nth-child(n)</strong>：选择属于其父元素的第 n 个子元素。</li><li><strong>:first-child</strong>：选择属于其父元素的第一个子元素。</li><li><strong>:last-child</strong>：选择属于其父元素的最后一个子元素。</li><li><strong>:not(selector)</strong>：选择不匹配指定选择器的元素。</li><li><strong>:empty</strong>：选择没有子元素或文本内容的元素。</li></ul><hr><h3 id="五、伪元素选择器-Pseudo-element-Selectors"><a href="#五、伪元素选择器-Pseudo-element-Selectors" class="headerlink" title="五、伪元素选择器 (Pseudo-element Selectors)"></a>五、伪元素选择器 (Pseudo-element Selectors)</h3><p>伪元素用于选择元素的<strong>特定部分</strong>。</p><ul><li><strong>::first-line</strong>：选择元素的第一行。</li><li><strong>::first-letter</strong>：选择元素的首个字母。</li><li><strong>::before</strong>：在元素的内容前面插入生成的内容。</li><li><strong>::after</strong>：在元素的内容后面插入生成的内容。</li></ul><hr><h3 id="优先级与层叠"><a href="#优先级与层叠" class="headerlink" title="优先级与层叠"></a>优先级与层叠</h3><p>当多个选择器选中同一个元素并应用不同的样式时，浏览器会根据**优先级（Specificity）**来决定最终样式。</p><ul><li><strong>优先级计算</strong>：<ul><li><code>!important</code>：最高优先级。</li><li><strong>行内样式</strong>：1000</li><li><strong>ID 选择器</strong>：100</li><li><strong>类、属性、伪类选择器</strong>：10</li><li><strong>元素、伪元素选择器</strong>：1</li><li><strong>通用选择器</strong>：0</li></ul></li><li><strong>举例</strong>：<ul><li><code>p &#123; color: red; &#125;</code>（优先级 1）</li><li><code>.highlight &#123; color: blue; &#125;</code>（优先级 10）</li><li><code>#main p &#123; color: green; &#125;</code>（优先级 101）</li></ul></li></ul><p>在这个例子中，即使 <code>p</code> 的样式最先声明，但 <code>main p</code> 的优先级最高，因此 <code>&lt;p id=&quot;main&quot;&gt;</code> 的字体颜色最终会是绿色。</p><p>好的，让我们来全面、深入地介绍 Maven，并剖析一些关键细节以及面试中可能遇到的问题。</p><hr><h3 id="一、Maven-核心概念"><a href="#一、Maven-核心概念" class="headerlink" title="一、Maven 核心概念"></a>一、Maven 核心概念</h3><h4 id="1-什么是-Maven？"><a href="#1-什么是-Maven？" class="headerlink" title="1. 什么是 Maven？"></a>1. 什么是 Maven？</h4><p>Maven 是一个<strong>项目管理和构建自动化工具</strong>。它提供了一套标准化的项目结构、统一的构建生命周期，并依赖于一个<strong>中央仓库</strong>来管理项目所需的依赖。</p><p>它的核心思想是**“约定优于配置”（Convention over Configuration）**，这意味着它有一套默认的项目目录结构和构建流程。只要你遵循这些约定，就可以用很少的配置完成复杂的构建任务。</p><h4 id="2-为什么需要-Maven？"><a href="#2-为什么需要-Maven？" class="headerlink" title="2. 为什么需要 Maven？"></a>2. 为什么需要 Maven？</h4><p>在 Maven 出现之前，Java 项目的构建非常混乱：</p><ul><li><strong>项目结构不统一</strong>：每个项目都有自己的目录结构，新成员需要花时间熟悉。</li><li><strong>依赖管理混乱</strong>：需要手动下载所有 JAR 包，并添加到项目中，非常容易出错。</li><li><strong>构建过程不统一</strong>：编译、测试、打包等操作需要手动执行脚本，效率低下。</li></ul><p>Maven 通过<strong>标准化</strong>解决了这些问题：</p><ul><li><strong>标准化的项目结构</strong>：所有 Maven 项目都遵循相同的目录结构，如 <code>src/main/java</code>、<code>src/test/java</code> 等。</li><li><strong>统一的依赖管理</strong>：通过在 <code>pom.xml</code> 中声明依赖，Maven 会自动从仓库下载并管理。</li><li><strong>标准化的构建生命周期</strong>：定义了一系列标准的构建阶段（如 <code>compile</code>, <code>test</code>, <code>package</code>），可以一键执行。</li></ul><hr><h3 id="二、Maven-的核心组成部分"><a href="#二、Maven-的核心组成部分" class="headerlink" title="二、Maven 的核心组成部分"></a>二、Maven 的核心组成部分</h3><h4 id="1-POM-Project-Object-Model"><a href="#1-POM-Project-Object-Model" class="headerlink" title="1. POM (Project Object Model)"></a>1. POM (Project Object Model)</h4><ul><li><strong>概念</strong>：<code>pom.xml</code> 文件是 Maven 项目的<strong>核心配置文件</strong>。它定义了项目的元数据、依赖、插件、构建配置等所有信息。</li><li><strong>重要标签</strong>：<ul><li><code>&lt;project&gt;</code>：根元素。</li><li><code>&lt;groupId&gt;</code>, <code>&lt;artifactId&gt;</code>, <code>&lt;version&gt;</code>：项目的唯一标识符，通常称为 <strong>GAV 坐标</strong>。</li><li><code>&lt;packaging&gt;</code>：打包类型，如 <code>jar</code>, <code>war</code>, <code>pom</code>。</li><li><code>&lt;dependencies&gt;</code>：定义项目所需的依赖。</li><li><code>&lt;parent&gt;</code>：继承父 POM，实现依赖的统一管理。</li><li><code>&lt;build&gt;</code>：定义构建过程，如插件配置。</li></ul></li></ul><h4 id="2-依赖管理-Dependency-Management"><a href="#2-依赖管理-Dependency-Management" class="headerlink" title="2. 依赖管理 (Dependency Management)"></a>2. 依赖管理 (Dependency Management)</h4><ul><li><strong>概念</strong>：通过在 <code>&lt;dependencies&gt;</code> 中定义 GAV 坐标，Maven 会自动从本地或远程仓库下载依赖。</li><li><strong>传递性依赖</strong>：如果你的项目依赖 A，A 又依赖 B，Maven 会自动将 B 也下载下来。这是其强大的地方，但有时也可能导致版本冲突。</li><li><strong><dependencyManagement></strong>：这是一个非常重要的标签，通常在<strong>父 POM</strong> 中使用。它只定义依赖的版本，但<strong>不实际引入</strong>。子项目继承后，只需声明 <code>&lt;artifactId&gt;</code> 和 <code>&lt;groupId&gt;</code>，版本号会自动继承，这能确保整个项目所有模块的依赖版本一致。</li></ul><h4 id="3-仓库-Repositories"><a href="#3-仓库-Repositories" class="headerlink" title="3. 仓库 (Repositories)"></a>3. 仓库 (Repositories)</h4><p>Maven 仓库是用来存放所有依赖 JAR 包的地方。它分为三种：</p><ul><li><strong>本地仓库 (Local Repository)</strong>：<code>~/.m2/repository</code>，首次下载的依赖会存放在这里，后续构建时会优先从这里读取。</li><li><strong>远程仓库 (Remote Repository)</strong>：<ul><li><strong>中央仓库 (Central Repository)</strong>：Maven 官方维护的公共仓库，包含了绝大多数常用的开源库。</li><li><strong>私服 (Private Repository)</strong>：企业内部搭建的仓库，用于存放公司内部的 JAR 包或作为中央仓库的代理，加快下载速度。</li></ul></li></ul><h4 id="4-生命周期与阶段-Lifecycle-Phases"><a href="#4-生命周期与阶段-Lifecycle-Phases" class="headerlink" title="4. 生命周期与阶段 (Lifecycle &amp; Phases)"></a>4. 生命周期与阶段 (Lifecycle &amp; Phases)</h4><p>Maven 有一套标准的构建生命周期，分为三个：</p><ul><li><strong>clean</strong>：清理项目。<ul><li><code>clean</code>：删除 <code>target</code> 目录。</li></ul></li><li><strong>default</strong>：构建项目。<ul><li><code>validate</code></li><li><code>compile</code>：编译源代码。</li><li><code>test</code>：运行测试。</li><li><code>package</code>：打包。</li><li><code>install</code>：安装到本地仓库。</li><li><code>deploy</code>：部署到远程仓库。</li></ul></li><li><strong>site</strong>：生成项目站点。</li></ul><p><strong>重要规则</strong>：执行某个阶段时，它之前的所有阶段都会按顺序执行。例如，<code>mvn package</code> 会自动执行 <code>compile</code> 和 <code>test</code>。</p><hr><h3 id="三、面试常见问题与回答技巧"><a href="#三、面试常见问题与回答技巧" class="headerlink" title="三、面试常见问题与回答技巧"></a>三、面试常见问题与回答技巧</h3><h4 id="1-Maven-的-GAV-坐标是什么？有什么作用？"><a href="#1-Maven-的-GAV-坐标是什么？有什么作用？" class="headerlink" title="1. Maven 的 GAV 坐标是什么？有什么作用？"></a>1. Maven 的 GAV 坐标是什么？有什么作用？</h4><ul><li><strong>回答</strong>：GAV 坐标是 Maven 项目的唯一标识符，由 <code>&lt;groupId&gt;</code>, <code>&lt;artifactId&gt;</code>, 和 <code>&lt;version&gt;</code> 三个元素组成。</li><li><strong>作用</strong>：<ul><li><strong>唯一性</strong>：确保每个项目和每个版本的依赖在仓库中都是唯一的。</li><li><strong>定位</strong>：Maven 通过 GAV 坐标来查找和下载依赖。</li><li><strong>传递性</strong>：在传递性依赖中，通过 GAV 坐标来识别和处理依赖关系。</li></ul></li></ul><h4 id="2-和-有什么区别？"><a href="#2-和-有什么区别？" class="headerlink" title="2. &lt;dependencyManagement&gt; 和 &lt;dependencies&gt; 有什么区别？"></a>2. <code>&lt;dependencyManagement&gt;</code> 和 <code>&lt;dependencies&gt;</code> 有什么区别？</h4><ul><li><strong>回答</strong>：这是面试高频问题，需要清晰地说明两者的职责。</li><li><strong><dependencies></strong>：<strong>实际引入</strong>依赖。它用于在当前项目中添加一个具体的依赖，Maven 会立即下载并使用它。</li><li><strong><dependencyManagement></strong>：<strong>只定义版本</strong>。它只声明依赖的版本，但<strong>不实际引入</strong>。其主要目的是<strong>统一管理子模块的依赖版本</strong>。子模块继承父 POM 后，只需在自己的 <code>&lt;dependencies&gt;</code> 中声明 <code>&lt;groupId&gt;</code> 和 <code>&lt;artifactId&gt;</code>，版本号会自动从父 POM 中继承，这避免了版本不一致的问题。</li></ul><h4 id="3-什么是-Maven-的生命周期？mvn-install-和-mvn-deploy-有什么区别？"><a href="#3-什么是-Maven-的生命周期？mvn-install-和-mvn-deploy-有什么区别？" class="headerlink" title="3. 什么是 Maven 的生命周期？mvn install 和 mvn deploy 有什么区别？"></a>3. 什么是 Maven 的生命周期？<code>mvn install</code> 和 <code>mvn deploy</code> 有什么区别？</h4><ul><li><strong>回答</strong>：</li><li><strong>生命周期</strong>：Maven 有三个标准的生命周期：<code>clean</code>、<code>default</code> 和 <code>site</code>。其中 <code>default</code> 包含了从编译到部署的所有阶段。</li><li><strong>mvn install</strong>：执行 <code>default</code> 生命周期到 <code>install</code> 阶段。它会将项目打包，并安装到<strong>本地仓库</strong>。这样，其他本地项目就可以依赖这个包。</li><li><strong>mvn deploy</strong>：执行 <code>default</code> 生命周期到 <code>deploy</code> 阶段。它会将项目打包，并部署到<strong>远程仓库</strong>（私服或中央仓库）。这使得其他团队成员或项目可以从远程仓库获取并使用这个包。</li></ul><h4 id="4-Maven-依赖冲突如何解决？"><a href="#4-Maven-依赖冲突如何解决？" class="headerlink" title="4. Maven 依赖冲突如何解决？"></a>4. Maven 依赖冲突如何解决？</h4><ul><li><strong>回答</strong>：当多个依赖间接引入了同一个库的不同版本时，就会发生依赖冲突。</li><li><strong>解决策略</strong>：<ul><li><strong>依赖调解（Dependency Mediation）</strong>：Maven 的默认规则是“<strong>路径最短者优先</strong>”。即在依赖树中，路径最短的那个版本会被选中。</li><li><strong>手动排除（Exclusion）</strong>：如果默认规则不能解决问题，可以在 <code>&lt;dependency&gt;</code> 标签内使用 <code>&lt;exclusions&gt;</code> 标签手动排除有问题的传递性依赖。</li><li><strong>手动引入（Declaration）</strong>：在 <code>&lt;dependencies&gt;</code> 中明确声明需要使用的版本。Maven 的另一个规则是“<strong>最近声明者优先</strong>”，即如果两个依赖路径长度相同，先声明的那个会被使用。但更好的做法是直接在父 POM 的 <code>&lt;dependencyManagement&gt;</code> 中统一版本。</li></ul></li></ul><p>好的，我们来详细梳理你提供的这份关于会话技术的笔记，并按照你要求的逻辑，以一种更清晰、更专业的面试回答或技术讲解的方式进行重新组织和补充。</p><hr><h3 id="一、会话技术概述：解决-HTTP-无状态问题"><a href="#一、会话技术概述：解决-HTTP-无状态问题" class="headerlink" title="一、会话技术概述：解决 HTTP 无状态问题"></a>一、会话技术概述：解决 HTTP 无状态问题</h3><p>HTTP 协议本身是无状态的，它不记得上一次请求的任何信息。为了在多次请求之间共享数据并识别用户，引入了两种核心的会话技术：客户端会话（Cookie）和服务器端会话（Session）。</p><h3 id="二、客户端会话：Cookie"><a href="#二、客户端会话：Cookie" class="headerlink" title="二、客户端会话：Cookie"></a>二、客户端会话：Cookie</h3><p><strong>核心概念</strong>：Cookie 是服务器发送给浏览器并存储在客户端的一小段文本信息。浏览器在下次访问同一服务器时会自动将该 Cookie 携带在请求中。</p><h4 id="1-关于-Cookie-的几个常见问题"><a href="#1-关于-Cookie-的几个常见问题" class="headerlink" title="1. 关于 Cookie 的几个常见问题"></a>1. 关于 Cookie 的几个常见问题</h4><ul><li><strong>一次请求响应可以发送多个 Cookie 吗？</strong><ul><li><strong>回答</strong>：<strong>可以</strong>。服务器可以在一个响应中通过多个 <code>Set-Cookie</code> 响应头来设置多个 Cookie。浏览器会分别存储这些 Cookie，并在后续请求中将它们全部发送给服务器。</li></ul></li><li><strong>Cookie 支持中文传输吗？</strong><ul><li><strong>回答</strong>：<strong>在大多数现代服务器和浏览器中都支持。</strong> 在早期的 Servlet 容器（如 Tomcat 8.0 之前），Cookie 不能直接存储中文，需要手动进行 URL 编码（<code>URLEncoder</code>）和解码（<code>URLDecoder</code>）。<strong>在 Tomcat 8.0 及以后版本</strong>，容器默认支持 UTF-8 编码，可以直接存储中文。</li></ul></li><li><strong>Cookie 的过期时间如何设置？</strong><ul><li><strong>回答</strong>：通过 <code>response.addCookie(cookie)</code> 方法，并调用 <code>cookie.setMaxAge(int expiry)</code> 方法来设置。<ul><li><code>expiry &gt; 0</code>：表示 Cookie 将被<strong>持久化</strong>到客户端硬盘，有效期为 <code>expiry</code> 秒。即使浏览器关闭，Cookie 依然存在，直到过期。</li><li><code>expiry = 0</code>：表示<strong>立即删除</strong>该 Cookie。常用于退出登录功能。</li><li><code>expiry &lt; 0</code>：<strong>默认值</strong>。表示 Cookie 只在内存中存在，当<strong>浏览器关闭时</strong>，该 Cookie 就会被删除。</li></ul></li></ul></li></ul><h4 id="2-Cookie-的特点"><a href="#2-Cookie-的特点" class="headerlink" title="2. Cookie 的特点"></a>2. Cookie 的特点</h4><ul><li><strong>存储位置</strong>：存储在客户端（浏览器）。</li><li><strong>大小限制</strong>：单个 Cookie 最大约 4KB。</li><li><strong>数量限制</strong>：一个服务器最多可以向一个浏览器保存 20 个 Cookie，一个浏览器最多可以保存 300 个 Cookie（这些是早期的规范，现代浏览器已放宽，但仍有限制）。</li><li><strong>安全性</strong>：数据以明文形式存储，且容易被用户修改，安全性较差。</li></ul><h4 id="3-Cookie-案例：获取上一次访问时间"><a href="#3-Cookie-案例：获取上一次访问时间" class="headerlink" title="3. Cookie 案例：获取上一次访问时间"></a>3. Cookie 案例：获取上一次访问时间</h4><p>这个案例是经典的 Cookie 用法。</p><ul><li><strong>首次访问</strong>：服务器接收请求，判断 Cookie 中没有记录上次访问时间。服务器创建一个新的 Cookie，存储当前时间，并将其发送给浏览器。</li><li><strong>再次访问</strong>：浏览器自动将上次存储的 Cookie 发送给服务器。服务器读取 Cookie，获取上次访问时间，并将其显示给用户。然后，服务器可以更新 Cookie 的时间，再次发送给浏览器。</li></ul><h3 id="三、服务器端会话：HttpSession"><a href="#三、服务器端会话：HttpSession" class="headerlink" title="三、服务器端会话：HttpSession"></a>三、服务器端会话：HttpSession</h3><p><strong>核心概念</strong>：Session 是服务器端为每个客户端创建的一个对象，用于在一次会话的多个请求之间存储和共享数据。</p><h4 id="1-Session-的快速使用"><a href="#1-Session-的快速使用" class="headerlink" title="1. Session 的快速使用"></a>1. Session 的快速使用</h4><ul><li><strong>获取对象</strong>：通过 <code>HttpServletRequest</code> 对象的 <code>getSession()</code> 方法来获取 <code>HttpSession</code> 对象。</li><li><strong>使用对象（域对象）</strong>：Session 是一个<strong>域对象</strong>，提供了以下方法：<ul><li><code>void setAttribute(String name, Object value)</code>：将数据以键值对形式存储到 Session 中。</li><li><code>Object getAttribute(String name)</code>：根据键名获取存储的数据。</li><li><code>void removeAttribute(String name)</code>：根据键名删除存储的数据。</li></ul></li></ul><h4 id="2-Session-的失效时间"><a href="#2-Session-的失效时间" class="headerlink" title="2. Session 的失效时间"></a>2. Session 的失效时间</h4><ul><li><p><strong>服务器关闭</strong>：当服务器关闭时，所有 Session 对象都会被销毁。</p></li><li><p><strong>手动失效</strong>：调用 <code>session.invalidate()</code> 方法，可以立即强制 Session 失效。常用于用户退出登录。</p></li><li><p><strong>默认失效时间</strong>：默认情况下，Session 有一个超时时间，通常是 30 分钟。如果客户端在 30 分钟内没有向服务器发送任何请求，Session 就会自动失效。这个时间可以在 <code>web.xml</code> 中配置。</p></li><li><p>对的 👍，在 **Java Web 应用（Servlet 容器，比如 Tomcat）**里，<code>Session</code> 的默认失效时间通常是 <strong>30 分钟</strong>。</p><p>要修改它，可以在 <code>web.xml</code> 中配置 <code>&lt;session-config&gt;</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- session 过期时间设置（单位：分钟） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>60<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>📌 说明：</p><ul><li><code>60</code> 表示 Session 在 <strong>60 分钟</strong>无请求时会自动失效。</li><li>默认值是 <strong>30</strong> 分钟，如果不配置，就走默认。</li><li>这个配置对所有用户 Session 都生效。</li></ul><h3 id="🔧-在代码里动态设置（单个-Session）"><a href="#🔧-在代码里动态设置（单个-Session）" class="headerlink" title="🔧 在代码里动态设置（单个 Session）"></a>🔧 在代码里动态设置（单个 Session）</h3><p>除了在 <code>web.xml</code> 里全局配置，还可以针对某个用户的 Session 动态修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">session.setMaxInactiveInterval(<span class="number">120</span> * <span class="number">60</span>); <span class="comment">// 单位：秒，这里是 2 小时</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="🔧-特殊情况"><a href="#🔧-特殊情况" class="headerlink" title="🔧 特殊情况"></a>🔧 特殊情况</h3><ul><li>如果 <code>session-timeout</code> 设置为 <strong>0</strong> → Session 永不超时（危险 ⚠️，容易导致内存泄露）。</li><li>如果设置为 <strong>负数</strong>（如 -1） → 表示 Session 仅在浏览器关闭时销毁（有些容器支持，有些不支持。</li></ul><h4 id="3-Session-的特点"><a href="#3-Session-的特点" class="headerlink" title="3. Session 的特点"></a>3. Session 的特点</h4><ul><li><strong>存储位置</strong>：存储在服务器端。</li><li><strong>大小限制</strong>：可以存储任意类型、任意大小的数据（受限于服务器内存）。</li><li><strong>安全性</strong>：由于数据存储在服务器，客户端只传递一个 Session ID，安全性相对较高。</li></ul><h4 id="4-面试题：Cookie-和-Session-的区别？"><a href="#4-面试题：Cookie-和-Session-的区别？" class="headerlink" title="4. 面试题：Cookie 和 Session 的区别？"></a>4. 面试题：Cookie 和 Session 的区别？</h4><ul><li><strong>存储位置</strong>：Cookie 存储在<strong>客户端</strong>，Session 存储在<strong>服务器端</strong>。</li><li><strong>数据大小</strong>：Cookie 的大小<strong>有限制</strong>（约 4KB），Session 的大小<strong>没有限制</strong>。</li><li><strong>安全性</strong>：Session <strong>相对安全</strong>，Cookie <strong>相对不安全</strong>。因为 Session ID 难以被猜测，而 Cookie 存储的数据是明文。</li><li><strong>服务器开销</strong>：Session 会占用服务器内存，在高并发场景下可能成为性能瓶颈；而 Cookie 不占用服务器资源。</li></ul><h3 id="四、Servlet-三大域对象的关系（按照你的逻辑）"><a href="#四、Servlet-三大域对象的关系（按照你的逻辑）" class="headerlink" title="四、Servlet 三大域对象的关系（按照你的逻辑）"></a>四、Servlet 三大域对象的关系（按照你的逻辑）</h3><p><strong>域对象</strong>（Scope Object）是指那些可以用来在不同组件之间共享数据的对象。Servlet 规范提供了三个这样的对象，它们的生命周期不同，从而决定了数据的共享范围。</p><ul><li><strong>request 域</strong>：生命周期最短。数据只能在<strong>一次请求-响应</strong>的周期内共享。即使请求被转发（forward），数据也依然可见。</li><li><strong>session 域</strong>：生命周期中等。数据可以在<strong>一次会话</strong>（多个请求）之间共享。只要浏览器不关闭，且 Session 未超时或失效，数据就一直存在。</li><li><strong>servletContext 域</strong>：生命周期最长。数据可以在<strong>整个 Web 应用</strong>中共享。从 Web 应用启动到关闭，数据都一直存在。</li></ul><p><strong>三大域对象之间的关系是包含关系，即 request &lt; session &lt; servletContext。</strong></p><ul><li><strong>request 包含于 session</strong>：一个 Session 中可以有多个请求。</li><li><strong>session 包含于 servletContext</strong>：一个 Web 应用（ServletContext）中可以有多个 Session。</li></ul><p>这个关系图清晰地展示了它们各自的生命周期和数据共享范围，是理解 Servlet 域对象的关键。</p><h2 id="Jar-Hell"><a href="#Jar-Hell" class="headerlink" title="Jar Hell"></a>Jar Hell</h2><p>你这个场景就是 <strong>同一个库的两个版本必须共存</strong>，典型的 “深度 JAR hell” 🚨。<br> 比如：</p><ul><li>你的系统用到 <strong>老版本 log4j</strong>，</li><li>但某个第三方库硬性依赖 <strong>新版本 log4j</strong>。</li></ul><p>这时候如果放到同一个 classpath 里，肯定会冲突。解决思路主要有三类：</p><hr><h3 id="✅-两个版本-JAR-共存的解决方案"><a href="#✅-两个版本-JAR-共存的解决方案" class="headerlink" title="✅ 两个版本 JAR 共存的解决方案"></a>✅ 两个版本 JAR 共存的解决方案</h3><h4 id="1-ClassLoader-隔离（推荐方式）"><a href="#1-ClassLoader-隔离（推荐方式）" class="headerlink" title="1. ClassLoader 隔离（推荐方式）"></a>1. <strong>ClassLoader 隔离</strong>（推荐方式）</h4><p>利用 <strong>不同的类加载器</strong> 来隔离两个版本的依赖，让它们互不干扰。</p><ul><li><p><strong>Web 容器隔离</strong>：</p><ul><li>把一个版本放在 <code>WEB-INF/lib</code>，另一个放在全局 <code>lib/ext</code>。</li><li>通过 parent-first &#x2F; parent-last 策略控制加载。</li></ul></li><li><p><strong>自定义 ClassLoader</strong>：</p><ul><li><p>用 <code>URLClassLoader</code> 指定不同版本 JAR 的路径。</p></li><li><p>哪个模块需要哪个版本，就用哪个 ClassLoader。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">URLClassLoader loaderV1 = new URLClassLoader(</span><br><span class="line">    new URL[]&#123; new File(&quot;lib/lib-old.jar&quot;).toURI().toURL() &#125;,</span><br><span class="line">    null // 不委托父加载器</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">URLClassLoader loaderV2 = new URLClassLoader(</span><br><span class="line">    new URL[]&#123; new File(&quot;lib/lib-new.jar&quot;).toURI().toURL() &#125;,</span><br><span class="line">    null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; clazz1 = loaderV1.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">Class&lt;?&gt; clazz2 = loaderV2.loadClass(&quot;com.example.MyClass&quot;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>👉 OSGi、Spring Boot 的 <strong>ClassLoader 层级</strong>就是用这种方法解决多版本依赖的。</p><hr><h4 id="2-包重定位（Shading-Relocation）"><a href="#2-包重定位（Shading-Relocation）" class="headerlink" title="2. 包重定位（Shading &#x2F; Relocation）"></a>2. <strong>包重定位（Shading &#x2F; Relocation）</strong></h4><p>把其中一个版本的包路径 <strong>改名</strong>，让 JVM 认为它是完全不同的类库。</p><ul><li><p>工具：</p><ul><li><code>jarjar</code></li><li>Maven Shade（即使你不用 Maven，也可以单独跑插件）</li><li>Gradle Shadow</li></ul></li><li><p>原理：自动把 <code>org.apache.commons</code> 改成 <code>myproject.shaded.org.apache.commons</code>。</p></li><li><p>示例（JarJar 规则）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule org.apache.log4j.** com.myapp.shaded.log4j.@1</span><br></pre></td></tr></table></figure></li></ul><p>这样，项目就能同时用 <code>log4j-1.2</code> 和 <code>log4j-2.x</code>。</p><hr><h4 id="3-服务解耦-模块化"><a href="#3-服务解耦-模块化" class="headerlink" title="3. 服务解耦 &#x2F; 模块化"></a>3. <strong>服务解耦 &#x2F; 模块化</strong></h4><p>如果两个版本都要在 <strong>同一个 JVM 里用</strong>，但 ClassLoader 太麻烦：</p><ul><li><strong>拆分成微服务 &#x2F; 子进程</strong>，让不同进程使用不同版本的依赖。</li><li>或者在 <strong>Java 9+ 模块系统 (JPMS)</strong> 下，给不同模块声明不同依赖，避免直接冲突。</li></ul><hr><h3 id="🚀-实际建议"><a href="#🚀-实际建议" class="headerlink" title="🚀 实际建议"></a>🚀 实际建议</h3><ul><li>如果你是 <strong>自己开发的项目</strong> → 用 <strong>包重定位</strong> 比较简单。</li><li>如果是 <strong>插件式系统 &#x2F; 容器运行</strong> → 用 <strong>ClassLoader 隔离</strong>。</li><li>如果是 <strong>重量级系统</strong>（比如需要不同版本的 JDBC 驱动） → 拆进程更干净。</li></ul><hr><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="一、CSS-选择器概述：精准定位网页元素"><a href="#一、CSS-选择器概述：精准定位网页元素" class="headerlink" title="一、CSS 选择器概述：精准定位网页元素"></a>一、CSS 选择器概述：精准定位网页元素</h4><p><strong>选择器</strong>是 CSS 的核心，它用于<strong>精确地选择 HTML 文档中的元素</strong>，并为其应用样式。掌握不同类型的选择器及其组合，是高效编写 CSS 代码的关键。</p><h4 id="二、基础选择器-Basic-Selectors"><a href="#二、基础选择器-Basic-Selectors" class="headerlink" title="二、基础选择器 (Basic Selectors)"></a>二、基础选择器 (Basic Selectors)</h4><p>基础选择器用于根据最基本的属性（标签、类、ID）来选择元素。</p><h5 id="1-标签选择器-Type-Selector"><a href="#1-标签选择器-Type-Selector" class="headerlink" title="1. 标签选择器 (Type Selector)"></a>1. 标签选择器 (Type Selector)</h5><ul><li><p><strong>原理</strong>：根据元素的<strong>标签名称</strong>来匹配。</p></li><li><p><strong>优点</strong>：简单、直接，可以一次性选中所有同类型的元素。</p></li><li><p><strong>缺点</strong>：过于笼统，无法对个别元素进行精确控制。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123; color: red; &#125; /* 所有&lt;div&gt;标签的字体颜色都为红色 */</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-类选择器-Class-Selector-1"><a href="#2-类选择器-Class-Selector-1" class="headerlink" title="2. 类选择器 (Class Selector)"></a>2. 类选择器 (Class Selector)</h5><ul><li><p><strong>原理</strong>：根据元素的 <code>class</code> 属性值来匹配。</p></li><li><p><strong>优点</strong>：</p><ul><li><strong>高度复用</strong>：可以在多个元素上使用同一个类名。</li><li><strong>灵活</strong>：一个元素可以拥有多个类名，用空格分隔。</li></ul></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.cl1 &#123; color: red; &#125; /* 所有class属性包含cl1的元素，字体颜色为红色 */</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-ID-选择器-ID-Selector-1"><a href="#3-ID-选择器-ID-Selector-1" class="headerlink" title="3. ID 选择器 (ID Selector)"></a>3. ID 选择器 (ID Selector)</h5><ul><li><p><strong>原理</strong>：根据元素的 <code>id</code> 属性值来匹配。</p></li><li><p><strong>优点</strong>：<strong>唯一性</strong>，精确地选中文档中唯一的元素。</p></li><li><p><strong>缺点</strong>：不具复用性，一个 ID 在文档中只能出现一次。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#p1 &#123; color: red; &#125; /* id为p1的唯一元素，字体颜色为红色 */</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-通配符选择器-Universal-Selector"><a href="#4-通配符选择器-Universal-Selector" class="headerlink" title="4. 通配符选择器 (Universal Selector)"></a>4. 通配符选择器 (Universal Selector)</h5><ul><li><p><strong>原理</strong>：匹配文档中<strong>所有</strong>的元素。</p></li><li><p><strong>优点</strong>：可以快速设置全局样式，常用于重置浏览器默认样式。</p></li><li><p><strong>缺点</strong>：性能开销大，因为浏览器需要遍历所有元素，应谨慎使用。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123; margin: 0; padding: 0; &#125; /* 清除所有元素的内外边距 */</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="三、组合选择器-Combinators"><a href="#三、组合选择器-Combinators" class="headerlink" title="三、组合选择器 (Combinators)"></a>三、组合选择器 (Combinators)</h4><p>组合选择器通过符号连接多个选择器，根据元素之间的关系来匹配。</p><h5 id="1-交集选择器-Intersection-Selector"><a href="#1-交集选择器-Intersection-Selector" class="headerlink" title="1. 交集选择器 (Intersection Selector)"></a>1. 交集选择器 (Intersection Selector)</h5><ul><li><p><strong>原理</strong>：同时满足多个选择器条件的元素。</p></li><li><p><strong>语法</strong>：<code>selector1selector2 &#123; ... &#125;</code>，中间<strong>没有空格</strong>。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.cl1 &#123; color: red; &#125; /* 既是&lt;div&gt;标签，又拥有cl1这个class的元素 */</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-并集选择器-Union-Selector"><a href="#2-并集选择器-Union-Selector" class="headerlink" title="2. 并集选择器 (Union Selector)"></a>2. 并集选择器 (Union Selector)</h5><ul><li><p><strong>原理</strong>：匹配所有满足其中任意一个选择器条件的元素。</p></li><li><p><strong>语法</strong>：<code>selector1, selector2 &#123; ... &#125;</code>，以<strong>逗号</strong>分隔。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, p &#123; color: red; &#125; /* 所有&lt;a&gt;标签和所有&lt;p&gt;标签的字体颜色都为红色 */</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-子选择器-Child-Selector"><a href="#3-子选择器-Child-Selector" class="headerlink" title="3. 子选择器 (Child Selector)"></a>3. 子选择器 (Child Selector)</h5><ul><li><p><strong>原理</strong>：匹配<strong>直接</strong>子元素。</p></li><li><p><strong>语法</strong>：<code>parent &gt; child &#123; ... &#125;</code>，以 <code>&gt;</code> 符号分隔。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#outer &gt; span &#123; color: red; &#125; /* 只选中id为outer的&lt;div&gt;的直接子元素&lt;span&gt; */</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-后代选择器-Descendant-Selector"><a href="#4-后代选择器-Descendant-Selector" class="headerlink" title="4. 后代选择器 (Descendant Selector)"></a>4. 后代选择器 (Descendant Selector)</h5><ul><li><p><strong>原理</strong>：匹配所有位于祖先元素内部的<strong>所有后代</strong>元素。</p></li><li><p><strong>语法</strong>：<code>ancestor descendant &#123; ... &#125;</code>，以<strong>空格</strong>分隔。</p></li><li><p><strong>示例</strong>：</p><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#outer span &#123; color: red; &#125; /* 选中id为outer的&lt;div&gt;内部的所有&lt;span&gt;，无论嵌套多深 */</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="四、属性选择器-Attribute-Selectors"><a href="#四、属性选择器-Attribute-Selectors" class="headerlink" title="四、属性选择器 (Attribute Selectors)"></a>四、属性选择器 (Attribute Selectors)</h4><p>属性选择器根据元素的属性及其值来匹配。</p><ul><li><strong>[attribute]</strong>：匹配具有该属性的元素。<ul><li>示例：<code>[class]</code> 匹配所有具有 <code>class</code> 属性的元素。</li></ul></li><li><strong>[attribute&#x3D;”value”]</strong>：匹配属性值完全相等的元素。<ul><li>示例：<code>[type=&quot;text&quot;]</code> 匹配 <code>type</code> 属性值恰好为 <code>&quot;text&quot;</code> 的元素。</li></ul></li><li><strong>[attribute~&#x3D;”value”]</strong>：匹配属性值中包含该<strong>独立单词</strong>的元素。</li><li><strong>[attribute^&#x3D;”value”]</strong>：匹配属性值以该字符串<strong>开头</strong>的元素。</li><li><strong>[attribute$&#x3D;”value”]</strong>：匹配属性值以该字符串<strong>结尾</strong>的元素。</li><li><strong>[attribute*&#x3D;”value”]</strong>：匹配属性值中包含该字符串的<strong>任意位置</strong>的元素。</li></ul><hr><h4 id="五、伪类与伪元素选择器-Pseudo-class-Pseudo-element-Selectors"><a href="#五、伪类与伪元素选择器-Pseudo-class-Pseudo-element-Selectors" class="headerlink" title="五、伪类与伪元素选择器 (Pseudo-class &amp; Pseudo-element Selectors)"></a>五、伪类与伪元素选择器 (Pseudo-class &amp; Pseudo-element Selectors)</h4><ul><li><strong>伪类</strong>：用<strong>一个冒号 :</strong>，表示元素在<strong>特定状态</strong>下的样式。<ul><li><strong>:link</strong>：未访问的链接。</li><li><strong>:visited</strong>：已访问的链接。</li><li><strong>:hover</strong>：鼠标悬停状态。</li><li><strong>:active</strong>：被点击状态。</li><li><strong>:focus</strong>：获得焦点状态（常用于表单）。</li></ul></li><li><strong>伪元素</strong>：用<strong>两个冒号 ::</strong>，表示元素的<strong>特定部分</strong>。<ul><li><strong>::before</strong> 和 <strong>::after</strong>：在元素内容的前后插入内容。</li><li><strong>::first-line</strong>：元素的文本第一行。</li><li><strong>::first-letter</strong>：元素的文本第一个字母。</li></ul></li></ul><hr><h4 id="六、选择器优先级-Specificity"><a href="#六、选择器优先级-Specificity" class="headerlink" title="六、选择器优先级 (Specificity)"></a>六、选择器优先级 (Specificity)</h4><p>这是 CSS 的核心机制，决定了当多个规则应用到同一个元素时，哪一个会生效。</p><ul><li><strong>计算规则</strong>：优先级由<strong>选择器的类型</strong>和<strong>数量</strong>决定。<ol><li><strong>行内样式</strong>：优先级最高，为 <code>1000</code>。</li><li><strong>ID 选择器</strong>：优先级为 <code>100</code>。</li><li><strong>类、属性、伪类选择器</strong>：优先级为 <code>10</code>。</li><li><strong>元素、伪元素选择器</strong>：优先级为 <code>1</code>。</li><li><strong>通用选择器 *</strong>：优先级为 <code>0</code>。</li></ol></li><li><strong>!important</strong>：最高优先级，但会破坏层叠机制，应<strong>避免使用</strong>。</li></ul><p>如何计算：</p><p>将每个选择器的优先级数字相加，得到一个最终的权重值。权重值越高的规则越优先。</p><ul><li>示例：<ul><li><code>p</code>：权重 <code>1</code>。</li><li><code>.cl1</code>：权重 <code>10</code>。</li><li><code>div.cl1</code>：权重 <code>1 + 10 = 11</code>。</li><li><code>#p1</code>：权重 <code>100</code>。</li><li><code>#outer span</code>：权重 <code>100 + 1 = 101</code>。</li></ul></li></ul><p><strong>!important</strong> 会凌驾于所有这些规则之上。当你遇到样式不生效的问题时，首先要检查优先级，其次是是否有 <code>!important</code> 的存在。</p><hr><h4 id="BOM-Browser-Object-Model"><a href="#BOM-Browser-Object-Model" class="headerlink" title="BOM (Browser Object Model)"></a>BOM (Browser Object Model)</h4><h5 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h5><p><strong>BOM</strong>，即<strong>浏览器对象模型</strong>，是 JavaScript 用于<strong>操作浏览器窗口</strong>的一套 API。它没有统一的标准，而是由各个浏览器厂商各自实现的。BOM 的核心是 <code>window</code> 对象，它既代表了浏览器窗口本身，也是 JavaScript 全局作用域的唯一对象。</p><h5 id="2-BOM-的核心对象与功能"><a href="#2-BOM-的核心对象与功能" class="headerlink" title="2. BOM 的核心对象与功能"></a>2. BOM 的核心对象与功能</h5><p>BOM 提供了以下关键对象，用于与浏览器进行交互：</p><ul><li><strong>window 对象</strong>：<ul><li><strong>全局对象</strong>：<code>window</code> 是 JavaScript 的全局对象，所有全局变量和函数都是 <code>window</code> 对象的属性和方法。</li><li><strong>窗口控制</strong>：<code>window.open()</code> (打开新窗口), <code>window.close()</code> (关闭当前窗口)。</li><li><strong>定时器</strong>：<code>setTimeout()</code> 和 <code>setInterval()</code>，用于延迟或重复执行代码。</li><li><strong>导航与位置</strong>：<code>window.location</code>，用于获取和修改当前页面的 URL。</li></ul></li><li><strong>location 对象</strong>：<ul><li><strong>URL 信息</strong>：提供了当前 URL 的详细信息，如 <code>location.href</code> (完整 URL), <code>location.protocol</code> (协议), <code>location.hostname</code> (主机名), <code>location.pathname</code> (路径)。</li><li><strong>页面跳转</strong>：<code>location.href = &#39;new_url&#39;</code> 或 <code>location.assign(&#39;new_url&#39;)</code> (有历史记录), <code>location.replace(&#39;new_url&#39;)</code> (不留历史记录), <code>location.reload()</code> (刷新页面)。</li></ul></li><li><strong>history 对象</strong>：<ul><li><strong>历史记录</strong>：提供了对浏览器历史记录的访问。</li><li><strong>导航</strong>：<code>history.back()</code> (后退), <code>history.forward()</code> (前进), <code>history.go(n)</code> (前进或后退 n 页)。</li></ul></li><li><strong>navigator 对象</strong>：<ul><li><strong>浏览器信息</strong>：提供了关于浏览器本身的信息，如 <code>navigator.userAgent</code> (用户代理字符串), <code>navigator.platform</code> (操作系统), <code>navigator.onLine</code> (是否在线)。</li></ul></li><li><strong>screen 对象</strong>：<ul><li><strong>屏幕信息</strong>：提供了关于用户屏幕的信息，如 <code>screen.width</code> (屏幕宽度), <code>screen.height</code> (屏幕高度)。</li></ul></li></ul><h5 id="3-BOM-的特点"><a href="#3-BOM-的特点" class="headerlink" title="3. BOM 的特点"></a>3. BOM 的特点</h5><ul><li><strong>没有标准</strong>：BOM 没有 W3C 的正式标准，不同浏览器可能在实现上存在差异。</li><li><strong>以 window 为核心</strong>：所有 BOM 对象都是 <code>window</code> 对象的属性。</li></ul><hr><h4 id="DOM-Document-Object-Model"><a href="#DOM-Document-Object-Model" class="headerlink" title="DOM (Document Object Model)"></a>DOM (Document Object Model)</h4><h5 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h5><p><strong>DOM</strong>，即<strong>文档对象模型</strong>，是 JavaScript 用于<strong>操作 HTML 或 XML 文档</strong>的一套 API。它将整个 HTML 文档解析为一个<strong>树形结构</strong>，每个 HTML 标签、属性和文本都成为了树中的一个节点（Node）。DOM 是一个由 W3C 制定的标准。</p><h5 id="2-DOM-的核心对象与功能"><a href="#2-DOM-的核心对象与功能" class="headerlink" title="2. DOM 的核心对象与功能"></a>2. DOM 的核心对象与功能</h5><p>DOM 的核心是 <code>document</code> 对象，它是整个文档的入口。</p><ul><li><strong>document 对象</strong>：<ul><li><strong>DOM 树的根节点</strong>：代表整个 HTML 文档。</li><li><strong>元素获取</strong>：提供了多种方法来获取页面上的元素：<ul><li><code>document.getElementById(&#39;id&#39;)</code>：通过 ID 获取单个元素。</li><li><code>document.getElementsByClassName(&#39;class&#39;)</code>：通过类名获取元素集合。</li><li><code>document.getElementsByTagName(&#39;tag&#39;)</code>：通过标签名获取元素集合。</li><li><code>document.querySelector(&#39;css_selector&#39;)</code>：通过 CSS 选择器获取第一个匹配的元素。</li><li><code>document.querySelectorAll(&#39;css_selector&#39;)</code>：通过 CSS 选择器获取所有匹配的元素。</li></ul></li></ul></li><li><strong>元素节点（Element Nodes）</strong>：<ul><li><strong>操作元素</strong>：提供了操作 HTML 元素的方法和属性：<ul><li><code>element.innerHTML</code>：获取或设置元素的 HTML 内容。</li><li><code>element.style.color</code>：修改元素的行内样式。</li><li><code>element.setAttribute(&#39;attr&#39;, &#39;val&#39;)</code>：设置元素的属性。</li><li><code>element.addEventListener(&#39;event&#39;, handler)</code>：添加事件监听器。</li></ul></li></ul></li><li><strong>DOM 树操作</strong>：<ul><li><strong>创建</strong>：<code>document.createElement(&#39;tag&#39;)</code> (创建新元素)。</li><li><strong>添加</strong>：<code>parent.appendChild(child)</code> (添加子元素)。</li><li><strong>删除</strong>：<code>parent.removeChild(child)</code> (删除子元素)。</li><li><strong>替换</strong>：<code>parent.replaceChild(newChild, oldChild)</code> (替换子元素)。</li></ul></li></ul><h5 id="3-DOM-的特点"><a href="#3-DOM-的特点" class="headerlink" title="3. DOM 的特点"></a>3. DOM 的特点</h5><ul><li><strong>有标准</strong>：DOM 是由 W3C 制定的标准，因此在不同浏览器中的实现差异较小。</li><li><strong>树形结构</strong>：将 HTML 文档抽象为树形结构，使得我们可以通过编程的方式像操作树一样操作网页。</li></ul><hr><h4 id="BOM-和-DOM-的核心区别与联系"><a href="#BOM-和-DOM-的核心区别与联系" class="headerlink" title="BOM 和 DOM 的核心区别与联系"></a>BOM 和 DOM 的核心区别与联系</h4><table><thead><tr><th>特性</th><th>BOM (Browser Object Model)</th><th>DOM (Document Object Model)</th></tr></thead><tbody><tr><td><strong>主要功能</strong></td><td><strong>操作浏览器窗口</strong></td><td><strong>操作网页文档内容</strong></td></tr><tr><td><strong>核心对象</strong></td><td><code>window</code></td><td><code>document</code></td></tr><tr><td><strong>标准化</strong></td><td>无统一标准（各浏览器实现不同）</td><td>有 W3C 标准</td></tr><tr><td><strong>层级关系</strong></td><td><code>window</code> 包含了 <code>location</code>, <code>history</code>, <code>navigator</code> 等，<strong>也包含了 document 对象</strong>。</td><td><code>document</code> 包含了 HTML 元素的树形结构。</td></tr></tbody></table><p>它们的关系：</p><p>BOM 是 DOM 的超集。window 对象是所有 JavaScript 对象的全局对象，它包含了 document 对象。换句话说，window.document 就是 document。因此，当我们使用 document 对象来操作网页时，实际上是通过 window 对象来访问的。</p><p>这个关系可以理解为：</p><p>window -&gt; 浏览器窗口</p><p>document -&gt; 窗口中加载的文档</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><hr><h4 id="一、JavaScript-中的数据类型"><a href="#一、JavaScript-中的数据类型" class="headerlink" title="一、JavaScript 中的数据类型"></a>一、JavaScript 中的数据类型</h4><h5 id="1-基础数据类型（原始数据类型）"><a href="#1-基础数据类型（原始数据类型）" class="headerlink" title="1. 基础数据类型（原始数据类型）"></a>1. 基础数据类型（原始数据类型）</h5><ul><li><p><strong>number 类型</strong>：</p><ul><li><strong>深入</strong>：JS 采用 IEEE 754 标准的双精度 64 位浮点数来表示所有数字。这意味着它<strong>没有单独的整数类型</strong>，所有数字都是浮点数。</li><li><code>NaN</code> (Not a Number)：表示非数字值。需要注意的是，<code>typeof NaN</code> 结果是 <code>number</code>。<code>NaN</code> 不等于自身，<code>NaN === NaN</code> 结果为 <code>false</code>。</li><li><code>Infinity</code>：表示正无穷大，<code>+Infinity</code> 和 <code>-Infinity</code> 分别表示正负无穷大。</li><li><code>0.1 + 0.2 !== 0.3</code>：由于浮点数表示的精度问题，这个经典问题需要注意。</li></ul></li><li><p><strong>boolean 类型</strong>：</p><ul><li><strong>深入</strong>：<code>true</code> 和 <code>false</code>。在条件判断中，所有数据类型都会被隐式转换为布尔值。</li></ul></li><li><p><strong>undefined 类型</strong>：</p><ul><li><strong>深入</strong>：表示一个<strong>未定义</strong>的变量或变量<strong>未被赋值</strong>。<code>typeof undefined</code> 结果为 <code>undefined</code>。它是一个值也是一个类型。</li><li><code>null</code>：与 <code>undefined</code> 的区别在于，<code>null</code> 是一种<strong>意图</strong>，表示变量被显式地赋予了“空”值。<code>typeof null</code> 结果为 <code>object</code>，这是一个历史遗留的 bug。</li></ul></li><li><p><strong>string 类型</strong>：</p><ul><li><p><strong>深入</strong>：JS 中<strong>没有字符类型</strong>。字符串是不可变的，一旦创建就不能修改。</p></li><li><p><strong>反引号（     ）</strong>：ES6 引入，支持<strong>模板字面量</strong>。它允许在字符串中嵌入变量和表达式，并支持多行书写，极大提升了字符串拼接的便利性。</p><p>JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = &quot;张三&quot;;</span><br><span class="line">console.log(`你好，我的名字是$&#123;name&#125;。`);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-数据类型转换"><a href="#2-数据类型转换" class="headerlink" title="2. 数据类型转换"></a>2. 数据类型转换</h5><ul><li><p><strong>转换为 number</strong>：<code>Number(value)</code></p><ul><li><strong>深入</strong>：会尝试将参数转换为数字。非数字字符串会返回 <code>NaN</code>。<code>null</code> 转为 <code>0</code>，<code>undefined</code> 转为 <code>NaN</code>。</li></ul></li><li><p><strong>转换为 boolean</strong>：<code>Boolean(value)</code></p><ul><li><strong>深入</strong>：所有能被转换为 <code>false</code> 的值被称为<strong>假值（Falsy Value）</strong>。</li><li><strong>假值列表</strong>：<code>0</code>, <code>-0</code>, <code>null</code>, <code>false</code>, <code>NaN</code>, <code>undefined</code>, <code>&#39;&#39;</code> (空字符串)。</li><li><strong>真值（Truthy Value）</strong>：除上述假值外，所有值都是真值，包括空数组 <code>[]</code> 和空对象 <code>&#123;&#125;</code>。</li></ul></li><li><p><strong>转换为 string</strong>：<code>String(value)</code> 或 <code>value + &#39;&#39;</code></p><ul><li><strong>深入</strong>：<code>value + &#39;&#39;</code> 是最常用的技巧，利用了 JS 的隐式类型转换。</li></ul></li><li><p><strong>parseInt 和 parseFloat</strong>：</p><ul><li><p><strong>深入</strong>：这两个函数专门用于从<strong>字符串开头</strong>解析出数字。</p></li><li><p><code>parseInt</code>：解析<strong>整数</strong>。遇到第一个非数字字符就停止解析。</p><p>JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&quot;100px&quot;); // 100</span><br><span class="line">parseInt(&quot;a100&quot;);  // NaN</span><br></pre></td></tr></table></figure></li><li><p><code>parseFloat</code>：解析<strong>浮点数</strong>。遇到第一个非数字字符（除了小数点）就停止解析。</p></li></ul></li></ul><h4 id="二、JavaScript-中的弹出框"><a href="#二、JavaScript-中的弹出框" class="headerlink" title="二、JavaScript 中的弹出框"></a>二、JavaScript 中的弹出框</h4><p>这些是浏览器提供的 BOM API。</p><ul><li><code>alert(message)</code>：<strong>警告框</strong>。阻塞式，显示一条消息，不返回任何值。</li><li><code>prompt(message, default_value)</code>：<strong>询问框</strong>。返回用户输入的字符串，如果点击“取消”则返回 <code>null</code>。</li><li><code>confirm(message)</code>：<strong>确认框</strong>。返回一个布尔值，用户点击“确定”返回 <code>true</code>，点击“取消”返回 <code>false</code>。</li></ul><h4 id="三、条件运算符：-和"><a href="#三、条件运算符：-和" class="headerlink" title="三、条件运算符：== 和 ==="></a>三、条件运算符：<code>==</code> 和 <code>===</code></h4><ul><li><p><strong>&#x3D;&#x3D;（宽松相等）</strong>：只比较<strong>值</strong>，不比较类型。它在比较前会进行<strong>隐式类型转换</strong>。</p><p>JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 == &quot;5&quot;;     // true</span><br><span class="line">null == undefined; // true</span><br></pre></td></tr></table></figure></li><li><p><strong>&#x3D;&#x3D;&#x3D;（严格相等）</strong>：既比较<strong>值</strong>，也比较<strong>类型</strong>。不会进行类型转换。</p><p>JavaScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 === &quot;5&quot;;    // false</span><br><span class="line">null === undefined; // false</span><br></pre></td></tr></table></figure></li><li><p><strong>面试建议</strong>：在实际开发中，<strong>强烈建议使用 &#x3D;&#x3D;&#x3D;</strong>，以避免不必要的类型转换带来的 bug。</p></li></ul><h4 id="四、字符串和数组"><a href="#四、字符串和数组" class="headerlink" title="四、字符串和数组"></a>四、字符串和数组</h4><ul><li><strong>字符串</strong>：<ul><li><strong>深入</strong>：<code>string</code> 是一个<strong>对象</strong>，拥有 <code>length</code> 属性和许多方法（如 <code>split()</code>, <code>slice()</code>, <code>indexOf()</code> 等），但它<strong>不可变</strong>。</li></ul></li><li><strong>数组</strong>：<ul><li><strong>特点</strong>：<ol><li><strong>动态长度</strong>：JS 数组的长度是可变的，你可以随时添加或删除元素。</li><li><strong>异构性</strong>：一个数组可以存放不同数据类型的元素，如 <code>[1, &quot;hello&quot;, true]</code>。</li></ol></li><li><strong>方法</strong>：<ul><li><code>push()</code>, <code>pop()</code>：在数组<strong>末尾</strong>添加和删除。</li><li><code>unshift()</code>, <code>shift()</code>：在数组<strong>开头</strong>添加和删除。</li><li><code>splice()</code>：功能强大的方法，用于删除、替换或添加元素。</li><li><code>forEach()</code>, <code>map()</code>, <code>filter()</code>：常用的遍历方法。</li></ul></li></ul></li></ul><h4 id="五、函数和对象"><a href="#五、函数和对象" class="headerlink" title="五、函数和对象"></a>五、函数和对象</h4><ul><li><strong>函数</strong>：<ul><li><strong>深入</strong>：在 JS 中，函数是<strong>一等公民（First-Class Citizens）</strong>。这意味着函数可以作为参数传递、作为返回值，也可以赋值给变量。</li></ul></li><li><strong>对象</strong>：<ul><li><strong>深入</strong>：JS 对象是<strong>键值对</strong>的集合。键是字符串，值可以是任意类型。</li><li><strong>访问属性</strong>：<ul><li>点语法：<code>obj.prop</code>。</li><li>中括号语法：<code>obj[&#39;prop&#39;]</code>。后者适用于键名包含特殊字符或动态键名的情况。</li></ul></li></ul></li></ul><h4 id="六、定时器"><a href="#六、定时器" class="headerlink" title="六、定时器"></a>六、定时器</h4><ul><li><strong>setTimeout(callback, delay)</strong>：<ul><li><strong>用途</strong>：只执行<strong>一次</strong>。</li><li><strong>深入</strong>：<code>delay</code> 参数是<strong>最小延迟时间</strong>。由于 JS 是单线程的，如果主线程被阻塞，<code>callback</code> 的执行会延迟。</li></ul></li><li><strong>setInterval(callback, delay)</strong>：<ul><li><strong>用途</strong>：<strong>重复</strong>执行。</li><li><strong>深入</strong>：每次执行完回调函数后，<code>setInterval</code> 都会将下一个回调任务放入队列。</li></ul></li></ul><h4 id="七、ES6-新特性（重要）"><a href="#七、ES6-新特性（重要）" class="headerlink" title="七、ES6 新特性（重要）"></a>七、ES6 新特性（重要）</h4><ul><li><strong>let 和 const</strong>：<ul><li><strong>var 的问题</strong>：全局作用域，可以被重复声明，有变量提升。</li><li><strong>let</strong>：<strong>块级作用域</strong>（<code>&#123;&#125;</code> 内），不能重复声明，没有变量提升。</li><li><strong>const</strong>：<strong>块级作用域</strong>，用于声明<strong>常量</strong>。一旦声明，其引用地址不能改变。</li></ul></li><li><strong>字符串模板字面量</strong>：使用反引号（<code>     </code>）创建多行字符串和嵌入变量。</li><li><strong>箭头函数</strong>：<ul><li><strong>语法</strong>：<code>const func = (param) =&gt; &#123; ... &#125;</code>。</li><li><strong>this 指向</strong>：箭头函数<strong>没有自己的 this</strong>，它会捕获其所在上下文的 <code>this</code> 值。这解决了传统函数中 <code>this</code> 绑定复杂的问题。</li></ul></li><li><strong>可变参数</strong>：<code>...args</code>，用于函数接收不确定数量的参数。</li></ul><h4 id="八、DOM"><a href="#八、DOM" class="headerlink" title="八、DOM"></a>八、DOM</h4><ul><li><strong>什么是 DOM</strong>：<ul><li><strong>深入</strong>：DOM 是浏览器将 HTML 文档解析后生成的<strong>树形结构</strong>，是 JavaScript 操作网页的接口。HTML 文件是文本，DOM 是一个对象，可以被 JS 编程控制。</li></ul></li><li><strong>DOM 操作</strong>：<ul><li><strong>获取标签对象</strong>：<ul><li><code>document.getElementById()</code></li><li><code>document.getElementsByClassName()</code></li><li><code>document.querySelector()</code> (更常用)</li></ul></li><li><strong>操作属性</strong>：<ul><li><code>element.attribute = &#39;...&#39;</code> (例如 <code>element.style.color = &#39;red&#39;</code>)</li><li><code>element.setAttribute(&#39;attr&#39;, &#39;value&#39;)</code></li></ul></li><li><strong>操作内容</strong>：<ul><li><code>element.innerHTML</code>：获取或设置元素的 HTML 内容（包括子标签）。</li><li><code>element.textContent</code>：获取或设置元素的文本内容（不含 HTML）。</li></ul></li></ul></li></ul><hr><h2 id="Web补充"><a href="#Web补充" class="headerlink" title="Web补充"></a>Web补充</h2><h3 id="一、Web-架构与网络基础"><a href="#一、Web-架构与网络基础" class="headerlink" title="一、Web 架构与网络基础"></a>一、Web 架构与网络基础</h3><h4 id="1-常见的软件架构"><a href="#1-常见的软件架构" class="headerlink" title="1. 常见的软件架构"></a>1. 常见的软件架构</h4><ul><li><strong>B&#x2F;S 架构 (Browser&#x2F;Server)</strong>：<ul><li><strong>概念</strong>：浏览器和服务器架构。客户端只需安装一个通用的浏览器，业务逻辑和数据都存储在服务器端。</li><li><strong>优点</strong>：易于维护和升级，跨平台性好。</li><li><strong>缺点</strong>：对网络依赖性强，用户体验可能不如 C&#x2F;S 架构。</li></ul></li><li><strong>C&#x2F;S 架构 (Client&#x2F;Server)</strong>：<ul><li><strong>概念</strong>：客户端和服务器架构。客户端需要安装专用的应用程序，例如桌面 QQ、微信等。</li><li><strong>优点</strong>：用户体验好，响应速度快，可以离线使用。</li><li><strong>缺点</strong>：维护和升级复杂，需要为不同平台开发不同版本。</li></ul></li></ul><h4 id="2-网络编程三要素"><a href="#2-网络编程三要素" class="headerlink" title="2. 网络编程三要素"></a>2. 网络编程三要素</h4><p>这是所有网络通信的基础，理解这三点至关重要。</p><ul><li><strong>IP 地址</strong>：设备在网络上的唯一标识，类似于你的家庭住址。它用于在网络中定位到一台具体的计算机。</li><li><strong>端口号</strong>：应用程序在计算机上的唯一标识，类似于你家里的电话号码或门牌号。一台计算机上可以运行多个应用程序，端口号用于区分它们。</li><li><strong>协议</strong>：通信规则。就像人与人交流需要遵循共同的语言一样，网络设备之间通信也需要遵循特定的协议，如 HTTP、FTP、TCP 等。</li></ul><h4 id="3-资源的分类"><a href="#3-资源的分类" class="headerlink" title="3. 资源的分类"></a>3. 资源的分类</h4><ul><li><strong>静态资源</strong>：<ul><li><strong>特点</strong>：内容固定，无需服务器端处理，可由浏览器直接解析。</li><li><strong>原理</strong>：当浏览器请求静态资源时，Web 服务器直接从文件系统中读取文件并返回。</li><li><strong>示例</strong>：HTML、CSS、JS、图片等。</li></ul></li><li><strong>动态资源</strong>：<ul><li><strong>特点</strong>：内容动态生成，需要服务器端处理后才能返回给浏览器。</li><li><strong>原理</strong>：当浏览器请求动态资源时，Web 服务器将请求交给<strong>后台程序</strong>（如 Servlet 容器），后台程序执行业务逻辑，生成静态内容（如 HTML、JSON 等），然后返回给服务器，服务器再返回给浏览器。</li><li><strong>示例</strong>：Servlet、JSP、PHP、ASP 等。</li></ul></li></ul><h3 id="二、Web-服务器"><a href="#二、Web-服务器" class="headerlink" title="二、Web 服务器"></a>二、Web 服务器</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>Web 服务器（也称为 <strong>Web 容器</strong>）是一个软件，它负责处理 HTTP 请求，并提供静态资源和动态资源。它为动态资源（如 Servlet）提供了一个运行环境。</p><h4 id="2-常见的-Web-服务器"><a href="#2-常见的-Web-服务器" class="headerlink" title="2. 常见的 Web 服务器"></a>2. 常见的 Web 服务器</h4><ul><li><strong>Tomcat</strong>：Apache 基金组织开发，<strong>中小型的 JavaEE 服务器</strong>，<strong>免费</strong>且开源。它是一个<strong>Servlet 容器</strong>，能够运行 Servlet 和 JSP。</li><li><strong>WebSphere</strong>：IBM 公司开发，<strong>大型的 JavaEE 服务器</strong>，<strong>收费</strong>。功能强大，支持完整的 JavaEE 规范。</li><li><strong>WebLogic</strong>：Oracle 公司开发，<strong>大型的 JavaEE 服务器</strong>，<strong>收费</strong>。</li><li><strong>JBoss&#x2F;WildFly</strong>：开源，但其商业版收费。</li></ul><h3 id="三、Tomcat-的使用与配置"><a href="#三、Tomcat-的使用与配置" class="headerlink" title="三、Tomcat 的使用与配置"></a>三、Tomcat 的使用与配置</h3><ul><li><strong>安装与启动</strong>：Tomcat 是免安装的，解压即可。启动前需要配置 <code>JAVA_HOME</code> 环境变量。启动后，默认监听 <code>8080</code> 端口。</li><li><strong>端口号修改</strong>：<ul><li><strong>面试题</strong>：修改 Tomcat 端口号在哪个文件？</li><li><strong>回答</strong>：在 Tomcat 的 <code>conf</code> 目录下的 <code>server.xml</code> 文件中，修改 <code>&lt;Connector&gt;</code> 标签的 <code>port</code> 属性。</li><li><strong>注意</strong>：HTTP 协议的默认端口号是 <code>80</code>。如果将 Tomcat 端口号改为 <code>80</code>，那么访问时就可以省略端口号，例如 <code>http://localhost/</code>。</li></ul></li><li><strong>项目部署</strong>：<ul><li><strong>静态项目</strong>：将 HTML、CSS、JS 等文件直接放到 <code>webapps</code> 目录下的文件夹中。</li><li><strong>动态项目</strong>：将包含 <code>WEB-INF</code> 文件夹的整个项目目录放到 <code>webapps</code> 目录下。</li><li><strong>WEB-INF</strong>：这是动态项目的核心目录，具有特殊作用，外部无法直接通过 URL 访问该目录下的资源，保证了项目的安全性。<ul><li><code>classes</code>：存放所有编译后的 <code>.class</code> 字节码文件。</li><li><code>lib</code>：存放项目依赖的第三方 <code>.jar</code> 包。</li><li><code>web.xml</code>：Web 项目的<strong>核心配置文件</strong>，用于配置 Servlet、监听器、过滤器等。</li></ul></li></ul></li></ul><h3 id="四、Servlet-深入解析"><a href="#四、Servlet-深入解析" class="headerlink" title="四、Servlet 深入解析"></a>四、Servlet 深入解析</h3><h4 id="1-Servlet-的概念和本质"><a href="#1-Servlet-的概念和本质" class="headerlink" title="1. Servlet 的概念和本质"></a>1. Servlet 的概念和本质</h4><ul><li><strong>概念</strong>：Servlet 是运行在服务器端的 Java 程序，用于处理客户端请求并生成动态响应。它不是一个独立的程序，<strong>必须部署到支持 Servlet 的容器中</strong>（如 Tomcat）才能运行。</li><li><strong>本质</strong>：Servlet 的本质是一个<strong>接口</strong>。所有自定义的 Servlet 类都必须<strong>实现 javax.servlet.Servlet 接口</strong>。</li></ul><h4 id="2-Servlet-的执行原理（详细解释）"><a href="#2-Servlet-的执行原理（详细解释）" class="headerlink" title="2. Servlet 的执行原理（详细解释）"></a>2. Servlet 的执行原理（详细解释）</h4><p>这是一个非常重要的面试点，需要从请求-响应的整个流程来详细阐述。</p><ol><li><strong>客户端请求</strong>：用户在浏览器中输入 URL，向服务器发送一个 HTTP 请求。</li><li><strong>Web 服务器接收请求</strong>：Web 服务器（Tomcat）接收到这个请求。</li><li><strong>Servlet 容器处理</strong>：Tomcat 会根据请求 URL，在 <code>web.xml</code> 或通过注解（如 <code>@WebServlet</code>）查找匹配的 Servlet。</li><li><strong>Servlet 实例创建</strong>：<ul><li>如果是<strong>第一次</strong>访问该 Servlet，Servlet 容器会创建一个该 Servlet 的实例。</li><li><strong>面试点</strong>：Servlet 是<strong>单例的</strong>，一个 Servlet 在容器中只会被创建一次。</li></ul></li><li><strong>init() 方法执行</strong>：<ul><li>在 Servlet 实例创建后，容器会立即调用它的 <code>init()</code> 方法。</li><li><code>init()</code> 方法只在 Servlet 的<strong>生命周期中执行一次</strong>，用于完成一些初始化工作，如加载配置文件、数据库连接等。</li></ul></li><li><strong>service() 方法执行</strong>：<ul><li>每次客户端请求该 Servlet 时，容器都会调用它的 <code>service()</code> 方法。</li><li><code>service()</code> 方法根据请求的 HTTP 方法（GET、POST 等），将请求分发给相应的 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li><li><strong>面试点</strong>：<code>service()</code> 方法是处理请求的核心方法，它是<strong>多线程的</strong>，每个请求都会在新线程中执行 <code>service()</code> 方法。</li></ul></li><li><strong>destroy() 方法执行</strong>：<ul><li>当 Servlet 容器关闭，或者决定卸载该 Servlet 时，会调用其 <code>destroy()</code> 方法。</li><li><code>destroy()</code> 方法也只执行一次，用于释放资源，如关闭数据库连接池。</li></ul></li></ol><p><strong>总结</strong>：Servlet 的生命周期是：<strong>创建实例</strong> -&gt; <strong>调用 init()</strong> (只一次) -&gt; <strong>调用 service()</strong> (多次) -&gt; <strong>调用 destroy()</strong> (只一次) -&gt; <strong>销毁实例</strong>。</p><hr><h3 id="一、网络编程三要素："><a href="#一、网络编程三要素：" class="headerlink" title="一、网络编程三要素："></a>一、网络编程三要素：</h3><p>网络编程的本质就是让不同的计算机上的应用程序能够进行通信。要实现这一点，必须解决三个核心问题：</p><ol><li><strong>找到对方计算机</strong>：IP 地址</li><li><strong>找到对方计算机上的应用程序</strong>：端口号</li><li><strong>以什么样的规则进行通信</strong>：协议</li></ol><p>这三者缺一不可。</p><h4 id="1-IP-地址-Internet-Protocol-Address"><a href="#1-IP-地址-Internet-Protocol-Address" class="headerlink" title="1. IP 地址 (Internet Protocol Address)"></a>1. IP 地址 (Internet Protocol Address)</h4><ul><li><strong>概念</strong>：IP 地址是分配给连接到网络中的设备（如计算机、手机、服务器）的一串数字标识。</li><li><strong>作用</strong>：它用于<strong>唯一地标识网络上的一个设备</strong>。数据包在网络中传输时，就是根据 IP 地址来路由和寻址的。</li><li><strong>版本</strong>：<ul><li><strong>IPv4</strong>：由 32 位二进制数组成，通常表示为四个十进制数，用点分隔（例如 <code>192.168.1.1</code>）。由于地址资源枯竭，现在已经不够用。</li><li><strong>IPv6</strong>：由 128 位二进制数组成，地址空间巨大，足以满足未来需求。</li></ul></li><li><strong>类型</strong>：<ul><li><strong>公网 IP</strong>：在互联网上是唯一的，可以直接访问。</li><li><strong>内网 IP</strong>：在局域网内是唯一的，不能直接在互联网上访问。例如 <code>192.168.x.x</code>、<code>10.x.x.x</code>。</li></ul></li></ul><h4 id="2-端口号-Port-Number"><a href="#2-端口号-Port-Number" class="headerlink" title="2. 端口号 (Port Number)"></a>2. 端口号 (Port Number)</h4><ul><li><strong>概念</strong>：端口号是用于<strong>区分一台计算机上不同应用程序</strong>的数字标识。它的范围是从 <code>0</code> 到 <code>65535</code>。</li><li><strong>作用</strong>：当一个数据包到达一台计算机时，操作系统会检查其目的端口号，然后将数据包交给监听该端口号的相应应用程序。</li><li><strong>与 IP 地址的关系</strong>：IP 地址解决了“数据包发送到哪台计算机”的问题，而端口号则解决了“数据包发送到这台计算机上的哪个应用程序”的问题。两者结合起来才能唯一确定一个网络连接的端点。</li></ul><h4 id="3-协议-Protocol"><a href="#3-协议-Protocol" class="headerlink" title="3. 协议 (Protocol)"></a>3. 协议 (Protocol)</h4><ul><li><strong>概念</strong>：协议是网络通信中<strong>数据传输的规则和约定</strong>。它定义了数据如何打包、传输、路由和接收。</li><li><strong>作用</strong>：确保通信双方能够理解彼此发送的数据。没有协议，数据包就是一堆无意义的字节。</li><li><strong>分层</strong>：网络协议通常是分层的，最经典的是 <strong>TCP&#x2F;IP 协议栈</strong>。<ul><li><strong>应用层</strong>：<strong>决定数据内容</strong>，如 HTTP、FTP、SMTP。</li><li><strong>传输层</strong>：<strong>决定数据如何传输</strong>，如 TCP 和 UDP。<ul><li><strong>TCP (Transmission Control Protocol)</strong>：面向连接、可靠、有序。适用于对数据完整性要求高的场景，如文件传输、网页浏览。</li><li><strong>UDP (User Datagram Protocol)</strong>：无连接、不可靠、速度快。适用于对实时性要求高的场景，如在线视频、游戏。</li></ul></li><li><strong>网络层</strong>：<strong>决定数据如何路由</strong>，如 IP 协议。</li><li><strong>数据链路层&#x2F;物理层</strong>：负责物理设备的通信。</li></ul></li></ul><hr><h3 id="二、常见应用的默认端口号"><a href="#二、常见应用的默认端口号" class="headerlink" title="二、常见应用的默认端口号"></a>二、常见应用的默认端口号</h3><p>了解这些默认端口号，可以帮助你更好地理解网络协议和服务。</p><ul><li><strong>Web 服务</strong><ul><li><strong>HTTP</strong> (HyperText Transfer Protocol)：<strong>80</strong></li><li><strong>HTTPS</strong> (HTTP Secure)：<strong>443</strong></li><li><strong>Tomcat</strong> (默认)：<strong>8080</strong></li><li><strong>WebLogic</strong> (默认)：<strong>7001</strong></li></ul></li><li><strong>文件传输</strong><ul><li><strong>FTP</strong> (File Transfer Protocol)：<strong>21</strong> (控制连接)</li><li><strong>SFTP</strong> (SSH File Transfer Protocol)：<strong>22</strong></li></ul></li><li><strong>远程登录与管理</strong><ul><li><strong>SSH</strong> (Secure Shell)：<strong>22</strong></li><li><strong>Telnet</strong>：<strong>23</strong></li><li><strong>RDP</strong> (Remote Desktop Protocol)：<strong>3389</strong></li></ul></li><li><strong>数据库服务</strong><ul><li><strong>MySQL</strong>：<strong>3306</strong></li><li><strong>PostgreSQL</strong>：<strong>5432</strong></li><li><strong>SQL Server</strong>：<strong>1433</strong></li><li><strong>Oracle</strong>：<strong>1521</strong></li></ul></li><li><strong>邮件服务</strong><ul><li><strong>SMTP</strong> (Simple Mail Transfer Protocol)：<strong>25</strong> (发送邮件)</li><li><strong>POP3</strong> (Post Office Protocol 3)：<strong>110</strong> (接收邮件)</li><li><strong>IMAP</strong> (Internet Message Access Protocol)：<strong>143</strong> (接收邮件)</li></ul></li><li><strong>其他常见服务</strong><ul><li><strong>DNS</strong> (Domain Name System)：<strong>53</strong></li><li><strong>Redis</strong>：<strong>6379</strong></li><li><strong>MongoDB</strong>：<strong>27017</strong></li><li><strong>Kafka</strong>：<strong>9092</strong></li></ul></li></ul><p>为什么需要默认端口号？</p><p>为了方便用户。当你在浏览器中访问 <a href="http://www.example.com/">www.example.com</a> 时，你不需要手动输入 <a href="http://www.example.com:80，因为浏览器知道">www.example.com:80，因为浏览器知道</a> HTTP 协议的默认端口就是 80。如果服务器的端口不是默认端口，你就必须手动指定，比如 <a href="http://www.example.com:8080。">www.example.com:8080。</a></p><hr><h3 id="一、Servlet-剩余部分"><a href="#一、Servlet-剩余部分" class="headerlink" title="一、Servlet 剩余部分"></a>一、Servlet 剩余部分</h3><h4 id="1-Servlet-的生命周期方法"><a href="#1-Servlet-的生命周期方法" class="headerlink" title="1. Servlet 的生命周期方法"></a>1. Servlet 的生命周期方法</h4><p>这是理解 Servlet 工作原理的核心。</p><ul><li><strong>init() 方法</strong>：<ul><li><strong>特点</strong>：只执行<strong>一次</strong>，用于初始化 Servlet 实例。</li><li><strong>执行时机</strong>：<ul><li><strong>默认（懒加载）</strong>：第一次被访问时执行。这是一种“按需加载”的策略，节省了服务器启动时的资源。</li><li><strong>预加载</strong>：可以在 <code>web.xml</code> 中通过 <code>&lt;load-on-startup&gt;</code> 标签来设置。如果值为非负整数（<code>0</code>或正数），Servlet 容器将在服务器启动时立即创建并初始化该 Servlet。这适用于需要立即提供服务、启动耗时较长的 Servlet。</li></ul></li></ul></li><li><strong>service() 方法</strong>：<ul><li><strong>特点</strong>：每次客户端请求该 Servlet 时，都会执行一次。</li><li><strong>原理</strong>：它是 Servlet 接口的核心方法，用于处理请求。对于 <code>HttpServlet</code> 来说，它会根据 HTTP 请求方法（GET、POST 等）来分发请求给相应的 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li><li><strong>重要性</strong>：<strong>service() 方法是多线程的</strong>。Servlet 容器会为每个请求创建一个新线程来执行 <code>service()</code> 方法，确保并发访问时互不影响。</li></ul></li><li><strong>destroy() 方法</strong>：<ul><li><strong>特点</strong>：只执行<strong>一次</strong>，在 Servlet 实例正常销毁时调用。</li><li><strong>执行时机</strong>：通常在 Web 应用关闭或 Servlet 容器关闭时。用于释放资源，如关闭数据库连接、文件句柄等。</li></ul></li></ul><h4 id="2-Servlet-的实现方式：XML-vs-注解"><a href="#2-Servlet-的实现方式：XML-vs-注解" class="headerlink" title="2. Servlet 的实现方式：XML vs. 注解"></a>2. Servlet 的实现方式：XML vs. 注解</h4><ul><li><p><strong>XML 配置方式</strong>：在 <code>web.xml</code> 文件中，通过 <code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code> 标签来配置 Servlet 的名称、类和访问路径。这是 Servlet 2.x 及以前版本的主流方式。</p></li><li><p><strong>注解方式</strong>：自 Servlet 3.0 开始引入，可以使用 <code>@WebServlet</code> 注解来代替 XML 配置。</p><ul><li><strong>优点</strong>：简化了配置，代码和配置更集中，提高了开发效率。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Servlet-的体系结构"><a href="#3-Servlet-的体系结构" class="headerlink" title="3. Servlet 的体系结构"></a>3. Servlet 的体系结构</h4><ul><li><code>Servlet</code> <strong>接口</strong>：所有 Servlet 的顶层接口，定义了 <code>init()</code>, <code>service()</code>, <code>destroy()</code> 等核心方法。</li><li><code>GenericServlet</code> <strong>抽象类</strong>：实现了 <code>Servlet</code> 接口，并提供了 <code>init()</code>, <code>destroy()</code> 的空实现，以及一些通用方法。开发者可以继承它来编写协议无关的 Servlet。</li><li><code>HttpServlet</code> <strong>抽象类</strong>：继承自 <code>GenericServlet</code>，专门用于处理 <strong>HTTP 请求</strong>。它重写了 <code>service()</code> 方法，并根据请求方法分发给 <code>doGet()</code>, <code>doPost()</code> 等具体方法。</li><li><strong>总结</strong>：在 Web 项目中，我们几乎总是处理 HTTP 请求，因此<strong>继承 HttpServlet 是最常用、最推荐的方式</strong>。</li></ul><hr><h3 id="二、HTTP-协议"><a href="#二、HTTP-协议" class="headerlink" title="二、HTTP 协议"></a>二、HTTP 协议</h3><h4 id="1-概念与特点"><a href="#1-概念与特点" class="headerlink" title="1. 概念与特点"></a>1. 概念与特点</h4><ul><li><strong>概念</strong>：<strong>超文本传输协议</strong>，是 Web 应用层协议，基于 TCP&#x2F;IP。它规定了客户端和服务器之间的通信格式。</li><li><strong>特点</strong>：<ul><li><strong>基于 TCP&#x2F;IP</strong>：它位于 TCP&#x2F;IP 协议栈的应用层，利用了 TCP 的可靠传输特性。</li><li><strong>请求&#x2F;响应模型</strong>：客户端发送请求，服务器返回响应，一次请求只对应一次响应。</li><li><strong>无状态</strong>：这是 HTTP 的核心特征。服务器不保留任何关于客户端过去请求的信息。每个请求都是独立的。</li><li><strong>无状态带来的问题</strong>：服务器无法识别多个请求是否来自同一个用户，因此需要引入<strong>会话技术</strong>（如 Cookie 和 Session）来解决。</li></ul></li></ul><h4 id="2-HTTP-协议的数据格式"><a href="#2-HTTP-协议的数据格式" class="headerlink" title="2. HTTP 协议的数据格式"></a>2. HTTP 协议的数据格式</h4><p>HTTP 协议是文本格式，由<strong>请求格式</strong>和<strong>响应格式</strong>两部分组成。</p><ul><li><strong>请求格式</strong>：<ol><li><strong>请求行</strong>：<code>请求方式 虚拟路径/资源路径[?参数] 请求协议/版本</code>。</li><li><strong>请求头</strong>：键值对形式，提供额外信息。<ul><li><code>Host</code>：目标主机名。</li><li><code>User-Agent</code>：浏览器类型和版本。</li><li><code>Referer</code>：请求来源地址，常用于防盗链。</li></ul></li><li><strong>请求空行</strong>：一个空行，用于分隔请求头和请求体。</li><li><strong>请求体</strong>：<strong>只有 POST 请求才有</strong>，用于封装请求参数。</li></ol></li></ul><h4 id="3-ServletRequest-对象"><a href="#3-ServletRequest-对象" class="headerlink" title="3. ServletRequest 对象"></a>3. <code>ServletRequest</code> 对象</h4><p><code>ServletRequest</code> 是 Servlet 容器在接收到请求后，封装请求信息的对象。</p><ul><li><strong>获取请求行信息</strong>：<ul><li><code>getMethod()</code>：获取请求方式（GET&#x2F;POST）。</li><li><code>getContextPath()</code>：获取虚拟路径。</li><li><code>getRequestURI()</code>：获取 URI，如 <code>/web02/demo4</code>。</li><li><code>getRequestURL()</code>：获取 URL，如 <code>http://localhost:8080/web02/demo4</code>。</li></ul></li><li><strong>获取请求头信息</strong>：<ul><li><code>getHeader(name)</code>：根据请求头名获取值。</li><li><code>getHeaderNames()</code>：获取所有请求头名。</li></ul></li><li><strong>获取请求体信息</strong>：<ul><li><code>getReader()</code> (字符流) 和 <code>getInputStream()</code> (字节流)，用于读取 POST 请求的请求体内容。</li></ul></li><li><strong>获取请求参数（通用）</strong>：<ul><li><code>getParameter(name)</code>：获取单个参数值。</li><li><code>getParameterValues(name)</code>：获取参数值数组，用于复选框等。</li></ul></li><li><strong>中文乱码</strong>：<ul><li><strong>GET 请求</strong>：在 Tomcat 8.x 及以后版本，默认已解决。</li><li><strong>POST 请求</strong>：需要手动设置编码，<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code>。</li></ul></li></ul><h4 id="4-request-请求转发"><a href="#4-request-请求转发" class="headerlink" title="4. request 请求转发"></a>4. <code>request</code> 请求转发</h4><ul><li><strong>概念</strong>：是一种<strong>服务器内部</strong>的资源跳转方式。请求从一个 Servlet 转发到另一个 Servlet 或 JSP，<strong>浏览器地址栏不会发生改变</strong>。</li><li><strong>特点</strong>：<ol><li><strong>地址栏不变</strong>：用户不知道发生了跳转。</li><li><strong>一次请求&#x2F;响应</strong>：整个转发过程发生在一次 HTTP 请求和一次 HTTP 响应中。</li><li><strong>共享数据</strong>：由于是同一次请求，<code>request</code> 对象中的数据在转发前后是共享的。</li></ol></li></ul><h4 id="5-request-作为域对象"><a href="#5-request-作为域对象" class="headerlink" title="5. request 作为域对象"></a>5. <code>request</code> 作为域对象</h4><ul><li><strong>概念</strong>：<code>request</code> 是一种<strong>域对象</strong>，其作用范围是<strong>一次请求-响应的生命周期</strong>。</li><li><strong>共享数据</strong>：可以使用 <code>setAttribute()</code>, <code>getAttribute()</code>, <code>removeAttribute()</code> 方法在这次请求的生命周期内共享数据。</li><li><strong>应用场景</strong>：常用于在 Servlet 和 JSP 之间传递数据。</li><li><strong>与会话技术的联系</strong>：<code>request</code> 是三大域对象（<code>request</code>, <code>session</code>, <code>servletContext</code>）中作用范围最小的一个。</li></ul><hr><h3 id="一、HTTP-协议的响应格式"><a href="#一、HTTP-协议的响应格式" class="headerlink" title="一、HTTP 协议的响应格式"></a>一、HTTP 协议的响应格式</h3><h4 id="1-响应格式组成"><a href="#1-响应格式组成" class="headerlink" title="1. 响应格式组成"></a>1. 响应格式组成</h4><p>HTTP 响应格式由四部分组成：<code>响应行</code>、<code>响应头</code>、<code>响应空行</code>、<code>响应体</code>。这与 HTTP 请求格式相呼应。</p><h4 id="2-响应行"><a href="#2-响应行" class="headerlink" title="2. 响应行"></a>2. 响应行</h4><ul><li><strong>格式</strong>：<code>协议/版本号 状态码 状态描述</code>。例如：<code>HTTP/1.1 200 OK</code>。</li><li><strong>状态码</strong>：一个三位数的数字，服务器用于告诉浏览器本次响应的状态。<ul><li><strong>2xx 成功</strong>：<ul><li><strong>200 OK</strong>：请求成功，一切正常。</li></ul></li><li><strong>3xx 重定向</strong>：<ul><li><strong>302 Found</strong>：重定向。服务器告诉浏览器，资源临时移动到另一个位置，请重新发起请求。</li><li><strong>304 Not Modified</strong>：访问缓存。服务器告诉浏览器，请求的资源没有更新，可以使用浏览器本地的缓存副本。</li></ul></li><li><strong>4xx 客户端错误</strong>：<ul><li><strong>404 Not Found</strong>：找不到资源。请求的路径没有对应的资源。</li><li><strong>405 Method Not Allowed</strong>：请求方法不被允许。例如，客户端用 POST 请求访问了只支持 GET 方法的 Servlet。</li></ul></li><li><strong>5xx 服务器端错误</strong>：<ul><li><strong>500 Internal Server Error</strong>：服务器内部错误。通常是服务器端的代码出现了异常。</li></ul></li></ul></li><li><strong>面试题</strong>：列举 5 个常见的状态码：200、302、304、404、405、500。</li></ul><h4 id="3-响应头"><a href="#3-响应头" class="headerlink" title="3. 响应头"></a>3. 响应头</h4><ul><li><strong>作用</strong>：以键值对形式提供关于响应的额外信息。</li><li><strong>常见响应头</strong>：<ul><li><strong>Content-Type</strong>：告诉浏览器响应体的数据类型和字符编码，例如 <code>text/html;charset=utf-8</code>。</li><li><strong>Content-disposition</strong>：<ul><li><strong>inline</strong> (默认)：浏览器在当前页面内直接打开。</li><li><strong>attachment;filename&#x3D;xxx</strong>：浏览器将数据作为附件下载。</li></ul></li><li><strong>Location</strong>：与 <code>3xx</code> 状态码配合使用，用于告诉浏览器重定向到哪个 URL。</li></ul></li></ul><h3 id="二、ServletResponse-response"><a href="#二、ServletResponse-response" class="headerlink" title="二、ServletResponse (response)"></a>二、ServletResponse (response)</h3><ul><li><strong>简介</strong>：<code>ServletResponse</code> 对象由 Tomcat 创建，封装了服务器发送给客户端的响应消息。</li><li><strong>相关方法</strong>：<ul><li><strong>设置响应行</strong>：<code>setStatus(int sc)</code></li><li><strong>设置响应头</strong>：<code>setHeader(String name, String value)</code></li><li><strong>设置响应体</strong>：<ul><li><code>getWriter()</code>：获取字符输出流，用于发送<strong>文本</strong>数据。</li><li><code>getOutputStream()</code>：获取字节输出流，用于发送<strong>字节</strong>数据（如图片、视频）。</li></ul></li></ul></li></ul><h3 id="三、转发（Forward）和重定向（Redirect）的区别"><a href="#三、转发（Forward）和重定向（Redirect）的区别" class="headerlink" title="三、转发（Forward）和重定向（Redirect）的区别"></a>三、转发（Forward）和重定向（Redirect）的区别</h3><p>这是一个非常重要的面试题，需要从多个角度进行对比。</p><table><thead><tr><th>特性</th><th>转发（Forward）</th><th>重定向（Redirect）</th></tr></thead><tbody><tr><td><strong>发生方</strong></td><td>服务器内部</td><td>浏览器</td></tr><tr><td><strong>地址栏</strong></td><td><strong>不变</strong></td><td><strong>会改变</strong></td></tr><tr><td><strong>请求次数</strong></td><td><strong>一次</strong>请求，一次响应</td><td><strong>两次</strong>请求，两次响应</td></tr><tr><td><strong>共享数据</strong></td><td><code>request</code> 对象共享数据</td><td><code>request</code> 对象不共享数据</td></tr><tr><td><strong>跳转范围</strong></td><td><strong>只能</strong>在当前 Web 项目内部</td><td>可以跳出项目，访问外部资源</td></tr><tr><td><strong>调用方</strong></td><td><code>RequestDispatcher</code> (<code>request</code>)</td><td><code>ServletResponse</code> (<code>response</code>)</td></tr><tr><td><strong>底层实现</strong></td><td><code>request.getRequestDispatcher().forward()</code></td><td><code>response.sendRedirect()</code></td></tr></tbody></table><ul><li><strong>重定向的实现原理</strong>：<ol><li>服务器收到请求，执行 <code>response.sendRedirect()</code>，并发送 <code>302</code> 状态码和 <code>Location</code> 响应头（值为新的 URL）。</li><li>浏览器收到响应，解析到 <code>302</code> 和 <code>Location</code> 头后，会<strong>自动</strong>向新的 URL 发起<strong>第二次</strong>请求。</li></ol></li></ul><h3 id="四、ServletContext"><a href="#四、ServletContext" class="headerlink" title="四、ServletContext"></a>四、ServletContext</h3><h4 id="1-简介与特点"><a href="#1-简介与特点" class="headerlink" title="1. 简介与特点"></a>1. 简介与特点</h4><ul><li><strong>作用</strong>：代表<strong>整个 Web 应用</strong>。可以用来和服务器容器进行通信。</li><li><strong>特点</strong>：<ul><li><strong>单例</strong>：一个 Web 应用只有一个 <code>ServletContext</code> 对象。</li><li><strong>作用域</strong>：是<strong>最大的域对象</strong>，其作用范围是整个 Web 应用，从应用启动到关闭。</li></ul></li></ul><h4 id="2-获取-ServletContext-对象"><a href="#2-获取-ServletContext-对象" class="headerlink" title="2. 获取 ServletContext 对象"></a>2. 获取 <code>ServletContext</code> 对象</h4><ul><li><strong>通过 request</strong>：<code>request.getServletContext()</code></li><li><strong>通过 HttpServlet</strong>：<code>getServletContext()</code></li></ul><h4 id="3-ServletContext-的方法"><a href="#3-ServletContext-的方法" class="headerlink" title="3. ServletContext 的方法"></a>3. <code>ServletContext</code> 的方法</h4><ul><li><strong>获取文件 MIME 类型</strong>：<code>getMimeType(String file)</code>，返回文件的类型，如 <code>image/jpeg</code>。</li><li><strong>作为域对象</strong>：提供了 <code>setAttribute()</code>, <code>getAttribute()</code>, <code>removeAttribute()</code> 方法，用于在整个 Web 应用范围内共享数据。<ul><li><strong>示例</strong>：您提供的代码片段完美地展示了如何使用 <code>ServletContext</code> 来统计服务器的访问次数。这是 <code>ServletContext</code> 作为域对象最经典的用法。</li></ul></li><li><strong>获取文件真实路径</strong>：<code>getRealPath(String path)</code>，将相对路径转换为服务器上的绝对路径。</li></ul><h3 id="五、会话（Session）"><a href="#五、会话（Session）" class="headerlink" title="五、会话（Session）"></a>五、会话（Session）</h3><h4 id="1-概念与作用"><a href="#1-概念与作用" class="headerlink" title="1. 概念与作用"></a>1. 概念与作用</h4><ul><li><strong>概念</strong>：在 HTTP 协议的无状态特性基础上，通过会话技术将多次请求和响应联系起来，形成一个完整的会话。</li><li><strong>作用</strong>：在一次会话范围内的多次请求之间<strong>共享数据</strong>，从而识别用户。</li><li><strong>实现方式</strong>：<ul><li><strong>客户端会话（Cookie）</strong>：数据存储在客户端浏览器。</li><li><strong>服务器端会话（Session）</strong>：数据存储在服务器端。</li></ul></li></ul><h4 id="2-客户端会话：Cookie"><a href="#2-客户端会话：Cookie" class="headerlink" title="2. 客户端会话：Cookie"></a>2. 客户端会话：Cookie</h4><ul><li><strong>快速开始</strong>：<ol><li><strong>创建</strong>：<code>new Cookie(name, value)</code>。</li><li><strong>发送</strong>：<code>response.addCookie(cookie)</code>，将 Cookie 发送给浏览器。</li><li><strong>获取</strong>：<code>request.getCookies()</code>，从请求中获取所有 Cookie。</li></ol></li><li><strong>特点</strong>：数据存储在客户端，有大小限制，安全性低。</li></ul><hr><h3 id="一、enctype"><a href="#一、enctype" class="headerlink" title="一、enctype"></a>一、<code>enctype</code></h3><ul><li><strong>作用域</strong>：HTML <code>&lt;form&gt;</code> 标签的属性。</li><li><strong>角色</strong>：客户端<strong>表单的编码方式</strong>。</li><li><strong>概念</strong>：<code>enctype</code> (Encoding Type) 告诉<strong>浏览器</strong>如何将 <code>&lt;form&gt;</code> 表单中的数据<strong>编码</strong>成 HTTP 请求体中的数据。它只作用于<strong>表单提交</strong>这个行为。</li><li><strong>常见值</strong>：<ul><li><code>application/x-www-form-urlencoded</code>：默认值，用于文本数据。</li><li><code>multipart/form-data</code>：用于文件上传。</li><li><code>text/plain</code>：用于纯文本提交。</li></ul></li></ul><p><strong>简单来说，enctype 是“表单数据在浏览器端如何打包”的规则。</strong></p><h3 id="二、Content-Type"><a href="#二、Content-Type" class="headerlink" title="二、Content-Type"></a>二、<code>Content-Type</code></h3><ul><li><strong>作用域</strong>：HTTP 请求头或响应头。</li><li><strong>角色</strong>：<strong>通信数据的媒体类型</strong>。</li><li><strong>概念</strong>：<code>Content-Type</code> 告诉接收方（服务器或浏览器）请求体或响应体中的<strong>数据是什么格式</strong>。它是一个通用的 HTTP 头部，不仅限于表单提交。</li><li><strong>常见值</strong>：<ul><li><code>text/html</code>：HTML 文档。</li><li><code>application/json</code>：JSON 格式数据。</li><li><code>image/jpeg</code>：JPEG 图片。</li><li><code>application/xml</code>：XML 文档。</li><li><code>text/plain</code>：纯文本。</li></ul></li></ul><p><strong>简单来说，Content-Type 是“我发送给你的数据是什么类型”的声明。</strong></p><h3 id="三、核心区别与联系"><a href="#三、核心区别与联系" class="headerlink" title="三、核心区别与联系"></a>三、核心区别与联系</h3><table><thead><tr><th>特性</th><th><code>enctype</code></th><th><code>Content-Type</code></th></tr></thead><tbody><tr><td><strong>位置</strong></td><td>HTML <code>&lt;form&gt;</code> 标签的属性</td><td>HTTP 请求头或响应头</td></tr><tr><td><strong>谁定义</strong></td><td>开发者在 HTML 中设置</td><td>发送方（浏览器或服务器）在 HTTP 头部中设置</td></tr><tr><td><strong>作用</strong></td><td>告诉<strong>浏览器</strong>如何<strong>打包</strong>表单数据</td><td>告诉<strong>接收方</strong>如何<strong>解析</strong>数据</td></tr><tr><td><strong>关系</strong></td><td><strong>enctype 的值决定了 HTTP 请求头中 Content-Type 的值。</strong></td><td><code>Content-Type</code> 是 HTTP 协议的一部分，<code>enctype</code> 是 HTML 的一部分。</td></tr></tbody></table><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假设你有一个包含用户名和头像上传的表单：</p><p>HTML</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/profile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;avatar&quot;&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>当用户点击提交时，浏览器会做两件事：</p><ol><li><p><strong>根据 enctype&#x3D;”multipart&#x2F;form-data” 规则</strong>，浏览器会生成一个**多部分（<code>multipart</code>）**的请求体，包含用户名和头像文件的二进制数据。</p></li><li><p>在发送 HTTP 请求时，浏览器会在请求头中自动添加一个 <code>Content-Type</code> 字段，其值为<strong>与 enctype 匹配的</strong> <code>multipart/form-data</code>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/profile</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundary...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong>：</p><ul><li><strong>enctype 是一个前端概念</strong>，它是 HTML 表单的属性，用于指导浏览器如何构建请求体。</li><li><strong>Content-Type 是一个 HTTP 协议概念</strong>，它是 HTTP 头部的一个字段，用于告知数据格式。</li><li>两者之间存在<strong>联动关系</strong>：你在 HTML 中设置的 <code>enctype</code> 值，会<strong>最终影响</strong>浏览器在 HTTP 请求中设置的 <code>Content-Type</code> 头的值。</li></ul><hr><h3 id="一、enctype-的常见值"><a href="#一、enctype-的常见值" class="headerlink" title="一、enctype 的常见值"></a>一、<code>enctype</code> 的常见值</h3><p><code>enctype</code> 是 HTML <code>&lt;form&gt;</code> 标签的属性，用于定义表单数据提交的编码方式。</p><ol><li><strong>application&#x2F;x-www-form-urlencoded</strong><ul><li><strong>用途</strong>：这是 <code>enctype</code> 的<strong>默认值</strong>。它将表单数据编码为键值对字符串，其中所有特殊字符都会被 URL 编码（例如空格被 <code>%20</code> 替代）。</li><li><strong>适用场景</strong>：只包含文本数据的普通表单提交。</li></ul></li><li><strong>multipart&#x2F;form-data</strong><ul><li><strong>用途</strong>：将表单数据分割成多个部分，每个部分都有独立的 <code>Content-Type</code> 和 <code>Content-Disposition</code> 头部。这种格式能够<strong>同时处理文本和二进制数据</strong>。</li><li><strong>适用场景</strong>：<strong>文件上传</strong>。</li></ul></li><li><strong>text&#x2F;plain</strong><ul><li><strong>用途</strong>：将表单数据以纯文本格式发送，不进行任何编码。数据以键值对的形式，用换行符分隔。</li><li><strong>适用场景</strong>：不常用，主要用于调试目的。</li></ul></li></ol><h3 id="二、Content-Type-的常见值"><a href="#二、Content-Type-的常见值" class="headerlink" title="二、Content-Type 的常见值"></a>二、<code>Content-Type</code> 的常见值</h3><p><code>Content-Type</code> 是 HTTP 头部字段，用于指定消息体的媒体类型（MIME 类型）。</p><h4 id="1-文本类型-text"><a href="#1-文本类型-text" class="headerlink" title="1. 文本类型 (text/)"></a>1. 文本类型 (<code>text/</code>)</h4><ul><li><strong>text&#x2F;plain</strong>：纯文本。</li><li><strong>text&#x2F;html</strong>：HTML 文档。这是浏览器渲染网页的默认类型。</li><li><strong>text&#x2F;css</strong>：CSS 样式表。</li><li><strong>text&#x2F;javascript</strong>：JavaScript 代码。</li></ul><h4 id="2-应用类型-application"><a href="#2-应用类型-application" class="headerlink" title="2. 应用类型 (application/)"></a>2. 应用类型 (<code>application/</code>)</h4><ul><li><strong>application&#x2F;json</strong>：JSON 格式的数据。目前最常用的前后端数据交互格式。</li><li><strong>application&#x2F;xml</strong>：XML 格式的数据。</li><li><strong>application&#x2F;pdf</strong>：PDF 文档。</li><li><strong>application&#x2F;octet-stream</strong>：通用的<strong>二进制流数据</strong>。通常用于<strong>强制浏览器下载</strong>未知类型的文件，因为它告诉浏览器“这是一个原始的字节流，请不要尝试解析它”。</li><li><strong>application&#x2F;x-www-form-urlencoded</strong>：与 <code>enctype</code> 的默认值对应，表明请求体是 URL 编码的键值对。</li><li><strong>application&#x2F;javascript</strong>：与 <code>text/javascript</code> 类似，更推荐使用。</li></ul><h4 id="3-图片类型-image"><a href="#3-图片类型-image" class="headerlink" title="3. 图片类型 (image/)"></a>3. 图片类型 (<code>image/</code>)</h4><ul><li><strong>image&#x2F;jpeg</strong>：JPEG&#x2F;JPG 格式的图片。</li><li><strong>image&#x2F;png</strong>：PNG 格式的图片。</li><li><strong>image&#x2F;gif</strong>：GIF 格式的图片。</li><li><strong>image&#x2F;svg+xml</strong>：SVG 矢量图。</li></ul><h4 id="4-音视频类型"><a href="#4-音视频类型" class="headerlink" title="4. 音视频类型"></a>4. 音视频类型</h4><ul><li><strong>audio&#x2F;mpeg</strong>：MP3 音频文件。</li><li><strong>video&#x2F;mp4</strong>：MP4 视频文件。</li></ul><h4 id="5-多部分类型-multipart"><a href="#5-多部分类型-multipart" class="headerlink" title="5. 多部分类型 (multipart/)"></a>5. 多部分类型 (<code>multipart/</code>)</h4><ul><li><strong>multipart&#x2F;form-data</strong>：用于文件上传，与 <code>enctype</code> 的值对应。</li><li><strong>multipart&#x2F;byteranges</strong>：用于分块下载，支持断点续传。</li></ul><hr><h3 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h3><ul><li><strong>URI (Uniform Resource Identifier) - 统一资源标识符</strong><ul><li><strong>概念</strong>：URI 是一个用于<strong>标识</strong>互联网上<strong>任何资源</strong>的字符串。它不仅仅能标识网页，还可以标识文件、服务、电子邮箱等。</li><li><strong>作用</strong>：<strong>标识</strong>。URI 就像一个资源的“身份证号”，它能唯一地识别一个资源，但<strong>不一定</strong>告诉我们如何访问它。</li></ul></li><li><strong>URL (Uniform Resource Locator) - 统一资源定位符</strong><ul><li><strong>概念</strong>：URL 是一个用于<strong>定位</strong>互联网上资源的字符串。它是 URI 的一个<strong>子集</strong>。</li><li><strong>作用</strong>：<strong>定位</strong>。URL 就像一个资源的“详细地址”，它不仅标识了资源，还提供了<strong>如何访问该资源</strong>的完整信息，包括协议、主机名、端口号和路径等。</li></ul></li></ul><h3 id="二、URL-和-URI-的关系"><a href="#二、URL-和-URI-的关系" class="headerlink" title="二、URL 和 URI 的关系"></a>二、URL 和 URI 的关系</h3><p>用一个比喻来理解：</p><ul><li><strong>URI</strong> 就像一个人的<strong>名字</strong>。<code>张三</code>这个名字可以标识这个人，但你不知道他在哪里、怎么找到他。</li><li><strong>URL</strong> 就像一个人的<strong>家庭住址</strong>。<code>北京市海淀区中关村大街1号</code>。这个地址不仅标识了这个人，还告诉了你如何定位他。</li></ul><p><strong>因此，所有的 URL 都是 URI，但并非所有的 URI 都是 URL。</strong></p><h3 id="三、URL-和-URI-的具体结构"><a href="#三、URL-和-URI-的具体结构" class="headerlink" title="三、URL 和 URI 的具体结构"></a>三、URL 和 URI 的具体结构</h3><h4 id="URI-的结构："><a href="#URI-的结构：" class="headerlink" title="URI 的结构："></a>URI 的结构：</h4><p>一个 URI 通常由两部分组成：</p><p><code>scheme:[//authority][path][?query][#fragment]</code></p><ul><li><code>scheme</code>：协议，如 <code>http</code>, <code>ftp</code>, <code>mailto</code>。</li><li><code>path</code>：资源路径。</li></ul><h4 id="URL-的结构："><a href="#URL-的结构：" class="headerlink" title="URL 的结构："></a>URL 的结构：</h4><p>URL 包含了 URI 的所有组成部分，并加入了定位信息。</p><p><code>scheme://host:port/path?query#fragment</code></p><ul><li><code>scheme</code>：协议。如 <code>http</code>, <code>https</code>, <code>ftp</code>。</li><li><code>host</code>：主机名或 IP 地址。</li><li><code>port</code>：端口号（可选，如果使用默认端口则可以省略）。</li><li><code>path</code>：资源路径。</li><li><code>query</code>：查询参数，以 <code>?</code> 开始。</li><li><code>fragment</code>：片段标识符，以 <code>#</code> 开始。</li></ul><h3 id="四、举例说明"><a href="#四、举例说明" class="headerlink" title="四、举例说明"></a>四、举例说明</h3><table><thead><tr><th>字符串</th><th>类别</th><th>解释</th></tr></thead><tbody><tr><td><code>https://www.google.com/search?q=url+uri</code></td><td><strong>URL</strong> 和 <strong>URI</strong></td><td>既是 URI（标识），也是 URL（定位），提供了完整的访问信息。</td></tr><tr><td><code>urn:isbn:0451450523</code></td><td><strong>URI</strong> 但<strong>不是 URL</strong></td><td><code>urn:isbn</code> 是一个 URN (Uniform Resource Name)，它是 URI 的另一种类型，用于标识一本书。它标识了资源，但没有提供如何访问它的位置信息。</td></tr><tr><td><code>/images/logo.png</code></td><td><strong>URI</strong> 但<strong>不是 URL</strong></td><td>这是一个相对路径，它标识了资源，但没有完整的定位信息（如协议、主机名），需要结合当前页面的 URL 才能确定完整位置。</td></tr><tr><td><code>mailto:test@example.com</code></td><td><strong>URI</strong> 但<strong>不是 URL</strong></td><td>标识了一个邮箱资源，但无法通过它来定位到具体的文件或服务器。</td></tr></tbody></table><h3 id="五、面试回答总结"><a href="#五、面试回答总结" class="headerlink" title="五、面试回答总结"></a>五、面试回答总结</h3><ol><li><p><strong>开门见山</strong>：URL 是 URI 的子集。</p></li><li><p><strong>核心区别</strong>：</p><ul><li><strong>URI 是标识符</strong>，它只负责<strong>标识</strong>一个资源，不提供如何访问它的信息。</li><li><strong>URL 是定位符</strong>，它在标识资源的同时，还提供了<strong>定位</strong>该资源的完整信息，如协议、主机名等。</li></ul></li><li><p><strong>举例</strong>：</p><ul><li>URL：<code>https://www.example.com/index.html</code>，包含了协议、主机、路径，可以明确地定位一个资源。</li><li>URI：<code>urn:isbn:0451450523</code>，它标识了一本书，但你无法通过它来访问这本书的电子版。</li></ul></li><li><p><strong>关系图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------------+</span><br><span class="line">|      URI    |</span><br><span class="line">|             |</span><br><span class="line">|  +----------+---------+</span><br><span class="line">|  |   URL    |   URN   |</span><br><span class="line">|  | (定位)   |  (命名) |</span><br><span class="line">|  +----------+---------+</span><br><span class="line">|             |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>用这个图能非常清晰地展现它们之间的关系。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> servlet </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写答案</title>
      <link href="/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/"/>
      <url>/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="1-实现单例模式-Singleton-Pattern"><a href="#1-实现单例模式-Singleton-Pattern" class="headerlink" title="1.实现单例模式 (Singleton Pattern)"></a>1.实现单例模式 (Singleton Pattern)</h3><h4 id="懒汉式："><a href="#懒汉式：" class="headerlink" title="懒汉式："></a>懒汉式：</h4><p>使用<strong>双重检查锁定 (DCL)</strong> 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有化构造器，防止外部直接 new 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供一个全局访问点，使用 DCL 确保线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查：如果实例已经存在，直接返回，避免不必要的同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一次检查失败，进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查：在同步块内部再次检查，防止多个线程同时通过第一次检查，</span></span><br><span class="line">                <span class="comment">// 导致创建多个实例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建实例</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个线程安全的懒汉式单例模式实例。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="饿汉式："><a href="#饿汉式：" class="headerlink" title="饿汉式："></a>饿汉式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonEager</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 在类加载时就创建静态实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonEager</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonEager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有化构造器，防止外部直接创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonEager</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供一个公共的静态方法来获取唯一实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonEager <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个线程安全的饿汉式单例模式实例。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-继承与多态-Inheritance-and-Polymorphism"><a href="#2-继承与多态-Inheritance-and-Polymorphism" class="headerlink" title="2.继承与多态 (Inheritance and Polymorphism)"></a>2.继承与多态 (Inheritance and Polymorphism)</h3><p>设计一个 <code>Animal</code> 抽象类，并创建 <code>Dog</code> 和 <code>Cat</code> 类来展示继承和多态。&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Animal 抽象类，定义通用行为</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Dog 类继承 Animal，并重写 eat() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗正在吃骨头。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Cat 类继承 Animal，并重写 eat() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫正在吃鱼。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 展示多态的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PolymorphismDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showPolymorphism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 父类引用指向子类对象，这就是多态</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用相同的方法，但由于指向不同的子类实例，执行不同的行为</span></span><br><span class="line">        myDog.eat(); <span class="comment">// 输出: 狗正在吃骨头。</span></span><br><span class="line">        myCat.eat(); <span class="comment">// 输出: 猫正在吃鱼。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="equals-和-hashCode"><a href="#equals-和-hashCode" class="headerlink" title="equals() 和 hashCode()"></a><code>equals()</code> 和 <code>hashCode()</code></h3><p>编写 <code>Student</code> 类，并重写 <code>equals()</code> 和 <code>hashCode()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 equals() 方法，根据 id 和 name 判断两个 Student 对象是否相等</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 检查是否为同一个对象的引用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 2. 检查对象是否为 null 或类型是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 3. 类型转换</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="comment">// 4. 比较关键字段 (id 和 name)</span></span><br><span class="line">        <span class="keyword">return</span> id == student.id &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 hashCode() 方法，为相等的对象生成相同的哈希码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Objects.hash() 方法生成哈希码，它会为多个字段生成一个组合哈希值</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 为什么需要两者一起重写？</span></span><br><span class="line"><span class="comment">* 1. 它们之间存在约定：如果两个对象通过 equals() 方法比较是相等的，那么它们的 hashCode() 方法返回的值也必须相等。</span></span><br><span class="line"><span class="comment">* 反之则不一定，不相等的对象可以有相同的哈希码（哈希冲突）。</span></span><br><span class="line"><span class="comment">* 2. 哈希表类（如 HashSet, HashMap）依赖于这个约定：当将对象存入哈希表时，</span></span><br><span class="line"><span class="comment">* 它会先调用 hashCode() 确定存储位置，再调用 equals() 来确认是否存在相同的对象。</span></span><br><span class="line"><span class="comment">* 3. 如果只重写 equals() 但不重写 hashCode()，可能导致两个逻辑上相等的对象被存储在不同的哈希位置，</span></span><br><span class="line"><span class="comment">* 从而无法正确查找和去重。例如，在 HashSet 中，即使两个 Student 对象 id 和 name 相同，</span></span><br><span class="line"><span class="comment">* 也会被认为是不同的对象而重复添加。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="接口与实现-Interfaces-and-Implementation"><a href="#接口与实现-Interfaces-and-Implementation" class="headerlink" title="接口与实现 (Interfaces and Implementation)"></a>接口与实现 (Interfaces and Implementation)</h3><p>设计 <code>Drawable</code> 接口，并由 <code>Circle</code> 和 <code>Rectangle</code> 实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义 Drawable 接口，包含一个抽象方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Circle 类实现 Drawable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在画一个圆形。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Rectangle 类实现 Drawable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在画一个矩形。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="异常处理-Exception-Handling"><a href="#异常处理-Exception-Handling" class="headerlink" title="异常处理 (Exception Handling)"></a>异常处理 (Exception Handling)</h3><p>使用 <code>try-catch-finally</code> 结构处理 <code>FileNotFoundException</code> 并确保资源关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 在 try 块外部声明，以便在 finally 块中访问</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试打开文件</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已成功打开。&quot;</span>);</span><br><span class="line">            <span class="comment">// 假设这里进行文件读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件未找到异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;错误：指定的文件不存在！路径：&quot;</span> + filePath);</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印异常堆栈信息</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论是否发生异常，finally 块都会执行</span></span><br><span class="line">            <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 确保文件流被关闭，防止资源泄露</span></span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件流已在 finally 块中关闭。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;关闭文件流时发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a><code>try-with-resources</code></h3><p>使用 <code>try-with-resources</code> 重写上一个题目，展示其简化优势。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TryWithResourcesDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processFileWithResources</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">// try-with-resources 语句，自动管理实现了 AutoCloseable 接口的资源</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已成功打开。&quot;</span>);</span><br><span class="line">            <span class="comment">// 假设这里进行文件读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件未找到异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;错误：指定的文件不存在！路径：&quot;</span> + filePath);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件关闭时可能发生的异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;关闭文件流时发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不需要单独的 finally 块来关闭资源，JVM 会自动完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件流已在 try-with-resources 语句中自动关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* try-with-resources 的优势：</span></span><br><span class="line"><span class="comment">* 1. 简化代码：不再需要显式的 finally 块来关闭资源，代码更简洁。</span></span><br><span class="line"><span class="comment">* 2. 避免资源泄露：无论 try 块是否正常完成或抛出异常，资源都会被自动关闭，</span></span><br><span class="line"><span class="comment">* 有效防止了因忘记关闭资源而导致的内存和文件句柄泄露。</span></span><br><span class="line"><span class="comment">* 3. 更好的异常处理：如果 try 块和资源关闭时都抛出异常，try-with-resources 会</span></span><br><span class="line"><span class="comment">* 将资源关闭时抛出的异常作为被抑制（suppressed）的异常，主异常保持不变，</span></span><br><span class="line"><span class="comment">* 便于调试。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 (Bubble Sort)"></a>冒泡排序 (Bubble Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortingAlgorithms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">// 外层循环控制比较轮数，共进行 n-1 轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 优化：如果在某一轮没有发生交换，说明数组已经有序</span></span><br><span class="line">            <span class="comment">// 内层循环负责每轮比较和交换，将最大元素“冒”到数组末尾</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换元素</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    swapped = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果没有发生交换，提前结束排序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortingAlgorithms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 找到基准元素的正确位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">            <span class="comment">// 递归地对左子数组进行排序</span></span><br><span class="line">            quickSort(arr, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归地对右子数组进行排序</span></span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择最右边的元素作为基准</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (low - <span class="number">1</span>); <span class="comment">// i 指向小于等于基准的元素的最后一个位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素小于等于基准</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 交换 arr[i] 和 arr[j]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基准元素放到正确的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i + <span class="number">1</span>];</span><br><span class="line">        arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">        arr[high] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二分查找-Binary-Search"><a href="#二分查找-Binary-Search" class="headerlink" title="二分查找 (Binary Search)"></a>二分查找 (Binary Search)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchAlgorithms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止整数溢出</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// 找到目标，返回索引</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 目标在右半部分，更新左边界</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 目标在左半部分，更新右边界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 没有找到目标</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="链表反转-Reverse-Linked-List"><a href="#链表反转-Reverse-Linked-List" class="headerlink" title="链表反转 (Reverse Linked List)"></a>链表反转 (Reverse Linked List)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 前一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head; <span class="comment">// 当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextTemp</span> <span class="operator">=</span> current.next; <span class="comment">// 暂存下一个节点</span></span><br><span class="line">            current.next = prev; <span class="comment">// 将当前节点的指针指向前一个节点</span></span><br><span class="line">            prev = current; <span class="comment">// 前一个节点向前移动</span></span><br><span class="line">            current = nextTemp; <span class="comment">// 当前节点向前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev; <span class="comment">// prev 最终会是新的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="链表中间节点-Middle-of-Linked-List"><a href="#链表中间节点-Middle-of-Linked-List" class="headerlink" title="链表中间节点 (Middle of Linked List)"></a>链表中间节点 (Middle of Linked List)</h3><p>使用<strong>快慢指针</strong>，快指针每次走两步，慢指针每次走一步。当快指针到达链表末尾时，慢指针正好在中间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findMiddleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head; <span class="comment">// 慢指针，每次走一步</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head; <span class="comment">// 快指针，每次走两步</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当快指针到达末尾时，慢指针正好在中间</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="移除重复元素-Remove-Duplicates"><a href="#移除重复元素-Remove-Duplicates" class="headerlink" title="移除重复元素 (Remove Duplicates)"></a>移除重复元素 (Remove Duplicates)</h3><p>不使用 <code>Set</code>，通过双层循环或排序后遍历实现。这里使用排序后遍历的方法，因为它更高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeDuplicates</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span> || list.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(list); <span class="comment">// 先排序，使得重复元素相邻</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 倒序遍历，移除重复元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).equals(list.get(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                list.remove(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串反转-Reverse-String"><a href="#字符串反转-Reverse-String" class="headerlink" title="字符串反转 (Reverse String)"></a>字符串反转 (Reverse String)</h3><p>不使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 的 <code>reverse()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> charArray.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 交换首尾字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> charArray[left];</span><br><span class="line">            charArray[left] = charArray[right];</span><br><span class="line">            charArray[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="回文字符串-Palindrome-String"><a href="#回文字符串-Palindrome-String" class="headerlink" title="回文字符串 (Palindrome String)"></a>回文字符串 (Palindrome String)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将字符串转换为小写并移除非字母数字字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cleanedStr</span> <span class="operator">=</span> str.toLowerCase().replaceAll(<span class="string">&quot;[^a-z0-9]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> cleanedStr.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cleanedStr.charAt(left) != cleanedStr.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="计算阶乘-Factorial-Calculation"><a href="#计算阶乘-Factorial-Calculation" class="headerlink" title="计算阶乘 (Factorial Calculation)"></a>计算阶乘 (Factorial Calculation)</h3><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">factorialRecursive</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Factorial is not defined for negative numbers.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * factorialRecursive(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MathProblems &#123;</span><br><span class="line">    public static long factorialIterative(int n) &#123;</span><br><span class="line">        if (n &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Factorial is not defined for negative numbers.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        long result = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            result *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="斐波那契数列-Fibonacci-Sequence"><a href="#斐波那契数列-Fibonacci-Sequence" class="headerlink" title="斐波那契数列 (Fibonacci Sequence)"></a>斐波那契数列 (Fibonacci Sequence)</h3><h4 id="递归方式-1"><a href="#递归方式-1" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fibonacciRecursive</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid input for Fibonacci sequence.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibonacciRecursive(n - <span class="number">1</span>) + fibonacciRecursive(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方式-1"><a href="#非递归方式-1" class="headerlink" title="非递归方式"></a>非递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fibonacciIterative</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid input for Fibonacci sequence.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串中字符计数-Character-Count"><a href="#字符串中字符计数-Character-Count" class="headerlink" title="字符串中字符计数 (Character Count)"></a>字符串中字符计数 (Character Count)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Character, Integer&gt; <span class="title function_">countCharacters</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; charCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> charCountMap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            charCountMap.put(c, charCountMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> charCountMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="两数之和-Two-Sum"><a href="#两数之和-Two-Sum" class="headerlink" title="两数之和 (Two Sum)"></a>两数之和 (Two Sum)</h3><p>使用 <code>HashMap</code> 将值和索引存储起来，实现一次遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; numMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (numMap.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;numMap.get(complement), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            numMap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;; <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数组中最大-小值-Max-Min-in-Array"><a href="#数组中最大-小值-Max-Min-in-Array" class="headerlink" title="数组中最大&#x2F;小值 (Max&#x2F;Min in Array)"></a>数组中最大&#x2F;小值 (Max&#x2F;Min in Array)</h3><p>一次遍历找到最大值和最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findMaxMin(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Array cannot be null or empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;max, min&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="质数判断-Prime-Number"><a href="#质数判断-Prime-Number" class="headerlink" title="质数判断 (Prime Number)"></a>质数判断 (Prime Number)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1 和更小的数都不是质数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只需要检查到 n 的平方根</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="集合交集-List-Intersection"><a href="#集合交集-List-Intersection" class="headerlink" title="集合交集 (List Intersection)"></a>集合交集 (List Intersection)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">intersection</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span> &#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">null</span> || list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历第一个列表，检查元素是否在第二个列表中</span></span><br><span class="line">        <span class="keyword">for</span> (T element : list1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list2.contains(element) &amp;&amp; !result.contains(element)) &#123;</span><br><span class="line">                result.add(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数组合并-Merge-Sorted-Arrays"><a href="#数组合并-Merge-Sorted-Arrays" class="headerlink" title="数组合并 (Merge Sorted Arrays)"></a>数组合并 (Merge Sorted Arrays)</h3><p>将两个已排序的数组合并为一个新的已排序数组，使用<strong>双指针</strong>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeSortedArrays(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="type">int</span>[] merged = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length + arr2.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] &lt; arr2[j]) &#123;</span><br><span class="line">                merged[k++] = arr1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged[k++] = arr2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr1.length) &#123;</span><br><span class="line">            merged[k++] = arr1[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; arr2.length) &#123;</span><br><span class="line">            merged[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="判断回文数-Palindrome-Number"><a href="#判断回文数-Palindrome-Number" class="headerlink" title="判断回文数 (Palindrome Number)"></a>判断回文数 (Palindrome Number)</h3><p>不使用 <code>String</code> 转换，通过数学方法反转一半数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindromeNumber</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 负数和以 0 结尾的非 0 数字都不是回文</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">reversedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; reversedNumber) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lastDigit</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">            reversedNumber = reversedNumber * <span class="number">10</span> + lastDigit;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偶数位数字时，x 等于 reversedNumber</span></span><br><span class="line">        <span class="comment">// 奇数位数字时，x 等于 reversedNumber 除以 10</span></span><br><span class="line">        <span class="keyword">return</span> x == reversedNumber || x == reversedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="罗马数字转整数-Roman-to-Integer"><a href="#罗马数字转整数-Roman-to-Integer" class="headerlink" title="罗马数字转整数 (Roman to Integer)"></a>罗马数字转整数 (Roman to Integer)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; romanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        romanMap.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentVal</span> <span class="operator">=</span> romanMap.get(s.charAt(i));</span><br><span class="line">            <span class="comment">// 如果当前字符的值小于下一个字符的值，则需要减去当前值</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; s.length() - <span class="number">1</span> &amp;&amp; currentVal &lt; romanMap.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                result -= currentVal;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += currentVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="爬楼梯-Climbing-Stairs"><a href="#爬楼梯-Climbing-Stairs" class="headerlink" title="爬楼梯 (Climbing Stairs)"></a>爬楼梯 (Climbing Stairs)</h3><p>这是经典的<strong>动态规划</strong>问题。</p><h4 id="动态规划方式-非递归"><a href="#动态规划方式-非递归" class="headerlink" title="动态规划方式 (非递归)"></a>动态规划方式 (非递归)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 爬 1 级台阶，有 1 种方法</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>; <span class="comment">// 爬 2 级台阶，有 2 种方法 (1+1, 2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 到达第 i 级台阶的方法数 = (从 i-1 级爬 1 级的方法数) + (从 i-2 级爬 2 级的方法数)</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，以下是基于  语言的线程基础与同步的实现，并附带详细注释。</p><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><h4 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1. 继承 Thread 类"></a>1. 继承 <code>Thread</code> 类</h4><p>通过继承 <code>java.lang.Thread</code> 类并重写其 <code>run()</code> 方法来创建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承 Thread 类创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用继承 Thread 类的方式创建的线程正在运行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现-Runnable-接口"><a href="#2-实现-Runnable-接口" class="headerlink" title="2. 实现 Runnable 接口"></a>2. 实现 <code>Runnable</code> 接口</h4><p>通过实现 <code>java.lang.Runnable</code> 接口并将其作为参数传递给 <code>Thread</code> 类的构造函数来创建线程。这种方式更灵活，推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Runnable 接口创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用实现 Runnable 接口的方式创建的线程正在运行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep() 与 yield()"></a><code>sleep()</code> 与 <code>yield()</code></h3><p><code>sleep()</code> 和 <code>yield()</code> 都是线程调度的方法，但它们的作用和效果不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepYieldDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 sleep() 的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// sleep() 使线程暂停指定时间，进入 WAITING 状态，但不会释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程 A: 准备睡眠 2 秒...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 A: 睡眠结束，继续执行。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 yield() 的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 B: 开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 B: 正在执行 &quot;</span> + i);</span><br><span class="line">                <span class="comment">// yield() 提示线程调度器让出 CPU 时间，但不保证一定生效</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 B: 执行完毕。&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>sleep()</strong>: 使当前线程<strong>暂停执行指定的时间</strong>，进入 <strong>TIMED_WAITING</strong> 状态。它会<strong>释放 CPU 资源</strong>，但<strong>不释放锁</strong>。</li><li><strong>yield()</strong>: 提示线程调度器，当前线程愿意<strong>让出当前 CPU 时间片</strong>。线程会从 <strong>RUNNING</strong> 状态转换为 <strong>RUNNABLE</strong> 状态，与其他线程竞争 CPU，但<strong>不保证</strong>其他线程能立即获得执行。它主要用于优化线程调度，通常在多线程程序中<strong>不应依赖</strong>其行为来保证正确性。</li></ul><hr><h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join() 方法"></a><code>join()</code> 方法</h3><p><code>join()</code> 方法允许一个线程等待另一个线程执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JoinDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程: 正在执行...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;子线程: 执行完毕。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        workerThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 等待子线程执行完毕...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用 join() 方法，主线程进入等待状态，直到 workerThread 执行完毕</span></span><br><span class="line">        workerThread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 子线程已执行完毕，主线程继续执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="非线程安全计数器"><a href="#非线程安全计数器" class="headerlink" title="非线程安全计数器"></a>非线程安全计数器</h3><p>在多线程环境下，多个线程同时对共享资源进行读写操作，可能导致数据不一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 这一行代码并非原子操作，它包含三个步骤：读、加 1、写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafetyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">UnsafeCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsafeCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果不一定是 100 * 10000 = 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;非线程安全计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><code>synchronized</code> 关键字</h3><p>使用 <code>synchronized</code> 关键字可以保证同一时刻只有一个线程访问共享资源，从而解决线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 关键字修饰方法，锁住整个对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SynchronizedCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果为 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="synchronized-块与方法"><a href="#synchronized-块与方法" class="headerlink" title="synchronized 块与方法"></a><code>synchronized</code> 块与方法</h3><ul><li><strong>synchronized 方法</strong>: 锁定的是当前对象实例 (<code>this</code>)。</li><li><strong>synchronized 块</strong>: 提供了更细粒度的控制，可以指定锁定的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedBlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized 方法，锁定当前对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synchronizedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入 synchronized 方法。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 离开 synchronized 方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized 块，锁定指定的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedBlock1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取 lock1...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已获取 lock1。&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放 lock1。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedBlock2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取 lock2...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已获取 lock2。&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放 lock2。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 区别与适用场景:</span></span><br><span class="line"><span class="comment"> * - synchronized 方法: 简单易用，但锁定范围大，可能导致性能问题。当需要同步整个方法时使用。</span></span><br><span class="line"><span class="comment"> * - synchronized 块: 锁定范围小，可以只同步需要保护的代码段，提高并发性能。当只需要同步部分代码时使用。</span></span><br><span class="line"><span class="comment"> * 同时，可以通过锁定不同的对象来避免不必要的阻塞，实现更高的并发度。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><code>volatile</code> 关键字</h3><p><code>volatile</code> 关键字保证了变量在多线程间的<strong>可见性</strong>，但不保证<strong>原子性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">    <span class="comment">// volatile 保证所有线程看到的是该变量的最新值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 正在等待标志位变为 true。&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="comment">// 空循环，等待 ready 变为 true</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 标志位已变为 true，循环结束。&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 确保线程 A 先运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 正在将标志位设置为 true。&quot;</span>);</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为什么 volatile 不能保证原子性?</span></span><br><span class="line"><span class="comment"> * - 原子性是指一个操作是不可中断的，要么全部执行，要么都不执行。</span></span><br><span class="line"><span class="comment"> * - volatile 只能保证变量的读写操作是原子的，但像 `count++` 这样的复合操作（读、加、写）</span></span><br><span class="line"><span class="comment"> * 依然不是原子的。多个线程可能同时读到旧值，导致最终结果不正确。</span></span><br><span class="line"><span class="comment"> * - volatile 主要用于一写多读的场景，或者用于控制线程执行流程的标志位。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a><code>AtomicInteger</code></h3><p><code>AtomicInteger</code> 是一个原子类，它使用 CAS (Compare-and-Swap) 机制来保证操作的原子性，从而实现线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 AtomicInteger 替代 int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet(); <span class="comment">// 这是一个原子操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果为 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicInteger 计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>使用 <code>wait()</code> 和 <code>notifyAll()</code> 实现两个线程交替打印奇数和偶数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintNumbers</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOdd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果是偶数，则等待</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEven</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count % <span class="number">2</span> != <span class="number">0</span>) &#123; <span class="comment">// 如果是奇数，则等待</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNumbers</span> <span class="variable">pn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumbers</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">oddThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(pn::printOdd, <span class="string">&quot;奇数线程&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">evenThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(pn::printEven, <span class="string">&quot;偶数线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        oddThread.start();</span><br><span class="line">        evenThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，以下是  中高级并发编程的实现，并附带详细注释。</p><h3 id="生产者-消费者模式-使用-wait-和-notifyAll"><a href="#生产者-消费者模式-使用-wait-和-notifyAll" class="headerlink" title="生产者-消费者模式 (使用 wait() 和 notifyAll())"></a>生产者-消费者模式 (使用 <code>wait()</code> 和 <code>notifyAll()</code>)</h3><p>这是一个经典的线程协作问题。生产者生产数据，放入共享队列；消费者从队列中取出数据进行消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerClassic</span> &#123;</span><br><span class="line">    <span class="comment">// 共享队列，使用 LinkedList 实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 队列最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 如果队列已满，生产者等待</span></span><br><span class="line">                <span class="keyword">while</span> (queue.size() == MAX_SIZE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列已满，生产者等待...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 生产数据并放入队列</span></span><br><span class="line">                queue.offer(i);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 唤醒所有等待的线程（包括消费者）</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟生产时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 如果队列为空，消费者等待</span></span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列为空，消费者等待...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 消费数据</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">                <span class="comment">// 唤醒所有等待的线程（包括生产者）</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">// 模拟消费时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="生产者-消费者模式-使用-BlockingQueue"><a href="#生产者-消费者模式-使用-BlockingQueue" class="headerlink" title="生产者-消费者模式 (使用 BlockingQueue)"></a>生产者-消费者模式 (使用 <code>BlockingQueue</code>)</h3><p><code>java.util.concurrent.BlockingQueue</code> 接口提供了线程安全的队列操作，简化了生产者-消费者模型的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerBlockingQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 BlockingQueue，它内部已经处理了线程同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// put() 方法在队列满时会自动阻塞</span></span><br><span class="line">            queue.put(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// take() 方法在队列空时会自动阻塞</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h3><p>使用 <code>ReentrantLock</code> 实现线程安全计数器，并解释其与 <code>synchronized</code> 的区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReentrantLockCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++; <span class="comment">// 在 try 块中执行需要同步的代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 在 finally 块中释放锁，确保锁总是被释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* ReentrantLock 与 synchronized 的区别:</span></span><br><span class="line"><span class="comment">* 1. 语法层面: `synchronized` 是 JVM 的内置关键字，而 `ReentrantLock` 是一个类。</span></span><br><span class="line"><span class="comment">* 2. 灵活性: `ReentrantLock` 提供了更灵活的锁定控制。例如，它支持公平锁（按请求顺序获取锁），</span></span><br><span class="line"><span class="comment">* 可以尝试非阻塞地获取锁（`tryLock()`），以及支持中断（`lockInterruptibly()`）。</span></span><br><span class="line"><span class="comment">* 3. 性能: 在早期版本中，`ReentrantLock` 通常性能更好。但随着  对 `synchronized` 优化（偏向锁、轻量级锁），</span></span><br><span class="line"><span class="comment">* 两者性能已非常接近。在简单场景下，`synchronized` 更简洁。</span></span><br><span class="line"><span class="comment">* 4. 协作: `ReentrantLock` 必须配合 `Condition` 接口才能实现线程间的等待/唤醒机制，而 `synchronized` 直接</span></span><br><span class="line"><span class="comment">* 使用 `Object` 的 `wait()` 和 `notify()`。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="ReentrantLock-与-Condition"><a href="#ReentrantLock-与-Condition" class="headerlink" title="ReentrantLock 与 Condition"></a><code>ReentrantLock</code> 与 <code>Condition</code></h3><p>使用 <code>ReentrantLock</code> 和 <code>Condition</code> 重新实现生产者-消费者模型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerCondition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 创建两个 Condition 实例，分别用于生产者和消费者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">producerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">consumerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == MAX_SIZE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列已满，生产者等待...&quot;</span>);</span><br><span class="line">                    producerCondition.await(); <span class="comment">// 生产者等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                consumerCondition.signalAll(); <span class="comment">// 唤醒所有消费者</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列为空，消费者等待...&quot;</span>);</span><br><span class="line">                    consumerCondition.await(); <span class="comment">// 消费者等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">                producerCondition.signalAll(); <span class="comment">// 唤醒所有生产者</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><code>ExecutorService</code></h3><p>创建一个固定大小的线程池，并向其提交多个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutorServiceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小为 3 的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 执行。&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池，不再接收新任务，已提交的任务会继续执行</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Callable-与-Future"><a href="#Callable-与-Future" class="headerlink" title="Callable 与 Future"></a><code>Callable</code> 与 <code>Future</code></h3><p>使用 <code>Callable</code> 提交任务，并使用 <code>Future</code> 获取返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 Callable 任务，它会返回一个字符串</span></span><br><span class="line">        Callable&lt;String&gt; task = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务开始执行...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;任务执行完毕，返回结果！&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务并获得 Future 对象</span></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(task);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 任务已提交，继续执行其他操作...&quot;</span>);</span><br><span class="line">        <span class="comment">// get() 方法会阻塞，直到任务完成并返回结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 获得任务结果 -&gt; &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h3><p><code>CountDownLatch</code> 允许一个或多个线程等待直到在其他线程中执行的一组操作完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">workerCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 计数器，当计数器减到 0 时，主线程会被唤醒</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(workerCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 开始执行任务...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">2000</span>)); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 任务完成。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown(); <span class="comment">// 任务完成后，计数器减 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 等待所有工作线程完成...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 阻塞主线程，直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 所有工作线程已完成，继续执行下一步。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code> 允许一组线程相互等待，直到所有线程都到达一个共同的屏障点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">partySize</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 当 3 个线程都到达屏障时，执行一个屏障动作</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(partySize, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n所有线程已到达屏障点！继续执行下一阶段。\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(partySize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; partySize; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在执行第一阶段任务...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 第一阶段任务完成，到达屏障。&quot;</span>);</span><br><span class="line">                    barrier.await(); <span class="comment">// 线程在此处等待</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在执行第二阶段任务...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h3><p><code>Semaphore</code>（信号量）用来控制对资源的并发访问数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 允许 3 个线程同时访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessResource</span><span class="params">(<span class="type">int</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 获取许可</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在访问资源...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟资源访问时间</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 访问资源完毕。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SemaphoreDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SemaphoreDemo</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; demo.accessResource(threadId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><h4 id="1-死锁演示"><a href="#1-死锁演示" class="headerlink" title="1. 死锁演示"></a>1. 死锁演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B: 已获得 lock2，尝试获取 lock1...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B: 已获得 lock1。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadA, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadB, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 死锁产生条件:</span></span><br><span class="line"><span class="comment">* 1. 互斥条件: 资源是独占的，一个线程在使用时，其他线程无法使用。</span></span><br><span class="line"><span class="comment">* 2. 请求与保持条件: 线程已经持有至少一个资源，但又请求其他资源，同时又保持对已有资源的占有。</span></span><br><span class="line"><span class="comment">* 3. 不可剥夺条件: 资源只能在持有它的线程完成任务后由它自己释放。</span></span><br><span class="line"><span class="comment">* 4. 循环等待条件: 存在一个线程资源的循环链，每个线程都在等待下一个线程所持有的资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>通过打破死锁的四个必要条件之一来预防死锁。这里通过<strong>资源有序分配</strong>来打破<strong>循环等待</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockPrevention</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 A 按顺序先获取 lock1，再获取 lock2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 B 也按顺序先获取 lock1，再获取 lock2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockPrevention</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockPrevention</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadA, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadB, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 两个线程都按相同的顺序获取锁，不会发生死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p><code>ThreadLocal</code> 为每个线程提供了一个独立的变量副本，实现了线程间的数据隔离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAndPrint</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置线程本地变量</span></span><br><span class="line">        threadLocal.set(value);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务</span></span><br><span class="line">            <span class="comment">// 获取并打印当前线程的变量值</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的变量值: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 最佳实践：使用完后移除，防止内存泄漏</span></span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 A 的数据&quot;</span>), <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 B 的数据&quot;</span>), <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 原理和作用:</span></span><br><span class="line"><span class="comment">* 原理: ThreadLocal 内部有一个 `ThreadLocalMap`，每个线程都有一个独立的 `ThreadLocalMap`。</span></span><br><span class="line"><span class="comment">* 当我们调用 `set()` 方法时，实际上是将值存储到了当前线程的 `ThreadLocalMap` 中，</span></span><br><span class="line"><span class="comment">* 键为 `ThreadLocal` 实例本身。</span></span><br><span class="line"><span class="comment">* 作用:</span></span><br><span class="line"><span class="comment">* 1. 数据隔离: 解决了多线程访问共享变量的线程安全问题，但其本质不是同步，而是通过“以空间换时间”的方式，</span></span><br><span class="line"><span class="comment">* 为每个线程提供独立副本，避免了竞争。</span></span><br><span class="line"><span class="comment">* 2. 传递参数: 在整个方法调用链中，无需层层传递参数，可以方便地在任何地方获取当前线程的上下文信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="线程安全单例-静态内部类"><a href="#线程安全单例-静态内部类" class="headerlink" title="线程安全单例 (静态内部类)"></a>线程安全单例 (静态内部类)</h3><p>静态内部类方式是实现线程安全的懒汉式单例的最佳实践之一。它利用了 JVM 类加载机制的线程安全特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonThreadSafe</span> &#123;</span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonThreadSafe</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类，它只在 SingletonThreadSafe 被首次调用时才会被加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 静态成员变量，在类加载时初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonThreadSafe</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonThreadSafe</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供全局访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonThreadSafe <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 优点:</span></span><br><span class="line"><span class="comment">* 1. 线程安全: 类的加载是线程安全的，因此 INSTANCE 的初始化是原子的。</span></span><br><span class="line"><span class="comment">* 2. 懒加载: 只有在调用 getInstance() 方法时，SingletonHolder 类才会被加载，</span></span><br><span class="line"><span class="comment">* 从而实现懒加载。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a><code>ReadWriteLock</code></h3><p><code>ReadWriteLock</code> 适用于读多写少的场景，它允许多个线程同时进行读操作，但写操作必须是互斥的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sharedData</span> <span class="operator">=</span> <span class="string">&quot;初始数据&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在读取数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> (String) sharedData;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String newData)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在写入数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">// sharedData = newData; // 实际更新数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><p><code>ExecutorService</code> 的两种关闭方式：<code>shutdown()</code> 和 <code>shutdownNow()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShutdownDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交 5 个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在执行...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 被中断。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// shutdown() vs shutdownNow()</span></span><br><span class="line">        <span class="comment">// executor.shutdown(); // 优雅关闭</span></span><br><span class="line">        executor.shutdownNow(); <span class="comment">// 暴力关闭</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池已关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 区别:</span></span><br><span class="line"><span class="comment">* - shutdown(): 优雅关闭。不再接受新的任务，但会等待已提交的任务（包括正在执行和在队列中的）全部执行完毕。</span></span><br><span class="line"><span class="comment">* 执行后，isShutdown() 返回 true，isTerminated() 返回 false，直到所有任务完成。</span></span><br><span class="line"><span class="comment">* - shutdownNow(): 暴力关闭。立即停止所有正在执行的任务，并返回在队列中等待执行的任务列表。</span></span><br><span class="line"><span class="comment">* 它会向所有线程发送 interrupt() 中断信号。</span></span><br><span class="line"><span class="comment">* 执行后，isShutdown() 返回 true，isTerminated() 立即返回 true。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>一个线程通过响应 <code>interrupt()</code> 调用来正确停止自身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptedThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; <span class="comment">// 检查中断标志</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程正在执行...&quot;</span>);</span><br><span class="line">                    <span class="comment">// sleep()、wait() 等方法会抛出 InterruptedException 并清除中断标志</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程被中断！&quot;</span>);</span><br><span class="line">                    <span class="comment">// 重新设置中断标志，以便外层循环能正确退出</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">// 或者直接 return 退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程已退出。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        worker.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送中断信号</span></span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子数组求和-Subarray-Sum"><a href="#子数组求和-Subarray-Sum" class="headerlink" title="子数组求和 (Subarray Sum)"></a>子数组求和 (Subarray Sum)</h3><p>使用<strong>滑动窗口</strong>或<strong>前缀和 + 哈希表</strong>两种方式解决。这里演示前缀和 + 哈希表，它能处理负数情况且时间复杂度更优。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出和等于目标值的连续子数组。</span></span><br><span class="line"><span class="comment">     * 使用前缀和与哈希表的方式，时间复杂度为 O(n)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums   整数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到，返回子数组的起始和结束索引；否则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findSubarraySum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key: 前缀和, value: 出现该前缀和的索引</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; prefixSumMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        prefixSumMap.put(<span class="number">0</span>, -<span class="number">1</span>); <span class="comment">// 初始化，处理从数组开头开始的子数组</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            currentSum += nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否存在 (currentSum - target) 这样的前缀和</span></span><br><span class="line">            <span class="keyword">if</span> (prefixSumMap.containsKey(currentSum - target)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> prefixSumMap.get(currentSum - target) + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prefixSumMap.put(currentSum, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串去重-Remove-Duplicates-from-String"><a href="#字符串去重-Remove-Duplicates-from-String" class="headerlink" title="字符串去重 (Remove Duplicates from String)"></a>字符串去重 (Remove Duplicates from String)</h3><p>使用 <code>LinkedHashSet</code> 保持相对顺序或手动遍历。这里手动遍历实现，避免使用额外数据结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对一个字符串进行去重，并保持原有字符的相对顺序。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 待去重的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 去重后的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">removeDuplicates</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">boolean</span>[] charSet = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>]; <span class="comment">// 假设为 ASCII 字符集</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!charSet[c]) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                charSet[c] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="最长不重复子串-Longest-Substring-Without-Repeating-Characters"><a href="#最长不重复子串-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="最长不重复子串 (Longest Substring Without Repeating Characters)"></a>最长不重复子串 (Longest Substring Without Repeating Characters)</h3><p>使用<strong>滑动窗口</strong>加<strong>哈希表</strong>或<strong>数组</strong>来高效解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出最长不重复子串的长度。</span></span><br><span class="line"><span class="comment">     * 使用滑动窗口（双指针）和哈希表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 输入字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长不重复子串的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key: 字符, value: 字符的最新索引</span></span><br><span class="line">        Map&lt;Character, Integer&gt; charIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 滑动窗口的左边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">currentChar</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前字符已在窗口内，更新左边界</span></span><br><span class="line">            <span class="keyword">if</span> (charIndexMap.containsKey(currentChar)) &#123;</span><br><span class="line">                left = Math.max(left, charIndexMap.get(currentChar) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            charIndexMap.put(currentChar, right);</span><br><span class="line">            maxLength = Math.max(maxLength, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串转整数-String-to-Integer-atoi"><a href="#字符串转整数-String-to-Integer-atoi" class="headerlink" title="字符串转整数 (String to Integer - atoi)"></a>字符串转整数 (String to Integer - atoi)</h3><p>实现 <code>atoi</code> 函数，需要考虑各种边界情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 atoi 函数，将字符串转换为整数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换后的整数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.trim(); <span class="comment">// 1. 去掉前导空格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2. 处理正负号</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(index) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = -<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(index) == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(index);</span><br><span class="line">            <span class="comment">// 3. 检查是否为数字</span></span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(c)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            result = result * <span class="number">10</span> + digit;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 处理溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="number">1</span> &amp;&amp; result &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sign == -<span class="number">1</span> &amp;&amp; -result &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (result * sign);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="判断子串-Substring-Check"><a href="#判断子串-Substring-Check" class="headerlink" title="判断子串 (Substring Check)"></a>判断子串 (Substring Check)</h3><p>使用 <code>String.indexOf()</code> 是最直接的方式。如果不能使用内置方法，可以通过双指针或 KMP 算法实现。这里提供双指针的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个字符串是否是另一个字符串的子串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mainStr 主字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subStr  子字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果 subStr 是 mainStr 的子串，返回 true；否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSubstring</span><span class="params">(String mainStr, String subStr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mainStr == <span class="literal">null</span> || subStr == <span class="literal">null</span> || mainStr.length() &lt; subStr.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subStr.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= mainStr.length() - subStr.length(); i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; subStr.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mainStr.charAt(i + j) != subStr.charAt(j)) &#123;</span><br><span class="line">                    match = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="数组旋转-Array-Rotation"><a href="#数组旋转-Array-Rotation" class="headerlink" title="数组旋转 (Array Rotation)"></a>数组旋转 (Array Rotation)</h3><p>向右旋转 <code>k</code> 步，可以通过三次反转或使用额外数组实现。这里使用空间复杂度为 <code>O(1)</code> 的三次反转方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个整数数组向右旋转 k 步。</span></span><br><span class="line"><span class="comment">     * 使用三次反转的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 整数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k    旋转步数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k %= nums.length; <span class="comment">// 处理 k 大于数组长度的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 反转整个数组</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 2. 反转前 k 个元素</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 反转剩下的元素</span></span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="交错字符串-Interleaving-String"><a href="#交错字符串-Interleaving-String" class="headerlink" title="交错字符串 (Interleaving String)"></a>交错字符串 (Interleaving String)</h3><p>判断 <code>s3</code> 是否由 <code>s1</code> 和 <code>s2</code> 交错而成，可以使用<strong>动态规划</strong>解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两个字符串交错形成的字符串是否等于第三个字符串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1 字符串1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2 字符串2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3 字符串3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是交错字符串，返回 true；否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s1 的前 i 个字符和 s2 的前 j 个字符能否交错组成 s3 的前 i+j 个字符</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行 (s1 不取字符)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s2.length(); j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一列 (s2 不取字符)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s1.length(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充 DP 表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s2.length(); j++) &#123;</span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>)) ||</span><br><span class="line">                           (dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="最长公共前缀-Longest-Common-Prefix"><a href="#最长公共前缀-Longest-Common-Prefix" class="headerlink" title="最长公共前缀 (Longest Common Prefix)"></a>最长公共前缀 (Longest Common Prefix)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出字符串数组中的最长公共前缀。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs 字符串数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长公共前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 循环比较，直到找到子串</span></span><br><span class="line">            <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 每次缩短 prefix</span></span><br><span class="line">                prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (prefix.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串压缩-String-Compression"><a href="#字符串压缩-String-Compression" class="headerlink" title="字符串压缩 (String Compression)"></a>字符串压缩 (String Compression)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现基本的字符串压缩，例如 aabcccccaaa 压缩为 a2b1c5a3。</span></span><br><span class="line"><span class="comment">     * 如果压缩后的字符串没有变短，则返回原字符串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 待压缩的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 压缩后的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">compressString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">compressed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; str.length() &amp;&amp; str.charAt(i) == str.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                compressed.append(str.charAt(i - <span class="number">1</span>)).append(count);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (compressed.length() &gt;= str.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> str; <span class="comment">// 如果压缩后没有变短，返回原字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compressed.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="寻找重复数-Find-the-Duplicate-Number"><a href="#寻找重复数-Find-the-Duplicate-Number" class="headerlink" title="寻找重复数 (Find the Duplicate Number)"></a>寻找重复数 (Find the Duplicate Number)</h3><p>给定一个包含 <code>n+1</code> 个整数的数组，数字都在 <code>1</code> 到 <code>n</code> 的范围内。找出这个重复的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用**快慢指针**（类似于检测链表环）来寻找重复数。</span></span><br><span class="line"><span class="comment">     * 假设数组是一个链表，索引 `i` 指向 `nums[i]`</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 包含 n+1 个整数的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 重复的数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 寻找环的入口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 找到环后，从头开始，快慢指针以相同速度前进，相遇点即为环的入口（重复数）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = nums[p1];</span><br><span class="line">            p2 = nums[p2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="链表、栈与队列"><a href="#链表、栈与队列" class="headerlink" title="链表、栈与队列"></a>链表、栈与队列</h3><h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>使用<strong>双指针</strong>方法，创建一个新的链表，遍历两个输入链表，比较节点值并依次添加到新链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个哑节点，简化操作</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                current.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将剩余的节点添加到新链表末尾</span></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            current.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            current.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表倒数第-k-个节点"><a href="#链表倒数第-k-个节点" class="headerlink" title="链表倒数第 k 个节点"></a>链表倒数第 k 个节点</h4><p>使用<strong>快慢指针</strong>，只遍历一次。快指针先走 <code>k</code> 步，然后快慢指针同时前进，当快指针到达末尾时，慢指针正好在倒数第 <code>k</code> 个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快指针先走 k 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 链表长度小于 k</span></span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针同时前进，直到快指针到达末尾</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除重复节点"><a href="#删除重复节点" class="headerlink" title="删除重复节点"></a>删除重复节点</h4><p>给定一个已排序的链表，删除所有重复的节点，使得每个元素只出现一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.val == current.next.val) &#123;</span><br><span class="line">                current.next = current.next.next; <span class="comment">// 删除下一个重复节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.next; <span class="comment">// 前进到下一个不重复的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h4><p>使用<strong>快慢指针</strong>。如果链表有环，快指针最终会追上慢指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已经到达末尾，没有环</span></span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h4><p>两个非负整数由链表表示，每个节点包含一个数字。计算它们的和。这里假设链表按<strong>逆序</strong>存储数字（个位在前）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h4><p>使用两个栈，一个用于入队 (<code>inStack</code>)，一个用于出队 (<code>outStack</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        outStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            transfer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            transfer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h4><p>使用两个队列，一个用于入栈 (<code>q1</code>)，一个用于辅助 (<code>q2</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; q1;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; q2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        q1.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (q1.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            q2.offer(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> q1.poll();</span><br><span class="line">        Queue&lt;Integer&gt; temp = q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pop();</span><br><span class="line">        q1.offer(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h4><p>使用一个<strong>栈</strong>来检查括号是否匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                    (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                    (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="树与递归"><a href="#树与递归" class="headerlink" title="树与递归"></a>树与递归</h3><p>定义一个简单的二叉树节点类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树前序遍历-Preorder-Traversal"><a href="#二叉树前序遍历-Preorder-Traversal" class="headerlink" title="二叉树前序遍历 (Preorder Traversal)"></a>二叉树前序遍历 (Preorder Traversal)</h4><p><strong>递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">preorderTraversalRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        preorder(node.left, list);</span><br><span class="line">        preorder(node.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">preorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="comment">// 先压入右子节点，再压入左子节点，保证弹出时先处理左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树中序遍历-Inorder-Traversal"><a href="#二叉树中序遍历-Inorder-Traversal" class="headerlink" title="二叉树中序遍历 (Inorder Traversal)"></a>二叉树中序遍历 (Inorder Traversal)</h4><p><strong>递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">inorderTraversalRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node.left, list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        inorder(node.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">inorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 将所有左子节点压入栈</span></span><br><span class="line">            <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(current);</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 弹出栈顶节点，并处理其右子树</span></span><br><span class="line">            current = stack.pop();</span><br><span class="line">            result.add(current.val);</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树后序遍历-Postorder-Traversal"><a href="#二叉树后序遍历-Postorder-Traversal" class="headerlink" title="二叉树后序遍历 (Postorder Traversal)"></a>二叉树后序遍历 (Postorder Traversal)</h4><p><strong>递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">postorderTraversalRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(node.left, list);</span><br><span class="line">        postorder(node.right, list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">postorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">// 倒序插入</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result); <span class="comment">// 将结果反转</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树层序遍历-Level-Order-Traversal"><a href="#二叉树层序遍历-Level-Order-Traversal" class="headerlink" title="二叉树层序遍历 (Level Order Traversal)"></a>二叉树层序遍历 (Level Order Traversal)</h4><p>使用<strong>队列</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">levelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; currentLevel = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                currentLevel.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currentLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对称二叉树-Symmetric-Tree"><a href="#对称二叉树-Symmetric-Tree" class="headerlink" title="对称二叉树 (Symmetric Tree)"></a>对称二叉树 (Symmetric Tree)</h4><p>使用<strong>递归</strong>，检查根节点的左右子树是否是镜像对称的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (t1.val == t2.val) &amp;&amp; isMirror(t1.right, t2.left) &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大深度-Maximum-Depth-of-Binary-Tree"><a href="#最大深度-Maximum-Depth-of-Binary-Tree" class="headerlink" title="最大深度 (Maximum Depth of Binary Tree)"></a>最大深度 (Maximum Depth of Binary Tree)</h4><p>使用<strong>递归</strong>（深度优先搜索）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证二叉搜索树-Validate-Binary-Search-Tree"><a href="#验证二叉搜索树-Validate-Binary-Search-Tree" class="headerlink" title="验证二叉搜索树 (Validate Binary Search Tree)"></a>验证二叉搜索树 (Validate Binary Search Tree)</h4><p>使用<strong>递归</strong>或<strong>中序遍历</strong>。二叉搜索树的中序遍历结果是升序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查当前节点的值是否在有效范围内</span></span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归检查左右子树，并缩小有效范围</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(node.left, min, node.val) &amp;&amp; isValidBST(node.right, node.val, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="最大子数组和-Maximum-Subarray-Sum"><a href="#最大子数组和-Maximum-Subarray-Sum" class="headerlink" title="最大子数组和 (Maximum Subarray Sum)"></a>最大子数组和 (Maximum Subarray Sum)</h4><p>使用<strong>动态规划</strong> (Kadane’s algorithm)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSoFar</span> <span class="operator">=</span> nums[<span class="number">0</span>]; <span class="comment">// 迄今为止的最大和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxEndingHere</span> <span class="operator">=</span> nums[<span class="number">0</span>]; <span class="comment">// 以当前位置结尾的最大和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// maxEndingHere 的值是：(当前元素) 或 (当前元素 + 之前的最大和)</span></span><br><span class="line">            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);</span><br><span class="line">            maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两数相加-Large-Number-Addition"><a href="#两数相加-Large-Number-Addition" class="headerlink" title="两数相加 (Large Number Addition)"></a>两数相加 (Large Number Addition)</h4><p>将两个超长正整数字符串相加，模拟小学加法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit1</span> <span class="operator">=</span> (i &gt;= <span class="number">0</span>) ? num1.charAt(i--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit2</span> <span class="operator">=</span> (j &gt;= <span class="number">0</span>) ? num2.charAt(j--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> digit1 + digit2 + carry;</span><br><span class="line">            sb.append(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="位运算实现加法-Addition-with-Bitwise-Operators"><a href="#位运算实现加法-Addition-with-Bitwise-Operators" class="headerlink" title="位运算实现加法 (Addition with Bitwise Operators)"></a>位运算实现加法 (Addition with Bitwise Operators)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        <span class="type">int</span> carry;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算无进位的和（异或）</span></span><br><span class="line">            sum = a ^ b;</span><br><span class="line">            <span class="comment">// 计算进位（与&amp;左移）</span></span><br><span class="line">            carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全排列-Permutations"><a href="#全排列-Permutations" class="headerlink" title="全排列 (Permutations)"></a>全排列 (Permutations)</h4><p>使用<strong>回溯算法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BacktrackingProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrackPermute(result, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtrackPermute</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList, <span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempList.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrackPermute(result, tempList, nums, used);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子集-Subsets"><a href="#子集-Subsets" class="headerlink" title="子集 (Subsets)"></a>子集 (Subsets)</h4><p>使用<strong>回溯算法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BacktrackingProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrackSubsets(result, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtrackSubsets</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList, <span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrackSubsets(result, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跳台阶-Climbing-Stairs"><a href="#跳台阶-Climbing-Stairs" class="headerlink" title="跳台阶 (Climbing Stairs)"></a>跳台阶 (Climbing Stairs)</h4><p>这是经典的<strong>动态规划</strong>问题，与斐波那契数列类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现一个简单的-Trie-前缀树"><a href="#实现一个简单的-Trie-前缀树" class="headerlink" title="实现一个简单的 Trie (前缀树)"></a>实现一个简单的 Trie (前缀树)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    Map&lt;Character, TrieNode&gt; children;</span><br><span class="line">    <span class="type">boolean</span> isEndOfWord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        isEndOfWord = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            current = current.children.computeIfAbsent(c, k -&gt; <span class="keyword">new</span> <span class="title class_">TrieNode</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        current.isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!current.children.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.children.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!current.children.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.children.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转链表-II-Reverse-Linked-List-II"><a href="#反转链表-II-Reverse-Linked-List-II" class="headerlink" title="反转链表 II (Reverse Linked List II)"></a>反转链表 II (Reverse Linked List II)</h4><p>反转链表从位置 <code>m</code> 到 <code>n</code> 的部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre.next; <span class="comment">// 移动到反转部分的前一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next; <span class="comment">// 反转部分的起始节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">then</span> <span class="operator">=</span> start.next; <span class="comment">// 待反转的第二个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">            start.next = then.next;</span><br><span class="line">            then.next = pre.next;</span><br><span class="line">            pre.next = then;</span><br><span class="line">            then = start.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LRU-缓存-LRU-Cache"><a href="#LRU-缓存-LRU-Cache" class="headerlink" title="LRU 缓存 (LRU Cache)"></a>LRU 缓存 (LRU Cache)</h4><p>使用 <code>LinkedHashMap</code> 可以非常方便地实现 LRU 缓存，因为它本身就维护了插入顺序或访问顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity, <span class="number">0.75f</span>, <span class="literal">true</span>); <span class="comment">// true 表示按访问顺序排序</span></span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="comment">// 当容量超过限制时，自动移除最老的（最久未访问的）条目</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getOrDefault(key, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断回文链表-Palindrome-Linked-List"><a href="#判断回文链表-Palindrome-Linked-List" class="headerlink" title="判断回文链表 (Palindrome Linked List)"></a>判断回文链表 (Palindrome Linked List)</h4><p>可以使用快慢指针找到中点，然后反转后半部分，最后比较两部分是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 快慢指针找中点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转后半部分</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">secondHalf</span> <span class="operator">=</span> reverseList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 比较前半部分和反转后的后半部分</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">firstHalf</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (secondHalf != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstHalf.val != secondHalf.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            firstHalf = firstHalf.next;</span><br><span class="line">            secondHalf = secondHalf.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextTemp</span> <span class="operator">=</span> current.next;</span><br><span class="line">            current.next = prev;</span><br><span class="line">            prev = current;</span><br><span class="line">            current = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ReadWriteLock-1"><a href="#ReadWriteLock-1" class="headerlink" title="ReadWriteLock"></a><code>ReadWriteLock</code></h3><p><code>ReadWriteLock</code> 允许多个线程同时进行读操作，但只允许一个线程进行写操作，从而提高读多写少的场景下的并发性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;初始数据&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作：允许多个线程同时访问</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在读取数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作：同一时刻只能有一个线程访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String newData)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在写入数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h3><p><code>CountDownLatch</code> 允许一个线程等待，直到其他线程都完成了某项工作。它就像一个倒计时器，一旦计数为零，等待的线程就会被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 创建一个计数器，初始值为 5</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(workerCount);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：启动 &quot;</span> + workerCount + <span class="string">&quot; 个工作线程...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 开始执行任务...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">2000</span>)); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 任务完成。&quot;</span>);</span><br><span class="line">                    latch.countDown(); <span class="comment">// 任务完成后，计数器减 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：等待所有工作线程完成...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 阻塞主线程，直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：所有工作线程已完成，继续执行下一步。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CyclicBarrier-1"><a href="#CyclicBarrier-1" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code> 允许一组线程在到达一个共同的屏障点后，再一起继续执行。它就像赛跑的起跑线，所有选手都准备好后，发令枪才响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">runnerCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 创建一个屏障，当 3 个线程都到达时，执行一个屏障动作</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(runnerCount, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n所有赛跑者都已就位，发令枪响！\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(runnerCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; runnerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">runnerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;赛跑者 &quot;</span> + runnerId + <span class="string">&quot; 正在走向起跑线...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">3000</span>)); <span class="comment">// 模拟准备时间</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;赛跑者 &quot;</span> + runnerId + <span class="string">&quot; 到达起跑线，准备就绪。&quot;</span>);</span><br><span class="line">                    barrier.await(); <span class="comment">// 线程在此处等待，直到所有线程都到达</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;赛跑者 &quot;</span> + runnerId + <span class="string">&quot; 开始跑步！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Semaphore-1"><a href="#Semaphore-1" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h3><p><code>Semaphore</code>（信号量）用来控制对某个资源的并发访问数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 停车场最多允许 3 辆车停放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">int</span> carId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;汽车 &quot;</span> + carId + <span class="string">&quot; 正在寻找车位...&quot;</span>);</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">            System.out.println(<span class="string">&quot;汽车 &quot;</span> + carId + <span class="string">&quot; 成功进入停车场。&quot;</span>);</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">3000</span>)); <span class="comment">// 模拟停车时间</span></span><br><span class="line">            System.out.println(<span class="string">&quot;汽车 &quot;</span> + carId + <span class="string">&quot; 离开停车场。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SemaphoreDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SemaphoreDemo</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>); <span class="comment">// 10 辆车</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">carId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; demo.park(carId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="死锁预防-按锁顺序"><a href="#死锁预防-按锁顺序" class="headerlink" title="死锁预防 (按锁顺序)"></a>死锁预防 (按锁顺序)</h3><p>通过<strong>资源有序分配</strong>来打破死锁的<strong>循环等待</strong>条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockPrevention</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 1: 已获得 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 1: 已获得 lockB。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 两个线程都按相同的顺序（先 A 后 B）获取锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 2: 已获得 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 2: 已获得 lockB。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockPrevention</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockPrevention</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadOne, <span class="string">&quot;Thread-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadTwo, <span class="string">&quot;Thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程池异常"><a href="#线程池异常" class="headerlink" title="线程池异常"></a>线程池异常</h3><p>使用 <code>Future.get()</code> 或在任务中捕获异常来处理线程池中任务抛出的异常。<code>execute()</code> 方法无法直接捕获异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPoolExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交一个会抛出运行时异常的任务</span></span><br><span class="line">        Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;这是一个模拟的任务执行异常。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取任务结果来捕获异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;捕获到任务执行异常：&quot;</span> + e.getCause().getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 execute() 提交任务，异常会被吞掉，除非自定义 UncaughtExceptionHandler</span></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;另一个任务开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;这个异常会被吞掉。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ThreadLocal-1"><a href="#ThreadLocal-1" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p><code>ThreadLocal</code> 为每个线程提供了独立的变量副本，实现了数据隔离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAndPrint</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        threadLocal.set(value); <span class="comment">// 设置当前线程的变量副本</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的变量值: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadLocal.remove(); <span class="comment">// 最佳实践：使用完后移除，防止内存泄漏</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 A 的数据&quot;</span>), <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 B 的数据&quot;</span>), <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a><code>LockSupport</code></h3><p><code>LockSupport.park()</code> 和 <code>LockSupport.unpark()</code> 提供了更灵活的线程阻塞和唤醒机制，类似于 <code>wait()</code> 和 <code>notify()</code>，但不需要依赖锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockSupportDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;工作线程: 任务准备就绪，即将阻塞...&quot;</span>);</span><br><span class="line">            LockSupport.park(); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            System.out.println(<span class="string">&quot;工作线程: 被唤醒，继续执行。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        workerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 确保工作线程已执行 park()</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 唤醒工作线程。&quot;</span>);</span><br><span class="line">        LockSupport.unpark(workerThread); <span class="comment">// 唤醒指定线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程通信-按顺序打印"><a href="#线程通信-按顺序打印" class="headerlink" title="线程通信 (按顺序打印)"></a>线程通信 (按顺序打印)</h3><p>使用 <code>wait()</code> 和 <code>notifyAll()</code> 实现三个线程按顺序打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SequentialPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 0: A, 1: B, 2: C</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String letter, <span class="type">int</span> expectedState)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (state != expectedState) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(letter);</span><br><span class="line">                state = (state + <span class="number">1</span>) % <span class="number">3</span>; <span class="comment">// 切换到下一个状态</span></span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SequentialPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequentialPrinter</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printA);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printB);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printC);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line"></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line">        threadC.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n打印完成。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="ThreadPoolExecutor-的七个参数"><a href="#ThreadPoolExecutor-的七个参数" class="headerlink" title="ThreadPoolExecutor 的七个参数"></a><code>ThreadPoolExecutor</code> 的七个参数</h4><ol><li><code>corePoolSize</code>: 核心线程数。线程池中常驻的线程数量，即使空闲也不会被销毁。</li><li><code>maximumPoolSize</code>: 最大线程数。当工作队列已满，且任务量继续增加时，线程池可以创建的最大线程数。</li><li><code>keepAliveTime</code>: 空闲线程存活时间。当线程数大于 <code>corePoolSize</code> 时，非核心线程的空闲存活时间。</li><li><code>unit</code>: <code>keepAliveTime</code> 的时间单位。</li><li><code>workQueue</code>: 工作队列。用于存放等待执行的任务，常用的有 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等。</li><li><code>threadFactory</code>: 线程工厂。用于创建新线程，可以自定义线程的名称、优先级等。</li><li><code>handler</code>: 拒绝策略。当线程池和工作队列都已满时，用于处理新来的任务，例如抛出异常、由调用者执行等。</li></ol><h4 id="手写一个自定义线程池"><a href="#手写一个自定义线程池" class="headerlink" title="手写一个自定义线程池"></a>手写一个自定义线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">5</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">60L</span>, <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), <span class="comment">// 工作队列容量为 10</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 默认线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略：由调用者线程执行</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 执行。&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>使用 <code>AtomicBoolean</code> 或 <code>AtomicReference</code> 解决并发问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicBooleanDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 确保只有一个线程执行初始化操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 只有当 initialized 为 false 时，才将其设置为 true 并执行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialized.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 开始执行初始化操作...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 初始化完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 初始化已被其他线程执行，跳过。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(AtomicBooleanDemo::initialize, <span class="string">&quot;Thread-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="volatile-内存语义"><a href="#volatile-内存语义" class="headerlink" title="volatile 内存语义"></a><code>volatile</code> 内存语义</h3><p><code>volatile</code> 确保了<strong>可见性</strong>和<strong>有序性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileMemorySemantics</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 可见性：当一个线程修改了 ready 的值，其他线程能立即看到最新值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriterThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            number = <span class="number">42</span>; <span class="comment">// 修改 number</span></span><br><span class="line">            ready = <span class="literal">true</span>; <span class="comment">// 修改 ready</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="comment">// 等待 ready 变为 true</span></span><br><span class="line">                <span class="comment">// 如果没有 volatile，这里可能会陷入死循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 有序性：写 volatile 变量（ready = true）之前的操作（number = 42）</span></span><br><span class="line">            <span class="comment">// 对其他线程都是可见的。保证了 number 的值是 42。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读取到的 number 值: &quot;</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WriterThread</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="中断机制-1"><a href="#中断机制-1" class="headerlink" title="中断机制"></a>中断机制</h3><p>一个线程通过响应 <code>interrupt()</code> 调用来正确停止自身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptibleThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; <span class="comment">// 检查中断标志</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程正在执行...&quot;</span>);</span><br><span class="line">                    <span class="comment">// sleep()、wait() 等方法会抛出 InterruptedException 并清除中断标志</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程被中断，即将退出...&quot;</span>);</span><br><span class="line">                    <span class="comment">// 重新设置中断标志，以便外层循环能正确退出</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">// 或者直接 break 或 return 退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程已优雅地退出。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        worker.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 发送中断信号。&quot;</span>);</span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h3><p><code>ConcurrentHashMap</code> 的并发原理是**分段锁（ 7）**或 <strong>CAS + Synchronized（ 8）</strong>，只对操作的桶进行锁定，大大提高了并发性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcurrentHashMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 10 个线程，每个线程向 map 中添加 1000 个键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key-&quot;</span> + (threadId * <span class="number">1000</span> + j);</span><br><span class="line">                    map.put(key, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终 map 的大小: &quot;</span> + map.size()); <span class="comment">// 期望值为 10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a><code>ForkJoinPool</code></h3><p><code>ForkJoinPool</code> 是一个用于分治任务的线程池，<code>RecursiveTask</code> 是可返回结果的分治任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 任务分解的阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SumTask</span><span class="params">(<span class="type">long</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务规模小于等于阈值，则直接计算</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，将任务分解成两个子任务</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, start, mid);</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, mid, end);</span><br><span class="line"></span><br><span class="line">            leftTask.fork(); <span class="comment">// 提交左子任务</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.compute(); <span class="comment">// 同步计算右子任务</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join(); <span class="comment">// 等待左子任务结果</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] array = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">1000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br><span class="line">        System.out.println(<span class="string">&quot;大数组的和为: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-语言基础"><a href="#1-语言基础" class="headerlink" title="1.  语言基础"></a>1.  语言基础</h3><h4 id="变量与数据类型"><a href="#变量与数据类型" class="headerlink" title="变量与数据类型"></a>变量与数据类型</h4><p> 的基本数据类型决定了变量可以存储的数据范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTypesDetailed</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 整数类型：默认为 int</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 占用 1 字节，-128 到 127</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 占用 2 字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100000</span>; <span class="comment">// 占用 4 字节</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">10000000000L</span>; <span class="comment">// 占用 8 字节，需要 L 或 l 后缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浮点类型：默认为 double</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.14f</span>; <span class="comment">// 占用 4 字节，需要 f 或 F 后缀</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.1415926535</span>; <span class="comment">// 占用 8 字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符类型</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 单个字符，占用 2 字节</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">65</span>; <span class="comment">// 也可以使用 ASCII 码或 Unicode</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1 和 c2 是否相等？ &quot;</span> + (c1 == c2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 布尔类型</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFun</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;学Java有趣吗？&quot;</span> + isFun);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p> 中，从小范围类型向大范围类型转换是<strong>自动</strong>的（隐式转换）；从大范围向小范围转换需要<strong>强制</strong>转换（显式转换），可能造成数据丢失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeCasting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 隐式转换：int -&gt; long</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">myInt</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">myLong</span> <span class="operator">=</span> myInt;</span><br><span class="line">        System.out.println(<span class="string">&quot;隐式转换后的 long 类型: &quot;</span> + myLong);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式转换：double -&gt; int</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">myDouble</span> <span class="operator">=</span> <span class="number">9.99</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">myInteger</span> <span class="operator">=</span> (<span class="type">int</span>) myDouble; <span class="comment">// 强制转换，小数部分被丢弃</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显式转换后的 int 类型: &quot;</span> + myInteger); <span class="comment">// 输出 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是存储<strong>固定大小</strong>同类型元素的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明并初始化一个整数数组</span></span><br><span class="line">        <span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 创建一个长度为 5 的数组</span></span><br><span class="line">        numbers[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        numbers[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明、初始化并赋值</span></span><br><span class="line">        String[] fruits = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有水果:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String fruit : fruits) &#123; <span class="comment">// 增强 for 循环</span></span><br><span class="line">            System.out.println(fruit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-面向对象编程-OOP"><a href="#2-面向对象编程-OOP" class="headerlink" title="2. 面向对象编程 (OOP)"></a>2. 面向对象编程 (OOP)</h3><h4 id="构造方法与方法重载"><a href="#构造方法与方法重载" class="headerlink" title="构造方法与方法重载"></a>构造方法与方法重载</h4><p><strong>构造方法</strong>是一种特殊方法，用于创建对象时初始化。<strong>方法重载</strong>是指在同一个类中，方法名相同但参数列表不同（参数类型、数量或顺序）的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;未知&quot;</span>, <span class="number">0</span>, <span class="string">&quot;000&quot;</span>); <span class="comment">// 调用本类的三参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = <span class="string">&quot;000&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法重载: 计算两个数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承、多态与抽象"><a href="#继承、多态与抽象" class="headerlink" title="继承、多态与抽象"></a>继承、多态与抽象</h4><p>继承实现代码复用，多态实现行为多样化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类：抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String brand; <span class="comment">// 子类可以访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vehicle</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;品牌是: &quot;</span> + brand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：继承 Vehicle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汽车正在路上行驶...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：继承 Vehicle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bicycle</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bicycle</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自行车正在骑行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphismDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;BMW&quot;</span>); <span class="comment">// 多态引用</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">myBicycle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bicycle</span>(<span class="string">&quot;Giant&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个方法调用，不同行为</span></span><br><span class="line">        myCar.run(); <span class="comment">// 输出 &quot;汽车正在路上行驶...&quot;</span></span><br><span class="line">        myBicycle.run(); <span class="comment">// 输出 &quot;自行车正在骑行...&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-核心类库"><a href="#3-核心类库" class="headerlink" title="3.  核心类库"></a>3.  核心类库</h3><p>好的，这次我们将把<strong>各种方法的使用代码</strong>直接嵌入到每个知识点的解释中，让您在学习概念的同时，就能看到具体的代码实现和效果。我们将专注于<strong>数组、字符串和集合</strong>这三大核心部分，把它们的创建、遍历、和各种常用方法的代码示例都清晰地展示出来。</p><hr><h3 id="1-数组（Array）"><a href="#1-数组（Array）" class="headerlink" title="1. 数组（Array）"></a>1. 数组（Array）</h3><p>数组是一种固定大小的、用于存储同类型元素的容器。</p><h4 id="创建和遍历"><a href="#创建和遍历" class="headerlink" title="创建和遍历"></a>创建和遍历</h4><p>这里展示两种最常见的创建数组的方式，并使用两种循环进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式一：声明并分配空间，系统赋默认值</span></span><br><span class="line">        <span class="type">int</span>[] intArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">// 创建一个包含3个整数的数组，默认值都是0</span></span><br><span class="line">        intArray[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        intArray[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">        intArray[<span class="number">2</span>] = <span class="number">30</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;数组 intArray 的第一个元素是: &quot;</span> + intArray[<span class="number">0</span>]); <span class="comment">// 输出: 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式二：声明并直接初始化</span></span><br><span class="line">        String[] stringArray = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;Java&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方式一：使用 for 循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 使用 for 循环遍历 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringArray.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stringArray[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + stringArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历方式二：使用增强 for 循环（更简洁）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 使用增强 for 循环遍历 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : stringArray) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;元素: &quot;</span> + element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Arrays-类的常用方法"><a href="#Arrays-类的常用方法" class="headerlink" title="Arrays 类的常用方法"></a><code>Arrays</code> 类的常用方法</h4><p><code>java.util.Arrays</code> 类提供了很多静态方法，方便我们对数组进行操作，比如排序、查找、复制等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysMethodExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 排序：Arrays.sort()</span></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后: &quot;</span> + Arrays.toString(numbers)); <span class="comment">// 输出: [1, 2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 查找：Arrays.binarySearch() (必须先排序)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素 6 的索引是: &quot;</span> + index); <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 填充：Arrays.fill()</span></span><br><span class="line">        <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        Arrays.fill(newArray, <span class="number">99</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;填充后: &quot;</span> + Arrays.toString(newArray)); <span class="comment">// 输出: [99, 99, 99, 99, 99]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 复制：Arrays.copyOf()</span></span><br><span class="line">        <span class="type">int</span>[] copiedArray = Arrays.copyOf(numbers, <span class="number">3</span>); <span class="comment">// 复制前3个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;复制前3个元素: &quot;</span> + Arrays.toString(copiedArray)); <span class="comment">// 输出: [1, 2, 4]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 比较：Arrays.equals()</span></span><br><span class="line">        <span class="type">int</span>[] anotherArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;两个数组是否相等: &quot;</span> + Arrays.equals(numbers, anotherArray)); <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-字符串（String）"><a href="#2-字符串（String）" class="headerlink" title="2. 字符串（String）"></a>2. 字符串（String）</h3><p><code>String</code> 是一个不可变的字符序列，这意味着一旦创建，它的内容就不能被修改。所有修改操作都会返回一个新的 <code>String</code> 对象。</p><h4 id="创建和常用方法"><a href="#创建和常用方法" class="headerlink" title="创建和常用方法"></a>创建和常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;  Java is a great language. &quot;</span>; <span class="comment">// 字面量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java is a great language.&quot;</span>); <span class="comment">// 使用 new 关键字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常用方法</span></span><br><span class="line">        <span class="comment">// 1. 获取长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str1.length();</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度: &quot;</span> + length); <span class="comment">// 输出: 29</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 访问字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> str1.charAt(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第3个字符是: &quot;</span> + firstChar); <span class="comment">// 输出: J</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 截取子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> str1.substring(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;截取子串: &quot;</span> + sub); <span class="comment">// 输出: is</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 查找位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str1.indexOf(<span class="string">&quot;great&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&#x27;great&#x27; 的索引: &quot;</span> + index); <span class="comment">// 输出: 11</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 判断</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> str1.contains(<span class="string">&quot;language&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含 &#x27;language&#x27;: &quot;</span> + contains); <span class="comment">// 输出: true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">startsWith</span> <span class="operator">=</span> str1.startsWith(<span class="string">&quot;  Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否以 &#x27;  Java&#x27; 开头: &quot;</span> + startsWith); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 替换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">replacedStr</span> <span class="operator">=</span> str1.replace(<span class="string">&quot;great&quot;</span>, <span class="string">&quot;wonderful&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;替换后: &quot;</span> + replacedStr); <span class="comment">// 输出:   Java is a wonderful language. </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 大小写转换和去空格</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">trimmedStr</span> <span class="operator">=</span> str1.trim();</span><br><span class="line">        System.out.println(<span class="string">&quot;去除首尾空格: &#x27;&quot;</span> + trimmedStr + <span class="string">&quot;&#x27;&quot;</span>); <span class="comment">// 输出: &#x27;Java is a great language.&#x27;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;转为大写: &quot;</span> + trimmedStr.toUpperCase());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 8. 分割和连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line">        String[] fruits = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;分割后: &quot;</span> + Arrays.toString(fruits)); <span class="comment">// 输出: [apple, banana, orange]</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">joinedString</span> <span class="operator">=</span> String.join(<span class="string">&quot; - &quot;</span>, fruits);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接后: &quot;</span> + joinedString); <span class="comment">// 输出: apple - banana - orange</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StringBuilder-和-StringBuffer"><a href="#StringBuilder-和-StringBuffer" class="headerlink" title="StringBuilder 和 StringBuffer"></a><code>StringBuilder</code> 和 <code>StringBuffer</code></h4><p>对于需要频繁修改字符串的场景，应使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 以提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 追加内容</span></span><br><span class="line">        sb.append(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;追加后: &quot;</span> + sb); <span class="comment">// 输出: Hello World</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 插入内容</span></span><br><span class="line">        sb.insert(<span class="number">6</span>, <span class="string">&quot;Beautiful &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;插入后: &quot;</span> + sb); <span class="comment">// 输出: Hello Beautiful World</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 删除内容</span></span><br><span class="line">        sb.delete(<span class="number">6</span>, <span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + sb); <span class="comment">// 输出: Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-集合（Collections）"><a href="#3-集合（Collections）" class="headerlink" title="3. 集合（Collections）"></a>3. 集合（Collections）</h3><p>Java 集合框架提供了强大的数据结构来存储和操作对象。</p><h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a><strong>List</strong>（列表）</h4><p><code>List</code> 是一种有序、可重复的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 ArrayList（查询快）</span></span><br><span class="line">        List&lt;String&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        fruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 添加元素</span></span><br><span class="line">        fruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        fruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 允许重复</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;列表元素: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Banana, Apple]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个元素: &quot;</span> + fruits.get(<span class="number">0</span>)); <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;列表大小: &quot;</span> + fruits.size());</span><br><span class="line"></span><br><span class="line">        fruits.set(<span class="number">1</span>, <span class="string">&quot;Grape&quot;</span>); <span class="comment">// 替换第二个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;替换后: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Grape, Apple]</span></span><br><span class="line"></span><br><span class="line">        fruits.remove(<span class="number">1</span>); <span class="comment">// 删除第二个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Apple]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Set（集）"><a href="#Set（集）" class="headerlink" title="Set（集）"></a><strong>Set</strong>（集）</h4><p><code>Set</code> 是一种无序、不可重复的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashSet</span></span><br><span class="line">        Set&lt;String&gt; uniqueFruits = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 添加重复元素，会失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;集合元素: &quot;</span> + uniqueFruits); <span class="comment">// 输出: [Apple, Banana] (顺序不定)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">containsBanana</span> <span class="operator">=</span> uniqueFruits.contains(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含 &#x27;Banana&#x27;: &quot;</span> + containsBanana); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">        uniqueFruits.remove(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + uniqueFruits); <span class="comment">// 输出: [Apple]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Map（映射）"><a href="#Map（映射）" class="headerlink" title="Map（映射）"></a><strong>Map</strong>（映射）</h4><p><code>Map</code> 存储键值对，键是唯一的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap</span></span><br><span class="line">        Map&lt;String, Integer&gt; studentScores = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        studentScores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">95</span>); <span class="comment">// 添加键值对</span></span><br><span class="line">        studentScores.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">88</span>);</span><br><span class="line">        studentScores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">100</span>); <span class="comment">// 键已存在，会覆盖旧值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Alice 的分数: &quot;</span> + studentScores.get(<span class="string">&quot;Alice&quot;</span>)); <span class="comment">// 输出: 100</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历 Map 的三种方式</span></span><br><span class="line">        <span class="comment">// 方式一：遍历键集</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历键集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : studentScores.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名: &quot;</span> + name + <span class="string">&quot;, 分数: &quot;</span> + studentScores.get(name));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式二：遍历值集</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历值集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer score : studentScores.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分数: &quot;</span> + score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式三：遍历键值对集 (Entry Set)，最常用且高效</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历键值对集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : studentScores.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名: &quot;</span> + entry.getKey() + <span class="string">&quot;, 分数: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式</title>
      <link href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Spring-Cloud-体系"><a href="#1-Spring-Cloud-体系" class="headerlink" title="1. Spring Cloud 体系"></a><strong>1. Spring Cloud 体系</strong></h4><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h5><p>Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的<strong>规范和解决方案的集合</strong>。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。</p><h5 id="Netflix-OSS-常用组件（部分进入维护模式）"><a href="#Netflix-OSS-常用组件（部分进入维护模式）" class="headerlink" title="Netflix OSS 常用组件（部分进入维护模式）"></a><strong>Netflix OSS 常用组件（部分进入维护模式）</strong></h5><ul><li><strong>服务注册与发现 (Service Discovery): Eureka</strong><ul><li><strong>作用</strong>: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。</li><li><strong>使用</strong>: 服务端添加 <code>spring-cloud-starter-netflix-eureka-server</code> 依赖，并使用 <code>@EnableEurekaServer</code> 注解。客户端添加 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖，并配置 Eureka Server 地址。</li></ul></li><li><strong>服务调用与负载均衡 (RPC &amp; Load Balancing): OpenFeign + Ribbon</strong><ul><li><strong>作用</strong>: Feign 让远程服务调用变得像调用本地方法一样简单。开发者只需定义一个接口，并使用 <code>@FeignClient</code> 注解，即可完成对远程服务的调用。Ribbon（现已被 Spring Cloud LoadBalancer 替代）则提供了客户端负载均衡能力，当从 Eureka 获取到多个服务实例地址时，Ribbon 会根据配置的策略（如轮询、随机）选择一个实例进行调用。</li><li><strong>使用</strong>: 添加 <code>spring-cloud-starter-openfeign</code> 依赖，在启动类上加 <code>@EnableFeignClients</code>，创建接口并使用 <code>@FeignClient(&quot;service-name&quot;)</code> 注解。</li></ul></li><li><strong>熔断与降级 (Circuit Breaker): Hystrix</strong><ul><li><strong>作用</strong>: 当某个下游服务出现故障或响应缓慢时，为了防止故障在系统中蔓延（即“服务雪崩”），熔断器会快速失败，暂时切断对该服务的调用。同时，可以执行一个预定义的降级逻辑（Fallback），例如返回一个缓存的、默认的或友好的提示信息。</li><li><strong>状态</strong>: Hystrix 已进入维护模式，官方推荐使用 Resilience4j 或其他替代方案。</li></ul></li><li><strong>API 网关 (API Gateway): Zuul</strong><ul><li><strong>作用</strong>: 作为系统的统一入口，API 网关负责请求路由、协议转换、权限校验、流量控制、日志监控等。所有外部请求都先经过网关，再由网关分发到后端的各个微服务。</li><li><strong>状态</strong>: Zuul 1.x 已进入维护模式，官方推荐使用 Spring Cloud Gateway。</li></ul></li></ul><hr><h5 id="Spring-Cloud-Alibaba-详解"><a href="#Spring-Cloud-Alibaba-详解" class="headerlink" title="Spring Cloud Alibaba 详解"></a><strong>Spring Cloud Alibaba 详解</strong></h5><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案，是 Spring Cloud 体系的重要实现。它集成了阿里巴巴开源的优秀组件，为开发者提供了更符合国内技术生态的选择。</p><ul><li><strong>服务注册与发现 &amp; 分布式配置中心: Nacos</strong><ul><li><strong>作用</strong>: Nacos (Naming and Configuration Service) 是一个功能丰富的平台，完美整合了<strong>服务注册发现</strong>和<strong>配置管理</strong>两大核心功能。<ul><li><strong>服务发现</strong>: 与 Eureka 类似，提供服务注册、发现和健康检查。但 Nacos 支持基于 DNS 和 RPC 的服务发现，并提供更实时的健康检查机制。</li><li><strong>配置管理</strong>: 可以作为分布式配置中心，对所有微服务的配置进行集中化管理。支持配置的热更新，即修改配置后无需重启服务即可生效。还支持配置的版本管理、灰度发布等高级功能。</li></ul></li><li><strong>使用</strong>:<ol><li>引入 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 和 <code>spring-cloud-starter-alibaba-nacos-config</code> 依赖。</li><li>在 <code>bootstrap.properties</code> (或 <code>.yml</code>) 文件中配置 Nacos 服务器地址和应用名。</li><li>使用 <code>@Value</code> 或 <code>@ConfigurationProperties</code> 注解即可动态获取和刷新配置。</li></ol></li></ul></li><li><strong>熔断、降级与流量控制: Sentinel</strong><ul><li><strong>作用</strong>: Sentinel 是面向分布式服务架构的“流量的守护者”，以流量为切入点，从<strong>流量控制、熔断降级、系统负载保护</strong>等多个维度保护服务的稳定性。相较于 Hystrix，Sentinel 功能更强大，提供了可视化的监控和配置平台，并且支持热点参数限流等精细化控制。</li><li><strong>核心概念</strong>:<ul><li><strong>资源 (Resource)</strong>: Sentinel 中一切皆资源，可以是一个方法、一段代码或一个服务 URL。</li><li><strong>规则 (Rule)</strong>: 定义如何保护资源，包括流控规则、降级规则、系统保护规则等。</li></ul></li><li><strong>使用</strong>:<ol><li>引入 <code>spring-cloud-starter-alibaba-sentinel</code> 依赖。</li><li>配置 Sentinel 控制台地址。</li><li>通过 <code>@SentinelResource</code> 注解来定义资源，并指定 Fallback (降级逻辑) 和 BlockHandler (流控&#x2F;熔断逻辑)。</li></ol></li></ul></li><li><strong>分布式事务解决方案: Seata</strong><ul><li><strong>作用</strong>: Seata 是一个开源的分布式事务解决方案，提供了高性能且易于使用的分布式事务服务。它支持多种事务模式，包括 AT（自动补偿）、TCC、Saga 和 XA 模式，旨在解决微服务架构下的数据一致性问题。</li><li><strong>使用</strong>: 引入 <code>spring-cloud-starter-alibaba-seata</code> 依赖，配置 Seata Server 地址，并使用 <code>@GlobalTransactional</code> 注解开启全局事务。</li></ul></li></ul><hr><h4 id="2-分布式ID：雪花算法（Snowflake）"><a href="#2-分布式ID：雪花算法（Snowflake）" class="headerlink" title="2. 分布式ID：雪花算法（Snowflake）"></a><strong>2. 分布式ID：雪花算法（Snowflake）</strong></h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>Snowflake 是 Twitter 开源的一种分布式 ID 生成算法，它能生成一个 64 位的 <code>long</code> 型数字作为全局唯一 ID。这个 64 位的 ID 由四部分构成：</p><ul><li><strong>1位符号位</strong>: 最高位，固定为0，表示正数，无实际意义。</li><li><strong>41位时间戳 (Timestamp)</strong>: 精确到毫秒级，是 <code>(当前时间戳 - 起始时间戳)</code> 的差值。41位可以表示 (241−1) 毫秒，大约可以使用 69 年。</li><li><strong>10位工作机器ID (Worker ID)</strong>: 这 10 位可以被灵活划分，例如前 5 位代表数据中心 ID (Datacenter ID)，后 5 位代表机器 ID (Machine ID)。这样总共可以支持 210&#x3D;1024 台机器。</li><li><strong>12位序列号 (Sequence)</strong>: 表示在同一毫秒内，同一台机器上生成的 ID 序列号。12位意味着每台机器每毫秒可以生成 212&#x3D;4096 个不同的 ID。</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h5><ul><li><strong>全局唯一</strong>: 通过时间戳、机器 ID 和序列号的组合，可以保证在分布式环境下的 ID 唯一性。</li><li><strong>趋势递增</strong>: 由于时间戳在高位，所以生成的 ID 整体上是按时间趋势递增的，这对于数据库索引（特别是 B+树）非常友好，可以减少页分裂，提高插入性能。</li><li><strong>高性能</strong>: ID 在本地生成，不依赖任何外部服务（如数据库或 Redis），生成效率极高。</li><li><strong>高可用</strong>: 算法本身不依赖网络，部署简单，具有很高的可用性。</li></ul><h5 id="面试题：“雪花算法有时钟回拨问题，如何解决？”"><a href="#面试题：“雪花算法有时钟回拨问题，如何解决？”" class="headerlink" title="面试题：“雪花算法有时钟回拨问题，如何解决？”"></a><strong>面试题：“雪花算法有时钟回拨问题，如何解决？”</strong></h5><p>回答要点:</p><p>时钟回拨是指服务器时间被同步到一个过去的时间点。如果算法不做处理，可能会生成重复的 ID。解决方案通常是：在生成 ID 时，记录上一次生成 ID 时所使用的时间戳。当发现当前时间戳小于上次记录的时间戳时，就意味着发生了时钟回拨。</p><ul><li><strong>方案一（拒绝服务）</strong>: 直接抛出异常，拒绝生成 ID，等待时钟恢复正常。这种方案简单，但会暂时影响可用性，适合对 ID 连续性要求不高的场景。</li><li><strong>方案二（等待追赶）</strong>: 如果回拨幅度很小（比如几毫秒），程序可以 <code>while(currentTime &lt; lastTimestamp)</code> 这样自旋等待，直到当前时间追赶上上次的时间戳。这会造成短暂的线程阻塞。</li><li><strong>方案三（使用备用位）</strong>: 一些改进版的雪花算法会预留几位作为扩展位，当发生时钟回拨时，在这几位上做自增，从而在短时间回拨内仍能生成不同的 ID。（这种方案实现较为复杂）</li><li><strong>业界实践（美团 Leaf）</strong>: 在发生时钟回拨时，切换到另一种备用 ID 生成策略（如号段模式），或者直接报错。</li></ul><hr><h4 id="3-RBAC（基于角色的访问控制）"><a href="#3-RBAC（基于角色的访问控制）" class="headerlink" title="3. RBAC（基于角色的访问控制）"></a><strong>3. RBAC（基于角色的访问控制）</strong></h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>RBAC (Role-Based Access Control) 是一种主流且灵活的权限管理模型。它的核心思想是在 <strong>用户 (User)</strong> 和 <strong>权限 (Permission)</strong> 之间引入一个中间层——<strong>角色 (Role)</strong>。权限不再直接授予用户，而是授予角色；然后将角色分配给用户。这样，用户与权限实现了解耦，当需要修改大量用户的权限时，只需修改他们共同拥有的角色的权限即可，极大地简化了权限管理和维护。</p><h5 id="核心三要素"><a href="#核心三要素" class="headerlink" title="核心三要素"></a><strong>核心三要素</strong></h5><ul><li><strong>用户 (User)</strong>: 系统操作的主体。</li><li><strong>角色 (Role)</strong>: 权限的集合，代表了一组特定的职责或身份，如“管理员”、“文章编辑”、“普通会员”。</li><li><strong>权限 (Permission)</strong>: 对系统中特定资源进行特定操作的许可。通常用一个字符串表示，如 <code>user:create</code>、<code>order:delete</code>、<code>article:publish</code>。</li></ul><h5 id="面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”"><a href="#面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”" class="headerlink" title="面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”"></a><strong>面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”</strong></h5><p>回答要点:</p><p>一个基础的 RBAC 模型至少需要五张表：</p><ul><li><strong>用户表 (t_user)</strong>: 存储用户信息。<ul><li><code>user_id</code> (主键), <code>username</code>, <code>password</code>, …</li></ul></li><li><strong>角色表 (t_role)</strong>: 存储角色信息。<ul><li><code>role_id</code> (主键), <code>role_name</code> (角色名, 如”管理员”), <code>role_key</code> (角色标识, 如”admin”), …</li></ul></li><li><strong>权限表 (t_permission)</strong>: 存储具体的权限点信息。<ul><li><code>permission_id</code> (主键), <code>permission_name</code> (权限名称, 如“新增用户”), <code>permission_code</code> (权限标识, 如 <code>user:add</code>), <code>parent_id</code> (用于菜单层级), …</li></ul></li><li><strong>用户-角色关联表 (t_user_role)</strong>: 存储用户和角色的多对多关系。<ul><li><code>user_id</code> (外键), <code>role_id</code> (外键)。(主键是 <code>user_id</code> 和 <code>role_id</code> 的联合主键)</li></ul></li><li><strong>角色-权限关联表 (t_role_permission)</strong>: 存储角色和权限的多对多关系。<ul><li><code>role_id</code> (外键), <code>permission_id</code> (外键)。(主键是 <code>role_id</code> 和 <code>permission_id</code> 的联合主键)</li></ul></li></ul><hr><h4 id="4-Redis-进阶详解"><a href="#4-Redis-进阶详解" class="headerlink" title="4. Redis 进阶详解"></a><strong>4. Redis 进阶详解</strong></h4><h5 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h5><ul><li><strong>基于内存</strong>: Redis 是一个内存数据结构存储系统，所有数据都存放在内存中，因此读写速度极快。</li><li><strong>单线程模型</strong>: Redis 的核心网络模型处理客户端请求是单线程的。这避免了多线程环境下的上下文切换和锁竞争带来的开销。（注意：Redis 6.0 之后引入了多线程来处理 I&#x2F;O，但执行命令的核心仍然是单线程）。</li><li><strong>IO多路复用</strong>: 单线程能实现高性能的关键在于它使用了 IO 多路复用技术（如 Linux 下的 epoll）。该技术允许单个线程同时监听多个网络连接上的 IO 事件，当某个连接准备好读或写时，才去处理它，极大地提高了并发处理能力。</li><li><strong>丰富的数据类型</strong>: 支持 String, Hash, List, Set, Sorted Set, Bitmap, HyperLogLog, GEO 等多种数据结构。</li></ul><h5 id="缓存三大问题与解决方案"><a href="#缓存三大问题与解决方案" class="headerlink" title="缓存三大问题与解决方案"></a><strong>缓存三大问题与解决方案</strong></h5><ul><li><strong>缓存穿透</strong>:<ul><li><strong>问题</strong>: 客户端查询一个数据库和缓存中<strong>都</strong>不存在的数据。这导致每次请求都会绕过缓存，直接打到数据库上，当有大量此类请求时，会给数据库带来巨大压力。</li><li><strong>解决</strong>:<ol><li><strong>缓存空对象</strong>: 当从数据库查询不到数据时，也在缓存中存入一个特殊的空值（如 <code>null</code> 或特定字符串），并设置一个较短的过期时间。</li><li><strong>布隆过滤器 (Bloom Filter)</strong>: 在访问缓存之前，先通过布隆过滤器判断 key 是否<strong>可能</strong>存在。布隆过滤器可以高效地判断一个元素<strong>一定不存在</strong>，从而在第一层就拦截掉大量无效请求。</li></ol></li></ul></li><li><strong>缓存击穿</strong>:<ul><li><strong>问题</strong>: 某个<strong>热点 Key</strong> 在某一时刻突然失效，而此时恰好有大量的并发请求访问这个 Key，这些请求会同时穿透缓存，直接打到数据库上，可能导致数据库瞬间崩溃。</li><li><strong>解决</strong>:<ol><li><strong>设置热点 Key 永不过期</strong>: 对于一些访问极其频繁且数据相对固定的热点数据，可以考虑不设置过期时间，通过后台任务定时更新。</li><li><strong>使用分布式锁</strong>: 在查询数据库之前，先获取一个该 Key 对应的分布式锁。只有第一个获取到锁的线程才能去查询数据库并回写缓存，其他线程则等待或直接返回。</li></ol></li></ul></li><li><strong>缓存雪崩</strong>:<ul><li><strong>问题</strong>: 大量的缓存 Key 在<strong>同一时间集中失效</strong>（例如，在应用启动时缓存了大量数据，并设置了相同的过期时间），导致所有请求都瞬间涌向数据库，造成数据库压力剧增甚至宕机。</li><li><strong>解决</strong>:<ol><li><strong>过期时间加随机值</strong>: 在设置缓存的过期时间时，在一个基础时间上增加一个随机数，使得 Key 的失效时间点尽可能分散。</li><li><strong>多级缓存</strong>: 建立多级缓存体系，如 Nginx 缓存 + Redis 缓存 + JVM 本地缓存（Caffeine&#x2F;Guava Cache）。</li><li><strong>熔断降级</strong>: 使用 Hystrix 或 Sentinel 等组件，当检测到数据库压力过大时，进行熔断或降级处理，暂时不访问数据库，返回一个默认值或提示信息。</li></ol></li></ul></li></ul><hr><h4 id="5-消息队列（MQ）"><a href="#5-消息队列（MQ）" class="headerlink" title="5. 消息队列（MQ）"></a><strong>5. 消息队列（MQ）</strong></h4><h5 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a><strong>核心作用</strong></h5><ul><li><strong>异步 (Asynchronous)</strong>: 将耗时的操作（如发送邮件、生成报表）作为消息放入 MQ，主流程可以立即返回，无需等待这些操作完成，从而提高系统的响应速度和吞吐量。</li><li><strong>解耦 (Decoupling)</strong>: 生产者和消费者之间通过 MQ 进行通信，无需直接相互依赖。任何一方的修改、宕机或升级都不会影响到另一方，增强了系统的灵活性和可维护性。</li><li><strong>削峰 (Peak Shaving)</strong>: 在秒杀、大促等高并发场景下，将瞬时涌入的大量请求暂存在 MQ 中，下游的消费者系统可以按照自己的处理能力，平稳地从 MQ 中拉取并处理请求，避免了流量洪峰直接冲垮下游服务。</li></ul><h5 id="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"><a href="#面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”" class="headerlink" title="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"></a><strong>面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”</strong></h5><p><strong>回答要点</strong>:</p><ul><li><strong>消息丢失 (Message Loss)</strong>:<ul><li><strong>问题</strong>: 消息从生产者发出后，由于网络或 MQ 服务故障，未能成功到达消费者。</li><li><strong>解决</strong>:<ol><li><strong>生产者端</strong>: 开启生产者的 <code>confirm</code> 或 <code>ack</code> 机制，确保消息被 MQ 成功接收。如果发送失败，可以进行重试。</li><li><strong>MQ 服务端</strong>: 对消息进行持久化，防止 MQ 宕机导致消息丢失（如 RabbitMQ 的持久化队列和消息，Kafka 的磁盘存储）。</li><li><strong>消费者端</strong>: 消费者在处理完业务逻辑后，再向 MQ 发送确认应答（<code>ack</code>）。如果处理过程中消费者宕机，MQ 没有收到 <code>ack</code>，会将该消息重新投递给其他消费者。</li></ol></li></ul></li><li><strong>重复消费 (Duplicate Consumption)</strong>:<ul><li><strong>问题</strong>: 由于网络抖动、消费者 <code>ack</code> 超时等原因，MQ 可能会重复投递同一条消息。</li><li><strong>解决</strong>: 核心是保证消费逻辑的<strong>幂等性 (Idempotence)</strong>。即多次执行同一个操作，结果都是相同的。实现方式有：<ol><li>在数据库中为业务操作创建一个<strong>唯一键</strong>，每次操作前先检查该唯一键是否存在。</li><li>使用一个全局唯一的<strong>业务 ID</strong>（如订单号），在处理消息前，先查询这个 ID 是否已经被处理过（例如，存入 Redis Set 或数据库）。</li></ol></li></ul></li><li><strong>消息堆积 (Message Backlog)</strong>:<ul><li><strong>问题</strong>: 生产者的生产速度远大于消费者的消费速度，导致大量消息在 MQ 中积压，占用资源并可能导致消息超时丢失。</li><li><strong>解决</strong>:<ol><li><strong>水平扩展消费者</strong>: 增加消费者实例的数量，并行处理消息。这是最常用的方法。</li><li><strong>优化消费逻辑</strong>: 检查消费者代码，看是否有可以优化的慢操作（如 I&#x2F;O 密集型操作）。</li><li><strong>消息分片&#x2F;分区</strong>: 对 Topic 进行分区（Partitioning），让不同的消费者组处理不同的分区，提高并发度。</li><li><strong>增加预警监控</strong>: 对消息堆积数量设置阈值，达到阈值时及时告警，人工介入。</li></ol></li></ul></li></ul><hr><h4 id="6-分布式锁详解"><a href="#6-分布式锁详解" class="headerlink" title="6. 分布式锁详解"></a><strong>6. 分布式锁详解</strong></h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在分布式系统环境下，多个进程或服务器上的多个线程需要访问同一个共享资源时，为了保证数据的一致性和操作的原子性，需要一种机制来确保在同一时刻，只有一个客户端能够持有锁并访问该资源。</p><h5 id="实现方案对比"><a href="#实现方案对比" class="headerlink" title="实现方案对比"></a><strong>实现方案对比</strong></h5><table><thead><tr><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>基于数据库</strong></td><td>实现简单，直接利用数据库（如唯一索引、悲观锁 <code>for update</code>）。</td><td>性能开销大，有锁库锁表的风险，不可重入，不是阻塞锁，数据库单点故障问题。</td><td>并发度不高的简单场景。</td></tr><tr><td><strong>基于 ZooKeeper</strong></td><td>可靠性高，天然支持阻塞锁和可重入，解决死锁问题（临时节点），无锁过期问题，支持公平锁。</td><td>性能不如 Redis，实现复杂，依赖 ZK 集群。</td><td>对可靠性要求极高，且能容忍一定性能损耗的场景，如分布式协调。</td></tr><tr><td><strong>基于 Redis</strong></td><td>性能极高，实现相对简单，有成熟的框架 (Redisson) 可用。</td><td>可靠性相对 ZK 稍差，需要处理锁过期和业务未执行完的问题，非公平锁。</td><td>互联网高并发、对性能要求高的绝大多数场景。</td></tr></tbody></table><h5 id="基于-Redis-的实现进阶"><a href="#基于-Redis-的实现进阶" class="headerlink" title="基于 Redis 的实现进阶"></a><strong>基于 Redis 的实现进阶</strong></h5><ul><li><p>加锁的正确姿势:</p><p>使用 SET key value NX EX time 命令。</p><ul><li><p><code>SET key value</code>: 设置键值。<code>value</code> 通常是一个唯一的随机字符串（如 UUID），用于标识锁的持有者。</p></li><li><p><code>NX</code>: (if Not eXists)，确保只有在 key 不存在时才能设置成功，实现了“加锁”的原子性。</p></li><li><p>EX time: 设置一个自动过期时间（秒），防止因客户端宕机而导致死锁。</p><p>这三个参数必须在一个命令中执行，保证原子性。</p></li></ul></li><li><p><strong>解锁的正确姿势：Lua 脚本</strong></p><ul><li><p><strong>为什么需要 Lua</strong>: 解锁操作包含“判断”和“删除”两步：1. <code>GET</code> 锁的 <code>value</code>，判断是否与自己加锁时设置的随机字符串相等。2. 如果相等，则 <code>DEL</code> 锁。如果不用 Lua 脚本，在执行完第一步后，若该线程阻塞，此时锁恰好过期，另一个线程获取了锁，那么当原线程恢复执行第二步时，就会<strong>误删掉新线程的锁</strong>。</p></li><li><p><strong>Lua 脚本示例</strong>:</p><p>Lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 脚本接收两个参数：KEYS[1] 是锁的 key，ARGV[1] 是加锁时设置的唯一值</span><br><span class="line">if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><p>Lua 脚本可以确保多个命令在 Redis 服务端被原子性地执行，杜绝了上述问题。</p></li><li><p><strong>Redis 乐观锁：WATCH 命令</strong></p><ul><li><p><strong>作用</strong>: <code>WATCH</code> 命令可以监视一个或多个 key，如果在事务 <code>EXEC</code> 执行之前，任何一个被监视的 key 被其他命令修改了，那么整个事务将被取消，<code>EXEC</code> 返回 <code>nil</code>。</p></li><li><p><strong>原理</strong>: 这是一种<strong>检查后设置 (Check-And-Set, CAS)</strong> 的实现。它不是真正的加锁，而是在更新数据时检查数据是否被修改过。</p></li><li><p><strong>使用场景</strong>: 适用于<strong>读多写少</strong>的并发场景，可以减少锁的开销。例如，更新商品库存。</p><ol><li><p><code>WATCH stock_key</code> &#x2F;&#x2F; 监视库存</p></li><li><p><code>current_stock = GET stock_key</code> &#x2F;&#x2F; 获取当前库存</p></li><li><p>(在客户端代码中判断 <code>current_stock</code> 是否足够)</p></li><li><p><code>MULTI</code> &#x2F;&#x2F; 开启事务</p></li><li><p><code>SET stock_key new_stock</code> &#x2F;&#x2F; 准备更新库存</p></li><li><p>EXEC &#x2F;&#x2F; 执行事务</p><p>如果从 WATCH 到 EXEC 之间 stock_key 被其他客户端修改，EXEC 将失败，此时客户端需要重试整个操作。</p></li></ol></li></ul></li></ul><h5 id="面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”"><a href="#面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”" class="headerlink" title="面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”"></a><strong>面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”</strong></h5><p>回答要点:</p><p>这是分布式锁的一个经典问题，被称为锁的超时续期问题。</p><ul><li><strong>问题根源</strong>: 我们给锁设置了一个过期时间，比如 30 秒，但业务执行了 35 秒。在第 30 秒时锁会自动释放，其他线程就能获取到锁，导致并发问题。</li><li><strong>解决方案：“看门狗”(Watchdog)机制</strong>。<ul><li><strong>原理</strong>: 比如 Java 中的 Redisson 框架就内置了看门狗。当一个线程获取锁成功后，Redisson 会启动一个后台线程（看门狗），定期（例如每 10 秒）检查该线程是否还持有锁。如果持有，并且业务仍在执行，看门狗就会自动为这个锁<strong>延长过期时间</strong>（续期），比如再续 30 秒。这个过程会一直持续，直到业务执行完毕，线程主动释放锁，看门狗才会停止。</li><li><strong>总结</strong>: 看门狗机制通过后台线程自动续期，确保了在业务执行完成之前，锁不会因为超时而提前释放，从而保证了锁的可靠性。</li></ul></li></ul><hr><h4 id="7-分布式事务详解"><a href="#7-分布式事务详解" class="headerlink" title="7. 分布式事务详解"></a><strong>7. 分布式事务详解</strong></h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在微服务架构中，一个业务操作可能需要调用多个独立的服务来共同完成（例如，电商下单操作需要调用订单服务、库存服务、积分服务）。分布式事务旨在保证这些跨服务的数据库操作能够遵循 ACID 原则，要么全部成功，要么全部回滚，以确保数据的<strong>最终一致性</strong>。</p><h5 id="解决方案深入分析"><a href="#解决方案深入分析" class="headerlink" title="解决方案深入分析"></a><strong>解决方案深入分析</strong></h5><ul><li><strong>XA (2PC&#x2F;3PC)</strong>: 两阶段&#x2F;三阶段提交协议。<ul><li><strong>角色</strong>: 事务管理器 (Transaction Manager, TM) 和 资源管理器 (Resource Manager, RM)。</li><li><strong>流程 (2PC)</strong>:<ol><li><strong>准备阶段 (Prepare)</strong>: TM 通知所有 RM 准备提交，RM 执行本地事务并锁定资源，但不提交，然后向 TM 报告准备就绪。</li><li><strong>提交&#x2F;回滚阶段 (Commit&#x2F;Rollback)</strong>: 如果所有 RM 都准备就绪，TM 通知所有 RM 提交；否则，通知所有 RM 回滚。</li></ol></li><li><strong>评价</strong>: 是一种<strong>强一致性</strong>的方案，但协议复杂，性能差，同步阻塞模型会长时间锁定资源，且协调器存在单点故障风险，在互联网高并发场景下<strong>很少使用</strong>。</li></ul></li><li><strong>TCC (Try-Confirm-Cancel)</strong>: 补偿型事务。<ul><li><strong>核心</strong>: 是一种<strong>业务层面</strong>的柔性事务方案，对代码侵入性强。</li><li><strong>流程</strong>:<ol><li><strong>Try</strong>: 对业务资源进行<strong>检查和预留</strong>。例如，扣减库存操作，Try 阶段是冻结库存。</li><li><strong>Confirm</strong>: 如果所有服务的 Try 阶段都成功，则执行所有服务的 <strong>Confirm</strong> 操作，真正完成业务。例如，将冻结的库存真实扣减。</li><li><strong>Cancel</strong>: 如果任何一个服务的 Try 阶段失败，则执行所有已成功服务的 <strong>Cancel</strong> 操作，释放预留的资源。例如，解冻之前被冻结的库存。</li></ol></li><li><strong>评价</strong>: 性能较好，数据一致性高于可靠消息方案。但开发成本极高，需要为每个操作都编写 Try, Confirm, Cancel 三个幂等的方法。</li></ul></li><li><strong>Saga 模式</strong>: 长事务解决方案。<ul><li><strong>核心</strong>: 将一个大的分布式事务拆分成多个<strong>本地事务</strong>，每个本地事务都有一个对应的<strong>补偿操作</strong>。</li><li><strong>流程</strong>:<ul><li><strong>正向执行</strong>: Saga 协调器按顺序调用 T1, T2, T3…Tn。</li><li><strong>反向补偿</strong>: 如果 Ti 失败，Saga 会按相反顺序调用前面已成功事务的补偿操作 C(i-1)…C2, C1，进行回滚。</li></ul></li><li><strong>与 TCC 对比</strong>:<ul><li>TCC 有资源<strong>预留</strong>阶段，锁资源时间长；Saga 没有预留，直接提交本地事务，锁资源时间短。</li><li>TCC 的补偿是<strong>逆向操作</strong> (Cancel)；Saga 的补偿是<strong>反向操作</strong>。</li></ul></li><li><strong>评价</strong>: 适合于业务流程长、需要保证最终一致性的场景。同样对代码有侵入性，需要设计好每个子事务的补偿逻辑。</li></ul></li><li><strong>基于可靠消息的最终一致性 (常用)</strong>:<ul><li><strong>核心</strong>: 这是微服务架构中<strong>最常用</strong>的柔性事务方案。</li><li><strong>原理</strong>: 服务 A 在执行完本地事务后，发送一条消息到 MQ。服务 B 订阅该消息，消费消息并执行自己的本地事务。</li><li><strong>关键问题</strong>: 如何保证<strong>本地事务执行</strong>和<strong>消息发送</strong>的原子性？<ul><li><strong>事务消息 (RocketMQ 支持)</strong>: 生产者先发送一条“半消息”到 MQ，MQ 收到后不投递。然后生产者执行本地事务。如果事务成功，则向 MQ 发送确认，MQ 投递该消息；如果事务失败，则通知 MQ 删除该半消息。</li><li><strong>本地消息表</strong>: 业务操作和“待发送消息”记录在同一本地事务中。一个后台任务定时扫描这张表，将消息发送到 MQ，发送成功后更新表状态。</li></ul></li><li><strong>评价</strong>: 实现了服务间的解耦，性能高，吞吐量大。但它不保证数据的强一致性，只保证<strong>最终一致性</strong>，存在一个短暂的数据不一致状态窗口。需要处理好消息的可靠投递和幂等消费问题。</li></ul></li></ul><h3 id="Lua-脚本详解-在-Redis-中的应用"><a href="#Lua-脚本详解-在-Redis-中的应用" class="headerlink" title="Lua 脚本详解 (在 Redis 中的应用)"></a><strong>Lua 脚本详解 (在 Redis 中的应用)</strong></h3><h4 id="1-Lua-是什么？"><a href="#1-Lua-是什么？" class="headerlink" title="1. Lua 是什么？"></a><strong>1. Lua 是什么？</strong></h4><p>Lua 是一种轻量级、可扩展的脚本语言，被设计用于嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。它以其简洁的语法、高效的执行性能和极小的内存占用而闻名。</p><p>在 Redis 的上下文中，Lua 脚本提供了一种在 Redis 服务器端执行复杂逻辑的强大能力。</p><h4 id="2-为什么-Redis-要支持-Lua-脚本？"><a href="#2-为什么-Redis-要支持-Lua-脚本？" class="headerlink" title="2. 为什么 Redis 要支持 Lua 脚本？"></a><strong>2. 为什么 Redis 要支持 Lua 脚本？</strong></h4><ul><li><strong>原子性 (Atomicity)</strong>: 这是在 Redis 中使用 Lua 最核心的原因。Redis 会将整个 Lua 脚本作为一个单独的命令来执行，<strong>在脚本执行期间，不会有其他客户端的命令被插入执行</strong>。这完美地解决了需要组合多个 Redis 命令才能完成一个业务逻辑时，可能出现的竞态条件问题。例如前面提到的“判断锁并删除锁”的操作，如果分两步执行，就不是原子的，而封装在 Lua 脚本中就是原子的。</li><li><strong>减少网络开销</strong>: 对于需要多次与 Redis 交互的复杂操作，可以将所有逻辑封装在一个 Lua 脚本中，一次性发送给 Redis 服务器。客户端只需发送一次请求，而不是多次，这显著减少了客户端与服务器之间的网络往返时间（RTT），提升了性能。</li><li><strong>代码复用</strong>: 编写好的 Lua 脚本可以被缓存（通过 <code>SCRIPT LOAD</code> 命令生成一个 SHA1 校验和），之后客户端可以通过这个简短的 SHA1 校验和（使用 <code>EVALSHA</code> 命令）来调用脚本，避免了每次都发送完整的脚本内容。</li></ul><h4 id="3-如何在-Redis-中使用-Lua-脚本？"><a href="#3-如何在-Redis-中使用-Lua-脚本？" class="headerlink" title="3. 如何在 Redis 中使用 Lua 脚本？"></a><strong>3. 如何在 Redis 中使用 Lua 脚本？</strong></h4><p>通过 EVAL 或 EVALSHA 命令来执行。</p><p>EVAL script numkeys key [key …] arg [arg …]</p><ul><li><code>script</code>: 要执行的 Lua 脚本字符串。</li><li><code>numkeys</code>: 后面跟的 <code>key</code> 参数的数量。这有助于 Redis 正确地将参数区分为键名（<code>KEYS</code>）和普通参数（<code>ARGV</code>），这对于 Redis Cluster 模式下的路由至关重要。</li><li><code>key [key ...]</code>：脚本中要操作的 Redis 键，在 Lua 脚本中可以通过全局变量 <code>KEYS</code> table（例如 <code>KEYS[1]</code>）来访问。</li><li><code>arg [arg ...]</code>：传递给脚本的额外参数，在 Lua 脚本中可以通过全局变量 <code>ARGV</code> table（例如 <code>ARGV[1]</code>）来访问。</li></ul><p><strong>示例：实现一个安全的库存扣减</strong></p><p>Lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 脚本逻辑：检查库存是否充足，如果充足则扣减并返回1，否则返回0</span><br><span class="line">-- KEYS[1]: 库存的 key，例如 &quot;product:1001:stock&quot;</span><br><span class="line">-- ARGV[1]: 本次要扣减的数量</span><br><span class="line"></span><br><span class="line">local stock = tonumber(redis.call(&#x27;get&#x27;, KEYS[1]))</span><br><span class="line">local quantity = tonumber(ARGV[1])</span><br><span class="line"></span><br><span class="line">if stock &gt;= quantity then</span><br><span class="line">    redis.call(&#x27;decrby&#x27;, KEYS[1], quantity)</span><br><span class="line">    return 1</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这个脚本保证了“读取库存”和“扣减库存”两个操作的原子性，避免了在高并发下超卖的问题。</p><hr><h3 id="Token-认证机制详解"><a href="#Token-认证机制详解" class="headerlink" title="Token 认证机制详解"></a><strong>Token 认证机制详解</strong></h3><h4 id="1-Token-是什么？"><a href="#1-Token-是什么？" class="headerlink" title="1. Token 是什么？"></a><strong>1. Token 是什么？</strong></h4><p>Token（令牌）是在服务端生成的一串加密字符串，作为客户端进行请求的一个“凭证”。当用户第一次登录成功后，服务端会生成一个 Token 并返回给客户端。之后，客户端在每次请求需要身份认证的接口时，都需要在请求头（通常是 <code>Authorization</code> 字段）中携带这个 Token。服务端接收到请求后，会验证 Token 的有效性，如果验证通过，则处理该请求；否则，拒绝该请求。</p><p>一个典型的 Token 是 <strong>JWT (JSON Web Token)</strong>，它由三部分组成，用 <code>.</code> 分隔：</p><ul><li><strong>Header (头部)</strong>: 包含了令牌的类型（<code>typ</code>，即 JWT）和所使用的签名算法（<code>alg</code>，如 HMAC SHA256 或 RSA）。</li><li><strong>Payload (负载)</strong>: 包含了“声明 (claims)”，是存放实际需要传递的数据的地方。例如用户ID（<code>sub</code>）、签发时间（<code>iat</code>）、过期时间（<code>exp</code>）以及其他自定义的用户信息。<strong>注意：Payload 部分是 Base64 编码的，并非加密，因此不应存放敏感信息。</strong></li><li><strong>Signature (签名)</strong>: 对前两部分（Header 和 Payload）使用指定的算法和存储在服务端的密钥（secret）进行签名。这个签名的作用是<strong>防止数据被篡改</strong>。服务端收到 Token 后，会用同样的算法和密钥重新计算签名，并与 Token 中的签名进行比对，若一致，则说明 Token 未被篡改且是可信的。</li></ul><h4 id="2-Token-认证原理（工作流程）"><a href="#2-Token-认证原理（工作流程）" class="headerlink" title="2. Token 认证原理（工作流程）"></a><strong>2. Token 认证原理（工作流程）</strong></h4><ol><li><strong>登录</strong>: 用户使用用户名和密码发起登录请求。</li><li><strong>验证</strong>: 服务端验证用户的凭据是否正确。</li><li><strong>签发 Token</strong>: 验证成功后，服务端根据用户ID、角色等信息，结合密钥（secret），生成一个 Token。</li><li><strong>返回 Token</strong>: 服务端将生成的 Token 返回给客户端。</li><li><strong>存储 Token</strong>: 客户端（浏览器、App）将 Token 存储起来，通常放在 <code>localStorage</code>、<code>sessionStorage</code> 或 <code>HttpOnly</code> 的 Cookie 中。</li><li><strong>携带 Token 请求</strong>: 客户端在后续每次请求受保护的 API 时，都会在 HTTP 请求头的 <code>Authorization</code> 字段中附上 Token，格式通常为 <code>Bearer &lt;token&gt;</code>。</li><li><strong>验证 Token</strong>: 服务端收到请求后，从请求头中解析出 Token，然后：<ul><li>验证签名是否正确，确保 Token 未被篡改。</li><li>检查 Token 是否在有效期内（<code>exp</code> 声明）。</li><li>如果验证通过，则从 Payload 中获取用户信息，执行业务逻辑并返回结果。</li><li>如果验证失败，则返回 <code>401 Unauthorized</code> 错误。</li></ul></li></ol><h4 id="3-为什么使用-Token？（与-Session-的区别）"><a href="#3-为什么使用-Token？（与-Session-的区别）" class="headerlink" title="3. 为什么使用 Token？（与 Session 的区别）"></a><strong>3. 为什么使用 Token？（与 Session 的区别）</strong></h4><p>在 Web 开发早期，<code>Session-Cookie</code> 机制是主流。服务端在用户登录后创建一个 Session 对象存储在内存或 Redis 中，并生成一个 Session ID，通过 Cookie 返回给浏览器。浏览器后续请求会自动带上这个 Session ID，服务端根据 ID 找到对应的 Session 信息来识别用户。</p><p><strong>Token 机制相比 Session 机制，核心优势在于“无状态性 (Statelessness)”</strong>，这带来了以下好处：</p><table><thead><tr><th>特性对比</th><th>Session 机制</th><th>Token 机制</th><th>优势说明</th></tr></thead><tbody><tr><td><strong>状态存储</strong></td><td><strong>有状态 (Stateful)</strong>。Session 信息需存储在服务端。</td><td><strong>无状态 (Stateless)</strong>。用户信息包含在 Token 的 Payload 中，服务端无需存储。</td><td><strong>减轻服务端压力</strong>。服务端不需要为每个在线用户维护一个 Session 对象。</td></tr><tr><td><strong>可扩展性</strong></td><td><strong>差</strong>。在分布式或集群环境下，需要解决 Session 共享问题（如 Session Sticky、Session Replication、集中存储）。</td><td><strong>好</strong>。由于服务端不存储状态，任何一台服务器只要有相同的密钥，就能验证 Token，天然适合分布式和微服务架构。</td><td><strong>轻松实现水平扩展</strong>。增加服务器节点无需额外配置 Session 共享。</td></tr><tr><td><strong>跨域支持</strong></td><td><strong>有限</strong>。基于 Cookie 的 Session 机制在跨域（CORS）场景下处理起来比较麻烦。</td><td><strong>优秀</strong>。Token 可以通过 HTTP 请求头发送，不受同源策略限制，非常适合前后端分离和跨域 API 调用。</td><td><strong>适应现代架构</strong>。完美支持 SPA（单页应用）、移动 App 等多种客户端。</td></tr><tr><td><strong>安全性</strong></td><td>依赖 Cookie 机制，可能遭受 CSRF 攻击。</td><td>如果 Token 存储在 <code>localStorage</code>，可能遭受 XSS 攻击。需要综合考虑存储方式。</td><td>两者各有安全风险点，需配合其他安全策略。Token 机制不依赖 Cookie，更灵活。</td></tr><tr><td><strong>适用性</strong></td><td>适合传统的、一体化的 Web 应用。</td><td>适合现代的、分布式的、跨终端的（Web, Mobile, IoT）应用架构。</td><td>Token 更具通用性和前瞻性。</td></tr></tbody></table><h4 id="4-双令牌策略-Access-Token-Refresh-Token"><a href="#4-双令牌策略-Access-Token-Refresh-Token" class="headerlink" title="4. 双令牌策略 (Access Token + Refresh Token)"></a><strong>4. 双令牌策略 (Access Token + Refresh Token)</strong></h4><ul><li><strong>Q: 为什么不用单个 Token？</strong><ul><li><strong>如果 Token 有效期很长（如一个月）</strong>: 安全风险高。一旦 Token 在此期间被窃取，攻击者可以长时间冒充用户身份进行操作。</li><li><strong>如果 Token 有效期很短（如 15 分钟）</strong>: 用户体验差。用户需要频繁地重新登录，这是无法接受的。</li></ul></li><li><strong>A: 双令牌策略应运而生，完美平衡了安全性和用户体验。</strong><ul><li><strong>Access Token (访问令牌)</strong>: 它的有效期<strong>非常短</strong>（如 15 分钟到 1 小时）。它被用于访问受保护的资源，由于其生命周期短，即使被窃取，攻击者能造成的危害也有限。</li><li><strong>Refresh Token (刷新令牌)</strong>: 它的有效期<strong>很长</strong>（如 7 天或 30 天）。它的<strong>唯一作用</strong>是用来获取新的 Access Token。Refresh Token 本身不包含任何权限信息，不能用于直接访问 API。</li></ul></li><li><strong>双令牌工作流程（静默刷新）</strong><ol><li><strong>首次登录</strong>: 用户登录成功，服务端返回一个短期的 <code>Access Token</code> 和一个长期的 <code>Refresh Token</code>。客户端将两者都存储起来。</li><li><strong>正常访问</strong>: 客户端使用 <code>Access Token</code> 访问 API。服务端验证 <code>Access Token</code> 通过，返回数据。</li><li><strong>Access Token 过期</strong>: 客户端再次使用过期的 <code>Access Token</code> 访问 API，服务端返回 <code>401 Unauthorized</code> 错误，并可能带上一个特定错误码，告知客户端是“令牌过期”而非“无效令牌”。</li><li><strong>静默刷新</strong>: 客户端的请求拦截器捕获到这个 <code>401</code> 错误后，<strong>不会立即跳转到登录页</strong>。而是自动发起一个特殊的请求，携带那个长期的 <code>Refresh Token</code> 去访问一个专门的刷新接口（如 <code>/api/token/refresh</code>）。</li><li><strong>签发新令牌</strong>: 服务端验证 <code>Refresh Token</code> 的有效性（通常会将其存储在 Redis 或数据库中进行比对，以实现强制下线功能）。如果验证通过，就生成一个<strong>新的 Access Token</strong>（有时也会生成一个新的 <code>Refresh Token</code>，这被称为刷新令牌滚动策略）并返回给客户端。</li><li><strong>重试请求</strong>: 客户端收到新的 <code>Access Token</code> 后，用它替换掉本地旧的 <code>Access Token</code>，然后<strong>自动重新发送刚才因令牌过期而失败的那个请求</strong>。</li><li><strong>无感体验</strong>: 整个过程对用户是透明的，用户感觉不到令牌已经过期并被刷新，实现了“静默刷新”，体验非常流畅。</li><li><strong>Refresh Token 过期</strong>: 如果 <code>Refresh Token</code> 也过期了，那么刷新接口会返回错误，此时客户端才会真正清除用户凭证并引导用户重新登录。</li></ol></li></ul><h4 id="5-Token-相关场景与面试题"><a href="#5-Token-相关场景与面试题" class="headerlink" title="5. Token 相关场景与面试题"></a><strong>5. Token 相关场景与面试题</strong></h4><ul><li><strong>面试题 1：“Token 应该存储在哪里？localStorage、sessionStorage 还是 Cookie？”</strong><ul><li><strong>回答要点</strong>:<ul><li><strong>localStorage&#x2F;sessionStorage</strong>:<ul><li><strong>优点</strong>: 方便 JavaScript 直接读写，容量较大（5MB）。</li><li><strong>缺点</strong>: 容易受到 <strong>XSS (跨站脚本攻击)</strong>。如果网站存在 XSS 漏洞，攻击者可以执行 JS 代码直接窃取存储在其中的 Token。</li></ul></li><li><strong>Cookie (HttpOnly)</strong>:<ul><li><strong>优点</strong>: 设置为 <code>HttpOnly</code> 后，JavaScript 将无法读写该 Cookie，可以有效<strong>防御 XSS 攻击</strong>。浏览器会自动在同域请求中携带它。</li><li><strong>缺点</strong>: 容易受到 <strong>CSRF (跨站请求伪造)</strong> 攻击。攻击者可以诱导用户点击恶意链接，浏览器会自动带上用户的 Cookie 去请求你的网站，执行非用户本意的操作。需要配合 Anti-CSRF Token 等机制来防御。容量较小（4KB）。</li></ul></li><li><strong>最佳实践&#x2F;结论</strong>: 没有绝对完美的选择，需要权衡。<ul><li><strong>高安全性方案</strong>: 将 <code>Refresh Token</code> 存储在 <code>HttpOnly</code> 的 Cookie 中（防止 XSS），将 <code>Access Token</code> 存储在内存中（变量里，页面刷新丢失）或 <code>sessionStorage</code> 中。同时，后端接口必须实施 CSRF 防御策略。</li><li><strong>主流实践方案 (前后端分离)</strong>: 将 Token 存储在 <code>localStorage</code> 中，并在 <code>Authorization</code> 请求头中携带。同时，前端必须严格做好输入过滤和内容转义，尽最大努力防止 XSS 漏洞的出现。</li></ul></li></ul></li></ul></li><li><strong>面试题 2：“用户点击“退出登录”时，Token 如何失效？”</strong><ul><li><strong>回答要点</strong>:<ul><li><strong>对于无状态的 JWT</strong>: 由于所有信息都在 Token 自身，服务端无法主动让其失效。因此，“退出登录”主要是一个<strong>客户端行为</strong>。<ul><li><strong>客户端</strong>: 只需从 <code>localStorage</code> 或其他存储位置清除 Token 即可。用户将无法再发起认证请求。</li></ul></li><li><strong>如何实现服务端强制下线？</strong>: 如果需要实现“踢人下线”或“修改密码后所有设备强制下线”的功能，就必须打破纯粹的无状态。<ul><li><strong>黑名单机制</strong>: 服务端可以建立一个 Token 黑名单（例如，使用 Redis Set）。当用户退出登录时，将该 Token 的 <code>jti</code> (JWT ID) 或整个 Token 放入黑名单，并设置与 Token 剩余有效期相同的过期时间。在每次验证 Token 时，除了常规验证，还需检查该 Token 是否在黑名单中。</li><li><strong>基于 Refresh Token</strong>: 在双令牌模式下，退出登录时只需让服务端的 <code>Refresh Token</code> 失效（例如，从 Redis 中删除）。这样用户就无法再获取新的 <code>Access Token</code>，当旧的 <code>Access Token</code> 过期后，自然就下线了。</li></ul></li></ul></li></ul></li><li><strong>面试题 3：“请你设计一个支持 Web 端和 App 端统一登录的认证系统。”</strong><ul><li><strong>回答要点</strong>:<ul><li>这正是 Token 认证机制的典型应用场景。我会采用基于 <strong>OAuth 2.0&#x2F;OIDC</strong> 或自定义的**双令牌（Access&#x2F;Refresh Token）**方案。</li><li><strong>统一认证中心 (UAC)</strong>: 建立一个独立的认证服务，负责处理所有客户端（Web, iOS, Android）的登录、注册、Token 签发和刷新。</li><li><strong>API 网关</strong>: 所有业务请求都通过 API 网关。网关的核心职责之一就是<strong>统一鉴权</strong>。它会拦截所有请求，解析 <code>Authorization</code> 头中的 <code>Access Token</code>，调用认证中心或自行验证 Token 的有效性。验证通过后，可以将解析出的用户信息（如用户ID）附加到请求头中，再转发给后端的业务微服务。</li><li><strong>业务微服务</strong>: 业务微服务本身<strong>不再关心 Token 的验证细节</strong>，它们信任来自网关的请求，直接从请求头中获取用户信息进行业务处理，实现了业务与认证的解耦。</li><li><strong>流程</strong>:<ol><li>Web&#x2F;App 客户端引导用户到认证中心进行登录。</li><li>登录成功后，认证中心返回 <code>Access Token</code> 和 <code>Refresh Token</code>。</li><li>客户端保存令牌，后续访问业务 API 时，在请求头携带 <code>Access Token</code>。</li><li>API 网关拦截请求，验证 <code>Access Token</code>。</li><li><code>Access Token</code> 过期后，客户端使用 <code>Refresh Token</code> 向认证中心申请新令牌。</li></ol></li><li>这个架构具有高内聚、低耦合、可扩展性强、安全性高的优点。</li></ul></li></ul></li></ul><h1 id="Redis-详细技术解析"><a href="#Redis-详细技术解析" class="headerlink" title="Redis 详细技术解析"></a>Redis 详细技术解析</h1><h2 id="Redis-核心架构与原理"><a href="#Redis-核心架构与原理" class="headerlink" title="Redis 核心架构与原理"></a>Redis 核心架构与原理</h2><h3 id="内存模型与数据结构"><a href="#内存模型与数据结构" class="headerlink" title="内存模型与数据结构"></a>内存模型与数据结构</h3><p>Redis采用基于内存的存储架构，所有数据都保存在RAM中，这是其高性能的根本原因。Redis使用了多种底层数据结构来实现上层的抽象数据类型：</p><p><strong>SDS（Simple Dynamic String）</strong> Redis没有直接使用C语言的字符串，而是构建了SDS。SDS在字符串头部记录了长度信息，避免了strlen的O(n)复杂度，同时预分配空间减少内存重分配次数。</p><p><strong>跳跃表（Skip List）</strong> 有序集合的底层实现之一，是一种随机化的数据结构，通过多层链表实现O(log N)的查找复杂度。相比红黑树，跳跃表实现更简单，且支持范围查询。</p><p><strong>压缩列表（Ziplist）</strong> 当哈希、列表、有序集合元素较少时使用的紧凑存储结构，所有元素存储在一块连续内存中，节省内存但插入删除效率较低。</p><p><strong>字典（Dict）</strong> Redis的核心数据结构，使用开放寻址法解决哈希冲突，支持渐进式rehash。当负载因子过高时，会创建新的哈希表并逐步迁移数据。</p><h3 id="单线程模型与事件循环"><a href="#单线程模型与事件循环" class="headerlink" title="单线程模型与事件循环"></a>单线程模型与事件循环</h3><p>Redis 6.0之前采用单线程模型处理客户端请求，通过I&#x2F;O多路复用（epoll&#x2F;kqueue）实现高并发。单线程避免了线程切换开销和并发控制问题，但也限制了CPU利用率。</p><p><strong>事件循环机制</strong> Redis使用Reactor模式的事件循环，分为文件事件和时间事件：</p><ul><li>文件事件：处理客户端连接、读写请求</li><li>时间事件：处理定时任务，如过期键删除、持久化等</li></ul><p>Redis 6.0引入了多线程I&#x2F;O，但命令执行仍是单线程，多线程只用于网络I&#x2F;O操作的读写，这样既提高了网络处理能力，又保持了数据操作的原子性。</p><h2 id="数据类型详解与应用场景"><a href="#数据类型详解与应用场景" class="headerlink" title="数据类型详解与应用场景"></a>数据类型详解与应用场景</h2><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String是Redis最基础的数据类型，底层可以是SDS、整数或浮点数。</p><p><strong>常用命令</strong>：SET、GET、INCR、DECR、APPEND、GETRANGE <strong>应用场景</strong>：</p><ul><li>缓存：存储用户会话、配置信息</li><li>计数器：网站访问量、点赞数（INCR原子性保证）</li><li>分布式锁：SET key value NX EX seconds</li><li>限流：结合EXPIRE实现滑动窗口限流</li></ul><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash类型适合存储对象，避免了将对象序列化为JSON字符串的开销。</p><p><strong>底层实现</strong>：元素较少时使用ziplist，元素较多时使用hashtable <strong>应用场景</strong>：</p><ul><li>存储用户信息：HSET user:1001 name “张三” age 25</li><li>购物车：HSET cart:1001 product:123 2</li><li>配置管理：分类存储不同模块的配置</li></ul><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>List是双向链表实现，支持在两端进行O(1)的插入和删除操作。</p><p><strong>常用命令</strong>：LPUSH、RPUSH、LPOP、RPOP、LRANGE、BLPOP <strong>应用场景</strong>：</p><ul><li>消息队列：生产者LPUSH，消费者BRPOP实现阻塞队列</li><li>最新列表：朋友圈动态、商品评论</li><li>栈和队列：LPUSH+LPOP实现栈，LPUSH+RPOP实现队列</li></ul><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Set是无序集合，元素唯一，底层使用hashtable或intset实现。</p><p><strong>集合运算</strong>：SINTER（交集）、SUNION（并集）、SDIFF（差集） <strong>应用场景</strong>：</p><ul><li>去重：统计网站独立访客</li><li>社交关系：共同好友、推荐用户</li><li>标签系统：用户标签、文章分类</li><li>抽奖系统：SRANDMEMBER随机抽取</li></ul><h3 id="Sorted-Set类型"><a href="#Sorted-Set类型" class="headerlink" title="Sorted Set类型"></a>Sorted Set类型</h3><p>有序集合，每个元素关联一个分数，按分数排序。底层使用跳跃表和哈希表。</p><p><strong>应用场景</strong>：</p><ul><li>排行榜：游戏积分、热搜榜</li><li>延时队列：分数为执行时间戳</li><li>范围查询：按时间、按分数范围获取数据</li></ul><h2 id="持久化机制深度解析"><a href="#持久化机制深度解析" class="headerlink" title="持久化机制深度解析"></a>持久化机制深度解析</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB通过fork子进程，将内存数据快照写入磁盘。</p><p><strong>优点</strong>：</p><ul><li>文件紧凑，适合备份和灾难恢复</li><li>恢复速度快</li><li>对Redis性能影响小（子进程操作）</li></ul><p><strong>缺点</strong>：</p><ul><li>数据丢失风险：两次快照间的数据可能丢失</li><li>fork过程会阻塞主进程</li><li>大数据集fork耗时较长</li></ul><p><strong>触发条件</strong>：</p><ul><li>手动执行SAVE或BGSAVE命令</li><li>配置自动触发：save 900 1（900秒内至少1个键改变）</li><li>主从复制时自动生成RDB</li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF记录每个写命令，通过重放命令恢复数据。</p><p><strong>写入时机</strong>：</p><ul><li>always：每个写命令立即同步，安全但性能低</li><li>everysec：每秒同步一次，平衡安全性和性能</li><li>no：由操作系统决定同步时机，性能高但安全性低</li></ul><p><strong>AOF重写</strong>： AOF文件会越来越大，Redis提供重写机制优化：</p><ul><li>遍历内存数据，用最少命令重建AOF文件</li><li>重写期间的新命令写入AOF重写缓冲区</li><li>原子性替换旧AOF文件</li></ul><p><strong>混合持久化</strong>： Redis 4.0引入RDB+AOF混合模式，重写时以RDB格式写入基础数据，增量命令以AOF格式追加，兼顾了恢复速度和数据安全。</p><h2 id="缓存问题与解决方案"><a href="#缓存问题与解决方案" class="headerlink" title="缓存问题与解决方案"></a>缓存问题与解决方案</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在的数据，缓存无法生效，请求直达数据库。</p><p><strong>解决方案</strong>：</p><ol><li><strong>空值缓存</strong>：查询结果为空时也缓存，设置较短过期时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (data == null) &#123;</span><br><span class="line">    redis.setex(key, 60, &quot;null&quot;);  // 缓存空值60秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>布隆过滤器</strong>：预先将所有可能存在的数据哈希到位数组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BloomFilter&lt;String&gt; filter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()), 1000000, 0.01);</span><br><span class="line">// 查询前先检查布隆过滤器</span><br><span class="line">if (!filter.mightContain(key)) &#123;</span><br><span class="line">    return null;  // 一定不存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>参数校验</strong>：在API层面进行参数合法性校验</li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>热点数据过期瞬间，大量并发请求击穿缓存。</p><p><strong>解决方案</strong>：</p><ol><li><strong>互斥锁</strong>：只允许一个线程查询数据库并重建缓存</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public String getData(String key) &#123;</span><br><span class="line">    String data = redis.get(key);</span><br><span class="line">    if (data == null) &#123;</span><br><span class="line">        String lockKey = &quot;lock:&quot; + key;</span><br><span class="line">        if (redis.setnx(lockKey, &quot;1&quot;, 10)) &#123;  // 获取锁</span><br><span class="line">            try &#123;</span><br><span class="line">                data = database.query(key);  // 查询数据库</span><br><span class="line">                redis.setex(key, 3600, data);  // 重建缓存</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                redis.del(lockKey);  // 释放锁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Thread.sleep(50);  // 等待其他线程重建缓存</span><br><span class="line">            return getData(key);  // 递归重试</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>热点数据永不过期</strong>：逻辑上设置过期时间，物理上不过期，异步更新</li><li><strong>预热机制</strong>：系统启动时预先加载热点数据</li><li><strong>二级缓存</strong>：L1缓存过期后，先返回L2缓存数据，异步更新L1</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量缓存同时过期或Redis宕机，请求涌向数据库。</p><p><strong>解决方案</strong>：</p><ol><li><strong>过期时间随机化</strong>：避免同时过期</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int randomExpire = baseExpire + new Random().nextInt(300);  // 基础时间+随机时间</span><br><span class="line">redis.setex(key, randomExpire, data);</span><br></pre></td></tr></table></figure><ol><li><strong>多级缓存架构</strong>：<ul><li>L1：本地缓存（如Caffeine）</li><li>L2：Redis分布式缓存</li><li>L3：数据库</li></ul></li><li><strong>限流降级</strong>：使用Sentinel、Hystrix等组件</li><li><strong>Redis高可用</strong>：主从复制、哨兵模式、集群部署</li></ol><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>系统启动时预先加载热点数据到缓存。</p><p><strong>实现方式</strong>：</p><ol><li><strong>定时任务预热</strong>：凌晨低峰期执行</li><li><strong>手动预热</strong>：管理后台触发预热任务</li><li><strong>实时预热</strong>：监控系统发现热点数据自动预热</li></ol><h2 id="数据一致性保证"><a href="#数据一致性保证" class="headerlink" title="数据一致性保证"></a>数据一致性保证</h2><h3 id="Cache-Aside模式（旁路缓存）"><a href="#Cache-Aside模式（旁路缓存）" class="headerlink" title="Cache Aside模式（旁路缓存）"></a>Cache Aside模式（旁路缓存）</h3><p>应用程序负责维护缓存和数据库的一致性。</p><p><strong>读操作</strong>：</p><ol><li>先读缓存，命中则返回</li><li>缓存不命中，查询数据库</li><li>将数据写入缓存并返回</li></ol><p><strong>写操作</strong>：</p><ol><li>先更新数据库</li><li>删除缓存（让下次读取时重新加载）</li></ol><p><strong>为什么是删除而不是更新缓存？</strong></p><ul><li>更新缓存可能存在并发问题</li><li>复杂查询的缓存更新成本高</li><li>删除缓存更简单可靠</li></ul><h3 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h3><p>解决读写并发导致的数据不一致问题。</p><p><strong>实现步骤</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void updateData(String key, Object data) &#123;</span><br><span class="line">    // 1. 删除缓存</span><br><span class="line">    redis.del(key);</span><br><span class="line">    </span><br><span class="line">    // 2. 更新数据库</span><br><span class="line">    database.update(data);</span><br><span class="line">    </span><br><span class="line">    // 3. 延时删除缓存（异步）</span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);  // 延时500ms</span><br><span class="line">            redis.del(key);     // 再次删除缓存</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            log.error(&quot;延时删除缓存失败&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>延时时间设置</strong>：通常为主从同步时间 + 读数据库时间 + 几十毫秒</p><h3 id="基于消息队列的最终一致性"><a href="#基于消息队列的最终一致性" class="headerlink" title="基于消息队列的最终一致性"></a>基于消息队列的最终一致性</h3><p>使用消息队列异步处理缓存更新，保证最终一致性。</p><p><strong>实现流程</strong>：</p><ol><li>更新数据库，发送消息到队列</li><li>消息消费者删除相关缓存</li><li>消费失败时重试，保证最终一致性</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 发送缓存删除消息</span><br><span class="line">@Transactional</span><br><span class="line">public void updateUser(User user) &#123;</span><br><span class="line">    userDao.update(user);  // 更新数据库</span><br><span class="line">    </span><br><span class="line">    // 发送缓存删除消息（事务提交后发送）</span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(</span><br><span class="line">        new TransactionSynchronizationAdapter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void afterCommit() &#123;</span><br><span class="line">                cacheDeleteMQ.send(&quot;user:&quot; + user.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式事务方案"><a href="#分布式事务方案" class="headerlink" title="分布式事务方案"></a>分布式事务方案</h3><p>对于强一致性要求高的场景，可以使用分布式事务。</p><p><strong>2PC（两阶段提交）</strong>：</p><ul><li>准备阶段：协调者询问参与者是否准备好</li><li>提交阶段：所有参与者都准备好则提交，否则回滚</li></ul><p><strong>TCC（Try-Confirm-Cancel）</strong>：</p><ul><li>Try：尝试执行，预留资源</li><li>Confirm：确认提交</li><li>Cancel：取消执行，释放资源</li></ul><h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><h3 id="基于SET命令的分布式锁"><a href="#基于SET命令的分布式锁" class="headerlink" title="基于SET命令的分布式锁"></a>基于SET命令的分布式锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class RedisDistributedLock &#123;</span><br><span class="line">    private Jedis jedis;</span><br><span class="line">    </span><br><span class="line">    public boolean tryLock(String lockKey, String requestId, int expireTime) &#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, &quot;NX&quot;, &quot;PX&quot;, expireTime);</span><br><span class="line">        return &quot;OK&quot;.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean releaseLock(String lockKey, String requestId) &#123;</span><br><span class="line">        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                       &quot;return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey),</span><br><span class="line">                                 Collections.singletonList(requestId));</span><br><span class="line">        return &quot;1&quot;.equals(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用方式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = &quot;lock:user:1001&quot;;</span><br><span class="line">String requestId = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">if (tryLock(lockKey, requestId, 30000)) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 执行业务逻辑</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        releaseLock(lockKey, requestId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h3><p>为了解决单点故障问题，Redis官方提出了Redlock算法。</p><p><strong>算法步骤</strong>：</p><ol><li>获取当前时间戳</li><li>依次向N个Redis实例申请锁</li><li>如果在大多数实例（N&#x2F;2+1）上获取锁成功，且总耗时小于锁超时时间，则认为获取锁成功</li><li>锁的有效时间 &#x3D; 初始有效时间 - 获取锁消耗的时间</li><li>释放锁时，向所有Redis实例发送释放命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Redlock &#123;</span><br><span class="line">    private List&lt;Jedis&gt; jedisInstances;</span><br><span class="line">    </span><br><span class="line">    public boolean lock(String resource, int ttl) &#123;</span><br><span class="line">        int quorum = jedisInstances.size() / 2 + 1;</span><br><span class="line">        int successCount = 0;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        for (Jedis jedis : jedisInstances) &#123;</span><br><span class="line">            if (lockInstance(jedis, resource, ttl)) &#123;</span><br><span class="line">                successCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        long elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        if (successCount &gt;= quorum &amp;&amp; elapsedTime &lt; ttl) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            unlock(resource);  // 释放已获取的锁</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁的问题与优化"><a href="#锁的问题与优化" class="headerlink" title="锁的问题与优化"></a>锁的问题与优化</h3><p><strong>锁超时问题</strong>： 业务执行时间超过锁超时时间，锁自动释放，可能导致并发问题。</p><p><strong>解决方案</strong>：</p><ol><li><strong>看门狗机制</strong>：定时续期锁的过期时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class WatchDog &#123;</span><br><span class="line">    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);</span><br><span class="line">    </span><br><span class="line">    public void startWatchDog(String lockKey, String requestId) &#123;</span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            // 续期锁</span><br><span class="line">            String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                           &quot;return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) else return 0 end&quot;;</span><br><span class="line">            jedis.eval(script, Arrays.asList(lockKey), </span><br><span class="line">                      Arrays.asList(requestId, &quot;30&quot;));</span><br><span class="line">        &#125;, 10, 10, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>合理评估业务执行时间</strong>：设置足够的锁超时时间</li></ol><p><strong>锁竞争激烈问题</strong>： 大量线程竞争同一把锁，导致性能下降。</p><p><strong>解决方案</strong>：</p><ol><li><strong>分段锁</strong>：将资源分段，减少锁竞争</li><li><strong>队列锁</strong>：使用List实现公平锁</li><li><strong>自旋锁优化</strong>：适当的退避算法</li></ol><h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>假设会发生并发冲突，在操作数据前先获取锁。</p><p><strong>Redis实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 使用Redis分布式锁实现悲观锁</span><br><span class="line">public void updateWithPessimisticLock(String userId, int amount) &#123;</span><br><span class="line">    String lockKey = &quot;lock:account:&quot; + userId;</span><br><span class="line">    String requestId = UUID.randomUUID().toString();</span><br><span class="line">    </span><br><span class="line">    if (tryLock(lockKey, requestId, 30000)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 查询账户余额</span><br><span class="line">            int balance = getBalance(userId);</span><br><span class="line">            if (balance &gt;= amount) &#123;</span><br><span class="line">                // 扣减余额</span><br><span class="line">                updateBalance(userId, balance - amount);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InsufficientBalanceException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            releaseLock(lockKey, requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new LockAcquisitionException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>假设不会发生冲突，在更新时检查数据是否被修改。</p><p><strong>基于版本号的乐观锁</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public boolean updateWithOptimisticLock(String userId, int amount, int expectedVersion) &#123;</span><br><span class="line">    // 使用Lua脚本保证原子性</span><br><span class="line">    String script = </span><br><span class="line">        &quot;local current = redis.call(&#x27;hmget&#x27;, KEYS[1], &#x27;balance&#x27;, &#x27;version&#x27;) &quot; +</span><br><span class="line">        &quot;if current[2] == ARGV[2] then &quot; +</span><br><span class="line">        &quot;  if tonumber(current[1]) &gt;= tonumber(ARGV[1]) then &quot; +</span><br><span class="line">        &quot;    redis.call(&#x27;hmset&#x27;, KEYS[1], &#x27;balance&#x27;, current[1] - ARGV[1], &#x27;version&#x27;, current[2] + 1) &quot; +</span><br><span class="line">        &quot;    return 1 &quot; +</span><br><span class="line">        &quot;  else &quot; +</span><br><span class="line">        &quot;    return -1 &quot; +  // 余额不足</span><br><span class="line">        &quot;  end &quot; +</span><br><span class="line">        &quot;else &quot; +</span><br><span class="line">        &quot;  return 0 &quot; +     // 版本号不匹配</span><br><span class="line">        &quot;end&quot;;</span><br><span class="line">    </span><br><span class="line">    String key = &quot;account:&quot; + userId;</span><br><span class="line">    Object result = jedis.eval(script, Arrays.asList(key), </span><br><span class="line">                              Arrays.asList(String.valueOf(amount), String.valueOf(expectedVersion)));</span><br><span class="line">    </span><br><span class="line">    int code = ((Long) result).intValue();</span><br><span class="line">    if (code == 1) &#123;</span><br><span class="line">        return true;  // 更新成功</span><br><span class="line">    &#125; else if (code == 0) &#123;</span><br><span class="line">        throw new OptimisticLockException(&quot;数据已被修改&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new InsufficientBalanceException(&quot;余额不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于CAS的乐观锁</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void updateWithCAS(String key, Function&lt;String, String&gt; updater) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 1. 获取当前值</span><br><span class="line">        String currentValue = redis.get(key);</span><br><span class="line">        </span><br><span class="line">        // 2. 计算新值</span><br><span class="line">        String newValue = updater.apply(currentValue);</span><br><span class="line">        </span><br><span class="line">        // 3. CAS更新</span><br><span class="line">        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                       &quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[2]) else return nil end&quot;;</span><br><span class="line">        Object result = redis.eval(script, Arrays.asList(key), </span><br><span class="line">                                  Arrays.asList(currentValue, newValue));</span><br><span class="line">        </span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            break;  // 更新成功</span><br><span class="line">        &#125;</span><br><span class="line">        // 更新失败，重试</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="悲观锁-vs-乐观锁选择"><a href="#悲观锁-vs-乐观锁选择" class="headerlink" title="悲观锁 vs 乐观锁选择"></a>悲观锁 vs 乐观锁选择</h3><p><strong>悲观锁适用场景</strong>：</p><ul><li>写操作频繁，冲突概率高</li><li>业务逻辑复杂，重试成本高</li><li>对数据一致性要求严格</li></ul><p><strong>乐观锁适用场景</strong>：</p><ul><li>读多写少，冲突概率低</li><li>业务逻辑简单，重试成本低</li><li>对性能要求高</li></ul><h2 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Master负责写操作，Slave负责读操作，通过复制实现数据同步。</p><p><strong>复制原理</strong>：</p><ol><li>Slave向Master发送PSYNC命令</li><li>Master执行BGSAVE生成RDB文件</li><li>Master将RDB文件发送给Slave</li><li>Slave载入RDB文件</li><li>Master将缓冲区的写命令发送给Slave</li><li>后续写命令实时同步</li></ol><p><strong>部分重同步</strong>： 网络断连后，Slave只需要同步断连期间的命令，而不是完整重同步。</p><h3 id="哨兵模式（Sentinel）"><a href="#哨兵模式（Sentinel）" class="headerlink" title="哨兵模式（Sentinel）"></a>哨兵模式（Sentinel）</h3><p>哨兵负责监控Master状态，在Master故障时自动进行故障转移。</p><p><strong>哨兵职责</strong>：</p><ul><li>监控：定期ping Master和Slave</li><li>通知：故障时通知管理员和客户端</li><li>故障转移：自动将Slave提升为新Master</li><li>配置管理：为客户端提供服务发现</li></ul><p><strong>故障转移流程</strong>：</p><ol><li>哨兵发现Master下线（主观下线）</li><li>多个哨兵确认Master下线（客观下线）</li><li>选举领导哨兵执行故障转移</li><li>选择合适的Slave作为新Master</li><li>修改其他Slave的配置指向新Master</li><li>通知客户端Master地址变更</li></ol><h3 id="集群模式（Cluster）"><a href="#集群模式（Cluster）" class="headerlink" title="集群模式（Cluster）"></a>集群模式（Cluster）</h3><p>Redis Cluster通过分片实现横向扩展和高可用。</p><p><strong>分片算法</strong>： 使用CRC16算法计算key的哈希值，然后对16384取模得到槽位号。</p><p><strong>节点通信</strong>： 使用Gossip协议在节点间交换状态信息，包括节点上线&#x2F;下线、槽位分配等。</p><p><strong>故障转移</strong>： 当Master节点故障时，其Slave自动提升为新Master，过程对客户端透明。</p><p><strong>数据迁移</strong>： 集群扩容时，需要将部分槽位从现有节点迁移到新节点。</p><h2 id="性能监控与优化"><a href="#性能监控与优化" class="headerlink" title="性能监控与优化"></a>性能监控与优化</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>Redis提供慢查询日志功能，记录执行时间超过阈值的命令。</p><p><strong>配置参数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than 10000  # 超过10毫秒记录</span><br><span class="line">slowlog-max-len 128           # 最多保存128条记录</span><br></pre></td></tr></table></figure><p><strong>查看慢查询</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLOWLOG GET 10  # 获取最近10条慢查询</span><br></pre></td></tr></table></figure><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p>使用MEMORY命令分析内存使用情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MEMORY USAGE key         # 查看key占用内存</span><br><span class="line">MEMORY STATS            # 查看内存统计信息</span><br><span class="line">MEMORY DOCTOR           # 内存使用建议</span><br></pre></td></tr></table></figure><h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><p><strong>避免大key</strong>：</p><ul><li>单个key的value不要超过10KB</li><li>集合类型元素数量控制在合理范围</li><li>使用SCAN代替KEYS命令</li></ul><p><strong>合理使用数据结构</strong>：</p><ul><li>小对象使用Hash而不是多个String</li><li>合理设置ziplist等压缩结构的阈值</li><li>使用位图(bitmap)存储布尔类型大数据集</li></ul><p><strong>网络优化</strong>：</p><ul><li>使用Pipeline批量操作</li><li>合理设置客户端连接池</li><li>启用TCP_NODELAY选项</li></ul><p><strong>持久化优化</strong>：</p><ul><li>根据业务需求选择RDB或AOF</li><li>合理配置自动保存条件</li><li>在从节点上进行持久化操作</li></ul><p>这些详细的技术点涵盖了Redis的核心概念、常见问题解决方案和实际应用场景，是Redis技术面试的重要考查内容。掌握这些知识点并能结合实际项目经验进行说明，将大大提高面试通过率。</p><h2 id="内存管理与淘汰机制"><a href="#内存管理与淘汰机制" class="headerlink" title="内存管理与淘汰机制"></a>内存管理与淘汰机制</h2><h3 id="内存淘汰策略详解"><a href="#内存淘汰策略详解" class="headerlink" title="内存淘汰策略详解"></a>内存淘汰策略详解</h3><p>当Redis内存使用达到maxmemory限制时，会根据配置的策略淘汰数据。</p><p><strong>8种淘汰策略</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 针对所有key</span><br><span class="line">noeviction          # 不淘汰，写入返回错误</span><br><span class="line">allkeys-lru         # 所有key中淘汰最近最少使用</span><br><span class="line">allkeys-lfu         # 所有key中淘汰最少频率使用</span><br><span class="line">allkeys-random      # 所有key中随机淘汰</span><br><span class="line"></span><br><span class="line"># 针对设置了过期时间的key</span><br><span class="line">volatile-lru        # 过期key中淘汰最近最少使用</span><br><span class="line">volatile-lfu        # 过期key中淘汰最少频率使用</span><br><span class="line">volatile-random     # 过期key中随机淘汰</span><br><span class="line">volatile-ttl        # 过期key中淘汰即将过期的</span><br></pre></td></tr></table></figure><p><strong>LRU vs LFU 实现细节</strong>： Redis的LRU并非严格的LRU，而是近似LRU算法：</p><ul><li>每个key都有24位的时钟字段记录访问时间</li><li>淘汰时随机采样5个key（可配置），选择时钟值最小的</li></ul><p>LFU算法维护访问频率：</p><ul><li>高16位存储上次访问时间</li><li>低8位存储访问频率计数器</li><li>计数器采用概率性递增，避免频率无限增长</li></ul><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p><strong>产生原因</strong>：</p><ul><li>频繁的数据更新导致内存分配&#x2F;释放</li><li>Redis使用jemalloc内存分配器，存在内存对齐</li><li>删除大key后留下内存空洞</li></ul><p><strong>检测方法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"># 关注 mem_fragmentation_ratio 指标</span><br><span class="line"># 比值 &gt; 1.5 表示碎片较多</span><br><span class="line"># 比值 &lt; 1 表示使用了swap，性能严重下降</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><ol><li><strong>内存整理</strong>（Redis 4.0+）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET activedefrag yes        # 开启自动整理</span><br><span class="line">CONFIG SET active-defrag-threshold-lower 10  # 碎片率超过10%启动</span><br><span class="line">MEMORY PURGE                       # 手动触发整理</span><br></pre></td></tr></table></figure><ol><li><strong>重启Redis</strong>：最彻底但影响服务可用性</li><li><strong>优化数据结构</strong>：减少小对象，使用Hash存储相关数据</li></ol><h2 id="过期策略与删除机制"><a href="#过期策略与删除机制" class="headerlink" title="过期策略与删除机制"></a>过期策略与删除机制</h2><h3 id="三种过期删除策略"><a href="#三种过期删除策略" class="headerlink" title="三种过期删除策略"></a>三种过期删除策略</h3><p><strong>定时删除</strong>：设置过期时间时创建定时器，到期立即删除</p><ul><li>优点：及时释放内存</li><li>缺点：消耗CPU资源创建和管理定时器</li></ul><p><strong>惰性删除</strong>：访问key时检查是否过期，过期则删除</p><ul><li>优点：CPU友好，只在必要时删除</li><li>缺点：内存不友好，过期key可能长期占用内存</li></ul><p><strong>定期删除</strong>：定期随机检查部分key，删除过期的</p><ul><li>Redis的实际策略，平衡CPU和内存使用</li></ul><h3 id="Redis过期删除实现"><a href="#Redis过期删除实现" class="headerlink" title="Redis过期删除实现"></a>Redis过期删除实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 简化的过期删除逻辑</span><br><span class="line">void activeExpireCycle(int type) &#123;</span><br><span class="line">    static int current_db = 0;</span><br><span class="line">    static int timelimit_exit = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">        redisDb *db = server.db + current_db % server.dbnum;</span><br><span class="line">        </span><br><span class="line">        int iteration = 0;</span><br><span class="line">        while (iteration &lt; 20) &#123;  // 最多检查20个key</span><br><span class="line">            long sampled = 0, expired = 0;</span><br><span class="line">            </span><br><span class="line">            // 随机选择key检查过期</span><br><span class="line">            for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                dictEntry *de = dictGetRandomKey(db-&gt;expires);</span><br><span class="line">                if (de == NULL) break;</span><br><span class="line">                </span><br><span class="line">                sampled++;</span><br><span class="line">                if (keyIsExpired(db, de)) &#123;</span><br><span class="line">                    deleteExpiredKey(db, de);</span><br><span class="line">                    expired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 如果过期比例超过25%，继续下轮检查</span><br><span class="line">            if (expired &gt; 5) iteration++;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        current_db++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构底层实现深度解析"><a href="#数据结构底层实现深度解析" class="headerlink" title="数据结构底层实现深度解析"></a>数据结构底层实现深度解析</h2><h3 id="压缩列表（ZipList）演进"><a href="#压缩列表（ZipList）演进" class="headerlink" title="压缩列表（ZipList）演进"></a>压缩列表（ZipList）演进</h3><p>Redis 7.0用ListPack替代了ZipList，解决了级联更新问题。</p><p><strong>ZipList问题</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ZipList结构导致的级联更新</span><br><span class="line">// 当插入元素导致某个entry的长度改变时</span><br><span class="line">// 可能引起后续所有entry的重新编码</span><br></pre></td></tr></table></figure><p><strong>ListPack优势</strong>：</p><ul><li>每个元素独立编码，避免级联更新</li><li>支持从尾部遍历，提高某些操作效率</li></ul><h3 id="字典扩容与rehash"><a href="#字典扩容与rehash" class="headerlink" title="字典扩容与rehash"></a>字典扩容与rehash</h3><p>Redis字典使用增量式rehash避免阻塞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 渐进式rehash实现</span><br><span class="line">int dictRehash(dict *d, int n) &#123;</span><br><span class="line">    int empty_visits = n * 10;</span><br><span class="line">    </span><br><span class="line">    if (!dictIsRehashing(d)) return 0;</span><br><span class="line">    </span><br><span class="line">    while (n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;</span><br><span class="line">        // 跳过空桶</span><br><span class="line">        while (d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            if (--empty_visits == 0) return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 迁移桶中所有元素</span><br><span class="line">        dictEntry *de = d-&gt;ht[0].table[d-&gt;rehashidx];</span><br><span class="line">        while (de) &#123;</span><br><span class="line">            dictEntry *nextde = de-&gt;next;</span><br><span class="line">            unsigned int h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[1].table[h];</span><br><span class="line">            d-&gt;ht[1].table[h] = de;</span><br><span class="line">            d-&gt;ht[0].used--;</span><br><span class="line">            d-&gt;ht[1].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络模型与性能优化"><a href="#网络模型与性能优化" class="headerlink" title="网络模型与性能优化"></a>网络模型与性能优化</h2><h3 id="Redis-6-0-多线程I-O"><a href="#Redis-6-0-多线程I-O" class="headerlink" title="Redis 6.0 多线程I&#x2F;O"></a>Redis 6.0 多线程I&#x2F;O</h3><p>多线程只用于网络I&#x2F;O，命令执行仍是单线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 多线程I/O处理流程</span><br><span class="line">void *IOThreadMain(void *myid) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 等待主线程分配任务</span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[id]);</span><br><span class="line">        </span><br><span class="line">        while (io_threads_list[id] &amp;&amp; io_threads_pending[id] == 0) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;io_threads_cond[id], &amp;io_threads_mutex[id]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 处理读写任务</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line">        listRewind(io_threads_list[id], &amp;li);</span><br><span class="line">        </span><br><span class="line">        while ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *c = listNodeValue(ln);</span><br><span class="line">            if (io_threads_op == IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                writeToClient(c, 0);</span><br><span class="line">            &#125; else if (io_threads_op == IO_THREADS_OP_READ) &#123;</span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        io_threads_pending[id] = 0;</span><br><span class="line">        pthread_mutex_unlock(&amp;io_threads_mutex[id]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端连接管理"><a href="#客户端连接管理" class="headerlink" title="客户端连接管理"></a>客户端连接管理</h3><p><strong>连接池配置优化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Jedis连接池配置</span><br><span class="line">JedisPoolConfig config = new JedisPoolConfig();</span><br><span class="line">config.setMaxTotal(200);                    // 最大连接数</span><br><span class="line">config.setMaxIdle(50);                      // 最大空闲连接</span><br><span class="line">config.setMinIdle(10);                      // 最小空闲连接</span><br><span class="line">config.setTestOnBorrow(true);               // 获取连接时测试</span><br><span class="line">config.setTestOnReturn(true);               // 归还连接时测试</span><br><span class="line">config.setTestWhileIdle(true);              // 空闲时测试</span><br><span class="line">config.setTimeBetweenEvictionRunsMillis(30000);  // 检查间隔</span><br><span class="line">config.setNumTestsPerEvictionRun(10);       // 每次检查连接数</span><br><span class="line">config.setMinEvictableIdleTimeMillis(60000);     // 最小空闲时间</span><br><span class="line"></span><br><span class="line">JedisPool pool = new JedisPool(config, &quot;localhost&quot;, 6379);</span><br></pre></td></tr></table></figure><p><strong>Pipeline优化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Pipeline批量操作</span><br><span class="line">public void batchSet(Map&lt;String, String&gt; data) &#123;</span><br><span class="line">    try (Jedis jedis = pool.getResource()) &#123;</span><br><span class="line">        Pipeline pipeline = jedis.pipelined();</span><br><span class="line">        </span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : data.entrySet()) &#123;</span><br><span class="line">            pipeline.set(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Object&gt; results = pipeline.syncAndReturnAll();</span><br><span class="line">        // 处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级数据类型与应用"><a href="#高级数据类型与应用" class="headerlink" title="高级数据类型与应用"></a>高级数据类型与应用</h2><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>用于基数统计，占用内存固定（12KB），误差率0.81%。</p><p><strong>实现原理</strong>：</p><ul><li>基于概率算法，通过观察随机数的最大前导零个数估算基数</li><li>使用调和平均数减少误差</li><li>适用于UV统计等场景</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 网站UV统计</span><br><span class="line">PFADD uv:20230815 user1 user2 user3</span><br><span class="line">PFCOUNT uv:20230815                    # 获取UV数量</span><br><span class="line">PFMERGE uv:week uv:20230815 uv:20230816  # 合并多日数据</span><br></pre></td></tr></table></figure><h3 id="布隆过滤器（Redis-Module）"><a href="#布隆过滤器（Redis-Module）" class="headerlink" title="布隆过滤器（Redis Module）"></a>布隆过滤器（Redis Module）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Redis布隆过滤器模块</span><br><span class="line">BF.RESERVE myfilter 0.01 1000000       # 创建过滤器，误报率0.01%，预期元素100万</span><br><span class="line">BF.ADD myfilter &quot;user123&quot;              # 添加元素</span><br><span class="line">BF.EXISTS myfilter &quot;user123&quot;           # 检查元素是否存在</span><br><span class="line">BF.MADD myfilter item1 item2 item3     # 批量添加</span><br><span class="line">BF.MEXISTS myfilter item1 item2 item3  # 批量检查</span><br></pre></td></tr></table></figure><h3 id="Geo地理位置"><a href="#Geo地理位置" class="headerlink" title="Geo地理位置"></a>Geo地理位置</h3><p>基于Sorted Set实现，使用GeoHash算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 添加地理位置</span><br><span class="line">GEOADD cities 116.397128 39.916527 &quot;北京&quot; 121.473701 31.230416 &quot;上海&quot;</span><br><span class="line"></span><br><span class="line"># 计算距离</span><br><span class="line">GEODIST cities &quot;北京&quot; &quot;上海&quot; km</span><br><span class="line"></span><br><span class="line"># 范围查询</span><br><span class="line">GEORADIUS cities 116.397128 39.916527 1000 km WITHDIST WITHCOORD</span><br><span class="line"></span><br><span class="line"># 根据成员查询</span><br><span class="line">GEORADIUSBYMEMBER cities &quot;北京&quot; 1000 km</span><br></pre></td></tr></table></figure><h2 id="安全性问题与防护"><a href="#安全性问题与防护" class="headerlink" title="安全性问题与防护"></a>安全性问题与防护</h2><h3 id="常见安全漏洞"><a href="#常见安全漏洞" class="headerlink" title="常见安全漏洞"></a>常见安全漏洞</h3><p><strong>命令注入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 错误做法：直接拼接用户输入</span><br><span class="line">String key = &quot;user:&quot; + userInput;  // userInput可能包含恶意命令</span><br><span class="line">jedis.eval(&quot;return redis.call(&#x27;get&#x27;, &#x27;&quot; + key + &quot;&#x27;)&quot;, 0);</span><br><span class="line"></span><br><span class="line">// 正确做法：使用参数化查询</span><br><span class="line">jedis.eval(&quot;return redis.call(&#x27;get&#x27;, KEYS[1])&quot;, 1, key);</span><br></pre></td></tr></table></figure><p><strong>未授权访问</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># redis.conf安全配置</span><br><span class="line">bind 127.0.0.1                        # 绑定指定IP</span><br><span class="line">requirepass your_password              # 设置密码</span><br><span class="line">protected-mode yes                     # 开启保护模式</span><br><span class="line">port 0                                # 禁用默认端口</span><br><span class="line">port 6380                             # 使用非标准端口</span><br></pre></td></tr></table></figure><p><strong>危险命令禁用</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 重命名危险命令</span><br><span class="line">rename-command FLUSHDB &quot;&quot;             # 禁用FLUSHDB</span><br><span class="line">rename-command FLUSHALL &quot;&quot;            # 禁用FLUSHALL</span><br><span class="line">rename-command SHUTDOWN &quot;REDIS_SHUTDOWN&quot;  # 重命名SHUTDOWN</span><br><span class="line">rename-command CONFIG &quot;REDIS_CONFIG&quot;   # 重命名CONFIG</span><br></pre></td></tr></table></figure><h3 id="ACL访问控制（Redis-6-0-）"><a href="#ACL访问控制（Redis-6-0-）" class="headerlink" title="ACL访问控制（Redis 6.0+）"></a>ACL访问控制（Redis 6.0+）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户</span><br><span class="line">ACL SETUSER alice on &gt;password123 ~cached:* +get +set</span><br><span class="line"></span><br><span class="line"># 查看用户权限</span><br><span class="line">ACL LIST</span><br><span class="line"></span><br><span class="line"># 删除用户</span><br><span class="line">ACL DELUSER alice</span><br><span class="line"></span><br><span class="line"># 检查权限</span><br><span class="line">AUTH alice password123</span><br></pre></td></tr></table></figure><h2 id="监控与运维"><a href="#监控与运维" class="headerlink" title="监控与运维"></a>监控与运维</h2><h3 id="关键监控指标"><a href="#关键监控指标" class="headerlink" title="关键监控指标"></a>关键监控指标</h3><p><strong>性能指标</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 通过INFO命令获取</span><br><span class="line">INFO stats</span><br><span class="line"># 关注指标：</span><br><span class="line"># - instantaneous_ops_per_sec: QPS</span><br><span class="line"># - keyspace_hits/keyspace_misses: 命中率</span><br><span class="line"># - used_cpu_sys/used_cpu_user: CPU使用率</span><br><span class="line"># - connected_clients: 连接数</span><br><span class="line"># - blocked_clients: 阻塞连接数</span><br></pre></td></tr></table></figure><p><strong>内存指标</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"># 关注指标：</span><br><span class="line"># - used_memory: 已使用内存</span><br><span class="line"># - used_memory_rss: 物理内存占用</span><br><span class="line"># - mem_fragmentation_ratio: 内存碎片率</span><br><span class="line"># - used_memory_peak: 内存使用峰值</span><br></pre></td></tr></table></figure><p><strong>持久化指标</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO persistence</span><br><span class="line"># 关注指标：</span><br><span class="line"># - rdb_last_save_time: 最后RDB保存时间</span><br><span class="line"># - aof_last_rewrite_time_sec: AOF重写耗时</span><br><span class="line"># - aof_current_size: AOF文件大小</span><br></pre></td></tr></table></figure><h3 id="故障排查常用命令"><a href="#故障排查常用命令" class="headerlink" title="故障排查常用命令"></a>故障排查常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接信息</span><br><span class="line">CLIENT LIST</span><br><span class="line">CLIENT INFO</span><br><span class="line"></span><br><span class="line"># 慢查询分析</span><br><span class="line">SLOWLOG GET 10</span><br><span class="line">CONFIG GET slowlog-log-slower-than</span><br><span class="line"></span><br><span class="line"># 大key查找</span><br><span class="line">MEMORY USAGE keyname</span><br><span class="line">redis-cli --bigkeys</span><br><span class="line"></span><br><span class="line"># 热点key分析</span><br><span class="line">redis-cli --hotkeys</span><br><span class="line"></span><br><span class="line"># 延迟监控</span><br><span class="line">LATENCY HISTORY command</span><br><span class="line">CONFIG SET latency-monitor-threshold 100</span><br></pre></td></tr></table></figure><h2 id="特殊应用场景"><a href="#特殊应用场景" class="headerlink" title="特殊应用场景"></a>特殊应用场景</h2><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p><strong>固定窗口限流</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class RedisRateLimiter &#123;</span><br><span class="line">    public boolean isAllowed(String key, int limit, int window) &#123;</span><br><span class="line">        long current = System.currentTimeMillis() / 1000 / window;</span><br><span class="line">        String windowKey = key + &quot;:&quot; + current;</span><br><span class="line">        </span><br><span class="line">        String script = </span><br><span class="line">            &quot;local count = redis.call(&#x27;incr&#x27;, KEYS[1]) &quot; +</span><br><span class="line">            &quot;if count == 1 then &quot; +</span><br><span class="line">            &quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[1]) &quot; +</span><br><span class="line">            &quot;end &quot; +</span><br><span class="line">            &quot;return count&quot;;</span><br><span class="line">            </span><br><span class="line">        Long count = (Long) jedis.eval(script, Arrays.asList(windowKey), </span><br><span class="line">                                      Arrays.asList(String.valueOf(window)));</span><br><span class="line">        </span><br><span class="line">        return count &lt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滑动窗口限流</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean slidingWindowLimit(String key, int limit, int window) &#123;</span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line">    long windowStart = now - window * 1000;</span><br><span class="line">    </span><br><span class="line">    String script = </span><br><span class="line">        &quot;redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">        &quot;local count = redis.call(&#x27;zcard&#x27;, KEYS[1]) &quot; +</span><br><span class="line">        &quot;if count &lt; tonumber(ARGV[2]) then &quot; +</span><br><span class="line">        &quot;  redis.call(&#x27;zadd&#x27;, KEYS[1], ARGV[3], ARGV[3]) &quot; +</span><br><span class="line">        &quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[4]) &quot; +</span><br><span class="line">        &quot;  return 1 &quot; +</span><br><span class="line">        &quot;else &quot; +</span><br><span class="line">        &quot;  return 0 &quot; +</span><br><span class="line">        &quot;end&quot;;</span><br><span class="line">    </span><br><span class="line">    Long result = (Long) jedis.eval(script, Arrays.asList(key),</span><br><span class="line">        Arrays.asList(String.valueOf(windowStart), String.valueOf(limit),</span><br><span class="line">                     String.valueOf(now), String.valueOf(window)));</span><br><span class="line">    </span><br><span class="line">    return result == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisSessionManager &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    public void createSession(String sessionId, String userId, int timeout) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        Map&lt;String, Object&gt; sessionData = new HashMap&lt;&gt;();</span><br><span class="line">        sessionData.put(&quot;userId&quot;, userId);</span><br><span class="line">        sessionData.put(&quot;createTime&quot;, System.currentTimeMillis());</span><br><span class="line">        </span><br><span class="line">        redisTemplate.opsForHash().putAll(key, sessionData);</span><br><span class="line">        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean isValidSession(String sessionId) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        return redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void renewSession(String sessionId, int timeout) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        if (redisTemplate.hasKey(key)) &#123;</span><br><span class="line">            redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息队列实现"><a href="#消息队列实现" class="headerlink" title="消息队列实现"></a>消息队列实现</h3><p><strong>基于List的简单队列</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class RedisQueue &#123;</span><br><span class="line">    // 生产者</span><br><span class="line">    public void produce(String queue, String message) &#123;</span><br><span class="line">        jedis.lpush(queue, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 消费者（阻塞式）</span><br><span class="line">    public String consume(String queue, int timeout) &#123;</span><br><span class="line">        List&lt;String&gt; result = jedis.brpop(timeout, queue);</span><br><span class="line">        return result != null ? result.get(1) : null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于Stream的消息队列</strong>（Redis 5.0+）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 生产消息</span><br><span class="line">XADD mystream * field1 value1 field2 value2</span><br><span class="line"></span><br><span class="line"># 创建消费者组</span><br><span class="line">XGROUP CREATE mystream mygroup $ MKSTREAM</span><br><span class="line"></span><br><span class="line"># 消费消息</span><br><span class="line">XREADGROUP GROUP mygroup consumer1 COUNT 10 STREAMS mystream &gt;</span><br><span class="line"></span><br><span class="line"># 确认消息</span><br><span class="line">XACK mystream mygroup message_id</span><br></pre></td></tr></table></figure><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class RedisDelayQueue &#123;</span><br><span class="line">    </span><br><span class="line">    public void addDelayTask(String task, long delayTime) &#123;</span><br><span class="line">        long executeTime = System.currentTimeMillis() + delayTime;</span><br><span class="line">        jedis.zadd(&quot;delay_queue&quot;, executeTime, task);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public List&lt;String&gt; getReadyTasks() &#123;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        Set&lt;String&gt; tasks = jedis.zrangeByScore(&quot;delay_queue&quot;, 0, now);</span><br><span class="line">        </span><br><span class="line">        if (!tasks.isEmpty()) &#123;</span><br><span class="line">            // 原子性删除已获取的任务</span><br><span class="line">            String script = </span><br><span class="line">                &quot;local tasks = redis.call(&#x27;zrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">                &quot;if #tasks &gt; 0 then &quot; +</span><br><span class="line">                &quot;  redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">                &quot;end &quot; +</span><br><span class="line">                &quot;return tasks&quot;;</span><br><span class="line">            </span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            List&lt;String&gt; result = (List&lt;String&gt;) jedis.eval(script, </span><br><span class="line">                Arrays.asList(&quot;delay_queue&quot;), Arrays.asList(String.valueOf(now)));</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能调优技巧"><a href="#性能调优技巧" class="headerlink" title="性能调优技巧"></a>性能调优技巧</h2><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p><strong>使用Hash存储小对象</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 不推荐：为每个用户字段单独设置key</span><br><span class="line">jedis.set(&quot;user:1001:name&quot;, &quot;张三&quot;);</span><br><span class="line">jedis.set(&quot;user:1001:age&quot;, &quot;25&quot;);</span><br><span class="line">jedis.set(&quot;user:1001:email&quot;, &quot;zhang@example.com&quot;);</span><br><span class="line"></span><br><span class="line">// 推荐：使用Hash存储</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;name&quot;, &quot;张三&quot;);</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;age&quot;, &quot;25&quot;);</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;email&quot;, &quot;zhang@example.com&quot;);</span><br></pre></td></tr></table></figure><p><strong>合理设置过期时间</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 避免同时过期导致雪崩</span><br><span class="line">int baseExpire = 3600;  // 1小时</span><br><span class="line">int randomExpire = baseExpire + new Random().nextInt(300);  // 增加0-5分钟随机时间</span><br><span class="line">jedis.setex(key, randomExpire, value);</span><br></pre></td></tr></table></figure><h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p><strong>批量操作优化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用Pipeline</span><br><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    pipeline.set(&quot;key&quot; + i, &quot;value&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">pipeline.sync();</span><br><span class="line"></span><br><span class="line">// 或使用原生批量命令</span><br><span class="line">Map&lt;String, String&gt; batch = new HashMap&lt;&gt;();</span><br><span class="line">// ... 填充数据</span><br><span class="line">jedis.mset(flattenMap(batch));</span><br></pre></td></tr></table></figure><h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p><strong>Lua脚本减少网络往返</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 原子性增加库存</span><br><span class="line">local current = redis.call(&#x27;get&#x27;, KEYS[1])</span><br><span class="line">if current == false then</span><br><span class="line">    return -1  -- key不存在</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">current = tonumber(current)</span><br><span class="line">if current &gt;= tonumber(ARGV[1]) then</span><br><span class="line">    redis.call(&#x27;decrby&#x27;, KEYS[1], ARGV[1])</span><br><span class="line">    return current - tonumber(ARGV[1])</span><br><span class="line">else</span><br><span class="line">    return -2  -- 库存不足</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>你好，我很乐意为你详细讲解 Redis。</p><p>Redis 是一个开源的、基于内存的、高性能的键值存储系统。它通常被用作数据库、缓存和消息中间件。Redis 支持多种数据结构，如字符串、哈希、列表、集合和有序集合，这使得它在各种应用场景中都非常灵活。</p><h3 id="Redis-的核心特点"><a href="#Redis-的核心特点" class="headerlink" title="Redis 的核心特点"></a>Redis 的核心特点</h3><hr><ul><li><strong>高性能</strong>: Redis 的所有数据都存储在内存中，因此读写速度非常快。通常，单个 Redis 实例每秒能处理超过 10 万次读写操作。</li><li><strong>丰富的数据结构</strong>: Redis 不仅仅是简单的键值存储，它支持多种复杂的数据结构，这让它能满足更广泛的应用需求。</li><li><strong>持久化</strong>: 虽然 Redis 是基于内存的，但它提供了两种不同的持久化方式，可以将数据从内存中保存到磁盘上，以防止服务器重启后数据丢失。</li><li><strong>原子性</strong>: Redis 的所有操作都是原子性的。这意味着一个命令要么完全执行，要么根本不执行，中间不会被打断，这在多客户端并发访问时尤其重要。</li><li><strong>主从复制</strong>: Redis 支持主从复制，可以将数据从一个主节点（Master）同步到一个或多个从节点（Slave），从而实现数据的备份和读写分离，提高系统的可用性和扩展性。</li><li><strong>高可用性与集群</strong>: Redis 提供了 Sentinel（哨兵）和 Cluster（集群）两种方案，来保证系统的高可用性和扩展性。</li></ul><h3 id="Redis-的数据结构详解"><a href="#Redis-的数据结构详解" class="headerlink" title="Redis 的数据结构详解"></a>Redis 的数据结构详解</h3><hr><p>这是 Redis 最有特色的地方，理解这些数据结构是掌握 Redis 的关键。</p><h4 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1. String (字符串)"></a>1. String (字符串)</h4><ul><li><strong>最基本的数据结构</strong>，可以存储任何类型的数据，比如字符串、数字或二进制数据。一个键最多可以存储 512MB 的值。</li><li><strong>常用命令</strong>:<ul><li><code>SET key value</code>: 设置键值对。</li><li><code>GET key</code>: 获取键对应的值。</li><li><code>INCR key</code>: 将键对应的值加 1，常用于计数器。</li><li><code>MSET key1 value1 key2 value2</code>: 同时设置多个键值对。</li><li><code>MGET key1 key2</code>: 同时获取多个键的值。</li></ul></li><li><strong>应用场景</strong>: 缓存、计数器、分布式锁等。</li></ul><h4 id="2-Hash-哈希"><a href="#2-Hash-哈希" class="headerlink" title="2. Hash (哈希)"></a>2. Hash (哈希)</h4><ul><li><strong>类似于一个键值对的集合</strong>。一个哈希键可以存储多个字段（field）和对应的值（value），非常适合存储对象。</li><li><strong>常用命令</strong>:<ul><li><code>HSET key field value</code>: 设置哈希键中一个字段的值。</li><li><code>HGET key field</code>: 获取哈希键中一个字段的值。</li><li><code>HGETALL key</code>: 获取哈希键中所有的字段和值。</li><li><code>HMSET key field1 value1 field2 value2</code>: 同时设置多个字段。</li><li><code>HDEL key field1 field2</code>: 删除一个或多个字段。</li></ul></li><li><strong>应用场景</strong>: 存储用户信息（如<code>user:100</code>作为键，<code>name</code>、<code>age</code>、<code>city</code>作为字段），商品信息等。</li></ul><h4 id="3-List-列表"><a href="#3-List-列表" class="headerlink" title="3. List (列表)"></a>3. List (列表)</h4><ul><li><strong>一个有序的、可以重复的字符串集合</strong>。可以从列表的头部或尾部添加或删除元素。</li><li><strong>常用命令</strong>:<ul><li><code>LPUSH key value1 value2</code>: 从列表的头部插入一个或多个值。</li><li><code>RPUSH key value1 value2</code>: 从列表的尾部插入一个或多个值。</li><li><code>LPOP key</code>: 从列表的头部移除并返回一个值。</li><li><code>RPOP key</code>: 从列表的尾部移除并返回一个值。</li><li><code>LRANGE key start stop</code>: 获取列表中指定范围的元素。</li></ul></li><li><strong>应用场景</strong>: 消息队列（队列、栈）、最新文章列表、历史记录等。</li></ul><h4 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4. Set (集合)"></a>4. Set (集合)</h4><ul><li><strong>一个无序的、不重复的字符串集合</strong>。集合提供了交集、并集和差集等操作。</li><li><strong>常用命令</strong>:<ul><li><code>SADD key member1 member2</code>: 向集合中添加一个或多个成员。</li><li><code>SMEMBERS key</code>: 获取集合中的所有成员。</li><li><code>SISMEMBER key member</code>: 判断一个成员是否在集合中。</li><li><code>SINTER key1 key2</code>: 求两个集合的交集。</li><li><code>SUNION key1 key2</code>: 求两个集合的并集。</li></ul></li><li><strong>应用场景</strong>: 社交网络中的共同好友、标签系统、去重等。</li></ul><h4 id="5-Sorted-Set-有序集合"><a href="#5-Sorted-Set-有序集合" class="headerlink" title="5. Sorted Set (有序集合)"></a>5. Sorted Set (有序集合)</h4><ul><li><strong>和集合类似，但每个成员都会关联一个分数（score）</strong>。通过这个分数，可以对集合中的成员进行排序。分数可以重复，但成员必须唯一。</li><li><strong>常用命令</strong>:<ul><li><code>ZADD key score1 member1 score2 member2</code>: 向有序集合中添加一个或多个带分数的成员。</li><li><code>ZRANGE key start stop</code>: 按分数从小到大排序，获取指定范围的成员。</li><li><code>ZREVRANGE key start stop</code>: 按分数从大到小排序，获取指定范围的成员。</li><li><code>ZSCORE key member</code>: 获取一个成员的分数。</li><li><code>ZINCRBY key increment member</code>: 给指定成员的分数增加指定值。</li></ul></li><li><strong>应用场景</strong>: 排行榜（游戏分数、热点新闻）、带权重的任务队列等。</li></ul><h3 id="Redis-的持久化机制"><a href="#Redis-的持久化机制" class="headerlink" title="Redis 的持久化机制"></a>Redis 的持久化机制</h3><hr><p>Redis 提供了两种持久化方式，可以将数据从内存保存到硬盘，确保数据不会因为服务重启而丢失。</p><h4 id="1-RDB-Redis-Database"><a href="#1-RDB-Redis-Database" class="headerlink" title="1. RDB (Redis Database)"></a>1. RDB (Redis Database)</h4><ul><li><strong>快照方式</strong>。它会在指定的时间间隔内，将内存中的数据快照写入到磁盘上一个二进制文件中（<code>dump.rdb</code>）。</li><li><strong>优点</strong>: RDB 文件是一个非常紧凑的二进制文件，非常适合备份和灾难恢复。</li><li><strong>缺点</strong>: 每次保存都会丢失从上次快照到现在之间的数据。</li></ul><h4 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2. AOF (Append Only File)"></a>2. AOF (Append Only File)</h4><ul><li><strong>日志方式</strong>。它会记录每一次对 Redis 数据库的写操作命令，并以追加（append）的方式写入到文件中。当 Redis 重启时，会重新执行 AOF 文件中的命令来恢复数据。</li><li><strong>优点</strong>: 数据丢失风险低，可以配置为每秒同步一次，或者每执行一个命令就同步一次。</li><li><strong>缺点</strong>: AOF 文件通常比 RDB 文件大，且恢复速度可能较慢。</li></ul><p>在实际应用中，通常会<strong>同时使用 RDB 和 AOF</strong>，以获得更高的可靠性。</p><h3 id="Redis-的高可用性"><a href="#Redis-的高可用性" class="headerlink" title="Redis 的高可用性"></a>Redis 的高可用性</h3><hr><h4 id="1-主从复制-Replication"><a href="#1-主从复制-Replication" class="headerlink" title="1. 主从复制 (Replication)"></a>1. 主从复制 (Replication)</h4><ul><li><strong>基本原理</strong>: 将一个 Redis 实例（主节点）的数据复制到一个或多个其他实例（从节点）。从节点的数据是主节点的完整副本。</li><li><strong>作用</strong>:<ul><li><strong>数据备份</strong>: 从节点可以作为数据的热备份。</li><li><strong>读写分离</strong>: 大多数读操作可以分流到从节点上，减轻主节点的压力。</li></ul></li></ul><h4 id="2-Sentinel-哨兵"><a href="#2-Sentinel-哨兵" class="headerlink" title="2. Sentinel (哨兵)"></a>2. Sentinel (哨兵)</h4><ul><li><strong>作用</strong>: 自动化管理主从复制集群。它是一个监控系统，可以监控主节点和从节点是否正常运行。</li><li><strong>核心功能</strong>:<ul><li><strong>监控</strong>: 不断检查主从节点是否正常工作。</li><li><strong>通知</strong>: 当某个 Redis 实例出现问题时，会发送通知。</li><li><strong>故障转移</strong>: 如果主节点发生故障，Sentinel 会自动从剩下的从节点中选举一个新的主节点，并让其他从节点切换到这个新的主节点上，从而实现高可用。</li></ul></li></ul><h4 id="3-Redis-Cluster-集群"><a href="#3-Redis-Cluster-集群" class="headerlink" title="3. Redis Cluster (集群)"></a>3. Redis Cluster (集群)</h4><ul><li><strong>作用</strong>: 解决 Redis 单机内存容量和并发量的瓶颈问题。它将数据分散到多个节点上，每个节点只负责存储部分数据。</li><li><strong>核心功能</strong>:<ul><li><strong>数据分片</strong>: 自动将数据分布在多个节点上。</li><li><strong>高可用性</strong>: 即使部分节点宕机，集群也能继续正常工作。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 分布式微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题单</title>
      <link href="/2025/09/11/%E9%A2%98%E5%8D%95/"/>
      <url>/2025/09/11/%E9%A2%98%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="🔹-数组（Array）"><a href="#🔹-数组（Array）" class="headerlink" title="🔹 数组（Array）"></a>🔹 数组（Array）</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(diff)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(diff), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-最大子数组和（Kadane-算法）"><a href="#2-最大子数组和（Kadane-算法）" class="headerlink" title="2. 最大子数组和（Kadane 算法）"></a>2. 最大子数组和（Kadane 算法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>], cur = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        cur = Math.max(nums[i], cur + nums[i]);</span><br><span class="line">        max = Math.max(max, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-链表（Linked-List）"><a href="#🔹-链表（Linked-List）" class="headerlink" title="🔹 链表（Linked List）"></a>🔹 链表（Linked List）</h2><h3 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1. 反转链表"></a>1. 反转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-判断链表是否有环（快慢指针）"><a href="#2-判断链表是否有环（快慢指针）" class="headerlink" title="2. 判断链表是否有环（快慢指针）"></a>2. 判断链表是否有环（快慢指针）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-栈-队列"><a href="#🔹-栈-队列" class="headerlink" title="🔹 栈 &#x2F; 队列"></a>🔹 栈 &#x2F; 队列</h2><h3 id="1-有效括号"><a href="#1-有效括号" class="headerlink" title="1. 有效括号"></a>1. 有效括号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-用栈实现队列"><a href="#2-用栈实现队列" class="headerlink" title="2. 用栈实现队列"></a>2. 用栈实现队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; in = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; out = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123; in.push(x); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123; peek(); <span class="keyword">return</span> out.pop(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (out.isEmpty()) <span class="keyword">while</span> (!in.isEmpty()) out.push(in.pop());</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123; <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-二叉树"><a href="#🔹-二叉树" class="headerlink" title="🔹 二叉树"></a>🔹 二叉树</h2><h3 id="1-二叉树的遍历（递归-迭代）"><a href="#1-二叉树的遍历（递归-迭代）" class="headerlink" title="1. 二叉树的遍历（递归 &amp; 迭代）"></a>1. 二叉树的遍历（递归 &amp; 迭代）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preorder(root.left);</span><br><span class="line">    preorder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) q.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) q.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-验证二叉搜索树"><a href="#2-验证二叉搜索树" class="headerlink" title="2. 验证二叉搜索树"></a>2. 验证二叉搜索树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(TreeNode node, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(node.left, min, node.val) &amp;&amp; helper(node.right, node.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-堆-优先队列"><a href="#🔹-堆-优先队列" class="headerlink" title="🔹 堆 &#x2F; 优先队列"></a>🔹 堆 &#x2F; 优先队列</h2><h3 id="1-数组中的第-K-大元素"><a href="#1-数组中的第-K-大元素" class="headerlink" title="1. 数组中的第 K 大元素"></a>1. 数组中的第 K 大元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">        pq.offer(n);</span><br><span class="line">        <span class="keyword">if</span> (pq.size() &gt; k) pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-图"><a href="#🔹-图" class="headerlink" title="🔹 图"></a>🔹 图</h2><h3 id="1-图的-BFS"><a href="#1-图的-BFS" class="headerlink" title="1. 图的 BFS"></a>1. 图的 BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> start, List&lt;List&lt;Integer&gt;&gt; graph)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.size()];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(start);</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nei : graph.get(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[nei]) &#123;</span><br><span class="line">                visited[nei] = <span class="literal">true</span>;</span><br><span class="line">                queue.offer(nei);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-岛屿数量（DFS）"><a href="#2-岛屿数量（DFS）" class="headerlink" title="2. 岛屿数量（DFS）"></a>2. 岛屿数量（DFS）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-排序算法"><a href="#🔹-排序算法" class="headerlink" title="🔹 排序算法"></a>🔹 排序算法</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left], i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    quickSort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-动态规划（DP）"><a href="#🔹-动态规划（DP）" class="headerlink" title="🔹 动态规划（DP）"></a>🔹 动态规划（DP）</h2><h3 id="1-爬楼梯（斐波那契）"><a href="#1-爬楼梯（斐波那契）" class="headerlink" title="1. 爬楼梯（斐波那契）"></a>1. 爬楼梯（斐波那契）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-最长公共子序列（LCS）"><a href="#2-最长公共子序列（LCS）" class="headerlink" title="2. 最长公共子序列（LCS）"></a>2. 最长公共子序列（LCS）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length(), n = text2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><blockquote><p>先给两个通用辅助类（很多题会用到）：<code>ListNode</code>（链表节点）和 <code>TreeNode</code>（二叉树节点）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用辅助类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> v) &#123; val = v; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">    TreeNode(<span class="type">int</span> v) &#123; val = v; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="目录（快速跳转）"><a href="#目录（快速跳转）" class="headerlink" title="目录（快速跳转）"></a>目录（快速跳转）</h1><ol><li>数组 &#x2F; 双指针 &#x2F; 滑动窗口 &#x2F; 前缀和</li><li>排序 &#x2F; 选择（Quickselect）</li><li>链表进阶</li><li>栈进阶 &#x2F; 单调栈</li><li>队列 &#x2F; 双端队列（滑动窗口最大值）</li><li>堆（合并 K 表、数据流中位数）</li><li>树（序列化&#x2F;反序列化、LCA、最大路径和）</li><li>图（拓扑、Dijkstra、Bellman-Ford、并查集）</li><li>动态规划（LIS、背包、DP 状态压缩等）</li><li>回溯（N 皇后、组合&#x2F;子集变体）</li><li>字符串（KMP、Rabin-Karp、最小覆盖子串）</li><li>字典树 Trie</li><li>线段树 &#x2F; 树状数组（Fenwick）</li><li>位运算 &#x2F; 数学小技巧</li><li>设计题（LRU Cache）</li></ol><hr><h1 id="1-数组-双指针-滑动窗口-前缀和"><a href="#1-数组-双指针-滑动窗口-前缀和" class="headerlink" title="1. 数组 &#x2F; 双指针 &#x2F; 滑动窗口 &#x2F; 前缀和"></a>1. 数组 &#x2F; 双指针 &#x2F; 滑动窗口 &#x2F; 前缀和</h1><h3 id="1-1-最长不含重复字符的子串（LeetCode-3）"><a href="#1-1-最长不含重复字符的子串（LeetCode-3）" class="headerlink" title="1.1 最长不含重复字符的子串（LeetCode 3）"></a>1.1 最长不含重复字符的子串（LeetCode 3）</h3><p>思路：滑动窗口 + 哈希表记录字符上次出现位置。<br> 复杂度：O(n) 时间，O(min(n, charset)) 空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>]; <span class="comment">// ASCII</span></span><br><span class="line">    Arrays.fill(last, -<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        start = Math.max(start, last[c] + <span class="number">1</span>);</span><br><span class="line">        maxLen = Math.max(maxLen, i - start + <span class="number">1</span>);</span><br><span class="line">        last[c] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-最小覆盖子串（LeetCode-76）"><a href="#1-2-最小覆盖子串（LeetCode-76）" class="headerlink" title="1.2 最小覆盖子串（LeetCode 76）"></a>1.2 最小覆盖子串（LeetCode 76）</h3><p>思路：滑动窗口 + 计数表；需要满足条件时收缩左边界。<br> 复杂度：O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; t.length()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) need[c]++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, required = t.length(), minLen = Integer.MAX_VALUE, start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right++);</span><br><span class="line">        <span class="keyword">if</span> (need[c]-- &gt; <span class="number">0</span>) required--;</span><br><span class="line">        <span class="keyword">while</span> (required == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; minLen) &#123; minLen = right - left; start = left; &#125;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left++);</span><br><span class="line">            <span class="keyword">if</span> (need[d]++ &gt;= <span class="number">0</span>) required++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-子数组和等于-k（LeetCode-560）"><a href="#1-3-子数组和等于-k（LeetCode-560）" class="headerlink" title="1.3 子数组和等于 k（LeetCode 560）"></a>1.3 子数组和等于 k（LeetCode 560）</h3><p>思路：前缀和 + 哈希表记录之前出现的前缀和频次。<br> 复杂度：O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    cnt.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">        sum += x;</span><br><span class="line">        res += cnt.getOrDefault(sum - k, <span class="number">0</span>);</span><br><span class="line">        cnt.put(sum, cnt.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-三数之和最接近（LeetCode-16）"><a href="#1-4-三数之和最接近（LeetCode-16）" class="headerlink" title="1.4 三数之和最接近（LeetCode 16）"></a>1.4 三数之和最接近（LeetCode 16）</h3><p>思路：排序 + 双指针。复杂度 O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">closest</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i + <span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(closest - target)) closest = sum;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) l++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> closest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-排序-选择-Quickselect"><a href="#2-排序-选择-Quickselect" class="headerlink" title="2. 排序 &#x2F; 选择 (Quickselect)"></a>2. 排序 &#x2F; 选择 (Quickselect)</h1><h3 id="2-1-Quickselect：第-k-小-第-k-大"><a href="#2-1-Quickselect：第-k-小-第-k-大" class="headerlink" title="2.1 Quickselect：第 k 小 &#x2F; 第 k 大"></a>2.1 Quickselect：第 k 小 &#x2F; 第 k 大</h3><p>思路：类似快速排序 partition，期望线性时间。<br> 复杂度：平均 O(n)，最坏 O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123; <span class="comment">// 1-based k-th smallest</span></span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(a, l, r);</span><br><span class="line">    <span class="keyword">if</span> (k == pivot) <span class="keyword">return</span> a[k];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; pivot) <span class="keyword">return</span> quickSelect(a, l, pivot - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(a, pivot + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivotVal</span> <span class="operator">=</span> a[r], i = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt;= pivotVal) swap(a, i++, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, i, r);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; a[i] = a[j]; a[j] = t; &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-链表进阶"><a href="#3-链表进阶" class="headerlink" title="3. 链表进阶"></a>3. 链表进阶</h1><h3 id="3-1-反转-k-个一组（LeetCode-25）"><a href="#3-1-反转-k-个一组（LeetCode-25）" class="headerlink" title="3.1 反转 k 个一组（LeetCode 25）"></a>3.1 反转 k 个一组（LeetCode 25）</h3><p>思路：分段反转。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), prev = dummy;</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; node != <span class="literal">null</span>; i++) node = node.next;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> prev.next, curr = tail.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            tail.next = curr.next;</span><br><span class="line">            curr.next = prev.next;</span><br><span class="line">            prev.next = curr;</span><br><span class="line">            curr = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-链表排序（归并排序，LeetCode-148）"><a href="#3-2-链表排序（归并排序，LeetCode-148）" class="headerlink" title="3.2 链表排序（归并排序，LeetCode 148）"></a>3.2 链表排序（归并排序，LeetCode 148）</h3><p>思路：递归分治，O(n log n) 时间，O(log n) 递归栈空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow.next; slow.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> merge(sortList(head), sortList(mid));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="literal">null</span> &amp;&amp; b != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.val &lt; b.val) &#123; p.next = a; a = a.next; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; p.next = b; b = b.next; &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = (a != <span class="literal">null</span>) ? a : b;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-环的入口（LeetCode-142）"><a href="#3-3-环的入口（LeetCode-142）" class="headerlink" title="3.3 环的入口（LeetCode 142）"></a>3.3 环的入口（LeetCode 142）</h3><p>思路：Floyd 快慢指针，找到相遇点后从头与相遇点同步移动。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next; fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span> (p != slow) &#123; p = p.next; slow = slow.next; &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-栈进阶-单调栈"><a href="#4-栈进阶-单调栈" class="headerlink" title="4. 栈进阶 &#x2F; 单调栈"></a>4. 栈进阶 &#x2F; 单调栈</h1><h3 id="4-1-单调栈模板（解决最近更大-更小元素、直方图最大矩形等）"><a href="#4-1-单调栈模板（解决最近更大-更小元素、直方图最大矩形等）" class="headerlink" title="4.1 单调栈模板（解决最近更大&#x2F;更小元素、直方图最大矩形等）"></a>4.1 单调栈模板（解决最近更大&#x2F;更小元素、直方图最大矩形等）</h3><p>思路：维护单调递增或递减栈（存下标）。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以寻找每个元素右侧第一个大于它的下标为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterIndices(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">    Deque&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; arr[i] &gt; arr[st.peek()]) res[st.pop()] = i;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-逆波兰表达式求值（LeetCode-150）"><a href="#4-2-逆波兰表达式求值（LeetCode-150）" class="headerlink" title="4.2 逆波兰表达式求值（LeetCode 150）"></a>4.2 逆波兰表达式求值（LeetCode 150）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String t : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+-*/&quot;</span>.contains(t)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> st.pop(), a = st.pop();</span><br><span class="line">            <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span> : st.push(a + b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span> : st.push(a - b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span> : st.push(a * b); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span> : st.push(a / b); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> st.push(Integer.parseInt(t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="5-队列-双端队列（滑动窗口最大值）"><a href="#5-队列-双端队列（滑动窗口最大值）" class="headerlink" title="5. 队列 &#x2F; 双端队列（滑动窗口最大值）"></a>5. 队列 &#x2F; 双端队列（滑动窗口最大值）</h1><h3 id="5-1-滑动窗口最大值（LeetCode-239）"><a href="#5-1-滑动窗口最大值（LeetCode-239）" class="headerlink" title="5.1 滑动窗口最大值（LeetCode 239）"></a>5.1 滑动窗口最大值（LeetCode 239）</h3><p>思路：用双端队列维护当前窗口的“候选”下标（单调递减）。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; dq.peekFirst() &lt; i - k + <span class="number">1</span>) dq.pollFirst();</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt; nums[i]) dq.pollLast();</span><br><span class="line">        dq.offerLast(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) res[i - k + <span class="number">1</span>] = nums[dq.peekFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="6-堆（PriorityQueue）"><a href="#6-堆（PriorityQueue）" class="headerlink" title="6. 堆（PriorityQueue）"></a>6. 堆（PriorityQueue）</h1><h3 id="6-1-合并-K-个有序链表（LeetCode-23）"><a href="#6-1-合并-K-个有序链表（LeetCode-23）" class="headerlink" title="6.1 合并 K 个有序链表（LeetCode 23）"></a>6.1 合并 K 个有序链表（LeetCode 23）</h3><p>思路：把每个链表头放入最小堆，循环弹出最小节点并推进。复杂度 O(N log k)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; a.val - b.val);</span><br><span class="line">    <span class="keyword">for</span> (ListNode ln : lists) <span class="keyword">if</span> (ln != <span class="literal">null</span>) pq.offer(ln);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        cur.next = node; cur = cur.next;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="literal">null</span>) pq.offer(node.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-数据流中位数（MedianFinder）"><a href="#6-2-数据流中位数（MedianFinder）" class="headerlink" title="6.2 数据流中位数（MedianFinder）"></a>6.2 数据流中位数（MedianFinder）</h3><p>思路：维护两个堆（大顶堆保存较小一半，小顶堆保存较大一半）。复杂度 add O(log n)，findMedian O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; small = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a); <span class="comment">// max-heap</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; large = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">// min-heap</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        small.offer(num);</span><br><span class="line">        large.offer(small.poll());</span><br><span class="line">        <span class="keyword">if</span> (small.size() &lt; large.size()) small.offer(large.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (small.size() &gt; large.size()) <span class="keyword">return</span> small.peek();</span><br><span class="line">        <span class="keyword">return</span> (small.peek() + large.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="7-树高级题"><a href="#7-树高级题" class="headerlink" title="7. 树高级题"></a>7. 树高级题</h1><h3 id="7-1-二叉树序列化与反序列化（LeetCode-297）"><a href="#7-1-二叉树序列化与反序列化（LeetCode-297）" class="headerlink" title="7.1 二叉树序列化与反序列化（LeetCode 297）"></a>7.1 二叉树序列化与反序列化（LeetCode 297）</h3><p>思路：BFS（层序）用特殊符号表示 null，或用前序 + 标记 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS 序列化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="literal">null</span>) sb.append(<span class="string">&quot;#,&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(n.val).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                q.offer(n.left); q.offer(n.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span> || data.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        String[] arr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(arr[<span class="number">0</span>]));</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (!arr[i].equals(<span class="string">&quot;#&quot;</span>)) &#123; node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(arr[i])); q.offer(node.left); &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (!arr[i].equals(<span class="string">&quot;#&quot;</span>)) &#123; node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(arr[i])); q.offer(node.right); &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-最近公共祖先（LCA-二叉树，LeetCode-236）"><a href="#7-2-最近公共祖先（LCA-二叉树，LeetCode-236）" class="headerlink" title="7.2 最近公共祖先（LCA, 二叉树，LeetCode 236）"></a>7.2 最近公共祖先（LCA, 二叉树，LeetCode 236）</h3><p>思路：递归搜索左右子树，若左右都有非 null 返回当前结点。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-二叉树最大路径和（LeetCode-124）"><a href="#7-3-二叉树最大路径和（LeetCode-124）" class="headerlink" title="7.3 二叉树最大路径和（LeetCode 124）"></a>7.3 二叉树最大路径和（LeetCode 124）</h3><p>思路：每个节点计算经过该节点的最大向下路径贡献，维护全局最大。复杂度 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, dfs(node.left));</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, dfs(node.right));</span><br><span class="line">    maxSum = Math.max(maxSum, node.val + left + right);</span><br><span class="line">    <span class="keyword">return</span> node.val + Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="8-图（高级）"><a href="#8-图（高级）" class="headerlink" title="8. 图（高级）"></a>8. 图（高级）</h1><h3 id="8-1-拓扑排序（Kahn-算法）"><a href="#8-1-拓扑排序（Kahn-算法）" class="headerlink" title="8.1 拓扑排序（Kahn 算法）"></a>8.1 拓扑排序（Kahn 算法）</h3><p>思路：入度为 0 的点入队，逐出并减小邻居入度。能检测有向无环图。复杂度 O(V+E)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">topoSort</span><span class="params">(<span class="type">int</span> n, List&lt;List&lt;Integer&gt;&gt; adj)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] indeg = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++) <span class="keyword">for</span> (<span class="type">int</span> v : adj.get(u)) indeg[v]++;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) q.offer(i);</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> q.poll(); res.add(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj.get(u)) <span class="keyword">if</span> (--indeg[v] == <span class="number">0</span>) q.offer(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.size() == n ? res : <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 若有环则返回空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-Dijkstra（带优先队列的邻接表版本）"><a href="#8-2-Dijkstra（带优先队列的邻接表版本）" class="headerlink" title="8.2 Dijkstra（带优先队列的邻接表版本）"></a>8.2 Dijkstra（带优先队列的邻接表版本）</h3><p>复杂度 O((V+E) log V)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123; <span class="type">int</span> to, w; Edge(<span class="type">int</span> t, <span class="type">int</span> w)&#123;to=t;<span class="built_in">this</span>.w=w;&#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dijkstra(<span class="type">int</span> n, List&lt;List&lt;Edge&gt;&gt; graph, <span class="type">int</span> src) &#123;</span><br><span class="line">    <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">    dist[src] = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(a-&gt;a[<span class="number">0</span>]));</span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, src&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span>[] cur = pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> cur[<span class="number">0</span>], u = cur[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (d &gt; dist[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : graph.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] + e.w &lt; dist[e.to]) &#123;</span><br><span class="line">                dist[e.to] = dist[u] + e.w;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;dist[e.to], e.to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-Bellman-Ford（带负权检测）"><a href="#8-3-Bellman-Ford（带负权检测）" class="headerlink" title="8.3 Bellman-Ford（带负权检测）"></a>8.3 Bellman-Ford（带负权检测）</h3><p>复杂度 O(V*E)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bellmanFord(<span class="type">int</span> n, <span class="type">int</span> src, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">    dist[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// relax n-1 times</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> e[<span class="number">0</span>], v = e[<span class="number">1</span>], w = e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (dist[u] != Integer.MAX_VALUE &amp;&amp; dist[u] + w &lt; dist[v]) dist[v] = dist[u] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测负环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[e[<span class="number">0</span>]] != Integer.MAX_VALUE &amp;&amp; dist[e[<span class="number">0</span>]] + e[<span class="number">2</span>] &lt; dist[e[<span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 存在负环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-并查集（Union-Find）"><a href="#8-4-并查集（Union-Find）" class="headerlink" title="8.4 并查集（Union-Find）"></a>8.4 并查集（Union-Find）</h3><p>思路：用于连通性、群组合并、Kruskal 最小生成树等。带路径压缩和按秩合并。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent, rank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n]; rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rx</span> <span class="operator">=</span> find(x), ry = find(y);</span><br><span class="line">        <span class="keyword">if</span> (rx == ry) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[rx] &lt; rank[ry]) parent[rx] = ry;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[rx] &gt; rank[ry]) parent[ry] = rx;</span><br><span class="line">        <span class="keyword">else</span> &#123; parent[ry] = rx; rank[rx]++; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="9-动态规划（DP）"><a href="#9-动态规划（DP）" class="headerlink" title="9. 动态规划（DP）"></a>9. 动态规划（DP）</h1><h3 id="9-1-最长递增子序列（LIS）-—-O-n-log-n"><a href="#9-1-最长递增子序列（LIS）-—-O-n-log-n" class="headerlink" title="9.1 最长递增子序列（LIS） — O(n log n)"></a>9.1 最长递增子序列（LIS） — O(n log n)</h3><p>思路：维护 tails 数组，tails[i] &#x3D; 最小结尾值使得长度为 i+1。可选重建路径。复杂度 O(n log n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] tails = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Arrays.binarySearch(tails, <span class="number">0</span>, size, x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) i = -(i + <span class="number">1</span>);</span><br><span class="line">        tails[i] = x;</span><br><span class="line">        <span class="keyword">if</span> (i == size) size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-0-1-背包（经典-DP）"><a href="#9-2-0-1-背包（经典-DP）" class="headerlink" title="9.2 0&#x2F;1 背包（经典 DP）"></a>9.2 0&#x2F;1 背包（经典 DP）</h3><p>时间 O(nW)，空间可滚动到 O(W)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span>[] wt, <span class="type">int</span>[] val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wt.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> W; w &gt;= wt[i]; w--) &#123;</span><br><span class="line">            dp[w] = Math.max(dp[w], dp[w - wt[i]] + val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-字符串拆分（Word-Break，LeetCode-139）"><a href="#9-3-字符串拆分（Word-Break，LeetCode-139）" class="headerlink" title="9.3 字符串拆分（Word Break，LeetCode 139）"></a>9.3 字符串拆分（Word Break，LeetCode 139）</h3><p>思路：DP，dp[i] &#x3D; [0..i)是否可拆分。复杂度 O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123; dp[i] = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="10-回溯（Backtracking）"><a href="#10-回溯（Backtracking）" class="headerlink" title="10. 回溯（Backtracking）"></a>10. 回溯（Backtracking）</h1><h3 id="10-1-N-皇后（LeetCode-51）"><a href="#10-1-N-皇后（LeetCode-51）" class="headerlink" title="10.1 N 皇后（LeetCode 51）"></a>10.1 N 皇后（LeetCode 51）</h3><p>思路：回溯 + 列 &#x2F; 斜对角 剪枝，可用位运算优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[][] board = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>[] row : board) Arrays.fill(row, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    backtrack(<span class="number">0</span>, board, res, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">char</span>[][] board, List&lt;List&lt;String&gt;&gt; res, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        List&lt;String&gt; sol = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] r : board) sol.add(<span class="keyword">new</span> <span class="title class_">String</span>(r));</span><br><span class="line">        res.add(sol);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValid(board, row, col, n)) <span class="keyword">continue</span>;</span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        backtrack(row + <span class="number">1</span>, board, res, n);</span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-组合总和（Combination-Sum，LeetCode-39）"><a href="#10-2-组合总和（Combination-Sum，LeetCode-39）" class="headerlink" title="10.2 组合总和（Combination Sum，LeetCode 39）"></a>10.2 组合总和（Combination Sum，LeetCode 39）</h3><p>思路：回溯，注意去重与剪枝（排序后剪枝）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    back(candidates, <span class="number">0</span>, target, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">back</span><span class="params">(<span class="type">int</span>[] cand, <span class="type">int</span> idx, <span class="type">int</span> target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123; res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path)); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; cand.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cand[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">        path.add(cand[i]);</span><br><span class="line">        back(cand, i, target - cand[i], path, res); <span class="comment">// i 允许重复</span></span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="11-字符串算法"><a href="#11-字符串算法" class="headerlink" title="11. 字符串算法"></a>11. 字符串算法</h1><h3 id="11-1-KMP（计算-LPS）"><a href="#11-1-KMP（计算-LPS）" class="headerlink" title="11.1 KMP（计算 LPS）"></a>11.1 KMP（计算 LPS）</h3><p>思路：预处理模式串得到最长相同前后缀数组 lps，然后线性匹配。复杂度 O(n+m)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] computeLPS(String pat) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pat.length();</span><br><span class="line">    <span class="type">int</span>[] lps = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pat.charAt(i) == pat.charAt(len)) &#123; lps[i++] = ++len; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) len = lps[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123; lps[i++] = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kmp</span><span class="params">(String s, String pat)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] lps = computeLPS(pat);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == pat.charAt(j)) &#123; i++; j++; <span class="keyword">if</span> (j == pat.length()) <span class="keyword">return</span> i - j; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) j = lps[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-Rabin-Karp（字符串哈希）"><a href="#11-2-Rabin-Karp（字符串哈希）" class="headerlink" title="11.2 Rabin-Karp（字符串哈希）"></a>11.2 Rabin-Karp（字符串哈希）</h3><p>思路：用滚动哈希快速比较子串，注意哈希冲突处理。复杂度 平均 O(n).</p><hr><h1 id="12-字典树-Trie"><a href="#12-字典树-Trie" class="headerlink" title="12. 字典树 Trie"></a>12. 字典树 Trie</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node[] next = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">boolean</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) cur.next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="13-线段树-树状数组（Fenwick）"><a href="#13-线段树-树状数组（Fenwick）" class="headerlink" title="13. 线段树 &#x2F; 树状数组（Fenwick）"></a>13. 线段树 &#x2F; 树状数组（Fenwick）</h1><h3 id="13-1-树状数组（Fenwick）"><a href="#13-1-树状数组（Fenwick）" class="headerlink" title="13.1 树状数组（Fenwick）"></a>13.1 树状数组（Fenwick）</h3><p>功能：前缀和 &#x2F; 单点更新，构建简单，复杂度 O(log n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">int</span> n; <span class="type">int</span>[] bit;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fenwick</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="built_in">this</span>.n = n; bit = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> &#123; <span class="keyword">for</span> (; i &lt;= n; i += i &amp; -i) bit[i] += delta; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; <span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i -= i &amp; -i) s += bit[i]; <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> &#123; <span class="keyword">return</span> query(r) - query(l - <span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-线段树（区间和-区间更新）"><a href="#13-2-线段树（区间和-区间更新）" class="headerlink" title="13.2 线段树（区间和 &#x2F; 区间更新）"></a>13.2 线段树（区间和 &#x2F; 区间更新）</h3><p>实现略长，模式熟悉后直接写模板即可 —— 支持区间查询&#x2F;更新，复杂度 O(log n)。</p><hr><h1 id="14-位运算-数学小技巧"><a href="#14-位运算-数学小技巧" class="headerlink" title="14. 位运算 &#x2F; 数学小技巧"></a>14. 位运算 &#x2F; 数学小技巧</h1><ul><li>单数：<code>x &amp; 1</code>；取反 <code>~x</code>。</li><li>异或特性：<code>a ^ a = 0</code>，用于求单数、交换不需要临时变量等。</li><li><code>lowbit(x) = x &amp; -x</code>（树状数组用到）。</li><li>统计 1 的个数（Hamming weight）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123; n &amp;= (n - <span class="number">1</span>); cnt++; &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单数问题（数组中其它数出现两次，只有一个出现一次）：使用 XOR。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) res ^= x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="15-设计题：LRU-Cache（双向链表-哈希表）"><a href="#15-设计题：LRU-Cache（双向链表-哈希表）" class="headerlink" title="15. 设计题：LRU Cache（双向链表 + 哈希表）"></a>15. 设计题：LRU Cache（双向链表 + 哈希表）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123; <span class="type">int</span> key, val; Node prev, next; Node(<span class="type">int</span> k,<span class="type">int</span> v)&#123;key=k;val=v;&#125; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>,<span class="number">0</span>), tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        capacity = cap;</span><br><span class="line">        head.next = tail; tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next; node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.next = head.next; node.prev = head;</span><br><span class="line">        head.next.prev = node; head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        remove(node); addToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key); node.val = value;</span><br><span class="line">            remove(node); addToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">tailPrev</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">                remove(tailPrev);</span><br><span class="line">                map.remove(tailPrev.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            addToHead(node); map.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="小结与复习建议（给你一个刷题路线）"><a href="#小结与复习建议（给你一个刷题路线）" class="headerlink" title="小结与复习建议（给你一个刷题路线）"></a>小结与复习建议（给你一个刷题路线）</h1><ul><li>基础题（数组 &#x2F; 链表 &#x2F; 栈 &#x2F; 队列 &#x2F; 哈希表）：先熟练增删查遍历，能写模板。</li><li>递归 + 树（中序&#x2F;前序&#x2F;后序&#x2F;层序） → 再做 LCA、序列化、最低深度。</li><li>双指针 &#x2F; 滑动窗口 &#x2F; 单调栈：拿来解决子数组、子串类题。</li><li>堆 &#x2F; 并查集 &#x2F; 图（BFS&#x2F;DFS&#x2F;Dijkstra&#x2F;拓扑） → 面试常考。</li><li>动态规划：从经典 1D DP → 背包、序列 DP → 状态压缩。</li><li>回溯：背诵回溯模板，练 N 皇后、子集 &#x2F; 组合 &#x2F; 排列 变体。</li><li>设计题：LRU&#x2F;MedianFinder&#x2F;Trie&#x2F;SegmentTree 模板要熟悉。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2025/09/11/%E7%AE%97%E6%B3%95/"/>
      <url>/2025/09/11/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="🔥-常见算法分类-Java实现"><a href="#🔥-常见算法分类-Java实现" class="headerlink" title="🔥 常见算法分类 + Java实现"></a>🔥 常见算法分类 + Java实现</h1><hr><h2 id="1-排序算法-Sorting"><a href="#1-排序算法-Sorting" class="headerlink" title="1. 排序算法 (Sorting)"></a>1. 排序算法 (Sorting)</h2><h3 id="1-1-冒泡排序-Bubble-Sort"><a href="#1-1-冒泡排序-Bubble-Sort" class="headerlink" title="1.1 冒泡排序 (Bubble Sort)"></a>1.1 冒泡排序 (Bubble Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-选择排序-Selection-Sort"><a href="#1-2-选择排序-Selection-Sort" class="headerlink" title="1.2 选择排序 (Selection Sort)"></a>1.2 选择排序 (Selection Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-插入排序-Insertion-Sort"><a href="#1-3-插入排序-Insertion-Sort" class="headerlink" title="1.3 插入排序 (Insertion Sort)"></a>1.3 插入排序 (Insertion Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-归并排序-Merge-Sort"><a href="#1-4-归并排序-Merge-Sort" class="headerlink" title="1.4 归并排序 (Merge Sort)"></a>1.4 归并排序 (Merge Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(arr, l, mid);</span><br><span class="line">    mergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        tmp[k++] = (arr[i] &lt;= arr[j]) ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = arr[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmp.length; i++) arr[l + i] = tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-快速排序-Quick-Sort"><a href="#1-5-快速排序-Quick-Sort" class="headerlink" title="1.5 快速排序 (Quick Sort)"></a>1.5 快速排序 (Quick Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(arr, l, r);</span><br><span class="line">    quickSort(arr, l, p - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[r], i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i]; arr[i] = arr[j]; arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i+<span class="number">1</span>]; arr[i+<span class="number">1</span>] = arr[r]; arr[r] = tmp;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-查找算法-Searching"><a href="#2-查找算法-Searching" class="headerlink" title="2. 查找算法 (Searching)"></a>2. 查找算法 (Searching)</h2><h3 id="2-1-顺序查找-Linear-Search"><a href="#2-1-顺序查找-Linear-Search" class="headerlink" title="2.1 顺序查找 (Linear Search)"></a>2.1 顺序查找 (Linear Search)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">linearSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == target) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-二分查找-Binary-Search-（数组有序）"><a href="#2-2-二分查找-Binary-Search-（数组有序）" class="headerlink" title="2.2 二分查找 (Binary Search)（数组有序）"></a>2.2 二分查找 (Binary Search)（数组有序）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-双指针算法-Two-Pointers"><a href="#3-双指针算法-Two-Pointers" class="headerlink" title="3. 双指针算法 (Two Pointers)"></a>3. 双指针算法 (Two Pointers)</h2><h3 id="3-1-反转数组"><a href="#3-1-反转数组" class="headerlink" title="3.1 反转数组"></a>3.1 反转数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[l]; arr[l] = arr[r]; arr[r] = tmp;</span><br><span class="line">        l++; r--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-三数之和-LeetCode-15"><a href="#3-2-三数之和-LeetCode-15" class="headerlink" title="3.2 三数之和 (LeetCode 15)"></a>3.2 三数之和 (LeetCode 15)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i+<span class="number">1</span>, r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l+<span class="number">1</span>]) l++;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r-<span class="number">1</span>]) r--;</span><br><span class="line">                l++; r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-动态规划-Dynamic-Programming"><a href="#4-动态规划-Dynamic-Programming" class="headerlink" title="4. 动态规划 (Dynamic Programming)"></a>4. 动态规划 (Dynamic Programming)</h2><h3 id="4-1-斐波那契数列"><a href="#4-1-斐波那契数列" class="headerlink" title="4.1 斐波那契数列"></a>4.1 斐波那契数列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-爬楼梯-LeetCode-70"><a href="#4-2-爬楼梯-LeetCode-70" class="headerlink" title="4.2 爬楼梯 (LeetCode 70)"></a>4.2 爬楼梯 (LeetCode 70)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a + b;</span><br><span class="line">        a = b; b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-最长公共子序列-LCS"><a href="#4-3-最长公共子序列-LCS" class="headerlink" title="4.3 最长公共子序列 (LCS)"></a>4.3 最长公共子序列 (LCS)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lcs</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length(), n = s2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-贪心算法-Greedy"><a href="#5-贪心算法-Greedy" class="headerlink" title="5. 贪心算法 (Greedy)"></a>5. 贪心算法 (Greedy)</h2><h3 id="5-1-跳跃游戏-LeetCode-55"><a href="#5-1-跳跃游戏-LeetCode-55" class="headerlink" title="5.1 跳跃游戏 (LeetCode 55)"></a>5.1 跳跃游戏 (LeetCode 55)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">farthest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; farthest) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        farthest = Math.max(farthest, i + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6-分治算法-Divide-Conquer"><a href="#6-分治算法-Divide-Conquer" class="headerlink" title="6. 分治算法 (Divide &amp; Conquer)"></a>6. 分治算法 (Divide &amp; Conquer)</h2><h3 id="6-1-归并排序-见上"><a href="#6-1-归并排序-见上" class="headerlink" title="6.1 归并排序 (见上)"></a>6.1 归并排序 (见上)</h3><h3 id="6-2-快速排序-见上"><a href="#6-2-快速排序-见上" class="headerlink" title="6.2 快速排序 (见上)"></a>6.2 快速排序 (见上)</h3><hr><h2 id="7-回溯算法-Backtracking"><a href="#7-回溯算法-Backtracking" class="headerlink" title="7. 回溯算法 (Backtracking)"></a>7. 回溯算法 (Backtracking)</h2><h3 id="7-1-全排列-LeetCode-46"><a href="#7-1-全排列-LeetCode-46" class="headerlink" title="7.1 全排列 (LeetCode 46)"></a>7.1 全排列 (LeetCode 46)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    backtrack(nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length], <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        path.add(nums[i]);</span><br><span class="line">        backtrack(nums, used, path, res);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="8-图算法-Graph-Algorithms"><a href="#8-图算法-Graph-Algorithms" class="headerlink" title="8. 图算法 (Graph Algorithms)"></a>8. 图算法 (Graph Algorithms)</h2><h3 id="8-1-BFS（最短路径）"><a href="#8-1-BFS（最短路径）" class="headerlink" title="8.1 BFS（最短路径）"></a>8.1 BFS（最短路径）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    q.add(start); visited.add(start);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nei : graph.getOrDefault(node, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(nei)) &#123;</span><br><span class="line">                visited.add(nei);</span><br><span class="line">                q.add(nei);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-DFS"><a href="#8-2-DFS" class="headerlink" title="8.2 DFS"></a>8.2 DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="type">int</span> start, Set&lt;Integer&gt; visited)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.contains(start)) <span class="keyword">return</span>;</span><br><span class="line">    visited.add(start);</span><br><span class="line">    System.out.print(start + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nei : graph.getOrDefault(start, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">        dfs(graph, nei, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-Dijkstra-最短路径"><a href="#8-3-Dijkstra-最短路径" class="headerlink" title="8.3 Dijkstra 最短路径"></a>8.3 Dijkstra 最短路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dijkstra(<span class="type">int</span>[][] graph, <span class="type">int</span> src) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">    <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">    dist[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; (u == -<span class="number">1</span> || dist[j] &lt; dist[u])) u = j;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[u][v] != <span class="number">0</span> &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + graph[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题目</title>
      <link href="/2025/09/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
      <url>/2025/09/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Java-基础语法-关键字"><a href="#一、Java-基础语法-关键字" class="headerlink" title="一、Java 基础语法 &amp; 关键字"></a>一、Java 基础语法 &amp; 关键字</h2><h2 id="1-JDK、JRE-和-JVM-的区别"><a href="#1-JDK、JRE-和-JVM-的区别" class="headerlink" title="1. JDK、JRE 和 JVM 的区别"></a>1. JDK、JRE 和 JVM 的区别</h2><ul><li><strong>JVM（Java Virtual Machine）</strong>：Java 虚拟机，负责执行字节码（<code>.class</code>）。提供类加载、字节码校验、内存管理（堆、方法区）、执行引擎、垃圾回收、线程调度等。是抽象的规范，具体由不同厂商实现（HotSpot、OpenJ9 等）。</li><li><strong>JRE（Java Runtime Environment）</strong>：运行环境，包含 JVM、核心类库（rt.jar 或 modules）、以及运行时需要的其它资源。用于运行 Java 程序。</li><li><strong>JDK（Java Development Kit）</strong>：开发工具包，包含 JRE + 开发工具（<code>javac</code>、<code>jar</code>、<code>javadoc</code>、调试工具等）。用于开发 Java 程序。<br> 总结：JDK ⊃ JRE ⊃ JVM（JDK 包含 JRE，JRE 包含 JVM）。</li></ul><hr><h2 id="2-Java-的跨平台原理是什么？"><a href="#2-Java-的跨平台原理是什么？" class="headerlink" title="2. Java 的跨平台原理是什么？"></a>2. Java 的跨平台原理是什么？</h2><ul><li>Java 程序先由 <code>javac</code> 编译成与平台无关的 <strong>字节码</strong>（<code>.class</code>）。字节码不是机器码，而是供 JVM 执行的指令集。</li><li>每个平台（Windows&#x2F;Linux&#x2F;macOS）有相应的 JVM 实现，JVM 把字节码翻译成该平台的机器指令（通过解释器、JIT 编译器等）。因此同一套 <code>.class</code> 可以在不同平台的 JVM 上运行 —— “一次编写，处处运行”（Write Once, Run Anywhere）。</li><li>其它保证跨平台的要点：标准库隐藏平台差异（I&#x2F;O、线程等），需避免使用与平台绑定的本地代码（JNI）。</li></ul><hr><h2 id="3-Java-的基本数据类型有哪些？各自的默认值？"><a href="#3-Java-的基本数据类型有哪些？各自的默认值？" class="headerlink" title="3. Java 的基本数据类型有哪些？各自的默认值？"></a>3. Java 的基本数据类型有哪些？各自的默认值？</h2><p>8 种基本类型及默认值（成员变量&#x2F;数组元素；局部变量无默认值必须初始化）：</p><ul><li><code>byte</code>：1 byte，默认值 <code>0</code></li><li><code>short</code>：2 bytes，默认值 <code>0</code></li><li><code>int</code>：4 bytes，默认值 <code>0</code></li><li><code>long</code>：8 bytes，默认值 <code>0L</code></li><li><code>float</code>：4 bytes，默认值 <code>0.0f</code></li><li><code>double</code>：8 bytes，默认值 <code>0.0d</code></li><li><code>char</code>：2 bytes（UTF-16 code unit），默认值 <code>&#39;\u0000&#39;</code>（即 0）</li><li><code>boolean</code>：JVM 语义上用 1 bit 表示，默认值 <code>false</code></li></ul><p>另外，<strong>引用类型</strong>（对象、数组等）的默认值是 <code>null</code>。</p><hr><h2 id="4-byte、short、int、long-各占多少字节？"><a href="#4-byte、short、int、long-各占多少字节？" class="headerlink" title="4. byte、short、int、long 各占多少字节？"></a>4. <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> 各占多少字节？</h2><ul><li><code>byte</code>：<strong>1 字节</strong>（8 位）</li><li><code>short</code>：<strong>2 字节</strong>（16 位）</li><li><code>int</code>：<strong>4 字节</strong>（32 位）</li><li><code>long</code>：<strong>8 字节</strong>（64 位）</li></ul><p>（上述为 Java 语言规范定义，与平台无关。）</p><hr><h2 id="5-float-和-double-的区别？"><a href="#5-float-和-double-的区别？" class="headerlink" title="5. float 和 double 的区别？"></a>5. <code>float</code> 和 <code>double</code> 的区别？</h2><ul><li>精度与存储：<ul><li><code>float</code>：32 位单精度浮点（IEEE 754），约 6~7 位有效数字。</li><li><code>double</code>：64 位双精度浮点（IEEE 754），约 15~16 位有效数字。</li></ul></li><li>精度更高的 <code>double</code> 更常用；<code>float</code> 用于节省内存或与特定 API（如图形库）兼容。</li><li>注意：浮点数有精度误差，不适合做精确货币计算（应使用 <code>BigDecimal</code>）。</li><li>默认浮点字面量为 <code>double</code>（例如 <code>1.2</code> 是 <code>double</code>，写成 <code>1.2f</code> 才是 <code>float</code>）。</li></ul><hr><h2 id="6-char-类型占几个字节？能存汉字吗？"><a href="#6-char-类型占几个字节？能存汉字吗？" class="headerlink" title="6. char 类型占几个字节？能存汉字吗？"></a>6. <code>char</code> 类型占几个字节？能存汉字吗？</h2><ul><li><code>char</code> 占 <strong>2 字节</strong>（16 位），表示 UTF-16 的一个 code unit。</li><li>能否存汉字：多数常用汉字（位于基本多文种平面 BMP）可以用单个 <code>char</code> 表示（例如 <code>&#39;你&#39;</code>）；但有些罕见汉字或 emoji 属于补充平面（Supplementary Planes），它们需要 <strong>两个 char（称为 surrogate pair）</strong> 来表示。</li><li>因此，单个 <code>char</code> 能表示一个 UTF-16 code unit，而不是完整的 Unicode code point。处理 Unicode 字符时注意使用 <code>int codePoint</code> &#x2F; <code>Character</code> 的相关 API。</li></ul><hr><h2 id="7-自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？"><a href="#7-自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？" class="headerlink" title="7. 自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？"></a>7. 自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？</h2><ul><li><p><strong>概念</strong>：</p><ul><li>装箱：把基本类型自动转换成对应的包装类型（如 <code>int</code> → <code>Integer</code>）。</li><li>拆箱：把包装类型自动转换回基本类型（如 <code>Integer</code> → <code>int</code>）。</li></ul></li><li><p><strong>编译器行为</strong>：自动装箱&#x2F;拆箱是在编译期由 Java 编译器插入对应的调用，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;        <span class="comment">// 编译器会转换为 Integer.valueOf(10)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;             <span class="comment">// 编译器会转换为 a.intValue()</span></span><br></pre></td></tr></table></figure></li><li><p><strong>valueOf 缓存</strong>：包装类（如 <code>Integer.valueOf(int)</code>）会对小整数（默认 -128 到 127）做缓存以重用对象，减少频繁创建对象。</p></li><li><p><strong>注意事项</strong>：</p><ul><li><p>拆箱 <code>null</code> 会抛出 <code>NullPointerException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x; <span class="comment">// NPE</span></span><br></pre></td></tr></table></figure></li><li><p>装箱&#x2F;拆箱会有性能开销（对象创建、装箱&#x2F;拆箱方法调用），在性能敏感场景尽量使用基本类型或手动优化。</p></li><li><p>比较时注意：<code>Integer a = 100; Integer b = 100; a==b</code> 在缓存范围内可能为 <code>true</code>，超出范围则通常为 <code>false</code>。</p></li></ul></li></ul><hr><h2 id="8-和-equals-的区别？"><a href="#8-和-equals-的区别？" class="headerlink" title="8. == 和 equals() 的区别？"></a>8. <code>==</code> 和 <code>equals()</code> 的区别？</h2><ul><li><strong>&#x3D;&#x3D;</strong>：<ul><li>对于基本类型：比较 <strong>值</strong>（数值是否相等）。</li><li>对于引用类型：比较 <strong>引用地址</strong>（是否是同一个对象）。</li></ul></li><li><strong>equals()</strong>：<ul><li>是 <code>Object</code> 的方法，默认实现也是比较引用（等价于 <code>==</code>）。</li><li>许多类（如 <code>String</code>、<code>Integer</code>、集合类等）重写了 <code>equals()</code>，用于比较<strong>逻辑&#x2F;内容相等</strong>。</li></ul></li><li><strong>使用建议</strong>：<ul><li>比较对象内容用 <code>equals()</code>（需检查 <code>null</code>），比较是否同一实例用 <code>==</code>。</li><li>与 <code>equals()</code> 配套应重写 <code>hashCode()</code>（见下题）。</li></ul></li></ul><hr><h2 id="9-hashCode-和-equals-的关系？"><a href="#9-hashCode-和-equals-的关系？" class="headerlink" title="9. hashCode 和 equals 的关系？"></a>9. <code>hashCode</code> 和 <code>equals</code> 的关系？</h2><ul><li><strong>合同（Contract）</strong>（重要）：<ol><li>如果两个对象通过 <code>equals()</code> 被判定为相等（<code>a.equals(b)</code> 为 <code>true</code>），那么 <code>a.hashCode() == b.hashCode()</code> 必须成立。</li><li>反之不要求：<code>hashCode</code> 相等的对象不一定 <code>equals()</code> 相等（哈希冲突允许）。</li></ol></li><li><strong>在哈希集合中的角色</strong>：<ul><li>哈希表（<code>HashMap</code>&#x2F;<code>HashSet</code>）先用 <code>hashCode()</code> 找到桶（bucket），若桶中有多个元素，再用 <code>equals()</code> 逐个比较确认相等或冲突。</li><li>如果只重写 <code>equals()</code> 而不重写 <code>hashCode()</code> 会破坏集合行为（例如放入 <code>HashSet</code> 后无法正确查找）。</li></ul></li><li><strong>实现要点</strong>：<ul><li><code>hashCode()</code> 要尽量分散（降低冲突），并在对象不可变字段上基于相同规则计算。</li><li>若对象可变，若用于哈希集合要小心：修改字段会导致 <code>hashCode()</code> 改变，破坏集合内部结构。</li></ul></li></ul><hr><h2 id="10-String、StringBuffer、StringBuilder-的区别？"><a href="#10-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="10. String、StringBuffer、StringBuilder 的区别？"></a>10. <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code> 的区别？</h2><ul><li><strong>String</strong>：<ul><li>不可变（immutable），每次修改都会产生新的对象（或新内部 char&#x2F;byte 数组）。</li><li>线程安全（因为不可变），适合频繁读取、少量修改的场景。</li></ul></li><li><strong>StringBuffer</strong>：<ul><li>可变的字符序列（内部有缓冲区 <code>char[]</code>&#x2F;<code>byte[]</code>），几乎与 <code>StringBuilder</code> 接口相同。</li><li><strong>线程安全</strong>，其方法大多使用 <code>synchronized</code>，因此在多线程下可以被多个线程安全使用。</li><li>相对较慢（同步开销）。</li></ul></li><li><strong>StringBuilder（Java 5+）</strong>：<ul><li>可变，<strong>非线程安全</strong>（没有同步），比 <code>StringBuffer</code> 快。</li><li>推荐在单线程或外部已同步的场景下使用。</li></ul></li><li><strong>选择建议</strong>：<ul><li>多线程需要可变字符串：<code>StringBuffer</code>（或外部同步）。</li><li>单线程&#x2F;局部构造字符串：<code>StringBuilder</code>。</li><li>常量字符串或少量拼接：<code>String</code>（编译器对 <code>+</code> 会优化为 <code>StringBuilder</code>）。</li></ul></li></ul><hr><h2 id="11-为什么-String-是不可变的（immutable）？"><a href="#11-为什么-String-是不可变的（immutable）？" class="headerlink" title="11. 为什么 String 是不可变的（immutable）？"></a>11. 为什么 <code>String</code> 是不可变的（immutable）？</h2><ol><li><strong>安全性</strong>：<code>String</code> 经常用于关键场景（类加载器、网络地址、文件名、权限检查、数据库连接字符串等）。不可变保证在传递引用时不被恶意或意外修改。</li><li><strong>线程安全</strong>：不可变对象固有线程安全，多个线程可共享同一 <code>String</code> 实例而无需同步。</li><li><strong>性能（缓存 hashCode）</strong>：<code>String</code> 的哈希值可缓存（<code>hash</code> 字段），便于作为 Map 的 key，避免重复计算。</li><li><strong>字符串常量池</strong>：可安全地将字面量放入池中重用，不用复制或担心修改。</li><li><strong>优化</strong>：JVM 可进行共享、常量折叠等优化（更易于实现某些编译期&#x2F;运行期优化）。</li></ol><hr><h2 id="12-String-常量池的实现机制？"><a href="#12-String-常量池的实现机制？" class="headerlink" title="12. String 常量池的实现机制？"></a>12. <code>String</code> 常量池的实现机制？</h2><ul><li><strong>概念</strong>：编译期和运行期维护一个字符串池（String Intern Pool），用于存放字符串字面量（literal）和显式 <code>intern()</code> 后的字符串，以便重用相同内容的 <code>String</code> 实例。</li><li><strong>编译期</strong>：源代码中的字符串字面量（如 <code>&quot;abc&quot;</code>）会被放到常量池（编译后的 class 文件常量池），类加载后这些字面量会放入运行时的字符串池。</li><li><strong>运行期</strong>：<ul><li>以前（Java 6 及更早）：字符串常量池在 PermGen（方法区）中。</li><li>Java 7 起：常量池迁移到 Java 堆（运行时常量池也在堆里），避免 PermGen 问题。</li></ul></li><li><strong>intern()</strong>：当调用 <code>s.intern()</code> 时，JVM 会检查池中是否已有相同内容的字符串：<ul><li>若存在，返回池中的引用；</li><li>若不存在，将该字符串的引用加入池并返回它。</li></ul></li><li><strong>编译时优化</strong>：字符串常量的拼接（编译时常量）会在编译期合并，如 <code>&quot;a&quot; + &quot;b&quot;</code> → <code>&quot;ab&quot;</code>，直接放入常量池；而运行时拼接（变量参与）则使用 <code>StringBuilder</code>。</li></ul><hr><h2 id="13-new-String-abc-创建了几个对象？"><a href="#13-new-String-abc-创建了几个对象？" class="headerlink" title="13. new String(&quot;abc&quot;) 创建了几个对象？"></a>13. <code>new String(&quot;abc&quot;)</code> 创建了几个对象？</h2><ul><li><strong>通常情形</strong>：<ul><li>若 <code>&quot;abc&quot;</code> 字面量尚未在常量池中存在，执行 <code>new String(&quot;abc&quot;)</code> 会导致 <strong>两个对象</strong> 被创建：常量池中的 <code>&quot;abc&quot;</code>（一个 <code>String</code>）和堆中通过 <code>new</code> 创建的新的 <code>String</code> 实例（内容通常是对常量池中字符数组的复制或共享，具体实现随 Java 版本而异）。</li><li>如果字面量 <code>&quot;abc&quot;</code> 已经存在于常量池中（例如之前被加载过），那么 <code>new String(&quot;abc&quot;)</code> 只会创建 <strong>一个堆对象</strong>（new 的那个 <code>String</code>）。</li></ul></li><li><strong>注意</strong>：自 Java 7&#x2F;9 后 <code>String</code> 内部实现改变（压缩字符串、byte[] 存储等），但逻辑上上述结论成立：通常 1 或 2 个对象，取决于常量池中是否已存在该字面量。</li></ul><hr><h2 id="14-final-关键字的作用？"><a href="#14-final-关键字的作用？" class="headerlink" title="14. final 关键字的作用？"></a>14. <code>final</code> 关键字的作用？</h2><ul><li><strong>用于类（final class）</strong>：类不可被继承（如 <code>String</code>）。</li><li><strong>用于方法（final 方法）</strong>：方法不能被子类重写（override），用于确保行为不可变。</li><li><strong>用于变量（final 字段&#x2F;局部变量）</strong>：<ul><li>对基本类型：赋值后值不可改变（常量）。</li><li>对引用类型：引用不可改变（不能指向另一个对象），但所指向对象的内部状态仍可变（除非对象本身不可变）。</li><li><code>static final</code> 常用来定义常量（编译期常量）。</li></ul></li><li><strong>用于参数</strong>（方法形参可以声明为 <code>final</code>）：代表方法内不能修改该参数引用&#x2F;值。</li><li><strong>其它用途</strong>：在多线程中，<code>final</code> 字段的写-构造过程被 JMM（Java 内存模型）处理，确保构造完成后其他线程可见（安全发布方面有好处）。</li></ul><hr><h2 id="15-static-关键字的作用？"><a href="#15-static-关键字的作用？" class="headerlink" title="15. static 关键字的作用？"></a>15. <code>static</code> 关键字的作用？</h2><ul><li>用于声明类级别成员（字段、方法、初始化块、嵌套类），不依赖实例。</li><li><strong>static 变量</strong>：类变量，所有实例共享一份。内存中仅有一份副本。</li><li><strong>static 方法</strong>：类方法，可通过 <code>ClassName.method()</code> 调用；不能直接访问非静态成员（因无 this）。</li><li><strong>static 代码块</strong>：类加载时执行一次（用于静态初始化）。</li><li><strong>static 嵌套类</strong>：可以声明为静态的内部类（静态嵌套类），没有外部实例引用。</li></ul><hr><h2 id="16-static-修饰变量、方法、代码块分别意味着什么？"><a href="#16-static-修饰变量、方法、代码块分别意味着什么？" class="headerlink" title="16. static 修饰变量、方法、代码块分别意味着什么？"></a>16. <code>static</code> 修饰变量、方法、代码块分别意味着什么？</h2><ul><li><strong>static 变量（类变量）</strong>：<ul><li>随类加载而创建，所有对象共享同一份数据。</li><li>可通过 <code>ClassName.field</code> 或 <code>instance.field</code>（不推荐）访问。</li></ul></li><li><strong>static 方法</strong>：<ul><li>属于类，调用时无需实例。</li><li>不能使用 <code>this</code>、不能直接访问非静态成员。</li><li>可作为工具方法（如 <code>Math.abs()</code>）。</li></ul></li><li><strong>static 代码块</strong>：<ul><li>在类加载阶段执行一次，用于复杂静态初始化（比如初始化静态常量、加载本地库等）。</li><li>执行顺序：静态块按定义顺序执行，类加载时运行（在实例化之前）。</li></ul></li></ul><hr><h2 id="17-static-和-final-能一起用吗？"><a href="#17-static-和-final-能一起用吗？" class="headerlink" title="17. static 和 final 能一起用吗？"></a>17. <code>static</code> 和 <code>final</code> 能一起用吗？</h2><ul><li><p><strong>能</strong>。<code>static final</code> 常用于定义类常量（尤其是基本类型和 <code>String</code>），例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static final int MAX = 100;</span><br><span class="line">public static final String NAME = &quot;abc&quot;;</span><br></pre></td></tr></table></figure></li><li><p><strong>区别</strong>：</p><ul><li>如果是编译期常量（<code>static final</code> 基本类型或 <code>String</code> 且在编译时可以确定），编译器会将其内联到使用处（被引用的类编译后看到的是常量值），注意跨模块修改可能导致需要重新编译引用方。</li><li>如果是 <code>static final</code> 引用对象且不是编译期常量，则引用本身不可变，但对象内容可能可变。</li></ul></li></ul><hr><h2 id="18-static-内部类和非静态内部类的区别？"><a href="#18-static-内部类和非静态内部类的区别？" class="headerlink" title="18. static 内部类和非静态内部类的区别？"></a>18. <code>static</code> 内部类和非静态内部类的区别？</h2><ul><li><strong>静态内部类（static nested class）</strong>：<ul><li>相当于外部类的一个静态成员。</li><li><strong>没有</strong>对外部类实例的隐式引用（不能直接访问外部类的非静态成员）。</li><li>可以像普通类那样实例化：<code>Outer.StaticInner inner = new Outer.StaticInner();</code></li></ul></li><li><strong>非静态内部类（inner class）</strong>：<ul><li>每个实例隐式持有一个外部类实例引用（<code>Outer.this</code>），可以直接访问外部类的所有成员（包括私有成员）。</li><li>创建方式：<code>Outer outer = new Outer(); Outer.Inner inner = outer.new Inner();</code></li><li>占用外部类对象的内存引用，可能导致内存泄露（如果长期持有内部类实例导致外部类不能被回收）。</li></ul></li><li><strong>选择原则</strong>：如果内部类不需要访问外部实例成员，优先使用 <code>static</code> 嵌套类，避免额外引用。</li></ul><hr><h2 id="19-Java-中的-this-和-super-的区别？"><a href="#19-Java-中的-this-和-super-的区别？" class="headerlink" title="19. Java 中的 this 和 super 的区别？"></a>19. Java 中的 <code>this</code> 和 <code>super</code> 的区别？</h2><ul><li><strong>this</strong>：<ul><li>引用当前对象的引用。</li><li>用于访问当前类的实例变量、调用当前类的其他构造器（<code>this(...)</code>）、或传递当前对象引用。</li></ul></li><li><strong>super</strong>：<ul><li>引用当前对象的父类部分。</li><li>用于访问父类被覆盖的方法（<code>super.method()</code>）、父类字段（若有同名字段）、以及在子类构造器第一行调用父类构造器（<code>super(...)</code>）。</li></ul></li><li><strong>注意</strong>：<ul><li><code>this()</code> 或 <code>super()</code> 必须在构造器的第一行（两者不能同时出现）。</li><li><code>super</code> 不能用于访问父类的 private 成员（编译期限制）。</li></ul></li></ul><hr><h2 id="20-Java-中构造方法能否被重写？"><a href="#20-Java-中构造方法能否被重写？" class="headerlink" title="20. Java 中构造方法能否被重写？"></a>20. Java 中构造方法能否被重写？</h2><ul><li><strong>不能</strong>。重写（override）适用于实例方法，构造方法不是继承的成员，子类不能重写父类的构造器。</li><li><strong>可以重载（overload）</strong>：在同一类中同名构造器有不同参数列表属于重载。</li><li>子类构造器可通过 <code>super(...)</code> 显式调用父类构造器来完成父类初始化。</li></ul><hr><h2 id="21-接口和抽象类的区别？"><a href="#21-接口和抽象类的区别？" class="headerlink" title="21. 接口和抽象类的区别？"></a>21. 接口和抽象类的区别？</h2><ul><li><strong>接口（interface）</strong>：<ul><li>早期（Java 7 之前）：只包含抽象方法（默认是 <code>public abstract</code>）和 <code>public static final</code> 常量。</li><li>Java 8+：可以包含 <code>default</code> 方法与 <code>static</code> 方法（可以有部分实现）；Java 9+ 允许 <code>private</code> 方法。</li><li>支持多继承（一个类可以实现多个接口）。</li><li>没有实例字段（除 <code>static final</code> 常量外）。</li></ul></li><li><strong>抽象类（abstract class）</strong>：<ul><li>可以有实例字段（非静态成员变量）、已有实现的方法（具体方法）、构造器。</li><li>适合表示一类有共同行为并共享状态的类层次。</li><li>类只能单继承（只能继承一个抽象类）。</li></ul></li><li><strong>选择建议</strong>：<ul><li>如果需要多继承行为、只定义方法契约且不需要状态，使用接口。</li><li>如果需要提供共有实现和状态，使用抽象类。</li></ul></li></ul><hr><h2 id="22-接口中可以有-default-方法和-static-方法吗？"><a href="#22-接口中可以有-default-方法和-static-方法吗？" class="headerlink" title="22. 接口中可以有 default 方法和 static 方法吗？"></a>22. 接口中可以有 <code>default</code> 方法和 <code>static</code> 方法吗？</h2><ul><li><strong>可以（Java 8 起）</strong>。<ul><li><code>default</code> 方法：为实现类提供默认实现，避免破坏已有实现（接口演化）。实现类可以覆盖（override）。</li><li><code>static</code> 方法：属于接口自身，可以通过 <code>InterfaceName.method()</code> 调用，不能通过实例调用。</li></ul></li><li>Java 9 及以后还可有 <code>private</code> 方法，供接口内部复用实现逻辑。</li></ul><hr><h2 id="23-Java-8-接口新增了什么？"><a href="#23-Java-8-接口新增了什么？" class="headerlink" title="23. Java 8 接口新增了什么？"></a>23. Java 8 接口新增了什么？</h2><ul><li>Java 8 在接口中新增了 <strong>default 方法</strong> 和 <strong>static 方法</strong>，允许接口提供带实现的方法，从而便于接口的演化（向后兼容）。这也是 Java 8 引入函数式编程支持的基础之一（允许接口作为函数式接口）。</li></ul><hr><h2 id="24-Java-8-有什么新特性，并详细介绍（重点）"><a href="#24-Java-8-有什么新特性，并详细介绍（重点）" class="headerlink" title="24. Java 8 有什么新特性，并详细介绍（重点）"></a>24. Java 8 有什么新特性，并详细介绍（重点）</h2><h1 id="一、Java-8-新特性深入解析"><a href="#一、Java-8-新特性深入解析" class="headerlink" title="一、Java 8 新特性深入解析"></a>一、Java 8 新特性深入解析</h1><h2 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1. Lambda 表达式"></a>1. Lambda 表达式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>匿名函数，允许把行为作为参数传递。</li><li>简化匿名内部类写法，实现函数式编程。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">Collections.sort(list, (s1, s2) -&gt; s1.length() - s2.length());</span><br></pre></td></tr></table></figure><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>编译器生成静态&#x2F;实例方法 + <code>invokedynamic</code> 指令。</li><li>JVM 调用 <code>LambdaMetafactory</code> 动态生成函数对象，实现 <strong>函数式接口</strong>。</li><li>捕获外部变量通过闭包机制存储（必须是 <code>effectively final</code>）。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>语法简洁</li><li>可作为参数传递行为</li><li>性能高于匿名内部类（减少对象创建）</li></ul><hr><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>仅有一个抽象方法的接口，用作 Lambda 表达式的目标类型。</li><li>可用 <code>@FunctionalInterface</code> 标识。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Converter&lt;String, Integer&gt; c = Integer::valueOf;</span><br><span class="line">System.out.println(c.convert(&quot;123&quot;)); // 123</span><br></pre></td></tr></table></figure><h3 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>Lambda 表达式编译时生成实现函数式接口的函数对象。</li><li>捕获变量通过闭包对象保存。</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>简化匿名类</li><li>支持函数式编程</li><li>可与 Stream &#x2F; Optional 等结合</li></ul><hr><h2 id="3-Stream-API"><a href="#3-Stream-API" class="headerlink" title="3. Stream API"></a>3. Stream API</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li>对集合进行声明式操作（过滤、映射、归约）。</li><li>支持 <strong>惰性求值</strong> 和 <strong>并行处理</strong>。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;);</span><br><span class="line">List&lt;String&gt; filtered = names.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt; 3)</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">System.out.println(filtered); // [ALICE, CHARLIE]</span><br></pre></td></tr></table></figure><h3 id="底层原理-2"><a href="#底层原理-2" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>Stream 是流水线对象，中间操作返回新的 Stream，终端操作触发计算。</li><li>串行流：顺序迭代器处理</li><li>并行流：ForkJoinPool 分块处理</li></ul><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>声明式、链式操作</li><li>支持并行</li><li>可与 Lambda &#x2F; 方法引用结合</li></ul><hr><h2 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul><li>Lambda 表达式的简化写法，引用现有方法。</li><li>类型：<ol><li>静态方法引用：<code>ClassName::staticMethod</code></li><li>实例方法引用：<code>instance::method</code></li><li>构造器引用：<code>ClassName::new</code></li></ol></li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;);</span><br><span class="line">names.forEach(System.out::println); // 实例方法引用</span><br><span class="line">Supplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::new; // 构造器引用</span><br></pre></td></tr></table></figure><h3 id="底层原理-3"><a href="#底层原理-3" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>编译器转成 Lambda 表达式 + invokedynamic。</li><li>JVM 生成实现函数式接口的函数对象，内部持有方法引用。</li></ul><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul><li>简洁直观</li><li>可减少 Lambda 代码</li><li>与 Stream &#x2F; Optional 配合使用</li></ul><hr><h2 id="5-java-time-API"><a href="#5-java-time-API" class="headerlink" title="5. java.time API"></a>5. java.time API</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><ul><li>替代 <code>Date</code> &#x2F; <code>Calendar</code>，不可变、线程安全。</li><li>核心类：<ul><li><code>LocalDate</code> &#x2F; <code>LocalTime</code> &#x2F; <code>LocalDateTime</code>（无时区）</li><li><code>ZonedDateTime</code>（带时区）</li><li><code>Duration</code> &#x2F; <code>Period</code>（时间段）</li></ul></li></ul><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plusDays(1);</span><br><span class="line">ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(&quot;Asia/Singapore&quot;));</span><br><span class="line">System.out.println(tomorrow);</span><br><span class="line">System.out.println(zdt);</span><br></pre></td></tr></table></figure><h3 id="底层原理-4"><a href="#底层原理-4" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>内部字段 <code>final</code> 保存值，不可变。</li><li>工厂方法创建对象，链式操作返回新对象。</li><li>使用 enum + 整型&#x2F;字节优化存储（如 LocalDate 年月日用 int）。</li></ul><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul><li>不可变，线程安全</li><li>链式操作，易组合</li><li>支持各种历法和时区计算</li></ul><hr><h2 id="6-Optional"><a href="#6-Optional" class="headerlink" title="6. Optional"></a>6. Optional</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><ul><li>容器对象，防止 <code>NullPointerException</code>。</li><li>可以包含值或为空（empty）。</li></ul><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt1 = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">Optional&lt;String&gt; opt2 = Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(opt1.isPresent()); <span class="comment">// true</span></span><br><span class="line">System.out.println(opt2.orElse(<span class="string">&quot;Default&quot;</span>)); <span class="comment">// Default</span></span><br><span class="line">opt1.map(String::toUpperCase).ifPresent(System.out::println); <span class="comment">// HELLO</span></span><br></pre></td></tr></table></figure><h3 id="底层原理-5"><a href="#底层原理-5" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>内部 <code>value</code> 字段存储非空值，空值使用单例 <code>EMPTY</code>。</li><li><code>map</code> &#x2F; <code>flatMap</code> &#x2F; <code>filter</code> 返回新的 Optional，对象不可变。</li><li>与 Lambda &#x2F; 函数式接口结合实现链式安全操作。</li></ul><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><ul><li>避免显式 null 判断</li><li>支持链式调用</li><li>可与 Stream &#x2F; Lambda 配合</li></ul><hr><h2 id="Java-8-六大核心特性底层对比表"><a href="#Java-8-六大核心特性底层对比表" class="headerlink" title="Java 8 六大核心特性底层对比表"></a>Java 8 六大核心特性底层对比表</h2><table><thead><tr><th>特性</th><th>底层实现</th><th>核心原理</th><th>优势</th></tr></thead><tbody><tr><td>Lambda</td><td>invokedynamic + LambdaMetafactory</td><td>动态生成函数对象</td><td>简洁、性能高</td></tr><tr><td>函数式接口</td><td>单抽象方法接口</td><td>捕获变量通过闭包存储</td><td>简化匿名类，函数式编程</td></tr><tr><td>Stream API</td><td>流水线 + 延迟求值</td><td>中间操作惰性，终端触发</td><td>声明式、可并行</td></tr><tr><td>方法引用</td><td>Lambda 简化语法 + invokedynamic</td><td>内部持有方法引用</td><td>简洁直观，减少代码</td></tr><tr><td>java.time</td><td>不可变对象 + 工厂方法</td><td>final字段保存值，链式返回新对象</td><td>线程安全，可组合</td></tr><tr><td>Optional</td><td>包装对象 + 单例 EMPTY</td><td>不可变容器，函数式链式调用</td><td>避免 NPE，安全链式操作</td></tr></tbody></table><hr><h1 id="二、synchronized-底层原理深入解析"><a href="#二、synchronized-底层原理深入解析" class="headerlink" title="二、synchronized 底层原理深入解析"></a>二、synchronized 底层原理深入解析</h1><h2 id="1-JVM-锁的类型"><a href="#1-JVM-锁的类型" class="headerlink" title="1. JVM 锁的类型"></a>1. JVM 锁的类型</h2><table><thead><tr><th>锁类型</th><th>特点</th><th>性能</th></tr></thead><tbody><tr><td>偏向锁 (Biased Lock)</td><td>无竞争时偏向第一个线程，轻量</td><td>高</td></tr><tr><td>轻量级锁 (Lightweight)</td><td>竞争少时使用 CAS 升级锁</td><td>中</td></tr><tr><td>重量级锁 (Monitor)</td><td>高竞争时使用 OS mutex，阻塞线程</td><td>低</td></tr></tbody></table><hr><h2 id="2-synchronized-对象头结构"><a href="#2-synchronized-对象头结构" class="headerlink" title="2. synchronized 对象头结构"></a>2. synchronized 对象头结构</h2><ul><li>每个对象在 JVM 内存中都有 <strong>对象头（Mark Word）</strong>，存储锁信息、哈希码、GC 标记等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象头 Mark Word (32/64bit)</span><br><span class="line">+----------------+----------------+----------------+</span><br><span class="line">| HashCode       | GC info        | Lock info      |</span><br><span class="line">+----------------+----------------+----------------+</span><br></pre></td></tr></table></figure><ul><li><strong>锁标记位</strong>：<ul><li>00：无锁</li><li>01：偏向锁</li><li>10：轻量级锁</li><li>11：重量级锁</li></ul></li></ul><hr><h2 id="3-synchronized-执行流程"><a href="#3-synchronized-执行流程" class="headerlink" title="3. synchronized 执行流程"></a>3. synchronized 执行流程</h2><h3 id="a-偏向锁（无竞争）"><a href="#a-偏向锁（无竞争）" class="headerlink" title="a) 偏向锁（无竞争）"></a>a) 偏向锁（无竞争）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程获取锁 -&gt; 在对象头打上线程ID -&gt; 执行 -&gt; 释放锁 -&gt; 保持偏向状态</span><br></pre></td></tr></table></figure><h3 id="b-轻量级锁（CAS竞争）"><a href="#b-轻量级锁（CAS竞争）" class="headerlink" title="b) 轻量级锁（CAS竞争）"></a>b) 轻量级锁（CAS竞争）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程尝试CAS抢锁 -&gt; 成功：持有锁 -&gt; 执行 -&gt; 释放</span><br><span class="line">                      |-&gt; 失败：升级为重量级锁</span><br></pre></td></tr></table></figure><h3 id="c-重量级锁（阻塞）"><a href="#c-重量级锁（阻塞）" class="headerlink" title="c) 重量级锁（阻塞）"></a>c) 重量级锁（阻塞）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程无法获取锁 -&gt; 阻塞（OS等待队列） -&gt; 被唤醒 -&gt; 获取锁 -&gt; 执行 -&gt; 释放锁</span><br></pre></td></tr></table></figure><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|  synchronized()  |</span><br><span class="line">+------------------+</span><br><span class="line">          |</span><br><span class="line">    JVM对象头Mark Word</span><br><span class="line">          |</span><br><span class="line">+------------------------+</span><br><span class="line">| 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure><hr><h2 id="4-synchronized-方法示例"><a href="#4-synchronized-方法示例" class="headerlink" title="4. synchronized 方法示例"></a>4. synchronized 方法示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>锁对象</strong>：实例方法锁住 <code>this</code>，静态方法锁住类对象 <code>ClassName.class</code>。</li><li><strong>效果</strong>：同一时间只有一个线程能进入 <code>increment()</code>，保证 <code>count++</code> 操作的原子性。</li></ul><hr><h2 id="5-JVM-优化"><a href="#5-JVM-优化" class="headerlink" title="5. JVM 优化"></a>5. JVM 优化</h2><ul><li><strong>锁消除</strong>：编译器或 JIT 可检测无竞争情况，消除同步锁。</li><li><strong>锁粗化</strong>：把多次连续的小范围锁合并，减少加锁次数。</li><li><strong>偏向锁 &#x2F; 轻量级锁 &#x2F; 重量级锁升级</strong>：动态适应竞争情况，兼顾性能与正确性。</li></ul><h2 id="25-多态的实现机制是什么？"><a href="#25-多态的实现机制是什么？" class="headerlink" title="25.多态的实现机制是什么？"></a>25.多态的实现机制是什么？</h2><ul><li><strong>概念</strong>：同一操作作用于不同对象时表现出不同的行为（主要表现为方法的动态绑定）。</li><li><strong>实现机制</strong>：<ul><li><strong>编译时</strong>：根据引用类型检查方法签名（静态类型检查）。</li><li><strong>运行时</strong>：实际调用的方法根据对象的实际类型（运行时类型）决定；即 <strong>动态绑定（dynamic dispatch）</strong>。</li><li>JVM 通常通过 <strong>虚方法表（vtable）&#x2F;方法查找机制</strong> 实现。调用一个非 <code>static</code>、非 <code>private</code>、非 <code>final</code> 的方法时，会在运行时查找实际类的实现并调用。</li></ul></li><li><strong>结果</strong>：子类可以覆盖父类方法，调用者使用父类引用指向子类对象时，调用的是子类的覆盖方法（运行时决定）。</li><li><strong>注意</strong>：<code>static</code>、<code>private</code>、<code>final</code> 方法不会被动态绑定（是静态绑定）。</li></ul><hr><h2 id="26-方法重载（overload）和方法重写（override）的区别？"><a href="#26-方法重载（overload）和方法重写（override）的区别？" class="headerlink" title="26. 方法重载（overload）和方法重写（override）的区别？"></a>26. 方法重载（overload）和方法重写（override）的区别？</h2><ul><li><p><strong>方法重载（Overloading）</strong>：</p><ul><li>同一类中方法名相同、参数列表不同（参数类型&#x2F;个数&#x2F;顺序），返回类型可以不同。</li><li>编译时决定（重载解析在编译期完成），与继承关系无关。</li></ul></li><li><p><strong>方法重写（Overriding）</strong>：</p><ul><li>子类定义与父类相同方法签名（方法名 + 参数类型相同）的实现，目的是改变&#x2F;扩展父类行为。</li><li>运行时动态绑定，必须满足访问权限不能更严格，抛出的受检异常不能超过父类版本等规则。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overload</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(String s)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// override</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;&#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; <span class="meta">@Override</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;&#125; &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="27-Java-支持多继承吗？如何实现类似效果？"><a href="#27-Java-支持多继承吗？如何实现类似效果？" class="headerlink" title="27. Java 支持多继承吗？如何实现类似效果？"></a>27. Java 支持多继承吗？如何实现类似效果？</h2><ul><li><strong>类的多继承</strong>：Java <strong>不支持类的多继承</strong>（不能继承多个类），以避免菱形继承问题（diamond problem）。</li><li><strong>实现类似效果的方法</strong>：<ul><li><strong>接口多实现</strong>：一个类可以实现多个接口（Java 8 的 <code>default</code> 方法也带来类似多继承方法实现的可能，但有冲突解决规则）。</li><li><strong>组合&#x2F;委托（composition&#x2F;delegation）</strong>：在类中持有其它类的实例并把调用委托给它们（优于继承的面向对象设计原则）。</li></ul></li><li><strong>接口冲突解决</strong>：若多个接口提供相同默认方法，类必须重写该方法并明确调用哪个接口的默认实现（<code>InterfaceName.super.method()</code>）。</li></ul><hr><h2 id="28-Java-的四种访问修饰符？"><a href="#28-Java-的四种访问修饰符？" class="headerlink" title="28. Java 的四种访问修饰符？"></a>28. Java 的四种访问修饰符？</h2><ul><li><code>public</code>：对所有类可见（任何包）。</li><li><code>protected</code>：对同包类和子类可见（即同包或子类可以访问）。</li><li><strong>默认（包私有，package-private）</strong>（不写修饰符）：对同包类可见，包外不可见。</li><li><code>private</code>：仅在本类内可见，包外&#x2F;子类不可访问（子类无法直接访问父类 private 成员）。</li><li><strong>注意</strong>：对类（顶层类）只能使用 <code>public</code> 或默认（包私有），不能声明为 <code>private</code>&#x2F;<code>protected</code>。</li></ul><hr><h2 id="29-transient-关键字的作用？"><a href="#29-transient-关键字的作用？" class="headerlink" title="29. transient 关键字的作用？"></a>29. <code>transient</code> 关键字的作用？</h2><ul><li>用于标记字段在 Java 序列化（<code>Serializable</code>）过程中<strong>不被序列化</strong>。</li><li>被标记为 <code>transient</code> 的字段在序列化后不会写入序列化流，反序列化时这些字段会以默认值恢复（基本类型 0，引用类型 <code>null</code>）。</li><li>常用于敏感信息（密码）、不需要持久化的缓存字段、或可重建的状态字段。</li><li>注意：<code>static</code> 字段本身也不会被序列化（因为是类级别，不属于实例状态）。</li></ul><hr><h2 id="30-volatile-关键字的作用？"><a href="#30-volatile-关键字的作用？" class="headerlink" title="30. volatile 关键字的作用？"></a>30. <code>volatile</code> 关键字的作用？</h2><ul><li><strong>可见性</strong>：保证对 <code>volatile</code> 变量的写入对其它线程立即可见（读取总是从主内存而不是线程缓存读取）。</li><li><strong>禁止指令重排序（部分）</strong>：读&#x2F;写 <code>volatile</code> 存在的内存屏障能保证一定的有序性（写 <code>volatile</code> 发生在后续读的可见性上，更多细节参考 JMM）。</li><li><strong>不保证原子性</strong>：对单次读&#x2F;写操作是原子的（对 <code>long</code>&#x2F;<code>double</code> 在 Java 5 后也保证原子），但非原子操作（如 <code>i++</code>）不是原子的。</li><li><strong>典型用途</strong>：<ul><li>状态标志（如 <code>volatile boolean running</code>）。</li><li>用于实现双重检查锁定（DCL）单例中的 <code>instance</code>（在 Java 5+ 环境下有效）。</li></ul></li><li><strong>与 synchronized 比较</strong>：<ul><li><code>volatile</code> 轻量，只保证可见性与部分有序性，不保证互斥；适用于简单状态通信。</li><li><code>synchronized</code> 提供互斥和可见性保证（更重），并可配合 <code>wait/notify</code>。</li></ul></li></ul><hr><h2 id="31-synchronized-的作用及底层原理？"><a href="#31-synchronized-的作用及底层原理？" class="headerlink" title="31. synchronized 的作用及底层原理？"></a>31. <code>synchronized</code> 的作用及底层原理？</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>互斥（排它）</strong>：保证同一时间只有一个线程可以执行被 <code>synchronized</code> 修饰的代码块或方法（针对同一把锁）。</li><li><strong>可见性</strong>：进入&#x2F;退出同步块会建立 happens-before 关系，确保锁释放前的写对随后获取该锁的线程可见。</li><li><strong>用途</strong>：保护临界区、确保多个线程对共享可变状态的安全访问。</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul><li><strong>方法级别</strong>：<ul><li><code>synchronized void m() &#123; ... &#125;</code>：等价于 <code>synchronized(this)</code>（实例方法）或 <code>synchronized (ClassName.class)</code>（静态方法）。</li></ul></li><li><strong>代码块级别</strong>：<ul><li><code>synchronized(this) &#123; ... &#125;</code> 或 <code>synchronized(lockObj) &#123; ... &#125;</code> 更灵活，能减小锁的粒度。</li></ul></li></ul><h3 id="底层原理（HotSpot-实现概要）"><a href="#底层原理（HotSpot-实现概要）" class="headerlink" title="底层原理（HotSpot 实现概要）"></a>底层原理（HotSpot 实现概要）</h3><ul><li>JVM 使用对象头（object header）中的 <strong>mark word</strong> 和关联数据结构维护锁状态。</li><li>锁优化策略（为提升性能，HotSpot 引入若干优化）：<ol><li><strong>偏向锁（Biased Locking）</strong>：在没有竞争的情况下，锁会偏向于第一次获得它的线程，重复获取无需 CAS，减少开销。</li><li><strong>轻量级锁（Lightweight Locking）</strong>：使用 CAS 操作在栈上记录加锁记录，避免进入重量级监视器（monitor）。</li><li><strong>重量级锁（Monitor&#x2F;Mutex）</strong>：当竞争激烈或 CAS 失败时，升级为重量级锁，使用操作系统互斥量（可能涉及线程阻塞&#x2F;唤醒）。</li></ol></li><li><code>monitorenter</code> &#x2F; <code>monitorexit</code> 是字节码指令（由编译器&#x2F;字节码生成器生成）。</li><li>JIT 编译器可进行锁消除、锁粗化、锁优化等（当能证明无并发访问或已外部同步时）。</li></ul><h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait/notify&#x2F;notifyAll"></a><code>wait/notify</code>&#x2F;<code>notifyAll</code></h3><ul><li><code>Object.wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 必须在持有对象监视器（即在 <code>synchronized</code> 块内）时调用，用于线程间协作（条件等待&#x2F;通知）。</li><li><code>wait()</code> 会释放锁并进入等待队列；<code>notify()</code> 唤醒等待队列中的一个线程（被唤醒线程在重新获得锁后继续）。</li></ul><h3 id="注意与陷阱"><a href="#注意与陷阱" class="headerlink" title="注意与陷阱"></a>注意与陷阱</h3><ul><li>锁粒度：避免用过大锁（如 <code>synchronized</code> 在方法头部锁住大量操作），谨慎使用 <code>String</code> 或装箱对象作为锁（可能会导致多个实例共用同一锁或锁被外部持有）。</li><li>死锁：多线程锁顺序不当可能死锁；设计时谨防。</li><li>性能：在高并发下可考虑使用 <code>java.util.concurrent</code> 包（<code>ReentrantLock</code>、<code>ConcurrentHashMap</code>、<code>AtomicXxx</code>）等更细粒度、高性能的并发工具。</li></ul><hr><h2 id="二、面向对象编程（OOP）"><a href="#二、面向对象编程（OOP）" class="headerlink" title="二、面向对象编程（OOP）"></a>二、面向对象编程（OOP）</h2><hr><h2 id="1-面向对象的三大特性是什么？"><a href="#1-面向对象的三大特性是什么？" class="headerlink" title="1. 面向对象的三大特性是什么？"></a><strong>1. 面向对象的三大特性是什么？</strong></h2><ul><li><strong>封装（Encapsulation）</strong>：隐藏实现细节，只暴露必要接口。</li><li><strong>继承（Inheritance）</strong>：子类复用父类属性和方法，扩展功能。</li><li><strong>多态（Polymorphism）</strong>：同一接口，不同实现。表现为方法重写、方法重载。</li></ul><hr><h2 id="2-封装的作用是什么？"><a href="#2-封装的作用是什么？" class="headerlink" title="2. 封装的作用是什么？"></a><strong>2. 封装的作用是什么？</strong></h2><ul><li>隐藏对象内部实现细节，只暴露必要接口。</li><li>提高代码复用性、安全性，避免数据被随意修改。</li><li>例如：类的成员变量用 <code>private</code>，提供 <code>getter/setter</code> 访问。</li></ul><hr><h2 id="3-多态的优点是什么？"><a href="#3-多态的优点是什么？" class="headerlink" title="3. 多态的优点是什么？"></a><strong>3. 多态的优点是什么？</strong></h2><ul><li><strong>接口统一</strong>：不同实现类可通过父类&#x2F;接口操作。</li><li><strong>可扩展性强</strong>：新增子类不影响原有代码。</li><li><strong>解耦</strong>：调用方只依赖抽象，而不依赖具体实现。</li><li>例：<code>List list = new ArrayList();</code>，后续可换成 <code>LinkedList</code>。</li></ul><hr><h2 id="4-重写方法时返回值能否不同？"><a href="#4-重写方法时返回值能否不同？" class="headerlink" title="4. 重写方法时返回值能否不同？"></a><strong>4. 重写方法时返回值能否不同？</strong></h2><ul><li><strong>不能完全不同</strong>。</li><li>Java 允许 <strong>协变返回类型</strong>：子类方法的返回值类型可以是父类方法返回值的子类。</li><li>例如：父类返回 <code>Number</code>，子类可以返回 <code>Integer</code>。</li></ul><hr><h2 id="5-构造函数能否被继承？"><a href="#5-构造函数能否被继承？" class="headerlink" title="5. 构造函数能否被继承？"></a><strong>5. 构造函数能否被继承？</strong></h2><ul><li><strong>不能继承</strong>，因为构造函数名必须与类名相同。</li><li>但子类可通过 <code>super(...)</code> 调用父类构造方法。</li></ul><hr><h2 id="6-构造函数能否-private？"><a href="#6-构造函数能否-private？" class="headerlink" title="6. 构造函数能否 private？"></a><strong>6. 构造函数能否 private？</strong></h2><ul><li><strong>可以</strong>，常见于单例模式（饿汉&#x2F;懒汉&#x2F;枚举单例）。</li><li>作用：禁止外部 <code>new</code>，只能通过类提供的方法获取实例。</li></ul><hr><h2 id="7-单例模式的几种实现方式？"><a href="#7-单例模式的几种实现方式？" class="headerlink" title="7. 单例模式的几种实现方式？"></a><strong>7. 单例模式的几种实现方式？</strong></h2><ol><li>饿汉式（类加载即实例化，线程安全，但可能浪费内存）。</li><li>懒汉式（延迟加载，需加 <code>synchronized</code> 保证线程安全）。</li><li>双重检查锁（DCL，volatile + synchronized，性能优）。</li><li>静态内部类（推荐，利用类加载机制，线程安全）。</li><li>枚举单例（最佳实践，防止反射和反序列化攻击）。</li></ol><hr><h2 id="8-饿汉式和懒汉式单例的区别？"><a href="#8-饿汉式和懒汉式单例的区别？" class="headerlink" title="8. 饿汉式和懒汉式单例的区别？"></a><strong>8. 饿汉式和懒汉式单例的区别？</strong></h2><ul><li><strong>饿汉式</strong>：类加载时实例化 → 线程安全，启动时可能浪费内存。</li><li><strong>懒汉式</strong>：第一次使用时才实例化 → 节省资源，但需加锁保证线程安全。</li></ul><hr><h2 id="9-为什么要使用内部类？"><a href="#9-为什么要使用内部类？" class="headerlink" title="9. 为什么要使用内部类？"></a><strong>9. 为什么要使用内部类？</strong></h2><ul><li>内部类可以 <strong>访问外部类的私有成员</strong>。</li><li>更好地组织代码，使逻辑更紧密。</li><li>在需要回调或事件监听时常用。</li></ul><hr><h2 id="10-成员内部类、局部内部类、静态内部类的区别？"><a href="#10-成员内部类、局部内部类、静态内部类的区别？" class="headerlink" title="10. 成员内部类、局部内部类、静态内部类的区别？"></a><strong>10. 成员内部类、局部内部类、静态内部类的区别？</strong></h2><ul><li><strong>成员内部类</strong>：依附于外部类实例，可以访问外部类实例变量。</li><li><strong>局部内部类</strong>：定义在方法内部，作用范围仅在方法内。</li><li><strong>静态内部类</strong>：不依赖外部类实例，只能访问外部类静态成员。</li></ul><hr><h2 id="11-Java-中对象的创建方式有哪些？"><a href="#11-Java-中对象的创建方式有哪些？" class="headerlink" title="11. Java 中对象的创建方式有哪些？"></a><strong>11. Java 中对象的创建方式有哪些？</strong></h2><ol><li><code>new</code> 关键字。</li><li>反射 <code>Class.newInstance()</code>。</li><li><code>Constructor.newInstance()</code>。</li><li>通过 <code>clone()</code>。</li><li>通过反序列化 <code>ObjectInputStream.readObject()</code>。</li></ol><hr><h2 id="12-对象之间的浅拷贝和深拷贝的区别？"><a href="#12-对象之间的浅拷贝和深拷贝的区别？" class="headerlink" title="12. 对象之间的浅拷贝和深拷贝的区别？"></a><strong>12. 对象之间的浅拷贝和深拷贝的区别？</strong></h2><ul><li><strong>浅拷贝</strong>：只复制对象本身，引用字段仍指向同一对象。</li><li><strong>深拷贝</strong>：连引用对象也复制一份，完全独立。</li></ul><hr><h2 id="13-clone-方法的原理？"><a href="#13-clone-方法的原理？" class="headerlink" title="13. clone() 方法的原理？"></a><strong>13. clone() 方法的原理？</strong></h2><ul><li>来自 <code>Object</code> 类，默认是 <strong>浅拷贝</strong>。</li><li>必须实现 <code>Cloneable</code> 接口，否则抛出 <code>CloneNotSupportedException</code>。</li><li>可重写 <code>clone()</code> 实现深拷贝。</li></ul><hr><h2 id="14-为什么-Java-不支持多继承？"><a href="#14-为什么-Java-不支持多继承？" class="headerlink" title="14. 为什么 Java 不支持多继承？"></a><strong>14. 为什么 Java 不支持多继承？</strong></h2><ul><li>为了避免 <strong>菱形继承问题</strong>（多个父类方法冲突）。</li><li>Java 使用 <strong>接口</strong> 来实现多继承特性。</li></ul><hr><h2 id="15-Java-是值传递还是引用传递？"><a href="#15-Java-是值传递还是引用传递？" class="headerlink" title="15. Java 是值传递还是引用传递？"></a><strong>15. Java 是值传递还是引用传递？</strong></h2><ul><li>Java <strong>只有值传递</strong>。</li><li>对象参数传递的是 <strong>引用的副本</strong>（值），但指向同一对象。</li></ul><hr><h2 id="16-方法参数传递时是如何处理对象的？"><a href="#16-方法参数传递时是如何处理对象的？" class="headerlink" title="16. 方法参数传递时是如何处理对象的？"></a><strong>16. 方法参数传递时是如何处理对象的？</strong></h2><ul><li>方法内修改对象的字段 → 会影响外部对象。</li><li>方法内给引用变量重新赋值 → 不会影响外部对象。</li></ul><hr><h2 id="17-封装性体现在哪些方面？"><a href="#17-封装性体现在哪些方面？" class="headerlink" title="17. 封装性体现在哪些方面？"></a><strong>17. 封装性体现在哪些方面？</strong></h2><ul><li>使用 <code>private</code> 修饰成员变量。</li><li>提供 <code>getter/setter</code> 控制访问权限。</li><li>使用访问修饰符（public&#x2F;protected&#x2F;default&#x2F;private）控制类和方法的可见性。</li></ul><hr><h2 id="18-为什么需要继承？"><a href="#18-为什么需要继承？" class="headerlink" title="18. 为什么需要继承？"></a><strong>18. 为什么需要继承？</strong></h2><ul><li>代码复用（减少重复）。</li><li>提高扩展性（子类扩展父类功能）。</li><li>实现多态，解耦业务逻辑。</li></ul><hr><h2 id="19-重写-Object-类的-toString-方法的意义？"><a href="#19-重写-Object-类的-toString-方法的意义？" class="headerlink" title="19. 重写 Object 类的 toString 方法的意义？"></a><strong>19. 重写 Object 类的 toString 方法的意义？</strong></h2><ul><li>提高可读性，方便调试和日志记录。</li><li>默认 <code>toString()</code> 打印类名+hashcode，不直观。</li><li>重写后可打印对象核心字段信息。</li></ul><hr><h2 id="20-重写-Object-类的-equals-方法时需要注意什么？"><a href="#20-重写-Object-类的-equals-方法时需要注意什么？" class="headerlink" title="20. 重写 Object 类的 equals 方法时需要注意什么？"></a><strong>20. 重写 Object 类的 equals 方法时需要注意什么？</strong></h2><ul><li>必须满足 <strong>自反性、对称性、传递性、一致性</strong>。</li><li>与 <code>hashCode()</code> 保持一致：相等对象必须有相同的 hashCode。</li><li>避免 <code>NullPointerException</code>。</li></ul><hr><h2 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h2><hr><h3 id="1-Java-的异常体系结构？"><a href="#1-Java-的异常体系结构？" class="headerlink" title="1. Java 的异常体系结构？"></a>1. Java 的异常体系结构？</h3><ul><li><strong>顶层类</strong>：<code>Throwable</code><ul><li><strong>Error</strong>（错误，程序无法处理，通常由 JVM 抛出）<ul><li>如：<code>OutOfMemoryError</code>、<code>StackOverflowError</code></li></ul></li><li><strong>Exception</strong>（异常，程序可处理）<ul><li><strong>Checked Exception</strong>（受检异常，编译期检查）<ul><li>如：<code>IOException</code>、<code>SQLException</code></li></ul></li><li><strong>Unchecked Exception</strong>（运行时异常，编译器不强制处理）<ul><li>如：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code></li></ul></li></ul></li></ul></li></ul><p>👉 结构图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Throwable</span><br><span class="line"> ├── Error</span><br><span class="line"> └── Exception</span><br><span class="line">      ├── Checked Exception</span><br><span class="line">      └── Unchecked Exception (RuntimeException)</span><br></pre></td></tr></table></figure><hr><h3 id="2-Checked-Exception-和-Unchecked-Exception-的区别？"><a href="#2-Checked-Exception-和-Unchecked-Exception-的区别？" class="headerlink" title="2. Checked Exception 和 Unchecked Exception 的区别？"></a>2. Checked Exception 和 Unchecked Exception 的区别？</h3><ul><li><strong>Checked Exception（受检异常）</strong><ul><li>必须显式处理（try-catch 或 throws 声明）。</li><li>编译器强制检查，否则无法通过编译。</li><li>典型场景：IO、数据库、网络调用。</li></ul></li><li><strong>Unchecked Exception（非受检异常 &#x2F; 运行时异常）</strong><ul><li>不强制处理，编译器不检查。</li><li>通常由程序逻辑错误导致。</li><li>典型场景：NPE、除零、数组越界。</li></ul></li></ul><hr><h3 id="3-throw-和-throws-的区别？"><a href="#3-throw-和-throws-的区别？" class="headerlink" title="3. throw 和 throws 的区别？"></a>3. throw 和 throws 的区别？</h3><ul><li><strong>throw</strong><ul><li>用于方法体内部，<strong>抛出具体的异常对象</strong>。</li><li>语法：<code>throw new Exception(&quot;msg&quot;);</code></li></ul></li><li><strong>throws</strong><ul><li>用于方法声明处，<strong>标识该方法可能抛出的异常类型</strong>。</li><li>语法：<code>public void test() throws IOException &#123;&#125;</code></li></ul></li></ul><p>👉 总结：</p><ul><li><code>throw</code> &#x3D; 抛出异常实例。</li><li><code>throws</code> &#x3D; 声明可能抛出的异常类型。</li></ul><hr><h3 id="4-try-catch-finally-的执行顺序？"><a href="#4-try-catch-finally-的执行顺序？" class="headerlink" title="4. try-catch-finally 的执行顺序？"></a>4. try-catch-finally 的执行顺序？</h3><ol><li><code>try</code> 块先执行。</li><li>如果发生异常，跳到对应 <code>catch</code> 执行。</li><li><code>finally</code> <strong>一定会执行</strong>（除非 <code>System.exit()</code>）。</li><li>如果 <code>try</code> 或 <code>catch</code> 有 <code>return</code>，会先执行 <code>finally</code>，再返回结果。</li></ol><hr><h3 id="5-finally-中的-return-会覆盖-try-中的-return-吗？"><a href="#5-finally-中的-return-会覆盖-try-中的-return-吗？" class="headerlink" title="5. finally 中的 return 会覆盖 try 中的 return 吗？"></a>5. finally 中的 return 会覆盖 try 中的 return 吗？</h3><p>✅ <strong>会覆盖</strong>。</p><ul><li>如果 <code>try</code> 中有 <code>return</code>，但 <code>finally</code> 中也有 <code>return</code>，最终返回的是 <code>finally</code> 的结果。<br> 👉 因此实际开发中 <strong>不推荐在 finally 中写 return</strong>。</li></ul><hr><h3 id="6-try-with-resources-的作用？"><a href="#6-try-with-resources-的作用？" class="headerlink" title="6. try-with-resources 的作用？"></a>6. try-with-resources 的作用？</h3><ul><li>Java 7 引入，简化资源管理（如流、数据库连接）。</li><li>自动关闭实现了 <code>AutoCloseable</code> 或 <code>Closeable</code> 接口的资源。</li><li>避免忘记 <code>finally &#123; resource.close(); &#125;</code>。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>))) &#123;</span><br><span class="line">    System.out.println(br.readLine());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-自定义异常类如何实现？"><a href="#7-自定义异常类如何实现？" class="headerlink" title="7. 自定义异常类如何实现？"></a>7. 自定义异常类如何实现？</h3><ul><li>继承 <code>Exception</code>（Checked）或 <code>RuntimeException</code>（Unchecked）。</li><li>提供构造方法：无参、带 message、带 cause。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-Error-和-Exception-的区别？"><a href="#8-Error-和-Exception-的区别？" class="headerlink" title="8. Error 和 Exception 的区别？"></a>8. Error 和 Exception 的区别？</h3><ul><li><strong>Error</strong>：系统级错误，JVM 无法恢复，程序不应该捕获。<ul><li>如 <code>OutOfMemoryError</code>、<code>StackOverflowError</code>。</li></ul></li><li><strong>Exception</strong>：应用级异常，程序应该处理。<ul><li>如 <code>IOException</code>、<code>SQLException</code>、<code>NullPointerException</code>。</li></ul></li></ul><hr><h3 id="9-NullPointerException-常见场景有哪些？"><a href="#9-NullPointerException-常见场景有哪些？" class="headerlink" title="9. NullPointerException 常见场景有哪些？"></a>9. NullPointerException 常见场景有哪些？</h3><ol><li>调用空对象的方法：<code>obj.toString()</code>。</li><li>访问空数组：<code>arr.length</code>。</li><li>访问空集合：<code>list.size()</code>。</li><li>自动拆箱：<code>Integer num = null; int n = num;</code>。</li><li>Map 查找为 null，再调用方法：<code>map.get(&quot;key&quot;).toString()</code>。</li><li>依赖注入&#x2F;未初始化的对象。</li></ol><hr><h3 id="10-运行时异常需要捕获吗？为什么"><a href="#10-运行时异常需要捕获吗？为什么" class="headerlink" title="10. 运行时异常需要捕获吗？为什么"></a>10. 运行时异常需要捕获吗？为什么</h3><ul><li><strong>通常不需要显式捕获</strong>，因为它们多由逻辑错误导致（如 NPE、除零）。</li><li>捕获运行时异常并不能解决问题，应该<strong>通过修改代码逻辑</strong>避免。</li><li>但在某些关键服务（如 API 层）可以用统一异常处理（如 Spring @ControllerAdvice）拦截，避免程序直接崩溃。</li></ul><hr><h2 id="四、集合框架（Collections）"><a href="#四、集合框架（Collections）" class="headerlink" title="四、集合框架（Collections）"></a>四、集合框架（Collections）</h2><hr><h3 id="1-Collection-和-Collections-的区别？"><a href="#1-Collection-和-Collections-的区别？" class="headerlink" title="1. Collection 和 Collections 的区别？"></a>1. Collection 和 Collections 的区别？</h3><ul><li><strong>Collection</strong>：集合接口，是所有集合类的父接口（List、Set）。</li><li><strong>Collections</strong>：工具类，提供操作集合的静态方法（排序、搜索、同步包装等）。</li></ul><hr><h3 id="2-List、Set、Map-的区别？"><a href="#2-List、Set、Map-的区别？" class="headerlink" title="2. List、Set、Map 的区别？"></a>2. List、Set、Map 的区别？</h3><ul><li><strong>List</strong>：有序、可重复，按索引访问（ArrayList、LinkedList）。</li><li><strong>Set</strong>：无序、不可重复，基于哈希或树（HashSet、TreeSet）。</li><li><strong>Map</strong>：键值对存储，Key 不可重复，Value 可重复（HashMap、TreeMap）。</li></ul><hr><h3 id="3-ArrayList-和-LinkedList-的区别？"><a href="#3-ArrayList-和-LinkedList-的区别？" class="headerlink" title="3. ArrayList 和 LinkedList 的区别？"></a>3. ArrayList 和 LinkedList 的区别？</h3><ul><li><strong>ArrayList</strong>：基于动态数组，查询快（O(1)），增删慢（O(n)）。</li><li><strong>LinkedList</strong>：基于双向链表，增删快（O(1)），查询慢（O(n)）。</li></ul><hr><h3 id="4-HashMap-的底层实现？"><a href="#4-HashMap-的底层实现？" class="headerlink" title="4. HashMap 的底层实现？"></a>4. HashMap 的底层实现？</h3><ul><li><strong>JDK 1.7</strong>：数组 + 链表。</li><li><strong>JDK 1.8</strong>：数组 + 链表 + 红黑树（链表长度 ≥ 8 时转为树）。</li></ul><hr><h3 id="5-HashMap-1-7-和-1-8-的区别？"><a href="#5-HashMap-1-7-和-1-8-的区别？" class="headerlink" title="5. HashMap 1.7 和 1.8 的区别？"></a>5. HashMap 1.7 和 1.8 的区别？</h3><ol><li>1.7：数组 + 链表，采用头插法，易出现并发死循环。</li><li>1.8：数组 + 链表&#x2F;红黑树，尾插法，避免死循环，提高性能。</li><li>1.8 引入红黑树，查找效率从 O(n) 优化为 O(log n)。</li></ol><hr><h3 id="6-HashMap-如何解决哈希冲突？"><a href="#6-HashMap-如何解决哈希冲突？" class="headerlink" title="6. HashMap 如何解决哈希冲突？"></a>6. HashMap 如何解决哈希冲突？</h3><ul><li>方法：拉链法（链表）+ 红黑树。</li><li>冲突时，将元素挂到链表&#x2F;树上。</li></ul><hr><h3 id="7-HashSet-的底层实现？"><a href="#7-HashSet-的底层实现？" class="headerlink" title="7. HashSet 的底层实现？"></a>7. HashSet 的底层实现？</h3><ul><li>基于 <strong>HashMap</strong> 实现。</li><li><code>HashSet</code> 的元素存储在 <code>HashMap</code> 的 key 上，value 为一个固定对象 <code>PRESENT</code>。</li></ul><hr><h3 id="8-ConcurrentHashMap-的底层实现？"><a href="#8-ConcurrentHashMap-的底层实现？" class="headerlink" title="8. ConcurrentHashMap 的底层实现？"></a>8. ConcurrentHashMap 的底层实现？</h3><ul><li><strong>JDK 1.7</strong>：分段锁（Segment + HashEntry）。</li><li><strong>JDK 1.8</strong>：CAS + synchronized，数据结构与 HashMap 类似，数组 + 链表 + 红黑树。</li></ul><hr><h3 id="9-Hashtable-和-HashMap-的区别？"><a href="#9-Hashtable-和-HashMap-的区别？" class="headerlink" title="9. Hashtable 和 HashMap 的区别？"></a>9. Hashtable 和 HashMap 的区别？</h3><ul><li><strong>线程安全性</strong>：Hashtable 是同步的，HashMap 不是。</li><li><strong>null</strong>：Hashtable 不允许 key、value 为 null；HashMap 允许一个 null key 和多个 null value。</li><li><strong>效率</strong>：HashMap 更高效。</li></ul><hr><h3 id="10-TreeMap-和-HashMap-的区别？"><a href="#10-TreeMap-和-HashMap-的区别？" class="headerlink" title="10. TreeMap 和 HashMap 的区别？"></a>10. TreeMap 和 HashMap 的区别？</h3><ul><li><strong>TreeMap</strong>：基于红黑树，有序（按 Key 排序）。</li><li><strong>HashMap</strong>：基于哈希表，无序。</li></ul><hr><h3 id="11-WeakHashMap-的特点？"><a href="#11-WeakHashMap-的特点？" class="headerlink" title="11. WeakHashMap 的特点？"></a>11. WeakHashMap 的特点？</h3><ul><li>Key 使用 <strong>弱引用</strong>，当没有强引用指向该 Key 时，会被 GC 回收。</li><li>常用于缓存。</li></ul><hr><h3 id="12-CopyOnWriteArrayList-的应用场景？"><a href="#12-CopyOnWriteArrayList-的应用场景？" class="headerlink" title="12. CopyOnWriteArrayList 的应用场景？"></a>12. CopyOnWriteArrayList 的应用场景？</h3><ul><li>写时复制：写操作时复制新数组，读操作不加锁。</li><li>适用于 <strong>读多写少</strong> 的并发场景，比如缓存、订阅列表。</li></ul><hr><h3 id="13-LinkedHashMap-的底层原理？"><a href="#13-LinkedHashMap-的底层原理？" class="headerlink" title="13. LinkedHashMap 的底层原理？"></a>13. LinkedHashMap 的底层原理？</h3><ul><li>基于 HashMap + 双向链表。</li><li>保证插入顺序（或 LRU 顺序）。</li></ul><hr><h3 id="14-Map-的-key-是否可以为-null？"><a href="#14-Map-的-key-是否可以为-null？" class="headerlink" title="14. Map 的 key 是否可以为 null？"></a>14. Map 的 key 是否可以为 null？</h3><ul><li><strong>HashMap</strong>：允许一个 null key。</li><li><strong>Hashtable &#x2F; TreeMap</strong>：不允许 null key。</li></ul><hr><h3 id="15-ArrayList-扩容机制？"><a href="#15-ArrayList-扩容机制？" class="headerlink" title="15. ArrayList 扩容机制？"></a>15. ArrayList 扩容机制？</h3><ul><li>初始容量 10，超过容量时扩容为原来的 1.5 倍。</li><li>通过 <code>Arrays.copyOf()</code> 实现数组复制。</li></ul><hr><h3 id="16-Vector-和-ArrayList-的区别？"><a href="#16-Vector-和-ArrayList-的区别？" class="headerlink" title="16. Vector 和 ArrayList 的区别？"></a>16. Vector 和 ArrayList 的区别？</h3><ul><li><strong>Vector</strong>：线程安全（方法加 synchronized），扩容为 2 倍。</li><li><strong>ArrayList</strong>：非线程安全，扩容为 1.5 倍。</li></ul><hr><h3 id="17-PriorityQueue-的底层实现？"><a href="#17-PriorityQueue-的底层实现？" class="headerlink" title="17. PriorityQueue 的底层实现？"></a>17. PriorityQueue 的底层实现？</h3><ul><li>基于 <strong>二叉小顶堆</strong>，保证队头元素是最小值。</li><li>插入、删除操作时间复杂度 O(log n)。</li></ul><hr><h3 id="18-BlockingQueue-的几种实现类？"><a href="#18-BlockingQueue-的几种实现类？" class="headerlink" title="18. BlockingQueue 的几种实现类？"></a>18. BlockingQueue 的几种实现类？</h3><ul><li><strong>ArrayBlockingQueue</strong>：数组结构，有界。</li><li><strong>LinkedBlockingQueue</strong>：链表结构，可选容量。</li><li><strong>PriorityBlockingQueue</strong>：优先级队列。</li><li><strong>DelayQueue</strong>：延时队列。</li><li><strong>SynchronousQueue</strong>：不存储元素，直接移交。</li></ul><hr><h3 id="19-HashMap-死循环问题出现在哪个版本？"><a href="#19-HashMap-死循环问题出现在哪个版本？" class="headerlink" title="19. HashMap 死循环问题出现在哪个版本？"></a>19. HashMap 死循环问题出现在哪个版本？</h3><ul><li><strong>JDK 1.7</strong> 多线程扩容时，链表采用头插法，可能形成环，导致死循环。</li><li><strong>JDK 1.8</strong> 使用尾插法，解决该问题。</li></ul><hr><h3 id="20-fail-fast-和-fail-safe-的区别？"><a href="#20-fail-fast-和-fail-safe-的区别？" class="headerlink" title="20. fail-fast 和 fail-safe 的区别？"></a>20. fail-fast 和 fail-safe 的区别？</h3><ul><li><strong>fail-fast</strong>：迭代过程中结构被修改，会抛出 <code>ConcurrentModificationException</code>。如：ArrayList、HashMap。</li><li><strong>fail-safe</strong>：迭代基于副本，不会抛异常。如：CopyOnWriteArrayList、ConcurrentHashMap。</li></ul><hr><h2 id="五、并发编程（JUC）"><a href="#五、并发编程（JUC）" class="headerlink" title="五、并发编程（JUC）"></a>五、并发编程（JUC）</h2><hr><h3 id="1-Java-中的线程生命周期？"><a href="#1-Java-中的线程生命周期？" class="headerlink" title="1. Java 中的线程生命周期？"></a>1. Java 中的线程生命周期？</h3><ul><li><strong>NEW（新建）</strong>：<code>new Thread()</code> 后，还没调用 <code>start()</code>。</li><li><strong>RUNNABLE（就绪&#x2F;运行中）</strong>：调用 <code>start()</code>，等待 CPU 调度。</li><li><strong>BLOCKED（阻塞）</strong>：等待锁。</li><li><strong>WAITING（无限等待）</strong>：调用 <code>wait()</code>、<code>join()</code>，需其他线程唤醒。</li><li><strong>TIMED_WAITING（限时等待）</strong>：调用 <code>sleep()</code>、<code>wait(timeout)</code>。</li><li><strong>TERMINATED（终止）</strong>：线程执行完毕或异常退出。</li></ul><hr><h3 id="2-Runnable-和-Callable-的区别？"><a href="#2-Runnable-和-Callable-的区别？" class="headerlink" title="2. Runnable 和 Callable 的区别？"></a>2. Runnable 和 Callable 的区别？</h3><ul><li><strong>Runnable</strong>：无返回值，不能抛出受检异常。</li><li><strong>Callable</strong>：有返回值（Future 获取），可抛出异常。</li></ul><hr><h3 id="3-ThreadPoolExecutor-的参数有哪些？"><a href="#3-ThreadPoolExecutor-的参数有哪些？" class="headerlink" title="3. ThreadPoolExecutor 的参数有哪些？"></a>3. ThreadPoolExecutor 的参数有哪些？</h3><ul><li><strong>corePoolSize</strong>：核心线程数。</li><li><strong>maximumPoolSize</strong>：最大线程数。</li><li><strong>keepAliveTime</strong>：非核心线程存活时间。</li><li><strong>unit</strong>：时间单位。</li><li><strong>workQueue</strong>：任务队列（BlockingQueue）。</li><li><strong>threadFactory</strong>：线程工厂（自定义线程名）。</li><li><strong>handler</strong>：拒绝策略。</li></ul><hr><h3 id="4-线程池的拒绝策略有哪些？"><a href="#4-线程池的拒绝策略有哪些？" class="headerlink" title="4. 线程池的拒绝策略有哪些？"></a>4. 线程池的拒绝策略有哪些？</h3><ul><li><strong>AbortPolicy</strong>（默认）：抛 <code>RejectedExecutionException</code>。</li><li><strong>CallerRunsPolicy</strong>：任务交给提交任务的线程执行。</li><li><strong>DiscardPolicy</strong>：直接丢弃任务。</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列里最旧的任务，再尝试提交。</li></ul><hr><h3 id="5-创建线程的四种方式？"><a href="#5-创建线程的四种方式？" class="headerlink" title="5. 创建线程的四种方式？"></a>5. 创建线程的四种方式？</h3><ol><li>继承 Thread 类。</li><li>实现 Runnable 接口。</li><li>实现 Callable + FutureTask。</li><li>使用线程池（ExecutorService）。</li></ol><hr><h3 id="6-synchronized-的底层实现原理？"><a href="#6-synchronized-的底层实现原理？" class="headerlink" title="6. synchronized 的底层实现原理？"></a>6. synchronized 的底层实现原理？</h3><ul><li>基于 <strong>对象头 (Mark Word)</strong> 和 <strong>Monitor（管程）</strong>。</li><li>进入同步块时，尝试获取对象的 Monitor，获取不到则阻塞。</li><li>底层依赖 <strong>JVM 指令</strong>：<code>monitorenter</code>、<code>monitorexit</code>。</li></ul><hr><h3 id="7-synchronized-和-ReentrantLock-的区别？"><a href="#7-synchronized-和-ReentrantLock-的区别？" class="headerlink" title="7. synchronized 和 ReentrantLock 的区别？"></a>7. synchronized 和 ReentrantLock 的区别？</h3><ul><li><strong>锁类型</strong>：synchronized 是 JVM 级别，ReentrantLock 是 JUC 提供的 API。</li><li><strong>功能</strong>：ReentrantLock 支持公平锁&#x2F;非公平锁、可中断、尝试加锁、条件变量。</li><li><strong>可重入性</strong>：两者都可重入。</li><li><strong>性能</strong>：synchronized 在 JDK1.6 之后优化（偏向锁、轻量级锁）性能已提升。</li></ul><hr><h3 id="8-公平锁和非公平锁的区别？"><a href="#8-公平锁和非公平锁的区别？" class="headerlink" title="8. 公平锁和非公平锁的区别？"></a>8. 公平锁和非公平锁的区别？</h3><ul><li><strong>公平锁</strong>：按照等待顺序获取锁。</li><li><strong>非公平锁</strong>：允许“插队”，减少上下文切换，提高吞吐量。</li><li>ReentrantLock 默认非公平。</li></ul><hr><h3 id="9-AQS-的原理？"><a href="#9-AQS-的原理？" class="headerlink" title="9. AQS 的原理？"></a>9. AQS 的原理？</h3><ul><li><strong>AQS（AbstractQueuedSynchronizer）</strong> 是构建锁和同步器的框架。</li><li>内部维护一个 <strong>state</strong>（表示资源数量）和 <strong>FIFO 双向队列</strong>。</li><li>通过 CAS 修改 state，失败则将线程加入等待队列，挂起阻塞，等资源释放再唤醒。</li></ul><hr><h3 id="10-CountDownLatch-的应用场景？"><a href="#10-CountDownLatch-的应用场景？" class="headerlink" title="10. CountDownLatch 的应用场景？"></a>10. CountDownLatch 的应用场景？</h3><ul><li>倒计数器：一个线程等待多个线程完成后再执行。</li><li>例子：主线程等待多个子任务执行完毕。</li></ul><hr><h3 id="11-CyclicBarrier-的应用场景？"><a href="#11-CyclicBarrier-的应用场景？" class="headerlink" title="11. CyclicBarrier 的应用场景？"></a>11. CyclicBarrier 的应用场景？</h3><ul><li>栅栏：一组线程互相等待，直到所有线程到达屏障点再继续。</li><li>例子：多人游戏，所有玩家都准备好再开始。</li></ul><hr><h3 id="12-Semaphore-的应用场景？"><a href="#12-Semaphore-的应用场景？" class="headerlink" title="12. Semaphore 的应用场景？"></a>12. Semaphore 的应用场景？</h3><ul><li>信号量：控制并发访问的线程数量。</li><li>例子：停车场限制车位数、数据库连接池。</li></ul><hr><h3 id="13-Exchanger-的应用场景？"><a href="#13-Exchanger-的应用场景？" class="headerlink" title="13. Exchanger 的应用场景？"></a>13. Exchanger 的应用场景？</h3><ul><li>线程间数据交换：两个线程配对交换数据。</li><li>例子：生产者和消费者交换缓冲区。</li></ul><hr><h3 id="14-volatile-能保证原子性吗？"><a href="#14-volatile-能保证原子性吗？" class="headerlink" title="14. volatile 能保证原子性吗？"></a>14. volatile 能保证原子性吗？</h3><ul><li><strong>不能</strong>，只能保证可见性和禁止指令重排。</li><li>例子：<code>count++</code> 在多线程下仍然不安全。</li></ul><hr><h3 id="15-CAS-的原理？"><a href="#15-CAS-的原理？" class="headerlink" title="15. CAS 的原理？"></a>15. CAS 的原理？</h3><ul><li>Compare And Swap：比较内存值是否为预期值，如果是则更新，否则重试。</li><li>底层依赖 CPU 的 <strong>cmpxchg</strong> 指令，保证原子性。</li></ul><hr><h3 id="16-ABA-问题是什么？怎么解决？"><a href="#16-ABA-问题是什么？怎么解决？" class="headerlink" title="16. ABA 问题是什么？怎么解决？"></a>16. ABA 问题是什么？怎么解决？</h3><ul><li><strong>问题</strong>：CAS 只比较值，无法感知值被改过。例如 A→B→A。</li><li><strong>解决</strong>：使用 <strong>版本号&#x2F;时间戳</strong>（AtomicStampedReference、AtomicMarkableReference）。</li></ul><hr><h3 id="17-ThreadLocal-的作用及原理？"><a href="#17-ThreadLocal-的作用及原理？" class="headerlink" title="17. ThreadLocal 的作用及原理？"></a>17. ThreadLocal 的作用及原理？</h3><ul><li><strong>作用</strong>：为每个线程提供独立变量副本，避免共享数据冲突。</li><li><strong>原理</strong>：Thread 内部有个 ThreadLocalMap，以 ThreadLocal 为 key 存储变量。</li></ul><hr><h3 id="18-ThreadLocal-内存泄漏的原因？"><a href="#18-ThreadLocal-内存泄漏的原因？" class="headerlink" title="18. ThreadLocal 内存泄漏的原因？"></a>18. ThreadLocal 内存泄漏的原因？</h3><ul><li>ThreadLocalMap 的 key 是 <strong>弱引用</strong>，可能被回收，value 却还存在，导致泄漏。</li><li>解决：用完及时 <code>remove()</code>。</li></ul><hr><h3 id="19-JUC-中的原子类有哪些？"><a href="#19-JUC-中的原子类有哪些？" class="headerlink" title="19. JUC 中的原子类有哪些？"></a>19. JUC 中的原子类有哪些？</h3><ul><li><strong>基本类型原子类</strong>：AtomicInteger、AtomicLong、AtomicBoolean。</li><li><strong>引用类型原子类</strong>：AtomicReference、AtomicStampedReference。</li><li><strong>数组原子类</strong>：AtomicIntegerArray、AtomicLongArray。</li><li><strong>对象属性更新器</strong>：AtomicIntegerFieldUpdater 等。</li></ul><hr><h3 id="20-乐观锁和悲观锁的区别？"><a href="#20-乐观锁和悲观锁的区别？" class="headerlink" title="20. 乐观锁和悲观锁的区别？"></a>20. 乐观锁和悲观锁的区别？</h3><ul><li><strong>悲观锁</strong>：假设会发生冲突，先加锁再操作（synchronized、ReentrantLock）。</li><li><strong>乐观锁</strong>：假设不会冲突，先操作再检查（CAS）。</li></ul><hr><h2 id="六、JVM-内存模型"><a href="#六、JVM-内存模型" class="headerlink" title="六、JVM &amp; 内存模型"></a>六、JVM &amp; 内存模型</h2><hr><h3 id="1-JVM-内存结构？"><a href="#1-JVM-内存结构？" class="headerlink" title="1. JVM 内存结构？"></a>1. JVM 内存结构？</h3><p>JVM 运行时主要分为：</p><ul><li><strong>堆（Heap）</strong>：存放对象实例，垃圾回收的主要区域。</li><li><strong>虚拟机栈（Stack）</strong>：存放方法调用的局部变量、操作数栈、动态链接、返回地址。</li><li><strong>本地方法栈（Native Method Stack）</strong>：为 native 方法服务。</li><li><strong>程序计数器（PC Register）</strong>：记录线程当前执行的字节码位置。</li><li><strong>方法区（Method Area &#x2F; Metaspace）</strong>：存放类元数据、常量池、静态变量、JIT 编译后的代码。</li></ul><hr><h3 id="2-堆和栈的区别？"><a href="#2-堆和栈的区别？" class="headerlink" title="2. 堆和栈的区别？"></a>2. 堆和栈的区别？</h3><ul><li><strong>堆</strong>：存放对象实例，线程共享，需垃圾回收。</li><li><strong>栈</strong>：存放方法帧、局部变量，线程私有，生命周期随线程结束。</li></ul><hr><h3 id="3-堆内存的分代模型？"><a href="#3-堆内存的分代模型？" class="headerlink" title="3. 堆内存的分代模型？"></a>3. 堆内存的分代模型？</h3><ul><li><strong>新生代（Young Generation）</strong>：Eden + Survivor（S0&#x2F;S1）。</li><li><strong>老年代（Old Generation）</strong>：存放长生命周期对象。</li><li><strong>永久代&#x2F;元空间</strong>：存放类元信息、常量池。</li></ul><hr><h3 id="4-新生代、老年代、永久代的区别？"><a href="#4-新生代、老年代、永久代的区别？" class="headerlink" title="4. 新生代、老年代、永久代的区别？"></a>4. 新生代、老年代、永久代的区别？</h3><ul><li><strong>新生代</strong>：对象新建时分配，大部分对象“朝生夕死”。</li><li><strong>老年代</strong>：存活时间长或大对象直接进入。</li><li><strong>永久代（JDK 7 及之前）</strong>：存放类信息、静态变量。</li><li><strong>元空间（JDK 8 之后）</strong>：替代永久代，使用本地内存，避免 OOM: PermGen。</li></ul><hr><h3 id="5-元空间和永久代的区别？"><a href="#5-元空间和永久代的区别？" class="headerlink" title="5. 元空间和永久代的区别？"></a>5. 元空间和永久代的区别？</h3><ul><li>永久代（PermGen）：使用 JVM 内存，容易 OOM。</li><li>元空间（Metaspace）：使用本地内存，理论上更大，更灵活。</li></ul><hr><h3 id="6-对象在堆中的分配过程？"><a href="#6-对象在堆中的分配过程？" class="headerlink" title="6. 对象在堆中的分配过程？"></a>6. 对象在堆中的分配过程？</h3><ol><li>在 Eden 区分配。</li><li>Minor GC 时，幸存的对象进入 Survivor 区。</li><li>多次 Minor GC 仍存活 → 晋升老年代。</li><li>大对象（如大数组）可能直接进入老年代。</li></ol><hr><h3 id="7-对象什么时候进入老年代？"><a href="#7-对象什么时候进入老年代？" class="headerlink" title="7. 对象什么时候进入老年代？"></a>7. 对象什么时候进入老年代？</h3><ul><li>在 Survivor 区经过多次 Minor GC，达到晋升阈值（默认 15 次）。</li><li>大对象超过阈值，直接进入老年代。</li><li>Survivor 区放不下，直接进入老年代。</li></ul><hr><h3 id="8-JVM-的垃圾回收算法？"><a href="#8-JVM-的垃圾回收算法？" class="headerlink" title="8. JVM 的垃圾回收算法？"></a>8. JVM 的垃圾回收算法？</h3><ul><li><strong>标记-清除</strong>：标记存活对象，清除未标记。缺点：碎片多。</li><li><strong>标记-整理</strong>：标记存活对象并移动，整理内存，避免碎片。</li><li><strong>复制算法</strong>：将活对象复制到新区域，清空旧区域，适合新生代。</li></ul><hr><h3 id="9-垃圾收集器有哪些？"><a href="#9-垃圾收集器有哪些？" class="headerlink" title="9. 垃圾收集器有哪些？"></a>9. 垃圾收集器有哪些？</h3><ul><li><strong>Serial</strong>（单线程，适合小内存）。</li><li><strong>ParNew</strong>（多线程版 Serial）。</li><li><strong>Parallel Scavenge（吞吐量优先）</strong>。</li><li><strong>CMS（低延迟，响应快）</strong>。</li><li><strong>G1（区域化，均衡停顿时间）</strong>。</li><li><strong>ZGC、Shenandoah（超低延迟，适合大内存场景）</strong>。</li></ul><hr><h3 id="10-CMS-和-G1-的区别？"><a href="#10-CMS-和-G1-的区别？" class="headerlink" title="10. CMS 和 G1 的区别？"></a>10. CMS 和 G1 的区别？</h3><ul><li><strong>CMS</strong>：并发收集，低延迟，但可能产生内存碎片。</li><li><strong>G1</strong>：基于分区（Region），可预测停顿时间，整理内存，适合大堆内存。</li></ul><hr><h3 id="11-Minor-GC-和-Full-GC-的区别？"><a href="#11-Minor-GC-和-Full-GC-的区别？" class="headerlink" title="11. Minor GC 和 Full GC 的区别？"></a>11. Minor GC 和 Full GC 的区别？</h3><ul><li><strong>Minor GC</strong>：回收新生代，速度快，频繁。</li><li><strong>Full GC</strong>：回收整个堆（新生代 + 老年代 + 元空间），耗时长，频率低。</li></ul><hr><h3 id="12-什么是-Stop-The-World？"><a href="#12-什么是-Stop-The-World？" class="headerlink" title="12. 什么是 Stop The World？"></a>12. 什么是 Stop The World？</h3><ul><li>GC 期间，所有工作线程必须停下来等待，造成应用暂停（STW）。</li><li>STW 是不可避免的，只能尽量减少时长。</li></ul><hr><h3 id="13-JVM-常见的调优参数？"><a href="#13-JVM-常见的调优参数？" class="headerlink" title="13. JVM 常见的调优参数？"></a>13. JVM 常见的调优参数？</h3><ul><li><code>-Xms</code> 初始堆大小。</li><li><code>-Xmx</code> 最大堆大小。</li><li><code>-Xmn</code> 新生代大小。</li><li><code>-XX:SurvivorRatio</code> Eden:Survivor 比例。</li><li><code>-XX:+PrintGCDetails</code> 打印 GC 日志。</li><li><code>-XX:+UseG1GC</code> 指定垃圾收集器。</li><li><code>-XX:MaxMetaspaceSize</code> 元空间大小。</li></ul><hr><h3 id="14-类加载的双亲委派机制？"><a href="#14-类加载的双亲委派机制？" class="headerlink" title="14. 类加载的双亲委派机制？"></a>14. 类加载的双亲委派机制？</h3><ul><li><strong>过程</strong>：加载请求先交给父加载器，如果父加载器无法加载，再由子加载器加载。</li></ul><hr><h3 id="15-双亲委派的好处？"><a href="#15-双亲委派的好处？" class="headerlink" title="15. 双亲委派的好处？"></a>15. 双亲委派的好处？</h3><ul><li>避免类重复加载。</li><li>保证核心类（如 java.lang.String）不会被篡改。</li></ul><hr><h3 id="16-类加载器的种类？"><a href="#16-类加载器的种类？" class="headerlink" title="16. 类加载器的种类？"></a>16. 类加载器的种类？</h3><ul><li><strong>Bootstrap ClassLoader</strong>：加载核心类库。</li><li><strong>Extension ClassLoader</strong>：加载扩展类。</li><li><strong>Application ClassLoader</strong>：加载用户应用类。</li><li><strong>自定义 ClassLoader</strong>：用户自己扩展。</li></ul><hr><h3 id="17-OOM-的常见类型？"><a href="#17-OOM-的常见类型？" class="headerlink" title="17. OOM 的常见类型？"></a>17. OOM 的常见类型？</h3><ul><li><strong>Java heap space</strong>：堆溢出。</li><li><strong>GC overhead limit exceeded</strong>：GC 回收无效。</li><li><strong>Metaspace</strong>：元空间溢出。</li><li><strong>Direct buffer memory</strong>：直接内存溢出。</li><li><strong>Unable to create new native thread</strong>：线程数过多。</li></ul><hr><h3 id="18-内存泄漏和内存溢出的区别？"><a href="#18-内存泄漏和内存溢出的区别？" class="headerlink" title="18. 内存泄漏和内存溢出的区别？"></a>18. 内存泄漏和内存溢出的区别？</h3><ul><li><strong>内存泄漏</strong>：不再使用的对象仍然被引用，不能被 GC 回收。</li><li><strong>内存溢出</strong>：内存不足，申请不到更多空间。</li></ul><hr><h3 id="19-finalize-方法的作用？"><a href="#19-finalize-方法的作用？" class="headerlink" title="19. finalize() 方法的作用？"></a>19. finalize() 方法的作用？</h3><ul><li>对象被 GC 前执行一次清理逻辑。</li><li>缺点：执行不确定、性能差，JDK9 开始废弃，推荐使用 <strong>try-with-resources&#x2F;AutoCloseable</strong>。</li></ul><hr><h3 id="20-Java-内存模型（JMM）的核心内容？"><a href="#20-Java-内存模型（JMM）的核心内容？" class="headerlink" title="20. Java 内存模型（JMM）的核心内容？"></a>20. Java 内存模型（JMM）的核心内容？</h3><ul><li>定义了多线程如何共享内存。</li><li>关键点：<ul><li><strong>主内存</strong>：存放共享变量。</li><li><strong>工作内存</strong>：每个线程的本地副本。</li><li><strong>happens-before 规则</strong>：保证可见性、有序性。</li><li><strong>volatile、synchronized、final</strong> 提供内存语义。</li></ul></li></ul><hr><h2 id="七、泛型、注解、反射"><a href="#七、泛型、注解、反射" class="headerlink" title="七、泛型、注解、反射"></a>七、泛型、注解、反射</h2><hr><h3 id="1-什么是泛型？"><a href="#1-什么是泛型？" class="headerlink" title="1. 什么是泛型？"></a>1. 什么是泛型？</h3><ul><li><p><strong>定义</strong>：泛型（Generic）是 <strong>参数化类型</strong>，让类、接口、方法可以操作不同类型的数据，而不用编写重复代码。</p></li><li><p><strong>好处</strong>：</p><ol><li><strong>类型安全</strong>（编译期检查，避免 <code>ClassCastException</code>）。</li><li><strong>代码复用</strong>（相同逻辑可适配多种类型）。</li><li><strong>可读性高</strong>（类型明确）。</li></ol></li><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 编译期检查类型</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-泛型的类型擦除机制？"><a href="#2-泛型的类型擦除机制？" class="headerlink" title="2. 泛型的类型擦除机制？"></a>2. 泛型的类型擦除机制？</h3><ul><li><p><strong>原理</strong>：Java 的泛型是 <strong>伪泛型</strong>，只在 <strong>编译期有效</strong>，编译后泛型信息被擦除（Type Erasure）。</p></li><li><p><strong>结果</strong>：</p><ul><li><code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在运行时是同一个类型：<code>List</code>。</li><li>泛型方法的类型参数会被擦除为 <strong>上界（extends）或 Object</strong>。</li></ul></li><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; l2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">System.out.println(l1.getClass() == l2.getClass()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-泛型通配符-extends-和-super-的区别？"><a href="#3-泛型通配符-extends-和-super-的区别？" class="headerlink" title="3. 泛型通配符 ? extends 和 ? super 的区别？"></a>3. 泛型通配符 ? extends 和 ? super 的区别？</h3><ul><li><code>? extends T</code>：表示类型的 <strong>上界</strong>，接受 <code>T</code> 及其子类。<ul><li>适合 <strong>生产者（Producer）</strong>，只读，不可写。</li></ul></li><li><code>? super T</code>：表示类型的 <strong>下界</strong>，接受 <code>T</code> 及其父类。<ul><li>适合 <strong>消费者（Consumer）</strong>，可以写入 T 及其子类对象。</li></ul></li><li><strong>口诀</strong>：PECS（Producer Extends, Consumer Super）。</li></ul><hr><h3 id="4-注解的作用是什么？"><a href="#4-注解的作用是什么？" class="headerlink" title="4. 注解的作用是什么？"></a>4. 注解的作用是什么？</h3><ul><li><strong>作用</strong>：注解（Annotation）是 <strong>元数据</strong>，为代码提供说明信息。</li><li><strong>分类</strong>：<ul><li>编译期使用（如 <code>@Override</code>, <code>@SuppressWarnings</code>）。</li><li>运行时使用（结合反射，驱动框架逻辑，如 <code>@Autowired</code>）。</li></ul></li><li><strong>应用场景</strong>：框架开发（Spring、Hibernate）、编译器检查、文档生成等。</li></ul><hr><h3 id="5-元注解有哪些？"><a href="#5-元注解有哪些？" class="headerlink" title="5. 元注解有哪些？"></a>5. 元注解有哪些？</h3><p>Java 提供了四个元注解（注解的注解）：</p><ol><li><code>@Target</code> —— 指定注解可用的位置（类、方法、字段、参数等）。</li><li><code>@Retention</code> —— 指定注解的生命周期（源码&#x2F;编译期&#x2F;运行时）。</li><li><code>@Documented</code> —— 是否包含在 javadoc 中。</li><li><code>@Inherited</code> —— 子类是否能继承父类的注解。</li></ol><hr><h3 id="6-自定义注解如何实现？"><a href="#6-自定义注解如何实现？" class="headerlink" title="6. 自定义注解如何实现？"></a>6. 自定义注解如何实现？</h3><ul><li><p><strong>定义</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>解析</strong>（反射）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">ann</span> <span class="operator">=</span> m.getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(ann.value());</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-反射的作用？"><a href="#7-反射的作用？" class="headerlink" title="7. 反射的作用？"></a>7. 反射的作用？</h3><ul><li><strong>定义</strong>：反射（Reflection）允许程序在 <strong>运行时</strong> 获取类的信息，并操作其属性、方法、构造器。</li><li><strong>作用</strong>：<ul><li>框架（如 Spring、MyBatis）自动注入和配置。</li><li>动态代理。</li><li>动态加载类。</li></ul></li></ul><hr><h3 id="8-反射的性能问题？"><a href="#8-反射的性能问题？" class="headerlink" title="8. 反射的性能问题？"></a>8. 反射的性能问题？</h3><ul><li><strong>原因</strong>：<ul><li>反射调用方法比直接调用多了安全检查、方法查找，性能差 10~20 倍。</li></ul></li><li><strong>优化</strong>：<ul><li>使用 <code>setAccessible(true)</code> 关闭安全检查。</li><li>使用 <code>MethodHandle</code>（JDK7+）。</li><li>使用 <code>LambdaMetafactory</code>（JDK8+）做动态代理。</li></ul></li></ul><hr><h3 id="9-反射能否访问私有字段？"><a href="#9-反射能否访问私有字段？" class="headerlink" title="9. 反射能否访问私有字段？"></a>9. 反射能否访问私有字段？</h3><ul><li><p><strong>能</strong>，需要 <code>setAccessible(true)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(obj, <span class="string">&quot;newValue&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：JDK 9 模块化后，跨模块访问可能会有 <code>InaccessibleObjectException</code>。</p></li></ul><hr><h3 id="10-动态代理的两种实现方式？"><a href="#10-动态代理的两种实现方式？" class="headerlink" title="10. 动态代理的两种实现方式？"></a>10. 动态代理的两种实现方式？</h3><ol><li><strong>JDK 动态代理</strong>：基于 <code>InvocationHandler + Proxy</code>，只能代理 <strong>接口</strong>。</li><li><strong>CGLIB 动态代理</strong>：基于 ASM 字节码生成，继承目标类，能代理 <strong>类</strong>。</li></ol><hr><h3 id="11-JDK-动态代理和-CGLIB-的区别？"><a href="#11-JDK-动态代理和-CGLIB-的区别？" class="headerlink" title="11. JDK 动态代理和 CGLIB 的区别？"></a>11. JDK 动态代理和 CGLIB 的区别？</h3><ul><li><strong>JDK 动态代理</strong>：<ul><li>代理接口。</li><li>JDK 自带，无需依赖。</li><li>性能略低。</li></ul></li><li><strong>CGLIB</strong>：<ul><li>代理类（生成子类）。</li><li>不能代理 <code>final</code> 类&#x2F;方法。</li><li>性能更高（字节码生成）。</li></ul></li></ul><hr><h3 id="12-反射如何创建对象？"><a href="#12-反射如何创建对象？" class="headerlink" title="12. 反射如何创建对象？"></a>12. 反射如何创建对象？</h3><ol><li><p><strong>使用 Class 的 <code>newInstance()</code></strong>（已废弃）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Constructor</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt; ctor = clazz.getConstructor(String.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ctor.newInstance(<span class="string">&quot;param&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="13-Class-forName-和-ClassLoader-loadClass-的区别？"><a href="#13-Class-forName-和-ClassLoader-loadClass-的区别？" class="headerlink" title="13. Class.forName 和 ClassLoader.loadClass 的区别？"></a>13. Class.forName 和 ClassLoader.loadClass 的区别？</h3><ul><li><strong>Class.forName</strong>：加载并 <strong>初始化</strong> 类（会执行静态代码块）。</li><li><strong>ClassLoader.loadClass</strong>：仅加载，不初始化（延迟执行 <code>&lt;clinit&gt;</code>）。</li></ul><hr><h3 id="14-注解和反射结合能实现哪些功能？"><a href="#14-注解和反射结合能实现哪些功能？" class="headerlink" title="14. 注解和反射结合能实现哪些功能？"></a>14. 注解和反射结合能实现哪些功能？</h3><ul><li>IOC &#x2F; DI（依赖注入，Spring 的 <code>@Autowired</code>）。</li><li>ORM 框架（MyBatis 的 <code>@Mapper</code>，JPA 的 <code>@Entity</code>）。</li><li>AOP（<code>@Aspect</code>）。</li><li>配置驱动开发（<code>@Configuration</code>, <code>@Value</code>）。</li></ul><hr><h3 id="15-注解处理器（APT）的作用？"><a href="#15-注解处理器（APT）的作用？" class="headerlink" title="15. 注解处理器（APT）的作用？"></a>15. 注解处理器（APT）的作用？</h3><ul><li><strong>APT（Annotation Processing Tool）</strong>：编译期扫描注解并生成代码。</li><li><strong>典型应用</strong>：<ul><li>Dagger2（依赖注入）。</li><li>ButterKnife（视图注入）。</li><li>Lombok（自动生成 getter&#x2F;setter&#x2F;toString 等）。</li></ul></li></ul><hr><h2 id="八、Java-8-新特性"><a href="#八、Java-8-新特性" class="headerlink" title="八、Java 8+ 新特性"></a>八、Java 8+ 新特性</h2><ol><li>Lambda 表达式的作用？</li><li>函数式接口有哪些？</li><li>Stream 流的常见操作？</li><li>Optional 的作用？</li><li>CompletableFuture 的作用？</li><li>Java 8 接口的默认方法和静态方法？</li><li>forEach 和传统 for 的区别？</li><li>parallelStream 的原理？</li><li>Java 9 模块化系统（Jigsaw）是什么？</li><li>Java 14 的 switch 表达式增强？</li><li>Java 16 的 record 特性？</li><li>Java 17 的 sealed class 特性？</li><li>var 关键字是什么？</li><li>ZGC 的特性？</li><li>Project Loom 的虚拟线程是什么？</li></ol><h2 id="九、IO"><a href="#九、IO" class="headerlink" title="九、IO"></a>九、IO</h2><hr><h2 id="一、Java-IO-基础与流（1–20）"><a href="#一、Java-IO-基础与流（1–20）" class="headerlink" title="一、Java IO 基础与流（1–20）"></a>一、Java IO 基础与流（1–20）</h2><hr><h3 id="1-Java-IO-的总体体系结构是什么？"><a href="#1-Java-IO-的总体体系结构是什么？" class="headerlink" title="1. Java IO 的总体体系结构是什么？"></a>1. Java IO 的总体体系结构是什么？</h3><ul><li><strong>IO 的两大基类</strong>：<ul><li>字节流：<code>InputStream</code>、<code>OutputStream</code>（处理二进制数据）。</li><li>字符流：<code>Reader</code>、<code>Writer</code>（处理文本字符）。</li></ul></li><li><strong>按功能划分</strong>：<ul><li>节点流（直接对接数据源，如 <code>FileInputStream</code>、<code>FileReader</code>）。</li><li>处理流（包装其他流，如 <code>BufferedReader</code>、<code>DataInputStream</code>）。</li></ul></li><li><strong>核心设计模式</strong>：装饰器模式（Decorator Pattern），通过层层包装增强功能。</li></ul><hr><h3 id="2-InputStream-OutputStream-的常见子类有哪些？"><a href="#2-InputStream-OutputStream-的常见子类有哪些？" class="headerlink" title="2. InputStream &#x2F; OutputStream 的常见子类有哪些？"></a>2. InputStream &#x2F; OutputStream 的常见子类有哪些？</h3><ul><li><strong>InputStream</strong>：<code>FileInputStream</code>、<code>BufferedInputStream</code>、<code>DataInputStream</code>、<code>ObjectInputStream</code>、<code>ByteArrayInputStream</code>。</li><li><strong>OutputStream</strong>：<code>FileOutputStream</code>、<code>BufferedOutputStream</code>、<code>DataOutputStream</code>、<code>ObjectOutputStream</code>、<code>ByteArrayOutputStream</code>。</li></ul><hr><h3 id="3-Reader-Writer-的常见子类有哪些？"><a href="#3-Reader-Writer-的常见子类有哪些？" class="headerlink" title="3. Reader &#x2F; Writer 的常见子类有哪些？"></a>3. Reader &#x2F; Writer 的常见子类有哪些？</h3><ul><li><strong>Reader</strong>：<code>FileReader</code>、<code>BufferedReader</code>、<code>InputStreamReader</code>、<code>CharArrayReader</code>、<code>StringReader</code>。</li><li><strong>Writer</strong>：<code>FileWriter</code>、<code>BufferedWriter</code>、<code>OutputStreamWriter</code>、<code>CharArrayWriter</code>、<code>StringWriter</code>。</li></ul><hr><h3 id="4-字节流与字符流的本质区别和使用场景？"><a href="#4-字节流与字符流的本质区别和使用场景？" class="headerlink" title="4. 字节流与字符流的本质区别和使用场景？"></a>4. 字节流与字符流的本质区别和使用场景？</h3><ul><li><strong>字节流</strong>（8bit）：面向二进制数据，如图片、音视频、压缩文件。</li><li><strong>字符流</strong>（16bit，基于 Unicode）：面向文本，自动处理字符编码。</li><li><strong>联系</strong>：字符流常常通过 <code>InputStreamReader/OutputStreamWriter</code> 包装字节流并指定编码。</li></ul><hr><h3 id="5-为什么要有缓冲流？"><a href="#5-为什么要有缓冲流？" class="headerlink" title="5. 为什么要有缓冲流？"></a>5. 为什么要有缓冲流？</h3><ul><li><strong>原因</strong>：文件 IO 属于系统调用，每次读写代价高。</li><li><strong>作用</strong>：减少磁盘交互次数，提高性能。</li><li><strong>例子</strong>：<code>BufferedReader.readLine()</code> 能按行读取，效率远高于 <code>FileReader.read()</code>。</li></ul><hr><h3 id="6-flush-与-close-的区别？"><a href="#6-flush-与-close-的区别？" class="headerlink" title="6. flush() 与 close() 的区别？"></a>6. flush() 与 close() 的区别？</h3><ul><li><strong>flush()</strong>：将内存缓冲区数据立刻写入目标（但不关闭流）。</li><li><strong>close()</strong>：先执行 <code>flush()</code>，然后释放底层资源。</li><li><strong>注意点</strong>：<ul><li>若忘记 <code>flush()</code>，可能导致部分数据未写入文件。</li><li><code>close()</code> 后再调用 <code>write()</code> 会抛异常。</li></ul></li></ul><hr><h3 id="7-try-with-resources-的工作原理？"><a href="#7-try-with-resources-的工作原理？" class="headerlink" title="7. try-with-resources 的工作原理？"></a>7. try-with-resources 的工作原理？</h3><ul><li><strong>语法糖</strong>：<code>try (Resource r = ...) &#123;&#125;</code>，要求资源实现 <code>AutoCloseable</code>。</li><li><strong>原理</strong>：编译器自动生成 <code>finally &#123; r.close() &#125;</code>。</li><li><strong>suppressed exceptions</strong>：如果 <code>try</code> 和 <code>close()</code> 都抛异常，关闭时的异常会被标记为 <strong>suppressed</strong>，可通过 <code>Throwable.getSuppressed()</code> 获取。</li></ul><hr><h3 id="8-装饰器模式在-Java-IO-中如何体现？"><a href="#8-装饰器模式在-Java-IO-中如何体现？" class="headerlink" title="8. 装饰器模式在 Java IO 中如何体现？"></a>8. 装饰器模式在 Java IO 中如何体现？</h3><ul><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>), StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure></li><li><p><strong>本质</strong>：每层流只关心自己的功能（缓冲、解码、行读取），通过链式组合增强能力。</p></li></ul><hr><h3 id="9-File-类的能力与限制？"><a href="#9-File-类的能力与限制？" class="headerlink" title="9. File 类的能力与限制？"></a>9. File 类的能力与限制？</h3><ul><li><strong>能做的</strong>：文件&#x2F;目录的元数据操作（路径、存在性、权限、大小、修改时间等）。</li><li><strong>不能做的</strong>：不支持读写文件内容，需结合 <code>InputStream/OutputStream</code>。</li></ul><hr><h3 id="10-RandomAccessFile-的用途？"><a href="#10-RandomAccessFile-的用途？" class="headerlink" title="10. RandomAccessFile 的用途？"></a>10. RandomAccessFile 的用途？</h3><ul><li><strong>功能</strong>：支持随机读写，内部有一个文件指针，可 <code>seek()</code> 到任意位置读写。</li><li><strong>典型场景</strong>：日志文件、数据库存储文件。</li><li><strong>并发问题</strong>：不是线程安全的，多线程写需加锁。</li></ul><hr><h3 id="11-FileInputStream-与-FileReader-的区别？"><a href="#11-FileInputStream-与-FileReader-的区别？" class="headerlink" title="11. FileInputStream 与 FileReader 的区别？"></a>11. FileInputStream 与 FileReader 的区别？</h3><ul><li><strong>FileInputStream</strong>：字节流，直接读二进制。</li><li><strong>FileReader</strong>：字符流，内部用 <code>InputStreamReader</code> 并默认使用平台编码。</li><li><strong>使用建议</strong>：<ul><li>非文本 → <code>FileInputStream</code>。</li><li>文本（需编码处理） → <code>FileReader</code>（但最好用 <code>InputStreamReader</code> 显式指定编码）。</li></ul></li></ul><hr><h3 id="12-常见文件拷贝方式性能对比"><a href="#12-常见文件拷贝方式性能对比" class="headerlink" title="12. 常见文件拷贝方式性能对比"></a>12. 常见文件拷贝方式性能对比</h3><ol><li><strong>裸 read&#x2F;write</strong>：逐字节拷贝，最慢。</li><li><strong>带缓冲</strong>：<code>BufferedInputStream/BufferedOutputStream</code>，性能提升 5~10 倍。</li><li><strong>NIO <code>FileChannel.transferTo()</code></strong>：利用零拷贝，性能最高。</li></ol><hr><h3 id="13-如何安全处理字符编码？"><a href="#13-如何安全处理字符编码？" class="headerlink" title="13. 如何安全处理字符编码？"></a>13. 如何安全处理字符编码？</h3><ul><li><p><strong>方式</strong>：使用 <code>InputStreamReader</code>&#x2F;<code>OutputStreamWriter</code> 并显式指定编码。</p></li><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="14-字符编码常见坑？"><a href="#14-字符编码常见坑？" class="headerlink" title="14. 字符编码常见坑？"></a>14. 字符编码常见坑？</h3><ul><li>UTF-8 vs GBK 混用：解码错误，出现乱码。</li><li>BOM（Byte Order Mark）：部分 UTF-8 文件前 3 字节 BOM 可能导致解析失败。</li><li>截断：写入时按字节截断 UTF-8 多字节字符 → 乱码。</li><li><strong>解决</strong>：统一编码（UTF-8），避免隐式编码。</li></ul><hr><h3 id="15-文件追加（append）方式？"><a href="#15-文件追加（append）方式？" class="headerlink" title="15. 文件追加（append）方式？"></a>15. 文件追加（append）方式？</h3><ul><li><p><strong>实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>原子性问题</strong>：多线程写入需加锁，否则可能交叉覆盖。</p></li></ul><hr><h3 id="16-如何判断并处理文件状态？"><a href="#16-如何判断并处理文件状态？" class="headerlink" title="16. 如何判断并处理文件状态？"></a>16. 如何判断并处理文件状态？</h3><ul><li><strong>存在性</strong>：<code>file.exists()</code>。</li><li><strong>权限</strong>：<code>file.canRead()</code>, <code>file.canWrite()</code>。</li><li><strong>占用</strong>：只能通过打开尝试，若被占用会抛异常。</li></ul><hr><h3 id="17-File-mkdirs-与-mkdir-区别？"><a href="#17-File-mkdirs-与-mkdir-区别？" class="headerlink" title="17. File.mkdirs() 与 mkdir() 区别？"></a>17. File.mkdirs() 与 mkdir() 区别？</h3><ul><li><strong>mkdir()</strong>：只创建当前目录，父目录不存在则失败。</li><li><strong>mkdirs()</strong>：会递归创建所有不存在的父目录。</li><li><strong>返回值</strong>：成功返回 <code>true</code>，否则 <code>false</code>。</li></ul><hr><h3 id="18-临时文件（createTempFile）的用途？"><a href="#18-临时文件（createTempFile）的用途？" class="headerlink" title="18. 临时文件（createTempFile）的用途？"></a>18. 临时文件（createTempFile）的用途？</h3><ul><li><strong>方法</strong>：<code>File.createTempFile(&quot;prefix&quot;, &quot;.tmp&quot;)</code>。</li><li><strong>特点</strong>：自动生成唯一文件名。</li><li><strong>删除策略</strong>：<code>file.deleteOnExit()</code> JVM 退出时删除，但依赖于正常退出。</li></ul><hr><h3 id="19-文件的读写锁与并发访问？"><a href="#19-文件的读写锁与并发访问？" class="headerlink" title="19. 文件的读写锁与并发访问？"></a>19. 文件的读写锁与并发访问？</h3><ul><li><strong>Java NIO</strong>：<code>FileChannel.lock()</code> 提供文件锁（独占锁、共享锁）。</li><li><strong>注意</strong>：文件锁是 OS 级别，跨进程生效；性能开销较大，不适合频繁操作。</li></ul><hr><h3 id="20-流关闭异常处理最佳实践"><a href="#20-流关闭异常处理最佳实践" class="headerlink" title="20. 流关闭异常处理最佳实践"></a>20. 流关闭异常处理最佳实践</h3><ul><li><strong>传统写法</strong>：try-finally 手动关闭流。</li><li><strong>推荐</strong>：try-with-resources，避免遗漏关闭。</li><li><strong>关闭异常</strong>：只 log，不影响主要业务异常处理。</li></ul><hr><h2 id="二、Java-IO-设计与模式（21–40）"><a href="#二、Java-IO-设计与模式（21–40）" class="headerlink" title="二、Java IO 设计与模式（21–40）"></a>二、Java IO 设计与模式（21–40）</h2><ol><li>InputStream&#x2F;OutputStream 的装饰器链常见组合（Buffered -&gt; GZIP -&gt; Cipher 等）。</li><li>PushbackInputStream、SequenceInputStream 的作用与应用场景。</li><li>PipedInputStream &#x2F; PipedOutputStream（管道流）的使用与线程注意点。</li><li>FilterInputStream&#x2F;FilterOutputStream 的设计与扩展。</li><li>IO 与异常处理：IOException 的常见子类与处理策略。</li><li>流复制的常见实现模板（模板方法式代码）。</li><li>NIO 引入前的 IO 局限性（可扩展性、线程模型）。</li><li>如何实现一个带超时的读操作（Socket&#x2F;Channel）？</li><li>流式处理与内存友好型处理（流式处理大文件）实践。</li><li>Base64 编解码在流中的高效集成方法。</li><li>加密&#x2F;解密流（CipherInputStream&#x2F;CipherOutputStream）如何正确关闭？</li><li>GZIPInputStream&#x2F;GZIPOutputStream 的压缩流使用注意事项。</li><li>ObjectInputStream&#x2F;ObjectOutputStream 的工作机制（类元数据、句柄表）。</li><li>如何实现跨语言的序列化兼容（JSON&#x2F;Protobuf&#x2F;Avro）？</li><li>实现自定义 InputStream 子类时需要注意什么（read 方法语义）？</li><li>设计用于日志写入的高吞吐 IO 模式（异步批量写）。</li><li>流复制时如何统计速率与进度（带进度回调）？</li><li>如何安全处理二进制文件（流边界、magic header）？</li><li>大对象&#x2F;大数组写入流时的内存优化策略（分块、流化）。</li><li>如何实现可重入&#x2F;可恢复的断点续传文件写入？</li></ol><hr><h2 id="三、文件系统、锁与操作（41–60）"><a href="#三、文件系统、锁与操作（41–60）" class="headerlink" title="三、文件系统、锁与操作（41–60）"></a>三、文件系统、锁与操作（41–60）</h2><ol><li>Java 中文件锁 FileLock 的类型（共享&#x2F;独占）及实现原理。</li><li>FileLock 的局限性（跨 JVM、跨 OS 行为差异）。</li><li>文件描述符泄露的常见原因与定位方法。</li><li>文件句柄上限（ulimit）对 Java 服务的影响与排查。</li><li>硬链接与软链接在 Java 中如何区分与操作？</li><li>MappedByteBuffer（内存映射文件）的优劣与风险（内存回收、文件锁）。</li><li>大文件分片读取与并发合并策略。</li><li>如何高效统计大日志文件中某条件的行数（分块 + 并行）？</li><li>文件系统缓存（PageCache）对读写性能的影响机制。</li><li>fsync &#x2F; FileDescriptor.sync 在持久化保障上的作用。</li><li>文件顺序写与随机写的性能差异与优化建议。</li><li>磁盘类型（SSD vs HDD）对 IO 策略的影响。</li><li>原子重命名（renameTo&#x2F;Files.move）的跨平台差异。</li><li>文件监控（WatchService）的实现限制与替代方案。</li><li>处理日志切割（rotation）时的文件句柄管理策略。</li><li>如何实现零停机部署中对文件的平滑迁移？</li><li>软删除（标记删除）与物理删除的 IO 考量。</li><li>备份&#x2F;快照策略对 IO 的影响（冷备 vs 热备）。</li><li>大文件校验（MD5&#x2F;SHA）在流式处理中的实现。</li><li>文件系统一致性问题（写入后立即读取到不同步）如何诊断。</li></ol><hr><h2 id="四、序列化与反序列化（61–75）"><a href="#四、序列化与反序列化（61–75）" class="headerlink" title="四、序列化与反序列化（61–75）"></a>四、序列化与反序列化（61–75）</h2><ol><li>Java 原生序列化（Serializable）的机制和对象写入格式。</li><li>serialVersionUID 的作用、自动生成与兼容性策略。</li><li>transient 字段、static 字段在序列化中的处理。</li><li>Externalizable 与 Serializable 的区别与使用场景。</li><li>Java 序列化的安全风险（反序列化漏洞）与防护措施。</li><li>高性能二进制序列化方案对比：Kryo、Protostuff、Protobuf、Avro。</li><li>JSON 和二进制序列化的权衡（可读性 vs 性能&#x2F;大小）。</li><li>如何实现可演化的序列化协议（向前&#x2F;向后兼容）？</li><li>对象图序列化时循环引用的处理（句柄机制）。</li><li>对象序列化性能调优要点（缓冲、对象重用）。</li><li>在分布式系统中如何管理序列化策略（跨服务版本）？</li><li>自定义序列化（writeObject&#x2F;readObject）常见陷阱。</li><li>序列化时如何处理类加载器问题？</li><li>大对象序列化时的内存与 GC 风险如何降低？</li><li>使用序列化作为缓存（Redis&#x2F;Memcached）时的注意事项。</li></ol><hr><h2 id="五、NIO-深入：Buffer-Channel-Selector（76–100）"><a href="#五、NIO-深入：Buffer-Channel-Selector（76–100）" class="headerlink" title="五、NIO 深入：Buffer &#x2F; Channel &#x2F; Selector（76–100）"></a>五、NIO 深入：Buffer &#x2F; Channel &#x2F; Selector（76–100）</h2><hr><h3 id="1-NIO-三大核心（Buffer、Channel、Selector）"><a href="#1-NIO-三大核心（Buffer、Channel、Selector）" class="headerlink" title="1. NIO 三大核心（Buffer、Channel、Selector）"></a>1. NIO 三大核心（Buffer、Channel、Selector）</h3><ul><li><strong>Buffer</strong>：数据容器，所有读写操作都要通过它完成。</li><li><strong>Channel</strong>：通道，连接数据源与 Buffer，支持双向读写。</li><li><strong>Selector</strong>：多路复用器，检测多个 Channel 的事件（读、写、连接等），实现非阻塞 IO。</li></ul><hr><h3 id="2-ByteBuffer-的-position-limit-capacity"><a href="#2-ByteBuffer-的-position-limit-capacity" class="headerlink" title="2. ByteBuffer 的 position &#x2F; limit &#x2F; capacity"></a>2. ByteBuffer 的 position &#x2F; limit &#x2F; capacity</h3><ul><li><strong>capacity</strong>：缓冲区的总容量，创建时确定。</li><li><strong>position</strong>：当前读写指针，表示下一个操作的位置。</li><li><strong>limit</strong>：可操作的边界，写模式下&#x3D;capacity，读模式下&#x3D;写入的数据量。</li></ul><hr><h3 id="3-flip-clear-rewind-compact"><a href="#3-flip-clear-rewind-compact" class="headerlink" title="3. flip(), clear(), rewind(), compact()"></a>3. flip(), clear(), rewind(), compact()</h3><ul><li><strong>flip()</strong>：切换写 → 读模式（limit&#x3D;position，position&#x3D;0）。</li><li><strong>clear()</strong>：清空缓冲，准备写（position&#x3D;0，limit&#x3D;capacity）。</li><li><strong>rewind()</strong>：重新读（position&#x3D;0，limit 不变）。</li><li><strong>compact()</strong>：未读数据前移，position 指向未读数据末尾。</li></ul><hr><h3 id="4-DirectByteBuffer-vs-HeapByteBuffer"><a href="#4-DirectByteBuffer-vs-HeapByteBuffer" class="headerlink" title="4. DirectByteBuffer vs HeapByteBuffer"></a>4. DirectByteBuffer vs HeapByteBuffer</h3><ul><li><strong>HeapByteBuffer</strong>：数据在 JVM 堆内存，GC 管理，拷贝到内核态多一份。</li><li><strong>DirectByteBuffer</strong>：数据在堆外内存，IO 时零拷贝，性能更高，但分配释放代价大。</li></ul><hr><h3 id="5-ByteBuffer-slice-asReadOnlyBuffer"><a href="#5-ByteBuffer-slice-asReadOnlyBuffer" class="headerlink" title="5. ByteBuffer slice() &#x2F; asReadOnlyBuffer()"></a>5. ByteBuffer slice() &#x2F; asReadOnlyBuffer()</h3><ul><li><strong>slice()</strong>：共享底层数据，新的缓冲区 position&#x3D;0，limit&#x3D;剩余。</li><li><strong>asReadOnlyBuffer()</strong>：生成只读视图，修改会抛 <code>ReadOnlyBufferException</code>。</li></ul><hr><h3 id="6-Scatter-Gather-IO"><a href="#6-Scatter-Gather-IO" class="headerlink" title="6. Scatter&#x2F;Gather IO"></a>6. Scatter&#x2F;Gather IO</h3><ul><li><strong>Scatter Read</strong>：一个 Channel → 多个 Buffer（适合固定头+体）。</li><li><strong>Gather Write</strong>：多个 Buffer → 一个 Channel（避免拼接）。</li></ul><hr><h3 id="7-FileChannel-的关键方法"><a href="#7-FileChannel-的关键方法" class="headerlink" title="7. FileChannel 的关键方法"></a>7. FileChannel 的关键方法</h3><ul><li><strong>position()</strong>：获取&#x2F;设置文件指针。</li><li><strong>size()</strong>：返回文件大小。</li><li><strong>truncate(long size)</strong>：截断文件。</li><li><strong>force(boolean metaData)</strong>：强制写入磁盘。</li></ul><hr><h3 id="8-MappedByteBuffer（内存映射）"><a href="#8-MappedByteBuffer（内存映射）" class="headerlink" title="8. MappedByteBuffer（内存映射）"></a>8. MappedByteBuffer（内存映射）</h3><ul><li><strong>创建</strong>：<code>FileChannel.map(mode, position, size)</code></li><li><strong>优点</strong>：直接操作内存映射，效率高。</li><li><strong>释放</strong>：JDK 无直接 API，通常通过反射 <code>Cleaner.clean()</code>，需注意内存泄露。</li></ul><hr><h3 id="9-Channel-vs-Stream"><a href="#9-Channel-vs-Stream" class="headerlink" title="9. Channel vs Stream"></a>9. Channel vs Stream</h3><ul><li><strong>Stream</strong>：单向、阻塞。</li><li><strong>Channel</strong>：双向、可非阻塞，可和 Selector 配合。</li></ul><hr><h3 id="10-Selector-工作流程"><a href="#10-Selector-工作流程" class="headerlink" title="10. Selector 工作流程"></a>10. Selector 工作流程</h3><ol><li><strong>注册</strong>：<code>channel.register(selector, ops)</code></li><li><strong>选择</strong>：<code>selector.select(timeout)</code></li><li><strong>遍历</strong>：<code>selectedKeys()</code> 遍历处理</li><li><strong>取消</strong>：调用 <code>key.cancel()</code></li></ol><hr><h3 id="11-Selector-底层实现"><a href="#11-Selector-底层实现" class="headerlink" title="11. Selector 底层实现"></a>11. Selector 底层实现</h3><ul><li><strong>Linux</strong>：epoll</li><li><strong>Windows</strong>：select</li><li><strong>macOS</strong>：kqueue<br> 影响性能和可扩展性（epoll 适合高并发）。</li></ul><hr><h3 id="12-非阻塞-Channel-的-read-write-返回值"><a href="#12-非阻塞-Channel-的-read-write-返回值" class="headerlink" title="12. 非阻塞 Channel 的 read&#x2F;write 返回值"></a>12. 非阻塞 Channel 的 read&#x2F;write 返回值</h3><ul><li><p><strong>read</strong>：</p><ul><li><blockquote><p>0：读取字节数</p></blockquote></li><li><p>0：无数据</p></li><li><p>-1：EOF（关闭）</p></li></ul></li><li><p><strong>write</strong>：</p><ul><li><blockquote><p>0：写入字节数</p></blockquote></li><li><p>0：内核缓冲区满</p></li></ul></li></ul><hr><h3 id="13-粘包-拆包问题"><a href="#13-粘包-拆包问题" class="headerlink" title="13. 粘包&#x2F;拆包问题"></a>13. 粘包&#x2F;拆包问题</h3><p>原因：TCP 流式传输无边界。<br> 解决策略：</p><ul><li>固定长度（定长协议）</li><li>分隔符（如 <code>\n</code>）</li><li>长度前置（常见）</li></ul><hr><h3 id="14-超时断开-心跳检测"><a href="#14-超时断开-心跳检测" class="headerlink" title="14. 超时断开 &amp; 心跳检测"></a>14. 超时断开 &amp; 心跳检测</h3><ul><li><strong>超时断开</strong>：在 <code>select(timeout)</code> 中检测长时间无读写的连接。</li><li><strong>心跳检测</strong>：客户端&#x2F;服务端定期发送 <code>PING</code>，无响应则断开。</li></ul><hr><h3 id="15-Pipe-在-NIO-中的作用"><a href="#15-Pipe-在-NIO-中的作用" class="headerlink" title="15. Pipe 在 NIO 中的作用"></a>15. Pipe 在 NIO 中的作用</h3><ul><li>单向通信（写端 → 读端），常用于线程间通信。</li><li>但性能不如 BlockingQueue。</li></ul><hr><h3 id="16-多-Selector-多-Reactor"><a href="#16-多-Selector-多-Reactor" class="headerlink" title="16. 多 Selector &#x2F; 多 Reactor"></a>16. 多 Selector &#x2F; 多 Reactor</h3><ul><li><strong>单 Reactor</strong>：一个线程负责 Selector。</li><li><strong>多 Reactor</strong>：主 Reactor 处理 accept，子 Reactor 处理 read&#x2F;write。</li><li><strong>多 Selector</strong>：线程池分担 Channel 负载。</li></ul><hr><h3 id="17-ByteBuffer-多线程问题"><a href="#17-ByteBuffer-多线程问题" class="headerlink" title="17. ByteBuffer 多线程问题"></a>17. ByteBuffer 多线程问题</h3><ul><li><strong>不是线程安全的</strong>。</li><li>解决：每个线程独立 Buffer，或外部加锁。</li></ul><hr><h3 id="18-DirectByteBuffer-避免泄露"><a href="#18-DirectByteBuffer-避免泄露" class="headerlink" title="18. DirectByteBuffer 避免泄露"></a>18. DirectByteBuffer 避免泄露</h3><ul><li>使用 <code>ByteBuffer.allocateDirect()</code> 代价大。</li><li>建议：使用 <code>-XX:+UseLargePages</code>、池化管理（Netty 的 <code>PooledByteBufAllocator</code>）。</li></ul><hr><h3 id="19-Selector-selectedKeys-正确用法"><a href="#19-Selector-selectedKeys-正确用法" class="headerlink" title="19. Selector selectedKeys 正确用法"></a>19. Selector selectedKeys 正确用法</h3><ul><li>遍历 <code>selectedKeys()</code></li><li>处理完一个 key → <code>iterator.remove()</code></li><li>否则下次循环仍会触发。</li></ul><hr><h3 id="20-NIO-高效读写循环模板"><a href="#20-NIO-高效读写循环模板" class="headerlink" title="20. NIO 高效读写循环模板"></a>20. NIO 高效读写循环模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    selector.select();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.read(buf);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) sc.close();</span><br><span class="line">            <span class="keyword">else</span> &#123; buf.flip(); sc.write(buf); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="21-transferTo-transferFrom（零拷贝）"><a href="#21-transferTo-transferFrom（零拷贝）" class="headerlink" title="21. transferTo&#x2F;transferFrom（零拷贝）"></a>21. transferTo&#x2F;transferFrom（零拷贝）</h3><ul><li>直接在内核空间完成文件复制（减少用户态拷贝）。</li><li>局限：Windows 一次传输大小有限，需循环。</li></ul><hr><h3 id="22-FileChannel-高效复制"><a href="#22-FileChannel-高效复制" class="headerlink" title="22. FileChannel 高效复制"></a>22. FileChannel 高效复制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src).getChannel();</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest).getChannel()) &#123;</span><br><span class="line">    in.transferTo(<span class="number">0</span>, in.size(), out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="23-高并发服务器瓶颈"><a href="#23-高并发服务器瓶颈" class="headerlink" title="23. 高并发服务器瓶颈"></a>23. 高并发服务器瓶颈</h3><ul><li>单线程 Selector 性能不足。</li><li>Buffer&#x2F;Direct 内存泄露。</li><li>大量小包（TCP 粘拆包）。</li><li>epoll 空轮询 bug（CPU 飙高）。</li></ul><hr><h3 id="24-Windows-vs-Linux"><a href="#24-Windows-vs-Linux" class="headerlink" title="24. Windows vs Linux"></a>24. Windows vs Linux</h3><ul><li><strong>Linux</strong>：epoll，可伸缩到百万连接。</li><li><strong>Windows</strong>：select，fd 数量受限，扩展性差。</li></ul><hr><h3 id="25-简单-Echo-Server-思路"><a href="#25-简单-Echo-Server-思路" class="headerlink" title="25. 简单 Echo Server 思路"></a>25. 简单 Echo Server 思路</h3><ol><li>创建 <code>Selector</code></li><li>注册 <code>ServerSocketChannel</code></li><li>循环 <code>select()</code></li><li>处理 <code>accept</code> → 注册 SocketChannel</li><li>处理 <code>read</code> → 回写数据</li></ol><hr><p>⚡总结：NIO 的核心是 <strong>缓冲区管理</strong>（ByteBuffer）、<strong>多路复用</strong>（Selector）、<strong>零拷贝优化</strong>（FileChannel.transferTo&#x2F;MappedByteBuffer）。<br> 在高并发系统里（如 Netty），这些 API 会结合线程模型和内存池进一步优化。</p><hr><h2 id="六、Socket-TCP-UDP-WebSocket（101–140）"><a href="#六、Socket-TCP-UDP-WebSocket（101–140）" class="headerlink" title="六、Socket &#x2F; TCP &#x2F; UDP &#x2F; WebSocket（101–140）"></a>六、Socket &#x2F; TCP &#x2F; UDP &#x2F; WebSocket（101–140）</h2><ol><li>Socket 的基本概念：端点、三元组&#x2F;四元组（IP:port + peer）。</li><li>Java 中 Socket、ServerSocket、DatagramSocket 的主要 API 区别。</li><li>TCP 与 UDP 的核心差异（可靠性、有序性、连接性）。</li><li>TCP 三次握手（SYN、SYN-ACK、ACK）与四次挥手流程详解。</li><li>TIME_WAIT、CLOSE_WAIT、FIN_WAIT1&#x2F;2 等 TCP 状态含义与产生原因。</li><li>半开连接（half-open）是什么，如何检测与恢复？</li><li>TCP 的流量控制（窗口）与拥塞控制（慢启动、拥塞避免、快重传、快恢复）基础。</li><li>Nagle 算法（TCP_NODELAY）的原理和在延迟场景下的影响。</li><li>TCP 延迟确认（delayed ACK）对交互型应用的影响。</li><li>Socket 选项 SO_TIMEOUT、SO_KEEPALIVE、SO_REUSEADDR、SO_REUSEPORT、SO_LINGER 含义与使用场景。</li><li>backlog 参数（ServerSocket 构造或 listen）与 accept 队列（syn, accept 队列）区别。</li><li>ephemeral port（短暂端口）与端口耗尽问题及解决办法。</li><li>SYN flood 攻击的原理和防护（SYN cookies、firewall）。</li><li>TCP 快速打开（TCP Fast Open）是什么，有何优劣？（简述）</li><li>MTU、MSS 与 IP 分片对传输的影响与诊断方法。</li><li>UDP 的组播（Multicast）与广播（Broadcast）机制与 Java 支持（MulticastSocket）。</li><li>UDP 丢包、乱序、包大小限制（最佳实践）。</li><li>UDP 穿透 NAT（STUN&#x2F;ICE）的基本原理。</li><li>如何在 Java 中实现高性能 UDP 服务器？（NIO + DatagramChannel）</li><li>WebSocket 协议基础（握手、帧格式、ping&#x2F;pong、close）。</li><li>Java 实现 WebSocket 的常见库（javax.websocket、Netty websocket、Undertow）。</li><li>TLS over TCP（HTTPS）的握手流程要点（证书验证、对称密钥协商）。</li><li>使用 SSLSocket &#x2F; SSLServerSocket 和 SSLEngine 的差别及适用场景。</li><li>SSL&#x2F;TLS 握手的重用（session resumption）与性能优化。</li><li>中间人攻击（MITM）与证书链、CA、信任根的角色。</li><li>如何在 Socket 程序中实现心跳、超时与断线重连？</li><li>TCP Keepalive 与应用层心跳的区别和协同使用。</li><li>如何通过抓包（tcpdump&#x2F;wireshark）诊断 Socket 连接问题？</li><li>Socket 的非阻塞 accept&#x2F;read&#x2F;write 实现注意点（资源&#x2F;异步安全）。</li><li>如何避免 TCP 粘包&#x2F;拆包在 Socket 原生编程中的影响（流式协议设计）？</li><li>实战：实现一个带长度前缀的 TCP 协议的 Java 服务端&#x2F;客户端（思路）。</li><li>如何优雅处理大量短连接的场景？（连接池、HTTP keep-alive）</li><li>Socket 端口复用（SO_REUSEADDR vs SO_REUSEPORT）在负载均衡中的用法。</li><li>多路复用（select&#x2F;poll&#x2F;epoll）与 socket 大连接数的处理。</li><li>网络字节序（big-endian）与数据编解码注意点。</li><li>使用 TCP_NODELAY（禁用 Nagle）时的 CPU&#x2F;网络 trade-off。</li><li>如何在 Java 中做到零拷贝文件传输（Socket + FileChannel.transferTo）？</li><li>Socket 关闭流程中遇到阻塞（SO_LINGER）的处理办法。</li><li>如何防止或检测 “socket half-closed” 的资源泄漏？</li><li>实战题：用 BIO、NIO、Netty 各实现一个简易的聊天服务器，比较性能与代码复杂度（思路要点）。</li></ol><hr><h2 id="七、异步-IO、IO-模型与高阶模式（141–150）"><a href="#七、异步-IO、IO-模型与高阶模式（141–150）" class="headerlink" title="七、异步 IO、IO 模型与高阶模式（141–150）"></a>七、异步 IO、IO 模型与高阶模式（141–150）</h2><ol><li>IO 模型分类：同步阻塞、同步非阻塞、IO 多路复用、信号驱动、异步（AIO）。</li><li>Reactor 模式与 Proactor 模式的原理与区别。</li><li>Java AIO（AsynchronousChannel、AsynchronousSocketChannel）API 介绍。</li><li>CompletionHandler 与 Future 风格的异步回调比较。</li><li>高并发下选择 NIO 还是 AIO 的实际考量（实现复杂度、平台支持）。</li><li>事件驱动系统的 back-pressure 设计（流控、速率限制）。</li><li>线程模型设计：acceptors &#x2F; io workers &#x2F; business workers 的权衡。</li><li>RCU、无锁队列在高并发 IO 框架中的应用场景。</li><li>如何在应用层实现请求队列与排队策略来缓解突发流量？</li><li>实战题：设计一个支持百万连接的服务器架构（核心组件与 IO 策略）。</li></ol><hr><h2 id="八、零拷贝、内核与性能调优（151–160）"><a href="#八、零拷贝、内核与性能调优（151–160）" class="headerlink" title="八、零拷贝、内核与性能调优（151–160）"></a>八、零拷贝、内核与性能调优（151–160）</h2><ol><li>零拷贝（zero-copy）概念和常见实现（sendfile, mmap, splice）。</li><li>FileChannel.transferTo&#x2F;transferFrom 在 Linux 下如何利用 sendfile 实现零拷贝？</li><li>mmap（内存映射文件）的实现原理与 GC &#x2F;回收问题。</li><li>DMA（Direct Memory Access）在零拷贝中的作用与限制。</li><li>内核态 &#x2F; 用户态拷贝次数与零拷贝带来的减少效果。</li><li>TCP 窗口、拥塞控制调优参数（net.ipv4.tcp_* 系列常见项）。</li><li>系统级调优：文件描述符上限（ulimit -n）、somaxconn、backlog、epoll_limits 等。</li><li>高并发网络服务的监控指标（fd 使用、accept latency、context switch、cpu steal）。</li><li>性能诊断工具与流程：iostat, vmstat, sar, perf, tcpdump, ss, strace。</li><li>实战题：如何定位并修复一个高并发服务器的 accept 阻塞 &#x2F; 连接丢失 问题（诊断步骤）。</li></ol><hr><h1 id="Java-基础面试题"><a href="#Java-基础面试题" class="headerlink" title="Java 基础面试题"></a>Java 基础面试题</h1><h3 id="一、语言特性-基础语法"><a href="#一、语言特性-基础语法" class="headerlink" title="一、语言特性 &amp; 基础语法"></a>一、语言特性 &amp; 基础语法</h3><hr><h3 id="1-Java-中的-和-equals-有什么区别？如何正确重写-equals-？"><a href="#1-Java-中的-和-equals-有什么区别？如何正确重写-equals-？" class="headerlink" title="1. Java 中的 &#x3D;&#x3D; 和 equals() 有什么区别？如何正确重写 equals()？"></a>1. Java 中的 &#x3D;&#x3D; 和 equals() 有什么区别？如何正确重写 equals()？</h3><ul><li><strong>&#x3D;&#x3D;</strong><ul><li>对于基本数据类型：比较值是否相等。</li><li>对于引用类型：比较两个引用是否指向同一块内存地址（即是否是同一个对象）。</li></ul></li><li><strong>equals()</strong><ul><li>定义在 <code>Object</code> 类中，默认实现也是 <code>==</code>。</li><li>一般会被类（如 <code>String</code>、<code>Integer</code> 等）重写，用来比较“内容”是否相同，而不是内存地址。</li></ul></li></ul><p>👉 正确重写 <code>equals()</code> 要满足 <strong>自反性、对称性、传递性、一致性</strong>，并且和 <code>null</code> 比较时返回 <code>false</code>。<br> 典型实现步骤：</p><ol><li>判断 <code>this == obj</code>，若相等直接返回 <code>true</code>。</li><li>判断 <code>obj</code> 是否为同类实例。</li><li>强制类型转换后逐个比较关键字段。</li></ol><hr><h3 id="2-为什么重写-equals-时必须重写-hashCode-？不重写会怎样？"><a href="#2-为什么重写-equals-时必须重写-hashCode-？不重写会怎样？" class="headerlink" title="2. 为什么重写 equals() 时必须重写 hashCode()？不重写会怎样？"></a>2. 为什么重写 equals() 时必须重写 hashCode()？不重写会怎样？</h3><ul><li><strong>原因</strong>：因为 <code>HashMap</code>、<code>HashSet</code> 等基于哈希表的集合使用 <code>hashCode()</code> 来决定元素存放位置，然后再用 <code>equals()</code> 判断元素是否相同。</li><li><strong>契约</strong>（JDK 文档规定）：<ul><li>如果两个对象 <code>equals()</code> 相等，那么它们的 <code>hashCode()</code> 必须相等。</li><li>反之，<code>hashCode()</code> 相等并不一定意味着 <code>equals()</code> 相等。</li></ul></li><li><strong>不重写会怎样</strong>：<ul><li>两个内容相同的对象可能 <code>equals()</code> 为 true，但 <code>hashCode()</code> 不同，导致放进 <code>HashSet</code> 时被当作两个对象存储，违背集合“不重复”的原则。</li></ul></li></ul><hr><h3 id="3-Object-类有哪些方法？哪些方法经常需要重写？"><a href="#3-Object-类有哪些方法？哪些方法经常需要重写？" class="headerlink" title="3. Object 类有哪些方法？哪些方法经常需要重写？"></a>3. Object 类有哪些方法？哪些方法经常需要重写？</h3><ul><li><strong>常用方法</strong>：<ul><li><code>equals()</code>：对象内容比较。</li><li><code>hashCode()</code>：哈希值，配合 <code>equals</code>。</li><li><code>toString()</code>：对象的字符串表示。</li><li><code>clone()</code>：对象克隆（浅拷贝，需实现 <code>Cloneable</code>）。</li><li><code>finalize()</code>：对象被 GC 前调用（已不推荐使用）。</li></ul></li><li><strong>同步方法</strong>：<ul><li><code>wait()</code> &#x2F; <code>notify()</code> &#x2F; <code>notifyAll()</code>：线程通信。</li></ul></li><li><strong>类相关方法</strong>：<ul><li><code>getClass()</code>：获取对象的运行时类型。</li></ul></li></ul><p>👉 经常需要重写的：<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>。</p><hr><h3 id="4-final、finally、finalize-有什么区别？"><a href="#4-final、finally、finalize-有什么区别？" class="headerlink" title="4. final、finally、finalize() 有什么区别？"></a>4. final、finally、finalize() 有什么区别？</h3><ul><li><strong>final</strong>：关键字<ul><li>修饰类：类不能被继承。</li><li>修饰方法：方法不能被重写。</li><li>修饰变量：变量成为常量，只能赋值一次。</li></ul></li><li><strong>finally</strong>：关键字<ul><li>用于 <code>try-catch-finally</code>，无论是否有异常，<code>finally</code> 块中的代码一定会执行（除非 <code>System.exit(0)</code>）。</li></ul></li><li><strong>finalize()</strong>：方法<ul><li><code>Object</code> 类定义，在 GC 前调用，常用于释放非托管资源。</li><li>已被标记为废弃（Java 9 开始），因为不可预测、不可靠。</li></ul></li></ul><hr><h3 id="5-Java-中的-instanceof-关键字是如何实现的？"><a href="#5-Java-中的-instanceof-关键字是如何实现的？" class="headerlink" title="5. Java 中的 instanceof 关键字是如何实现的？"></a>5. Java 中的 instanceof 关键字是如何实现的？</h3><ul><li><strong>作用</strong>：判断某个对象是否为某个类或其子类的实例。</li><li><strong>实现原理</strong>：<ul><li>JVM 在对象头中存储了对象所属的类的元数据指针。</li><li><code>instanceof</code> 实际是检查该类元数据是否是指定类或其子类。</li><li>编译器会将 <code>obj instanceof A</code> 转换为字节码 <code>instanceof</code> 指令，由 JVM 在运行时判断。</li></ul></li></ul><hr><h3 id="6-接口和抽象类的区别？接口能不能有构造函数？"><a href="#6-接口和抽象类的区别？接口能不能有构造函数？" class="headerlink" title="6. 接口和抽象类的区别？接口能不能有构造函数？"></a>6. 接口和抽象类的区别？接口能不能有构造函数？</h3><ul><li><strong>接口</strong>：<ul><li>只能定义方法（Java 8 之后可有 <code>default</code> 和 <code>static</code> 方法）。</li><li>不能有构造函数（因为接口不能直接实例化）。</li><li>可以实现 <strong>多继承</strong>（一个类可以实现多个接口）。</li></ul></li><li><strong>抽象类</strong>：<ul><li>可以有普通方法、抽象方法、成员变量。</li><li>可以有构造函数（但不能直接 new，用于子类构造时调用）。</li><li>只能单继承。</li></ul></li></ul><hr><h3 id="7-接口可以多继承吗？抽象类可以实现接口吗？"><a href="#7-接口可以多继承吗？抽象类可以实现接口吗？" class="headerlink" title="7. 接口可以多继承吗？抽象类可以实现接口吗？"></a>7. 接口可以多继承吗？抽象类可以实现接口吗？</h3><ul><li><strong>接口可以多继承</strong>：<code>interface A extends B, C &#123;&#125;</code></li><li><strong>抽象类可以实现接口</strong>：可以选择性实现接口的方法，未实现的方法仍保持 <code>abstract</code>，由子类实现。</li></ul><hr><h3 id="8-default-方法和-static-方法在接口中的意义是什么？"><a href="#8-default-方法和-static-方法在接口中的意义是什么？" class="headerlink" title="8. default 方法和 static 方法在接口中的意义是什么？"></a>8. default 方法和 static 方法在接口中的意义是什么？</h3><ul><li><strong>default 方法</strong>：<ul><li>Java 8 引入，接口中可以有默认实现的方法。</li><li>解决接口扩展的兼容性问题（给老接口新增方法不会导致所有实现类报错）。</li></ul></li><li><strong>static 方法</strong>：<ul><li>属于接口本身，而不是实现类。</li><li>用于提供工具方法或公共逻辑（类似 <code>Collections</code> 的工具类方法）。</li></ul></li></ul><hr><h3 id="9-什么是内部类？分为哪几种？"><a href="#9-什么是内部类？分为哪几种？" class="headerlink" title="9. 什么是内部类？分为哪几种？"></a>9. 什么是内部类？分为哪几种？</h3><ul><li><strong>内部类</strong>：定义在类中的类，可以访问外部类的成员。</li><li><strong>种类</strong>：<ol><li><strong>成员内部类</strong>（非静态内部类）<ul><li>依赖外部类实例，不能有 <code>static</code> 成员。</li></ul></li><li><strong>静态内部类</strong><ul><li>类似普通类，但作用域在外部类内，可以有 <code>static</code> 成员。</li></ul></li><li><strong>局部内部类</strong><ul><li>定义在方法体或代码块中，只能在该范围内使用。</li></ul></li><li><strong>匿名内部类</strong><ul><li>没有名字，通常在需要“临时实现接口或继承类”的场景使用。</li></ul></li></ol></li></ul><hr><h3 id="10-匿名内部类和-Lambda-表达式的区别？"><a href="#10-匿名内部类和-Lambda-表达式的区别？" class="headerlink" title="10. 匿名内部类和 Lambda 表达式的区别？"></a>10. 匿名内部类和 Lambda 表达式的区别？</h3><ul><li><strong>匿名内部类</strong>：<ul><li>实现接口&#x2F;继承抽象类的 <strong>具体匿名类对象</strong>。</li><li>可以有多个方法，但通常只重写需要的方法。</li><li>生成 <code>.class</code> 文件（额外开销）。</li></ul></li><li><strong>Lambda 表达式</strong>：<ul><li>仅能用于 <strong>函数式接口</strong>（只有一个抽象方法的接口）。</li><li>更简洁，本质是语法糖，编译后生成 <code>invokedynamic</code> 字节码指令，调用运行时生成的函数对象。</li><li>不会创建新的 <code>.class</code> 文件，更轻量。</li></ul></li></ul><hr><h3 id="二、数据类型-内存"><a href="#二、数据类型-内存" class="headerlink" title="二、数据类型 &amp; 内存"></a>二、数据类型 &amp; 内存</h3><hr><h3 id="1-Java-中的基本数据类型和包装类型有哪些区别？"><a href="#1-Java-中的基本数据类型和包装类型有哪些区别？" class="headerlink" title="1. Java 中的基本数据类型和包装类型有哪些区别？"></a>1. Java 中的基本数据类型和包装类型有哪些区别？</h3><ul><li><strong>基本数据类型</strong>（primitive）：<code>byte, short, int, long, float, double, char, boolean</code><ul><li>存储在栈上（或寄存器），效率高，空间占用固定。</li><li>不能为 <code>null</code>，默认值固定（如 <code>int</code> 默认 <code>0</code>，<code>boolean</code> 默认 <code>false</code>）。</li></ul></li><li><strong>包装类型</strong>（wrapper）：<code>Byte, Short, Integer, Long, Float, Double, Character, Boolean</code><ul><li>是对象，存储在堆中。</li><li>可以为 <code>null</code>，有丰富的 API。</li><li>可以参与集合类（如 <code>ArrayList</code> 只能存对象）。</li></ul></li><li><strong>自动装箱&#x2F;拆箱</strong>：Java 会在基本类型和包装类之间自动转换。</li></ul><hr><h3 id="2-为什么-Integer-有缓存机制？范围是多少？"><a href="#2-为什么-Integer-有缓存机制？范围是多少？" class="headerlink" title="2. 为什么 Integer 有缓存机制？范围是多少？"></a>2. 为什么 Integer 有缓存机制？范围是多少？</h3><ul><li><strong>原因</strong>：<ul><li>为了避免频繁创建对象，提高性能。</li><li>小整数使用频率高（如循环、下标），所以缓存常用的整数。</li></ul></li><li><strong>范围</strong>：<code>-128 ~ 127</code>。</li><li><strong>实现</strong>：<ul><li><code>IntegerCache</code> 静态内部类在类加载时初始化缓存数组。</li><li><code>Integer.valueOf(int i)</code> 方法会先查缓存，再决定是否 new 对象。</li></ul></li></ul><hr><h3 id="3-为什么-new-Integer-127-new-Integer-127-为-false，而-Integer-valueOf-127-Integer-valueOf-127-为-true？"><a href="#3-为什么-new-Integer-127-new-Integer-127-为-false，而-Integer-valueOf-127-Integer-valueOf-127-为-true？" class="headerlink" title="3. 为什么 new Integer(127) == new Integer(127) 为 false，而 Integer.valueOf(127) == Integer.valueOf(127) 为 true？"></a>3. 为什么 <code>new Integer(127) == new Integer(127)</code> 为 false，而 <code>Integer.valueOf(127) == Integer.valueOf(127)</code> 为 true？</h3><ul><li><code>new Integer(127)</code>：每次都会创建新对象，内存地址不同，所以 <code>==</code> 为 false。</li><li><code>Integer.valueOf(127)</code>：会查缓存，<code>127</code> 在 <code>-128~127</code> 范围内，返回同一个对象引用，所以 <code>==</code> 为 true。</li></ul><p>👉 <strong>总结</strong>：</p><ul><li><code>==</code> 比较的是引用地址。</li><li><code>equals()</code> 才是比较数值。</li></ul><hr><h3 id="4-NaN-和-Infinity-在-Java-中如何表示？"><a href="#4-NaN-和-Infinity-在-Java-中如何表示？" class="headerlink" title="4. NaN 和 Infinity 在 Java 中如何表示？"></a>4. NaN 和 Infinity 在 Java 中如何表示？</h3><ul><li><strong>NaN（Not a Number）</strong>：<ul><li>如 <code>0.0 / 0.0</code> 或 <code>Math.sqrt(-1)</code>。</li><li>特点：<code>NaN != NaN</code>，要用 <code>Double.isNaN()</code> 检测。</li></ul></li><li><strong>Infinity（正&#x2F;负无穷大）</strong>：<ul><li>如 <code>1.0 / 0.0 = Infinity</code>，<code>-1.0 / 0.0 = -Infinity</code>。</li><li>用 <code>Double.isInfinite()</code> 检测。</li></ul></li></ul><hr><h3 id="5-为什么浮点数计算有精度问题？如何避免？"><a href="#5-为什么浮点数计算有精度问题？如何避免？" class="headerlink" title="5. 为什么浮点数计算有精度问题？如何避免？"></a>5. 为什么浮点数计算有精度问题？如何避免？</h3><ul><li><strong>原因</strong>：<ul><li>浮点数采用 <strong>IEEE 754 二进制浮点表示</strong>，大多数十进制小数（如 <code>0.1</code>）不能精确表示，只能存储近似值。</li><li>计算时会累积误差。</li></ul></li><li><strong>避免方法</strong>：<ul><li>使用 <code>BigDecimal</code>（推荐）。</li><li>或使用整数替代（如金额用分而不是元）。</li></ul></li></ul><hr><h3 id="6-BigDecimal-为什么能解决浮点数精度问题？"><a href="#6-BigDecimal-为什么能解决浮点数精度问题？" class="headerlink" title="6. BigDecimal 为什么能解决浮点数精度问题？"></a>6. BigDecimal 为什么能解决浮点数精度问题？</h3><ul><li><strong>原理</strong>：<ul><li>内部使用 <strong>BigInteger + 精度标识 scale</strong> 表示任意精度的十进制数。</li><li>不依赖二进制浮点存储，而是基于字符串或整数进行精确计算。</li></ul></li><li><strong>注意</strong>：<ul><li>不能用 <code>new BigDecimal(double)</code>（会带入二进制误差）。</li><li>推荐 <code>BigDecimal.valueOf(double)</code> 或 <code>new BigDecimal(String)</code>。</li></ul></li></ul><hr><h3 id="7-Java-中的字符集默认是什么？在不同平台上会不一样吗？"><a href="#7-Java-中的字符集默认是什么？在不同平台上会不一样吗？" class="headerlink" title="7. Java 中的字符集默认是什么？在不同平台上会不一样吗？"></a>7. Java 中的字符集默认是什么？在不同平台上会不一样吗？</h3><ul><li>Java 内部使用 <strong>UTF-16（Unicode）</strong> 存储 <code>char</code> 和 <code>String</code>。</li><li>默认字符集（<code>Charset.defaultCharset()</code>）会随平台不同而不同：<ul><li>Windows（中文环境）：<code>GBK</code> 或 <code>GB2312</code>。</li><li>Linux &#x2F; macOS：通常是 <code>UTF-8</code>。<br> 👉 这会影响文件读写、网络传输等。</li></ul></li></ul><hr><h3 id="8-String、StringBuilder、StringBuffer-区别？线程安全性？"><a href="#8-String、StringBuilder、StringBuffer-区别？线程安全性？" class="headerlink" title="8. String、StringBuilder、StringBuffer 区别？线程安全性？"></a>8. String、StringBuilder、StringBuffer 区别？线程安全性？</h3><ul><li><strong>String</strong><ul><li>不可变类（底层 <code>final char[]</code>），每次拼接都会生成新对象。</li></ul></li><li><strong>StringBuilder</strong><ul><li>可变字符序列（底层 <code>char[]</code>），高效，<strong>非线程安全</strong>。</li></ul></li><li><strong>StringBuffer</strong><ul><li>可变字符序列，方法加了 <code>synchronized</code>，<strong>线程安全</strong>，效率比 <code>StringBuilder</code> 低。</li></ul></li></ul><p>👉 单线程推荐 <code>StringBuilder</code>，多线程推荐 <code>StringBuffer</code>。</p><hr><h3 id="9-为什么-String-是不可变的？背后实现细节？"><a href="#9-为什么-String-是不可变的？背后实现细节？" class="headerlink" title="9. 为什么 String 是不可变的？背后实现细节？"></a>9. 为什么 String 是不可变的？背后实现细节？</h3><ul><li><strong>原因</strong>：<ol><li><strong>安全性</strong>：如网络请求 URL、文件路径、ClassLoader 名称等，一旦创建不可修改，避免被篡改。</li><li><strong>线程安全</strong>：不可变对象天然线程安全。</li><li><strong>哈希值缓存</strong>：<code>String</code> 缓存了 <code>hashCode</code>，不可变保证哈希值不会变化。</li><li><strong>字符串常量池优化</strong>：不可变对象可被复用。</li></ol></li><li><strong>实现</strong>：<ul><li><code>private final char[] value</code>（JDK 9 以后改成 <code>byte[]</code> + <code>coder</code>，节省内存）。</li></ul></li></ul><hr><h3 id="10-intern-方法的作用是什么？"><a href="#10-intern-方法的作用是什么？" class="headerlink" title="10. intern() 方法的作用是什么？"></a>10. intern() 方法的作用是什么？</h3><ul><li><p><strong>作用</strong>：</p><ul><li>将字符串放入 <strong>字符串常量池</strong>，返回池中的引用。</li><li>若池中已有等值字符串，则返回已有对象引用。</li></ul></li><li><p><strong>意义</strong>：</p><ul><li>减少内存占用，提高比较效率（常量池中的 <code>String</code> 可以直接用 <code>==</code> 比较）。</li></ul></li><li><p><strong>例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s2 == s3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="三、集合框架"><a href="#三、集合框架" class="headerlink" title="三、集合框架"></a>三、集合框架</h3><hr><h2 id="1-ArrayList-和-Vector-的区别"><a href="#1-ArrayList-和-Vector-的区别" class="headerlink" title="1. ArrayList 和 Vector 的区别"></a><strong>1. ArrayList 和 Vector 的区别</strong></h2><table><thead><tr><th>特性</th><th>ArrayList</th><th>Vector</th></tr></thead><tbody><tr><td>线程安全</td><td>非线程安全</td><td>线程安全（方法加 synchronized）</td></tr><tr><td>扩容机制</td><td>默认 1.5 倍</td><td>默认 2 倍</td></tr><tr><td>性能</td><td>高（无锁）</td><td>低（同步开销）</td></tr><tr><td>用途</td><td>多线程外部不安全</td><td>适合多线程共享场景，但现在较少使用</td></tr><tr><td>面试拓展</td><td>如何在多线程下安全使用 ArrayList？可用 <code>Collections.synchronizedList()</code> 或 <code>CopyOnWriteArrayList</code></td><td></td></tr></tbody></table><p><strong>原理</strong>：</p><ul><li>都基于动态数组实现</li><li>添加元素时如果容量不够，会创建一个新的数组并复制原数组内容</li></ul><hr><h2 id="2-为什么-ArrayList-的扩容是-1-5-倍？"><a href="#2-为什么-ArrayList-的扩容是-1-5-倍？" class="headerlink" title="2. 为什么 ArrayList 的扩容是 1.5 倍？"></a><strong>2. 为什么 ArrayList 的扩容是 1.5 倍？</strong></h2><ul><li><p><strong>目的</strong>：平衡 <strong>内存消耗</strong> 和 <strong>扩容频率</strong></p></li><li><p><strong>原理</strong>：</p><ul><li>过小扩容：频繁创建新数组，复制开销大</li><li>过大扩容：浪费内存</li></ul></li><li><p>JDK 1.8 的扩容公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 相当于 1.5 倍</span></span><br></pre></td></tr></table></figure></li><li><p>面试点：</p><ul><li>LinkedList 不需要扩容，因为链表动态增长</li><li>如何自定义扩容策略？</li></ul></li></ul><hr><h2 id="3-LinkedList-是双向链表还是单向链表？"><a href="#3-LinkedList-是双向链表还是单向链表？" class="headerlink" title="3. LinkedList 是双向链表还是单向链表？"></a><strong>3. LinkedList 是双向链表还是单向链表？</strong></h2><ul><li><p><strong>Java 中 LinkedList 是双向链表</strong></p></li><li><p><strong>结构</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>优点</strong>：</p><ul><li>支持快速插入&#x2F;删除（O(1)）</li><li>支持从头尾遍历</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>随机访问慢（O(n)）</li><li>内存占用大（需要 prev 指针）</li></ul></li></ul><hr><h2 id="4-HashSet-底层实现"><a href="#4-HashSet-底层实现" class="headerlink" title="4. HashSet 底层实现"></a><strong>4. HashSet 底层实现</strong></h2><ul><li><strong>底层使用 HashMap 实现</strong></li><li><strong>原理</strong>：<ul><li>每个元素作为 <code>HashMap</code> 的 key</li><li>value 使用一个固定的 Object 对象 <code>PRESENT</code></li></ul></li><li><strong>特点</strong>：<ul><li>不允许重复</li><li>无序存储</li></ul></li><li><strong>性能</strong>：<ul><li>插入、删除、查找均 O(1) 平均</li></ul></li><li>面试拓展：HashSet 和 LinkedHashSet 的区别？<ul><li>LinkedHashSet 维护了插入顺序</li></ul></li></ul><hr><h2 id="5-TreeSet-和-TreeMap-的底层实现"><a href="#5-TreeSet-和-TreeMap-的底层实现" class="headerlink" title="5. TreeSet 和 TreeMap 的底层实现"></a><strong>5. TreeSet 和 TreeMap 的底层实现</strong></h2><ul><li><strong>TreeMap</strong>：基于 <strong>红黑树</strong> 实现</li><li><strong>TreeSet</strong>：内部使用 TreeMap 存储元素</li><li><strong>特点</strong>：<ul><li>自动排序（自然排序或 Comparator）</li><li>查找、插入、删除 O(log n)</li></ul></li><li><strong>红黑树特性</strong>：<ul><li>自平衡二叉搜索树</li><li>插入&#x2F;删除保持平衡，通过旋转和染色操作</li></ul></li></ul><hr><h2 id="6-PriorityQueue-的底层数据结构"><a href="#6-PriorityQueue-的底层数据结构" class="headerlink" title="6. PriorityQueue 的底层数据结构"></a><strong>6. PriorityQueue 的底层数据结构</strong></h2><ul><li><p><strong>基于堆实现</strong>（默认最小堆）</p></li><li><p><strong>特性</strong>：</p><ul><li>插入 O(log n)</li><li>取出最小值 O(log n)</li></ul></li><li><p><strong>内部实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] queue; <span class="comment">// 动态数组存储堆</span></span><br></pre></td></tr></table></figure></li><li><p><strong>应用</strong>：</p><ul><li>定时任务调度</li><li>Dijkstra 算法</li></ul></li><li><p>面试拓展：如何实现最大堆？</p><ul><li>使用 Comparator 或覆写 compare 方法</li></ul></li></ul><hr><h2 id="7-ConcurrentSkipListMap-的底层原理"><a href="#7-ConcurrentSkipListMap-的底层原理" class="headerlink" title="7. ConcurrentSkipListMap 的底层原理"></a><strong>7. ConcurrentSkipListMap 的底层原理</strong></h2><ul><li><strong>基于跳表实现</strong></li><li><strong>特点</strong>：<ul><li>有序 Map，支持并发操作</li><li>读操作无锁（lock-free），写操作使用 CAS&#x2F;锁粒度较小</li></ul></li><li><strong>跳表原理</strong>：<ul><li>多层链表</li><li>顶层链表间隔大</li><li>查找、插入、删除 O(log n) 平均</li></ul></li></ul><hr><h2 id="8-CopyOnWriteArrayList-的写时复制"><a href="#8-CopyOnWriteArrayList-的写时复制" class="headerlink" title="8. CopyOnWriteArrayList 的写时复制"></a><strong>8. CopyOnWriteArrayList 的写时复制</strong></h2><ul><li><strong>原理</strong>：<ul><li>每次写操作（add、remove）都会复制一份底层数组</li><li>读操作不加锁，直接读取旧数组</li></ul></li><li><strong>优点</strong>：<ul><li>高度并发读性能</li><li>避免 ConcurrentModificationException</li></ul></li><li><strong>缺点</strong>：<ul><li>写操作成本高（数组复制）</li><li>内存开销大</li></ul></li><li><strong>应用场景</strong>：<ul><li>读多写少（如监听器列表、配置缓存）</li></ul></li></ul><hr><h2 id="9-EnumMap-和-EnumSet"><a href="#9-EnumMap-和-EnumSet" class="headerlink" title="9. EnumMap 和 EnumSet"></a><strong>9. EnumMap 和 EnumSet</strong></h2><ul><li><strong>EnumMap</strong>：<ul><li>Key 是枚举类型</li><li>底层使用数组存储，效率高</li></ul></li><li><strong>EnumSet</strong>：<ul><li>元素为枚举</li><li>底层使用 <strong>位向量(bit vector)</strong> 存储</li></ul></li><li><strong>特点</strong>：<ul><li>高效，占用内存小</li><li>遍历速度快</li></ul></li><li><strong>应用</strong>：<ul><li>状态机、标志位集合</li></ul></li></ul><hr><h2 id="10-WeakHashMap-和-HashMap-的区别"><a href="#10-WeakHashMap-和-HashMap-的区别" class="headerlink" title="10. WeakHashMap 和 HashMap 的区别"></a><strong>10. WeakHashMap 和 HashMap 的区别</strong></h2><table><thead><tr><th>特性</th><th>HashMap</th><th>WeakHashMap</th></tr></thead><tbody><tr><td>Key 引用类型</td><td>强引用</td><td>弱引用</td></tr><tr><td>GC 行为</td><td>不受垃圾回收影响</td><td>Key 被回收时自动删除 Entry</td></tr><tr><td>用途</td><td>普通 Map</td><td>缓存、内存敏感对象的映射</td></tr><tr><td>面试点</td><td>WeakHashMap 如何防止内存泄漏？</td><td></td></tr></tbody></table><p><strong>原理</strong>：</p><ul><li>WeakHashMap 的 key 是 <code>WeakReference</code></li><li>当 key 不再被外部强引用时，垃圾回收器回收，并通过 ReferenceQueue 清理 Entry</li></ul><hr><h3 id="四、异常-错误处理"><a href="#四、异常-错误处理" class="headerlink" title="四、异常 &amp; 错误处理"></a>四、异常 &amp; 错误处理</h3><hr><h2 id="1-Java-中的异常分为哪两大类？"><a href="#1-Java-中的异常分为哪两大类？" class="headerlink" title="1. Java 中的异常分为哪两大类？"></a><strong>1. Java 中的异常分为哪两大类？</strong></h2><ul><li><strong>Error（错误）</strong>：<ul><li>系统级错误，通常无法恢复</li><li>例子：<code>OutOfMemoryError</code>、<code>StackOverflowError</code></li><li>不建议捕获</li></ul></li><li><strong>Exception（异常）</strong>：<ul><li>程序可以捕获、处理</li><li>子类：<ol><li><strong>受检异常（CheckedException）</strong>：必须 try&#x2F;catch 或 throws 抛出<ul><li>例子：<code>IOException</code>、<code>SQLException</code></li></ul></li><li><strong>非受检异常（UncheckedException &#x2F; RuntimeException）</strong>：可选择捕获<ul><li>例子：<code>NullPointerException</code>、<code>IllegalArgumentException</code></li></ul></li></ol></li></ul></li></ul><p><strong>面试点</strong>：</p><ul><li>Checked vs Unchecked 异常的设计初衷：<ul><li>Checked 异常强制处理，提高程序健壮性</li><li>RuntimeException 用于编程错误，不必强制捕获</li></ul></li></ul><hr><h2 id="2-Error-和-Exception-的区别"><a href="#2-Error-和-Exception-的区别" class="headerlink" title="2. Error 和 Exception 的区别"></a><strong>2. Error 和 Exception 的区别</strong></h2><table><thead><tr><th>特性</th><th>Error</th><th>Exception</th></tr></thead><tbody><tr><td>是否可恢复</td><td>不可恢复</td><td>可恢复（程序可处理）</td></tr><tr><td>捕获建议</td><td>不建议捕获</td><td>建议捕获和处理</td></tr><tr><td>子类示例</td><td>OutOfMemoryError</td><td>IOException, SQLException</td></tr><tr><td>使用场景</td><td>JVM 内部错误</td><td>应用程序异常处理</td></tr></tbody></table><hr><h2 id="3-受检异常和非受检异常区别"><a href="#3-受检异常和非受检异常区别" class="headerlink" title="3. 受检异常和非受检异常区别"></a><strong>3. 受检异常和非受检异常区别</strong></h2><table><thead><tr><th>特性</th><th>CheckedException</th><th>UncheckedException</th></tr></thead><tbody><tr><td>编译器检查</td><td>编译器强制要求处理</td><td>编译器不要求</td></tr><tr><td>继承关系</td><td>Exception 除 RuntimeException</td><td>RuntimeException 子类</td></tr><tr><td>使用场景</td><td>可恢复异常，如文件不存在</td><td>编程错误，如空指针</td></tr></tbody></table><p><strong>面试点</strong>：</p><ul><li>Checked 异常在 API 设计中可提示调用者</li><li>RuntimeException 多用于程序逻辑错误，防止过多 try&#x2F;catch</li></ul><hr><h2 id="4-throw-和-throws-的区别"><a href="#4-throw-和-throws-的区别" class="headerlink" title="4. throw 和 throws 的区别"></a><strong>4. throw 和 throws 的区别</strong></h2><table><thead><tr><th>特性</th><th>throw</th><th>throws</th></tr></thead><tbody><tr><td>位置</td><td>方法体内</td><td>方法声明上</td></tr><tr><td>用途</td><td>抛出具体异常实例</td><td>声明方法可能抛出的异常类型</td></tr><tr><td>个数限制</td><td>一次抛出一个</td><td>可声明多个异常</td></tr><tr><td>面试示例</td><td><code>throw new IOException()</code></td><td><code>void read() throws IOException</code></td></tr></tbody></table><hr><h2 id="5-try-with-resources-的底层原理"><a href="#5-try-with-resources-的底层原理" class="headerlink" title="5. try-with-resources 的底层原理"></a><strong>5. try-with-resources 的底层原理</strong></h2><ul><li><p><strong>语法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>底层实现</strong>：</p><ul><li><p>自动调用资源的 <code>close()</code> 方法</p></li><li><p>资源必须实现 <strong>AutoCloseable</strong> 接口</p></li><li><p>编译器将其转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="literal">null</span>) br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>优势</strong>：</p><ul><li>自动关闭资源，避免资源泄漏</li><li>支持多个资源声明</li></ul></li><li><p><strong>面试拓展</strong>：多资源关闭的异常抑制机制 (<code>addSuppressed</code>)</p></li></ul><hr><h2 id="6-自定义异常如何设计？继承哪个类"><a href="#6-自定义异常如何设计？继承哪个类" class="headerlink" title="6. 自定义异常如何设计？继承哪个类"></a><strong>6. 自定义异常如何设计？继承哪个类</strong></h2><ul><li><p><strong>继承 RuntimeException</strong>：</p><ul><li>用于非受检异常（编程错误、业务逻辑异常）</li></ul></li><li><p><strong>继承 Exception</strong>：</p><ul><li>用于受检异常（需要调用者处理）</li></ul></li><li><p><strong>实现建议</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBusinessException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBusinessException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>面试点</strong>：</p><ul><li>自定义异常加上异常链（cause）</li><li>规范异常信息，便于日志追踪</li></ul></li></ul><hr><h2 id="7-为什么不建议捕获-Throwable？"><a href="#7-为什么不建议捕获-Throwable？" class="headerlink" title="7. 为什么不建议捕获 Throwable？"></a><strong>7. 为什么不建议捕获 Throwable？</strong></h2><ul><li>Throwable 包含 Error 和 Exception</li><li>捕获 Throwable 会：<ul><li>捕获系统级错误（OutOfMemoryError）</li><li>破坏 JVM 正常工作</li></ul></li><li><strong>最佳实践</strong>：<ul><li>只捕获可恢复的 Exception 或 RuntimeException</li><li>捕获 Throwable 仅用于日志收集或监控</li></ul></li></ul><hr><h2 id="8-异常链（Exception-Chaining）是什么"><a href="#8-异常链（Exception-Chaining）是什么" class="headerlink" title="8. 异常链（Exception Chaining）是什么"></a><strong>8. 异常链（Exception Chaining）是什么</strong></h2><ul><li><p><strong>概念</strong>：</p><ul><li>在捕获一个异常时，将原异常封装在新异常中抛出</li></ul></li><li><p><strong>实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;读取文件失败&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>优势</strong>：</p><ul><li>保留原始异常信息</li><li>便于调试和日志追踪</li></ul></li></ul><hr><h2 id="9-Java-8-之后对异常处理的改进"><a href="#9-Java-8-之后对异常处理的改进" class="headerlink" title="9. Java 8 之后对异常处理的改进"></a><strong>9. Java 8 之后对异常处理的改进</strong></h2><ul><li><p><strong>Lambda 表达式</strong>：</p><ul><li>对受检异常的处理更加简洁，但需要特殊处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(item -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; process(item); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(IOException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Optional &amp; Streams</strong>：</p><ul><li>避免空指针异常</li><li>可以在 <code>map</code>&#x2F;<code>filter</code> 中处理异常</li></ul></li><li><p><strong>面试拓展</strong>：</p><ul><li>异常在并行 Stream 中如何传递</li><li><code>CompletableFuture</code> 异常处理</li></ul></li></ul><hr><h2 id="10-多线程环境下如何正确传递异常"><a href="#10-多线程环境下如何正确传递异常" class="headerlink" title="10. 多线程环境下如何正确传递异常"></a><strong>10. 多线程环境下如何正确传递异常</strong></h2><ul><li><p><strong>问题</strong>：</p><ul><li>子线程异常不会直接抛给主线程</li></ul></li><li><p><strong>解决方案</strong>：</p><ol><li><p><strong>Future &#x2F; Callable</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executor.submit(() -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error&quot;</span>); &#125;);</span><br><span class="line">future.get(); <span class="comment">// 会抛 ExecutionException</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Thread.UncaughtExceptionHandler</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setUncaughtExceptionHandler((t, e) -&gt; log.error(<span class="string">&quot;线程异常&quot;</span>, e));</span><br></pre></td></tr></table></figure></li><li><p><strong>CompletableFuture.exceptionally</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(); &#125;)</span><br><span class="line">                 .exceptionally(ex -&gt; &#123; log.error(ex); <span class="keyword">return</span> <span class="literal">null</span>; &#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>面试拓展</strong>：</p><ul><li>如何处理线程池中未捕获异常</li><li>异步任务异常链追踪</li></ul></li></ul><hr><h3 id="五、JVM-内存管理"><a href="#五、JVM-内存管理" class="headerlink" title="五、JVM &amp; 内存管理"></a>五、JVM &amp; 内存管理</h3><hr><h2 id="1-Java-内存模型（JMM）是什么？"><a href="#1-Java-内存模型（JMM）是什么？" class="headerlink" title="1. Java 内存模型（JMM）是什么？"></a><strong>1. Java 内存模型（JMM）是什么？</strong></h2><ul><li><strong>定义</strong>：<ul><li>Java 内存模型（Java Memory Model，JMM）是 Java 虚拟机规范中定义的一套规范，用于描述 <strong>Java 程序中各个线程如何访问共享内存以及如何保证可见性、原子性、有序性</strong>。</li></ul></li><li><strong>核心作用</strong>：<ol><li><strong>解决多线程可见性问题</strong></li><li><strong>规定内存操作顺序</strong>（happens-before 原则）</li><li><strong>定义变量访问原子性</strong></li></ol></li><li><strong>关键概念</strong>：<ul><li><strong>主内存（Main Memory）</strong>：共享变量存储位置</li><li><strong>工作内存（Working Memory &#x2F; Thread Local Cache）</strong>：线程私有缓存</li><li><strong>volatile、synchronized、final</strong> 的语义保证不同层次的可见性和原子性</li></ul></li></ul><hr><h2 id="2-JVM-内存分为哪几个区域？每个区域的作用是什么？"><a href="#2-JVM-内存分为哪几个区域？每个区域的作用是什么？" class="headerlink" title="2. JVM 内存分为哪几个区域？每个区域的作用是什么？"></a><strong>2. JVM 内存分为哪几个区域？每个区域的作用是什么？</strong></h2><ol><li><strong>程序计数器（PC Register）</strong><ul><li>每个线程私有</li><li>保存当前线程执行的字节码指令地址</li><li>支持线程切换和方法调用返回</li></ul></li><li><strong>虚拟机栈（Stack）</strong><ul><li>每个线程私有</li><li>存储局部变量、操作栈、动态链接信息、方法出口</li><li>栈帧：方法执行的最小单位</li><li>异常：StackOverflowError</li></ul></li><li><strong>本地方法栈（Native Method Stack）</strong><ul><li>JVM 调用本地方法（C&#x2F;C++实现）使用</li><li>HotSpot 通常与虚拟机栈合并</li></ul></li><li><strong>堆（Heap）</strong><ul><li>所有线程共享</li><li>存储对象实例及数组</li><li>垃圾收集的主要区域</li><li>子区域：<ul><li><strong>年轻代（Young Generation）</strong>：Eden + Survivor0 + Survivor1</li><li><strong>老年代（Old Generation）</strong></li><li><strong>元空间（Metaspace &#x2F; 方法区）</strong>：存放类元信息</li></ul></li></ul></li><li><strong>方法区（Metaspace &#x2F; 以前称为 PermGen）</strong><ul><li>存储类信息、常量池、静态变量</li><li>Metaspace 从本地内存分配（不再受 JVM 堆大小限制）</li></ul></li><li><strong>运行时常量池</strong><ul><li>类加载时生成</li><li>存放字面量、符号引用、字符串常量等</li></ul></li></ol><hr><h2 id="3-为什么-String-常量池要放在堆里而不是方法区？"><a href="#3-为什么-String-常量池要放在堆里而不是方法区？" class="headerlink" title="3. 为什么 String 常量池要放在堆里而不是方法区？"></a><strong>3. 为什么 String 常量池要放在堆里而不是方法区？</strong></h2><ul><li><strong>历史原因</strong>：<ul><li>JDK 1.6 及以前：字符串常量池在永久代（PermGen），易导致 OOM</li></ul></li><li><strong>现代实现</strong>：<ul><li>JDK 7+ 将常量池移到堆</li></ul></li><li><strong>优势</strong>：<ol><li>垃圾回收可管理</li><li>内存分配灵活，避免方法区溢出</li><li>多线程访问安全性提升（与堆对象 GC 同步）</li></ol></li></ul><hr><h2 id="4-什么是垃圾回收（GC）的可达性分析算法？"><a href="#4-什么是垃圾回收（GC）的可达性分析算法？" class="headerlink" title="4. 什么是垃圾回收（GC）的可达性分析算法？"></a><strong>4. 什么是垃圾回收（GC）的可达性分析算法？</strong></h2><ul><li><p><strong>可达性分析（Reachability Analysis）</strong>：</p><ul><li>从 <strong>GC Roots</strong> 开始，通过引用链判断对象是否可达</li><li><strong>不可达对象</strong>即为垃圾，可以回收</li></ul></li><li><p><strong>示意</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GC Roots</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">Object A --&gt; Object B</span><br></pre></td></tr></table></figure><ul><li>如果 Object B 无法通过 GC Roots 访问，则被回收</li></ul></li></ul><hr><h2 id="5-哪些对象可以作为-GC-Roots？"><a href="#5-哪些对象可以作为-GC-Roots？" class="headerlink" title="5. 哪些对象可以作为 GC Roots？"></a><strong>5. 哪些对象可以作为 GC Roots？</strong></h2><p>常见 GC Roots：</p><ol><li><strong>虚拟机栈中的引用</strong>（局部变量、方法参数）</li><li><strong>静态变量</strong>（类静态成员）</li><li><strong>常量引用</strong>（常量池引用）</li><li><strong>JNI 引用</strong>（本地方法栈中的引用）</li></ol><hr><h2 id="6-强引用、软引用、弱引用、虚引用的区别"><a href="#6-强引用、软引用、弱引用、虚引用的区别" class="headerlink" title="6. 强引用、软引用、弱引用、虚引用的区别"></a><strong>6. 强引用、软引用、弱引用、虚引用的区别</strong></h2><table><thead><tr><th>类型</th><th>特点</th><th>GC 行为</th><th>面试应用</th></tr></thead><tbody><tr><td>强引用（Strong Reference）</td><td>普通对象引用</td><td>不可回收</td><td>普通对象</td></tr><tr><td>软引用（Soft Reference）</td><td>通过 SoftReference 引用</td><td>内存不足时回收</td><td>缓存（Memory-sensitive cache）</td></tr><tr><td>弱引用（Weak Reference）</td><td>WeakReference 引用</td><td>GC 时立即回收</td><td>ThreadLocal 清理、缓存</td></tr><tr><td>虚引用（Phantom Reference）</td><td>PhantomReference 引用</td><td>仅做引用队列通知</td><td>对象回收前做清理、资源释放</td></tr></tbody></table><hr><h2 id="7-GC-算法"><a href="#7-GC-算法" class="headerlink" title="7. GC 算法"></a><strong>7. GC 算法</strong></h2><ol><li><strong>标记-清除（Mark-Sweep）</strong><ul><li>标记可达对象，清除未标记对象</li><li>优点：简单</li><li>缺点：产生碎片</li></ul></li><li><strong>标记-整理（Mark-Compact）</strong><ul><li>标记可达对象</li><li>将存活对象移动到一端</li><li>优点：解决碎片问题</li><li>缺点：移动对象成本高</li></ul></li><li><strong>复制算法（Copying）</strong><ul><li>将内存分为两块</li><li>将存活对象复制到另一块，清理旧块</li><li>优点：分配快，整理快</li><li>缺点：内存利用率低</li></ul></li></ol><hr><h2 id="8-常见的垃圾收集器"><a href="#8-常见的垃圾收集器" class="headerlink" title="8. 常见的垃圾收集器"></a><strong>8. 常见的垃圾收集器</strong></h2><table><thead><tr><th>垃圾收集器</th><th>适用场景</th><th>特点</th></tr></thead><tbody><tr><td>Serial GC</td><td>单核</td><td>STW 串行，简单、高吞吐量低</td></tr><tr><td>Parallel GC</td><td>多核</td><td>并行回收年轻代，高吞吐量</td></tr><tr><td>CMS GC</td><td>多核</td><td>并发回收老年代，减少 STW</td></tr><tr><td>G1 GC</td><td>大堆</td><td>分区回收，低延迟，预测停顿</td></tr><tr><td>ZGC</td><td>超大堆</td><td>并发标记-清理，低延迟</td></tr><tr><td>Shenandoah</td><td>大堆</td><td>并发标记-整理，减少 STW</td></tr></tbody></table><hr><h2 id="9-什么是-Stop-The-World-STW-？"><a href="#9-什么是-Stop-The-World-STW-？" class="headerlink" title="9. 什么是 Stop-The-World (STW)？"></a><strong>9. 什么是 Stop-The-World (STW)？</strong></h2><ul><li><strong>定义</strong>：JVM 暂停所有应用线程执行，专门进行 GC</li><li><strong>原因</strong>：<ul><li>防止对象被修改导致回收错误</li></ul></li><li><strong>面试拓展</strong>：<ul><li>G1&#x2F;ZGC&#x2F;Shenandoah 尽量缩短 STW 时间</li><li>并发 GC 与 STW 的折中</li></ul></li></ul><hr><h2 id="10-JVM-调优常见参数"><a href="#10-JVM-调优常见参数" class="headerlink" title="10. JVM 调优常见参数"></a><strong>10. JVM 调优常见参数</strong></h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>-Xmx</code></td><td>最大堆大小</td></tr><tr><td><code>-Xms</code></td><td>初始堆大小</td></tr><tr><td><code>-Xmn</code></td><td>年轻代大小</td></tr><tr><td><code>-XX:SurvivorRatio</code></td><td>Eden&#x2F;Survivor 比例</td></tr><tr><td><code>-XX:+UseG1GC</code></td><td>使用 G1 GC</td></tr><tr><td><code>-XX:MaxGCPauseMillis</code></td><td>最大停顿时间</td></tr><tr><td><code>-XX:+PrintGCDetails</code></td><td>打印 GC 日志</td></tr><tr><td><code>-XX:+HeapDumpOnOutOfMemoryError</code></td><td>OOM 时生成堆转储</td></tr></tbody></table><p><strong>面试拓展</strong>：</p><ul><li>如何调优老年代和年轻代比例？</li><li>GC 日志分析示例：年轻代满、老年代晋升、STW 停顿</li></ul><hr><h3 id="六、并发编程基础"><a href="#六、并发编程基础" class="headerlink" title="六、并发编程基础"></a>六、并发编程基础</h3><hr><h2 id="1-Java-中的-volatile-关键字的底层实现原理"><a href="#1-Java-中的-volatile-关键字的底层实现原理" class="headerlink" title="1. Java 中的 volatile 关键字的底层实现原理"></a><strong>1. Java 中的 volatile 关键字的底层实现原理</strong></h2><ul><li><strong>作用</strong>：<ol><li><strong>保证可见性</strong>：一个线程修改变量后，其他线程立即可见</li><li><strong>禁止指令重排</strong>：保证顺序性</li></ol></li><li><strong>原理</strong>：<ul><li>底层通过 <strong>内存屏障（Memory Barrier &#x2F; Fence）</strong> 实现</li><li><code>volatile</code> 读操作：<ul><li>加载屏障（LoadLoad + LoadStore）</li></ul></li><li><code>volatile</code> 写操作：<ul><li>写屏障（StoreStore + StoreLoad）</li></ul></li></ul></li><li><strong>注意</strong>：<ul><li>不能保证 <strong>原子性</strong></li><li>适合 <strong>状态标识、开关变量</strong></li></ul></li></ul><hr><h2 id="2-synchronized-的实现原理"><a href="#2-synchronized-的实现原理" class="headerlink" title="2. synchronized 的实现原理"></a><strong>2. synchronized 的实现原理</strong></h2><ul><li><strong>作用</strong>：<ul><li>保证 <strong>互斥访问</strong></li><li>保证 <strong>可见性</strong></li></ul></li><li><strong>底层机制</strong>：<ul><li>Java 对象头包含 <strong>Mark Word</strong></li><li>每个对象可以关联一个 <strong>Monitor</strong></li><li><strong>Monitor</strong> 用于管理线程的加锁、阻塞、唤醒</li></ul></li><li><strong>锁升级流程</strong>：<ol><li><strong>偏向锁</strong>（默认轻量级线程无竞争）</li><li><strong>轻量级锁</strong>（CAS 竞争，膨胀前）</li><li><strong>重量级锁</strong>（锁膨胀，阻塞其他线程）</li></ol></li></ul><hr><h2 id="3-偏向锁、轻量级锁、重量级锁"><a href="#3-偏向锁、轻量级锁、重量级锁" class="headerlink" title="3. 偏向锁、轻量级锁、重量级锁"></a><strong>3. 偏向锁、轻量级锁、重量级锁</strong></h2><table><thead><tr><th>锁类型</th><th>适用场景</th><th>实现方式</th><th>优缺点</th></tr></thead><tbody><tr><td>偏向锁</td><td>单线程</td><td>在对象头标记线程 ID</td><td>减少无竞争开销</td></tr><tr><td>轻量级锁</td><td>多线程竞争轻量</td><td>CAS 自旋 + 栈记录锁</td><td>高效，避免阻塞</td></tr><tr><td>重量级锁</td><td>多线程竞争严重</td><td>Monitor + 阻塞</td><td>开销大，可能 STW</td></tr></tbody></table><p><strong>面试拓展</strong>：</p><ul><li>如何通过 <code>-XX:+PrintFlagsFinal</code> 查看锁标志位</li><li>偏向锁默认延迟 4 秒启用</li></ul><hr><h2 id="4-什么是-CAS-操作？ABA-问题如何解决？"><a href="#4-什么是-CAS-操作？ABA-问题如何解决？" class="headerlink" title="4. 什么是 CAS 操作？ABA 问题如何解决？"></a><strong>4. 什么是 CAS 操作？ABA 问题如何解决？</strong></h2><ul><li><p><strong>CAS（Compare-And-Swap）</strong>：</p><ul><li>原子操作</li><li>比较内存值是否为预期值，如果是就更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAS(V, A, B)</span><br></pre></td></tr></table></figure></li><li><p><strong>ABA 问题</strong>：</p><ul><li>值先从 A 改成 B，又改回 A</li><li>CAS 无法检测变化，可能出错</li></ul></li><li><p><strong>解决方案</strong>：</p><ol><li><strong>版本号机制</strong>（AtomicStampedReference）</li><li><strong>加锁</strong></li></ol></li></ul><hr><h2 id="5-什么是线程安全？举例线程安全类"><a href="#5-什么是线程安全？举例线程安全类" class="headerlink" title="5. 什么是线程安全？举例线程安全类"></a><strong>5. 什么是线程安全？举例线程安全类</strong></h2><ul><li><strong>定义</strong>：多个线程访问同一个对象时，不会破坏对象的状态，并保证正确性</li><li><strong>线程安全类示例</strong>：<ul><li>集合类：<code>Vector</code>, <code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code></li><li>原子类：<code>AtomicInteger</code>, <code>AtomicReference</code></li><li>工具类：<code>ThreadLocal</code>, <code>BlockingQueue</code></li></ul></li></ul><hr><h2 id="6-ThreadLocal-的底层原理与内存泄漏问题"><a href="#6-ThreadLocal-的底层原理与内存泄漏问题" class="headerlink" title="6. ThreadLocal 的底层原理与内存泄漏问题"></a><strong>6. ThreadLocal 的底层原理与内存泄漏问题</strong></h2><ul><li><strong>原理</strong>：<ul><li>每个线程维护一个 <code>ThreadLocalMap</code></li><li>key 是 <strong>ThreadLocal 对象</strong></li><li>value 是对应的值</li></ul></li><li><strong>内存泄漏原因</strong>：<ul><li>ThreadLocalMap 的 key 是 <strong>弱引用</strong></li><li>如果 ThreadLocal 对象被回收，但线程仍存活，value 仍然存在</li></ul></li><li><strong>解决方法</strong>：<ul><li>使用 <code>remove()</code> 方法</li><li>避免长生命周期线程存储大量 ThreadLocal</li></ul></li></ul><hr><h2 id="7-线程池的核心参数"><a href="#7-线程池的核心参数" class="headerlink" title="7. 线程池的核心参数"></a><strong>7. 线程池的核心参数</strong></h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程数，常驻线程</td></tr><tr><td>maximumPoolSize</td><td>最大线程数</td></tr><tr><td>keepAliveTime</td><td>非核心线程空闲存活时间</td></tr><tr><td>workQueue</td><td>等待队列，用于存放任务</td></tr><tr><td>threadFactory</td><td>线程创建工厂</td></tr><tr><td>RejectedExecutionHandler</td><td>拒绝策略</td></tr></tbody></table><hr><h2 id="8-什么是拒绝策略"><a href="#8-什么是拒绝策略" class="headerlink" title="8. 什么是拒绝策略"></a><strong>8. 什么是拒绝策略</strong></h2><ul><li><strong>触发场景</strong>：线程池满了，队列满了</li><li><strong>常见策略</strong>：<ol><li><strong>AbortPolicy</strong>：抛异常，默认</li><li><strong>CallerRunsPolicy</strong>：由调用线程执行任务</li><li><strong>DiscardPolicy</strong>：直接丢弃任务</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列中最旧任务</li></ol></li></ul><hr><h2 id="9-Executors-提供的常见线程池"><a href="#9-Executors-提供的常见线程池" class="headerlink" title="9. Executors 提供的常见线程池"></a><strong>9. Executors 提供的常见线程池</strong></h2><table><thead><tr><th>线程池类型</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td>FixedThreadPool</td><td>固定线程数</td><td>CPU密集型任务</td></tr><tr><td>CachedThreadPool</td><td>可扩容线程池</td><td>短生命周期任务</td></tr><tr><td>SingleThreadExecutor</td><td>单线程顺序执行</td><td>顺序任务</td></tr><tr><td>ScheduledThreadPool</td><td>支持定时&#x2F;周期执行</td><td>定时任务</td></tr></tbody></table><p><strong>面试拓展</strong>：</p><ul><li>Executors.newFixedThreadPool 会使用 <strong>LinkedBlockingQueue</strong></li><li>CachedThreadPool 使用 <strong>SynchronousQueue</strong>，任务直接交给线程</li></ul><hr><h2 id="10-Future-和-CompletableFuture-区别"><a href="#10-Future-和-CompletableFuture-区别" class="headerlink" title="10. Future 和 CompletableFuture 区别"></a><strong>10. Future 和 CompletableFuture 区别</strong></h2><table><thead><tr><th>特性</th><th>Future</th><th>CompletableFuture</th></tr></thead><tbody><tr><td>异步</td><td>提交任务后可阻塞获取结果</td><td>可链式异步操作</td></tr><tr><td>API</td><td>get() 阻塞</td><td>thenApply, thenAccept 等链式</td></tr><tr><td>异常处理</td><td>阻塞式，捕获 ExecutionException</td><td>支持 exceptionally&#x2F;handle</td></tr><tr><td>组合任务</td><td>组合困难</td><td>支持 allOf &#x2F; anyOf &#x2F; thenCombine</td></tr></tbody></table><p><strong>面试点</strong>：</p><ul><li>CompletableFuture 适合多异步任务组合</li><li>FutureTask 可作为 Future 的实现类</li></ul><hr><h3 id="七、编译-运行时"><a href="#七、编译-运行时" class="headerlink" title="七、编译 &amp; 运行时"></a>七、编译 &amp; 运行时</h3><hr><h2 id="1-Java-的反射机制是什么？底层原理？"><a href="#1-Java-的反射机制是什么？底层原理？" class="headerlink" title="1. Java 的反射机制是什么？底层原理？"></a><strong>1. Java 的反射机制是什么？底层原理？</strong></h2><ul><li><p><strong>概念</strong>：</p><ul><li>反射机制允许在运行时 <strong>获取类的信息、实例化对象、访问字段和方法</strong>，而不需要在编译期知道具体类型</li></ul></li><li><p><strong>常用 API</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.User&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line">method.invoke(obj, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>底层原理</strong>：</p><ul><li>JVM 中类对象 <code>Class</code> 对应内存中的元数据（方法表、字段表、常量池）</li><li>通过 <strong>Native 方法</strong> 调用，访问类的元数据和对象实例</li></ul></li><li><p><strong>面试拓展</strong>：</p><ul><li>反射可访问私有字段&#x2F;方法（<code>setAccessible(true)</code>）</li><li>反射适用于框架（Spring、MyBatis）</li></ul></li></ul><hr><h2 id="2-为什么反射性能差？JDK-9-之后如何优化？"><a href="#2-为什么反射性能差？JDK-9-之后如何优化？" class="headerlink" title="2. 为什么反射性能差？JDK 9 之后如何优化？"></a><strong>2. 为什么反射性能差？JDK 9 之后如何优化？</strong></h2><ul><li><strong>性能差原因</strong>：<ol><li>每次访问方法&#x2F;字段都要进行动态解析</li><li>JVM 无法做内联优化（方法调用不是静态绑定）</li><li>需要检查权限、类型转换</li></ol></li><li><strong>优化措施</strong>：<ul><li><strong>JDK 7 及以后</strong>：<code>MethodHandle</code> 和 <code>invokeDynamic</code></li><li><strong>JDK 9+</strong>：增强模块化（模块边界检查优化）</li><li><strong>热点编译器 JIT</strong> 可以对反射调用做内联</li></ul></li></ul><hr><h2 id="3-什么是动态代理？JDK-动态代理和-CGLIB-区别？"><a href="#3-什么是动态代理？JDK-动态代理和-CGLIB-区别？" class="headerlink" title="3. 什么是动态代理？JDK 动态代理和 CGLIB 区别？"></a><strong>3. 什么是动态代理？JDK 动态代理和 CGLIB 区别？</strong></h2><ul><li><p><strong>动态代理</strong>：</p><ul><li>在运行时生成代理对象，拦截方法调用，增强行为</li></ul></li><li><p><strong>JDK 动态代理</strong>：</p><ul><li>基于接口</li><li>使用 <code>Proxy.newProxyInstance</code></li><li>通过 <code>InvocationHandler.invoke</code> 调用</li></ul></li><li><p><strong>CGLIB</strong>：</p><ul><li>基于子类继承（无接口也可代理）</li><li>使用 ASM 字节码生成子类</li><li>注意 final 类&#x2F;方法不能被代理</li></ul></li><li><p><strong>对比</strong>：</p><table><thead><tr><th>特性</th><th>JDK 动态代理</th><th>CGLIB</th></tr></thead><tbody><tr><td>是否需要接口</td><td>必须</td><td>不需要</td></tr><tr><td>原理</td><td>Proxy + InvocationHandler</td><td>ASM 字节码生成子类</td></tr><tr><td>性能</td><td>略慢</td><td>较快</td></tr><tr><td>局限性</td><td>无</td><td>final 类&#x2F;方法不可代理</td></tr></tbody></table></li></ul><hr><h2 id="4-注解的底层原理是什么？运行时注解如何实现？"><a href="#4-注解的底层原理是什么？运行时注解如何实现？" class="headerlink" title="4. 注解的底层原理是什么？运行时注解如何实现？"></a><strong>4. 注解的底层原理是什么？运行时注解如何实现？</strong></h2><ul><li><strong>概念</strong>：<ul><li>注解是一种 <strong>元数据</strong>，用于给类、方法、字段等提供信息</li></ul></li><li><strong>底层原理</strong>：<ul><li>编译时生成 <code>.class</code> 文件中 <code>RuntimeVisibleAnnotations</code> 属性</li><li>JVM 通过 <code>java.lang.reflect.AnnotatedElement</code> 获取</li></ul></li><li><strong>运行时注解</strong>：<ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code></li><li>通过反射 API 读取注解并执行逻辑</li></ul></li><li><strong>应用场景</strong>：<ul><li>Spring 注解（<code>@Autowired</code>、<code>@Service</code>）</li><li>JPA 注解（<code>@Entity</code>、<code>@Column</code>）</li></ul></li></ul><hr><h2 id="5-ClassLoader-的双亲委派模型是什么？"><a href="#5-ClassLoader-的双亲委派模型是什么？" class="headerlink" title="5. ClassLoader 的双亲委派模型是什么？"></a><strong>5. ClassLoader 的双亲委派模型是什么？</strong></h2><ul><li><p><strong>原理</strong>：</p><ul><li>当类加载请求到来时，<strong>先委托父 ClassLoader 加载</strong></li><li>如果父 ClassLoader 加载失败，再由子 ClassLoader 加载</li></ul></li><li><p><strong>优点</strong>：</p><ol><li>避免重复加载</li><li>保证核心类（如 <code>java.lang.*</code>）唯一性</li></ol></li><li><p><strong>示意</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap -&gt; Extension -&gt; App -&gt; Custom</span><br></pre></td></tr></table></figure></li><li><p><strong>面试拓展</strong>：</p><ul><li>双亲委派模型是保证 JVM 核心类安全的重要机制</li></ul></li></ul><hr><h2 id="6-如何打破双亲委派？"><a href="#6-如何打破双亲委派？" class="headerlink" title="6. 如何打破双亲委派？"></a><strong>6. 如何打破双亲委派？</strong></h2><ul><li>自定义 ClassLoader</li><li>在 <code>loadClass</code> 中先加载自己定义的类，再委派父类（逆向委派）</li><li>注意：破坏双亲委派可能引发类冲突、内存泄漏</li></ul><hr><h2 id="7-什么是-SPI（Service-Provider-Interface）机制？"><a href="#7-什么是-SPI（Service-Provider-Interface）机制？" class="headerlink" title="7. 什么是 SPI（Service Provider Interface）机制？"></a><strong>7. 什么是 SPI（Service Provider Interface）机制？</strong></h2><ul><li><strong>概念</strong>：<ul><li>Java 提供的一种服务发现机制</li><li>通过接口 + 配置文件，动态加载实现类</li></ul></li><li><strong>实现</strong>：<ol><li>接口 <code>MyService</code></li><li>文件 <code>META-INF/services/com.example.MyService</code><ul><li>内容：实现类全限定名</li></ul></li><li><code>ServiceLoader.load(MyService.class)</code> 自动加载实现类</li></ol></li><li><strong>应用</strong>：<ul><li>JDBC 驱动加载</li><li>Logging 框架（SLF4J）</li></ul></li></ul><hr><h2 id="8-Java-是如何实现跨平台的？"><a href="#8-Java-是如何实现跨平台的？" class="headerlink" title="8. Java 是如何实现跨平台的？"></a><strong>8. Java 是如何实现跨平台的？</strong></h2><ul><li><strong>原理</strong>：<ol><li>Java 代码 -&gt; 编译成 <strong>字节码（.class）</strong></li><li>JVM 负责字节码解释或即时编译（JIT）执行</li><li>JVM 将字节码映射到不同操作系统和 CPU</li></ol></li><li><strong>面试拓展</strong>：<ul><li>字节码验证机制确保安全性</li><li>HotSpot JIT 提供本地优化</li></ul></li></ul><hr><h2 id="9-JIT（即时编译器）优化了哪些东西？"><a href="#9-JIT（即时编译器）优化了哪些东西？" class="headerlink" title="9. JIT（即时编译器）优化了哪些东西？"></a><strong>9. JIT（即时编译器）优化了哪些东西？</strong></h2><ul><li><strong>JIT（Just-In-Time Compiler）</strong>：<ul><li>将热点字节码动态编译成本地机器码</li></ul></li><li><strong>优化策略</strong>：<ol><li><strong>方法内联</strong>：减少方法调用开销</li><li><strong>循环优化</strong>：消除冗余计算</li><li><strong>逃逸分析</strong>：栈上分配对象</li><li><strong>锁消除&#x2F;锁粗化</strong>：减少锁开销</li><li><strong>指令重排序优化</strong></li></ol></li></ul><hr><h2 id="10-什么是逃逸分析？"><a href="#10-什么是逃逸分析？" class="headerlink" title="10. 什么是逃逸分析？"></a><strong>10. 什么是逃逸分析？</strong></h2><ul><li><strong>概念</strong>：<ul><li>分析对象的引用范围</li><li>判断对象是否“逃逸”出方法或线程</li></ul></li><li><strong>优化应用</strong>：<ol><li><strong>栈上分配</strong>：对象不逃逸可以直接分配在栈上</li><li><strong>标量替换</strong>：将对象拆解为基本类型，提高缓存命中</li><li><strong>锁消除</strong>：对象不逃逸，synchronized 可被消除</li></ol></li><li><strong>面试拓展</strong>：<ul><li>JIT 结合逃逸分析可显著提升性能</li><li>适用于短生命周期对象</li></ul></li></ul><hr><h3 id="八、常见场景-设计"><a href="#八、常见场景-设计" class="headerlink" title="八、常见场景 &amp; 设计"></a>八、常见场景 &amp; 设计</h3><hr><h2 id="1-单例模式在-Java-中有哪些实现方式？哪种最优？"><a href="#1-单例模式在-Java-中有哪些实现方式？哪种最优？" class="headerlink" title="1. 单例模式在 Java 中有哪些实现方式？哪种最优？"></a><strong>1. 单例模式在 Java 中有哪些实现方式？哪种最优？</strong></h2><ul><li><p><strong>常见实现方式</strong>：</p><ol><li><p><strong>饿汉式（静态常量）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：线程安全，简单</li><li>缺点：类加载即初始化，不支持延迟加载</li></ul></li><li><p><strong>懒汉式（加锁）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：支持延迟加载</li><li>缺点：每次访问都有同步开销</li></ul></li><li><p><strong>双重检查锁（Double-Checked Locking）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：线程安全 + 延迟加载 + 高性能</li><li><strong>推荐</strong></li></ul></li><li><p><strong>静态内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123; <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> Holder.INSTANCE; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原理：JVM 保证类加载线程安全</li><li>优点：懒加载 + 高性能</li><li><strong>最佳实践之一</strong></li></ul></li><li><p><strong>枚举单例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123; INSTANCE; &#125;</span><br></pre></td></tr></table></figure><ul><li>原理：JVM 保证枚举类型单例</li><li>优点：线程安全、防止反射和序列化破坏</li><li><strong>最佳实践</strong></li></ul></li></ol></li></ul><hr><h2 id="2-懒汉模式和饿汉模式的区别"><a href="#2-懒汉模式和饿汉模式的区别" class="headerlink" title="2. 懒汉模式和饿汉模式的区别"></a><strong>2. 懒汉模式和饿汉模式的区别</strong></h2><table><thead><tr><th>特性</th><th>懒汉模式</th><th>饿汉模式</th></tr></thead><tbody><tr><td>加载时机</td><td>延迟加载，第一次使用</td><td>类加载即初始化</td></tr><tr><td>线程安全</td><td>需加锁&#x2F;双重检查</td><td>天然线程安全</td></tr><tr><td>性能</td><td>多线程同步有开销</td><td>无额外开销</td></tr><tr><td>内存使用</td><td>按需分配</td><td>类加载时分配</td></tr></tbody></table><hr><h2 id="3-枚举单例为什么是最佳实践"><a href="#3-枚举单例为什么是最佳实践" class="headerlink" title="3. 枚举单例为什么是最佳实践"></a><strong>3. 枚举单例为什么是最佳实践</strong></h2><ul><li>JVM 保证枚举实例唯一性</li><li><strong>防止反射和序列化破坏</strong></li><li>实现简洁，无需手动同步</li><li>面试常考点：相比双重检查锁更安全</li></ul><hr><h2 id="4-为什么要用工厂模式？"><a href="#4-为什么要用工厂模式？" class="headerlink" title="4. 为什么要用工厂模式？"></a><strong>4. 为什么要用工厂模式？</strong></h2><ul><li><strong>作用</strong>：<ul><li>隐藏对象创建逻辑</li><li>解耦调用方和实现类</li></ul></li><li><strong>类型</strong>：<ol><li><strong>简单工厂</strong>：静态方法返回对象</li><li><strong>工厂方法</strong>：子类决定创建哪种对象</li><li><strong>抽象工厂</strong>：一组相关对象的创建</li></ol></li><li><strong>优势</strong>：<ul><li>可扩展性高</li><li>符合开闭原则</li></ul></li></ul><hr><h2 id="5-装饰器模式和代理模式区别"><a href="#5-装饰器模式和代理模式区别" class="headerlink" title="5. 装饰器模式和代理模式区别"></a><strong>5. 装饰器模式和代理模式区别</strong></h2><table><thead><tr><th>特性</th><th>装饰器模式</th><th>代理模式</th></tr></thead><tbody><tr><td>目的</td><td>动态增强对象功能</td><td>控制对象访问</td></tr><tr><td>结构</td><td>包装原对象，继承接口</td><td>持有原对象，方法委托</td></tr><tr><td>场景</td><td>IO 流（BufferedReader）</td><td>远程调用、权限控制</td></tr><tr><td>动态性</td><td>高</td><td>可以通过动态代理实现</td></tr></tbody></table><hr><h2 id="6-Java-中的事件监听模型是怎么实现的？"><a href="#6-Java-中的事件监听模型是怎么实现的？" class="headerlink" title="6. Java 中的事件监听模型是怎么实现的？"></a><strong>6. Java 中的事件监听模型是怎么实现的？</strong></h2><ul><li><strong>机制</strong>：<ol><li><strong>事件源（Event Source）</strong>：产生事件</li><li><strong>事件监听器（Listener）</strong>：接口，定义回调方法</li><li><strong>注册与触发</strong>：源对象维护监听器列表，事件发生时通知监听器</li></ol></li><li><strong>典型应用</strong>：<ul><li>Swing&#x2F;AWT 事件</li><li>Spring ApplicationEvent</li></ul></li></ul><hr><h2 id="7-为什么-Java-不支持多继承？"><a href="#7-为什么-Java-不支持多继承？" class="headerlink" title="7. 为什么 Java 不支持多继承？"></a><strong>7. 为什么 Java 不支持多继承？</strong></h2><ul><li><strong>原因</strong>：<ul><li>避免 <strong>钻石问题</strong>（多继承产生方法冲突）</li><li>简化对象模型，保证 JVM 类型安全</li></ul></li><li><strong>替代方案</strong>：<ul><li>接口多继承 + 默认方法（Java 8+）</li><li>组合设计模式（优先使用 has-a 而不是 is-a）</li></ul></li></ul><hr><h2 id="8-如何用-Java-实现回调机制？"><a href="#8-如何用-Java-实现回调机制？" class="headerlink" title="8. 如何用 Java 实现回调机制？"></a><strong>8. 如何用 Java 实现回调机制？</strong></h2><ul><li><p><strong>原理</strong>：</p><ul><li>将函数封装成对象或接口传递给另一个对象</li><li>由被调用对象在合适时机调用接口方法</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123; <span class="keyword">void</span> <span class="title function_">onDone</span><span class="params">(String result)</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">asyncProcess</span><span class="params">(Callback callback)</span> &#123; <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; callback.onDone(<span class="string">&quot;ok&quot;</span>)).start(); &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="9-Java-中如何实现观察者模式？"><a href="#9-Java-中如何实现观察者模式？" class="headerlink" title="9. Java 中如何实现观察者模式？"></a><strong>9. Java 中如何实现观察者模式？</strong></h2><ul><li><p><strong>机制</strong>：</p><ol><li><strong>Subject（被观察者）</strong>：维护观察者列表，提供注册&#x2F;注销方法</li><li><strong>Observer（观察者）</strong>：接口，定义 update 方法</li><li><strong>触发事件</strong>：Subject 状态变化时调用所有 Observer 的 update</li></ol></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123; <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String msg)</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer o)</span> &#123; observers.add(o); &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        observers.forEach(o -&gt; o.update(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="10-Optional-的设计初衷是什么？"><a href="#10-Optional-的设计初衷是什么？" class="headerlink" title="10. Optional 的设计初衷是什么？"></a><strong>10. Optional 的设计初衷是什么？</strong></h2><ul><li><p><strong>目的</strong>：</p><ul><li>避免 null 值导致的 <strong>NullPointerException</strong></li><li>提供函数式 API，提高可读性</li></ul></li><li><p><strong>使用方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.ofNullable(getValue());</span><br><span class="line">optional.ifPresent(System.out::println);</span><br><span class="line"><span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> optional.orElse(<span class="string">&quot;default&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>优势</strong>：</p><ul><li>显示处理缺失值</li><li>支持链式调用、函数式风格</li></ul></li><li><p><strong>面试拓展</strong>：</p><ul><li>Optional 不适合用于集合属性，避免滥用</li></ul></li></ul><hr><h2 id="二、Java-并发编程（30题）"><a href="#二、Java-并发编程（30题）" class="headerlink" title="二、Java 并发编程（30题）"></a>二、Java 并发编程（30题）</h2><hr><h2 id="1-线程的生命周期"><a href="#1-线程的生命周期" class="headerlink" title="1. 线程的生命周期"></a><strong>1. 线程的生命周期</strong></h2><ul><li><strong>状态</strong>：<ol><li><strong>NEW</strong>：创建后，未调用 <code>start()</code></li><li><strong>RUNNABLE</strong>：调用 <code>start()</code>，可运行（线程调度器决定何时执行）</li><li><strong>BLOCKED</strong>：等待锁</li><li><strong>WAITING</strong>：无限期等待（<code>Object.wait()</code> &#x2F; <code>LockSupport.park()</code>）</li><li><strong>TIMED_WAITING</strong>：超时等待（<code>sleep()</code>, <code>join(timeout)</code>）</li><li><strong>TERMINATED</strong>：执行完毕</li></ol></li></ul><hr><h2 id="2-创建线程的方式"><a href="#2-创建线程的方式" class="headerlink" title="2. 创建线程的方式"></a><strong>2. 创建线程的方式</strong></h2><ol><li><strong>继承 Thread 类</strong></li><li><strong>实现 Runnable 接口</strong></li><li><strong>实现 Callable + FutureTask</strong></li><li><strong>线程池（推荐）</strong></li></ol><hr><h2 id="3-Runnable-和-Callable-区别"><a href="#3-Runnable-和-Callable-区别" class="headerlink" title="3. Runnable 和 Callable 区别"></a><strong>3. Runnable 和 Callable 区别</strong></h2><table><thead><tr><th>特性</th><th>Runnable</th><th>Callable</th></tr></thead><tbody><tr><td>返回值</td><td>无</td><td>可以有返回值</td></tr><tr><td>异常</td><td>不可抛出检查异常</td><td>可以抛出异常</td></tr><tr><td>执行方式</td><td>new Thread(runnable)</td><td>ExecutorService.submit(callable)</td></tr></tbody></table><hr><h2 id="4-Future-和-CompletableFuture-区别"><a href="#4-Future-和-CompletableFuture-区别" class="headerlink" title="4. Future 和 CompletableFuture 区别"></a><strong>4. Future 和 CompletableFuture 区别</strong></h2><ul><li><strong>Future</strong>：<ul><li>阻塞式获取结果</li><li>不支持链式异步处理</li></ul></li><li><strong>CompletableFuture</strong>：<ul><li>支持链式异步处理（thenApply, thenCombine, exceptionally）</li><li>可组合多个异步任务</li></ul></li></ul><hr><h2 id="5-ThreadLocal-原理"><a href="#5-ThreadLocal-原理" class="headerlink" title="5. ThreadLocal 原理"></a><strong>5. ThreadLocal 原理</strong></h2><ul><li>每个线程持有一个 <strong>ThreadLocalMap</strong></li><li>key 是 <strong>ThreadLocal 对象</strong>，value 是线程私有变量</li><li>内存泄漏风险：<ul><li>ThreadLocal 弱引用被 GC，value 没有被回收</li></ul></li><li>解决方法：<ul><li>使用 <code>remove()</code> 清理</li></ul></li></ul><hr><h2 id="6-synchronized-的锁优化机制"><a href="#6-synchronized-的锁优化机制" class="headerlink" title="6. synchronized 的锁优化机制"></a><strong>6. synchronized 的锁优化机制</strong></h2><ol><li><strong>偏向锁</strong>：减少无竞争开销</li><li><strong>轻量级锁</strong>：CAS + 自旋</li><li><strong>重量级锁</strong>：Monitor 阻塞线程</li><li><strong>锁消除&#x2F;锁粗化</strong>：JIT 优化</li></ol><hr><h2 id="7-ReentrantLock-实现原理"><a href="#7-ReentrantLock-实现原理" class="headerlink" title="7. ReentrantLock 实现原理"></a><strong>7. ReentrantLock 实现原理</strong></h2><ul><li>基于 <strong>AQS（AbstractQueuedSynchronizer）</strong></li><li>内部维护一个 <strong>state</strong> 表示锁状态</li><li>队列 FIFO 管理等待线程</li><li>支持公平锁&#x2F;非公平锁</li></ul><hr><h2 id="8-公平锁和非公平锁区别"><a href="#8-公平锁和非公平锁区别" class="headerlink" title="8. 公平锁和非公平锁区别"></a><strong>8. 公平锁和非公平锁区别</strong></h2><table><thead><tr><th>特性</th><th>公平锁</th><th>非公平锁</th></tr></thead><tbody><tr><td>加锁顺序</td><td>FIFO</td><td>不保证</td></tr><tr><td>性能</td><td>低</td><td>高（线程争抢）</td></tr><tr><td>场景</td><td>避免饥饿</td><td>高性能锁场景</td></tr></tbody></table><hr><h2 id="9-乐观锁和悲观锁区别"><a href="#9-乐观锁和悲观锁区别" class="headerlink" title="9. 乐观锁和悲观锁区别"></a><strong>9. 乐观锁和悲观锁区别</strong></h2><ul><li><strong>悲观锁</strong>：假设会发生冲突，直接加锁（如 synchronized &#x2F; ReentrantLock）</li><li><strong>乐观锁</strong>：假设冲突少，使用 CAS（如 Atomic 类）</li></ul><hr><h2 id="10-AQS-原理"><a href="#10-AQS-原理" class="headerlink" title="10. AQS 原理"></a><strong>10. AQS 原理</strong></h2><ul><li><strong>核心</strong>：state + CLH 队列</li><li><strong>特性</strong>：<ul><li>独占模式 &#x2F; 共享模式</li><li>基于 FIFO 队列管理等待线程</li></ul></li><li><strong>应用</strong>：<ul><li>ReentrantLock、Semaphore、CountDownLatch、FutureTask</li></ul></li></ul><hr><h2 id="11-CountDownLatch-和-CyclicBarrier-区别"><a href="#11-CountDownLatch-和-CyclicBarrier-区别" class="headerlink" title="11. CountDownLatch 和 CyclicBarrier 区别"></a><strong>11. CountDownLatch 和 CyclicBarrier 区别</strong></h2><table><thead><tr><th>特性</th><th>CountDownLatch</th><th>CyclicBarrier</th></tr></thead><tbody><tr><td>使用次数</td><td>一次性</td><td>可重复使用</td></tr><tr><td>功能</td><td>等待线程完成</td><td>等待线程到达同一点</td></tr><tr><td>场景</td><td>线程结束同步</td><td>多线程并行分段</td></tr></tbody></table><hr><h2 id="12-Semaphore-的实现原理"><a href="#12-Semaphore-的实现原理" class="headerlink" title="12. Semaphore 的实现原理"></a><strong>12. Semaphore 的实现原理</strong></h2><ul><li>控制并发线程数量</li><li>基于 AQS 的共享锁</li><li>acquire() 获取许可，release() 释放许可</li></ul><hr><h2 id="13-Exchanger-的使用场景"><a href="#13-Exchanger-的使用场景" class="headerlink" title="13. Exchanger 的使用场景"></a><strong>13. Exchanger 的使用场景</strong></h2><ul><li>两个线程交换数据</li><li>典型场景：生产者-消费者线程交换缓冲区</li></ul><hr><h2 id="14-ForkJoinPool-的原理"><a href="#14-ForkJoinPool-的原理" class="headerlink" title="14. ForkJoinPool 的原理"></a><strong>14. ForkJoinPool 的原理</strong></h2><ul><li><strong>工作窃取算法</strong>：<ul><li>空闲线程从其他线程队列中窃取任务</li></ul></li><li>适合 <strong>递归任务</strong></li><li>通过 <strong>ForkJoinTask</strong> 递归拆分计算</li></ul><hr><h2 id="15-CAS-操作的底层实现"><a href="#15-CAS-操作的底层实现" class="headerlink" title="15. CAS 操作的底层实现"></a><strong>15. CAS 操作的底层实现</strong></h2><ul><li>基于 CPU <strong>原子指令（CMPXCHG）</strong></li><li>JVM <code>Unsafe</code> 提供支持</li><li><strong>优点</strong>：无锁、线程安全</li><li><strong>缺点</strong>：ABA 问题</li></ul><hr><h2 id="16-ABA-问题及解决"><a href="#16-ABA-问题及解决" class="headerlink" title="16. ABA 问题及解决"></a><strong>16. ABA 问题及解决</strong></h2><ul><li><strong>问题</strong>：值先 A → B → A，CAS 无法判断变化</li><li><strong>解决</strong>：<ul><li>版本号机制（AtomicStampedReference）</li><li>双重检查</li></ul></li></ul><hr><h2 id="17-Atomic-原子类原理"><a href="#17-Atomic-原子类原理" class="headerlink" title="17. Atomic 原子类原理"></a><strong>17. Atomic 原子类原理</strong></h2><ul><li>基于 <strong>CAS + Unsafe + volatile</strong></li><li>实现非阻塞线程安全</li><li>示例：<code>AtomicInteger</code> 使用 <code>compareAndSwapInt</code></li></ul><hr><h2 id="18-BlockingQueue-实现原理"><a href="#18-BlockingQueue-实现原理" class="headerlink" title="18. BlockingQueue 实现原理"></a><strong>18. BlockingQueue 实现原理</strong></h2><ul><li>内部维护 <strong>锁 + 条件队列</strong></li><li>put 阻塞满队列，take 阻塞空队列</li><li>常用实现：<ul><li>ArrayBlockingQueue（数组 + ReentrantLock）</li><li>LinkedBlockingQueue（链表 + ReentrantLock）</li></ul></li></ul><hr><h2 id="19-ConcurrentHashMap-的分段锁机制"><a href="#19-ConcurrentHashMap-的分段锁机制" class="headerlink" title="19. ConcurrentHashMap 的分段锁机制"></a><strong>19. ConcurrentHashMap 的分段锁机制</strong></h2><ul><li>JDK 1.7：<ul><li><strong>Segment[] + synchronized</strong></li></ul></li><li>JDK 1.8：<ul><li><strong>CAS + synchronized 链表 + 红黑树 + Node</strong></li></ul></li><li>支持高并发读写</li></ul><hr><h2 id="20-ConcurrentHashMap-扩容机制"><a href="#20-ConcurrentHashMap-扩容机制" class="headerlink" title="20. ConcurrentHashMap 扩容机制"></a><strong>20. ConcurrentHashMap 扩容机制</strong></h2><ul><li>采用 <strong>分段扩容 + CAS</strong></li><li>链表转红黑树提高查找性能</li><li>扩容过程中使用 <strong>迁移节点</strong></li></ul><hr><h2 id="21-CopyOnWriteArrayList-原理"><a href="#21-CopyOnWriteArrayList-原理" class="headerlink" title="21. CopyOnWriteArrayList 原理"></a><strong>21. CopyOnWriteArrayList 原理</strong></h2><ul><li>写时复制：<ol><li>写操作复制数组</li><li>修改后替换引用</li></ol></li><li>适合读多写少场景</li></ul><hr><h2 id="22-线程池核心参数"><a href="#22-线程池核心参数" class="headerlink" title="22. 线程池核心参数"></a><strong>22. 线程池核心参数</strong></h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程数</td></tr><tr><td>maximumPoolSize</td><td>最大线程数</td></tr><tr><td>keepAliveTime</td><td>非核心线程存活时间</td></tr><tr><td>workQueue</td><td>任务队列</td></tr><tr><td>RejectedExecutionHandler</td><td>拒绝策略</td></tr></tbody></table><hr><h2 id="23-线程池拒绝策略"><a href="#23-线程池拒绝策略" class="headerlink" title="23. 线程池拒绝策略"></a><strong>23. 线程池拒绝策略</strong></h2><ol><li>AbortPolicy（默认，抛异常）</li><li>CallerRunsPolicy（调用线程执行）</li><li>DiscardPolicy（丢弃任务）</li><li>DiscardOldestPolicy（丢弃队列最老任务）</li></ol><hr><h2 id="24-线程池工作流程"><a href="#24-线程池工作流程" class="headerlink" title="24. 线程池工作流程"></a><strong>24. 线程池工作流程</strong></h2><ol><li>提交任务 → 放入队列</li><li>核心线程未满 → 创建线程</li><li>队列满 → 创建非核心线程</li><li>达到最大线程 → 触发拒绝策略</li></ol><hr><h2 id="25-ThreadPoolExecutor-vs-ScheduledThreadPoolExecutor"><a href="#25-ThreadPoolExecutor-vs-ScheduledThreadPoolExecutor" class="headerlink" title="25. ThreadPoolExecutor vs ScheduledThreadPoolExecutor"></a><strong>25. ThreadPoolExecutor vs ScheduledThreadPoolExecutor</strong></h2><table><thead><tr><th>特性</th><th>ThreadPoolExecutor</th><th>ScheduledThreadPoolExecutor</th></tr></thead><tbody><tr><td>功能</td><td>通用线程池</td><td>支持定时 &#x2F; 周期任务</td></tr><tr><td>队列</td><td>BlockingQueue</td><td>DelayQueue</td></tr><tr><td>场景</td><td>并发任务</td><td>定时任务</td></tr></tbody></table><hr><h2 id="26-为什么不建议使用-Executors-创建线程池"><a href="#26-为什么不建议使用-Executors-创建线程池" class="headerlink" title="26. 为什么不建议使用 Executors 创建线程池"></a><strong>26. 为什么不建议使用 Executors 创建线程池</strong></h2><ul><li>Executors 会产生 <strong>无限队列</strong>（如 newCachedThreadPool）</li><li>容易 <strong>OOM &#x2F; 线程数过多</strong></li><li>推荐：手动使用 <strong>ThreadPoolExecutor</strong> 配置核心参数</li></ul><hr><h2 id="27-JMM-内存可见性问题"><a href="#27-JMM-内存可见性问题" class="headerlink" title="27. JMM 内存可见性问题"></a><strong>27. JMM 内存可见性问题</strong></h2><ul><li>多线程访问共享变量，修改不立即可见</li><li><strong>解决方法</strong>：<ul><li><code>volatile</code></li><li><code>synchronized</code> &#x2F; Lock</li></ul></li></ul><hr><h2 id="28-happens-before-规则"><a href="#28-happens-before-规则" class="headerlink" title="28. happens-before 规则"></a><strong>28. happens-before 规则</strong></h2><ul><li><strong>保证操作顺序与可见性</strong></li><li>常见规则：<ol><li><strong>锁的解锁 → 加锁</strong></li><li><strong>volatile 写 → 读</strong></li><li><strong>线程 start() → run()</strong></li><li><strong>线程 join() → 结束</strong></li></ol></li></ul><hr><h2 id="29-死锁产生条件及避免"><a href="#29-死锁产生条件及避免" class="headerlink" title="29. 死锁产生条件及避免"></a><strong>29. 死锁产生条件及避免</strong></h2><ul><li><strong>四个必要条件</strong>：<ol><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ol></li><li><strong>避免方法</strong>：<ul><li>避免循环等待，按顺序加锁</li><li>使用 tryLock + 超时</li><li>使用单一锁</li></ul></li></ul><hr><h2 id="30-常见并发容器及区别"><a href="#30-常见并发容器及区别" class="headerlink" title="30. 常见并发容器及区别"></a><strong>30. 常见并发容器及区别</strong></h2><table><thead><tr><th>容器</th><th>特性</th></tr></thead><tbody><tr><td>ConcurrentHashMap</td><td>高并发读写，分段&#x2F;链表+红黑树</td></tr><tr><td>CopyOnWriteArrayList</td><td>写时复制，读多写少</td></tr><tr><td>ConcurrentLinkedQueue</td><td>非阻塞</td></tr></tbody></table><p>队列，基于 CAS |<br> | BlockingQueue（Array&#x2F;Linked） | 支持阻塞 put&#x2F;take |<br> | ConcurrentSkipListMap | 有序，基于跳表，线程安全 |</p><hr><h2 id="三、JVM-与性能优化（30题）"><a href="#三、JVM-与性能优化（30题）" class="headerlink" title="三、JVM 与性能优化（30题）"></a>三、JVM 与性能优化（30题）</h2><hr><h2 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1. JVM 内存结构"></a><strong>1. JVM 内存结构</strong></h2><ul><li><strong>方法区 &#x2F; 元空间（Metaspace）</strong>：存放类信息、常量、静态变量</li><li><strong>堆（Heap）</strong>：对象实例、GC 管理区</li><li><strong>栈（Stack）</strong>：方法调用、局部变量</li><li><strong>程序计数器（PC）</strong>：记录线程执行地址</li><li><strong>本地方法栈（Native Stack）</strong>：执行 native 方法</li><li><strong>直接内存（Direct Memory）</strong>：堆外内存，用于 NIO</li></ul><hr><h2 id="2-堆和栈的区别"><a href="#2-堆和栈的区别" class="headerlink" title="2. 堆和栈的区别"></a><strong>2. 堆和栈的区别</strong></h2><table><thead><tr><th>特性</th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td>存储内容</td><td>对象实例</td><td>方法调用帧、局部变量</td></tr><tr><td>生命周期</td><td>GC 管理</td><td>随方法结束释放</td></tr><tr><td>线程共享</td><td>是</td><td>否（线程私有）</td></tr><tr><td>访问速度</td><td>较慢</td><td>快</td></tr><tr><td>内存大小</td><td>大</td><td>小</td></tr></tbody></table><hr><h2 id="3-新生代、老年代、永久代（元空间）的区别"><a href="#3-新生代、老年代、永久代（元空间）的区别" class="headerlink" title="3. 新生代、老年代、永久代（元空间）的区别"></a><strong>3. 新生代、老年代、永久代（元空间）的区别</strong></h2><ul><li><strong>新生代</strong>（Young Generation）：<ul><li>存放新创建对象</li><li>分为 Eden + 2 个 Survivor 区</li><li>Minor GC 主要发生在此</li></ul></li><li><strong>老年代</strong>（Old&#x2F;Tenured Generation）：<ul><li>长寿命对象</li><li>Full GC 主要作用区域</li></ul></li><li><strong>永久代 &#x2F; 元空间</strong>：<ul><li>存放类元数据</li><li>Java 8+ 使用 Metaspace（Native 内存）</li></ul></li></ul><hr><h2 id="4-对象的创建过程"><a href="#4-对象的创建过程" class="headerlink" title="4. 对象的创建过程"></a><strong>4. 对象的创建过程</strong></h2><ol><li><strong>类加载检查</strong></li><li><strong>分配内存</strong>：<ul><li>堆上分配对象空间（TLAB&#x2F;大对象直接分配）</li></ul></li><li><strong>初始化零值</strong></li><li><strong>构造器初始化</strong></li><li><strong>引用赋值</strong></li></ol><hr><h2 id="5-对象的内存分配策略"><a href="#5-对象的内存分配策略" class="headerlink" title="5. 对象的内存分配策略"></a><strong>5. 对象的内存分配策略</strong></h2><ul><li><strong>年轻代分配</strong>：TLAB（Thread Local Allocation Buffer）</li><li><strong>大对象直接进入老年代</strong>（如数组 &gt; 1MB）</li><li><strong>长期存活对象晋升到老年代</strong></li><li><strong>栈上分配</strong>：通过逃逸分析优化</li></ul><hr><h2 id="6-GC-Roots"><a href="#6-GC-Roots" class="headerlink" title="6. GC Roots"></a><strong>6. GC Roots</strong></h2><ul><li><strong>常见类型</strong>：<ul><li>栈帧中的引用变量</li><li>方法区静态变量</li><li>常量引用</li><li>本地方法栈引用</li></ul></li></ul><hr><h2 id="7-垃圾回收算法"><a href="#7-垃圾回收算法" class="headerlink" title="7. 垃圾回收算法"></a><strong>7. 垃圾回收算法</strong></h2><ul><li><strong>引用计数</strong>（不可解决循环引用）</li><li><strong>可达性分析</strong>（GC Roots）</li><li><strong>具体回收算法</strong>：<ul><li>标记-清除</li><li>标记-整理</li><li>复制算法</li><li>分代回收</li></ul></li></ul><hr><h2 id="8-CMS-垃圾回收器流程"><a href="#8-CMS-垃圾回收器流程" class="headerlink" title="8. CMS 垃圾回收器流程"></a><strong>8. CMS 垃圾回收器流程</strong></h2><ol><li>初始标记（Stop-The-World）</li><li>并发标记（标记可回收对象）</li><li>并发预清理</li><li>重新标记（Stop-The-World）</li><li>并发清理（回收老年代）</li></ol><ul><li><strong>特点</strong>：低停顿，但有浮动垃圾和内存碎片问题</li></ul><hr><h2 id="9-G1-垃圾回收器原理"><a href="#9-G1-垃圾回收器原理" class="headerlink" title="9. G1 垃圾回收器原理"></a><strong>9. G1 垃圾回收器原理</strong></h2><ul><li><strong>Region（分区）管理堆</strong></li><li><strong>分代+并行+增量收集</strong></li><li><strong>垃圾回收策略</strong>：<ul><li>优先回收回收成本低的 Region</li><li>并发标记 + 并行清理</li></ul></li><li><strong>目标</strong>：控制停顿时间</li><li><strong>优势</strong>：无碎片、可预测停顿</li></ul><hr><h2 id="10-ZGC-和-Shenandoah-特点"><a href="#10-ZGC-和-Shenandoah-特点" class="headerlink" title="10. ZGC 和 Shenandoah 特点"></a><strong>10. ZGC 和 Shenandoah 特点</strong></h2><ul><li><strong>低延迟 GC</strong>，停顿时间 &lt; 10ms</li><li><strong>并发标记 + 并发压缩</strong></li><li><strong>内存可扩展性好</strong></li><li>支持大内存 (&gt;100GB)</li><li>面试常问区别：ZGC 使用 <strong>Load Barrier</strong>，Shenandoah 使用 <strong>Region Pinning</strong></li></ul><hr><h2 id="11-Minor-GC-与-Full-GC-区别"><a href="#11-Minor-GC-与-Full-GC-区别" class="headerlink" title="11. Minor GC 与 Full GC 区别"></a><strong>11. Minor GC 与 Full GC 区别</strong></h2><table><thead><tr><th>特性</th><th>Minor GC</th><th>Full GC</th></tr></thead><tbody><tr><td>触发区域</td><td>新生代</td><td>整个堆（包括老年代）</td></tr><tr><td>停顿时间</td><td>短</td><td>长</td></tr><tr><td>频率</td><td>高</td><td>低</td></tr><tr><td>GC 类型</td><td>复制算法</td><td>标记-整理 &#x2F; CMS &#x2F; G1</td></tr></tbody></table><hr><h2 id="12-OOM-常见类型及排查"><a href="#12-OOM-常见类型及排查" class="headerlink" title="12. OOM 常见类型及排查"></a><strong>12. OOM 常见类型及排查</strong></h2><ul><li><strong>Java Heap Space</strong>：堆内存不足</li><li><strong>GC Overhead Limit</strong>：GC 花费过多时间</li><li><strong>Metaspace</strong>：类元信息过多</li><li><strong>Direct Memory</strong>：堆外内存溢出</li><li><strong>排查工具</strong>：<ul><li>jmap、jstack、VisualVM、MAT</li></ul></li></ul><hr><h2 id="13-类加载器分类"><a href="#13-类加载器分类" class="headerlink" title="13. 类加载器分类"></a><strong>13. 类加载器分类</strong></h2><ul><li>Bootstrap（根类加载器）</li><li>Extension（扩展类加载器）</li><li>Application（系统类加载器）</li><li>自定义 ClassLoader</li></ul><hr><h2 id="14-双亲委派模型破坏场景"><a href="#14-双亲委派模型破坏场景" class="headerlink" title="14. 双亲委派模型破坏场景"></a><strong>14. 双亲委派模型破坏场景</strong></h2><ul><li>动态加载不同版本类</li><li>热部署、插件化框架（Tomcat、OSGi）</li></ul><hr><h2 id="15-JVM-常见参数调优"><a href="#15-JVM-常见参数调优" class="headerlink" title="15. JVM 常见参数调优"></a><strong>15. JVM 常见参数调优</strong></h2><ul><li><strong>堆大小</strong>：<code>-Xms -Xmx</code></li><li><strong>新生代比例</strong>：<code>-XX:NewRatio</code></li><li><strong>GC 类型</strong>：<code>-XX:+UseG1GC</code></li><li><strong>线程栈大小</strong>：<code>-Xss</code></li><li><strong>Metaspace</strong>：<code>-XX:MetaspaceSize</code></li></ul><hr><h2 id="16-内存泄漏-vs-内存溢出"><a href="#16-内存泄漏-vs-内存溢出" class="headerlink" title="16. 内存泄漏 vs 内存溢出"></a><strong>16. 内存泄漏 vs 内存溢出</strong></h2><ul><li><strong>内存泄漏</strong>：对象不再使用，但仍有引用</li><li><strong>内存溢出（OOM）</strong>：申请内存失败</li></ul><hr><h2 id="17-逃逸分析"><a href="#17-逃逸分析" class="headerlink" title="17. 逃逸分析"></a><strong>17. 逃逸分析</strong></h2><ul><li><strong>作用</strong>：<ul><li>分析对象作用域</li><li>栈上分配、锁消除、同步优化</li></ul></li><li><strong>JVM 优化</strong>：<ul><li>栈上分配（不入堆）</li><li>去掉无用锁（锁消除）</li></ul></li></ul><hr><h2 id="18-方法内联"><a href="#18-方法内联" class="headerlink" title="18. 方法内联"></a><strong>18. 方法内联</strong></h2><ul><li>JIT 优化</li><li>小方法直接替换调用，减少方法调用开销</li><li>增加 CPU 指令局部性，提高性能</li></ul><hr><h2 id="19-JIT-编译器优化"><a href="#19-JIT-编译器优化" class="headerlink" title="19. JIT 编译器优化"></a><strong>19. JIT 编译器优化</strong></h2><ul><li>方法内联</li><li>循环展开</li><li>逃逸分析</li><li>常量折叠</li><li>逃逸分析 + 栈上分配</li></ul><hr><h2 id="20-Safepoint-机制"><a href="#20-Safepoint-机制" class="headerlink" title="20. Safepoint 机制"></a><strong>20. Safepoint 机制</strong></h2><ul><li>所有线程暂停，进行 GC 或其他全局操作</li><li>JVM 可安全修改线程状态</li></ul><hr><h2 id="21-Stop-The-World-STW"><a href="#21-Stop-The-World-STW" class="headerlink" title="21. Stop The World (STW)"></a><strong>21. Stop The World (STW)</strong></h2><ul><li><strong>定义</strong>：暂停所有用户线程进行 GC 或其他 JVM 内部操作</li><li><strong>影响</strong>：应用停顿，低延迟场景需控制 STW 时间</li></ul><hr><h2 id="22-Finalize-方法问题"><a href="#22-Finalize-方法问题" class="headerlink" title="22. Finalize 方法问题"></a><strong>22. Finalize 方法问题</strong></h2><ul><li>不确定执行时间</li><li>性能开销大</li><li>可导致对象“复活”，增加内存压力</li><li><strong>替代方案</strong>：try-with-resources &#x2F; Cleaner</li></ul><hr><h2 id="23-JVM-如何判断对象可回收"><a href="#23-JVM-如何判断对象可回收" class="headerlink" title="23. JVM 如何判断对象可回收"></a><strong>23. JVM 如何判断对象可回收</strong></h2><ul><li><strong>可达性分析</strong>：从 GC Roots 出发，未被可达的对象可回收</li></ul><hr><h2 id="24-TLAB（Thread-Local-Allocation-Buffer）作用"><a href="#24-TLAB（Thread-Local-Allocation-Buffer）作用" class="headerlink" title="24. TLAB（Thread Local Allocation Buffer）作用"></a><strong>24. TLAB（Thread Local Allocation Buffer）作用</strong></h2><ul><li>每个线程独享一块 Eden 内存</li><li><strong>作用</strong>：<ul><li>减少多线程竞争</li><li>提高对象分配效率</li></ul></li></ul><hr><h2 id="25-Direct-Memory-为什么会-OOM"><a href="#25-Direct-Memory-为什么会-OOM" class="headerlink" title="25. Direct Memory 为什么会 OOM"></a><strong>25. Direct Memory 为什么会 OOM</strong></h2><ul><li>堆外内存不足</li><li>NIO Buffer 使用 <code>Unsafe</code> 分配</li><li>不受堆内存限制，但 JVM 无法直接管理</li></ul><hr><h2 id="26-Metaspace-作用"><a href="#26-Metaspace-作用" class="headerlink" title="26. Metaspace 作用"></a><strong>26. Metaspace 作用</strong></h2><ul><li>存放类元数据</li><li>Java 8+ 替代永久代</li><li>可以通过 <code>-XX:MetaspaceSize</code> 限制</li></ul><hr><h2 id="27-Full-GC-触发条件"><a href="#27-Full-GC-触发条件" class="headerlink" title="27. Full GC 触发条件"></a><strong>27. Full GC 触发条件</strong></h2><ul><li>老年代空间不足</li><li>永久代 &#x2F; 元空间不足</li><li>System.gc() 调用</li><li>内存分配失败</li></ul><hr><h2 id="28-查看-JVM-内存使用情况"><a href="#28-查看-JVM-内存使用情况" class="headerlink" title="28. 查看 JVM 内存使用情况"></a><strong>28. 查看 JVM 内存使用情况</strong></h2><ul><li><code>jstat -gc &lt;pid&gt;</code></li><li><code>jmap -heap &lt;pid&gt;</code></li><li><code>VisualVM</code> &#x2F; <code>JConsole</code></li><li><code>MAT</code> 分析 heap dump</li></ul><hr><h2 id="29-Arthas-常用命令"><a href="#29-Arthas-常用命令" class="headerlink" title="29. Arthas 常用命令"></a><strong>29. Arthas 常用命令</strong></h2><ul><li><code>dashboard</code>：系统指标</li><li><code>thread</code>：线程状态</li><li><code>heapdump</code>：堆转储</li><li><code>monitor</code>：方法耗时</li><li><code>watch</code>：方法参数&#x2F;返回值</li><li><code>jad</code>：反编译类</li></ul><hr><h2 id="30-JVM-调优常见面试题"><a href="#30-JVM-调优常见面试题" class="headerlink" title="30. JVM 调优常见面试题"></a><strong>30. JVM 调优常见面试题</strong></h2><ul><li>堆大小设置策略</li><li>新生代&#x2F;老年代比例</li><li>GC 选择（G1 &#x2F; CMS &#x2F; Parallel）</li><li>TLAB 与对象分配优化</li><li>Full GC 触发条件</li><li>内存泄漏排查与 MAT 使用</li></ul><hr><h2 id="四、Spring-Spring-Boot（30题）"><a href="#四、Spring-Spring-Boot（30题）" class="headerlink" title="四、Spring &amp; Spring Boot（30题）"></a>四、Spring &amp; Spring Boot（30题）</h2><h3 id="1-Spring-的-IoC-容器原理？"><a href="#1-Spring-的-IoC-容器原理？" class="headerlink" title="1. Spring 的 IoC 容器原理？"></a>1. Spring 的 IoC 容器原理？</h3><p><strong>核心回答：</strong><br> IoC（控制反转）是通过容器管理对象创建和依赖注入，开发者不需要手动 new 对象，而是由 Spring 容器统一管理。</p><p><strong>深入解析：</strong></p><ul><li>IoC 容器的核心是 <strong>BeanFactory</strong> 和 <strong>ApplicationContext</strong>。</li><li>工作流程：<ol><li><strong>配置解析</strong>：读取 XML &#x2F; 注解 &#x2F; JavaConfig；</li><li><strong>BeanDefinition</strong>：将配置转成 BeanDefinition；</li><li><strong>Bean 实例化</strong>：通过反射或 CGLIB 创建对象；</li><li><strong>依赖注入</strong>：根据构造方法 &#x2F; Setter &#x2F; @Autowired 注入依赖；</li><li><strong>初始化回调</strong>：执行 BeanPostProcessor &#x2F; InitializingBean；</li><li><strong>放入单例池</strong>：容器保存对象供全局使用。</li></ol></li></ul><p><strong>延伸思考：</strong></p><ul><li>IoC 是 <strong>依赖查找（DL）</strong> 和 <strong>依赖注入（DI）</strong> 的结合。</li><li>面试可能追问：Spring 如何实现延迟加载？（@Lazy + 单例池管理）</li><li>实战：配置文件少时用 XML，大项目推荐 <strong>JavaConfig + 注解</strong>。</li></ul><hr><h3 id="2-Bean-的生命周期？"><a href="#2-Bean-的生命周期？" class="headerlink" title="2. Bean 的生命周期？"></a>2. Bean 的生命周期？</h3><p><strong>核心回答：</strong><br> 创建 → 属性注入 → 初始化 → 使用 → 销毁。</p><p><strong>深入解析：</strong></p><ol><li><strong>实例化</strong>：通过反射创建对象；</li><li><strong>依赖注入</strong>：注入属性；</li><li><strong>Aware 接口回调</strong>：如 BeanNameAware、ApplicationContextAware；</li><li><strong>BeanPostProcessor 前置处理</strong>：比如 @Autowired 的处理；</li><li><strong>初始化方法</strong>：@PostConstruct &#x2F; InitializingBean.afterPropertiesSet() &#x2F; init-method；</li><li><strong>BeanPostProcessor 后置处理</strong>；</li><li><strong>就绪使用</strong>；</li><li><strong>销毁回调</strong>：@PreDestroy &#x2F; DisposableBean.destroy() &#x2F; destroy-method。</li></ol><p><strong>延伸思考：</strong></p><ul><li>面试常追问：Spring 容器关闭时，单例 Bean 会被销毁吗？（会，调用 destroy 回调）。</li><li>原型作用域 Bean 不会被销毁，需要开发者手动管理。</li></ul><hr><h3 id="3-BeanFactory-和-ApplicationContext-的区别？"><a href="#3-BeanFactory-和-ApplicationContext-的区别？" class="headerlink" title="3. BeanFactory 和 ApplicationContext 的区别？"></a>3. BeanFactory 和 ApplicationContext 的区别？</h3><p><strong>核心回答：</strong></p><ul><li><strong>BeanFactory</strong>：最基础 IoC 容器，懒加载，轻量级；</li><li><strong>ApplicationContext</strong>：继承 BeanFactory，支持 AOP、国际化、事件机制、自动装配，默认预实例化。</li></ul><p><strong>深入解析：</strong></p><ul><li>BeanFactory：面向低资源环境，功能有限；</li><li>ApplicationContext：常用实现有 ClassPathXmlApplicationContext、AnnotationConfigApplicationContext。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试常问：为什么 ApplicationContext 默认是预加载？（减少运行时性能开销，启动时完成依赖检查）。</li></ul><hr><h3 id="4-单例-Bean-如何保证线程安全？"><a href="#4-单例-Bean-如何保证线程安全？" class="headerlink" title="4. 单例 Bean 如何保证线程安全？"></a>4. 单例 Bean 如何保证线程安全？</h3><p><strong>核心回答：</strong><br> Spring <strong>不保证单例 Bean 的线程安全</strong>，需要开发者在代码中保证。</p><p><strong>深入解析：</strong></p><ul><li>IoC 容器中的单例 Bean 是 <strong>多线程共享的</strong>；</li><li>常见的线程安全措施：<ol><li><strong>无状态设计</strong>（推荐）；</li><li><strong>使用 ThreadLocal 保存状态</strong>；</li><li><strong>方法内部使用局部变量</strong>；</li><li><strong>必要时加锁（synchronized &#x2F; Lock）</strong>。</li></ol></li></ul><p><strong>延伸思考：</strong></p><ul><li>面试陷阱：Spring 单例 Bean 是不是线程安全的？答：不是。</li><li>例子：Controller、Service 通常是无状态的，可以安全单例。</li></ul><hr><h3 id="5-Spring-AOP-的实现原理？"><a href="#5-Spring-AOP-的实现原理？" class="headerlink" title="5. Spring AOP 的实现原理？"></a>5. Spring AOP 的实现原理？</h3><p><strong>核心回答：</strong><br> AOP（面向切面编程）通过 <strong>动态代理</strong> 实现，在方法执行前后插入增强逻辑。</p><p><strong>深入解析：</strong></p><ul><li>实现方式：<ol><li><strong>JDK 动态代理</strong>：基于接口；</li><li><strong>CGLIB 代理</strong>：基于子类字节码增强。</li></ol></li><li>AOP 核心组件：<ul><li>JoinPoint（连接点）、Pointcut（切点）、Advice（通知）、Weaving（织入）、Proxy（代理对象）。</li></ul></li><li>AOP 流程：调用目标方法 → 代理对象拦截 → 执行切面逻辑 → 继续执行原方法。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官可能问：Spring 默认用哪种代理？<ul><li>如果有接口 → JDK 动态代理；</li><li>没有接口 → CGLIB。</li></ul></li><li>JDK 代理只能基于接口，CGLIB 可以基于类。</li></ul><hr><h3 id="6-JDK-动态代理和-CGLIB-的区别？"><a href="#6-JDK-动态代理和-CGLIB-的区别？" class="headerlink" title="6. JDK 动态代理和 CGLIB 的区别？"></a>6. JDK 动态代理和 CGLIB 的区别？</h3><p><strong>核心回答：</strong></p><ul><li>JDK：基于接口，生成实现类；</li><li>CGLIB：基于继承，生成子类字节码。</li></ul><p><strong>深入解析：</strong></p><ul><li>JDK 动态代理：利用 <code>Proxy.newProxyInstance</code>，性能较高；</li><li>CGLIB：利用 ASM 字节码操作生成子类，性能稍慢，但支持类代理；</li><li>Spring 默认优先使用 JDK，如果没有接口再用 CGLIB。</li></ul><p><strong>延伸思考：</strong></p><ul><li>限制：CGLIB 无法代理 <code>final</code> 类 &#x2F; <code>final</code> 方法；</li><li>Spring Boot 可通过 <code>spring.aop.proxy-target-class=true</code> 强制使用 CGLIB。</li></ul><hr><h3 id="7-Spring-事务的传播机制？"><a href="#7-Spring-事务的传播机制？" class="headerlink" title="7. Spring 事务的传播机制？"></a>7. Spring 事务的传播机制？</h3><p><strong>核心回答：</strong><br> 事务传播机制定义了方法在调用时事务的边界，常见类型：</p><ul><li>REQUIRED（默认）、REQUIRES_NEW、NESTED、SUPPORTS、NOT_SUPPORTED、MANDATORY、NEVER。</li></ul><p><strong>深入解析：</strong></p><ul><li><strong>REQUIRED</strong>：有事务就加入，没有就新建；</li><li><strong>REQUIRES_NEW</strong>：挂起当前事务，新建一个；</li><li><strong>NESTED</strong>：嵌套事务（依赖保存点 rollback）；</li><li><strong>SUPPORTS</strong>：有就用，没有就不用；</li><li><strong>NOT_SUPPORTED</strong>：挂起事务，以非事务运行；</li><li><strong>MANDATORY</strong>：必须在事务中调用；</li><li><strong>NEVER</strong>：必须在非事务中运行。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试陷阱：嵌套事务和新事务的区别？<ul><li>嵌套事务依赖外层事务回滚；</li><li>新事务互相独立。</li></ul></li></ul><hr><h3 id="8-Spring-事务的隔离级别？"><a href="#8-Spring-事务的隔离级别？" class="headerlink" title="8. Spring 事务的隔离级别？"></a>8. Spring 事务的隔离级别？</h3><p><strong>核心回答：</strong><br> 事务隔离级别解决并发问题，Spring 支持数据库的 5 种隔离级别：</p><ul><li>DEFAULT（数据库默认）</li><li>READ_UNCOMMITTED（可能脏读）</li><li>READ_COMMITTED（防脏读）</li><li>REPEATABLE_READ（防脏读、不可重复读）</li><li>SERIALIZABLE（防脏读、不可重复读、幻读）</li></ul><p><strong>深入解析：</strong></p><ul><li>InnoDB 默认是 <strong>REPEATABLE_READ</strong>；</li><li>Oracle 默认是 <strong>READ_COMMITTED</strong>。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试可能追问：MySQL 的 REPEATABLE_READ 如何避免幻读？（MVCC + 间隙锁）。</li></ul><hr><h3 id="9-Transactional-的实现原理？"><a href="#9-Transactional-的实现原理？" class="headerlink" title="9. @Transactional 的实现原理？"></a>9. @Transactional 的实现原理？</h3><p><strong>核心回答：</strong><br> @Transactional 通过 <strong>AOP 代理</strong>，在方法执行前后控制事务。</p><p><strong>深入解析：</strong></p><ul><li>Spring 容器解析 @Transactional → 生成代理 → 在代理方法里执行事务增强逻辑：<ol><li>获取事务管理器；</li><li>开启事务；</li><li>执行目标方法；</li><li>异常回滚 &#x2F; 正常提交；</li><li>清理资源。</li></ol></li></ul><p><strong>延伸思考：</strong></p><ul><li>默认只回滚 RuntimeException 和 Error，检查异常需要 <code>rollbackFor</code>。</li><li>面试常问：为什么 @Transactional 方法用 <code>private</code> 修饰无效？<br> → 因为 AOP 代理无法拦截 private 方法。</li></ul><hr><h3 id="10-循环依赖如何解决？"><a href="#10-循环依赖如何解决？" class="headerlink" title="10. 循环依赖如何解决？"></a>10. 循环依赖如何解决？</h3><p><strong>核心回答：</strong><br> Spring 通过 <strong>三级缓存</strong> 解决单例 Bean 的循环依赖。</p><p><strong>深入解析：</strong></p><ul><li>三级缓存：<ol><li>singletonObjects（成品对象）</li><li>earlySingletonObjects（提前暴露的对象，半成品）</li><li>singletonFactories（对象工厂，提供代理对象）</li></ol></li><li>流程：A → 依赖 B → B 依赖 A → 提前暴露 A 的引用给 B → 依赖注入成功。</li></ul><p><strong>延伸思考：</strong></p><ul><li>只能解决 <strong>单例 + setter 注入</strong> 的循环依赖；</li><li><strong>构造器注入循环依赖</strong> 无法解决，会抛出异常。</li></ul><h3 id="11-Spring-的三级缓存解决了什么问题？"><a href="#11-Spring-的三级缓存解决了什么问题？" class="headerlink" title="11. Spring 的三级缓存解决了什么问题？"></a>11. Spring 的三级缓存解决了什么问题？</h3><p><strong>核心回答：</strong><br> 解决 <strong>单例 Bean 的循环依赖</strong>，保证在创建过程中能提前暴露代理对象。</p><p><strong>深入解析：</strong></p><ul><li>Spring 单例池维护了 <strong>三级缓存</strong>：<ol><li><code>singletonObjects</code> → 一级缓存（完全初始化的单例）；</li><li><code>earlySingletonObjects</code> → 二级缓存（提前暴露的半成品对象）；</li><li><code>singletonFactories</code> → 三级缓存（对象工厂，通常生成代理对象）。</li></ol></li><li>流程：<ul><li>当 A 依赖 B，B 又依赖 A 时：<ol><li>创建 A → 放入三级缓存；</li><li>B 依赖 A 时，先从三级缓存拿到 A 的工厂，暴露提前代理对象 → 放入二级缓存；</li><li>等 A 完成初始化后，替换为一级缓存。</li></ol></li></ul></li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官可能追问：为什么要三级缓存，不是二级就够了吗？<br> → 因为 AOP 代理对象需要通过工厂提前暴露，不能只放半成品对象。</li><li>只支持 <strong>setter 注入的循环依赖</strong>，不支持 <strong>构造函数循环依赖</strong>。</li></ul><hr><h3 id="12-Spring-MVC-的工作流程？"><a href="#12-Spring-MVC-的工作流程？" class="headerlink" title="12. Spring MVC 的工作流程？"></a>12. Spring MVC 的工作流程？</h3><p><strong>核心回答：</strong><br> 请求 → DispatcherServlet → HandlerMapping → HandlerAdapter → Controller → ViewResolver → 响应。</p><p><strong>深入解析：</strong></p><ol><li>用户请求到达 DispatcherServlet；</li><li>DispatcherServlet 调用 HandlerMapping 寻找处理器；</li><li>通过 HandlerAdapter 调用具体 Controller；</li><li>Controller 执行业务逻辑，返回 ModelAndView；</li><li>ViewResolver 解析视图；</li><li>DispatcherServlet 渲染并返回响应给客户端。</li></ol><p><strong>延伸思考：</strong></p><ul><li>面试官常问：DispatcherServlet 是单例还是多例？（单例，线程安全依赖于无状态设计）。</li><li>实战：可以用 <code>@RestController</code> 直接返回 JSON，省略 ViewResolver。</li></ul><hr><h3 id="13-DispatcherServlet-的作用？"><a href="#13-DispatcherServlet-的作用？" class="headerlink" title="13. DispatcherServlet 的作用？"></a>13. DispatcherServlet 的作用？</h3><p><strong>核心回答：</strong><br> Spring MVC 的 <strong>前端控制器</strong>，负责请求分发和响应渲染。</p><p><strong>深入解析：</strong></p><ul><li>职责：<ol><li>拦截请求；</li><li>调用 HandlerMapping 找到 Controller；</li><li>调用 HandlerAdapter 执行 Controller；</li><li>调用 ViewResolver 渲染视图；</li><li>返回响应。</li></ol></li><li>核心思想：<strong>统一入口，集中控制</strong>。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试追问：DispatcherServlet 在 Spring Boot 中怎么注册的？<br> → 自动配置类 <code>DispatcherServletAutoConfiguration</code> 注册。</li></ul><hr><h3 id="14-Spring-Boot-的自动装配原理？"><a href="#14-Spring-Boot-的自动装配原理？" class="headerlink" title="14. Spring Boot 的自动装配原理？"></a>14. Spring Boot 的自动装配原理？</h3><p><strong>核心回答：</strong><br> 基于 <code>@EnableAutoConfiguration</code> + <code>SpringFactoriesLoader</code> 实现，根据 classpath 条件加载配置类。</p><p><strong>深入解析：</strong></p><ol><li><code>@SpringBootApplication</code> → 启用 <code>@EnableAutoConfiguration</code>；</li><li><code>SpringFactoriesLoader</code> 读取 <code>META-INF/spring.factories</code> 文件；</li><li>根据 <code>@Conditional</code> 注解判断是否加载；</li><li>把匹配的 Bean 注册到容器。</li></ol><p><strong>延伸思考：</strong></p><ul><li>面试官可能追问：怎么禁用某个自动配置？<br> → <code>@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</code></li><li>或者在 <code>application.yml</code> 中配置 <code>spring.autoconfigure.exclude</code>。</li></ul><hr><h3 id="15-Spring-Boot-Starter-的机制？"><a href="#15-Spring-Boot-Starter-的机制？" class="headerlink" title="15. Spring Boot Starter 的机制？"></a>15. Spring Boot Starter 的机制？</h3><p><strong>核心回答：</strong><br> Starter 是一组 <strong>依赖封装 + 自动配置</strong>，简化第三方库集成。</p><p><strong>深入解析：</strong></p><ul><li>命名规范：<code>spring-boot-starter-xxx</code>；</li><li>依赖 Starter → 自动引入必要依赖 + 自动装配类；</li><li>例子：<code>spring-boot-starter-web</code> → 引入 Spring MVC + Tomcat + Jackson，并自动配置 DispatcherServlet。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官常问：怎么写一个自定义 Starter？<ol><li>提供 <code>AutoConfiguration</code> 类；</li><li>在 <code>META-INF/spring.factories</code> 注册；</li><li>打包发布。</li></ol></li></ul><hr><h3 id="16-ConfigurationProperties-和-Value-的区别？"><a href="#16-ConfigurationProperties-和-Value-的区别？" class="headerlink" title="16. @ConfigurationProperties 和 @Value 的区别？"></a>16. @ConfigurationProperties 和 @Value 的区别？</h3><p><strong>核心回答：</strong></p><ul><li><code>@Value</code>：单个属性注入；</li><li><code>@ConfigurationProperties</code>：批量绑定配置，支持类型安全。</li></ul><p><strong>深入解析：</strong></p><ul><li><code>@Value(&quot;$&#123;key&#125;&quot;)</code>：只能注入单个值；</li><li><code>@ConfigurationProperties(prefix = &quot;xxx&quot;)</code>：把配置文件中 <code>xxx.*</code> 映射到 JavaBean。</li><li><code>@ConfigurationProperties</code> 更适合复杂配置对象。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官可能追问：推荐用哪个？<br> → <code>@ConfigurationProperties</code>，因为支持校验（<code>@Validated</code>）、IDE 提示。</li><li>实战：数据库配置常用 <code>@ConfigurationProperties</code>。</li></ul><hr><h3 id="17-Spring-Boot-如何实现热部署？"><a href="#17-Spring-Boot-如何实现热部署？" class="headerlink" title="17. Spring Boot 如何实现热部署？"></a>17. Spring Boot 如何实现热部署？</h3><p><strong>核心回答：</strong><br> 主要通过 <strong>Spring Boot DevTools</strong> 或 <strong>JRebel</strong>。</p><p><strong>深入解析：</strong></p><ul><li>DevTools：监控 classpath 文件变化，触发 SpringContext 重启；</li><li>JRebel：字节码增强，做到无感知热替换；</li><li>IDE（IntelliJ IDEA &#x2F; Eclipse）也支持 Build 自动 reload。</li></ul><p><strong>延伸思考：</strong></p><ul><li>DevTools 适合开发，JRebel 更强大但收费。</li><li>生产环境不建议热部署，而是灰度发布&#x2F;滚动更新。</li></ul><hr><h3 id="18-Spring-Boot-如何处理配置文件？"><a href="#18-Spring-Boot-如何处理配置文件？" class="headerlink" title="18. Spring Boot 如何处理配置文件？"></a>18. Spring Boot 如何处理配置文件？</h3><p><strong>核心回答：</strong><br> Spring Boot 读取 <code>application.yml/properties</code>，并支持多环境和优先级加载。</p><p><strong>深入解析：</strong></p><ul><li>默认加载顺序：<ol><li>命令行参数；</li><li><code>application.properties</code> &#x2F; <code>application.yml</code>；</li><li>外部配置文件（config 目录）；</li><li>默认配置。</li></ol></li><li>支持多环境：<code>application-dev.yml</code>、<code>application-prod.yml</code>，通过 <code>spring.profiles.active=dev</code> 切换。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试官可能问：优先级谁最高？<br> → 命令行参数。</li><li>实战：生产环境常用外部化配置（如 <code>--spring.config.location</code>）。</li></ul><hr><h3 id="19-Conditional-注解的作用？"><a href="#19-Conditional-注解的作用？" class="headerlink" title="19. @Conditional 注解的作用？"></a>19. @Conditional 注解的作用？</h3><p><strong>核心回答：</strong><br> 用于 <strong>条件装配</strong>，根据环境 &#x2F; 配置 &#x2F; Bean 是否存在决定是否加载 Bean。</p><p><strong>深入解析：</strong></p><ul><li>常见实现：<ul><li><code>@ConditionalOnClass</code>（类存在时装配）；</li><li><code>@ConditionalOnMissingBean</code>（没有 Bean 时装配）；</li><li><code>@ConditionalOnProperty</code>（配置项满足条件时装配）；</li><li><code>@ConditionalOnWebApplication</code>。</li></ul></li><li>广泛用于自动配置。</li></ul><p><strong>延伸思考：</strong></p><ul><li>面试追问：怎么写自定义条件？<br> → 实现 <code>Condition</code> 接口，重写 <code>matches()</code> 方法。</li></ul><hr><h3 id="20-Spring-Boot-常见的优化点？"><a href="#20-Spring-Boot-常见的优化点？" class="headerlink" title="20. Spring Boot 常见的优化点？"></a>20. Spring Boot 常见的优化点？</h3><p><strong>核心回答：</strong></p><ul><li>启动优化：懒加载、裁剪 Starter；</li><li>内存优化：减小 Bean 数量、引入轻量组件；</li><li>数据库优化：连接池、批量操作；</li><li>生产优化：Actuator 监控、外部化配置。</li></ul><p><strong>深入解析：</strong></p><ol><li><strong>启动性能</strong>：<code>spring.main.lazy-initialization=true</code>；</li><li><strong>数据库性能</strong>：HikariCP 连接池、批处理 SQL；</li><li><strong>缓存优化</strong>：整合 Redis、Caffeine；</li><li><strong>日志优化</strong>：异步日志（Logback AsyncAppender）；</li><li><strong>部署优化</strong>：分层构建（Layered Jar）、Docker 镜像加速。</li></ol><p><strong>延伸思考：</strong></p><ul><li>面试常问：Spring Boot 为什么启动比 Spring 慢？<br> → 因为要做自动装配和环境扫描。</li><li>实战：生产中可用 <code>spring-context-indexer</code> 加快启动。</li></ul><hr><h3 id="21-Spring-Boot-的自动配置原理"><a href="#21-Spring-Boot-的自动配置原理" class="headerlink" title="21. Spring Boot 的自动配置原理"></a><strong>21. Spring Boot 的自动配置原理</strong></h3><p><strong>核心回答</strong><br> Spring Boot 的自动配置基于 <strong>SpringFactoriesLoader + @EnableAutoConfiguration + 条件注解（@ConditionalXXX）</strong>。<br> 它会根据 classpath 中依赖的 jar 包和已有 Bean 自动装配所需的配置。</p><p><strong>深入解析</strong></p><ol><li><strong>关键入口</strong>：<ul><li><code>@SpringBootApplication</code> → <code>@EnableAutoConfiguration</code> → <code>AutoConfigurationImportSelector</code>。</li></ul></li><li><strong>配置来源</strong>：<ul><li><code>META-INF/spring.factories</code> 或 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>。</li></ul></li><li><strong>条件装配</strong>：<ul><li>通过 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等来避免重复配置。</li></ul></li><li><strong>运行时流程</strong>：<ul><li>启动时加载所有候选配置类 → 根据条件筛选 → 注册 BeanDefinition → 实例化 Bean。</li></ul></li></ol><p><strong>延伸思考</strong></p><ul><li>面试追问：如何排查“为什么某个 Bean 没有生效”？<br> → 使用 <code>--debug</code> 参数查看 <strong>自动配置报告</strong>。</li><li>实战：如果不想加载某个自动配置，可以用 <code>@SpringBootApplication(exclude=XXXAutoConfiguration.class)</code>。</li></ul><hr><h3 id="22-Spring-Boot-的启动流程"><a href="#22-Spring-Boot-的启动流程" class="headerlink" title="22. Spring Boot 的启动流程"></a><strong>22. Spring Boot 的启动流程</strong></h3><p><strong>核心回答</strong><br> 启动流程：</p><ol><li>创建 <code>SpringApplication</code> 对象。</li><li>准备环境（Environment）。</li><li>加载 ApplicationContext。</li><li>调用自动配置。</li><li>启动内嵌容器（Tomcat&#x2F;Jetty&#x2F;Netty）。</li><li>执行 <code>CommandLineRunner</code> 和 <code>ApplicationRunner</code>。</li></ol><p><strong>深入解析</strong></p><ul><li><strong>源码入口</strong>：<code>SpringApplication.run()</code>。</li><li><strong>事件监听</strong>：<ul><li><code>ApplicationStartingEvent</code>（最早事件），</li><li><code>ApplicationReadyEvent</code>（启动完成）。</li></ul></li><li><strong>Bean 加载</strong>：<ul><li>先加载主类所在包及子包的组件（<code>@ComponentScan</code>）。</li><li>再结合自动配置。</li></ul></li></ul><p><strong>延伸思考</strong></p><ul><li>面试官可能问：<strong>Spring Boot 如何支持外部配置？</strong><br> → 通过 <code>ConfigFileApplicationListener</code> 解析 <code>application.properties</code> &#x2F; <code>application.yml</code> 并注入 Environment。</li></ul><hr><h3 id="23-Spring-Boot-的配置文件加载顺序"><a href="#23-Spring-Boot-的配置文件加载顺序" class="headerlink" title="23. Spring Boot 的配置文件加载顺序"></a><strong>23. Spring Boot 的配置文件加载顺序</strong></h3><p><strong>核心回答</strong><br> Spring Boot 的配置优先级（从高到低）：</p><ol><li>命令行参数</li><li><code>application.properties/yml</code>（在 <code>config/</code> &gt; 当前目录 &gt; classpath 下）</li><li>外部系统环境变量</li><li>JNDI、系统属性</li><li>默认配置</li></ol><p><strong>深入解析</strong></p><ul><li><strong>多 profile</strong>：<code>application-dev.yml</code> 会在 <code>--spring.profiles.active=dev</code> 时覆盖默认配置。</li><li><strong>优先级控制</strong>：同一属性多次定义时，高优先级覆盖低优先级。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：如果配置冲突，如何快速定位？<br> → 启动时加参数 <code>--debug</code>，查看配置源和优先级。</li></ul><hr><h3 id="24-Spring-Boot-如何实现热部署"><a href="#24-Spring-Boot-如何实现热部署" class="headerlink" title="24. Spring Boot 如何实现热部署"></a><strong>24. Spring Boot 如何实现热部署</strong></h3><p><strong>核心回答</strong><br> 通过 <strong>Spring Boot DevTools</strong> 或 <strong>JRebel</strong> 实现热部署。</p><p><strong>深入解析</strong></p><ul><li><strong>DevTools 原理</strong>：<ul><li>使用两个 ClassLoader：<ul><li>Base ClassLoader（第三方依赖不会变），</li><li>Restart ClassLoader（自己代码，改动后只重新加载）。</li></ul></li></ul></li><li><strong>局限性</strong>：修改依赖库不会触发热部署，只能重启。</li></ul><p><strong>延伸思考</strong></p><ul><li>实际开发中推荐用 <strong>DevTools + IDEA 自动构建</strong>。</li><li>面试追问：生产环境如何实现热更新？<br> → 使用 Spring Cloud Config + 动态刷新（<code>/actuator/refresh</code>）。</li></ul><hr><h3 id="25-Spring-Boot-中的监控和健康检查"><a href="#25-Spring-Boot-中的监控和健康检查" class="headerlink" title="25. Spring Boot 中的监控和健康检查"></a><strong>25. Spring Boot 中的监控和健康检查</strong></h3><p><strong>核心回答</strong><br> Spring Boot 提供 <strong>Actuator 模块</strong>，可监控应用运行状态。</p><p><strong>深入解析</strong></p><ul><li>常见端点：<ul><li><code>/actuator/health</code>（健康检查）</li><li><code>/actuator/metrics</code>（性能指标）</li><li><code>/actuator/env</code>（环境变量）</li><li><code>/actuator/beans</code>（已加载 Bean）</li></ul></li><li>健康检查可扩展：实现 <code>HealthIndicator</code> 接口，自定义检查逻辑（如 Redis、MQ）。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：如何在 Kubernetes 中结合健康检查？<br> → 配置 <strong>livenessProbe</strong> 和 <strong>readinessProbe</strong> 调用 <code>/actuator/health</code>。</li></ul><hr><h3 id="26-Spring-Boot-如何集成数据库（JDBC、JPA、MyBatis）"><a href="#26-Spring-Boot-如何集成数据库（JDBC、JPA、MyBatis）" class="headerlink" title="26. Spring Boot 如何集成数据库（JDBC、JPA、MyBatis）"></a><strong>26. Spring Boot 如何集成数据库（JDBC、JPA、MyBatis）</strong></h3><p><strong>核心回答</strong><br> Spring Boot 提供 <code>spring-boot-starter-jdbc</code>、<code>spring-boot-starter-data-jpa</code> 等 starter，支持开箱即用。</p><p><strong>深入解析</strong></p><ul><li><strong>JDBC</strong>：直接操作数据库，结合 <code>JdbcTemplate</code>。</li><li><strong>JPA</strong>：基于 Hibernate，支持声明式 ORM（<code>@Entity</code>）。</li><li><strong>MyBatis</strong>：需引入第三方 starter（<code>mybatis-spring-boot-starter</code>），用 <code>@MapperScan</code>。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：<strong>Spring Data JPA 与 MyBatis 区别？</strong><ul><li>JPA → ORM 自动化，适合快速开发。</li><li>MyBatis → SQL 手写，灵活可控，适合复杂业务。</li></ul></li></ul><hr><h3 id="27-Spring-Boot-如何实现日志管理"><a href="#27-Spring-Boot-如何实现日志管理" class="headerlink" title="27. Spring Boot 如何实现日志管理"></a><strong>27. Spring Boot 如何实现日志管理</strong></h3><p><strong>核心回答</strong><br> Spring Boot 默认使用 <strong>SLF4J + Logback</strong>，可支持 Log4j2。</p><p><strong>深入解析</strong></p><ul><li><strong>配置方式</strong>：<ul><li><code>application.yml</code> 或 <code>logback-spring.xml</code>。</li></ul></li><li><strong>日志级别</strong>：<code>TRACE</code> &lt; <code>DEBUG</code> &lt; <code>INFO</code> &lt; <code>WARN</code> &lt; <code>ERROR</code>。</li><li><strong>多环境日志</strong>：<ul><li><code>logback-spring.xml</code> + <code>springProfile</code> 标签可区分 dev &#x2F; prod。</li></ul></li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：如何将日志输出到 ELK（ElasticSearch + Logstash + Kibana）？<br> → 使用 <code>logstash-logback-encoder</code>。</li></ul><hr><h3 id="28-Spring-Boot-如何处理跨域问题（CORS）"><a href="#28-Spring-Boot-如何处理跨域问题（CORS）" class="headerlink" title="28. Spring Boot 如何处理跨域问题（CORS）"></a><strong>28. Spring Boot 如何处理跨域问题（CORS）</strong></h3><p><strong>核心回答</strong><br> 通过 <strong>@CrossOrigin</strong> 或全局配置 <code>CorsFilter</code>。</p><p><strong>深入解析</strong></p><ul><li><p><strong>方式1：注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins=&quot;http://example.com&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/api/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方式2：全局配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WebMvcConfigurer <span class="title function_">corsConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">            registry.addMapping(<span class="string">&quot;/**&quot;</span>).allowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：CORS 和 Nginx 反向代理跨域的区别？<ul><li>CORS → Spring Boot 处理，适合单应用。</li><li>Nginx → 网关层处理，适合微服务架构。</li></ul></li></ul><hr><h3 id="29-Spring-Boot-中的安全机制（Spring-Security）"><a href="#29-Spring-Boot-中的安全机制（Spring-Security）" class="headerlink" title="29. Spring Boot 中的安全机制（Spring Security）"></a><strong>29. Spring Boot 中的安全机制（Spring Security）</strong></h3><p><strong>核心回答</strong><br> Spring Security 提供认证（Authentication）+ 授权（Authorization）。</p><p><strong>深入解析</strong></p><ol><li><strong>认证流程</strong>：<ul><li>用户请求 → <code>UsernamePasswordAuthenticationFilter</code> → AuthenticationManager → UserDetailsService → 认证成功 → SecurityContext 保存信息。</li></ul></li><li><strong>授权机制</strong>：<ul><li>基于 URL（拦截路径）、方法级（<code>@PreAuthorize</code>）、表达式。</li></ul></li><li><strong>默认用户</strong>：Spring Boot 2.x 默认生成随机密码（日志中输出）。</li></ol><p><strong>延伸思考</strong></p><ul><li>面试追问：如何在 Spring Security 中集成 JWT？<ul><li>自定义过滤器，解析 JWT 并注入 SecurityContext。</li></ul></li></ul><hr><h3 id="30-如何优化-Spring-Boot-启动速度"><a href="#30-如何优化-Spring-Boot-启动速度" class="headerlink" title="30. 如何优化 Spring Boot 启动速度"></a><strong>30. 如何优化 Spring Boot 启动速度</strong></h3><p><strong>核心回答</strong><br> 优化手段：减少自动配置、延迟初始化、引入轻量依赖。</p><p><strong>深入解析</strong></p><ul><li><strong>延迟加载</strong>：<code>spring.main.lazy-initialization=true</code>。</li><li><strong>移除不必要的 starter</strong>。</li><li><strong>本地调试时跳过安全&#x2F;监控配置</strong>。</li><li><strong>使用 GraalVM Native Image 加速启动</strong>。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：Spring Boot 启动慢，如何排查？<ul><li>使用 <code>--debug</code> 和 <code>ApplicationStartup</code> 查看 Bean 加载耗时。</li></ul></li></ul><hr><h2 id="五、Spring-Cloud（30题）"><a href="#五、Spring-Cloud（30题）" class="headerlink" title="五、Spring Cloud（30题）"></a>五、Spring Cloud（30题）</h2><hr><h2 id="1-Spring-Cloud-是什么？"><a href="#1-Spring-Cloud-是什么？" class="headerlink" title="1. Spring Cloud 是什么？"></a><strong>1. Spring Cloud 是什么？</strong></h2><p><strong>核心回答</strong><br> Spring Cloud 是基于 Spring Boot 的微服务治理框架，提供了分布式系统所需的全套组件：服务注册发现、负载均衡、配置中心、网关、熔断限流、链路追踪等。</p><p><strong>深入原理</strong></p><ul><li><strong>定位</strong>：微服务的 “生态整合者”，不是单一技术，而是一套解决方案。</li><li><strong>核心组件</strong>：<ul><li>Eureka（注册中心）</li><li>Ribbon &#x2F; LoadBalancer（客户端负载均衡）</li><li>Feign（声明式远程调用）</li><li>Hystrix &#x2F; Resilience4j &#x2F; Sentinel（熔断限流）</li><li>Config Server（配置中心）</li><li>Gateway（网关）</li><li>Sleuth + Zipkin（链路追踪）</li></ul></li><li><strong>本质</strong>：解决分布式复杂性，降低开发门槛。</li></ul><p><strong>面试延伸</strong></p><ul><li>Spring Cloud 与 Kubernetes Service Mesh 的区别：前者 SDK 模式，后者 Sidecar 模式。</li></ul><hr><h2 id="2-Spring-Cloud-和-Dubbo-的区别？"><a href="#2-Spring-Cloud-和-Dubbo-的区别？" class="headerlink" title="2. Spring Cloud 和 Dubbo 的区别？"></a><strong>2. Spring Cloud 和 Dubbo 的区别？</strong></h2><p><strong>核心回答</strong></p><ul><li>Dubbo：高性能 RPC 框架，核心是远程调用。</li><li>Spring Cloud：全家桶式微服务生态，功能更全面。</li></ul><p><strong>深入原理</strong></p><ul><li>协议层：Dubbo 用 TCP&#x2F;自定义协议，性能高；Spring Cloud 多用 REST&#x2F;HTTP。</li><li>功能覆盖：Dubbo 主要做服务调用，Spring Cloud 包含注册、配置、熔断、网关等。</li><li>演进：Dubbo3.0 开始支持 gRPC&#x2F;Triple 协议，与 Spring Cloud 越来越接近。</li></ul><p><strong>面试延伸</strong></p><ul><li>公司内网场景（追求性能） → Dubbo；</li><li>大规模分布式互联网场景（追求生态） → Spring Cloud。</li></ul><hr><h2 id="3-Eureka-的工作原理？"><a href="#3-Eureka-的工作原理？" class="headerlink" title="3. Eureka 的工作原理？"></a><strong>3. Eureka 的工作原理？</strong></h2><p><strong>核心回答</strong><br> Eureka 是 Netflix 开源的注册中心，负责 <strong>服务注册与发现</strong>，遵循 <strong>AP</strong> 原则。</p><p><strong>深入原理</strong></p><ul><li><strong>注册</strong>：服务启动后将自身信息（IP、端口、状态）注册到 Eureka Server。</li><li><strong>续约</strong>：服务定期发送心跳（默认 30s）。</li><li><strong>下线</strong>：服务关闭时发送下线请求。</li><li><strong>拉取</strong>：客户端定期从 Server 拉取注册表（默认 30s），本地缓存，提高可用性。</li></ul><p><strong>面试延伸</strong></p><ul><li>面试官可能问：Eureka 与 Zookeeper 区别？<ul><li>Eureka AP → 保证可用性（即使部分节点挂了仍能服务）；</li><li>Zookeeper CP → 强一致性（选举可能导致服务不可用）。</li></ul></li></ul><hr><h2 id="4-Eureka-的自我保护机制？"><a href="#4-Eureka-的自我保护机制？" class="headerlink" title="4. Eureka 的自我保护机制？"></a><strong>4. Eureka 的自我保护机制？</strong></h2><p><strong>核心回答</strong><br> Eureka 会在网络分区或心跳丢失时，<strong>不立即移除服务实例</strong>，保证可用性。</p><p><strong>深入原理</strong></p><ul><li>触发条件：在 15 分钟内心跳失败比例 &gt; 85%。</li><li>行为：<ul><li>暂停剔除失效服务。</li><li>保留已有注册表，允许客户端继续获取服务。</li></ul></li><li>好处：防止因网络抖动导致“服务雪崩”。</li></ul><p><strong>面试延伸</strong></p><ul><li>缺点：可能把已经宕机的实例继续暴露出去。</li><li>可配置 <code>eureka.server.enable-self-preservation=false</code> 来关闭。</li></ul><hr><h2 id="5-Ribbon-的负载均衡策略？"><a href="#5-Ribbon-的负载均衡策略？" class="headerlink" title="5. Ribbon 的负载均衡策略？"></a><strong>5. Ribbon 的负载均衡策略？</strong></h2><p><strong>核心回答</strong><br> Ribbon 是客户端负载均衡组件，常见策略有：</p><ul><li>轮询（RoundRobin）</li><li>随机（Random）</li><li>权重（WeightedResponseTimeRule）</li><li>最小并发（BestAvailableRule）</li></ul><p><strong>深入原理</strong><br> Ribbon 在客户端维护服务列表，从注册中心拉取后，根据策略选择目标服务发起请求。</p><p><strong>面试延伸</strong></p><ul><li>与 Nginx 的区别：Ribbon 是 <strong>客户端负载均衡</strong>（调用方决定），Nginx 是 <strong>服务端负载均衡</strong>（请求先到代理）。</li></ul><hr><h2 id="6-Ribbon-和-Nginx-的区别？"><a href="#6-Ribbon-和-Nginx-的区别？" class="headerlink" title="6. Ribbon 和 Nginx 的区别？"></a><strong>6. Ribbon 和 Nginx 的区别？</strong></h2><p><strong>核心回答</strong></p><ul><li>Ribbon：客户端负载均衡，本地决定调用哪台服务。</li><li>Nginx：服务端负载均衡，所有流量先经过代理。</li></ul><p><strong>深入原理</strong></p><ul><li><strong>部署位置</strong>：Ribbon 在调用方应用中，Nginx 独立部署。</li><li><strong>扩展性</strong>：Ribbon 与 Eureka 配合，支持动态上下线；Nginx 需手动改配置或借助 Consul&#x2F;Keepalived。</li></ul><p><strong>面试延伸</strong></p><ul><li>面试官追问：为什么微服务更倾向于 Ribbon？<ul><li>因为客户端模式更灵活，可以无感知扩容&#x2F;缩容。</li></ul></li></ul><hr><h2 id="7-Feign-的工作原理？"><a href="#7-Feign-的工作原理？" class="headerlink" title="7. Feign 的工作原理？"></a><strong>7. Feign 的工作原理？</strong></h2><p><strong>核心回答</strong><br> Feign 是声明式 HTTP 客户端，通过接口 + 注解的方式调用远程服务。</p><p><strong>深入原理</strong></p><ul><li>运行时基于 <strong>动态代理</strong>（JDK Proxy）。</li><li>结合 Ribbon 负载均衡，自动选择服务实例。</li><li>可集成 Hystrix&#x2F;Sentinel，支持熔断。</li></ul><p><strong>面试延伸</strong></p><ul><li>面试官问：Feign 和 RestTemplate 的区别？<ul><li>RestTemplate → 代码侵入性强，需要手动拼接请求。</li><li>Feign → 声明式，更优雅。</li></ul></li></ul><hr><h2 id="8-Feign-如何支持熔断？"><a href="#8-Feign-如何支持熔断？" class="headerlink" title="8. Feign 如何支持熔断？"></a><strong>8. Feign 如何支持熔断？</strong></h2><p><strong>核心回答</strong><br> Feign 可集成 Hystrix 或 Sentinel，通过 <strong>Fallback</strong> 提供降级逻辑。</p><p><strong>深入原理</strong></p><ul><li>Hystrix：在请求失败&#x2F;超时时调用 fallback 方法。</li><li>Sentinel：通过注解 @SentinelResource + fallback 实现。</li></ul><p><strong>面试延伸</strong></p><ul><li>面试官追问：熔断和降级区别？<ul><li>熔断：保护系统不被拖垮。</li><li>降级：提供兜底逻辑，保证用户体验。</li></ul></li></ul><hr><h2 id="9-Hystrix-的工作原理？"><a href="#9-Hystrix-的工作原理？" class="headerlink" title="9. Hystrix 的工作原理？"></a><strong>9. Hystrix 的工作原理？</strong></h2><p><strong>核心回答</strong><br> Hystrix 通过 <strong>线程池隔离 + 熔断器机制</strong> 保护服务，防止雪崩效应。</p><p><strong>深入原理</strong></p><ul><li><strong>线程池隔离</strong>：不同服务调用用不同线程池，避免相互影响。</li><li><strong>熔断机制</strong>：<ul><li>统计请求失败率。</li><li>达到阈值 → 熔断打开，直接走 fallback。</li><li>一段时间后 → 尝试半开，成功则恢复。</li></ul></li></ul><p><strong>面试延伸</strong></p><ul><li>Hystrix 已停止维护，推荐用 Resilience4j 或 Sentinel。</li></ul><hr><h2 id="10-Hystrix-的线程池隔离和信号量隔离？"><a href="#10-Hystrix-的线程池隔离和信号量隔离？" class="headerlink" title="10. Hystrix 的线程池隔离和信号量隔离？"></a><strong>10. Hystrix 的线程池隔离和信号量隔离？</strong></h2><p><strong>核心回答</strong></p><ul><li><strong>线程池隔离</strong>：每个依赖用独立线程池，适合耗时操作。</li><li><strong>信号量隔离</strong>：限制并发数，不开线程池，适合低延迟操作。</li></ul><p><strong>深入原理</strong></p><ul><li>线程池隔离：开销大，但最安全。</li><li>信号量隔离：轻量，但不能防止调用阻塞线程。</li></ul><p><strong>面试延伸</strong></p><ul><li>实战经验：大多数 IO 调用用线程池隔离，本地计算或轻量调用用信号量隔离。</li></ul><hr><h2 id="11-Resilience4j-和-Hystrix-区别？"><a href="#11-Resilience4j-和-Hystrix-区别？" class="headerlink" title="11. Resilience4j 和 Hystrix 区别？"></a><strong>11. Resilience4j 和 Hystrix 区别？</strong></h2><ul><li>Resilience4j 基于 Java 8 函数式接口，更轻量，支持熔断、限流、重试、隔离等；</li><li>Hystrix 已停止维护，功能单一（熔断+线程隔离）。</li><li>Resilience4j 模块化，可按需引入。</li></ul><hr><h2 id="12-Gateway-的核心功能？"><a href="#12-Gateway-的核心功能？" class="headerlink" title="12. Gateway 的核心功能？"></a><strong>12. Gateway 的核心功能？</strong></h2><ul><li><strong>路由转发</strong>（根据路径、Header、参数转发请求）。</li><li><strong>过滤器机制</strong>（统一鉴权、日志、限流）。</li><li><strong>负载均衡</strong>（结合注册中心）。</li><li><strong>协议支持</strong>（WebSocket、HTTPS）。</li></ul><hr><h2 id="13-Gateway-和-Zuul-的区别？"><a href="#13-Gateway-和-Zuul-的区别？" class="headerlink" title="13. Gateway 和 Zuul 的区别？"></a><strong>13. Gateway 和 Zuul 的区别？</strong></h2><ul><li>Zuul1 基于 Servlet，阻塞 IO，性能差。</li><li>Gateway 基于 Netty + Reactor，支持响应式，性能高。</li><li>Zuul2 虽然改为异步，但生态上 Gateway 更推荐。</li></ul><hr><h2 id="14-Config-Server-的作用？"><a href="#14-Config-Server-的作用？" class="headerlink" title="14. Config Server 的作用？"></a><strong>14. Config Server 的作用？</strong></h2><ul><li>统一管理微服务配置，支持 Git、SVN 等存储。</li><li>动态刷新配置，保证环境一致性。</li><li>与 Bus 结合可广播刷新。</li></ul><hr><h2 id="15-Config-Server-如何保证配置实时刷新？"><a href="#15-Config-Server-如何保证配置实时刷新？" class="headerlink" title="15. Config Server 如何保证配置实时刷新？"></a><strong>15. Config Server 如何保证配置实时刷新？</strong></h2><ul><li>客户端通过 <code>@RefreshScope</code> 实现动态刷新。</li><li>手动触发 <code>/actuator/refresh</code>。</li><li>结合 Spring Cloud Bus，可用消息队列广播刷新。</li></ul><hr><h2 id="16-Spring-Cloud-Bus-的原理？"><a href="#16-Spring-Cloud-Bus-的原理？" class="headerlink" title="16. Spring Cloud Bus 的原理？"></a><strong>16. Spring Cloud Bus 的原理？</strong></h2><ul><li>底层基于消息队列（Kafka、RabbitMQ）。</li><li>当配置变更时，Bus 广播事件，所有服务接收并刷新配置。</li></ul><hr><h2 id="17-Sleuth-的作用？"><a href="#17-Sleuth-的作用？" class="headerlink" title="17. Sleuth 的作用？"></a><strong>17. Sleuth 的作用？</strong></h2><ul><li>在微服务调用链路中，自动生成 <strong>TraceId &#x2F; SpanId</strong>。</li><li>实现请求链路追踪，定位性能瓶颈。</li></ul><hr><h2 id="18-Sleuth-与-Zipkin-的关系？"><a href="#18-Sleuth-与-Zipkin-的关系？" class="headerlink" title="18. Sleuth 与 Zipkin 的关系？"></a><strong>18. Sleuth 与 Zipkin 的关系？</strong></h2><ul><li>Sleuth：负责埋点、生成日志。</li><li>Zipkin：负责收集、存储、展示调用链数据。</li></ul><hr><h2 id="19-分布式链路追踪的原理？"><a href="#19-分布式链路追踪的原理？" class="headerlink" title="19. 分布式链路追踪的原理？"></a><strong>19. 分布式链路追踪的原理？</strong></h2><ul><li>通过唯一 TraceId 贯穿整个调用链。</li><li>每次远程调用生成新的 SpanId。</li><li>数据上报到集中式系统（Zipkin&#x2F;Jaeger）。</li></ul><hr><h2 id="20-Spring-Cloud-Stream-的作用？"><a href="#20-Spring-Cloud-Stream-的作用？" class="headerlink" title="20. Spring Cloud Stream 的作用？"></a><strong>20. Spring Cloud Stream 的作用？</strong></h2><ul><li>封装消息中间件（Kafka&#x2F;RabbitMQ）。</li><li>提供统一编程模型，屏蔽底层差异。</li><li>支持消息驱动架构。</li></ul><hr><h2 id="21-消息驱动模型和事件驱动模型区别？"><a href="#21-消息驱动模型和事件驱动模型区别？" class="headerlink" title="21. 消息驱动模型和事件驱动模型区别？"></a><strong>21. 消息驱动模型和事件驱动模型区别？</strong></h2><ul><li>消息驱动：强调解耦，消息可靠投递。</li><li>事件驱动：强调系统对事件的响应。</li><li>Spring Cloud Stream 更偏消息驱动，但也支持事件模式。</li></ul><hr><h2 id="22-Nacos-和-Eureka-的区别？"><a href="#22-Nacos-和-Eureka-的区别？" class="headerlink" title="22. Nacos 和 Eureka 的区别？"></a><strong>22. Nacos 和 Eureka 的区别？</strong></h2><ul><li>Nacos 除了服务注册发现，还提供配置中心功能。</li><li>Nacos 支持 <strong>AP&#x2F;CP 模式切换</strong>；Eureka 固定 AP。</li><li>Nacos 提供 UI，更易运维。</li></ul><hr><h2 id="23-Nacos-配置中心和注册中心的实现原理？"><a href="#23-Nacos-配置中心和注册中心的实现原理？" class="headerlink" title="23. Nacos 配置中心和注册中心的实现原理？"></a><strong>23. Nacos 配置中心和注册中心的实现原理？</strong></h2><ul><li>配置中心：基于推拉结合（长轮询 + Server 推送）。</li><li>注册中心：基于心跳机制维护服务健康状态。</li></ul><hr><h2 id="24-Sentinel-的工作原理？"><a href="#24-Sentinel-的工作原理？" class="headerlink" title="24. Sentinel 的工作原理？"></a><strong>24. Sentinel 的工作原理？</strong></h2><ul><li>基于 <strong>滑动窗口统计</strong> 请求 QPS、响应时间。</li><li>支持多种限流、熔断、降级规则。</li><li>与 Dubbo&#x2F;Spring Cloud&#x2F;Feign 无缝集成。</li></ul><hr><h2 id="25-限流的常见算法（令牌桶、漏桶）？"><a href="#25-限流的常见算法（令牌桶、漏桶）？" class="headerlink" title="25. 限流的常见算法（令牌桶、漏桶）？"></a><strong>25. 限流的常见算法（令牌桶、漏桶）？</strong></h2><ul><li><strong>令牌桶</strong>：系统以固定速率生成令牌，请求需拿到令牌才执行。</li><li><strong>漏桶</strong>：请求先进入桶，系统以固定速率处理，超出则丢弃。</li><li>区别：令牌桶允许突发流量，漏桶更平滑。</li></ul><hr><h2 id="26-熔断和降级的区别？"><a href="#26-熔断和降级的区别？" class="headerlink" title="26. 熔断和降级的区别？"></a><strong>26. 熔断和降级的区别？</strong></h2><ul><li>熔断：系统保护机制，拒绝调用，防止雪崩。</li><li>降级：业务兜底方案，返回备用结果。</li><li>熔断是“硬防护”，降级是“软兜底”。</li></ul><hr><h2 id="27-CAP-定理和-Spring-Cloud-的关系？"><a href="#27-CAP-定理和-Spring-Cloud-的关系？" class="headerlink" title="27. CAP 定理和 Spring Cloud 的关系？"></a><strong>27. CAP 定理和 Spring Cloud 的关系？</strong></h2><ul><li>CAP：一致性（C）、可用性（A）、分区容错性（P）。</li><li>Eureka → AP；Consul → CP；Nacos → AP&#x2F;CP 切换。</li></ul><hr><h2 id="28-Spring-Cloud-与-Kubernetes-的关系？"><a href="#28-Spring-Cloud-与-Kubernetes-的关系？" class="headerlink" title="28. Spring Cloud 与 Kubernetes 的关系？"></a><strong>28. Spring Cloud 与 Kubernetes 的关系？</strong></h2><ul><li>Spring Cloud：偏应用层，开发框架。</li><li>Kubernetes：偏基础设施，容器编排。</li><li>可结合使用：Spring Cloud 负责应用治理，K8s 负责资源调度。</li></ul><hr><h2 id="29-微服务中的灰度发布？"><a href="#29-微服务中的灰度发布？" class="headerlink" title="29. 微服务中的灰度发布？"></a><strong>29. 微服务中的灰度发布？</strong></h2><ul><li>指新版本只对部分用户开放。</li><li>实现方式：<ul><li>Nginx&#x2F;Gateway 按用户 ID 或流量比例路由。</li><li>Service Mesh（Istio）支持更灵活的流量控制。</li></ul></li></ul><hr><h2 id="30-Spring-Cloud-如何实现服务网格？"><a href="#30-Spring-Cloud-如何实现服务网格？" class="headerlink" title="30. Spring Cloud 如何实现服务网格？"></a><strong>30. Spring Cloud 如何实现服务网格？</strong></h2><ul><li>原生 Spring Cloud 偏 SDK 模式，缺乏服务网格能力。</li><li>可结合 <strong>Spring Cloud + Istio&#x2F;Envoy</strong>，实现流量治理、观测、熔断、灰度。</li><li>越来越多团队采用 <strong>Spring Cloud Alibaba + Service Mesh</strong> 的混合方案。</li></ul><hr><h2 id="六、微服务架构-分布式系统（30题）"><a href="#六、微服务架构-分布式系统（30题）" class="headerlink" title="六、微服务架构 &amp; 分布式系统（30题）"></a>六、微服务架构 &amp; 分布式系统（30题）</h2><hr><h2 id="1-什么是微服务？"><a href="#1-什么是微服务？" class="headerlink" title="1. 什么是微服务？"></a><strong>1. 什么是微服务？</strong></h2><p><strong>核心回答</strong><br> 微服务是一种架构风格，将单体应用拆分为一组小型、独立部署的服务，每个服务聚焦某个业务能力，通过 API（HTTP&#x2F;gRPC&#x2F;MQ）通信。</p><p><strong>深入原理</strong></p><ul><li>每个服务独立开发、部署、扩容。</li><li>服务自治：有自己的数据库、缓存、逻辑。</li><li>通常结合容器化、CI&#x2F;CD、服务治理框架（如 Spring Cloud、Dubbo、K8s）。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：和单体应用区别？ → 单体耦合度高，微服务解耦但更复杂。</li></ul><hr><h2 id="2-微服务与-SOA-的区别？"><a href="#2-微服务与-SOA-的区别？" class="headerlink" title="2. 微服务与 SOA 的区别？"></a><strong>2. 微服务与 SOA 的区别？</strong></h2><p><strong>核心回答</strong></p><ul><li><strong>SOA</strong>：面向服务的架构，通常依赖 ESB（企业服务总线）。</li><li><strong>微服务</strong>：轻量级、去中心化，强调小而独立，常用 REST&#x2F;gRPC。</li></ul><p><strong>深入原理</strong></p><ul><li>SOA → 偏企业内部，服务较大，依赖统一中间件（如 ESB）。</li><li>微服务 → 服务更小，避免单点中心，强调去中心化自治。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试追问：为什么微服务比 SOA 更流行？ → 云原生背景下，微服务更适应敏捷开发和快速迭代。</li></ul><hr><h2 id="3-微服务的优缺点？"><a href="#3-微服务的优缺点？" class="headerlink" title="3. 微服务的优缺点？"></a><strong>3. 微服务的优缺点？</strong></h2><p><strong>核心回答</strong></p><ul><li>优点：独立部署、技术多样性、弹性伸缩、快速迭代。</li><li>缺点：分布式复杂性、运维难度高、数据一致性挑战、服务治理成本高。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试官常问：什么时候不适合微服务？ → 业务小、团队小、系统简单时。</li></ul><hr><h2 id="4-微服务的拆分原则？"><a href="#4-微服务的拆分原则？" class="headerlink" title="4. 微服务的拆分原则？"></a><strong>4. 微服务的拆分原则？</strong></h2><p><strong>核心回答</strong></p><ul><li>按业务边界（DDD 的领域驱动设计）。</li><li>高内聚、低耦合。</li><li>一个服务只聚焦一个核心业务能力。</li></ul><p><strong>深入原理</strong></p><ul><li>拆分方式：按业务（订单、用户、支付）、按场景（核心 vs 辅助）、按非功能需求（性能瓶颈点）。</li></ul><p><strong>延伸思考</strong></p><ul><li>常见错误：按数据库表拆分，导致过度依赖跨服务调用。</li></ul><hr><h2 id="5-如何保证微服务之间的数据一致性？"><a href="#5-如何保证微服务之间的数据一致性？" class="headerlink" title="5. 如何保证微服务之间的数据一致性？"></a><strong>5. 如何保证微服务之间的数据一致性？</strong></h2><p><strong>核心回答</strong></p><ul><li>避免强一致，采用 <strong>最终一致性</strong>。</li><li>方案：分布式事务、消息驱动、补偿机制。</li></ul><p><strong>深入原理</strong></p><ul><li>同步方案：XA（两阶段提交）。</li><li>异步方案：TCC、SAGA、可靠消息。</li></ul><p><strong>延伸思考</strong></p><ul><li>面试官追问：你在项目中怎么做？ → 消息队列（事务消息&#x2F;本地消息表）。</li></ul><hr><h2 id="6-分布式事务有哪些解决方案？"><a href="#6-分布式事务有哪些解决方案？" class="headerlink" title="6. 分布式事务有哪些解决方案？"></a><strong>6. 分布式事务有哪些解决方案？</strong></h2><p><strong>核心回答</strong></p><ul><li>XA（两阶段提交）</li><li>TCC（Try-Confirm-Cancel）</li><li>SAGA（长事务补偿）</li><li>本地消息表 &#x2F; 事务消息</li></ul><p><strong>深入原理</strong></p><ul><li>XA：强一致性，但性能差。</li><li>TCC：业务入侵高，但灵活。</li><li>SAGA：长事务场景，失败时用补偿。</li><li>本地消息表：保证最终一致性。</li></ul><hr><h2 id="7-TCC、SAGA、XA-的区别？"><a href="#7-TCC、SAGA、XA-的区别？" class="headerlink" title="7. TCC、SAGA、XA 的区别？"></a><strong>7. TCC、SAGA、XA 的区别？</strong></h2><ul><li><strong>XA</strong>：数据库层两阶段提交，强一致，性能差。</li><li><strong>TCC</strong>：应用层三步（预留资源、确认、回滚），侵入性高。</li><li><strong>SAGA</strong>：长事务，每步都有补偿动作，保证最终一致性。</li></ul><hr><h2 id="8-本地消息表和可靠消息最终一致性？"><a href="#8-本地消息表和可靠消息最终一致性？" class="headerlink" title="8. 本地消息表和可靠消息最终一致性？"></a><strong>8. 本地消息表和可靠消息最终一致性？</strong></h2><ul><li>本地消息表：在本地事务中写业务表 + 消息表 → MQ 异步投递 → 消费端确认。</li><li>可靠消息：MQ 支持事务（如 RocketMQ 半消息），确保消息必达，保证最终一致性。</li></ul><hr><h2 id="9-分布式锁的实现方式？"><a href="#9-分布式锁的实现方式？" class="headerlink" title="9. 分布式锁的实现方式？"></a><strong>9. 分布式锁的实现方式？</strong></h2><ul><li>数据库锁（悲观锁&#x2F;唯一索引）。</li><li>Redis 分布式锁（setnx + expire）。</li><li>Zookeeper 分布式锁（临时顺序节点）。</li></ul><hr><h2 id="10-Redis-分布式锁的缺陷？"><a href="#10-Redis-分布式锁的缺陷？" class="headerlink" title="10. Redis 分布式锁的缺陷？"></a><strong>10. Redis 分布式锁的缺陷？</strong></h2><ul><li>单点问题（需 Redis Cluster 或 Redlock）。</li><li>锁过期可能导致误释放。</li><li>不能保证严格公平。</li></ul><hr><h2 id="11-Zookeeper-分布式锁的实现？"><a href="#11-Zookeeper-分布式锁的实现？" class="headerlink" title="11. Zookeeper 分布式锁的实现？"></a><strong>11. Zookeeper 分布式锁的实现？</strong></h2><ul><li>利用 <strong>临时顺序节点</strong>：<ul><li>客户端创建顺序节点。</li><li>判断自己是否是最小节点 → 获取锁。</li><li>不是则监听前一个节点的删除事件。</li></ul></li></ul><hr><h2 id="12-数据库分库分表策略？"><a href="#12-数据库分库分表策略？" class="headerlink" title="12. 数据库分库分表策略？"></a><strong>12. 数据库分库分表策略？</strong></h2><ul><li>垂直分库（按业务拆分）。</li><li>水平分表（按用户 ID、时间做分片）。</li><li>常见路由方式：哈希取模、范围、时间。</li></ul><hr><h2 id="13-水平拆分与垂直拆分区别？"><a href="#13-水平拆分与垂直拆分区别？" class="headerlink" title="13. 水平拆分与垂直拆分区别？"></a><strong>13. 水平拆分与垂直拆分区别？</strong></h2><ul><li><strong>水平拆分</strong>：同一张表的数据分到多个库表（按范围&#x2F;哈希）。</li><li><strong>垂直拆分</strong>：不同业务表放到不同库（用户库、订单库）。</li></ul><hr><h2 id="14-分布式-ID-生成方案？"><a href="#14-分布式-ID-生成方案？" class="headerlink" title="14. 分布式 ID 生成方案？"></a><strong>14. 分布式 ID 生成方案？</strong></h2><ul><li>UUID（无序，不适合数据库）。</li><li>数据库自增 ID（单点瓶颈）。</li><li>Redis 自增。</li><li>雪花算法（Snowflake）。</li><li>Leaf（美团开源）。</li></ul><hr><h2 id="15-雪花算法的原理？"><a href="#15-雪花算法的原理？" class="headerlink" title="15. 雪花算法的原理？"></a><strong>15. 雪花算法的原理？</strong></h2><ul><li>64 位长整型：<ul><li>时间戳（41 位）</li><li>机器 ID（10 位）</li><li>序列号（12 位）</li></ul></li><li>保证全局唯一、有序。</li></ul><hr><h2 id="16-API-网关的作用？"><a href="#16-API-网关的作用？" class="headerlink" title="16. API 网关的作用？"></a><strong>16. API 网关的作用？</strong></h2><ul><li>统一入口，做路由转发。</li><li>鉴权、安全控制。</li><li>流量控制、熔断、降级。</li><li>日志监控。</li></ul><hr><h2 id="17-服务注册与发现机制？"><a href="#17-服务注册与发现机制？" class="headerlink" title="17. 服务注册与发现机制？"></a><strong>17. 服务注册与发现机制？</strong></h2><ul><li>服务启动 → 注册中心注册（IP&#x2F;端口&#x2F;状态）。</li><li>调用方 → 从注册中心获取地址列表。</li><li>注册中心 → 通过心跳维持健康状态。</li></ul><hr><h2 id="18-微服务如何保证高可用？"><a href="#18-微服务如何保证高可用？" class="headerlink" title="18. 微服务如何保证高可用？"></a><strong>18. 微服务如何保证高可用？</strong></h2><ul><li>服务冗余（多实例部署）。</li><li>负载均衡。</li><li>熔断、降级、限流。</li><li>自动故障转移（K8s + 服务治理框架）。</li></ul><hr><h2 id="19-微服务中的限流和熔断？"><a href="#19-微服务中的限流和熔断？" class="headerlink" title="19. 微服务中的限流和熔断？"></a><strong>19. 微服务中的限流和熔断？</strong></h2><ul><li>限流：控制流量，保护系统（令牌桶&#x2F;漏桶）。</li><li>熔断：当下游服务异常时，直接失败并快速返回。</li></ul><hr><h2 id="20-微服务如何保证安全性？"><a href="#20-微服务如何保证安全性？" class="headerlink" title="20. 微服务如何保证安全性？"></a><strong>20. 微服务如何保证安全性？</strong></h2><ul><li>认证授权（OAuth2、JWT）。</li><li>HTTPS、加密通信。</li><li>API 网关统一鉴权。</li><li>数据脱敏。</li></ul><hr><h2 id="21-OAuth2-的原理？"><a href="#21-OAuth2-的原理？" class="headerlink" title="21. OAuth2 的原理？"></a><strong>21. OAuth2 的原理？</strong></h2><ul><li>基于令牌的认证授权协议。</li><li>四种模式：授权码、密码、客户端凭证、简化模式。</li><li>典型流程：用户 → 授权服务器 → 获取 Token → 调用资源服务器。</li></ul><hr><h2 id="22-JWT-的作用？"><a href="#22-JWT-的作用？" class="headerlink" title="22. JWT 的作用？"></a><strong>22. JWT 的作用？</strong></h2><ul><li>JSON Web Token，一种无状态令牌。</li><li>内容包含三部分：Header、Payload、Signature。</li><li>适合分布式系统做认证，无需存储 Session。</li></ul><hr><h2 id="23-单点登录-SSO-的实现？"><a href="#23-单点登录-SSO-的实现？" class="headerlink" title="23. 单点登录 SSO 的实现？"></a><strong>23. 单点登录 SSO 的实现？</strong></h2><ul><li>用户只需登录一次，获取全局 Token&#x2F;Session。</li><li>常见实现：CAS、OAuth2、JWT。</li><li>核心：统一认证中心。</li></ul><hr><h2 id="24-配置中心的作用？"><a href="#24-配置中心的作用？" class="headerlink" title="24. 配置中心的作用？"></a><strong>24. 配置中心的作用？</strong></h2><ul><li>集中化配置管理。</li><li>支持动态刷新。</li><li>环境隔离（dev&#x2F;test&#x2F;prod）。</li></ul><hr><h2 id="25-微服务中的监控体系？"><a href="#25-微服务中的监控体系？" class="headerlink" title="25. 微服务中的监控体系？"></a><strong>25. 微服务中的监控体系？</strong></h2><ul><li>指标监控：Prometheus + Grafana。</li><li>日志监控：ELK（Elasticsearch + Logstash + Kibana）。</li><li>链路追踪：Sleuth + Zipkin&#x2F;Jaeger。</li></ul><hr><h2 id="26-Prometheus-的原理？"><a href="#26-Prometheus-的原理？" class="headerlink" title="26. Prometheus 的原理？"></a><strong>26. Prometheus 的原理？</strong></h2><ul><li>基于 Pull 模型，定期从应用&#x2F;Exporter 拉取指标。</li><li>TSDB（时间序列数据库）存储数据。</li><li>结合 Grafana 做可视化。</li></ul><hr><h2 id="27-ELK-在微服务中的应用？"><a href="#27-ELK-在微服务中的应用？" class="headerlink" title="27. ELK 在微服务中的应用？"></a><strong>27. ELK 在微服务中的应用？</strong></h2><ul><li>Logstash：日志采集。</li><li>Elasticsearch：日志存储、搜索。</li><li>Kibana：日志分析、可视化。</li><li>用于统一日志平台。</li></ul><hr><h2 id="28-服务调用链路追踪的意义？"><a href="#28-服务调用链路追踪的意义？" class="headerlink" title="28. 服务调用链路追踪的意义？"></a><strong>28. 服务调用链路追踪的意义？</strong></h2><ul><li>解决“调用链不清楚”的问题。</li><li>快速定位性能瓶颈、错误位置。</li><li>提升运维可观测性。</li></ul><hr><h2 id="29-服务雪崩效应是什么？"><a href="#29-服务雪崩效应是什么？" class="headerlink" title="29. 服务雪崩效应是什么？"></a><strong>29. 服务雪崩效应是什么？</strong></h2><ul><li>一个服务故障 → 引发调用它的服务故障 → 最终导致整个系统崩溃。</li><li>原因：依赖调用无保护（无熔断&#x2F;限流）。</li></ul><hr><h2 id="30-如何设计一个高并发的微服务系统？"><a href="#30-如何设计一个高并发的微服务系统？" class="headerlink" title="30. 如何设计一个高并发的微服务系统？"></a><strong>30. 如何设计一个高并发的微服务系统？</strong></h2><p><strong>核心思路</strong></p><ul><li>架构：微服务 + API 网关 + 服务治理。</li><li>高可用：负载均衡、多副本、自动故障转移。</li><li>高性能：缓存（Redis）、异步化、限流、降级。</li><li>数据层：分库分表、读写分离。</li><li>安全：OAuth2&#x2F;JWT。</li><li>可观测性：监控 + 日志 + 链路追踪。</li></ul><hr><h2 id="七、数据库-缓存（30题）"><a href="#七、数据库-缓存（30题）" class="headerlink" title="七、数据库 &amp; 缓存（30题）"></a>七、数据库 &amp; 缓存（30题）</h2><hr><h2 id="1-MySQL-的存储引擎区别"><a href="#1-MySQL-的存储引擎区别" class="headerlink" title="1. MySQL 的存储引擎区别"></a><strong>1. MySQL 的存储引擎区别</strong></h2><ul><li><strong>存储引擎</strong>是 MySQL 管理数据的底层组件，决定了数据存储方式、事务支持、锁机制、索引支持等。</li><li><strong>主要存储引擎</strong>：<ul><li><strong>InnoDB</strong>：事务型，支持行级锁、外键、MVCC、崩溃恢复。适合高并发、事务要求高的场景。</li><li><strong>MyISAM</strong>：非事务型，表级锁，支持全文索引。适合读多写少、日志或统计类表。</li><li><strong>Memory</strong>：数据存储在内存中，访问速度快，但断电数据丢失。适合临时表。</li><li><strong>Archive</strong>：归档引擎，只支持插入和查询，不支持更新，压缩存储。</li></ul></li><li><strong>面试重点</strong>：<ul><li>选择存储引擎需根据业务需求：事务要求、并发量、数据量和恢复策略。</li></ul></li></ul><hr><h2 id="2-InnoDB-和-MyISAM-的区别"><a href="#2-InnoDB-和-MyISAM-的区别" class="headerlink" title="2. InnoDB 和 MyISAM 的区别"></a><strong>2. InnoDB 和 MyISAM 的区别</strong></h2><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>事务</td><td>支持 ACID</td><td>不支持</td></tr><tr><td>锁类型</td><td>行级锁+表锁</td><td>表级锁</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>崩溃恢复</td><td>自动恢复</td><td>需手动修复</td></tr><tr><td>全文索引</td><td>5.6+ 支持</td><td>支持</td></tr><tr><td>并发场景</td><td>高并发写+读</td><td>读多写少</td></tr><tr><td>适用案例</td><td>金融、电商订单</td><td>日志分析、统计表</td></tr></tbody></table><hr><h2 id="3-MySQL-事务特性"><a href="#3-MySQL-事务特性" class="headerlink" title="3. MySQL 事务特性"></a><strong>3. MySQL 事务特性</strong></h2><ul><li><strong>ACID 原则</strong>：<ol><li><strong>原子性（Atomic）</strong>：事务全部执行或全部回滚。</li><li><strong>一致性（Consistency）</strong>：事务执行前后数据库状态合法。</li><li><strong>隔离性（Isolation）</strong>：事务互不干扰。</li><li><strong>持久性（Durability）</strong>：提交后数据不会丢失。</li></ol></li><li><strong>隔离级别</strong>：<ul><li><strong>Read Uncommitted</strong>：允许脏读。</li><li><strong>Read Committed</strong>：防止脏读，但可能不可重复读。</li><li><strong>Repeatable Read（默认 InnoDB）</strong>：防止不可重复读，间隙锁解决幻读。</li><li><strong>Serializable</strong>：完全串行执行，性能最低，但完全隔离。</li></ul></li><li><strong>面试追问</strong>：隔离级别与死锁、性能的权衡。</li></ul><hr><h2 id="4-MVCC-的实现原理"><a href="#4-MVCC-的实现原理" class="headerlink" title="4. MVCC 的实现原理"></a><strong>4. MVCC 的实现原理</strong></h2><ul><li><strong>原理</strong>：<ul><li>InnoDB 为每行增加隐藏列 <code>trx_id</code> 和 <code>roll_pointer</code>。</li><li>查询时根据事务 ID 判断哪一版本可见。</li><li>读操作不阻塞写操作，实现 <strong>非阻塞读</strong>。</li></ul></li><li><strong>应用</strong>：提高并发性能，避免读写互相阻塞。</li><li><strong>面试追问</strong>：MVCC 如何实现 Repeatable Read，为什么不锁表。</li></ul><hr><h2 id="5-MySQL-的索引类型"><a href="#5-MySQL-的索引类型" class="headerlink" title="5. MySQL 的索引类型"></a><strong>5. MySQL 的索引类型</strong></h2><ul><li><strong>B+ 树索引</strong>：范围查询、排序，叶子节点按顺序连接。</li><li><strong>哈希索引</strong>：精确查找快（Memory 引擎）。</li><li><strong>全文索引</strong>：文本搜索。</li><li><strong>空间索引</strong>：地理信息查询（R-Tree）。</li><li><strong>面试追问</strong>：什么时候选择组合索引，覆盖索引优化查询。</li></ul><hr><h2 id="6-聚簇索引-vs-非聚簇索引"><a href="#6-聚簇索引-vs-非聚簇索引" class="headerlink" title="6. 聚簇索引 vs 非聚簇索引"></a><strong>6. 聚簇索引 vs 非聚簇索引</strong></h2><ul><li><strong>聚簇索引</strong>：<ul><li>数据行存储顺序与主键顺序一致。</li><li>查询范围、排序效率高。</li></ul></li><li><strong>非聚簇索引</strong>：<ul><li>索引存 key + 主键，回表获取其他字段。</li></ul></li><li><strong>面试追问</strong>：聚簇索引插入顺序对性能影响，回表成本。</li></ul><hr><h2 id="7-B-树索引原理"><a href="#7-B-树索引原理" class="headerlink" title="7. B+ 树索引原理"></a><strong>7. B+ 树索引原理</strong></h2><ul><li>内节点：存 key + 子节点指针</li><li>叶子节点：存完整记录或指针，并链表连接</li><li><strong>特点</strong>：<ul><li>支持范围查询</li><li>磁盘 IO 高效</li></ul></li><li><strong>面试追问</strong>：为什么 MySQL 选择 B+ 树而不是 B 树或 Hash。</li></ul><hr><h2 id="8-覆盖索引-vs-回表"><a href="#8-覆盖索引-vs-回表" class="headerlink" title="8. 覆盖索引 vs 回表"></a><strong>8. 覆盖索引 vs 回表</strong></h2><ul><li><strong>覆盖索引</strong>：索引包含所有查询字段，无需访问表。</li><li><strong>回表</strong>：索引只包含部分字段，需要通过主键查表。</li><li><strong>优化方法</strong>：尽量让热点查询使用覆盖索引，减少 IO。</li></ul><hr><h2 id="9-索引下推优化"><a href="#9-索引下推优化" class="headerlink" title="9. 索引下推优化"></a><strong>9. 索引下推优化</strong></h2><ul><li>WHERE 条件在存储引擎层过滤，减少返回上层的数据量。</li><li>特别在组合索引或函数查询时有效。</li><li><strong>面试追问</strong>：索引下推能否应用于非 InnoDB 存储引擎。</li></ul><hr><h2 id="10-MySQL-锁机制"><a href="#10-MySQL-锁机制" class="headerlink" title="10. MySQL 锁机制"></a><strong>10. MySQL 锁机制</strong></h2><ul><li><strong>表锁</strong>：锁整张表，低并发。</li><li><strong>行锁</strong>：锁单行，InnoDB 默认。</li><li><strong>意向锁</strong>：表级锁意图，避免死锁。</li><li><strong>间隙锁</strong>：防止幻读。</li><li><strong>面试追问</strong>：行锁、表锁的实现原理，锁冲突如何处理。</li></ul><hr><h2 id="11-行锁-vs-表锁"><a href="#11-行锁-vs-表锁" class="headerlink" title="11. 行锁 vs 表锁"></a><strong>11. 行锁 vs 表锁</strong></h2><ul><li>行锁：粒度小，高并发，事务安全。</li><li>表锁：粒度大，适合批量操作。</li><li><strong>应用场景</strong>：高并发写用行锁，批量更新可用表锁。</li></ul><hr><h2 id="12-间隙锁"><a href="#12-间隙锁" class="headerlink" title="12. 间隙锁"></a><strong>12. 间隙锁</strong></h2><ul><li>锁定索引间隙，防止其他事务插入幻读。</li><li>与记录锁结合形成 <strong>Next-Key Lock</strong>。</li><li>默认在 Repeatable Read 下使用。</li></ul><hr><h2 id="13-死锁排查"><a href="#13-死锁排查" class="headerlink" title="13. 死锁排查"></a><strong>13. 死锁排查</strong></h2><ul><li><code>SHOW ENGINE INNODB STATUS\G</code> 查看最新死锁。</li><li>优化：<ol><li>统一访问表顺序。</li><li>尽量缩短事务时间。</li><li>加索引减少扫描行数。</li></ol></li></ul><hr><h2 id="14-SQL-执行计划"><a href="#14-SQL-执行计划" class="headerlink" title="14. SQL 执行计划"></a><strong>14. SQL 执行计划</strong></h2><ul><li>使用 <code>EXPLAIN</code> 分析：<ul><li>type：访问类型（ALL &lt; INDEX &lt; REF &lt; CONST）</li><li>key：使用的索引</li><li>rows：扫描行数</li><li>Extra：如 Using index, Using temporary</li></ul></li></ul><hr><h2 id="15-慢查询优化"><a href="#15-慢查询优化" class="headerlink" title="15. 慢查询优化"></a><strong>15. 慢查询优化</strong></h2><ul><li>建索引（覆盖索引、组合索引）</li><li>避免 SELECT *</li><li>避免在列上函数操作</li><li>分库分表</li><li>缓存（Redis&#x2F;Caffeine）</li></ul><hr><h2 id="16-分库分表难点"><a href="#16-分库分表难点" class="headerlink" title="16. 分库分表难点"></a><strong>16. 分库分表难点</strong></h2><ul><li>跨库 join、分页</li><li>分布式事务</li><li>全局唯一 ID</li><li>数据路由、迁移</li></ul><hr><h2 id="17-分布式事务"><a href="#17-分布式事务" class="headerlink" title="17. 分布式事务"></a><strong>17. 分布式事务</strong></h2><ul><li><strong>XA</strong>：两阶段提交，保证强一致性。</li><li><strong>TCC</strong>：Try → Confirm → Cancel，业务补偿操作。</li><li><strong>SAGA</strong>：长事务补偿。</li><li><strong>本地消息表 + MQ</strong>：最终一致性。</li></ul><hr><h2 id="18-Redis-数据结构"><a href="#18-Redis-数据结构" class="headerlink" title="18. Redis 数据结构"></a><strong>18. Redis 数据结构</strong></h2><ul><li><strong>String</strong>、<strong>Hash</strong>、<strong>List</strong>、<strong>Set</strong>、<strong>Sorted Set</strong></li><li>Bitmap、HyperLogLog、Geo</li><li>应用：排行榜、计数、集合操作、地理位置、布隆过滤器</li></ul><hr><h2 id="19-Redis-为什么快"><a href="#19-Redis-为什么快" class="headerlink" title="19. Redis 为什么快"></a><strong>19. Redis 为什么快</strong></h2><ul><li>全内存存储</li><li>单线程 + epoll</li><li>高效数据结构</li><li>避免锁竞争</li></ul><hr><h2 id="20-Redis-持久化"><a href="#20-Redis-持久化" class="headerlink" title="20. Redis 持久化"></a><strong>20. Redis 持久化</strong></h2><ul><li><strong>RDB</strong>：定期快照</li><li><strong>AOF</strong>：写命令日志，append only</li><li><strong>混合持久化</strong>：RDB + AOF，提高安全性与效率</li></ul><hr><h2 id="21-Redis-过期策略"><a href="#21-Redis-过期策略" class="headerlink" title="21. Redis 过期策略"></a><strong>21. Redis 过期策略</strong></h2><ul><li><strong>惰性删除</strong>：访问时检查 TTL</li><li><strong>定期删除</strong>：周期性扫描</li><li><strong>定时删除</strong>：每个 key 单独定时器</li></ul><hr><h2 id="22-Redis-内存淘汰策略"><a href="#22-Redis-内存淘汰策略" class="headerlink" title="22. Redis 内存淘汰策略"></a><strong>22. Redis 内存淘汰策略</strong></h2><ul><li>noeviction、allkeys-lru、volatile-lru、allkeys-lfu、volatile-ttl</li><li>LRU：最近最少使用</li><li>LFU：使用频率最低</li><li>TTL：临期优先淘汰</li></ul><hr><h2 id="23-Redis-主从复制"><a href="#23-Redis-主从复制" class="headerlink" title="23. Redis 主从复制"></a><strong>23. Redis 主从复制</strong></h2><ul><li>异步复制</li><li>全量复制 + 增量复制</li><li>读写分离，提升扩展性</li></ul><hr><h2 id="24-Redis-哨兵机制"><a href="#24-Redis-哨兵机制" class="headerlink" title="24. Redis 哨兵机制"></a><strong>24. Redis 哨兵机制</strong></h2><ul><li>监控、通知、故障转移</li><li>Sentinel 投票机制切换主节点</li><li>高可用架构核心组件</li></ul><hr><h2 id="25-Redis-集群模式"><a href="#25-Redis-集群模式" class="headerlink" title="25. Redis 集群模式"></a><strong>25. Redis 集群模式</strong></h2><ul><li>16384 个哈希槽分片</li><li>Master + Slave</li><li>跨槽操作有限制</li><li>高可用 + 水平扩展</li></ul><hr><h2 id="26-Redis-分布式锁"><a href="#26-Redis-分布式锁" class="headerlink" title="26. Redis 分布式锁"></a><strong>26. Redis 分布式锁</strong></h2><ul><li><strong>单机</strong>：SETNX + EXPIRE</li><li><strong>Redisson</strong>：<ul><li>自动续期（看门狗机制）</li><li>可重入锁</li><li>公平锁</li></ul></li><li><strong>RedLock</strong>：多节点强一致性</li></ul><hr><h2 id="27-Redis-常见问题"><a href="#27-Redis-常见问题" class="headerlink" title="27. Redis 常见问题"></a><strong>27. Redis 常见问题</strong></h2><ul><li>内存不足 &#x2F; OOM</li><li>热点 key</li><li>bigkey 导致阻塞</li><li>RDB fork 阻塞</li><li>主从延迟</li></ul><hr><h2 id="28-缓存穿透、击穿、雪崩"><a href="#28-缓存穿透、击穿、雪崩" class="headerlink" title="28. 缓存穿透、击穿、雪崩"></a><strong>28. 缓存穿透、击穿、雪崩</strong></h2><ul><li><strong>穿透</strong>：不存在数据频繁访问 → 布隆过滤器</li><li><strong>击穿</strong>：热点 key 瞬间失效 → 互斥锁&#x2F;永不过期缓存</li><li><strong>雪崩</strong>：大量 key 同时过期 → TTL + 随机值</li></ul><hr><h2 id="29-缓存与数据库一致性"><a href="#29-缓存与数据库一致性" class="headerlink" title="29. 缓存与数据库一致性"></a><strong>29. 缓存与数据库一致性</strong></h2><ul><li><strong>Cache Aside</strong>：先 DB，再删缓存</li><li><strong>双写</strong>：DB + 缓存同步更新</li><li><strong>异步消息</strong>：MQ + 延时队列，实现最终一致性</li></ul><hr><h2 id="30-Redis-vs-Caffeine"><a href="#30-Redis-vs-Caffeine" class="headerlink" title="30. Redis vs Caffeine"></a><strong>30. Redis vs Caffeine</strong></h2><table><thead><tr><th>特性</th><th>Redis</th><th>Caffeine</th></tr></thead><tbody><tr><td>类型</td><td>分布式缓存</td><td>本地缓存</td></tr><tr><td>持久化</td><td>RDB &#x2F; AOF</td><td>不支持</td></tr><tr><td>集群</td><td>支持</td><td>不支持</td></tr><tr><td>访问速度</td><td>毫秒级</td><td>纳秒级</td></tr><tr><td>场景</td><td>分布式共享，高并发</td><td>本地热点缓存</td></tr></tbody></table><p><strong>最佳实践</strong>：Caffeine（本地缓存）+ Redis（分布式缓存）+ DB → 多级缓存结构。</p><hr><h2 id="八、消息队列（30题）"><a href="#八、消息队列（30题）" class="headerlink" title="八、消息队列（30题）"></a>八、消息队列（30题）</h2><hr><h2 id="1-为什么要使用消息队列？"><a href="#1-为什么要使用消息队列？" class="headerlink" title="1. 为什么要使用消息队列？"></a><strong>1. 为什么要使用消息队列？</strong></h2><ul><li><strong>解耦系统</strong>：生产者与消费者不直接调用，通过队列传递消息。</li><li><strong>异步处理</strong>：用户请求不等待后端业务完成，提高响应速度。</li><li><strong>削峰填谷</strong>：缓冲高峰流量，避免数据库或服务压力过大。</li><li><strong>可靠传输</strong>：通过持久化、ACK 机制保证消息不丢失。</li><li><strong>可扩展性</strong>：增加消费者可水平扩展，提高系统吞吐量。</li><li><strong>面试追问</strong>：为什么 MQ 可以解决微服务间耦合问题？</li></ul><hr><h2 id="2-消息队列的优缺点"><a href="#2-消息队列的优缺点" class="headerlink" title="2. 消息队列的优缺点"></a><strong>2. 消息队列的优缺点</strong></h2><ul><li><strong>优点</strong>：<ul><li>异步处理提升吞吐量</li><li>系统解耦</li><li>支持削峰填谷</li><li>消息可靠性可控</li></ul></li><li><strong>缺点</strong>：<ul><li>系统复杂度增加</li><li>消息延迟</li><li>顺序和重复消费需要额外处理</li></ul></li><li><strong>优化点</strong>：结合幂等设计、延迟队列和批量处理</li></ul><hr><h2 id="3-RabbitMQ-核心组件"><a href="#3-RabbitMQ-核心组件" class="headerlink" title="3. RabbitMQ 核心组件"></a><strong>3. RabbitMQ 核心组件</strong></h2><ul><li><strong>Producer</strong>：发送消息</li><li><strong>Exchange</strong>：路由消息（Direct、Fanout、Topic、Headers）</li><li><strong>Queue</strong>：存储消息</li><li><strong>Binding</strong>：绑定 Exchange 和 Queue</li><li><strong>Consumer</strong>：接收消息</li><li><strong>原理</strong>：Exchange 决定路由规则，Queue 负责缓冲和投递</li></ul><hr><h2 id="4-RabbitMQ-消息确认机制"><a href="#4-RabbitMQ-消息确认机制" class="headerlink" title="4. RabbitMQ 消息确认机制"></a><strong>4. RabbitMQ 消息确认机制</strong></h2><ul><li><strong>生产者端</strong>：<ul><li>Publisher Confirm，确保消息写入 Broker</li></ul></li><li><strong>消费者端</strong>：<ul><li>自动 ack：消费即确认</li><li>手动 ack：成功处理后确认</li></ul></li><li><strong>应用实践</strong>：手动 ack 可处理异常重试，保证消息不丢失</li></ul><hr><h2 id="5-Kafka-核心概念"><a href="#5-Kafka-核心概念" class="headerlink" title="5. Kafka 核心概念"></a><strong>5. Kafka 核心概念</strong></h2><ul><li><strong>Producer&#x2F;Consumer</strong>：消息发送和接收</li><li><strong>Topic&#x2F;Partition</strong>：主题和分区</li><li><strong>Broker&#x2F;Cluster</strong>：节点和集群</li><li><strong>Consumer Group</strong>：消费组实现负载均衡</li><li><strong>Offset</strong>：记录消费位置</li><li><strong>原理</strong>：生产者写入 Partition，消费者根据 Offset 消费</li></ul><hr><h2 id="6-Kafka-分区机制"><a href="#6-Kafka-分区机制" class="headerlink" title="6. Kafka 分区机制"></a><strong>6. Kafka 分区机制</strong></h2><ul><li><strong>Partition 提高并行</strong></li><li><strong>分区内顺序保证</strong></li><li><strong>路由策略</strong>：默认轮询，或 Key 哈希分区</li><li><strong>面试点</strong>：如何保证全局顺序？只能保证分区内顺序</li></ul><hr><h2 id="7-Kafka-副本机制"><a href="#7-Kafka-副本机制" class="headerlink" title="7. Kafka 副本机制"></a><strong>7. Kafka 副本机制</strong></h2><ul><li><strong>Leader&#x2F;Follower 结构</strong></li><li><strong>同步机制</strong>：ISR 列表跟随 Leader</li><li><strong>高可用</strong>：Leader 异常自动切换</li><li><strong>面试拓展</strong>：副本同步模式对性能的影响</li></ul><hr><h2 id="8-Kafka-ISR-原理"><a href="#8-Kafka-ISR-原理" class="headerlink" title="8. Kafka ISR 原理"></a><strong>8. Kafka ISR 原理</strong></h2><ul><li><strong>ISR（In-Sync Replicas）</strong>：跟上 Leader 的副本集合</li><li><strong>消息提交规则</strong>：只要 ISR 内副本写入才算成功</li><li><strong>优化</strong>：副本数量与 ACK 策略可调节可靠性与吞吐量</li></ul><hr><h2 id="9-Kafka-消费组原理"><a href="#9-Kafka-消费组原理" class="headerlink" title="9. Kafka 消费组原理"></a><strong>9. Kafka 消费组原理</strong></h2><ul><li>同一组内的每个 Partition 只被一个 Consumer 消费</li><li>多组可重复消费，实现广播</li><li>提高并行消费，减少重复消费</li><li><strong>拓展</strong>：消费组重平衡、再均衡机制</li></ul><hr><h2 id="10-Kafka-Offset-提交方式"><a href="#10-Kafka-Offset-提交方式" class="headerlink" title="10. Kafka Offset 提交方式"></a><strong>10. Kafka Offset 提交方式</strong></h2><ul><li>自动提交：消费完成后自动提交 Offset</li><li>手动提交：<ul><li>同步提交：阻塞等待</li><li>异步提交：性能高，可能丢少量消息</li></ul></li><li><strong>实践</strong>：结合事务实现 Exactly Once</li></ul><hr><h2 id="11-Kafka-高吞吐量原理"><a href="#11-Kafka-高吞吐量原理" class="headerlink" title="11. Kafka 高吞吐量原理"></a><strong>11. Kafka 高吞吐量原理</strong></h2><ul><li>顺序写磁盘，避免随机 IO</li><li>批量发送消息，减少网络开销</li><li>零拷贝机制，减少 CPU 消耗</li><li><strong>面试拓展</strong>：如何调整批量大小提高吞吐量</li></ul><hr><h2 id="12-Kafka-零拷贝机制"><a href="#12-Kafka-零拷贝机制" class="headerlink" title="12. Kafka 零拷贝机制"></a><strong>12. Kafka 零拷贝机制</strong></h2><ul><li>直接从磁盘 buffer 传到网络 buffer，无用户态复制</li><li>利用 sendfile() 提升大流量传输效率</li></ul><hr><h2 id="13-RocketMQ-核心特点"><a href="#13-RocketMQ-核心特点" class="headerlink" title="13. RocketMQ 核心特点"></a><strong>13. RocketMQ 核心特点</strong></h2><ul><li>高可靠，高性能</li><li>顺序消息、事务消息原生支持</li><li>Broker 无状态，易水平扩展</li><li>支持多语言客户端</li><li>消息存储：CommitLog + ConsumeQueue + IndexFile</li></ul><hr><h2 id="14-RocketMQ-顺序消息"><a href="#14-RocketMQ-顺序消息" class="headerlink" title="14. RocketMQ 顺序消息"></a><strong>14. RocketMQ 顺序消息</strong></h2><ul><li>通过 Key 哈希映射到队列</li><li>队列内顺序严格保证</li><li>应用场景：订单支付、流水处理</li></ul><hr><h2 id="15-RocketMQ-事务消息"><a href="#15-RocketMQ-事务消息" class="headerlink" title="15. RocketMQ 事务消息"></a><strong>15. RocketMQ 事务消息</strong></h2><ul><li><strong>半消息机制</strong>：<ol><li>发送半消息到 Broker</li><li>执行本地事务</li><li>提交或回滚消息</li></ol></li><li>保证分布式事务最终一致性</li></ul><hr><h2 id="16-如何保证消息不丢失"><a href="#16-如何保证消息不丢失" class="headerlink" title="16. 如何保证消息不丢失"></a><strong>16. 如何保证消息不丢失</strong></h2><ul><li><strong>生产者端</strong>：确认机制</li><li><strong>Broker端</strong>：消息持久化</li><li><strong>消费者端</strong>：手动 ack + 幂等消费</li></ul><hr><h2 id="17-如何保证消息不重复消费"><a href="#17-如何保证消息不重复消费" class="headerlink" title="17. 如何保证消息不重复消费"></a><strong>17. 如何保证消息不重复消费</strong></h2><ul><li>消息幂等：唯一 ID + 数据库唯一约束 + Redis 去重</li><li>Kafka Exactly Once + 事务处理</li></ul><hr><h2 id="18-如何保证消息有序"><a href="#18-如何保证消息有序" class="headerlink" title="18. 如何保证消息有序"></a><strong>18. 如何保证消息有序</strong></h2><ul><li><strong>Kafka</strong>：Partition 内顺序</li><li><strong>RocketMQ</strong>：队列内顺序</li><li><strong>注意</strong>：多 Partition 并行可能导致整体无序</li></ul><hr><h2 id="19-消息堆积解决办法"><a href="#19-消息堆积解决办法" class="headerlink" title="19. 消息堆积解决办法"></a><strong>19. 消息堆积解决办法</strong></h2><ul><li>增加消费者数量</li><li>扩展队列分区</li><li>流量削峰</li><li>消费端批量处理，提高吞吐量</li></ul><hr><h2 id="20-如何设计延迟队列"><a href="#20-如何设计延迟队列" class="headerlink" title="20. 如何设计延迟队列"></a><strong>20. 如何设计延迟队列</strong></h2><ul><li><strong>RabbitMQ</strong>：TTL + Dead Letter Queue</li><li><strong>Kafka</strong>：延迟消息插件 &#x2F; 时间轮</li><li><strong>Redis</strong>：SortedSet + 轮询</li><li><strong>场景</strong>：订单超时、短信延迟发送</li></ul><hr><h2 id="21-死信队列作用"><a href="#21-死信队列作用" class="headerlink" title="21. 死信队列作用"></a><strong>21. 死信队列作用</strong></h2><ul><li>消费失败消息收集到死信队列</li><li>支持重试、告警和问题排查</li><li>提高系统可靠性</li></ul><hr><h2 id="22-幂等实现方式"><a href="#22-幂等实现方式" class="headerlink" title="22. 幂等实现方式"></a><strong>22. 幂等实现方式</strong></h2><ul><li>消息唯一 ID</li><li>数据库唯一约束</li><li>Redis 去重缓存</li><li>本地事务结合 MQ 保证幂等</li></ul><hr><h2 id="23-消息队列限流方式"><a href="#23-消息队列限流方式" class="headerlink" title="23. 消息队列限流方式"></a><strong>23. 消息队列限流方式</strong></h2><ul><li>消费者限流：处理速率限制</li><li>生产者限流：令牌桶&#x2F;漏桶</li><li>Broker 队列容量限制 + 拒绝策略</li></ul><hr><h2 id="24-消息队列监控"><a href="#24-消息队列监控" class="headerlink" title="24. 消息队列监控"></a><strong>24. 消息队列监控</strong></h2><ul><li>消息堆积量</li><li>消费速率</li><li>Broker 健康状态</li><li>延迟时间</li><li>工具：Prometheus + Grafana、Kafka Manager、RocketMQ Console、RabbitMQ Management</li></ul><hr><h2 id="25-Kafka-vs-RabbitMQ"><a href="#25-Kafka-vs-RabbitMQ" class="headerlink" title="25. Kafka vs RabbitMQ"></a><strong>25. Kafka vs RabbitMQ</strong></h2><table><thead><tr><th>特性</th><th>Kafka</th><th>RabbitMQ</th></tr></thead><tbody><tr><td>模型</td><td>Pub&#x2F;Sub + Queue</td><td>AMQP</td></tr><tr><td>消息存储</td><td>持久化日志</td><td>队列存储</td></tr><tr><td>顺序保证</td><td>Partition 内顺序</td><td>队列顺序</td></tr><tr><td>高吞吐</td><td>高（批量 + 零拷贝）</td><td>中等</td></tr><tr><td>消费模式</td><td>Pull &#x2F; Push</td><td>Push</td></tr><tr><td>使用场景</td><td>大数据流、日志、事件驱动</td><td>任务队列、异步处理、可靠投递</td></tr></tbody></table><hr><h2 id="26-Kafka-vs-RocketMQ"><a href="#26-Kafka-vs-RocketMQ" class="headerlink" title="26. Kafka vs RocketMQ"></a><strong>26. Kafka vs RocketMQ</strong></h2><table><thead><tr><th>特性</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>顺序消息</td><td>Partition 内顺序</td><td>队列内顺序全局可控</td></tr><tr><td>事务消息</td><td>限制较多</td><td>原生支持</td></tr><tr><td>存储方式</td><td>CommitLog</td><td>CommitLog + ConsumeQueue + IndexFile</td></tr><tr><td>高可用</td><td>ISR + 副本</td><td>Master-Slave + HA</td></tr><tr><td>生态</td><td>Flink、Spark 集成</td><td>分布式事务、支付系统应用</td></tr></tbody></table><hr><h2 id="27-Pulsar-特点"><a href="#27-Pulsar-特点" class="headerlink" title="27. Pulsar 特点"></a><strong>27. Pulsar 特点</strong></h2><ul><li>多租户支持</li><li>持久化使用 BookKeeper</li><li>Topic 可分 Partition</li><li>支持事务、延迟消息</li><li>Push&#x2F;Pull 消费模式灵活</li></ul><hr><h2 id="28-消息中间件如何保证高可用"><a href="#28-消息中间件如何保证高可用" class="headerlink" title="28. 消息中间件如何保证高可用"></a><strong>28. 消息中间件如何保证高可用</strong></h2><ul><li>多副本 + 自动切换</li><li>Broker 集群</li><li>消息持久化</li><li>客户端重试</li><li>Zookeeper&#x2F;Controller 管理元数据</li></ul><hr><h2 id="29-消息队列水平扩展"><a href="#29-消息队列水平扩展" class="headerlink" title="29. 消息队列水平扩展"></a><strong>29. 消息队列水平扩展</strong></h2><ul><li>Kafka：增加 Partition &#x2F; Broker</li><li>RabbitMQ：集群 + Shovel&#x2F;Federation</li><li>RocketMQ：增加 Broker + Topic 分区</li><li><strong>注意</strong>：分区扩展可能影响顺序，需要 Key 路由</li></ul><hr><h2 id="30-消息队列-vs-事件总线"><a href="#30-消息队列-vs-事件总线" class="headerlink" title="30. 消息队列 vs 事件总线"></a><strong>30. 消息队列 vs 事件总线</strong></h2><ul><li>MQ：关注消息可靠性、顺序、确认</li><li>EventBus：关注解耦、广播、轻量级</li><li>MQ 偏向可靠持久化，EventBus 偏向系统内部事件触发</li></ul><hr><h2 id="九、DevOps-容器化（30题）"><a href="#九、DevOps-容器化（30题）" class="headerlink" title="九、DevOps &amp; 容器化（30题）"></a>九、DevOps &amp; 容器化（30题）</h2><hr><h2 id="1-CI-CD-的流程"><a href="#1-CI-CD-的流程" class="headerlink" title="1. CI&#x2F;CD 的流程"></a><strong>1. CI&#x2F;CD 的流程</strong></h2><ul><li><strong>CI（Continuous Integration，持续集成）</strong>：<ul><li>开发者提交代码 → 自动构建 → 自动单元测试 → 自动生成构建产物</li></ul></li><li><strong>CD（Continuous Delivery&#x2F;Deployment，持续交付&#x2F;部署）</strong>：<ul><li>自动部署到测试&#x2F;生产环境 → 自动化验证 → 生产发布</li></ul></li><li><strong>工具链</strong>：<ul><li>Jenkins、GitLab CI、Argo CD</li></ul></li><li><strong>实践要点</strong>：<ul><li>流程自动化</li><li>保证构建产物可回滚</li></ul></li><li><strong>面试拓展</strong>：CI&#x2F;CD 与 DevOps 的关系</li></ul><hr><h2 id="2-Jenkins-的作用"><a href="#2-Jenkins-的作用" class="headerlink" title="2. Jenkins 的作用"></a><strong>2. Jenkins 的作用</strong></h2><ul><li>自动化构建、测试、部署工具</li><li><strong>核心功能</strong>：<ul><li>支持多种 SCM（Git、SVN）</li><li>Pipeline 管理</li><li>插件生态丰富（Docker、K8s 集成）</li></ul></li><li><strong>面试追问</strong>：Pipeline 如何保证构建可重复、可回滚</li></ul><hr><h2 id="3-Docker-核心原理"><a href="#3-Docker-核心原理" class="headerlink" title="3. Docker 核心原理"></a><strong>3. Docker 核心原理</strong></h2><ul><li><strong>容器化技术</strong>：<ul><li>Linux <strong>namespace</strong> 隔离（进程、网络、文件系统）</li><li>Linux <strong>cgroups</strong> 限制资源（CPU、内存）</li><li>**联合文件系统（UnionFS）**实现镜像分层</li></ul></li><li><strong>容器 ≈ 轻量级虚拟机</strong>，共享宿主 OS 内核</li></ul><hr><h2 id="4-Docker-镜像-vs-容器"><a href="#4-Docker-镜像-vs-容器" class="headerlink" title="4. Docker 镜像 vs 容器"></a><strong>4. Docker 镜像 vs 容器</strong></h2><table><thead><tr><th>区别</th><th>镜像</th><th>容器</th></tr></thead><tbody><tr><td>定义</td><td>只读模板</td><td>镜像运行实例</td></tr><tr><td>存储</td><td>分层只读文件系统</td><td>读写层 + 镜像</td></tr><tr><td>生命周期</td><td>永久</td><td>临时，可停止&#x2F;删除</td></tr><tr><td>用途</td><td>构建应用</td><td>运行应用</td></tr></tbody></table><hr><h2 id="5-Dockerfile-常用指令"><a href="#5-Dockerfile-常用指令" class="headerlink" title="5. Dockerfile 常用指令"></a><strong>5. Dockerfile 常用指令</strong></h2><ul><li><code>FROM</code>：基础镜像</li><li><code>RUN</code>：执行命令构建镜像</li><li><code>COPY</code>&#x2F;<code>ADD</code>：复制文件到镜像</li><li><code>CMD</code>&#x2F;<code>ENTRYPOINT</code>：容器启动命令</li><li><code>EXPOSE</code>：声明端口</li><li><code>ENV</code>：环境变量</li><li><strong>优化</strong>：减少镜像层，顺序合理缓存</li></ul><hr><h2 id="6-镜像分层机制"><a href="#6-镜像分层机制" class="headerlink" title="6. 镜像分层机制"></a><strong>6. 镜像分层机制</strong></h2><ul><li>镜像每条指令生成一个只读层</li><li>联合文件系统（UnionFS）叠加这些层</li><li>容器启动时增加读写层</li><li><strong>优势</strong>：<ul><li>共享公共层，节省空间</li><li>支持增量构建</li></ul></li></ul><hr><h2 id="7-容器-vs-虚拟机"><a href="#7-容器-vs-虚拟机" class="headerlink" title="7. 容器 vs 虚拟机"></a><strong>7. 容器 vs 虚拟机</strong></h2><table><thead><tr><th>区别</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>内核</td><td>共享宿主 OS 内核</td><td>独立 OS</td></tr><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>资源占用</td><td>轻量</td><td>重量</td></tr><tr><td>隔离</td><td>进程级</td><td>硬件级</td></tr></tbody></table><hr><h2 id="8-Kubernetes-核心组件"><a href="#8-Kubernetes-核心组件" class="headerlink" title="8. Kubernetes 核心组件"></a><strong>8. Kubernetes 核心组件</strong></h2><ul><li><strong>Master</strong>：<ul><li>API Server：接收用户请求</li><li>Scheduler：Pod 调度</li><li>Controller Manager：状态管理</li><li>etcd：分布式配置存储</li></ul></li><li><strong>Node</strong>：<ul><li>Kubelet：Pod 生命周期管理</li><li>Kube-proxy：服务网络代理</li><li>Container Runtime（Docker&#x2F;CRI-O）</li></ul></li></ul><hr><h2 id="9-Pod-生命周期"><a href="#9-Pod-生命周期" class="headerlink" title="9. Pod 生命周期"></a><strong>9. Pod 生命周期</strong></h2><ul><li><strong>Pending</strong> → <strong>Running</strong> → <strong>Succeeded&#x2F;Failed</strong></li><li><strong>状态管理</strong>：<ul><li>initContainer → main container → postStop Hook</li></ul></li><li><strong>面试点</strong>：Pod 重启策略（Always&#x2F;OnFailure&#x2F;Never）</li></ul><hr><h2 id="10-Deployment-vs-StatefulSet"><a href="#10-Deployment-vs-StatefulSet" class="headerlink" title="10. Deployment vs StatefulSet"></a><strong>10. Deployment vs StatefulSet</strong></h2><table><thead><tr><th>特性</th><th>Deployment</th><th>StatefulSet</th></tr></thead><tbody><tr><td>Pod 标识</td><td>无固定名字</td><td>有固定名字</td></tr><tr><td>顺序更新</td><td>可并行更新</td><td>严格顺序更新</td></tr><tr><td>持久化存储</td><td>共享卷</td><td>独立持久卷</td></tr><tr><td>应用场景</td><td>无状态服务</td><td>数据库、Kafka Broker 等状态服务</td></tr></tbody></table><hr><h2 id="11-K8s-服务发现机制"><a href="#11-K8s-服务发现机制" class="headerlink" title="11. K8s 服务发现机制"></a><strong>11. K8s 服务发现机制</strong></h2><ul><li><strong>ClusterIP</strong>：集群内部访问</li><li><strong>NodePort</strong>：节点端口访问</li><li><strong>LoadBalancer</strong>：外部访问</li><li><strong>DNS + kube-proxy</strong>：Pod 名称解析 + iptables 转发</li></ul><hr><h2 id="12-ConfigMap-和-Secret"><a href="#12-ConfigMap-和-Secret" class="headerlink" title="12. ConfigMap 和 Secret"></a><strong>12. ConfigMap 和 Secret</strong></h2><table><thead><tr><th>特性</th><th>ConfigMap</th><th>Secret</th></tr></thead><tbody><tr><td>数据类型</td><td>明文配置</td><td>Base64 编码敏感信息</td></tr><tr><td>使用方式</td><td>Env&#x2F;Volume</td><td>Env&#x2F;Volume</td></tr><tr><td>安全性</td><td>不加密</td><td>加密可集成 KMS</td></tr></tbody></table><hr><h2 id="13-Ingress-的作用"><a href="#13-Ingress-的作用" class="headerlink" title="13. Ingress 的作用"></a><strong>13. Ingress 的作用</strong></h2><ul><li>集群外部访问 Pod 的入口</li><li>功能：<ul><li>路由到不同服务</li><li>TLS 终端</li><li>负载均衡</li></ul></li><li><strong>面试点</strong>：Ingress Controller vs Service LB</li></ul><hr><h2 id="14-K8s-水平扩缩容机制"><a href="#14-K8s-水平扩缩容机制" class="headerlink" title="14. K8s 水平扩缩容机制"></a><strong>14. K8s 水平扩缩容机制</strong></h2><ul><li><strong>HPA（Horizontal Pod Autoscaler）</strong>：根据 CPU、内存或自定义指标调整 Pod 数量</li><li><strong>VPA（Vertical Pod Autoscaler）</strong>：自动调整 Pod 资源配置</li><li><strong>Cluster Autoscaler</strong>：节点自动扩缩容</li></ul><hr><h2 id="15-K8s-滚动更新机制"><a href="#15-K8s-滚动更新机制" class="headerlink" title="15. K8s 滚动更新机制"></a><strong>15. K8s 滚动更新机制</strong></h2><ul><li><strong>Deployment</strong> 滚动更新策略：<ul><li><code>maxUnavailable</code>：最大不可用 Pod</li><li><code>maxSurge</code>：最大新增 Pod</li></ul></li><li><strong>保证无中断升级</strong></li></ul><hr><h2 id="16-K8s-灰度发布"><a href="#16-K8s-灰度发布" class="headerlink" title="16. K8s 灰度发布"></a><strong>16. K8s 灰度发布</strong></h2><ul><li><strong>方法</strong>：<ul><li>分流流量（Ingress&#x2F;Service Mesh）</li><li>多版本 Deployment</li><li>Canary Pod + 路由权重</li></ul></li></ul><hr><h2 id="17-K8s-调度策略"><a href="#17-K8s-调度策略" class="headerlink" title="17. K8s 调度策略"></a><strong>17. K8s 调度策略</strong></h2><ul><li><strong>默认调度</strong>：基于资源（CPU&#x2F;Memory）</li><li><strong>亲和性&#x2F;反亲和性</strong>：<ul><li>NodeAffinity</li><li>PodAffinity &#x2F; PodAntiAffinity</li></ul></li><li><strong>Taints &amp; Tolerations</strong>：节点污点控制 Pod 调度</li></ul><hr><h2 id="18-K8s-网络模型"><a href="#18-K8s-网络模型" class="headerlink" title="18. K8s 网络模型"></a><strong>18. K8s 网络模型</strong></h2><ul><li><strong>要求</strong>：<ul><li>Pod 可以直接互相通信</li><li>Pod 与 Node 通信</li></ul></li><li><strong>方案</strong>：<ul><li>Flannel、Calico、Cilium 等</li></ul></li><li><strong>面试点</strong>：Overlay 网络 vs Underlay 网络</li></ul><hr><h2 id="19-Service-Mesh-作用"><a href="#19-Service-Mesh-作用" class="headerlink" title="19. Service Mesh 作用"></a><strong>19. Service Mesh 作用</strong></h2><ul><li>透明通信管理</li><li>流量控制、熔断、限流</li><li>可观察性（Tracing、Metrics）</li><li>安全（mTLS）</li></ul><hr><h2 id="20-Istio-工作原理"><a href="#20-Istio-工作原理" class="headerlink" title="20. Istio 工作原理"></a><strong>20. Istio 工作原理</strong></h2><ul><li><strong>Sidecar Proxy</strong>：每个 Pod 注入 Envoy</li><li><strong>控制平面（Pilot）</strong>：下发路由规则</li><li><strong>Mixer &#x2F; Telemetry</strong>：采集指标和日志</li><li><strong>应用</strong>：<ul><li>灰度发布、流量镜像、故障注入、服务间安全通信</li></ul></li></ul><hr><h2 id="21-Helm-的作用"><a href="#21-Helm-的作用" class="headerlink" title="21. Helm 的作用"></a><strong>21. Helm 的作用</strong></h2><ul><li>Kubernetes 包管理工具</li><li><strong>功能</strong>：<ul><li>Chart 模板化部署</li><li>版本管理</li><li>一键升级&#x2F;回滚</li></ul></li><li><strong>面试拓展</strong>：Helm 与 Kustomize 区别</li></ul><hr><h2 id="22-K8s-存储方案"><a href="#22-K8s-存储方案" class="headerlink" title="22. K8s 存储方案"></a><strong>22. K8s 存储方案</strong></h2><ul><li><strong>临时存储</strong>：emptyDir</li><li><strong>持久卷</strong>：PersistentVolume + PersistentVolumeClaim</li><li><strong>存储类型</strong>：<ul><li>本地存储</li><li>NFS</li><li>Ceph &#x2F; GlusterFS</li><li>云存储（EBS、OSS）</li></ul></li></ul><hr><h2 id="23-Prometheus-监控体系"><a href="#23-Prometheus-监控体系" class="headerlink" title="23. Prometheus 监控体系"></a><strong>23. Prometheus 监控体系</strong></h2><ul><li>Pull 模型采集指标</li><li>TSDB 存储时间序列数据</li><li>AlertManager 告警</li><li>可监控 K8s 组件、Pod、应用指标</li></ul><hr><h2 id="24-Grafana-的作用"><a href="#24-Grafana-的作用" class="headerlink" title="24. Grafana 的作用"></a><strong>24. Grafana 的作用</strong></h2><ul><li>可视化 Prometheus 数据</li><li>仪表盘定制</li><li>支持多数据源（InfluxDB、ElasticSearch）</li><li>面试点：报警可视化和多租户支持</li></ul><hr><h2 id="25-K8s-安全机制"><a href="#25-K8s-安全机制" class="headerlink" title="25. K8s 安全机制"></a><strong>25. K8s 安全机制</strong></h2><ul><li><strong>认证（Authentication）</strong>：Token &#x2F; X.509 &#x2F; OIDC</li><li><strong>授权（Authorization）</strong>：RBAC</li><li><strong>网络策略（NetworkPolicy）</strong></li><li><strong>Secret 加密</strong></li></ul><hr><h2 id="26-容器资源限制"><a href="#26-容器资源限制" class="headerlink" title="26. 容器资源限制"></a><strong>26. 容器资源限制</strong></h2><ul><li><strong>CPU &#x2F; Memory</strong>：requests &#x2F; limits</li><li><strong>QoS 分类</strong>：<ul><li>Guaranteed、Burstable、BestEffort</li></ul></li><li><strong>面试点</strong>：容器 OOM 及限流策略</li></ul><hr><h2 id="27-Docker-Compose-作用"><a href="#27-Docker-Compose-作用" class="headerlink" title="27. Docker Compose 作用"></a><strong>27. Docker Compose 作用</strong></h2><ul><li>多容器应用管理</li><li>本地开发、测试</li><li>声明式配置网络、依赖关系</li></ul><hr><h2 id="28-DevOps-最佳实践"><a href="#28-DevOps-最佳实践" class="headerlink" title="28. DevOps 最佳实践"></a><strong>28. DevOps 最佳实践</strong></h2><ul><li>持续集成&#x2F;持续交付</li><li>基础设施即代码（IaC）</li><li>自动化测试与部署</li><li>微服务 + 容器化 + 云原生</li></ul><hr><h2 id="29-GitOps-理念"><a href="#29-GitOps-理念" class="headerlink" title="29. GitOps 理念"></a><strong>29. GitOps 理念</strong></h2><ul><li>将 Git 作为单一真源</li><li>K8s 自动同步 Git 状态</li><li>优点：<ul><li>可追踪、可回滚</li><li>流程统一、可审计</li></ul></li></ul><hr><h2 id="30-K8s-如何保证高可用"><a href="#30-K8s-如何保证高可用" class="headerlink" title="30. K8s 如何保证高可用"></a><strong>30. K8s 如何保证高可用</strong></h2><ul><li>Master 节点多副本（HA）</li><li>ETCD 集群存储</li><li>Pod 多副本 + Deployment&#x2F;StatefulSet</li><li>Service + LoadBalancer 提供稳定访问</li><li>Cluster Autoscaler 支持节点弹性扩展</li></ul><hr><h2 id="十、场景设计题（30题）"><a href="#十、场景设计题（30题）" class="headerlink" title="十、场景设计题（30题）"></a>十、场景设计题（30题）</h2><ol><li>如何设计一个秒杀系统？</li><li>如何设计一个短链系统？</li><li>如何设计一个分布式 ID 生成系统？</li><li>如何设计一个高可用缓存系统？</li><li>如何设计一个订单系统？</li><li>如何设计一个支付系统？</li><li>如何设计一个消息推送系统？</li><li>如何设计一个日志收集系统？</li><li>如何设计一个搜索引擎？</li><li>如何设计一个推荐系统？</li><li>如何设计一个分布式锁？</li><li>如何设计一个统一鉴权系统？</li><li>如何设计一个限流系统？</li><li>如何设计一个灰度发布系统？</li><li>如何设计一个电商购物车？</li><li>如何设计一个库存系统？</li><li>如何设计一个分布式文件存储系统？</li><li>如何设计一个微服务网关？</li><li>如何设计一个分布式任务调度系统？</li><li>如何设计一个监控报警系统？</li><li>如何设计一个高并发聊天室？</li><li>如何设计一个排行榜系统？</li><li>如何设计一个评论系统？</li><li>如何设计一个分布式事务系统？</li><li>如何设计一个高可用注册中心？</li><li>如何设计一个数据同步系统？</li><li>如何设计一个 API 限速系统？</li><li>如何设计一个高可用的支付网关？</li><li>如何设计一个跨境电商架构？</li><li>如何设计一个金融级别的微服务系统？</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/09/11/hello-world/"/>
      <url>/2025/09/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

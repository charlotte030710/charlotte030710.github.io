<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>框架常用注解 | 浮生若梦</title><meta name="author" content="Charlotte"><meta name="copyright" content="Charlotte"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="🧩 一、Spring 常用注解（IOC &#x2F; AOP 核心）💠 1. IOC 相关（控制反转）   注解 作用 场景    @Component 标识一个普通组件，交给 Spring 容器管理 普通类   @Controller 表示控制层组件 Web 控制器   @Service 表示服务层组件 业务逻辑层   @Repository 表示 DAO 层组件 数据访问层   @Aut">
<meta property="og:type" content="article">
<meta property="og:title" content="框架常用注解">
<meta property="og:url" content="https://charlotte030710.github.io/2025/10/01/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/index.html">
<meta property="og:site_name" content="浮生若梦">
<meta property="og:description" content="🧩 一、Spring 常用注解（IOC &#x2F; AOP 核心）💠 1. IOC 相关（控制反转）   注解 作用 场景    @Component 标识一个普通组件，交给 Spring 容器管理 普通类   @Controller 表示控制层组件 Web 控制器   @Service 表示服务层组件 业务逻辑层   @Repository 表示 DAO 层组件 数据访问层   @Aut">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://charlotte030710.github.io/img/title.jpg">
<meta property="article:published_time" content="2025-09-30T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-05T10:52:17.248Z">
<meta property="article:author" content="Charlotte">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://charlotte030710.github.io/img/title.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "框架常用注解",
  "url": "https://charlotte030710.github.io/2025/10/01/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/",
  "image": "https://charlotte030710.github.io/img/title.jpg",
  "datePublished": "2025-09-30T16:00:00.000Z",
  "dateModified": "2025-10-05T10:52:17.248Z",
  "author": [
    {
      "@type": "Person",
      "name": "Charlotte",
      "url": "https://charlotte030710.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="https://charlotte030710.github.io/2025/10/01/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '框架常用注解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="浮生若梦" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/title.jpg" alt="Logo"><span class="site-name">浮生若梦</span></a><a class="nav-page-title" href="/"><span class="site-name">框架常用注解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">框架常用注解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-30T16:00:00.000Z" title="发表于 2025-10-01 00:00:00">2025-10-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-05T10:52:17.248Z" title="更新于 2025-10-05 18:52:17">2025-10-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<h1 id="🧩-一、Spring-常用注解（IOC-AOP-核心）"><a href="#🧩-一、Spring-常用注解（IOC-AOP-核心）" class="headerlink" title="🧩 一、Spring 常用注解（IOC &#x2F; AOP 核心）"></a>🧩 一、Spring 常用注解（IOC &#x2F; AOP 核心）</h1><h3 id="💠-1-IOC-相关（控制反转）"><a href="#💠-1-IOC-相关（控制反转）" class="headerlink" title="💠 1. IOC 相关（控制反转）"></a>💠 1. IOC 相关（控制反转）</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Component</code></td>
<td>标识一个普通组件，交给 Spring 容器管理</td>
<td>普通类</td>
</tr>
<tr>
<td><code>@Controller</code></td>
<td>表示控制层组件</td>
<td>Web 控制器</td>
</tr>
<tr>
<td><code>@Service</code></td>
<td>表示服务层组件</td>
<td>业务逻辑层</td>
</tr>
<tr>
<td><code>@Repository</code></td>
<td>表示 DAO 层组件</td>
<td>数据访问层</td>
</tr>
<tr>
<td><code>@Autowired</code></td>
<td>按类型自动注入</td>
<td>字段、构造器、setter</td>
</tr>
<tr>
<td><code>@Qualifier</code></td>
<td>与 <code>@Autowired</code> 联合使用，按名称注入</td>
<td>解决多个 Bean 同类型冲突</td>
</tr>
<tr>
<td><code>@Resource</code></td>
<td>JSR-250 标准注入，按名称优先</td>
<td>同上</td>
</tr>
<tr>
<td><code>@Value</code></td>
<td>注入配置文件中的属性值</td>
<td>常量、配置字段</td>
</tr>
<tr>
<td><code>@Primary</code></td>
<td>指定优先注入的 Bean</td>
<td>同类型 Bean 多个时</td>
</tr>
<tr>
<td><code>@Lazy</code></td>
<td>延迟加载 Bean</td>
<td>优化启动性能</td>
</tr>
</tbody></table>
<hr>
<h3 id="💠-2-AOP-相关（切面编程）"><a href="#💠-2-AOP-相关（切面编程）" class="headerlink" title="💠 2. AOP 相关（切面编程）"></a>💠 2. AOP 相关（切面编程）</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Aspect</code></td>
<td>声明一个切面类</td>
<td>AOP 切面定义</td>
</tr>
<tr>
<td><code>@Before</code></td>
<td>方法执行前执行通知</td>
<td>前置通知</td>
</tr>
<tr>
<td><code>@After</code></td>
<td>方法执行后执行通知</td>
<td>后置通知（无论异常）</td>
</tr>
<tr>
<td><code>@AfterReturning</code></td>
<td>方法成功返回后执行</td>
<td>返回通知</td>
</tr>
<tr>
<td><code>@AfterThrowing</code></td>
<td>方法异常时执行</td>
<td>异常通知</td>
</tr>
<tr>
<td><code>@Around</code></td>
<td>包裹整个方法（可控制执行时机）</td>
<td>性能监控、事务控制</td>
</tr>
<tr>
<td><code>@Pointcut</code></td>
<td>定义切入点表达式</td>
<td>统一复用表达式</td>
</tr>
</tbody></table>
<hr>
<h3 id="💠-3-配置相关"><a href="#💠-3-配置相关" class="headerlink" title="💠 3. 配置相关"></a>💠 3. 配置相关</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Configuration</code></td>
<td>声明配置类（代替 XML）</td>
<td>JavaConfig</td>
</tr>
<tr>
<td><code>@Bean</code></td>
<td>注册一个 Bean 到容器</td>
<td>配合 <code>@Configuration</code></td>
</tr>
<tr>
<td><code>@Import</code></td>
<td>导入额外配置类</td>
<td>组合配置</td>
</tr>
<tr>
<td><code>@PropertySource</code></td>
<td>加载外部 properties 文件</td>
<td>读取配置</td>
</tr>
<tr>
<td><code>@ComponentScan</code></td>
<td>扫描指定包</td>
<td>注册组件</td>
</tr>
<tr>
<td><code>@Conditional</code></td>
<td>条件加载 Bean</td>
<td>动态配置</td>
</tr>
</tbody></table>
<hr>
<h1 id="🌐-二、Spring-MVC-常用注解"><a href="#🌐-二、Spring-MVC-常用注解" class="headerlink" title="🌐 二、Spring MVC 常用注解"></a>🌐 二、Spring MVC 常用注解</h1><h3 id="💠-1-控制层映射"><a href="#💠-1-控制层映射" class="headerlink" title="💠 1. 控制层映射"></a>💠 1. 控制层映射</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Controller</code></td>
<td>定义控制器类</td>
<td>Web 层</td>
</tr>
<tr>
<td><code>@RestController</code></td>
<td>等价于 <code>@Controller + @ResponseBody</code></td>
<td>REST 接口</td>
</tr>
<tr>
<td><code>@RequestMapping</code></td>
<td>定义请求路径、方法</td>
<td>类或方法级别</td>
</tr>
<tr>
<td><code>@GetMapping</code> &#x2F; <code>@PostMapping</code> &#x2F; <code>@PutMapping</code> &#x2F; <code>@DeleteMapping</code></td>
<td>简化版请求映射</td>
<td>REST 风格接口</td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>获取请求参数</td>
<td><code>?name=xxx</code></td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>获取路径参数</td>
<td><code>/user/&#123;id&#125;</code></td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>将 JSON 请求体映射为对象</td>
<td>POST JSON 请求</td>
</tr>
<tr>
<td><code>@ResponseBody</code></td>
<td>将返回值序列化为 JSON</td>
<td>REST 返回</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>绑定模型数据或方法参数</td>
<td>表单提交</td>
</tr>
<tr>
<td><code>@SessionAttributes</code></td>
<td>将数据保存到 session</td>
<td>登录状态存储</td>
</tr>
</tbody></table>
<h3 id="💠-2-异常-返回处理"><a href="#💠-2-异常-返回处理" class="headerlink" title="💠 2. 异常 &amp; 返回处理"></a>💠 2. 异常 &amp; 返回处理</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>@ControllerAdvice</code></td>
<td>全局异常处理类</td>
<td>全局控制器拦截</td>
</tr>
<tr>
<td><code>@ExceptionHandler</code></td>
<td>指定异常处理方法</td>
<td>捕获异常</td>
</tr>
<tr>
<td><code>@ResponseStatus</code></td>
<td>设置响应状态码</td>
<td>返回状态控制</td>
</tr>
<tr>
<td><code>@InitBinder</code></td>
<td>初始化数据绑定器</td>
<td>参数转换</td>
</tr>
</tbody></table>
<hr>
<h1 id="💾-三、MyBatis-常用注解"><a href="#💾-三、MyBatis-常用注解" class="headerlink" title="💾 三、MyBatis 常用注解"></a>💾 三、MyBatis 常用注解</h1><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Mapper</code></td>
<td>标识为 MyBatis 映射接口</td>
<td>DAO 层接口</td>
</tr>
<tr>
<td><code>@Select</code> &#x2F; <code>@Insert</code> &#x2F; <code>@Update</code> &#x2F; <code>@Delete</code></td>
<td>编写 SQL 语句</td>
<td>简单查询或更新</td>
</tr>
<tr>
<td><code>@Results</code> &#x2F; <code>@Result</code></td>
<td>字段映射</td>
<td>数据库字段与实体字段名不同</td>
</tr>
<tr>
<td><code>@Param</code></td>
<td>指定 SQL 参数名</td>
<td>多参数方法</td>
</tr>
<tr>
<td><code>@Options</code></td>
<td>设置主键回填、事务行为等</td>
<td>插入时主键自动生成</td>
</tr>
<tr>
<td><code>@MapKey</code></td>
<td>指定返回 Map 的 key</td>
<td>查询结果 Map 化</td>
</tr>
</tbody></table>
<hr>
<h1 id="🚀-四、Spring-Boot-常用注解"><a href="#🚀-四、Spring-Boot-常用注解" class="headerlink" title="🚀 四、Spring Boot 常用注解"></a>🚀 四、Spring Boot 常用注解</h1><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>@SpringBootApplication</code></td>
<td>核心入口（含 <code>@Configuration</code>, <code>@EnableAutoConfiguration</code>, <code>@ComponentScan</code>）</td>
<td>启动类</td>
</tr>
<tr>
<td><code>@EnableAutoConfiguration</code></td>
<td>启用自动配置</td>
<td>底层自动装配</td>
</tr>
<tr>
<td><code>@ConfigurationProperties</code></td>
<td>将配置文件映射为对象</td>
<td>封装配置类</td>
</tr>
<tr>
<td><code>@EnableConfigurationProperties</code></td>
<td>开启上面映射功能</td>
<td>配置类启用</td>
</tr>
<tr>
<td><code>@ConditionalOnProperty</code></td>
<td>当某配置满足时加载 Bean</td>
<td>条件化配置</td>
</tr>
<tr>
<td><code>@ConditionalOnMissingBean</code></td>
<td>Bean 不存在时加载</td>
<td>自动配置</td>
</tr>
<tr>
<td><code>@SpringBootTest</code></td>
<td>启动完整 Spring Boot 测试环境</td>
<td>单元测试</td>
</tr>
<tr>
<td><code>@TestConfiguration</code></td>
<td>测试专用配置</td>
<td>隔离测试 Bean</td>
</tr>
<tr>
<td><code>@RestControllerAdvice</code></td>
<td>全局异常 + REST 接口</td>
<td>统一异常返回 JSON</td>
</tr>
</tbody></table>
<hr>
<h1 id="🔐-五、Spring-Security-常用注解"><a href="#🔐-五、Spring-Security-常用注解" class="headerlink" title="🔐 五、Spring Security 常用注解"></a>🔐 五、Spring Security 常用注解</h1><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>@EnableWebSecurity</code></td>
<td>开启 Web 安全配置</td>
<td>Security 配置类</td>
</tr>
<tr>
<td><code>@Configuration</code></td>
<td>标识配置类</td>
<td></td>
</tr>
<tr>
<td><code>@PreAuthorize</code></td>
<td>方法执行前验证权限</td>
<td>细粒度控制（SpEL 表达式）</td>
</tr>
<tr>
<td><code>@PostAuthorize</code></td>
<td>方法执行后再验证权限</td>
<td>返回后检查</td>
</tr>
<tr>
<td><code>@Secured</code></td>
<td>指定角色访问权限</td>
<td>简单权限控制</td>
</tr>
<tr>
<td><code>@RolesAllowed</code></td>
<td>与 <code>@Secured</code> 类似（JSR-250）</td>
<td>指定角色</td>
</tr>
<tr>
<td><code>@WithMockUser</code></td>
<td>测试时模拟登录用户</td>
<td>单元测试</td>
</tr>
<tr>
<td><code>@AuthenticationPrincipal</code></td>
<td>获取当前登录用户</td>
<td>Controller 层</td>
</tr>
</tbody></table>
<hr>
<h1 id="☁️-六、Spring-Cloud-常用注解（微服务体系）"><a href="#☁️-六、Spring-Cloud-常用注解（微服务体系）" class="headerlink" title="☁️ 六、Spring Cloud 常用注解（微服务体系）"></a>☁️ 六、Spring Cloud 常用注解（微服务体系）</h1><h3 id="💠-1-服务注册与发现（Eureka-Nacos）"><a href="#💠-1-服务注册与发现（Eureka-Nacos）" class="headerlink" title="💠 1. 服务注册与发现（Eureka &#x2F; Nacos）"></a>💠 1. 服务注册与发现（Eureka &#x2F; Nacos）</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@EnableEurekaClient</code> &#x2F; <code>@EnableDiscoveryClient</code></td>
<td>启用服务注册与发现</td>
</tr>
<tr>
<td><code>@LoadBalanced</code></td>
<td>启用 Ribbon 负载均衡</td>
</tr>
<tr>
<td><code>@Value</code> &#x2F; <code>@RefreshScope</code></td>
<td>动态刷新配置（与 Config 一起）</td>
</tr>
</tbody></table>
<h3 id="💠-2-服务调用（OpenFeign）"><a href="#💠-2-服务调用（OpenFeign）" class="headerlink" title="💠 2. 服务调用（OpenFeign）"></a>💠 2. 服务调用（OpenFeign）</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@EnableFeignClients</code></td>
<td>开启 Feign 客户端</td>
</tr>
<tr>
<td><code>@FeignClient(name=&quot;service-name&quot;)</code></td>
<td>定义服务调用接口</td>
</tr>
<tr>
<td><code>@RequestMapping</code> &#x2F; <code>@GetMapping</code></td>
<td>映射远程接口路径</td>
</tr>
</tbody></table>
<h3 id="💠-3-服务网关（Gateway）"><a href="#💠-3-服务网关（Gateway）" class="headerlink" title="💠 3. 服务网关（Gateway）"></a>💠 3. 服务网关（Gateway）</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@EnableGateway</code> <em>(部分版本自带)</em></td>
<td>启用网关服务</td>
</tr>
<tr>
<td><code>@RequestRateLimiter</code></td>
<td>限流控制</td>
</tr>
<tr>
<td><code>@EnableDiscoveryClient</code></td>
<td>注册到注册中心</td>
</tr>
</tbody></table>
<h3 id="💠-4-熔断-限流（Hystrix-Sentinel）"><a href="#💠-4-熔断-限流（Hystrix-Sentinel）" class="headerlink" title="💠 4. 熔断 &amp; 限流（Hystrix &#x2F; Sentinel）"></a>💠 4. 熔断 &amp; 限流（Hystrix &#x2F; Sentinel）</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@EnableHystrix</code> &#x2F; <code>@EnableCircuitBreaker</code></td>
<td>开启熔断机制</td>
</tr>
<tr>
<td><code>@HystrixCommand(fallbackMethod=&quot;...&quot;)</code></td>
<td>定义降级逻辑</td>
</tr>
<tr>
<td><code>@SentinelResource(value=&quot;resourceName&quot;, blockHandler=&quot;blockHandler&quot;)</code></td>
<td>Sentinel 控制限流熔断</td>
</tr>
</tbody></table>
<hr>
<h1 id="📘-七、面试记忆小技巧"><a href="#📘-七、面试记忆小技巧" class="headerlink" title="📘 七、面试记忆小技巧"></a>📘 七、面试记忆小技巧</h1><table>
<thead>
<tr>
<th>模块</th>
<th>关键注解记忆点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Spring 核心</strong></td>
<td><code>@Component</code> 系列 + <code>@Autowired</code> + <code>@Configuration</code></td>
</tr>
<tr>
<td><strong>Spring MVC</strong></td>
<td><code>@RestController</code> + <code>@RequestMapping</code> + <code>@RequestBody</code></td>
</tr>
<tr>
<td><strong>MyBatis</strong></td>
<td><code>@Mapper</code> + <code>@Select</code> + <code>@Param</code></td>
</tr>
<tr>
<td><strong>Spring Boot</strong></td>
<td><code>@SpringBootApplication</code> + <code>@ConfigurationProperties</code></td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td><code>@EnableWebSecurity</code> + <code>@PreAuthorize</code></td>
</tr>
<tr>
<td><strong>Spring Cloud</strong></td>
<td><code>@EnableDiscoveryClient</code> + <code>@FeignClient</code> + <code>@HystrixCommand</code></td>
</tr>
</tbody></table>
<hr>
<h1 id="🌱-一、Spring-核心注解运行机制（IOC-AOP）"><a href="#🌱-一、Spring-核心注解运行机制（IOC-AOP）" class="headerlink" title="🌱 一、Spring 核心注解运行机制（IOC &#x2F; AOP）"></a>🌱 一、Spring 核心注解运行机制（IOC &#x2F; AOP）</h1><h3 id="1️⃣-Component-系列注解（Bean-扫描注册流程）"><a href="#1️⃣-Component-系列注解（Bean-扫描注册流程）" class="headerlink" title="1️⃣ @Component 系列注解（Bean 扫描注册流程）"></a>1️⃣ <code>@Component</code> 系列注解（Bean 扫描注册流程）</h3><p><strong>流程图：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Spring 启动</span><br><span class="line">  ↓</span><br><span class="line">AnnotationConfigApplicationContext.refresh()</span><br><span class="line">  ↓</span><br><span class="line">ConfigurationClassPostProcessor 解析配置类</span><br><span class="line">  ↓</span><br><span class="line">ComponentScanAnnotationParser 解析 @ComponentScan</span><br><span class="line">  ↓</span><br><span class="line">ClassPathBeanDefinitionScanner 扫描包路径</span><br><span class="line">  ↓</span><br><span class="line">发现带 @Component / @Service / @Repository 的类</span><br><span class="line">  ↓</span><br><span class="line">封装成 BeanDefinition</span><br><span class="line">  ↓</span><br><span class="line">注册到 BeanDefinitionRegistry</span><br><span class="line">  ↓</span><br><span class="line">实例化 Bean → 放入 BeanFactory 容器</span><br></pre></td></tr></table></figure>

<p><strong>关键类：</strong></p>
<ul>
<li><code>ClassPathBeanDefinitionScanner</code></li>
<li><code>ScannedGenericBeanDefinition</code></li>
<li><code>DefaultListableBeanFactory</code></li>
</ul>
<p><strong>时机：</strong></p>
<blockquote>
<p>BeanDefinition 阶段（容器刷新 refresh() 时）</p>
</blockquote>
<hr>
<h3 id="2️⃣-Autowired-注入流程"><a href="#2️⃣-Autowired-注入流程" class="headerlink" title="2️⃣ @Autowired 注入流程"></a>2️⃣ <code>@Autowired</code> 注入流程</h3><p><strong>流程图：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">实例化 Bean</span><br><span class="line">  ↓</span><br><span class="line">执行 populateBean()</span><br><span class="line">  ↓</span><br><span class="line">AutowiredAnnotationBeanPostProcessor 处理 @Autowired</span><br><span class="line">  ↓</span><br><span class="line">反射获取依赖字段</span><br><span class="line">  ↓</span><br><span class="line">从 BeanFactory 中查找匹配类型 Bean</span><br><span class="line">  ↓</span><br><span class="line">通过 ReflectionUtils.setField() 注入字段值</span><br></pre></td></tr></table></figure>

<p><strong>关键类：</strong></p>
<ul>
<li><code>AutowiredAnnotationBeanPostProcessor</code></li>
<li><code>DefaultListableBeanFactory.resolveDependency()</code></li>
</ul>
<p><strong>时机：</strong></p>
<blockquote>
<p>Bean 初始化阶段（构造完成后，init 前）</p>
</blockquote>
<hr>
<h3 id="3️⃣-Configuration-Bean"><a href="#3️⃣-Configuration-Bean" class="headerlink" title="3️⃣ @Configuration + @Bean"></a>3️⃣ <code>@Configuration</code> + <code>@Bean</code></h3><p><strong>流程图：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">启动阶段</span><br><span class="line">  ↓</span><br><span class="line">ConfigurationClassPostProcessor 扫描 @Configuration 类</span><br><span class="line">  ↓</span><br><span class="line">解析 @Bean 方法</span><br><span class="line">  ↓</span><br><span class="line">为配置类生成 CGLIB 代理</span><br><span class="line">  ↓</span><br><span class="line">调用 @Bean 方法时，从容器返回单例对象</span><br></pre></td></tr></table></figure>

<p><strong>关键类：</strong></p>
<ul>
<li><code>ConfigurationClassPostProcessor</code></li>
<li><code>Enhancer</code>（CGLIB）</li>
<li><code>BeanDefinitionRegistry</code></li>
</ul>
<p><strong>时机：</strong></p>
<blockquote>
<p>注册 BeanDefinition 阶段（启动时）</p>
</blockquote>
<hr>
<h3 id="4️⃣-AOP-注解（-Aspect-Around-等）"><a href="#4️⃣-AOP-注解（-Aspect-Around-等）" class="headerlink" title="4️⃣ AOP 注解（@Aspect, @Around 等）"></a>4️⃣ AOP 注解（<code>@Aspect</code>, <code>@Around</code> 等）</h3><p><strong>流程图：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">启动时</span><br><span class="line">  ↓</span><br><span class="line">AnnotationAwareAspectJAutoProxyCreator 注册切面</span><br><span class="line">  ↓</span><br><span class="line">解析 @Aspect 类 → 提取切点表达式</span><br><span class="line">  ↓</span><br><span class="line">为目标类创建代理对象（JDK / CGLIB）</span><br><span class="line">  ↓</span><br><span class="line">方法调用时进入代理逻辑</span><br><span class="line">  ↓</span><br><span class="line">执行 Interceptor 链（Before → Around → After）</span><br></pre></td></tr></table></figure>

<p><strong>关键类：</strong></p>
<ul>
<li><code>AnnotationAwareAspectJAutoProxyCreator</code></li>
<li><code>AspectJExpressionPointcut</code></li>
<li><code>ProxyFactory</code></li>
</ul>
<p><strong>时机：</strong></p>
<blockquote>
<p>Bean 初始化结束后创建代理对象阶段</p>
</blockquote>
<hr>
<h1 id="🌐-二、Spring-MVC-注解运行机制"><a href="#🌐-二、Spring-MVC-注解运行机制" class="headerlink" title="🌐 二、Spring MVC 注解运行机制"></a>🌐 二、Spring MVC 注解运行机制</h1><h3 id="1️⃣-RequestMapping、-GetMapping"><a href="#1️⃣-RequestMapping、-GetMapping" class="headerlink" title="1️⃣ @RequestMapping、@GetMapping"></a>1️⃣ <code>@RequestMapping</code>、<code>@GetMapping</code></h3><p><strong>流程图：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SpringMVC 启动</span><br><span class="line">  ↓</span><br><span class="line">DispatcherServlet 初始化</span><br><span class="line">  ↓</span><br><span class="line">RequestMappingHandlerMapping 扫描 @Controller 类</span><br><span class="line">  ↓</span><br><span class="line">解析每个方法的 @RequestMapping 路径</span><br><span class="line">  ↓</span><br><span class="line">建立 URL -&gt; HandlerMethod 映射表</span><br><span class="line">  ↓</span><br><span class="line">请求到达时通过 HandlerMapping 匹配</span><br><span class="line">  ↓</span><br><span class="line">调用 HandlerAdapter 执行目标方法</span><br></pre></td></tr></table></figure>

<p><strong>关键类：</strong></p>
<ul>
<li><code>RequestMappingHandlerMapping</code></li>
<li><code>HandlerMethod</code></li>
<li><code>DispatcherServlet</code></li>
</ul>
<p><strong>时机：</strong></p>
<blockquote>
<p>初始化阶段注册映射；请求阶段匹配调用。</p>
</blockquote>
<hr>
<h3 id="2️⃣-RequestBody-ResponseBody"><a href="#2️⃣-RequestBody-ResponseBody" class="headerlink" title="2️⃣ @RequestBody &#x2F; @ResponseBody"></a>2️⃣ <code>@RequestBody</code> &#x2F; <code>@ResponseBody</code></h3><p><strong>流程图：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">请求进入 DispatcherServlet</span><br><span class="line">  ↓</span><br><span class="line">HandlerAdapter 调用目标方法</span><br><span class="line">  ↓</span><br><span class="line">检测参数是否有 @RequestBody</span><br><span class="line">  ↓</span><br><span class="line">使用 HttpMessageConverter 反序列化 JSON → Java 对象</span><br><span class="line">  ↓</span><br><span class="line">方法执行完成后检测 @ResponseBody</span><br><span class="line">  ↓</span><br><span class="line">再次通过 HttpMessageConverter 序列化返回对象 → JSON</span><br></pre></td></tr></table></figure>

<p><strong>关键类：</strong></p>
<ul>
<li><code>RequestResponseBodyMethodProcessor</code></li>
<li><code>MappingJackson2HttpMessageConverter</code></li>
</ul>
<p><strong>时机：</strong></p>
<blockquote>
<p>请求处理阶段（方法调用前后）</p>
</blockquote>
<hr>
<h1 id="💾-三、MyBatis-注解运行机制"><a href="#💾-三、MyBatis-注解运行机制" class="headerlink" title="💾 三、MyBatis 注解运行机制"></a>💾 三、MyBatis 注解运行机制</h1><p><strong>流程图：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Spring 启动时</span><br><span class="line">  ↓</span><br><span class="line">MapperScannerConfigurer 扫描 @Mapper 接口</span><br><span class="line">  ↓</span><br><span class="line">为每个 Mapper 生成 MapperFactoryBean</span><br><span class="line">  ↓</span><br><span class="line">调用时由 MapperProxy 拦截</span><br><span class="line">  ↓</span><br><span class="line">从 MapperMethod 获取对应 SQL（注解或 XML）</span><br><span class="line">  ↓</span><br><span class="line">通过 SqlSessionTemplate 执行 SQL</span><br></pre></td></tr></table></figure>

<p><strong>关键类：</strong></p>
<ul>
<li><code>MapperScannerConfigurer</code></li>
<li><code>MapperProxy</code></li>
<li><code>SqlSessionTemplate</code></li>
</ul>
<p><strong>时机：</strong></p>
<blockquote>
<p>Mapper 代理对象创建阶段 + 调用时动态执行 SQL</p>
</blockquote>
<hr>
<h1 id="🚀-四、Spring-Boot-注解运行机制"><a href="#🚀-四、Spring-Boot-注解运行机制" class="headerlink" title="🚀 四、Spring Boot 注解运行机制"></a>🚀 四、Spring Boot 注解运行机制</h1><h3 id="1️⃣-SpringBootApplication-自动装配流程"><a href="#1️⃣-SpringBootApplication-自动装配流程" class="headerlink" title="1️⃣ @SpringBootApplication 自动装配流程"></a>1️⃣ <code>@SpringBootApplication</code> 自动装配流程</h3><p><strong>流程图：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">启动类 @SpringBootApplication</span><br><span class="line">  ↓</span><br><span class="line">@SpringBootApplication = @EnableAutoConfiguration + @ComponentScan + @Configuration</span><br><span class="line">  ↓</span><br><span class="line">@EnableAutoConfiguration 导入 AutoConfigurationImportSelector</span><br><span class="line">  ↓</span><br><span class="line">从 META-INF/spring.factories 读取所有自动配置类</span><br><span class="line">  ↓</span><br><span class="line">判断条件注解（@ConditionalOnClass, @ConditionalOnMissingBean...）</span><br><span class="line">  ↓</span><br><span class="line">符合条件的自动配置类注册到容器</span><br><span class="line">  ↓</span><br><span class="line">完成 Bean 装配</span><br></pre></td></tr></table></figure>

<p><strong>关键类：</strong></p>
<ul>
<li><code>SpringApplication</code></li>
<li><code>AutoConfigurationImportSelector</code></li>
<li><code>SpringFactoriesLoader</code></li>
</ul>
<p><strong>时机：</strong></p>
<blockquote>
<p>启动阶段（容器刷新前）</p>
</blockquote>
<hr>
<h1 id="🔐-五、Spring-Security-注解运行机制"><a href="#🔐-五、Spring-Security-注解运行机制" class="headerlink" title="🔐 五、Spring Security 注解运行机制"></a>🔐 五、Spring Security 注解运行机制</h1><p><strong>流程图：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@EnableWebSecurity</span><br><span class="line">  ↓</span><br><span class="line">注册 DelegatingFilterProxy → springSecurityFilterChain</span><br><span class="line">  ↓</span><br><span class="line">加载 WebSecurityConfigurerAdapter</span><br><span class="line">  ↓</span><br><span class="line">配置过滤器链（认证、授权）</span><br><span class="line">  ↓</span><br><span class="line">执行 Controller 方法前，MethodSecurityInterceptor 检查 @PreAuthorize / @Secured</span><br><span class="line">  ↓</span><br><span class="line">解析 SpEL 表达式校验当前用户权限</span><br></pre></td></tr></table></figure>

<p><strong>关键类：</strong></p>
<ul>
<li><code>MethodSecurityInterceptor</code></li>
<li><code>SecurityFilterChain</code></li>
<li><code>AccessDecisionManager</code></li>
</ul>
<p><strong>时机：</strong></p>
<blockquote>
<p>请求进入 Security Filter 阶段 &amp; 方法调用前</p>
</blockquote>
<hr>
<h1 id="☁️-六、Spring-Cloud-注解运行机制"><a href="#☁️-六、Spring-Cloud-注解运行机制" class="headerlink" title="☁️ 六、Spring Cloud 注解运行机制"></a>☁️ 六、Spring Cloud 注解运行机制</h1><h3 id="1️⃣-EnableDiscoveryClient"><a href="#1️⃣-EnableDiscoveryClient" class="headerlink" title="1️⃣ @EnableDiscoveryClient"></a>1️⃣ <code>@EnableDiscoveryClient</code></h3><p><strong>流程图：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动阶段</span><br><span class="line">  ↓</span><br><span class="line">通过 ImportSelector 导入 DiscoveryClientAutoConfiguration</span><br><span class="line">  ↓</span><br><span class="line">初始化 DiscoveryClient (Eureka / Nacos)</span><br><span class="line">  ↓</span><br><span class="line">将当前服务信息注册到注册中心</span><br></pre></td></tr></table></figure>

<h3 id="2️⃣-FeignClient"><a href="#2️⃣-FeignClient" class="headerlink" title="2️⃣ @FeignClient"></a>2️⃣ <code>@FeignClient</code></h3><p><strong>流程图：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableFeignClients 启动</span><br><span class="line">  ↓</span><br><span class="line">FeignClientsRegistrar 注册 FeignClientFactoryBean</span><br><span class="line">  ↓</span><br><span class="line">创建 Feign 动态代理对象</span><br><span class="line">  ↓</span><br><span class="line">方法调用 → FeignInvocationHandler 拦截</span><br><span class="line">  ↓</span><br><span class="line">构造 HTTP 请求 → Ribbon 负载均衡 → RestTemplate 调用远程接口</span><br></pre></td></tr></table></figure>

<p><strong>关键类：</strong></p>
<ul>
<li><code>FeignClientsRegistrar</code></li>
<li><code>FeignClientFactoryBean</code></li>
<li><code>FeignInvocationHandler</code></li>
</ul>
<hr>
<h2 id="🚨-七、所有框架调用时机总览表"><a href="#🚨-七、所有框架调用时机总览表" class="headerlink" title="🚨 七、所有框架调用时机总览表"></a>🚨 七、所有框架调用时机总览表</h2><table>
<thead>
<tr>
<th>阶段</th>
<th>注解类型</th>
<th>核心执行器</th>
<th>时机</th>
</tr>
</thead>
<tbody><tr>
<td>Bean 扫描注册</td>
<td><code>@Component</code> 系列</td>
<td><code>ClassPathBeanDefinitionScanner</code></td>
<td>容器启动</td>
</tr>
<tr>
<td>依赖注入</td>
<td><code>@Autowired</code></td>
<td><code>AutowiredAnnotationBeanPostProcessor</code></td>
<td>Bean 初始化阶段</td>
</tr>
<tr>
<td>配置解析</td>
<td><code>@Configuration</code>、<code>@Bean</code></td>
<td><code>ConfigurationClassPostProcessor</code></td>
<td>容器刷新前</td>
</tr>
<tr>
<td>AOP 创建代理</td>
<td><code>@Aspect</code></td>
<td><code>AnnotationAwareAspectJAutoProxyCreator</code></td>
<td>Bean 初始化后</td>
</tr>
<tr>
<td>MVC 映射注册</td>
<td><code>@Controller</code>、<code>@RequestMapping</code></td>
<td><code>RequestMappingHandlerMapping</code></td>
<td>Web 容器启动</td>
</tr>
<tr>
<td>JSON 转换</td>
<td><code>@RequestBody</code>、<code>@ResponseBody</code></td>
<td><code>HttpMessageConverter</code></td>
<td>请求调用时</td>
</tr>
<tr>
<td>MyBatis 代理</td>
<td><code>@Mapper</code></td>
<td><code>MapperProxy</code></td>
<td>运行时调用接口方法</td>
</tr>
<tr>
<td>自动装配</td>
<td><code>@EnableAutoConfiguration</code></td>
<td><code>AutoConfigurationImportSelector</code></td>
<td>启动阶段</td>
</tr>
<tr>
<td>权限控制</td>
<td><code>@PreAuthorize</code></td>
<td><code>MethodSecurityInterceptor</code></td>
<td>方法调用前</td>
</tr>
<tr>
<td>服务注册</td>
<td><code>@EnableDiscoveryClient</code></td>
<td><code>DiscoveryClientAutoConfiguration</code></td>
<td>启动阶段</td>
</tr>
<tr>
<td>远程调用</td>
<td><code>@FeignClient</code></td>
<td><code>FeignClientFactoryBean</code></td>
<td>调用接口时</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧠-八、面试延伸逻辑（高频问法）"><a href="#🧠-八、面试延伸逻辑（高频问法）" class="headerlink" title="🧠 八、面试延伸逻辑（高频问法）"></a>🧠 八、面试延伸逻辑（高频问法）</h2><table>
<thead>
<tr>
<th>典型问题</th>
<th>核心回答逻辑</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>@Autowired</code> 注入是怎么实现的？</strong></td>
<td>通过 <code>AutowiredAnnotationBeanPostProcessor</code> 在 Bean 初始化阶段用反射注入依赖。</td>
</tr>
<tr>
<td><strong><code>@Configuration</code> 为什么会生成代理类？</strong></td>
<td>确保 <code>@Bean</code> 方法多次调用返回同一单例 Bean。</td>
</tr>
<tr>
<td><strong>Spring Boot 自动装配的原理？</strong></td>
<td><code>@EnableAutoConfiguration</code> → <code>AutoConfigurationImportSelector</code> → 读取 <code>spring.factories</code>。</td>
</tr>
<tr>
<td><strong>Spring AOP 如何织入？</strong></td>
<td>使用代理模式（JDK&#x2F;CGLIB），由 <code>AnnotationAwareAspectJAutoProxyCreator</code> 创建代理对象。</td>
</tr>
<tr>
<td><strong>Spring MVC 是如何找到 Controller 的？</strong></td>
<td><code>RequestMappingHandlerMapping</code> 扫描 <code>@Controller</code> 并建立 URL 映射表。</td>
</tr>
<tr>
<td><strong>Feign 是怎么实现远程调用的？</strong></td>
<td>通过动态代理生成接口实现类，调用时封装 HTTP 请求发往目标服务。</td>
</tr>
</tbody></table>
<hr>
<p>太好了 👏<br> 那我们就进入<strong>第二阶段：六大框架的深入机制讲解版</strong>，把每个框架的注解从“会用”提升到“懂原理、能讲源码逻辑”。</p>
<p>我会按顺序讲，每个模块包含：<br> 1️⃣ 常用注解<br> 2️⃣ 运行机制（源码&#x2F;原理）<br> 3️⃣ 实战&#x2F;场景<br> 4️⃣ 面试追问点（能拿高分的深答法）</p>
<hr>
<h1 id="🌱-一、Spring-核心注解-深入解析（IOC-AOP）"><a href="#🌱-一、Spring-核心注解-深入解析（IOC-AOP）" class="headerlink" title="🌱 一、Spring 核心注解 深入解析（IOC + AOP）"></a>🌱 一、Spring 核心注解 深入解析（IOC + AOP）</h1><p>Spring 是一切的根。只要理解它的 IOC 容器和 AOP 原理，后面所有框架的注解你都会秒懂。</p>
<hr>
<h2 id="1️⃣-IOC-核心注解机制"><a href="#1️⃣-IOC-核心注解机制" class="headerlink" title="1️⃣ IOC 核心注解机制"></a>1️⃣ IOC 核心注解机制</h2><p><strong>核心注解</strong>：<br> <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>, <code>@Configuration</code>, <code>@Bean</code>, <code>@Scope</code></p>
<hr>
<h3 id="🔍-1-原理"><a href="#🔍-1-原理" class="headerlink" title="🔍 1. 原理"></a>🔍 1. 原理</h3><h4 id="🧩-IOC（Inversion-of-Control）——控制反转"><a href="#🧩-IOC（Inversion-of-Control）——控制反转" class="headerlink" title="🧩 IOC（Inversion of Control）——控制反转"></a>🧩 IOC（Inversion of Control）——控制反转</h4><ul>
<li>核心思想：<strong>对象不由自己创建，而是交给容器管理</strong>。</li>
<li>Spring 容器本质是一个 <strong>BeanFactory &#x2F; ApplicationContext</strong>。</li>
<li>它启动时会执行：<ol>
<li>扫描包（<code>@ComponentScan</code>）</li>
<li>找到带 <code>@Component</code> 系的类</li>
<li>实例化成 Bean，放入 IOC 容器</li>
<li>执行依赖注入（DI）</li>
</ol>
</li>
</ul>
<h4 id="🧠-底层关键类："><a href="#🧠-底层关键类：" class="headerlink" title="🧠 底层关键类："></a>🧠 底层关键类：</h4><ul>
<li><code>ClassPathScanningCandidateComponentProvider</code>：扫描所有类</li>
<li><code>AnnotationConfigApplicationContext</code>：基于注解的容器入口</li>
<li><code>DefaultListableBeanFactory</code>：Bean 存储与生命周期管理</li>
</ul>
<hr>
<h3 id="⚙️-2-Component-与派生注解"><a href="#⚙️-2-Component-与派生注解" class="headerlink" title="⚙️ 2. @Component 与派生注解"></a>⚙️ 2. @Component 与派生注解</h3><p>Spring 在扫描时会判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clazz.isAnnotationPresent(Component.class) </span><br><span class="line">    || clazz.isAnnotationPresent(Controller.class) </span><br><span class="line">    || clazz.isAnnotationPresent(Service.class)</span><br><span class="line">    || clazz.isAnnotationPresent(Repository.class)) &#123;</span><br><span class="line">    <span class="comment">// 注册 BeanDefinition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>👉 所以 <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code> 都是 <code>@Component</code> 的语义扩展，只是方便分层。</p>
<hr>
<h3 id="⚙️-3-Configuration-Bean-原理"><a href="#⚙️-3-Configuration-Bean-原理" class="headerlink" title="⚙️ 3. @Configuration + @Bean 原理"></a>⚙️ 3. @Configuration + @Bean 原理</h3><ul>
<li><code>@Configuration</code> 标识配置类，本质上是一个带 CGLIB 代理的 Bean。</li>
<li>代理的目的是防止多次实例化同一个 Bean。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层 Spring 会：</p>
<ol>
<li>解析 <code>@Configuration</code></li>
<li>生成 CGLIB 代理子类</li>
<li>拦截对 <code>@Bean</code> 方法的调用</li>
<li>若 Bean 已存在，不重新创建</li>
</ol>
<hr>
<h3 id="⚙️-4-依赖注入注解机制"><a href="#⚙️-4-依赖注入注解机制" class="headerlink" title="⚙️ 4. 依赖注入注解机制"></a>⚙️ 4. 依赖注入注解机制</h3><table>
<thead>
<tr>
<th>注解</th>
<th>机制</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Autowired</strong></td>
<td>反射注入。先按类型匹配，再按名称。</td>
</tr>
<tr>
<td><strong>@Qualifier</strong></td>
<td>指定注入 Bean 名称。</td>
</tr>
<tr>
<td><strong>@Resource</strong></td>
<td>JSR-250 标准，先按名称，再按类型。</td>
</tr>
<tr>
<td><strong>@Value</strong></td>
<td>从 <code>Environment</code> 中取值（支持 <code>$&#123;&#125;</code>）。</td>
</tr>
</tbody></table>
<p>底层类：</p>
<ul>
<li><code>AutowiredAnnotationBeanPostProcessor</code></li>
<li><code>CommonAnnotationBeanPostProcessor</code></li>
<li><code>ValueAnnotationBeanPostProcessor</code></li>
</ul>
<p>这些都是在 Bean 初始化阶段执行的 <strong>BeanPostProcessor</strong>。</p>
<hr>
<h2 id="2️⃣-AOP-核心注解机制"><a href="#2️⃣-AOP-核心注解机制" class="headerlink" title="2️⃣ AOP 核心注解机制"></a>2️⃣ AOP 核心注解机制</h2><p><strong>核心注解</strong>：<code>@Aspect</code>, <code>@Before</code>, <code>@After</code>, <code>@Around</code>, <code>@Pointcut</code></p>
<h3 id="🧩-1-原理：动态代理-通知织入"><a href="#🧩-1-原理：动态代理-通知织入" class="headerlink" title="🧩 1. 原理：动态代理 + 通知织入"></a>🧩 1. 原理：动态代理 + 通知织入</h3><p>Spring 启动时：</p>
<ol>
<li>扫描 <code>@Aspect</code> 类；</li>
<li>解析通知方法（<code>@Before</code>, <code>@Around</code>…）；</li>
<li>生成代理对象（JDK Proxy 或 CGLIB）；</li>
<li>方法执行时由代理拦截，执行通知逻辑。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.demo.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 <code>service</code> 方法时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK 动态代理 → 进入 AOP 代理类 → 执行 before() → 调用原方法 → after()</span><br></pre></td></tr></table></figure>

<p>底层关键类：</p>
<ul>
<li><code>AspectJExpressionPointcut</code></li>
<li><code>JdkDynamicAopProxy</code></li>
<li><code>CglibAopProxy</code></li>
</ul>
<hr>
<h2 id="🧠-面试深问点（可直接说出原理）"><a href="#🧠-面试深问点（可直接说出原理）" class="headerlink" title="🧠 面试深问点（可直接说出原理）"></a>🧠 面试深问点（可直接说出原理）</h2><table>
<thead>
<tr>
<th>问题</th>
<th>答案要点</th>
</tr>
</thead>
<tbody><tr>
<td>@Component 和 @Bean 区别？</td>
<td>@Component 自动扫描，@Bean 手动注册；前者类级别，后者方法级别。</td>
</tr>
<tr>
<td>@Configuration 为什么要代理？</td>
<td>为了保证 @Bean 返回的单例不会重复创建。</td>
</tr>
<tr>
<td>AOP 是如何实现的？</td>
<td>基于 JDK&#x2F;CGLIB 动态代理，通过 ProxyFactory 创建代理对象，执行通知链。</td>
</tr>
<tr>
<td>@Autowired 什么时候注入？</td>
<td>在 BeanPostProcessor 阶段的 <code>postProcessPropertyValues()</code> 里注入。</td>
</tr>
</tbody></table>
<hr>
<h1 id="🌐-二、SpringMVC-常用注解深度解析（请求分发-参数绑定-消息转换）"><a href="#🌐-二、SpringMVC-常用注解深度解析（请求分发-参数绑定-消息转换）" class="headerlink" title="🌐 二、SpringMVC 常用注解深度解析（请求分发 + 参数绑定 + 消息转换）"></a>🌐 二、SpringMVC 常用注解深度解析（请求分发 + 参数绑定 + 消息转换）</h1><p>SpringMVC 是 Spring 的 Web 层框架，它的注解体系围绕 <strong>请求映射、参数绑定、返回响应</strong> 三大核心展开。</p>
<hr>
<h2 id="1️⃣-SpringMVC-的整体架构与执行流程"><a href="#1️⃣-SpringMVC-的整体架构与执行流程" class="headerlink" title="1️⃣ SpringMVC 的整体架构与执行流程"></a>1️⃣ SpringMVC 的整体架构与执行流程</h2><blockquote>
<p>🌊 面试常问：<strong>“SpringMVC 请求是怎么从 URL 到 Controller 方法执行的？”</strong></p>
</blockquote>
<p>🧩 核心机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DispatcherServlet（前端控制器）</span><br><span class="line">   ↓</span><br><span class="line">HandlerMapping（映射处理器）  ← 解析 @RequestMapping</span><br><span class="line">   ↓</span><br><span class="line">HandlerAdapter（适配器）      ← 解析 @RequestBody、@ModelAttribute 等参数</span><br><span class="line">   ↓</span><br><span class="line">Controller 方法执行</span><br><span class="line">   ↓</span><br><span class="line">ViewResolver（视图解析） / HttpMessageConverter（JSON 转换）</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：SpringMVC 初始化时，会扫描所有带有 <code>@Controller</code>、<code>@RestController</code>、<code>@RequestMapping</code> 的类和方法，并建立映射表（HandlerMapping）。</p>
<hr>
<h2 id="2️⃣-控制层核心注解（Controller-体系）"><a href="#2️⃣-控制层核心注解（Controller-体系）" class="headerlink" title="2️⃣ 控制层核心注解（Controller 体系）"></a>2️⃣ 控制层核心注解（Controller 体系）</h2><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Controller</strong></td>
<td>声明控制层组件</td>
<td>返回视图（如 JSP、Thymeleaf）</td>
</tr>
<tr>
<td><strong>@RestController</strong></td>
<td>&#x3D; @Controller + @ResponseBody</td>
<td>返回 JSON 数据</td>
</tr>
<tr>
<td><strong>@RequestMapping</strong></td>
<td>定义请求路径、方法、参数规则</td>
<td>可标注在类或方法上</td>
</tr>
<tr>
<td><strong>@GetMapping &#x2F; @PostMapping &#x2F; @PutMapping &#x2F; @DeleteMapping</strong></td>
<td>@RequestMapping 的快捷形式</td>
<td>仅限制 HTTP Method</td>
</tr>
<tr>
<td><strong>@ResponseBody</strong></td>
<td>将返回对象序列化为 JSON</td>
<td>由 HttpMessageConverter 实现</td>
</tr>
<tr>
<td><strong>@RequestBody</strong></td>
<td>将请求体 JSON 反序列化为对象</td>
<td>由 HttpMessageConverter 实现</td>
</tr>
</tbody></table>
<hr>
<h3 id="💡-实战示例"><a href="#💡-实战示例" class="headerlink" title="💡 实战示例"></a>💡 实战示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        userService.save(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🔹 <code>/user/&#123;id&#125;</code> → <code>getUser()</code><br> 🔹 请求体 JSON → 通过 <code>@RequestBody</code> 自动映射到 <code>User</code> 对象</p>
<hr>
<h2 id="3️⃣-请求映射机制（HandlerMapping）"><a href="#3️⃣-请求映射机制（HandlerMapping）" class="headerlink" title="3️⃣ 请求映射机制（HandlerMapping）"></a>3️⃣ 请求映射机制（HandlerMapping）</h2><p>Spring 启动时会注册多个 HandlerMapping 实现类，其中最关键的是：</p>
<ul>
<li><code>RequestMappingHandlerMapping</code></li>
</ul>
<p>它负责扫描所有 Controller 类的方法并建立 URL 映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title function_">requestMappingHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层逻辑（源码简化版）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : controllerClass.getMethods()) &#123;</span><br><span class="line">    <span class="type">RequestMappingInfo</span> <span class="variable">info</span> <span class="operator">=</span> createRequestMappingInfo(method);</span><br><span class="line">    handlerMapping.registerMapping(info, controller, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🧠 所以：</p>
<ul>
<li>类上的 <code>@RequestMapping(&quot;/user&quot;)</code></li>
<li>方法上的 <code>@GetMapping(&quot;/&#123;id&#125;&quot;)</code></li>
</ul>
<p>会拼接成完整路径 <code>/user/&#123;id&#125;</code> 注册到映射表中。</p>
<hr>
<h2 id="4️⃣-参数绑定注解（HandlerMethodArgumentResolver）"><a href="#4️⃣-参数绑定注解（HandlerMethodArgumentResolver）" class="headerlink" title="4️⃣ 参数绑定注解（HandlerMethodArgumentResolver）"></a>4️⃣ 参数绑定注解（HandlerMethodArgumentResolver）</h2><p>SpringMVC 的参数解析是由 <code>HandlerMethodArgumentResolver</code> 实现的。<br> 它通过一系列解析器解析注解参数。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>对应解析器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@RequestParam</strong></td>
<td><code>RequestParamMethodArgumentResolver</code></td>
<td>解析 URL 查询参数</td>
</tr>
<tr>
<td><strong>@PathVariable</strong></td>
<td><code>PathVariableMethodArgumentResolver</code></td>
<td>解析路径参数</td>
</tr>
<tr>
<td><strong>@RequestBody</strong></td>
<td><code>RequestResponseBodyMethodProcessor</code></td>
<td>JSON → 对象</td>
</tr>
<tr>
<td><strong>@RequestHeader</strong></td>
<td><code>RequestHeaderMethodArgumentResolver</code></td>
<td>获取请求头</td>
</tr>
<tr>
<td><strong>@CookieValue</strong></td>
<td><code>CookieValueMethodArgumentResolver</code></td>
<td>获取 Cookie 值</td>
</tr>
<tr>
<td><strong>@ModelAttribute</strong></td>
<td><code>ModelAttributeMethodProcessor</code></td>
<td>表单对象绑定</td>
</tr>
<tr>
<td><strong>@SessionAttributes</strong></td>
<td><code>SessionAttributesHandler</code></td>
<td>保留 Session 数据</td>
</tr>
</tbody></table>
<hr>
<h3 id="💡-参数绑定示例"><a href="#💡-参数绑定示例" class="headerlink" title="💡 参数绑定示例"></a>💡 参数绑定示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">query</span><span class="params">(<span class="meta">@RequestParam</span> String name, <span class="meta">@RequestParam(defaultValue=&quot;1&quot;)</span> <span class="type">int</span> page)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">detail</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@ModelAttribute</span> User user)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginDTO dto)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>🧠 底层逻辑：</p>
<ul>
<li>SpringMVC 调用每个 <code>HandlerMethodArgumentResolver</code>；</li>
<li>找到能处理对应注解的解析器；</li>
<li>把请求内容转换成参数。</li>
</ul>
<hr>
<h2 id="5️⃣-响应返回注解（HttpMessageConverter）"><a href="#5️⃣-响应返回注解（HttpMessageConverter）" class="headerlink" title="5️⃣ 响应返回注解（HttpMessageConverter）"></a>5️⃣ 响应返回注解（HttpMessageConverter）</h2><p>SpringMVC 的返回值也通过一系列 <strong>HandlerMethodReturnValueHandler</strong> 处理。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>对应机制</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@ResponseBody</strong></td>
<td>调用 <code>HttpMessageConverter</code> 序列化返回对象为 JSON</td>
</tr>
<tr>
<td><strong>@RestController</strong></td>
<td>相当于全类级别 <code>@ResponseBody</code></td>
</tr>
<tr>
<td><strong>@ResponseStatus(HttpStatus.XXX)</strong></td>
<td>设置 HTTP 状态码</td>
</tr>
<tr>
<td><strong>@ControllerAdvice + @ExceptionHandler</strong></td>
<td>全局异常捕获和统一响应</td>
</tr>
</tbody></table>
<hr>
<h3 id="💡-JSON-转换过程原理"><a href="#💡-JSON-转换过程原理" class="headerlink" title="💡 JSON 转换过程原理"></a>💡 JSON 转换过程原理</h3><p>当方法标注了 <code>@ResponseBody</code>：</p>
<ol>
<li>SpringMVC 使用 <code>RequestResponseBodyMethodProcessor</code> 处理；</li>
<li>调用合适的 <code>HttpMessageConverter</code>；</li>
<li>常见实现：<ul>
<li><code>MappingJackson2HttpMessageConverter</code> → 使用 Jackson 转 JSON；</li>
<li><code>StringHttpMessageConverter</code> → 返回字符串。</li>
</ul>
</li>
</ol>
<p>反过来：</p>
<ul>
<li><code>@RequestBody</code> 也是通过同样的 <code>HttpMessageConverter</code> 将 JSON 转成 Java 对象。</li>
</ul>
<hr>
<h2 id="6️⃣-异常处理与全局控制"><a href="#6️⃣-异常处理与全局控制" class="headerlink" title="6️⃣ 异常处理与全局控制"></a>6️⃣ 异常处理与全局控制</h2><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@ExceptionHandler(Exception.class)</strong></td>
<td>捕获特定异常</td>
</tr>
<tr>
<td><strong>@ControllerAdvice</strong></td>
<td>全局异常&#x2F;数据绑定处理</td>
</tr>
<tr>
<td><strong>@InitBinder</strong></td>
<td>数据绑定格式化（如时间）</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handle</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(<span class="number">500</span>).body(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧠-面试追问点与高分答法"><a href="#🧠-面试追问点与高分答法" class="headerlink" title="🧠 面试追问点与高分答法"></a>🧠 面试追问点与高分答法</h2><table>
<thead>
<tr>
<th>问题</th>
<th>深度答法</th>
</tr>
</thead>
<tbody><tr>
<td>SpringMVC 如何将 JSON 转换为对象？</td>
<td>通过 <code>@RequestBody</code> → <code>RequestResponseBodyMethodProcessor</code> → <code>HttpMessageConverter</code>（默认 Jackson）。</td>
</tr>
<tr>
<td>@Controller 与 @RestController 区别？</td>
<td>@RestController &#x3D; @Controller + @ResponseBody，用于 RESTful API 返回 JSON。</td>
</tr>
<tr>
<td>参数绑定是怎么实现的？</td>
<td>每个注解对应一个 <code>HandlerMethodArgumentResolver</code>，逐个匹配执行。</td>
</tr>
<tr>
<td>DispatcherServlet 做了什么？</td>
<td>它是前端控制器，负责请求分发、参数解析、调用 Controller、返回视图或 JSON。</td>
</tr>
<tr>
<td>@ControllerAdvice 有什么用？</td>
<td>统一异常处理、数据绑定、全局配置。</td>
</tr>
</tbody></table>
<hr>
<h1 id="💾-三、MyBatis-常用注解-底层映射原理（Mapper-动态代理机制）"><a href="#💾-三、MyBatis-常用注解-底层映射原理（Mapper-动态代理机制）" class="headerlink" title="💾 三、MyBatis 常用注解 + 底层映射原理（Mapper 动态代理机制）"></a>💾 三、MyBatis 常用注解 + 底层映射原理（Mapper 动态代理机制）</h1><p>MyBatis 是 Spring 体系中连接数据库的核心 ORM 框架。<br> 与 JPA 不同，它更轻量、可控，常通过 <strong>接口 + 注解 &#x2F; XML 映射</strong> 实现 SQL 操作。</p>
<hr>
<h2 id="一、MyBatis-常用注解总览"><a href="#一、MyBatis-常用注解总览" class="headerlink" title="一、MyBatis 常用注解总览"></a>一、MyBatis 常用注解总览</h2><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>使用位置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Mapper</strong></td>
<td>标记 Mapper 接口</td>
<td>接口</td>
<td>告诉 Spring 这是一个 MyBatis Mapper</td>
</tr>
<tr>
<td><strong>@MapperScan</strong></td>
<td>批量扫描 Mapper 包</td>
<td>启动类或配置类</td>
<td>替代逐个写 @Mapper</td>
</tr>
<tr>
<td><strong>@Select &#x2F; @Insert &#x2F; @Update &#x2F; @Delete</strong></td>
<td>声明 SQL 语句</td>
<td>方法</td>
<td>注解式 SQL</td>
</tr>
<tr>
<td><strong>@Results &#x2F; @Result</strong></td>
<td>字段与属性映射</td>
<td>方法</td>
<td>解决数据库字段与实体属性不一致</td>
</tr>
<tr>
<td><strong>@Param</strong></td>
<td>映射方法参数名</td>
<td>方法参数</td>
<td>SQL 中使用 #{参数名}</td>
</tr>
<tr>
<td><strong>@Options</strong></td>
<td>设置 SQL 执行选项</td>
<td>方法</td>
<td>例如自动主键回填</td>
</tr>
<tr>
<td><strong>@SelectProvider &#x2F; @UpdateProvider …</strong></td>
<td>动态 SQL 生成</td>
<td>方法</td>
<td>指定 SQL 由某类动态生成</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、Mapper-注册机制与动态代理原理"><a href="#二、Mapper-注册机制与动态代理原理" class="headerlink" title="二、Mapper 注册机制与动态代理原理"></a>二、Mapper 注册机制与动态代理原理</h2><p>🧠 面试常问：“@Mapper 是如何让接口不写实现类还能执行 SQL 的？”</p>
<p>核心答案：<br> 👉 MyBatis 使用 <strong>动态代理（MapperProxy）</strong> 为接口创建实现类。</p>
<h3 id="💡-执行流程示意"><a href="#💡-执行流程示意" class="headerlink" title="💡 执行流程示意"></a>💡 执行流程示意</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口调用 → MapperProxy.invoke() → SqlSession → 执行 SQL → 映射结果 → 返回对象</span><br></pre></td></tr></table></figure>

<p>详细步骤：</p>
<p>1️⃣ Spring 启动时，<code>@MapperScan</code> 扫描包路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br></pre></td></tr></table></figure>

<p>2️⃣ Spring 会为每个接口创建 <strong>MapperFactoryBean</strong>，交给 IOC 容器管理。</p>
<p>3️⃣ 当注入 Mapper 时，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br></pre></td></tr></table></figure>

<p>其实注入的是一个由 MyBatis 创建的代理对象。</p>
<p>4️⃣ 代理对象的核心类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">        <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5️⃣ 最终执行 SQL：</p>
<ul>
<li>从注解或 XML 读取 SQL；</li>
<li>替换参数；</li>
<li>执行 JDBC；</li>
<li>使用 <code>ResultSetHandler</code> 将结果映射成对象。</li>
</ul>
<hr>
<h2 id="三、注解式-SQL-示例"><a href="#三、注解式-SQL-示例" class="headerlink" title="三、注解式 SQL 示例"></a>三、注解式 SQL 示例</h2><h3 id="1️⃣-基本-CRUD-注解"><a href="#1️⃣-基本-CRUD-注解" class="headerlink" title="1️⃣ 基本 CRUD 注解"></a>1️⃣ 基本 CRUD 注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO user(name, age) VALUES(#&#123;name&#125;, #&#123;age&#125;)&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE user SET name=#&#123;name&#125;, age=#&#123;age&#125; WHERE id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM user WHERE id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🧩 <strong>说明</strong>：</p>
<ul>
<li><code>#&#123;&#125;</code> 会被 MyBatis 解析为 <code>?</code> 占位符；</li>
<li><code>@Options(useGeneratedKeys=true)</code> 可自动回填主键；</li>
<li><code>@Param</code> 显式指定参数名，防止参数混乱。</li>
</ul>
<hr>
<h3 id="2️⃣-结果映射注解（解决字段名不匹配）"><a href="#2️⃣-结果映射注解（解决字段名不匹配）" class="headerlink" title="2️⃣ 结果映射注解（解决字段名不匹配）"></a>2️⃣ 结果映射注解（解决字段名不匹配）</h3><p>数据库字段 → Java 属性不一致时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT user_id, user_name FROM user WHERE user_id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;user_id&quot;, property=&quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;user_name&quot;, property=&quot;name&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">User <span class="title function_">getUser</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure>

<p>底层使用 <code>ResultSetHandler</code> 将列值与属性对应。</p>
<hr>
<h3 id="3️⃣-动态-SQL-注解"><a href="#3️⃣-动态-SQL-注解" class="headerlink" title="3️⃣ 动态 SQL 注解"></a>3️⃣ 动态 SQL 注解</h3><p>用于复杂 SQL（可条件拼接）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;buildSelect&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">selectByCondition</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure>

<p>SQL 动态生成类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">buildSelect</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;SELECT * FROM user WHERE 1=1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user.getName() != <span class="literal">null</span>) sql.append(<span class="string">&quot; AND name = #&#123;name&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user.getAge() != <span class="literal">null</span>) sql.append(<span class="string">&quot; AND age = #&#123;age&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sql.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、-Mapper-与-MapperScan-的关系"><a href="#四、-Mapper-与-MapperScan-的关系" class="headerlink" title="四、@Mapper 与 @MapperScan 的关系"></a>四、@Mapper 与 @MapperScan 的关系</h2><table>
<thead>
<tr>
<th>场景</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>少量 Mapper</td>
<td>每个接口加 @Mapper</td>
</tr>
<tr>
<td>多个 Mapper</td>
<td>在配置类加 @MapperScan(“com.example.mapper”)</td>
</tr>
</tbody></table>
<p>📦 Spring Boot 中通常只需：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、底层关键组件解析（源码角度）"><a href="#五、底层关键组件解析（源码角度）" class="headerlink" title="五、底层关键组件解析（源码角度）"></a>五、底层关键组件解析（源码角度）</h2><table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SqlSessionFactoryBean</strong></td>
<td>生成 SqlSession 工厂</td>
</tr>
<tr>
<td><strong>MapperFactoryBean</strong></td>
<td>每个 Mapper 的代理工厂</td>
</tr>
<tr>
<td><strong>MapperProxy</strong></td>
<td>动态代理核心</td>
</tr>
<tr>
<td><strong>Executor</strong></td>
<td>执行 SQL 的底层执行器</td>
</tr>
<tr>
<td><strong>ResultSetHandler</strong></td>
<td>结果集映射</td>
</tr>
<tr>
<td><strong>StatementHandler</strong></td>
<td>负责预编译和执行 SQL</td>
</tr>
</tbody></table>
<p>🧩 执行链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MapperProxy.invoke()</span><br><span class="line">    ↓</span><br><span class="line">MapperMethod.execute()</span><br><span class="line">    ↓</span><br><span class="line">SqlSession.select / insert / update</span><br><span class="line">    ↓</span><br><span class="line">Executor.query()</span><br><span class="line">    ↓</span><br><span class="line">StatementHandler.prepare()</span><br><span class="line">    ↓</span><br><span class="line">ResultSetHandler.handleResultSets()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、MyBatis-Spring-的整合机制"><a href="#六、MyBatis-Spring-的整合机制" class="headerlink" title="六、MyBatis + Spring 的整合机制"></a>六、MyBatis + Spring 的整合机制</h2><p>Spring Boot 整合时，核心是：</p>
<ul>
<li><code>MyBatisAutoConfiguration</code></li>
<li>自动注册 <code>SqlSessionFactory</code> 和 <code>MapperScannerConfigurer</code></li>
<li>自动扫描带 @Mapper 的接口</li>
</ul>
<p>配置简化到只需：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=...</span><br><span class="line">mybatis.mapper-locations=classpath:mappers<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、面试追问点（高分回答）"><a href="#七、面试追问点（高分回答）" class="headerlink" title="七、面试追问点（高分回答）"></a>七、面试追问点（高分回答）</h2><table>
<thead>
<tr>
<th>问题</th>
<th>深度答法</th>
</tr>
</thead>
<tbody><tr>
<td>@Mapper 与 @MapperScan 区别？</td>
<td>@Mapper 作用于接口；@MapperScan 作用于包；底层都注册 MapperFactoryBean。</td>
</tr>
<tr>
<td>MyBatis 是如何执行 SQL 的？</td>
<td>MapperProxy 拦截方法 → SqlSession → Executor → StatementHandler → JDBC 执行。</td>
</tr>
<tr>
<td>注解与 XML 映射的区别？</td>
<td>注解轻量、便于维护小 SQL；XML 更灵活，支持动态标签、条件判断。</td>
</tr>
<tr>
<td>MyBatis 如何实现参数和结果映射？</td>
<td>参数：通过 ParameterHandler 替换占位符；结果：ResultSetHandler 根据 ResultMap 映射。</td>
</tr>
<tr>
<td>@SelectProvider 有什么用？</td>
<td>用于动态生成 SQL，支持复杂查询逻辑。</td>
</tr>
</tbody></table>
<h1 id="🌸-四、Spring-Boot-常用注解与底层机制（自动装配-条件加载）"><a href="#🌸-四、Spring-Boot-常用注解与底层机制（自动装配-条件加载）" class="headerlink" title="🌸 四、Spring Boot 常用注解与底层机制（自动装配 + 条件加载）"></a>🌸 四、Spring Boot 常用注解与底层机制（自动装配 + 条件加载）</h1><p>这一部分是面试高频 + 实战必懂的核心。<br> 重点是理解 <strong>Spring Boot 为什么能“自动装配”</strong>，以及这些注解在底层是怎么工作的。</p>
<hr>
<h2 id="一、Spring-Boot-核心注解全图"><a href="#一、Spring-Boot-核心注解全图" class="headerlink" title="一、Spring Boot 核心注解全图"></a>一、Spring Boot 核心注解全图</h2><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>核心原理</th>
</tr>
</thead>
<tbody><tr>
<td><code>@SpringBootApplication</code></td>
<td>核心入口注解（整合 3 个注解）</td>
<td>启动自动配置与组件扫描</td>
</tr>
<tr>
<td><code>@SpringBootConfiguration</code></td>
<td>标识配置类</td>
<td>继承自 <code>@Configuration</code></td>
</tr>
<tr>
<td><code>@EnableAutoConfiguration</code></td>
<td>自动装配核心</td>
<td>从 <code>META-INF/spring.factories</code> 加载配置类</td>
</tr>
<tr>
<td><code>@ComponentScan</code></td>
<td>包扫描</td>
<td>扫描项目包路径下的组件</td>
</tr>
<tr>
<td><code>@ConfigurationProperties</code></td>
<td>绑定配置文件属性</td>
<td>从 <code>application.yml</code> 绑定属性到 Bean</td>
</tr>
<tr>
<td><code>@Conditional</code> 系列</td>
<td>条件装配</td>
<td>控制 Bean 是否加载</td>
</tr>
<tr>
<td><code>@Import</code></td>
<td>导入配置类</td>
<td>支持多种导入方式（类、Selector、Registrar）</td>
</tr>
<tr>
<td><code>@Value</code></td>
<td>注入单个配置值</td>
<td>读取 Environment 中的配置</td>
</tr>
<tr>
<td><code>@RestController</code></td>
<td>&#x3D; <code>@Controller</code> + <code>@ResponseBody</code></td>
<td>快速创建 REST API</td>
</tr>
<tr>
<td><code>@SpringBootTest</code></td>
<td>测试启动</td>
<td>启动完整 SpringBoot 环境进行单元测试</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、核心注解剖析"><a href="#二、核心注解剖析" class="headerlink" title="二、核心注解剖析"></a>二、核心注解剖析</h2><h3 id="⚙️-1️⃣-SpringBootApplication（入口注解）"><a href="#⚙️-1️⃣-SpringBootApplication（入口注解）" class="headerlink" title="⚙️ 1️⃣ @SpringBootApplication（入口注解）"></a>⚙️ 1️⃣ @SpringBootApplication（入口注解）</h3><p>这是 Spring Boot 应用的入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>👉 所以它本质上是：</p>
<ol>
<li>声明一个配置类</li>
<li>启动自动装配</li>
<li>开启组件扫描</li>
</ol>
<hr>
<h3 id="⚙️-2️⃣-EnableAutoConfiguration（自动装配核心）"><a href="#⚙️-2️⃣-EnableAutoConfiguration（自动装配核心）" class="headerlink" title="⚙️ 2️⃣ @EnableAutoConfiguration（自动装配核心）"></a>⚙️ 2️⃣ @EnableAutoConfiguration（自动装配核心）</h3><blockquote>
<p>这是 Spring Boot 最重要的注解！</p>
</blockquote>
<p>底层逻辑：</p>
<ol>
<li>通过 <code>SpringFactoriesLoader</code> 读取所有 <code>META-INF/spring.factories</code> 文件；</li>
<li>找到 key 为 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 的类；</li>
<li>把这些类加载进容器；</li>
<li>根据 <code>@Conditional</code> 系列判断是否生效。</li>
</ol>
<p>这些类通常是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DataSourceAutoConfiguration</span><br><span class="line">WebMvcAutoConfiguration</span><br><span class="line">RedisAutoConfiguration</span><br><span class="line">SecurityAutoConfiguration</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这些就是所谓的“自动装配类”。</p>
<hr>
<h4 id="🔍-自动装配核心源码逻辑"><a href="#🔍-自动装配核心源码逻辑" class="headerlink" title="🔍 自动装配核心源码逻辑"></a>🔍 自动装配核心源码逻辑</h4><p>在 <code>AutoConfigurationImportSelector</code> 类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">        EnableAutoConfiguration.class, classLoader);</span><br></pre></td></tr></table></figure>

<p>每个自动配置类都像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DataSource.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以：<br> ✅ <strong>有 DataSource 类存在时才加载</strong><br> ✅ <strong>会自动从 application.yml 绑定属性</strong></p>
<hr>
<h3 id="⚙️-3️⃣-条件装配注解（Conditional-系列）"><a href="#⚙️-3️⃣-条件装配注解（Conditional-系列）" class="headerlink" title="⚙️ 3️⃣ 条件装配注解（Conditional 系列）"></a>⚙️ 3️⃣ 条件装配注解（Conditional 系列）</h3><table>
<thead>
<tr>
<th>注解</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>@ConditionalOnClass</code></td>
<td>类存在时加载</td>
</tr>
<tr>
<td><code>@ConditionalOnMissingBean</code></td>
<td>Bean 不存在时加载</td>
</tr>
<tr>
<td><code>@ConditionalOnProperty</code></td>
<td>指定配置项满足条件时加载</td>
</tr>
<tr>
<td><code>@ConditionalOnMissingClass</code></td>
<td>类不存在时加载</td>
</tr>
<tr>
<td><code>@ConditionalOnWebApplication</code></td>
<td>当前为 Web 环境时加载</td>
</tr>
<tr>
<td><code>@ConditionalOnExpression</code></td>
<td>满足 SpEL 表达式时加载</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;app.feature.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeatureConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FeatureService <span class="title function_">featureService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FeatureService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>👉 只有当配置文件里有 <code>app.feature.enabled=true</code> 时才加载。</p>
<hr>
<h3 id="⚙️-4️⃣-ConfigurationProperties（配置绑定）"><a href="#⚙️-4️⃣-ConfigurationProperties（配置绑定）" class="headerlink" title="⚙️ 4️⃣ @ConfigurationProperties（配置绑定）"></a>⚙️ 4️⃣ @ConfigurationProperties（配置绑定）</h3><p>自动绑定配置文件中的属性：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="string">@Component</span></span><br><span class="line"><span class="string">@ConfigurationProperties(prefix</span> <span class="string">=</span> <span class="string">&quot;server&quot;</span><span class="string">)</span></span><br><span class="line"><span class="string">public</span> <span class="string">class</span> <span class="string">ServerConfig</span> &#123;</span><br><span class="line">    <span class="string">private</span> <span class="string">int</span> <span class="string">port;</span></span><br><span class="line">    <span class="string">private</span> <span class="string">String</span> <span class="string">address;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层机制：</p>
<ul>
<li>通过 <code>Binder</code> 绑定 Environment 中的属性；</li>
<li>利用 <code>RelaxedDataBinder</code> 支持松散匹配；</li>
<li>可以用 <code>@EnableConfigurationProperties</code> 显式启用。</li>
</ul>
<hr>
<h3 id="⚙️-5️⃣-Import（手动扩展装配）"><a href="#⚙️-5️⃣-Import（手动扩展装配）" class="headerlink" title="⚙️ 5️⃣ @Import（手动扩展装配）"></a>⚙️ 5️⃣ @Import（手动扩展装配）</h3><p>四种导入方式：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>导入类</td>
<td><code>@Import(MyConfig.class)</code></td>
<td>导入配置类</td>
</tr>
<tr>
<td>导入 ImportSelector</td>
<td><code>@Import(MyImportSelector.class)</code></td>
<td>批量导入配置类</td>
</tr>
<tr>
<td>导入 ImportBeanDefinitionRegistrar</td>
<td><code>@Import(MyRegistrar.class)</code></td>
<td>动态注册 Bean</td>
</tr>
<tr>
<td>导入普通 Bean</td>
<td><code>@Import(&#123;A.class, B.class&#125;)</code></td>
<td>多类导入</td>
</tr>
</tbody></table>
<p>面试常问：</p>
<blockquote>
<p>“Spring Boot 自动装配用的是哪种方式？”<br> 答：<strong>ImportSelector（AutoConfigurationImportSelector）</strong></p>
</blockquote>
<hr>
<h2 id="三、Spring-Boot-启动流程（重点）"><a href="#三、Spring-Boot-启动流程（重点）" class="headerlink" title="三、Spring Boot 启动流程（重点）"></a>三、Spring Boot 启动流程（重点）</h2><p>当你执行 <code>SpringApplication.run()</code> 时，实际发生了：</p>
<p>1️⃣ 创建 <code>SpringApplication</code> 实例<br> 2️⃣ 推断应用类型（Web&#x2F;Reactive&#x2F;None）<br> 3️⃣ 加载 ApplicationContext<br> 4️⃣ 扫描主类所在包<br> 5️⃣ 加载自动配置类（EnableAutoConfiguration）<br> 6️⃣ 实例化 Bean + 依赖注入<br> 7️⃣ 启动内嵌服务器（Tomcat&#x2F;Jetty&#x2F;Undertow）</p>
<hr>
<h2 id="四、面试深问点（高分答法）"><a href="#四、面试深问点（高分答法）" class="headerlink" title="四、面试深问点（高分答法）"></a>四、面试深问点（高分答法）</h2><table>
<thead>
<tr>
<th>问题</th>
<th>高分答法</th>
</tr>
</thead>
<tbody><tr>
<td>Spring Boot 为什么能自动装配？</td>
<td>因为 @EnableAutoConfiguration 通过 SpringFactoriesLoader 从 META-INF&#x2F;spring.factories 加载自动配置类，并结合 @Conditional 系列按条件注册 Bean。</td>
</tr>
<tr>
<td>@SpringBootApplication 里面包含了什么？</td>
<td>它整合了 @Configuration、@EnableAutoConfiguration、@ComponentScan。</td>
</tr>
<tr>
<td>@ConfigurationProperties 和 @Value 区别？</td>
<td>前者用于批量属性绑定（对象映射），后者用于单值注入。</td>
</tr>
<tr>
<td>Spring Boot 启动流程？</td>
<td>run → 创建 ApplicationContext → 扫描组件 → 自动装配 → 启动容器（Tomcat）。</td>
</tr>
<tr>
<td>自动装配失效的原因有哪些？</td>
<td>类缺失、条件不满足（@Conditional）、配置关闭（spring.autoconfigure.exclude）。</td>
</tr>
</tbody></table>
<h1 id="🛡️-五、Spring-Security-常用注解与底层机制（认证与授权）"><a href="#🛡️-五、Spring-Security-常用注解与底层机制（认证与授权）" class="headerlink" title="🛡️ 五、Spring Security 常用注解与底层机制（认证与授权）"></a>🛡️ 五、Spring Security 常用注解与底层机制（认证与授权）</h1><p>Spring Security 是企业级安全框架，核心在于 <strong>认证（Authentication）</strong> 和 <strong>授权（Authorization）</strong>。<br> 注解只是暴露给开发者的快捷入口，底层依靠 <strong>过滤器链 + 访问决策管理器</strong> 实现安全控制。</p>
<hr>
<h2 id="一、核心注解总览"><a href="#一、核心注解总览" class="headerlink" title="一、核心注解总览"></a>一、核心注解总览</h2><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@EnableWebSecurity</strong></td>
<td>启用 Spring Security</td>
<td>配置类上</td>
</tr>
<tr>
<td><strong>@Configuration</strong></td>
<td>配置类</td>
<td>配合@EnableWebSecurity</td>
</tr>
<tr>
<td><strong>@Secured</strong></td>
<td>方法级权限</td>
<td>限制角色访问，老版本</td>
</tr>
<tr>
<td><strong>@PreAuthorize</strong></td>
<td>方法前表达式授权</td>
<td>支持 SpEL 表达式，推荐</td>
</tr>
<tr>
<td><strong>@PostAuthorize</strong></td>
<td>方法后表达式授权</td>
<td>可基于返回值做授权判断</td>
</tr>
<tr>
<td><strong>@RolesAllowed</strong></td>
<td>JSR-250 标准</td>
<td>限制角色访问</td>
</tr>
<tr>
<td><strong>@WithMockUser</strong></td>
<td>测试模拟用户</td>
<td>单元测试</td>
</tr>
<tr>
<td><strong>@AuthenticationPrincipal</strong></td>
<td>获取当前认证用户</td>
<td>Controller 方法参数注入</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、核心机制解析"><a href="#二、核心机制解析" class="headerlink" title="二、核心机制解析"></a>二、核心机制解析</h2><h3 id="1️⃣-FilterChainProxy（安全过滤器链）"><a href="#1️⃣-FilterChainProxy（安全过滤器链）" class="headerlink" title="1️⃣ FilterChainProxy（安全过滤器链）"></a>1️⃣ FilterChainProxy（安全过滤器链）</h3><p>Spring Security 基于 <strong>Servlet Filter</strong> 实现，核心流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求 → FilterChainProxy → SecurityFilters（多个） → DispatcherServlet</span><br></pre></td></tr></table></figure>

<ul>
<li>常用 Filter：<ul>
<li><code>UsernamePasswordAuthenticationFilter</code>：表单登录</li>
<li><code>BasicAuthenticationFilter</code>：HTTP Basic</li>
<li><code>ExceptionTranslationFilter</code>：异常处理</li>
<li><code>FilterSecurityInterceptor</code>：最终授权决策</li>
</ul>
</li>
</ul>
<p>💡 面试高频：</p>
<blockquote>
<p>“Spring Security 如何拦截请求？”<br> 答：通过 <code>FilterChainProxy</code>，按顺序执行过滤器链，每个 Filter 负责不同安全功能。</p>
</blockquote>
<hr>
<h3 id="2️⃣-EnableWebSecurity"><a href="#2️⃣-EnableWebSecurity" class="headerlink" title="2️⃣ @EnableWebSecurity"></a>2️⃣ @EnableWebSecurity</h3><ul>
<li>激活 Web 安全配置；</li>
<li>内部通过 <code>@Import(WebSecurityConfiguration.class)</code> 注入：<ul>
<li><code>FilterChainProxy</code></li>
<li><code>AuthenticationManager</code></li>
<li><code>AccessDecisionManager</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="3️⃣-方法级权限注解"><a href="#3️⃣-方法级权限注解" class="headerlink" title="3️⃣ 方法级权限注解"></a>3️⃣ 方法级权限注解</h3><h4 id="a-Secured"><a href="#a-Secured" class="headerlink" title="a. @Secured"></a>a. @Secured</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Secured(&quot;ROLE_ADMIN&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>仅支持角色（ROLE_ 前缀）</li>
<li>核心类：<code>SecuredAnnotationSecurityMetadataSource</code></li>
</ul>
<h4 id="b-PreAuthorize-PostAuthorize"><a href="#b-PreAuthorize-PostAuthorize" class="headerlink" title="b. @PreAuthorize &#x2F; @PostAuthorize"></a>b. @PreAuthorize &#x2F; @PostAuthorize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;) and #id == authentication.principal.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(Long id)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostAuthorize(&quot;returnObject.owner == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>支持 SpEL 表达式，可基于方法参数、返回值、认证对象授权</li>
<li>核心类：<ul>
<li><code>ExpressionBasedAnnotationAttributeFactory</code></li>
<li><code>PreInvocationAuthorizationAdviceVoter</code></li>
</ul>
</li>
</ul>
<h4 id="c-RolesAllowed"><a href="#c-RolesAllowed" class="headerlink" title="c. @RolesAllowed"></a>c. @RolesAllowed</h4><ul>
<li>JSR-250 标准，底层映射到 <code>Jsr250MethodSecurityMetadataSource</code></li>
</ul>
<hr>
<h3 id="4️⃣-获取当前用户注解"><a href="#4️⃣-获取当前用户注解" class="headerlink" title="4️⃣ 获取当前用户注解"></a>4️⃣ 获取当前用户注解</h3><h4 id="AuthenticationPrincipal"><a href="#AuthenticationPrincipal" class="headerlink" title="@AuthenticationPrincipal"></a>@AuthenticationPrincipal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/me&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">me</span><span class="params">(<span class="meta">@AuthenticationPrincipal</span> User user)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注入当前认证对象</li>
<li>底层通过 <code>SecurityContextHolder.getContext().getAuthentication().getPrincipal()</code></li>
</ul>
<hr>
<h3 id="5️⃣-测试支持"><a href="#5️⃣-测试支持" class="headerlink" title="5️⃣ 测试支持"></a>5️⃣ 测试支持</h3><h4 id="WithMockUser"><a href="#WithMockUser" class="headerlink" title="@WithMockUser"></a>@WithMockUser</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithMockUser(username=&quot;admin&quot;, roles=&#123;&quot;ADMIN&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdminAccess</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>模拟登录用户，方便方法级安全测试</li>
</ul>
<hr>
<h3 id="6️⃣-身份认证流程（核心链条）"><a href="#6️⃣-身份认证流程（核心链条）" class="headerlink" title="6️⃣ 身份认证流程（核心链条）"></a>6️⃣ 身份认证流程（核心链条）</h3><ol>
<li>用户请求登录 <code>/login</code></li>
<li><code>UsernamePasswordAuthenticationFilter</code> 拦截请求</li>
<li>调用 <code>AuthenticationManager</code> → <code>ProviderManager</code></li>
<li>执行 <code>UserDetailsService.loadUserByUsername</code> 获取用户信息</li>
<li>验证密码 → 生成 <code>Authentication</code> → 存入 <code>SecurityContextHolder</code></li>
<li>后续请求通过过滤器链进行授权检查</li>
</ol>
<hr>
<h3 id="7️⃣-授权决策"><a href="#7️⃣-授权决策" class="headerlink" title="7️⃣ 授权决策"></a>7️⃣ 授权决策</h3><ul>
<li>核心类：<code>AccessDecisionManager</code></li>
<li>核心逻辑：<ol>
<li>获取请求 URL &#x2F; 方法的权限元信息（MetadataSource）</li>
<li>通过 <code>Voter</code> 投票机制判定允许或拒绝</li>
<li>常用 Voter：<ul>
<li><code>RoleVoter</code></li>
<li><code>AuthenticatedVoter</code></li>
<li><code>ExpressionVoter</code>（用于 @PreAuthorize &#x2F; @PostAuthorize）</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="三、面试追问点（高分回答）"><a href="#三、面试追问点（高分回答）" class="headerlink" title="三、面试追问点（高分回答）"></a>三、面试追问点（高分回答）</h2><table>
<thead>
<tr>
<th>问题</th>
<th>高分答法</th>
</tr>
</thead>
<tbody><tr>
<td>Spring Security 如何拦截请求？</td>
<td>通过 <code>FilterChainProxy</code> 执行多个 Filter，每个 Filter 完成认证或授权逻辑。</td>
</tr>
<tr>
<td>@PreAuthorize 与 @Secured 区别？</td>
<td>@Secured 仅支持角色，@PreAuthorize 支持 SpEL 表达式，可基于方法参数&#x2F;返回值授权。</td>
</tr>
<tr>
<td>当前用户怎么获取？</td>
<td><code>SecurityContextHolder.getContext().getAuthentication().getPrincipal()</code> 或 <code>@AuthenticationPrincipal</code> 注入。</td>
</tr>
<tr>
<td>FilterChain 执行顺序？</td>
<td>登录认证 → 异常处理 → 授权 → 业务 Controller → 响应处理。</td>
</tr>
<tr>
<td>如何测试方法级安全？</td>
<td>使用 <code>@WithMockUser</code> 注解模拟用户身份。</td>
</tr>
</tbody></table>
<h1 id="☁️-六、Spring-Cloud-常用注解与底层机制（服务注册、发现、负载均衡、远程调用）"><a href="#☁️-六、Spring-Cloud-常用注解与底层机制（服务注册、发现、负载均衡、远程调用）" class="headerlink" title="☁️ 六、Spring Cloud 常用注解与底层机制（服务注册、发现、负载均衡、远程调用）"></a>☁️ 六、Spring Cloud 常用注解与底层机制（服务注册、发现、负载均衡、远程调用）</h1><p>Spring Cloud 是微服务架构核心框架，它提供了 <strong>服务治理、配置中心、服务调用、熔断降级</strong> 等功能。<br> 我们重点分析 <strong>常用注解 + 底层原理 + 面试追问点</strong>。</p>
<hr>
<h2 id="一、服务注册与发现（Eureka-Nacos）"><a href="#一、服务注册与发现（Eureka-Nacos）" class="headerlink" title="一、服务注册与发现（Eureka &#x2F; Nacos）"></a>一、服务注册与发现（Eureka &#x2F; Nacos）</h2><h3 id="1️⃣-核心注解"><a href="#1️⃣-核心注解" class="headerlink" title="1️⃣ 核心注解"></a>1️⃣ 核心注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@EnableEurekaClient</code></td>
<td>启用 Eureka 客户端，自动注册服务</td>
</tr>
<tr>
<td><code>@EnableDiscoveryClient</code></td>
<td>通用服务发现注解（Eureka、Consul、Nacos）</td>
</tr>
<tr>
<td><code>@LoadBalanced</code></td>
<td>配置 RestTemplate 或 WebClient 支持客户端负载均衡</td>
</tr>
<tr>
<td><code>@RefreshScope</code></td>
<td>配置热刷新，用于配置中心动态刷新</td>
</tr>
</tbody></table>
<hr>
<h3 id="2️⃣-服务注册流程（Eureka-示例）"><a href="#2️⃣-服务注册流程（Eureka-示例）" class="headerlink" title="2️⃣ 服务注册流程（Eureka 示例）"></a>2️⃣ 服务注册流程（Eureka 示例）</h3><ol>
<li>启动微服务 → <code>EurekaClient</code> 初始化</li>
<li>发送心跳 <code>POST /eureka/apps/&#123;serviceName&#125;</code></li>
<li>Eureka Server 接收并注册实例</li>
<li>其他微服务通过 <code>/eureka/apps</code> 获取服务列表</li>
<li>内部缓存一份服务列表，提高访问效率</li>
</ol>
<blockquote>
<p>🔥 面试点：Eureka 默认 <strong>心跳 30s</strong>，下线延迟 90s，可能存在短暂不可用。</p>
</blockquote>
<hr>
<h2 id="二、负载均衡（Ribbon-Spring-Cloud-LoadBalancer）"><a href="#二、负载均衡（Ribbon-Spring-Cloud-LoadBalancer）" class="headerlink" title="二、负载均衡（Ribbon &#x2F; Spring Cloud LoadBalancer）"></a>二、负载均衡（Ribbon &#x2F; Spring Cloud LoadBalancer）</h2><h3 id="1️⃣-核心注解-1"><a href="#1️⃣-核心注解-1" class="headerlink" title="1️⃣ 核心注解"></a>1️⃣ 核心注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@LoadBalanced</code></td>
<td>配置 RestTemplate 或 WebClient 支持 Ribbon 或 Spring Cloud LoadBalancer</td>
</tr>
<tr>
<td><code>@FeignClient</code></td>
<td>声明式远程调用，集成负载均衡和熔断</td>
</tr>
</tbody></table>
<hr>
<h3 id="2️⃣-客户端负载均衡原理"><a href="#2️⃣-客户端负载均衡原理" class="headerlink" title="2️⃣ 客户端负载均衡原理"></a>2️⃣ 客户端负载均衡原理</h3><ul>
<li><strong>Ribbon（老版）</strong>：<ul>
<li>从服务发现获取服务列表</li>
<li>使用负载策略（轮询、随机、权重）选择实例</li>
<li>发起请求</li>
</ul>
</li>
<li><strong>Spring Cloud LoadBalancer（新方案）</strong>：<ul>
<li>默认轮询算法</li>
<li>支持自定义策略</li>
<li>通过 <code>LoadBalancerClient</code> 或 <code>ReactiveLoadBalancer</code> 选择实例</li>
</ul>
</li>
</ul>
<hr>
<h2 id="三、声明式远程调用（Feign）"><a href="#三、声明式远程调用（Feign）" class="headerlink" title="三、声明式远程调用（Feign）"></a>三、声明式远程调用（Feign）</h2><h3 id="1️⃣-核心注解-2"><a href="#1️⃣-核心注解-2" class="headerlink" title="1️⃣ 核心注解"></a>1️⃣ 核心注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@EnableFeignClients</code></td>
<td>启用 Feign 客户端扫描</td>
</tr>
<tr>
<td><code>@FeignClient(name=&quot;service-name&quot;, path=&quot;/api&quot;)</code></td>
<td>声明远程服务接口</td>
</tr>
<tr>
<td><code>@RequestMapping / @GetMapping / @PostMapping</code></td>
<td>定义远程调用接口方法</td>
</tr>
</tbody></table>
<hr>
<h3 id="2️⃣-Feign-调用原理"><a href="#2️⃣-Feign-调用原理" class="headerlink" title="2️⃣ Feign 调用原理"></a>2️⃣ Feign 调用原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FeignClient Proxy（动态代理）</span><br><span class="line">    ↓</span><br><span class="line">Spring Cloud LoadBalancer（选择实例）</span><br><span class="line">    ↓</span><br><span class="line">Ribbon 或 RestTemplate 执行 HTTP 请求</span><br><span class="line">    ↓</span><br><span class="line">返回结果 → JSON 转对象</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3️⃣-示例"><a href="#3️⃣-示例" class="headerlink" title="3️⃣ 示例"></a>3️⃣ 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name=&quot;user-service&quot;, path=&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用 <code>userClient.getUser(1L)</code> 时：</p>
<ol>
<li>Feign 创建动态代理对象</li>
<li>使用服务注册中心获取可用实例</li>
<li>通过 HTTP 发起请求</li>
<li>返回 JSON 转对象</li>
</ol>
</blockquote>
<hr>
<h2 id="四、网关（Spring-Cloud-Gateway）"><a href="#四、网关（Spring-Cloud-Gateway）" class="headerlink" title="四、网关（Spring Cloud Gateway）"></a>四、网关（Spring Cloud Gateway）</h2><h3 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@EnableGateway</code></td>
<td>启用网关（Spring Boot 自动装配即可）</td>
</tr>
<tr>
<td><code>@Bean RouteLocator</code></td>
<td>配置路由规则</td>
</tr>
<tr>
<td><code>@Configuration</code></td>
<td>配置类，定义自定义过滤器</td>
</tr>
</tbody></table>
<h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><ul>
<li>基于 <strong>WebFlux &#x2F; Netty</strong> 实现异步非阻塞网关</li>
<li>请求 → GlobalFilter → RouteLocator 匹配 → 目标服务</li>
<li>支持限流、熔断、重试、认证等功能</li>
</ul>
<hr>
<h2 id="五、熔断与降级（Resilience4j-Spring-Cloud-CircuitBreaker）"><a href="#五、熔断与降级（Resilience4j-Spring-Cloud-CircuitBreaker）" class="headerlink" title="五、熔断与降级（Resilience4j &#x2F; Spring Cloud CircuitBreaker）"></a>五、熔断与降级（Resilience4j &#x2F; Spring Cloud CircuitBreaker）</h2><h3 id="核心注解-1"><a href="#核心注解-1" class="headerlink" title="核心注解"></a>核心注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@EnableCircuitBreaker</code></td>
<td>启用熔断器</td>
</tr>
<tr>
<td><code>@CircuitBreaker(name=&quot;backend&quot;, fallbackMethod=&quot;fallback&quot;)</code></td>
<td>方法级熔断</td>
</tr>
<tr>
<td><code>@Retryable</code></td>
<td>方法重试</td>
</tr>
<tr>
<td><code>@TimeLimiter</code></td>
<td>异步方法超时控制</td>
</tr>
</tbody></table>
<hr>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li>调用被监控方法</li>
<li>出现异常或超时，熔断器计数器累加</li>
<li>达到阈值 → 打开熔断，直接调用 fallback</li>
<li>超过时间或条件恢复 → 关闭熔断器</li>
</ol>
<hr>
<h2 id="六、面试高频问点"><a href="#六、面试高频问点" class="headerlink" title="六、面试高频问点"></a>六、面试高频问点</h2><table>
<thead>
<tr>
<th>问题</th>
<th>高分回答</th>
</tr>
</thead>
<tbody><tr>
<td>Spring Cloud 如何实现服务注册与发现？</td>
<td>微服务启动注册到 Eureka&#x2F;Nacos，通过客户端缓存获取可用服务列表，实现服务调用。</td>
</tr>
<tr>
<td>@FeignClient 如何负载均衡？</td>
<td>结合 Ribbon 或 Spring Cloud LoadBalancer，通过服务注册中心获取实例列表，并按策略选择。</td>
</tr>
<tr>
<td>网关路由原理？</td>
<td>请求经过 GlobalFilter → RouteLocator 匹配 → Forward 到目标服务，支持限流、认证、熔断。</td>
</tr>
<tr>
<td>熔断器是怎么工作的？</td>
<td>通过 CircuitBreaker 监控方法调用，达到阈值时打开熔断，调用 fallback 方法。</td>
</tr>
<tr>
<td>@RefreshScope 作用？</td>
<td>允许 Bean 在配置中心更新时热刷新，不重启应用即可生效。</td>
</tr>
</tbody></table>
<hr>
<p>完全可以 😎！我帮你整理一份 <strong>六大框架超级速记卡 &#x2F; 可打印版知识图谱</strong>，兼顾：</p>
<ul>
<li><strong>结构图</strong>：模块 + 核心注解分类</li>
<li><strong>流程链</strong>：底层执行顺序（请求 → 执行 → 返回）</li>
<li><strong>时机表</strong>：各注解触发时机 &#x2F; 生命周期</li>
</ul>
<p>我设计成一页 A4 可打印的面试速记卡风格，每个框架重点突出高频面试点。</p>
<hr>
<h3 id="样例结构（六大框架速查卡）"><a href="#样例结构（六大框架速查卡）" class="headerlink" title="样例结构（六大框架速查卡）"></a>样例结构（六大框架速查卡）</h3><hr>
<h2 id="1️⃣-Spring-核心注解-生命周期"><a href="#1️⃣-Spring-核心注解-生命周期" class="headerlink" title="1️⃣ Spring 核心注解 &amp; 生命周期"></a>1️⃣ Spring 核心注解 &amp; 生命周期</h2><p><strong>模块结构图</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component / @Service / @Repository / @Controller</span><br><span class="line">         ↓</span><br><span class="line">@Autowired / @Qualifier → 依赖注入</span><br><span class="line">@PostConstruct / @PreDestroy → 生命周期回调</span><br><span class="line">@Scope → Bean 范围（Singleton / Prototype / Request / Session）</span><br></pre></td></tr></table></figure>

<p><strong>执行链</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bean 定义加载 → BeanPostProcessor → 初始化（@PostConstruct） → 依赖注入完成 → Bean 可用</span><br></pre></td></tr></table></figure>

<p><strong>时机表</strong>：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>@Component&#x2F;@Service</td>
<td>容器启动扫描注册</td>
</tr>
<tr>
<td>@Autowired</td>
<td>Bean 初始化阶段注入</td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>Bean 初始化后立即调用</td>
</tr>
<tr>
<td>@PreDestroy</td>
<td>容器关闭前调用</td>
</tr>
</tbody></table>
<hr>
<h2 id="2️⃣-SpringMVC-注解-请求处理"><a href="#2️⃣-SpringMVC-注解-请求处理" class="headerlink" title="2️⃣ SpringMVC 注解 &amp; 请求处理"></a>2️⃣ SpringMVC 注解 &amp; 请求处理</h2><p><strong>结构图</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Controller / @RestController</span><br><span class="line">        ↓</span><br><span class="line">@RequestMapping / @GetMapping / @PostMapping</span><br><span class="line">        ↓</span><br><span class="line">@PathVariable / @RequestParam / @RequestBody / @ResponseBody</span><br><span class="line">        ↓</span><br><span class="line">@ExceptionHandler / @ControllerAdvice</span><br></pre></td></tr></table></figure>

<p><strong>执行链</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP 请求 → DispatcherServlet → HandlerMapping → HandlerAdapter → Controller → ViewResolver → Response</span><br></pre></td></tr></table></figure>

<p><strong>时机表</strong>：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>@ControllerAdvice</td>
<td>Controller 异常触发</td>
</tr>
<tr>
<td>@InitBinder</td>
<td>Controller 方法调用前绑定参数</td>
</tr>
<tr>
<td>@RequestBody &#x2F; @ResponseBody</td>
<td>方法调用序列中请求解析 &amp; 响应序列化</td>
</tr>
</tbody></table>
<hr>
<h2 id="3️⃣-MyBatis-注解-SQL-执行"><a href="#3️⃣-MyBatis-注解-SQL-执行" class="headerlink" title="3️⃣ MyBatis 注解 &amp; SQL 执行"></a>3️⃣ MyBatis 注解 &amp; SQL 执行</h2><p><strong>结构图</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Mapper / @MapperScan</span><br><span class="line">        ↓</span><br><span class="line">MapperProxy → SqlSession → Executor → StatementHandler → ResultSetHandler → 返回对象</span><br><span class="line">@Select / @Insert / @Update / @Delete</span><br><span class="line">@Param → 参数绑定</span><br><span class="line">@Results / @Result → 字段映射</span><br></pre></td></tr></table></figure>

<p><strong>执行链</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口方法调用 → MapperProxy.invoke() → SqlSession.select() → Executor → JDBC → ResultSet → 映射到对象</span><br></pre></td></tr></table></figure>

<p><strong>时机表</strong>：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>@MapperScan</td>
<td>容器启动时扫描 Mapper</td>
</tr>
<tr>
<td>@Select &#x2F; @Insert</td>
<td>方法调用时解析 SQL</td>
</tr>
<tr>
<td>@Param</td>
<td>方法调用解析参数</td>
</tr>
<tr>
<td>@Results</td>
<td>执行 SQL 返回结果映射</td>
</tr>
</tbody></table>
<hr>
<h2 id="4️⃣-Spring-Boot-注解-自动装配"><a href="#4️⃣-Spring-Boot-注解-自动装配" class="headerlink" title="4️⃣ Spring Boot 注解 &amp; 自动装配"></a>4️⃣ Spring Boot 注解 &amp; 自动装配</h2><p><strong>结构图</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">        ↓</span><br><span class="line">@SpringBootConfiguration / @EnableAutoConfiguration / @ComponentScan</span><br><span class="line">        ↓</span><br><span class="line">@ConfigurationProperties → 配置绑定</span><br><span class="line">@Conditional 系列 → 条件加载</span><br></pre></td></tr></table></figure>

<p><strong>执行链</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.run() → ApplicationContext 创建 → 自动配置加载 → Bean 实例化 → 自动装配 → 容器启动</span><br></pre></td></tr></table></figure>

<p><strong>时机表</strong>：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>@EnableAutoConfiguration</td>
<td>ApplicationContext 创建阶段</td>
</tr>
<tr>
<td>@ConditionalOnClass &#x2F; OnMissingBean</td>
<td>Bean 实例化前条件判断</td>
</tr>
<tr>
<td>@ConfigurationProperties</td>
<td>Bean 实例化绑定属性</td>
</tr>
<tr>
<td>@Value</td>
<td>Bean 初始化注入属性</td>
</tr>
</tbody></table>
<hr>
<h2 id="5️⃣-Spring-Security-注解-权限控制"><a href="#5️⃣-Spring-Security-注解-权限控制" class="headerlink" title="5️⃣ Spring Security 注解 &amp; 权限控制"></a>5️⃣ Spring Security 注解 &amp; 权限控制</h2><p><strong>结构图</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@EnableWebSecurity</span><br><span class="line">        ↓</span><br><span class="line">FilterChainProxy → 各类 Filter（认证/授权）</span><br><span class="line">@Secured / @PreAuthorize / @PostAuthorize / @RolesAllowed</span><br><span class="line">@AuthenticationPrincipal → 注入用户</span><br><span class="line">@WithMockUser → 测试</span><br></pre></td></tr></table></figure>

<p><strong>执行链</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求 → FilterChainProxy → AuthenticationManager → UserDetailsService → 验证 → SecurityContextHolder → 授权 → Controller</span><br></pre></td></tr></table></figure>

<p><strong>时机表</strong>：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>@EnableWebSecurity</td>
<td>容器启动配置安全过滤器链</td>
</tr>
<tr>
<td>@PreAuthorize &#x2F; @Secured</td>
<td>方法调用前判断权限</td>
</tr>
<tr>
<td>@PostAuthorize</td>
<td>方法执行后基于返回值判断</td>
</tr>
<tr>
<td>@AuthenticationPrincipal</td>
<td>Controller 方法参数注入当前用户</td>
</tr>
</tbody></table>
<hr>
<h2 id="6️⃣-Spring-Cloud-注解-微服务调用"><a href="#6️⃣-Spring-Cloud-注解-微服务调用" class="headerlink" title="6️⃣ Spring Cloud 注解 &amp; 微服务调用"></a>6️⃣ Spring Cloud 注解 &amp; 微服务调用</h2><p><strong>结构图</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableEurekaClient / @EnableDiscoveryClient</span><br><span class="line">        ↓</span><br><span class="line">服务注册 → Eureka / Nacos</span><br><span class="line">@LoadBalanced → RestTemplate / WebClient</span><br><span class="line">@FeignClient → 声明式远程调用</span><br><span class="line">@CircuitBreaker / @Retryable → 熔断与重试</span><br><span class="line">@RefreshScope → 配置热刷新</span><br></pre></td></tr></table></figure>

<p><strong>执行链</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端请求 → 服务注册中心获取实例 → 负载均衡选择 → 远程调用 → 返回 → 熔断/降级处理</span><br></pre></td></tr></table></figure>

<p><strong>时机表</strong>：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>@EnableEurekaClient</td>
<td>启动时注册服务</td>
</tr>
<tr>
<td>@FeignClient</td>
<td>接口方法调用时生成动态代理发 HTTP</td>
</tr>
<tr>
<td>@LoadBalanced</td>
<td>RestTemplate 调用前选择服务实例</td>
</tr>
<tr>
<td>@CircuitBreaker</td>
<td>方法执行异常或超时触发</td>
</tr>
</tbody></table>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://charlotte030710.github.io">Charlotte</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://charlotte030710.github.io/2025/10/01/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">https://charlotte030710.github.io/2025/10/01/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://charlotte030710.github.io" target="_blank">浮生若梦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/img/title.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/01/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/" title="牛客面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">牛客面试题</div></div><div class="info-2"><div class="info-item-1"> Spring-牛客面经八股 1. 说说 Spring Boot 常用的注解 @SpringBootApplication：组合注解（@Configuration + @EnableAutoConfiguration + @ComponentScan），应用入口常放在主类上。 @Configuration &#x2F; @Bean：定义配置类和显式创建 Bean。 @Component &#x2F; @Service &#x2F; @Repository &#x2F; @Controller &#x2F; @RestController：组件扫描管理类；@RestController = @Controller + @ResponseBody。 @Autowired &#x2F; @Qualifier &#x2F; @Value &#x2F; @Resource：依赖注入、按类型&#x2F;按名称注入、读取配置。 @ConfigurationProperties：将一组配置绑定到 POJO（推荐用于复杂配置）。 @EnableAutoConfiguration（隐含在 @Spri...</div></div></div></a><a class="pagination-related" href="/2025/09/23/%E7%AE%80%E6%98%93%E7%89%88%E9%A2%98%E7%9B%AE/" title="简易版题目"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">简易版题目</div></div><div class="info-2"><div class="info-item-1">📚 数据库题库答案1、OSI 七层模型 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 功能：自下而上分别负责传输介质、链路控制、路由转发、端到端传输、会话管理、数据格式转换、应用服务。   2、TCP 的三次握手 客户端 → 服务端：SYN&#x3D;1（请求建立连接）。 服务端 → 客户端：SYN&#x3D;1, ACK&#x3D;1（确认并同意建立）。 客户端 → 服务端：ACK&#x3D;1（确认）。 👉 作用：确保双方具备收发能力，并同步初始序列号。   3、TCP 的四次挥手 客户端 → 服务端：FIN&#x3D;1（我没数据了）。 服务端 → 客户端：ACK&#x3D;1（收到）。 服务端 → 客户端：FIN&#x3D;1（我也没数据了）。 客户端 → 服务端：ACK&#x3D;1（收到）。 👉 双方各自独立关闭。   4、SQL 语言和方言的区别 SQL 语言：标准 SQL（ANSI&#x2F;ISO 定义），如 SELECT * FROM table;。 SQL 方言：不同数据库厂商在标准 SQL 基础上扩展的特性，如 MySQL 的 LIM...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/01/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/" title="牛客面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-01</div><div class="info-item-2">牛客面试题</div></div><div class="info-2"><div class="info-item-1"> Spring-牛客面经八股 1. 说说 Spring Boot 常用的注解 @SpringBootApplication：组合注解（@Configuration + @EnableAutoConfiguration + @ComponentScan），应用入口常放在主类上。 @Configuration &#x2F; @Bean：定义配置类和显式创建 Bean。 @Component &#x2F; @Service &#x2F; @Repository &#x2F; @Controller &#x2F; @RestController：组件扫描管理类；@RestController = @Controller + @ResponseBody。 @Autowired &#x2F; @Qualifier &#x2F; @Value &#x2F; @Resource：依赖注入、按类型&#x2F;按名称注入、读取配置。 @ConfigurationProperties：将一组配置绑定到 POJO（推荐用于复杂配置）。 @EnableAutoConfiguration（隐含在 @Spri...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/title.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Charlotte</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/charlotte030710"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Das Leben schwingt wie ein Pendel, hin und her, zwischen dem Schmerz und der Langeweile.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%80%E3%80%81Spring-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%88IOC-AOP-%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">🧩 一、Spring 常用注解（IOC &#x2F; AOP 核心）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A0-1-IOC-%E7%9B%B8%E5%85%B3%EF%BC%88%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%89"><span class="toc-number">1.0.1.</span> <span class="toc-text">💠 1. IOC 相关（控制反转）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A0-2-AOP-%E7%9B%B8%E5%85%B3%EF%BC%88%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%89"><span class="toc-number">1.0.2.</span> <span class="toc-text">💠 2. AOP 相关（切面编程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A0-3-%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3"><span class="toc-number">1.0.3.</span> <span class="toc-text">💠 3. 配置相关</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%90-%E4%BA%8C%E3%80%81Spring-MVC-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">🌐 二、Spring MVC 常用注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A0-1-%E6%8E%A7%E5%88%B6%E5%B1%82%E6%98%A0%E5%B0%84"><span class="toc-number">2.0.1.</span> <span class="toc-text">💠 1. 控制层映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A0-2-%E5%BC%82%E5%B8%B8-%E8%BF%94%E5%9B%9E%E5%A4%84%E7%90%86"><span class="toc-number">2.0.2.</span> <span class="toc-text">💠 2. 异常 &amp; 返回处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%92%BE-%E4%B8%89%E3%80%81MyBatis-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">💾 三、MyBatis 常用注解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9A%80-%E5%9B%9B%E3%80%81Spring-Boot-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">🚀 四、Spring Boot 常用注解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%90-%E4%BA%94%E3%80%81Spring-Security-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">🔐 五、Spring Security 常用注解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%98%81%EF%B8%8F-%E5%85%AD%E3%80%81Spring-Cloud-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">☁️ 六、Spring Cloud 常用注解（微服务体系）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A0-1-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%EF%BC%88Eureka-Nacos%EF%BC%89"><span class="toc-number">6.0.1.</span> <span class="toc-text">💠 1. 服务注册与发现（Eureka &#x2F; Nacos）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A0-2-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%EF%BC%88OpenFeign%EF%BC%89"><span class="toc-number">6.0.2.</span> <span class="toc-text">💠 2. 服务调用（OpenFeign）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A0-3-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%EF%BC%88Gateway%EF%BC%89"><span class="toc-number">6.0.3.</span> <span class="toc-text">💠 3. 服务网关（Gateway）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A0-4-%E7%86%94%E6%96%AD-%E9%99%90%E6%B5%81%EF%BC%88Hystrix-Sentinel%EF%BC%89"><span class="toc-number">6.0.4.</span> <span class="toc-text">💠 4. 熔断 &amp; 限流（Hystrix &#x2F; Sentinel）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%93%98-%E4%B8%83%E3%80%81%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BF%86%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">7.</span> <span class="toc-text">📘 七、面试记忆小技巧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%B1-%E4%B8%80%E3%80%81Spring-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%88IOC-AOP%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">🌱 一、Spring 核心注解运行机制（IOC &#x2F; AOP）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-Component-%E7%B3%BB%E5%88%97%E6%B3%A8%E8%A7%A3%EF%BC%88Bean-%E6%89%AB%E6%8F%8F%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">8.0.1.</span> <span class="toc-text">1️⃣ @Component 系列注解（Bean 扫描注册流程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-Autowired-%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">8.0.2.</span> <span class="toc-text">2️⃣ @Autowired 注入流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-Configuration-Bean"><span class="toc-number">8.0.3.</span> <span class="toc-text">3️⃣ @Configuration + @Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-AOP-%E6%B3%A8%E8%A7%A3%EF%BC%88-Aspect-Around-%E7%AD%89%EF%BC%89"><span class="toc-number">8.0.4.</span> <span class="toc-text">4️⃣ AOP 注解（@Aspect, @Around 等）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%90-%E4%BA%8C%E3%80%81Spring-MVC-%E6%B3%A8%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">🌐 二、Spring MVC 注解运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-RequestMapping%E3%80%81-GetMapping"><span class="toc-number">9.0.1.</span> <span class="toc-text">1️⃣ @RequestMapping、@GetMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-RequestBody-ResponseBody"><span class="toc-number">9.0.2.</span> <span class="toc-text">2️⃣ @RequestBody &#x2F; @ResponseBody</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%92%BE-%E4%B8%89%E3%80%81MyBatis-%E6%B3%A8%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">10.</span> <span class="toc-text">💾 三、MyBatis 注解运行机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9A%80-%E5%9B%9B%E3%80%81Spring-Boot-%E6%B3%A8%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">11.</span> <span class="toc-text">🚀 四、Spring Boot 注解运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-SpringBootApplication-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="toc-number">11.0.1.</span> <span class="toc-text">1️⃣ @SpringBootApplication 自动装配流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%90-%E4%BA%94%E3%80%81Spring-Security-%E6%B3%A8%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">12.</span> <span class="toc-text">🔐 五、Spring Security 注解运行机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%98%81%EF%B8%8F-%E5%85%AD%E3%80%81Spring-Cloud-%E6%B3%A8%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">13.</span> <span class="toc-text">☁️ 六、Spring Cloud 注解运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-EnableDiscoveryClient"><span class="toc-number">13.0.1.</span> <span class="toc-text">1️⃣ @EnableDiscoveryClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-FeignClient"><span class="toc-number">13.0.2.</span> <span class="toc-text">2️⃣ @FeignClient</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A8-%E4%B8%83%E3%80%81%E6%89%80%E6%9C%89%E6%A1%86%E6%9E%B6%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA%E6%80%BB%E8%A7%88%E8%A1%A8"><span class="toc-number">13.1.</span> <span class="toc-text">🚨 七、所有框架调用时机总览表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E5%85%AB%E3%80%81%E9%9D%A2%E8%AF%95%E5%BB%B6%E4%BC%B8%E9%80%BB%E8%BE%91%EF%BC%88%E9%AB%98%E9%A2%91%E9%97%AE%E6%B3%95%EF%BC%89"><span class="toc-number">13.2.</span> <span class="toc-text">🧠 八、面试延伸逻辑（高频问法）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%B1-%E4%B8%80%E3%80%81Spring-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%EF%BC%88IOC-AOP%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">🌱 一、Spring 核心注解 深入解析（IOC + AOP）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-IOC-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6"><span class="toc-number">14.1.</span> <span class="toc-text">1️⃣ IOC 核心注解机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-1-%E5%8E%9F%E7%90%86"><span class="toc-number">14.1.1.</span> <span class="toc-text">🔍 1. 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A7%A9-IOC%EF%BC%88Inversion-of-Control%EF%BC%89%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="toc-number">14.1.1.1.</span> <span class="toc-text">🧩 IOC（Inversion of Control）——控制反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A7%A0-%E5%BA%95%E5%B1%82%E5%85%B3%E9%94%AE%E7%B1%BB%EF%BC%9A"><span class="toc-number">14.1.1.2.</span> <span class="toc-text">🧠 底层关键类：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-2-Component-%E4%B8%8E%E6%B4%BE%E7%94%9F%E6%B3%A8%E8%A7%A3"><span class="toc-number">14.1.2.</span> <span class="toc-text">⚙️ 2. @Component 与派生注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-3-Configuration-Bean-%E5%8E%9F%E7%90%86"><span class="toc-number">14.1.3.</span> <span class="toc-text">⚙️ 3. @Configuration + @Bean 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-4-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6"><span class="toc-number">14.1.4.</span> <span class="toc-text">⚙️ 4. 依赖注入注解机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-AOP-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6"><span class="toc-number">14.2.</span> <span class="toc-text">2️⃣ AOP 核心注解机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-1-%E5%8E%9F%E7%90%86%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-%E9%80%9A%E7%9F%A5%E7%BB%87%E5%85%A5"><span class="toc-number">14.2.1.</span> <span class="toc-text">🧩 1. 原理：动态代理 + 通知织入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E6%B7%B1%E9%97%AE%E7%82%B9%EF%BC%88%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%AF%B4%E5%87%BA%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-number">14.3.</span> <span class="toc-text">🧠 面试深问点（可直接说出原理）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%90-%E4%BA%8C%E3%80%81SpringMVC-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E8%AF%B7%E6%B1%82%E5%88%86%E5%8F%91-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A-%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">🌐 二、SpringMVC 常用注解深度解析（请求分发 + 参数绑定 + 消息转换）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-SpringMVC-%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">15.1.</span> <span class="toc-text">1️⃣ SpringMVC 的整体架构与执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E6%8E%A7%E5%88%B6%E5%B1%82%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%EF%BC%88Controller-%E4%BD%93%E7%B3%BB%EF%BC%89"><span class="toc-number">15.2.</span> <span class="toc-text">2️⃣ 控制层核心注解（Controller 体系）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E5%AE%9E%E6%88%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">15.2.1.</span> <span class="toc-text">💡 实战示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%88HandlerMapping%EF%BC%89"><span class="toc-number">15.3.</span> <span class="toc-text">3️⃣ 请求映射机制（HandlerMapping）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E6%B3%A8%E8%A7%A3%EF%BC%88HandlerMethodArgumentResolver%EF%BC%89"><span class="toc-number">15.4.</span> <span class="toc-text">4️⃣ 参数绑定注解（HandlerMethodArgumentResolver）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E7%A4%BA%E4%BE%8B"><span class="toc-number">15.4.1.</span> <span class="toc-text">💡 参数绑定示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E5%93%8D%E5%BA%94%E8%BF%94%E5%9B%9E%E6%B3%A8%E8%A7%A3%EF%BC%88HttpMessageConverter%EF%BC%89"><span class="toc-number">15.5.</span> <span class="toc-text">5️⃣ 响应返回注解（HttpMessageConverter）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-JSON-%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="toc-number">15.5.1.</span> <span class="toc-text">💡 JSON 转换过程原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%B8%8F%E2%83%A3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%85%A8%E5%B1%80%E6%8E%A7%E5%88%B6"><span class="toc-number">15.6.</span> <span class="toc-text">6️⃣ 异常处理与全局控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE%E7%82%B9%E4%B8%8E%E9%AB%98%E5%88%86%E7%AD%94%E6%B3%95"><span class="toc-number">15.7.</span> <span class="toc-text">🧠 面试追问点与高分答法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%92%BE-%E4%B8%89%E3%80%81MyBatis-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3-%E5%BA%95%E5%B1%82%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86%EF%BC%88Mapper-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">💾 三、MyBatis 常用注解 + 底层映射原理（Mapper 动态代理机制）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81MyBatis-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E8%A7%88"><span class="toc-number">16.1.</span> <span class="toc-text">一、MyBatis 常用注解总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Mapper-%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">16.2.</span> <span class="toc-text">二、Mapper 注册机制与动态代理原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F"><span class="toc-number">16.2.1.</span> <span class="toc-text">💡 执行流程示意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B3%A8%E8%A7%A3%E5%BC%8F-SQL-%E7%A4%BA%E4%BE%8B"><span class="toc-number">16.3.</span> <span class="toc-text">三、注解式 SQL 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E5%9F%BA%E6%9C%AC-CRUD-%E6%B3%A8%E8%A7%A3"><span class="toc-number">16.3.1.</span> <span class="toc-text">1️⃣ 基本 CRUD 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84%E6%B3%A8%E8%A7%A3%EF%BC%88%E8%A7%A3%E5%86%B3%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E5%8C%B9%E9%85%8D%EF%BC%89"><span class="toc-number">16.3.2.</span> <span class="toc-text">2️⃣ 结果映射注解（解决字段名不匹配）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E5%8A%A8%E6%80%81-SQL-%E6%B3%A8%E8%A7%A3"><span class="toc-number">16.3.3.</span> <span class="toc-text">3️⃣ 动态 SQL 注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-Mapper-%E4%B8%8E-MapperScan-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">16.4.</span> <span class="toc-text">四、@Mapper 与 @MapperScan 的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BA%95%E5%B1%82%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90%EF%BC%88%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-number">16.5.</span> <span class="toc-text">五、底层关键组件解析（源码角度）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81MyBatis-Spring-%E7%9A%84%E6%95%B4%E5%90%88%E6%9C%BA%E5%88%B6"><span class="toc-number">16.6.</span> <span class="toc-text">六、MyBatis + Spring 的整合机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE%E7%82%B9%EF%BC%88%E9%AB%98%E5%88%86%E5%9B%9E%E7%AD%94%EF%BC%89"><span class="toc-number">16.7.</span> <span class="toc-text">七、面试追问点（高分回答）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%B8-%E5%9B%9B%E3%80%81Spring-Boot-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%EF%BC%88%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D-%E6%9D%A1%E4%BB%B6%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="toc-number">17.</span> <span class="toc-text">🌸 四、Spring Boot 常用注解与底层机制（自动装配 + 条件加载）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Spring-Boot-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E5%85%A8%E5%9B%BE"><span class="toc-number">17.1.</span> <span class="toc-text">一、Spring Boot 核心注解全图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E5%89%96%E6%9E%90"><span class="toc-number">17.2.</span> <span class="toc-text">二、核心注解剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-1%EF%B8%8F%E2%83%A3-SpringBootApplication%EF%BC%88%E5%85%A5%E5%8F%A3%E6%B3%A8%E8%A7%A3%EF%BC%89"><span class="toc-number">17.2.1.</span> <span class="toc-text">⚙️ 1️⃣ @SpringBootApplication（入口注解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="toc-number">17.2.1.1.</span> <span class="toc-text">组成结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-2%EF%B8%8F%E2%83%A3-EnableAutoConfiguration%EF%BC%88%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-number">17.2.2.</span> <span class="toc-text">⚙️ 2️⃣ @EnableAutoConfiguration（自动装配核心）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%8D-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E9%80%BB%E8%BE%91"><span class="toc-number">17.2.2.1.</span> <span class="toc-text">🔍 自动装配核心源码逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-3%EF%B8%8F%E2%83%A3-%E6%9D%A1%E4%BB%B6%E8%A3%85%E9%85%8D%E6%B3%A8%E8%A7%A3%EF%BC%88Conditional-%E7%B3%BB%E5%88%97%EF%BC%89"><span class="toc-number">17.2.3.</span> <span class="toc-text">⚙️ 3️⃣ 条件装配注解（Conditional 系列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-4%EF%B8%8F%E2%83%A3-ConfigurationProperties%EF%BC%88%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A%EF%BC%89"><span class="toc-number">17.2.4.</span> <span class="toc-text">⚙️ 4️⃣ @ConfigurationProperties（配置绑定）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-5%EF%B8%8F%E2%83%A3-Import%EF%BC%88%E6%89%8B%E5%8A%A8%E6%89%A9%E5%B1%95%E8%A3%85%E9%85%8D%EF%BC%89"><span class="toc-number">17.2.5.</span> <span class="toc-text">⚙️ 5️⃣ @Import（手动扩展装配）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Spring-Boot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">17.3.</span> <span class="toc-text">三、Spring Boot 启动流程（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%9D%A2%E8%AF%95%E6%B7%B1%E9%97%AE%E7%82%B9%EF%BC%88%E9%AB%98%E5%88%86%E7%AD%94%E6%B3%95%EF%BC%89"><span class="toc-number">17.4.</span> <span class="toc-text">四、面试深问点（高分答法）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9B%A1%EF%B8%8F-%E4%BA%94%E3%80%81Spring-Security-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%EF%BC%88%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">🛡️ 五、Spring Security 常用注解与底层机制（认证与授权）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%80%BB%E8%A7%88"><span class="toc-number">18.1.</span> <span class="toc-text">一、核心注解总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90"><span class="toc-number">18.2.</span> <span class="toc-text">二、核心机制解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-FilterChainProxy%EF%BC%88%E5%AE%89%E5%85%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%EF%BC%89"><span class="toc-number">18.2.1.</span> <span class="toc-text">1️⃣ FilterChainProxy（安全过滤器链）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-EnableWebSecurity"><span class="toc-number">18.2.2.</span> <span class="toc-text">2️⃣ @EnableWebSecurity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E6%96%B9%E6%B3%95%E7%BA%A7%E6%9D%83%E9%99%90%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.2.3.</span> <span class="toc-text">3️⃣ 方法级权限注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-Secured"><span class="toc-number">18.2.3.1.</span> <span class="toc-text">a. @Secured</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-PreAuthorize-PostAuthorize"><span class="toc-number">18.2.3.2.</span> <span class="toc-text">b. @PreAuthorize &#x2F; @PostAuthorize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-RolesAllowed"><span class="toc-number">18.2.3.3.</span> <span class="toc-text">c. @RolesAllowed</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.2.4.</span> <span class="toc-text">4️⃣ 获取当前用户注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AuthenticationPrincipal"><span class="toc-number">18.2.4.1.</span> <span class="toc-text">@AuthenticationPrincipal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E6%B5%8B%E8%AF%95%E6%94%AF%E6%8C%81"><span class="toc-number">18.2.5.</span> <span class="toc-text">5️⃣ 测试支持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WithMockUser"><span class="toc-number">18.2.5.1.</span> <span class="toc-text">@WithMockUser</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%B8%8F%E2%83%A3-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%EF%BC%88%E6%A0%B8%E5%BF%83%E9%93%BE%E6%9D%A1%EF%BC%89"><span class="toc-number">18.2.6.</span> <span class="toc-text">6️⃣ 身份认证流程（核心链条）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%B8%8F%E2%83%A3-%E6%8E%88%E6%9D%83%E5%86%B3%E7%AD%96"><span class="toc-number">18.2.7.</span> <span class="toc-text">7️⃣ 授权决策</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE%E7%82%B9%EF%BC%88%E9%AB%98%E5%88%86%E5%9B%9E%E7%AD%94%EF%BC%89"><span class="toc-number">18.3.</span> <span class="toc-text">三、面试追问点（高分回答）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%98%81%EF%B8%8F-%E5%85%AD%E3%80%81Spring-Cloud-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%EF%BC%88%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E3%80%81%E5%8F%91%E7%8E%B0%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-number">19.</span> <span class="toc-text">☁️ 六、Spring Cloud 常用注解与底层机制（服务注册、发现、负载均衡、远程调用）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%EF%BC%88Eureka-Nacos%EF%BC%89"><span class="toc-number">19.1.</span> <span class="toc-text">一、服务注册与发现（Eureka &#x2F; Nacos）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">19.1.1.</span> <span class="toc-text">1️⃣ 核心注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B%EF%BC%88Eureka-%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">19.1.2.</span> <span class="toc-text">2️⃣ 服务注册流程（Eureka 示例）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%88Ribbon-Spring-Cloud-LoadBalancer%EF%BC%89"><span class="toc-number">19.2.</span> <span class="toc-text">二、负载均衡（Ribbon &#x2F; Spring Cloud LoadBalancer）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3-1"><span class="toc-number">19.2.1.</span> <span class="toc-text">1️⃣ 核心注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86"><span class="toc-number">19.2.2.</span> <span class="toc-text">2️⃣ 客户端负载均衡原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%EF%BC%88Feign%EF%BC%89"><span class="toc-number">19.3.</span> <span class="toc-text">三、声明式远程调用（Feign）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3-2"><span class="toc-number">19.3.1.</span> <span class="toc-text">1️⃣ 核心注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-Feign-%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-number">19.3.2.</span> <span class="toc-text">2️⃣ Feign 调用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E7%A4%BA%E4%BE%8B"><span class="toc-number">19.3.3.</span> <span class="toc-text">3️⃣ 示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BD%91%E5%85%B3%EF%BC%88Spring-Cloud-Gateway%EF%BC%89"><span class="toc-number">19.4.</span> <span class="toc-text">四、网关（Spring Cloud Gateway）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">19.4.1.</span> <span class="toc-text">核心注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">19.4.2.</span> <span class="toc-text">核心原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%8D%E7%BA%A7%EF%BC%88Resilience4j-Spring-Cloud-CircuitBreaker%EF%BC%89"><span class="toc-number">19.5.</span> <span class="toc-text">五、熔断与降级（Resilience4j &#x2F; Spring Cloud CircuitBreaker）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3-1"><span class="toc-number">19.5.1.</span> <span class="toc-text">核心注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">19.5.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%97%AE%E7%82%B9"><span class="toc-number">19.6.</span> <span class="toc-text">六、面试高频问点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E7%BB%93%E6%9E%84%EF%BC%88%E5%85%AD%E5%A4%A7%E6%A1%86%E6%9E%B6%E9%80%9F%E6%9F%A5%E5%8D%A1%EF%BC%89"><span class="toc-number">19.6.1.</span> <span class="toc-text">样例结构（六大框架速查卡）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-Spring-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">19.7.</span> <span class="toc-text">1️⃣ Spring 核心注解 &amp; 生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-SpringMVC-%E6%B3%A8%E8%A7%A3-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">19.8.</span> <span class="toc-text">2️⃣ SpringMVC 注解 &amp; 请求处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-MyBatis-%E6%B3%A8%E8%A7%A3-SQL-%E6%89%A7%E8%A1%8C"><span class="toc-number">19.9.</span> <span class="toc-text">3️⃣ MyBatis 注解 &amp; SQL 执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-Spring-Boot-%E6%B3%A8%E8%A7%A3-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">19.10.</span> <span class="toc-text">4️⃣ Spring Boot 注解 &amp; 自动装配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-Spring-Security-%E6%B3%A8%E8%A7%A3-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">19.11.</span> <span class="toc-text">5️⃣ Spring Security 注解 &amp; 权限控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%B8%8F%E2%83%A3-Spring-Cloud-%E6%B3%A8%E8%A7%A3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="toc-number">19.12.</span> <span class="toc-text">6️⃣ Spring Cloud 注解 &amp; 微服务调用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/01/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/" title="框架常用注解">框架常用注解</a><time datetime="2025-09-30T16:00:00.000Z" title="发表于 2025-10-01 00:00:00">2025-10-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/01/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/" title="牛客面试题">牛客面试题</a><time datetime="2025-09-30T16:00:00.000Z" title="发表于 2025-10-01 00:00:00">2025-10-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/23/%E7%AE%80%E6%98%93%E7%89%88%E9%A2%98%E7%9B%AE/" title="简易版题目">简易版题目</a><time datetime="2025-09-22T16:00:00.000Z" title="发表于 2025-09-23 00:00:00">2025-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/22/go/" title="go">go</a><time datetime="2025-09-21T16:00:00.000Z" title="发表于 2025-09-22 00:00:00">2025-09-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/22/%E6%80%BB%E7%BB%93/" title="要点提纲">要点提纲</a><time datetime="2025-09-21T16:00:00.000Z" title="发表于 2025-09-22 00:00:00">2025-09-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bg.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Charlotte</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
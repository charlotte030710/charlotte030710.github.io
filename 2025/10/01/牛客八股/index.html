<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>牛客面试题 | 浮生若梦</title><meta name="author" content="Charlotte"><meta name="copyright" content="Charlotte"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring-牛客面经八股 1. 说说 Spring Boot 常用的注解 @SpringBootApplication：组合注解（@Configuration + @EnableAutoConfiguration + @ComponentScan），应用入口常放在主类上。 @Configuration &#x2F; @Bean：定义配置类和显式创建 Bean。 @Component &amp;#x2F">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客面试题">
<meta property="og:url" content="http://example.com/2025/10/01/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="浮生若梦">
<meta property="og:description" content="Spring-牛客面经八股 1. 说说 Spring Boot 常用的注解 @SpringBootApplication：组合注解（@Configuration + @EnableAutoConfiguration + @ComponentScan），应用入口常放在主类上。 @Configuration &#x2F; @Bean：定义配置类和显式创建 Bean。 @Component &amp;#x2F">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/title.jpg">
<meta property="article:published_time" content="2025-09-30T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-02T20:13:25.331Z">
<meta property="article:author" content="Charlotte">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/title.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "牛客面试题",
  "url": "http://example.com/2025/10/01/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/",
  "image": "http://example.com/img/title.jpg",
  "datePublished": "2025-09-30T16:00:00.000Z",
  "dateModified": "2025-10-02T20:13:25.331Z",
  "author": [
    {
      "@type": "Person",
      "name": "Charlotte",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="http://example.com/2025/10/01/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '牛客面试题',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="浮生若梦" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/title.jpg" alt="Logo"><span class="site-name">浮生若梦</span></a><a class="nav-page-title" href="/"><span class="site-name">牛客面试题</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">牛客面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-30T16:00:00.000Z" title="发表于 2025-10-01 00:00:00">2025-10-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-02T20:13:25.331Z" title="更新于 2025-10-03 04:13:25">2025-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<h2 id="Spring-牛客面经八股"><a href="#Spring-牛客面经八股" class="headerlink" title="Spring-牛客面经八股"></a>Spring-牛客面经八股</h2><hr>
<h3 id="1-说说-Spring-Boot-常用的注解"><a href="#1-说说-Spring-Boot-常用的注解" class="headerlink" title="1. 说说 Spring Boot 常用的注解"></a><strong>1. 说说 Spring Boot 常用的注解</strong></h3><ul>
<li><code>@SpringBootApplication</code>：组合注解（<code>@Configuration</code> + <code>@EnableAutoConfiguration</code> + <code>@ComponentScan</code>），应用入口常放在主类上。</li>
<li><code>@Configuration</code> &#x2F; <code>@Bean</code>：定义配置类和显式创建 Bean。</li>
<li><code>@Component</code> &#x2F; <code>@Service</code> &#x2F; <code>@Repository</code> &#x2F; <code>@Controller</code> &#x2F; <code>@RestController</code>：组件扫描管理类；<code>@RestController = @Controller + @ResponseBody</code>。</li>
<li><code>@Autowired</code> &#x2F; <code>@Qualifier</code> &#x2F; <code>@Value</code> &#x2F; <code>@Resource</code>：依赖注入、按类型&#x2F;按名称注入、读取配置。</li>
<li><code>@ConfigurationProperties</code>：将一组配置绑定到 POJO（推荐用于复杂配置）。</li>
<li><code>@EnableAutoConfiguration</code>（隐含在 <code>@SpringBootApplication</code> 中）：启用自动配置。</li>
<li>条件注解（常用于自动配置类）：<code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>、<code>@ConditionalOnProperty</code>、<code>@ConditionalOnBean</code> 等。</li>
<li><code>@Transactional</code>：声明式事务。</li>
<li><code>@RestControllerAdvice</code> &#x2F; <code>@ControllerAdvice</code>：统一异常&#x2F;全局处理。</li>
<li>测试相关：<code>@SpringBootTest</code>、<code>@WebMvcTest</code>、<code>@DataJpaTest</code> 等。</li>
<li>其他：<code>@EnableScheduling</code>、<code>@EnableCaching</code>、<code>@EnableFeignClients</code>、<code>@EnableDiscoveryClient</code> 等（看用到的组件）。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123; <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; SpringApplication.run(App.class, args); &#125; &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-Spring-Boot-启动流程"><a href="#2-Spring-Boot-启动流程" class="headerlink" title="2.Spring Boot 启动流程"></a><strong>2.Spring Boot 启动流程</strong></h3><p>入口一般是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ol>
<li><h4 id="调用-SpringApplication-run"><a href="#调用-SpringApplication-run" class="headerlink" title="调用 SpringApplication.run(...)"></a>调用 <code>SpringApplication.run(...)</code></h4></li>
</ol>
<ul>
<li><strong>作用</strong>：创建一个 <code>SpringApplication</code> 实例，准备运行环境。</li>
<li><strong>关键点</strong>：<ul>
<li>判断当前应用类型（<code>NONE</code>、<code>SERVLET</code>、<code>REACTIVE</code>），决定用什么样的 <code>ApplicationContext</code>。</li>
<li>加载并设置 <code>ApplicationContextInitializer</code> 和 <code>ApplicationListener</code>。</li>
</ul>
</li>
</ul>
<hr>
<ol start="2">
<li><h4 id="触发-SpringApplicationRunListeners-的-starting"><a href="#触发-SpringApplicationRunListeners-的-starting" class="headerlink" title="触发 SpringApplicationRunListeners 的 starting()"></a>触发 <code>SpringApplicationRunListeners</code> 的 <code>starting()</code></h4></li>
</ol>
<ul>
<li><strong>事件</strong>：<code>ApplicationStartingEvent</code>。</li>
<li><strong>触发时机</strong>：Spring 环境还未初始化前。</li>
<li><strong>用途</strong>：做一些极早期的日志初始化、Banner 输出等。</li>
</ul>
<hr>
<ol start="3">
<li><h4 id="准备-Environment"><a href="#准备-Environment" class="headerlink" title="准备 Environment"></a>准备 <code>Environment</code></h4></li>
</ol>
<ul>
<li><strong>工作内容</strong>：<ul>
<li>创建 <code>ConfigurableEnvironment</code>（不同应用类型对应不同环境类）。</li>
<li>加载配置源：系统属性、环境变量、命令行参数、<code>application.properties</code> &#x2F; <code>application.yml</code>、<code>@PropertySource</code>。</li>
<li>执行 <code>ConfigFileApplicationListener</code>，解析并注入配置文件属性。</li>
</ul>
</li>
<li><strong>扩展点</strong>：可通过 <code>EnvironmentPostProcessor</code> 在环境准备阶段修改&#x2F;添加配置。</li>
</ul>
<hr>
<ol start="4">
<li><h4 id="创建并准备-ApplicationContext"><a href="#创建并准备-ApplicationContext" class="headerlink" title="创建并准备 ApplicationContext"></a>创建并准备 <code>ApplicationContext</code></h4></li>
</ol>
<ul>
<li><strong>默认情况</strong>：<ul>
<li>普通应用 → <code>AnnotationConfigApplicationContext</code></li>
<li>Web Servlet 应用 → <code>AnnotationConfigServletWebServerApplicationContext</code></li>
<li>Web Reactive 应用 → <code>AnnotationConfigReactiveWebServerApplicationContext</code></li>
</ul>
</li>
<li><strong>扩展点</strong>：可通过 <code>SpringApplication.setApplicationContextClass()</code> 自定义上下文类型。</li>
</ul>
<hr>
<ol start="5">
<li><h4 id="调用-ApplicationContextInitializer"><a href="#调用-ApplicationContextInitializer" class="headerlink" title="调用 ApplicationContextInitializer"></a>调用 <code>ApplicationContextInitializer</code></h4></li>
</ol>
<ul>
<li><strong>作用</strong>：在 <code>ApplicationContext</code> 刷新之前，可以对其进行个性化处理。</li>
<li><strong>加载方式</strong>：<ul>
<li><code>spring.factories</code> 中的 <code>ApplicationContextInitializer</code>。</li>
<li><code>SpringApplication.addInitializers(...)</code> 手动添加。</li>
</ul>
</li>
<li><strong>应用场景</strong>：在容器 refresh 前注册属性源、配置 BeanDefinition 等。</li>
</ul>
<hr>
<ol start="6">
<li><h4 id="加载自动配置"><a href="#加载自动配置" class="headerlink" title="加载自动配置"></a>加载自动配置</h4></li>
</ol>
<ul>
<li><strong>关键机制</strong>：<ul>
<li><code>@EnableAutoConfiguration</code> 触发 <code>AutoConfigurationImportSelector</code>。</li>
<li>从 <code>META-INF/spring.factories</code> 或 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 加载所有候选配置类。</li>
<li>通过 <code>@ConditionalOnClass</code>、<code>@ConditionalOnBean</code>、<code>@ConditionalOnMissingBean</code> 等条件注解筛选。</li>
</ul>
</li>
<li><strong>结果</strong>：按需装配 starter 中的 Bean（如 <code>DataSourceAutoConfiguration</code>、<code>WebMvcAutoConfiguration</code> 等）。</li>
</ul>
<hr>
<ol start="7">
<li><h4 id="执行-BeanFactoryPostProcessor"><a href="#执行-BeanFactoryPostProcessor" class="headerlink" title="执行 BeanFactoryPostProcessor"></a>执行 <code>BeanFactoryPostProcessor</code></h4></li>
</ol>
<ul>
<li><strong>代表类</strong>：<ul>
<li><code>ConfigurationClassPostProcessor</code>：解析 <code>@Configuration</code> 类、<code>@ComponentScan</code>、<code>@Import</code>、<code>@Bean</code> 等注解。</li>
<li>其他定制的 <code>BeanFactoryPostProcessor</code>。</li>
</ul>
</li>
<li><strong>扩展点</strong>：可以在 BeanDefinition 阶段修改 bean 的元数据。</li>
</ul>
<hr>
<ol start="8">
<li><h4 id="创建并实例化单例-Bean"><a href="#创建并实例化单例-Bean" class="headerlink" title="创建并实例化单例 Bean"></a>创建并实例化单例 Bean</h4></li>
</ol>
<p>过程：</p>
<ol>
<li><strong>实例化</strong>（调用构造器）。</li>
<li><strong>依赖注入</strong>（populate 属性）。</li>
<li><strong>回调 Aware 接口</strong>（如 <code>BeanNameAware</code>、<code>ApplicationContextAware</code>）。</li>
<li><strong>BeanPostProcessor#postProcessBeforeInitialization</strong>。</li>
<li><strong>初始化方法</strong>（<code>@PostConstruct</code>、<code>InitializingBean.afterPropertiesSet()</code>、自定义 init-method）。</li>
<li><strong>BeanPostProcessor#postProcessAfterInitialization&#96;</strong>。</li>
<li>最终放入一级缓存（<code>singletonObjects</code>）。</li>
</ol>
<hr>
<ol start="9">
<li><h4 id="容器-refresh-完成"><a href="#容器-refresh-完成" class="headerlink" title="容器 refresh() 完成"></a>容器 <code>refresh()</code> 完成</h4></li>
</ol>
<ul>
<li><strong>标志事件</strong>：<ul>
<li><code>ApplicationStartedEvent</code>：容器启动完成。</li>
<li><code>ApplicationReadyEvent</code>：应用准备好接收请求。</li>
</ul>
</li>
<li><strong>其他事件</strong>：<ul>
<li><code>ContextRefreshedEvent</code>（上下文刷新完成）。</li>
<li><code>WebServerInitializedEvent</code>（WebServer 启动完成）。</li>
</ul>
</li>
</ul>
<hr>
<ol start="10">
<li><h4 id="应用接受请求-启动异常处理"><a href="#应用接受请求-启动异常处理" class="headerlink" title="应用接受请求 &#x2F; 启动异常处理"></a>应用接受请求 &#x2F; 启动异常处理</h4></li>
</ol>
<ul>
<li>成功：Web 应用启动，内嵌 Tomcat&#x2F;Jetty&#x2F;Undertow 已经监听端口。</li>
<li>失败：触发 <code>ApplicationFailedEvent</code>，进入 <code>FailureAnalyzers</code> 分析错误并输出人性化提示。</li>
</ul>
<hr>
<h4 id="🔑-重要扩展点总结"><a href="#🔑-重要扩展点总结" class="headerlink" title="🔑 重要扩展点总结"></a>🔑 重要扩展点总结</h4><ul>
<li><p><strong>ApplicationListeners</strong>：贯穿整个生命周期，可监听各种事件。</p>
</li>
<li><p><strong>ApplicationContextInitializer</strong>：在容器刷新前定制化上下文。</p>
</li>
<li><p><strong>BeanFactoryPostProcessor</strong>：修改 BeanDefinition。</p>
</li>
<li><p><strong>BeanPostProcessor</strong>：定制 Bean 实例化前后行为。</p>
</li>
<li><p><strong>@ConditionalOn…</strong>：自动配置的核心。</p>
<p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/5c3752c7c3fa4d4eafa6ea73fee027d7%7Etplv-k3u1fbpfcp-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.jpg" alt="Spring-Springboot启动流程图.jpg"></p>
</li>
</ul>
<hr>
<h3 id="3-对-IoC（Inversion-of-Control-依赖注入）的理解"><a href="#3-对-IoC（Inversion-of-Control-依赖注入）的理解" class="headerlink" title="3. 对 IoC（Inversion of Control &#x2F; 依赖注入）的理解"></a><strong>3. 对 IoC（Inversion of Control &#x2F; 依赖注入）的理解</strong></h3><ul>
<li>本质：把对象的创建和依赖的组装（控制权）从类内部移到容器（Spring）来管理——“控制反转”。实际表现为依赖注入（Dependency Injection）。</li>
<li>优点：解耦（组件只声明依赖，不负责创建）、易测试（可以注入 mock）、统一管理生命周期、便于 AOP 切面化。</li>
<li>注入方式：构造器注入（推荐，强制依赖、利于测试）、setter 注入、字段注入（简便但不推荐）。</li>
<li>容器职责：管理 bean 的实例化、装配、生命周期、作用域（singleton&#x2F;prototype&#x2F;request&#x2F;session）等。</li>
</ul>
<hr>
<h3 id="4-对-AOP（面向切面编程）的理解"><a href="#4-对-AOP（面向切面编程）的理解" class="headerlink" title="4. 对 AOP（面向切面编程）的理解"></a><strong>4. 对 AOP（面向切面编程）的理解</strong></h3><ul>
<li>目的：把横切关注点（日志&#x2F;事务&#x2F;安全&#x2F;缓存等）从业务代码分离出来。</li>
<li>术语：切面（Aspect）、通知（Advice：before&#x2F;after&#x2F;around&#x2F;afterReturning&#x2F;afterThrowing）、连接点（Join point）、切入点（Pointcut）、目标对象（Target）、代理（Proxy）。</li>
<li>实现方式：Spring 默认基于代理（JDK 动态代理：接口；CGLIB：类代理）；也可用 AspectJ（编译&#x2F;类加载期织入）实现更强的能力。</li>
<li>常见限制：代理是对象外部的包装 → 自身（同类）方法调用不会触发代理（self-invocation 问题）；可用 <code>AopContext.currentProxy()</code> 或 AspectJ 解决，或将需要切面的调用拆到另一个 bean。</li>
<li>使用示例（注解式）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">  <span class="meta">@Around(&quot;execution(* com.example.service..*(..))&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">log</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// before</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="comment">// after</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-Bean-的生命周期（主要步骤与钩子）"><a href="#5-Bean-的生命周期（主要步骤与钩子）" class="headerlink" title="5. Bean 的生命周期（主要步骤与钩子）"></a><strong>5. Bean 的生命周期（主要步骤与钩子）</strong></h3><ol>
<li><strong>实例化</strong>（instantiate bean）</li>
<li><strong>依赖注入</strong>（populate properties）</li>
<li>Aware 接口回调：<code>BeanNameAware.setBeanName()</code>、<code>BeanFactoryAware.setBeanFactory()</code>、<code>ApplicationContextAware.setApplicationContext()</code> 等</li>
<li><code>BeanPostProcessor.postProcessBeforeInitialization(...)</code></li>
<li>初始化回调：<code>@PostConstruct</code>、<code>afterPropertiesSet()</code> (InitializingBean)、自定义 <code>init-method</code></li>
<li><code>BeanPostProcessor.postProcessAfterInitialization(...)</code> → Bean 就绪可用（在容器中）</li>
<li><strong>销毁</strong>（单例在容器关闭时）: <code>@PreDestroy</code>、<code>DisposableBean.destroy()</code>、自定义 <code>destroy-method</code>。</li>
</ol>
<ul>
<li>另外：<code>SmartLifecycle</code>、<code>InitializingBean</code>、<code>DisposableBean</code>、<code>BeanFactoryPostProcessor</code>、<code>BeanPostProcessor</code> 等都参与生命周期扩展。</li>
</ul>
<hr>
<h3 id="6-Autowired-和-Resource-的区别"><a href="#6-Autowired-和-Resource-的区别" class="headerlink" title="6. @Autowired 和 @Resource 的区别"></a><strong>6. <code>@Autowired</code> 和 <code>@Resource</code> 的区别</strong></h3><ul>
<li>来源：<code>@Autowired</code> 是 Spring 注解；<code>@Resource</code> 是 JSR-250（Java 标准）。</li>
<li><strong>注入方式</strong>：<ul>
<li><code>@Autowired</code>：按 <strong>类型（byType）</strong> 注入；若有多个候选可结合 <code>@Qualifier</code> 或 <code>@Primary</code>。支持 <code>required</code>（默认 <code>true</code>，可设 <code>false</code>）或 <code>Optional&lt;T&gt;</code> &#x2F; <code>@Nullable</code>。支持构造器&#x2F;字段&#x2F;setter。</li>
<li><code>@Resource</code>：默认按 <strong>名称（byName）</strong> 注入（会先按 name 属性或字段名匹配 bean 名称），若找不到则回退按类型注入。没有 <code>required</code> 属性。</li>
</ul>
</li>
<li>使用习惯：<code>@Autowired</code> 更常见（Spring 风格）；如果需要严格按 bean 名称注入可用 <code>@Resource(name=&quot;...&quot;)</code>。</li>
<li>另外：<code>@Inject</code>（JSR-330）类似 <code>@Autowired</code>（按类型）。</li>
</ul>
<hr>
<h3 id="7-Spring-事务管理"><a href="#7-Spring-事务管理" class="headerlink" title="7. Spring 事务管理"></a><strong>7. Spring 事务管理</strong></h3><ul>
<li>两种方式：<strong>声明式</strong>（<code>@Transactional</code> 最常见）和<strong>编程式</strong>（<code>PlatformTransactionManager</code> + <code>TransactionTemplate</code>）。</li>
<li>事务管理器（常见）：<code>DataSourceTransactionManager</code>（JDBC）、<code>JpaTransactionManager</code>（JPA&#x2F;Hibernate）、<code>JtaTransactionManager</code>（分布式&#x2F;XA）。</li>
<li><code>@Transactional</code> 常用属性：<code>propagation</code>、<code>isolation</code>、<code>readOnly</code>、<code>timeout</code>、<code>rollbackFor</code>&#x2F;<code>noRollbackFor</code>。</li>
<li><strong>传播行为</strong>（常用几种）：<ul>
<li><code>REQUIRED</code>（默认）：如果有事务就加入，否则新建。</li>
<li><code>REQUIRES_NEW</code>：挂起当前事务，另启新事务（独立提交&#x2F;回滚）。</li>
<li><code>NESTED</code>：在同一物理连接上通过 savepoint 实现“子事务”（回滚到 savepoint），只有支持 JDBC 的事务管理器才有效。</li>
<li><code>SUPPORTS</code>、<code>NOT_SUPPORTED</code>、<code>MANDATORY</code>、<code>NEVER</code> 等。</li>
</ul>
</li>
<li>回滚规则：默认对 unchecked（<code>RuntimeException</code>、<code>Error</code>）回滚；若要对 checked exception 回滚需指定 <code>rollbackFor</code>。</li>
<li>注意点：<code>@Transactional</code> 通过 AOP 代理实现（代理对象拦截方法并管理事务），因此<strong>同类内部方法调用</strong>不会走代理，事务注解不会生效（self-invocation）。解决办法：把方法放到另一个 bean、使用 <code>AspectJ</code> 或手动通过 <code>TransactionTemplate</code>。</li>
<li>事务与连接：Spring 管理 JDBC 连接绑定到线程（事务同步），propagation 影响是否复用或者新开连接。</li>
</ul>
<hr>
<h3 id="8-Spring-MVC-的执行流程（请求到响应的完整链路）"><a href="#8-Spring-MVC-的执行流程（请求到响应的完整链路）" class="headerlink" title="8. Spring MVC 的执行流程（请求到响应的完整链路）"></a><strong>8. Spring MVC 的执行流程（请求到响应的完整链路）</strong></h3><p> 简化流程（按实际处理顺序）：</p>
<ol>
<li><strong>客户端请求</strong> → 到 <code>DispatcherServlet</code>（前端控制器，Front Controller）。</li>
<li><code>HandlerMapping</code> 根据 URL 找到对应的 Handler（Controller 方法，内部为 <code>HandlerMethod</code>）。</li>
<li>执行 <code>HandlerInterceptor.preHandle()</code>（可拦截、返回 false 终止）。</li>
<li><code>HandlerAdapter</code> 调用 Controller 方法：内部会执行 <code>HandlerMethodArgumentResolver</code>（解析方法参数）和 <code>HandlerMethodReturnValueHandler</code>（处理返回值）。对于 <code>@ResponseBody</code> &#x2F; 返回对象，会交给 <code>HttpMessageConverter</code> 序列化（JSON&#x2F;XML）。</li>
<li>Controller 返回 <code>ModelAndView</code> 或视图名或响应体。</li>
<li><code>HandlerInterceptor.postHandle()</code>（可修改 ModelAndView）。</li>
<li><code>ViewResolver</code> 解析视图，<code>View</code> 渲染最终响应；若 <code>@ResponseBody</code>，则直接写出。</li>
<li><code>HandlerInterceptor.afterCompletion()</code>（清理工作），以及 <code>ExceptionResolver</code> 处理异常路径。</li>
</ol>
<p>关键扩展点：拦截器、过滤器、异常处理器（<code>@ControllerAdvice</code> &#x2F; <code>HandlerExceptionResolver</code>）、参数解析（<code>@RequestParam</code>、<code>@PathVariable</code>、<code>@RequestBody</code>）等。</p>
<hr>
<h3 id="9-Component-和-Bean-的区别"><a href="#9-Component-和-Bean-的区别" class="headerlink" title="9. @Component 和 @Bean 的区别"></a><strong>9. <code>@Component</code> 和 <code>@Bean</code> 的区别</strong></h3><ul>
<li><code>@Component</code>：类级注解，交给组件扫描自动发现并注册为 bean。适合你自己写的类。</li>
<li><code>@Bean</code>：方法级注解，放在 <code>@Configuration</code> 类中，由方法的返回值注册为 bean。适合第三方类或需要程序化创建的 bean。</li>
<li>细节区别：<ul>
<li><code>@Configuration</code> 类会被 CGLIB 代理以保证 <code>@Bean</code> 方法的单例语义（同一配置类内调用 <code>@Bean</code> 方法会返回容器中的单例，而不是新实例）。</li>
<li><code>@Component</code> 比较“自动”，<code>@Bean</code> 更显式、可编程（可以在方法中做复杂逻辑）。</li>
<li>注入优先级&#x2F;覆盖规则：<code>@Bean</code> 定义的 bean 名称可和扫描到的组件冲突，容器按注册顺序&#x2F;配置决定覆盖或报错（可用 <code>@Primary</code>、<code>@Order</code> 或显式排除）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10-Spring-中用到的设计模式"><a href="#10-Spring-中用到的设计模式" class="headerlink" title="10. Spring 中用到的设计模式"></a><strong>10. Spring 中用到的设计模式</strong></h3><ul>
<li><strong>单例模式（Singleton）</strong>：Spring 的单例 scope（容器保证）。</li>
<li><strong>工厂模式（Factory） &#x2F; 抽象工厂</strong>：<code>BeanFactory</code>&#x2F;<code>ApplicationContext</code> 提供 <code>getBean</code>。</li>
<li><strong>代理模式（Proxy）</strong>：AOP 使用（JDK 动态代理 &#x2F; CGLIB）。</li>
<li><strong>模板方法模式（Template Method）</strong>：<code>JdbcTemplate</code>, <code>JmsTemplate</code> 等，封装固定流程，留钩子给子类&#x2F;回调。</li>
<li><strong>策略模式（Strategy）</strong>：可插拔的实现选择，如不同的序列化&#x2F;编码&#x2F;厂商策略、事务策略。</li>
<li><strong>观察者模式（Observer）</strong>：<code>ApplicationEvent</code> &#x2F; <code>ApplicationListener</code>。</li>
<li><strong>前端控制器（Front Controller）</strong>：<code>DispatcherServlet</code>。</li>
<li><strong>适配器模式（Adapter）</strong>：<code>HandlerAdapter</code> 用于适配不同 handler。</li>
<li><strong>责任链（Chain of Responsibility）</strong>：Servlet Filter 链、Spring Security 的 filter chain、Interceptor 链。</li>
<li><strong>门面模式（Facade）</strong>：例如 <code>JdbcTemplate</code> 对复杂 JDBC 操作的简化封装。</li>
</ul>
<hr>
<h3 id="11-Spring-循环依赖是什么？介绍下三级缓存"><a href="#11-Spring-循环依赖是什么？介绍下三级缓存" class="headerlink" title="11. Spring 循环依赖是什么？介绍下三级缓存"></a><strong>11. Spring 循环依赖是什么？介绍下三级缓存</strong></h3><ul>
<li><strong>循环依赖</strong>：A -&gt; B -&gt; A 的依赖关系。Spring 能自动解决部分场景（<strong>单例 bean 且为 setter&#x2F;属性注入</strong> 的情况可以解决；<strong>构造器注入</strong> 则无法解决）。</li>
<li><strong>三级缓存（三缓存）</strong>（Spring 单例循环依赖解决的核心）：<ol>
<li><strong>singletonObjects</strong>（一级缓存）——完全初始化好的单例 bean 实例（最终放这里）。</li>
<li><strong>earlySingletonObjects</strong>（二级缓存）——提前曝光的 bean 实例（未完成初始化但可以被其它 bean 引用，通常用于原始对象或早期代理）。</li>
<li><strong>singletonFactories</strong>（三级缓存）——保存一个 <code>ObjectFactory</code>，当需要早期引用时可以调用它得到（常用于创建代理对象，支持 AOP 情况）。</li>
</ol>
</li>
<li><strong>简要流程</strong>（创建 bean A）：<ol>
<li>实例化 A（还没注入属性）。把 A 的 <code>ObjectFactory</code> 放入 <code>singletonFactories</code>（使别人能拿到早期引用）。</li>
<li>当创建 B 时需要 A，会先从 <code>singletonObjects</code> 看不到，再从 <code>earlySingletonObjects</code> &#x2F; <code>singletonFactories</code> 找到早期引用并加入 <code>earlySingletonObjects</code>。</li>
<li>B 的注入完成后返回，A 完成属性注入、执行后置处理器，最后把 A 放入 <code>singletonObjects</code>，并从早期缓存移除。</li>
</ol>
</li>
<li><strong>限制 &amp; 注意</strong>：<ul>
<li>只能解决<strong>单例且非构造器注入</strong>的循环依赖；构造器注入需要构造函数就得到依赖，无法提前暴露，故会抛异常。</li>
<li>AOP 代理会影响：默认如果需要代理，Spring 会在 <code>singletonFactories</code> 存入创建代理的工厂，这样早期引用能得到代理，避免后续再创建新的代理导致不一致。</li>
<li>Prototype scope（原型）不支持自动解决循环依赖。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="12-Spring-Security-是什么？"><a href="#12-Spring-Security-是什么？" class="headerlink" title="12. Spring Security 是什么？"></a><strong>12. Spring Security 是什么？</strong></h3><ul>
<li>Spring Security 是一个提供认证（Authentication）与授权&#x2F;访问控制（Authorization）的企业级安全框架，功能包括：登录&#x2F;登出、权限控制、方法级安全、会话管理、CSRF 防护、加密密码、集成 OAuth2 &#x2F; OIDC &#x2F; SSO 等。</li>
<li>主要组件：<code>SecurityFilterChain</code>（一系列 Filter 拦截与安全处理）、<code>AuthenticationManager</code>、<code>UserDetailsService</code>（加载用户信息）、<code>GrantedAuthority</code>（权限）、密码编码器（如 <code>BCryptPasswordEncoder</code>）、<code>MethodSecurity</code>（<code>@Secured</code>、<code>@PreAuthorize</code>）等。</li>
<li>集成点：与 Spring MVC &#x2F; WebFlux 无缝集成，常用配置有基于 DSL 的 Java Config（Spring Security 5+ 风格）以及注解式方法安全。</li>
</ul>
<hr>
<h3 id="13-Spring、Spring-MVC、Spring-Boot-三者之间的关系"><a href="#13-Spring、Spring-MVC、Spring-Boot-三者之间的关系" class="headerlink" title="13. Spring、Spring MVC、Spring Boot 三者之间的关系"></a><strong>13. Spring、Spring MVC、Spring Boot 三者之间的关系</strong></h3><ul>
<li><strong>Spring Framework</strong>：底层核心框架，提供 IoC（依赖注入）、AOP、事务管理、数据访问支持等基础功能。</li>
<li><strong>Spring MVC</strong>：Spring 的一个模块（web 框架），实现 MVC 模式，基于 Spring 的 IoC&#x2F;AOP 运行，负责处理 HTTP 请求、分发到 Controller、渲染视图等。</li>
<li><strong>Spring Boot</strong>：基于 Spring 的约定优于配置（opinionated）框架，简化 Spring 应用的配置与启动（starter 依赖、自动配置、嵌入式容器、Actuator 等）。它不是替代 Spring，而是简化使用 Spring（及 Spring MVC、Spring Data、Spring Security 等生态）的方式。</li>
</ul>
<p>简单：<strong>Spring &#x3D; 基础，Spring MVC &#x3D; Web 模块，Spring Boot &#x3D; 用来快速启动&#x2F;配置 Spring 应用的工具集与约定。</strong></p>
<hr>
<h3 id="14-Spring-Boot-自动配置原理（原理概述）"><a href="#14-Spring-Boot-自动配置原理（原理概述）" class="headerlink" title="14. Spring Boot 自动配置原理（原理概述）"></a><strong>14. Spring Boot 自动配置原理（原理概述）</strong></h3><ul>
<li>核心：<code>@EnableAutoConfiguration</code>（隐含在 <code>@SpringBootApplication</code>）通过 <code>AutoConfigurationImportSelector</code> 导入大量候选自动配置类。</li>
<li>自动配置类通常放在 <code>org.springframework.boot.autoconfigure.*</code>，并带有条件注解（<code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>、<code>@ConditionalOnProperty</code> 等）来决定是否生效。</li>
<li><strong>自动配置候选的来源</strong>：传统上通过 <code>META-INF/spring.factories</code> 列表来发现（Spring Boot 2.x 常用），较新的 Boot 版本引入了更现代的自动配置注册机制（也使用 metadata 文件来列出 auto-config 类）。无论机制如何，核心思想是：<strong>按需注册、并允许用户通过 <code>spring.autoconfigure.exclude</code> 或 <code>@SpringBootApplication(exclude=...)</code> 覆盖&#x2F;排除</strong>。</li>
<li>覆盖顺序：用户显式定义的 <code>@Bean</code> 通常优先于自动配置；自动配置通过条件注解判断是否装配。</li>
<li>常用条件注解举例：<code>@ConditionalOnClass</code>（类在类路径中时生效）、<code>@ConditionalOnMissingBean</code>（当容器中没有某 bean 时生效）、<code>@ConditionalOnProperty</code>（基于配置属性启用&#x2F;禁用）。</li>
</ul>
<blockquote>
<p>提示：自动配置是“约定优于配置”的实现：在默认配置无法满足时，用户可通过自定义配置&#x2F;排除来自定义行为。</p>
</blockquote>
<hr>
<h3 id="15-Spring-Cloud-的组件有哪些？（常见模块与作用）"><a href="#15-Spring-Cloud-的组件有哪些？（常见模块与作用）" class="headerlink" title="15. Spring Cloud 的组件有哪些？（常见模块与作用）"></a><strong>15. Spring Cloud 的组件有哪些？（常见模块与作用）</strong></h3><p> Spring Cloud 是一套构建分布式系统的工具集合，包含很多子项目。常见模块（并非全部）：</p>
<ul>
<li><strong>Spring Cloud Config</strong>：集中式配置管理（server + client）。</li>
<li><strong>Spring Cloud Netflix</strong>（整合 Netflix OSS）：Eureka（服务发现）、Ribbon（客户端负载均衡，已在新版本逐步被 <code>Spring Cloud LoadBalancer</code> 取代）、Hystrix（断路器，已进入维护&#x2F;弃用，替代方案 <code>Resilience4j</code>）。</li>
<li><strong>Spring Cloud Gateway</strong>：API 网关&#x2F;路由。</li>
<li><strong>OpenFeign &#x2F; Spring Cloud OpenFeign</strong>：声明式 HTTP 客户端。</li>
<li><strong>Spring Cloud LoadBalancer</strong>：客户端负载均衡（替代 Ribbon）。</li>
<li><strong>Spring Cloud CircuitBreaker</strong>：抽象断路器，支持 Resilience4j 等实现。</li>
<li><strong>Spring Cloud Stream</strong>：事件&#x2F;消息驱动（Kafka&#x2F;RabbitMQ 绑定）。</li>
<li><strong>Spring Cloud Bus</strong>：消息总线（广播配置刷新等）。</li>
<li><strong>Spring Cloud Sleuth &#x2F; Zipkin &#x2F; Micrometer</strong>：分布式追踪与监控。</li>
<li><strong>Spring Cloud Gateway &#x2F; Zuul（老）</strong>：API 路由&#x2F;网关实现。</li>
<li><strong>Spring Cloud Contract</strong>：契约测试。</li>
<li><strong>Spring Cloud Kubernetes &#x2F; Consul &#x2F; Zookeeper</strong>：与 k8s、Consul、ZK 的整合。</li>
</ul>
<blockquote>
<p>注：Spring Cloud 生态很大，不同版本间有替代与弃用（例如 Ribbon -&gt; LoadBalancer，Hystrix 逐步被 Resilience4j 取代），实际项目中按需要选用。</p>
</blockquote>
<hr>
<h3 id="16-在-REQUIRES-NEW-场景下，子事务同时操作同一数据会发生什么？"><a href="#16-在-REQUIRES-NEW-场景下，子事务同时操作同一数据会发生什么？" class="headerlink" title="16. 在 REQUIRES_NEW 场景下，子事务同时操作同一数据会发生什么？"></a><strong>16. 在 <code>REQUIRES_NEW</code> 场景下，子事务同时操作同一数据会发生什么？</strong></h3><p>这是一个非常实战且需要深入理解数据库事务模型与 Spring 事务传播差异的问题。下面分几部分说明：<strong>实现细节、并发与隔离语义、可能的异常&#x2F;问题、解决方案&#x2F;最佳实践</strong>。</p>
<h4 id="（A）REQUIRES-NEW-的行为（实现层面）"><a href="#（A）REQUIRES-NEW-的行为（实现层面）" class="headerlink" title="（A）REQUIRES_NEW 的行为（实现层面）"></a>（A）<code>REQUIRES_NEW</code> 的行为（实现层面）</h4><ul>
<li><code>REQUIRES_NEW</code> 会 <strong>挂起</strong> 当前（外层）事务，然后在一个 <strong>独立的事务</strong> 中执行子事务。实现上（本地事务）通常意味着：挂起外层事务的连接&#x2F;事务状态，取得新的数据库连接（或从连接池取出），在该连接上开启新的事务；子事务完成后提交&#x2F;回滚并关闭该连接，然后恢复外层事务继续执行（用原来的连接与事务）。</li>
<li>结果：子事务的提交或回滚 <strong>与外层事务相互独立</strong>（子事务已提交后，即使外层后续回滚，也无法回滚子事务）。</li>
</ul>
<h4 id="（B）若子事务和外层-另一个子事务“同时”操作同一数据，会发生什么？"><a href="#（B）若子事务和外层-另一个子事务“同时”操作同一数据，会发生什么？" class="headerlink" title="（B）若子事务和外层&#x2F;另一个子事务“同时”操作同一数据，会发生什么？"></a>（B）若子事务和外层&#x2F;另一个子事务“同时”操作同一数据，会发生什么？</h4><p>行为由 <strong>数据库隔离级别</strong>、<strong>锁机制</strong>（悲观锁 &#x2F; 行级锁）、以及<strong>操作顺序</strong>决定。常见情况：</p>
<ol>
<li><strong>子事务在另一个事务之后提交（顺序不同）</strong><ul>
<li>若两个事务更新同一行，数据库会对行加锁（具体行为依 DB 引擎）。例如 InnoDB（MySQL）执行 <code>UPDATE</code> 会加行锁。第二个事务会在尝试修改时等待第一个事务释放锁（或触发死锁检测）。最终一个事务会被回滚（DB 检测到死锁）或等待成功后提交。Spring 会把底层 SQLException 转为 <code>DataAccessException</code> 抛出，事务会相应回滚或提交。</li>
</ul>
</li>
<li><strong>并发读写 + 隔离级别影响（READ_COMMITTED vs REPEATABLE_READ）</strong><ul>
<li><strong>READ_COMMITTED</strong>：每条语句看到的是已提交的数据；如果子事务提交后，外层事务在挂起后恢复并重新读取，会看到子事务的修改。</li>
<li><strong>REPEATABLE_READ（MySQL 默认）</strong>：事务开始时建立读快照；在外层事务尚未提交且使用 REPEATABLE_READ 时，外层事务可能不会看到子事务提交的更改，直到外层事务结束并重新开始事务。</li>
<li>因此：数据可见性取决隔离级别与何时读取。</li>
</ul>
</li>
<li><strong>丢失更新（Lost Update）</strong><ul>
<li>场景：T1（外层）读到值 <code>v</code> → 执行 REQUIRES_NEW 的子事务 T2 更新为 <code>v2</code> 并提交 → T1 继续基于旧 <code>v</code> 计算并写回 → 如果没有版本控制&#x2F;锁机制，会覆盖 T2 的更新（丢失更新）。</li>
</ul>
</li>
<li><strong>悲观锁 &#x2F; 乐观锁的影响</strong><ul>
<li><strong>悲观锁（SELECT … FOR UPDATE）</strong>：可以避免并发写冲突（会阻塞直到锁释放）。</li>
<li><strong>乐观锁（version 字段）</strong>：写时检查版本号，不匹配则抛出 <code>OptimisticLockingFailureException</code>，开发者可捕获重试以解决冲突。</li>
</ul>
</li>
</ol>
<h4 id="（C）与-NESTED-的对比（重要）"><a href="#（C）与-NESTED-的对比（重要）" class="headerlink" title="（C）与 NESTED 的对比（重要）"></a>（C）与 <code>NESTED</code> 的对比（重要）</h4><ul>
<li><code>NESTED</code> 在多数实现下使用 <strong>同一物理连接 + savepoint</strong> 实现：子事务回滚只是回到 savepoint，不会独立提交。<code>REQUIRES_NEW</code> 是独立事务并提交后不可撤销。</li>
<li>因此：若想实现“子事务失败不影响外层”且不希望子事务独立提交，<code>NESTED</code> 比 <code>REQUIRES_NEW</code> 更合适（但需 DB &amp; 事务管理器支持）。</li>
</ul>
<h4 id="（D）JPA-Hibernate-细节（ORM-层的问题）"><a href="#（D）JPA-Hibernate-细节（ORM-层的问题）" class="headerlink" title="（D）JPA&#x2F;Hibernate 细节（ORM 层的问题）"></a>（D）JPA&#x2F;Hibernate 细节（ORM 层的问题）</h4><ul>
<li>使用 JPA&#x2F;Hibernate 时，<code>REQUIRES_NEW</code> 会创建新的 <code>EntityManager</code> &#x2F; persistence context。外层事务的持久化上下文（1st-level cache）在恢复后仍保留旧实体的状态（可能是陈旧的）。因此：外层事务需要 <code>entityManager.refresh(entity)</code> 或 <code>entityManager.clear()</code> 来看到子事务的修改，否则可能基于陈旧实体写回，导致覆盖或冲突。</li>
<li>注意：<code>REQUIRES_NEW</code> 额外创建连接&#x2F;实体管理器，开销较大，且更容易产生并发冲突需要手工处理。</li>
</ul>
<h4 id="（E）示例场景（伪代码，说明丢失更新）："><a href="#（E）示例场景（伪代码，说明丢失更新）：" class="headerlink" title="（E）示例场景（伪代码，说明丢失更新）："></a>（E）示例场景（伪代码，说明丢失更新）：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外层事务 T1</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Account</span> <span class="variable">a</span> <span class="operator">=</span> repo.findById(<span class="number">1</span>); <span class="comment">// balance = 100  (snapshot)</span></span><br><span class="line">  modifyByRequiresNew();        <span class="comment">// 在 REQUIRES_NEW 中把 balance -&gt; 200 并提交</span></span><br><span class="line">  <span class="comment">// outer 仍持有 a.balance = 100（未刷新）</span></span><br><span class="line">  a.setBalance(a.getBalance() + <span class="number">50</span>); <span class="comment">// 基于旧值写回 150，覆盖了子事务的 200 -&gt; 丢失更新</span></span><br><span class="line">  repo.save(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyByRequiresNew</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Account</span> <span class="variable">a</span> <span class="operator">=</span> repo.findById(<span class="number">1</span>);</span><br><span class="line">  a.setBalance(<span class="number">200</span>);</span><br><span class="line">  repo.save(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：若不处理，可能出现覆盖&#x2F;丢失更新或不可预期的数据一致性问题。</p>
<h4 id="（F）数据库级别的异常（死锁、序列化失败等）"><a href="#（F）数据库级别的异常（死锁、序列化失败等）" class="headerlink" title="（F）数据库级别的异常（死锁、序列化失败等）"></a>（F）数据库级别的异常（死锁、序列化失败等）</h4><ul>
<li>并发更新同一资源可引发<strong>死锁</strong>，DB 会回滚其中一个事务并抛出异常（例如 MySQL 的死锁错误）。Spring 捕获后会抛出 DataAccessException 或其子类，事务回滚。需要在调用方处理（重试或降级）。</li>
<li>在更严格隔离（<code>SERIALIZABLE</code>）下可能出现序列化异常，也需要重试逻辑。</li>
</ul>
<h4 id="（G）最佳实践与建议"><a href="#（G）最佳实践与建议" class="headerlink" title="（G）最佳实践与建议"></a>（G）最佳实践与建议</h4><ol>
<li><strong>明确事务边界</strong>：不要随意大量使用 <code>REQUIRES_NEW</code>，它会增加连接数和复杂度。只在确实需要“子事务独立提交”的场景使用（如写审计日志、发送外部不可回滚的操作）。</li>
<li><strong>避免丢失更新</strong>：对重要并发更新场景使用**乐观锁（version）**或**悲观锁（SELECT … FOR UPDATE）**。</li>
<li><strong>在 JPA 场景谨慎处理 Persistence Context</strong>：<code>REQUIRES_NEW</code> 后如果外层要使用被子事务修改的实体，记得 <code>refresh()</code> 或 <code>clear()</code>，以避免使用 stale entity。</li>
<li><strong>NESTED vs REQUIRES_NEW</strong>：如果想在同一物理事务里局部回滚用 NESTED（savepoint），想要真正独立提交用 REQUIRES_NEW。</li>
<li><strong>处理异常与重试</strong>：对可能的死锁&#x2F;序列化冲突做重试策略（指数退避等）。Spring 的 <code>@Transactional</code> 不会自动重试，需自己实现。</li>
<li><strong>监控与容量注意</strong>：<code>REQUIRES_NEW</code> 增加并发连接数，注意数据库连接池容量。</li>
</ol>
<hr>
<h4 id="小结（关于第16题的实战提醒）"><a href="#小结（关于第16题的实战提醒）" class="headerlink" title="小结（关于第16题的实战提醒）"></a>小结（关于第16题的实战提醒）</h4><ul>
<li><code>REQUIRES_NEW</code> 会产生独立事务并独立提交。若外层&#x2F;其他事务同时对同一数据修改，最终行为取决于 DB 的锁与隔离级别：会有等待、死锁、丢失更新或序列化冲突等情况。</li>
<li>解决思路：用乐观锁&#x2F;悲观锁、合理选择传播行为（NESTED vs REQUIRES_NEW）、在 ORM 场景刷新&#x2F;清理持久化上下文、并实现重试策略与良好的异常处理。</li>
</ul>
<hr>
<h2 id="Java基础-牛客面经八股"><a href="#Java基础-牛客面经八股" class="headerlink" title="Java基础-牛客面经八股"></a>Java基础-牛客面经八股</h2><h3 id="1-Java-基本数据类型与引用类型"><a href="#1-Java-基本数据类型与引用类型" class="headerlink" title="1 Java 基本数据类型与引用类型"></a>1 Java 基本数据类型与引用类型</h3><h4 id="1-基本类型（Primitive-Types-8-种）"><a href="#1-基本类型（Primitive-Types-8-种）" class="headerlink" title="1. 基本类型（Primitive Types, 8 种）"></a>1. 基本类型（Primitive Types, 8 种）</h4><ul>
<li><strong>类型</strong>：<code>byte</code>(1B)、<code>short</code>(2B)、<code>int</code>(4B)、<code>long</code>(8B)、<code>float</code>(4B)、<code>double</code>(8B)、<code>char</code>(2B, UTF-16 code unit)、<code>boolean</code>（大小未在 JVM 规范中强制规定，通常用 1 bit&#x2F;1 byte 存储）。</li>
<li><strong>存放位置</strong>：<ul>
<li>方法里的局部变量 → <strong>JVM 栈帧的局部变量表</strong>（直接存值）。</li>
<li>如果是对象的字段 → 存在 <strong>堆内存的对象布局中</strong>（对象头 + 实例字段 + 对齐填充）。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>直接值语义，没有引用开销。</li>
<li>不参与 GC，性能高。</li>
<li>内存占用小。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>不能为 <code>null</code>。</li>
<li>不具备面向对象特性（没有方法）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-引用类型（Reference-Types）"><a href="#2-引用类型（Reference-Types）" class="headerlink" title="2. 引用类型（Reference Types）"></a>2. 引用类型（Reference Types）</h4><ul>
<li><strong>类型</strong>：类、接口、数组、枚举、注解。</li>
<li><strong>存放方式</strong>：<ul>
<li><strong>引用变量</strong> 存在栈或对象字段中，存储的是对象在堆上的地址（引用）。</li>
<li><strong>对象本体</strong> 存在堆中（对象头 + 实例数据 + 对齐）。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>可以为 <code>null</code>。</li>
<li>传递时是 <strong>值传递</strong>，但值是引用的拷贝（可能导致“看起来像引用传递”）。</li>
<li>需要 GC 管理生命周期。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-内存结构对比"><a href="#3-内存结构对比" class="headerlink" title="3. 内存结构对比"></a>3. 内存结构对比</h4><ul>
<li><strong>基本类型字段</strong>：直接存值，结构紧凑。</li>
<li><strong>包装类型（如 <code>Integer</code>）</strong>：对象有对象头（MarkWord + Klass 指针）+ 实例数据（int 值）+ 对齐填充。内存占用比基本类型大得多（通常至少 16B+）。</li>
<li><strong>布尔类型</strong>：虽然语义是 true&#x2F;false，但在对象中至少占 1B（HotSpot 会优化压缩到 bitset，但不保证）。</li>
</ul>
<h4 id="Q1-为什么-Java-有基本类型而不是全部用对象？"><a href="#Q1-为什么-Java-有基本类型而不是全部用对象？" class="headerlink" title="Q1. 为什么 Java 有基本类型而不是全部用对象？"></a>Q1. 为什么 Java 有基本类型而不是全部用对象？</h4><p>👉 <strong>回答要点</strong>：</p>
<ul>
<li>性能考虑。</li>
<li>基本类型避免了对象包装的额外开销（对象头、GC、指针寻址）。</li>
<li>在高频计算（循环、数值运算）中，大量创建对象会显著拖慢性能。</li>
</ul>
<hr>
<h4 id="Q2-基本类型和包装类型的区别？"><a href="#Q2-基本类型和包装类型的区别？" class="headerlink" title="Q2. 基本类型和包装类型的区别？"></a>Q2. 基本类型和包装类型的区别？</h4><p>👉 <strong>回答要点</strong>：</p>
<ul>
<li>基本类型直接存值，包装类型是对象（有引用开销）。</li>
<li>包装类型可以为 <code>null</code>，而基本类型不行。</li>
<li>包装类型支持方法（如 <code>Integer.valueOf</code>、<code>compareTo</code>）。</li>
<li>自动装箱&#x2F;拆箱可能引发性能问题。</li>
<li>比较时：<ul>
<li>基本类型用 <code>==</code> 比较值。</li>
<li>包装类型 <code>==</code> 比较引用（除非在 [-128,127] 缓存范围内的整型）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Q3-为什么-Integer-i1-127-Integer-i2-127-i1-i2-返回-true，而换成-128-返回-false？"><a href="#Q3-为什么-Integer-i1-127-Integer-i2-127-i1-i2-返回-true，而换成-128-返回-false？" class="headerlink" title="Q3. 为什么 Integer i1 = 127; Integer i2 = 127; i1 == i2 返回 true，而换成 128 返回 false？"></a>Q3. 为什么 <code>Integer i1 = 127; Integer i2 = 127; i1 == i2</code> 返回 true，而换成 128 返回 false？</h4><p>👉 <strong>回答要点</strong>：</p>
<ul>
<li>因为 Java 对 <code>Integer</code> 做了缓存（<code>IntegerCache</code>，默认缓存 -128 ~ 127）。</li>
<li>超出范围会创建新的对象。</li>
</ul>
<hr>
<h4 id="Q4-对象在堆中的内存布局是怎样的？"><a href="#Q4-对象在堆中的内存布局是怎样的？" class="headerlink" title="Q4. 对象在堆中的内存布局是怎样的？"></a>Q4. 对象在堆中的内存布局是怎样的？</h4><p>👉 <strong>回答要点</strong>：</p>
<ol>
<li><strong>对象头</strong>：<ul>
<li>Mark Word（哈希码、锁信息、GC 信息）。</li>
<li>Klass Pointer（指向类元数据）。</li>
</ul>
</li>
<li><strong>实例数据</strong>：成员变量。</li>
<li><strong>对齐填充</strong>：保证 8 字节对齐。</li>
</ol>
<hr>
<h4 id="Q5-为什么建议用不可变对象（String-Integer-Long-等）作为共享数据？"><a href="#Q5-为什么建议用不可变对象（String-Integer-Long-等）作为共享数据？" class="headerlink" title="Q5. 为什么建议用不可变对象（String, Integer, Long 等）作为共享数据？"></a>Q5. 为什么建议用不可变对象（<code>String</code>, <code>Integer</code>, <code>Long</code> 等）作为共享数据？</h4><p>👉 <strong>回答要点</strong>：</p>
<ul>
<li>不可变 → 线程安全，不需要额外同步。</li>
<li>可作为 Map 的 key（不会被修改导致 hashCode 变化）。</li>
<li>方便缓存（如 String Pool）。</li>
</ul>
<hr>
<h4 id="Q6-什么时候用基本类型，什么时候用包装类型？"><a href="#Q6-什么时候用基本类型，什么时候用包装类型？" class="headerlink" title="Q6. 什么时候用基本类型，什么时候用包装类型？"></a>Q6. 什么时候用基本类型，什么时候用包装类型？</h4><p>👉 <strong>回答要点</strong>：</p>
<ul>
<li><strong>优先用基本类型</strong> → 性能敏感场景（循环计数器、数值计算）。</li>
<li><strong>必须用包装类型</strong> →<ul>
<li>需要使用泛型（<code>List&lt;Integer&gt;</code>）。</li>
<li>需要为 <code>null</code> 表示缺省值。</li>
<li>需要调用包装类的方法。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Q7-为什么-boolean-大小未定义？JVM-实际是怎么处理的？"><a href="#Q7-为什么-boolean-大小未定义？JVM-实际是怎么处理的？" class="headerlink" title="Q7. 为什么 boolean 大小未定义？JVM 实际是怎么处理的？"></a>Q7. 为什么 boolean 大小未定义？JVM 实际是怎么处理的？</h4><p>👉 <strong>回答要点</strong>：</p>
<ul>
<li>JVM 规范只定义了 boolean 的语义，没有强制大小。</li>
<li>实际实现：<ul>
<li>在数组中，boolean 常按 byte 存储。</li>
<li>在对象字段中，HotSpot 常把 boolean 当成 1B，但可能和其他字段合并压缩（bitfield）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="🔹-面试小结"><a href="#🔹-面试小结" class="headerlink" title="🔹 面试小结"></a>🔹 面试小结</h4><ul>
<li><strong>基本类型</strong> → 性能好，存值，不可为 null。</li>
<li><strong>引用类型</strong> → 面向对象特性，存引用，需 GC 管理。</li>
<li><strong>面试重点</strong>：装箱拆箱、缓存机制、对象内存布局、堆 vs 栈、不可变对象的好处。</li>
</ul>
<hr>
<h4 id="🔹-栈（Stack）"><a href="#🔹-栈（Stack）" class="headerlink" title="🔹 栈（Stack）"></a>🔹 栈（Stack）</h4><ul>
<li><strong>定义</strong>：线程私有，每个线程启动时会创建一个栈，生命周期和线程相同。</li>
<li><strong>存放内容</strong>：<ul>
<li><strong>局部变量</strong>（基本类型的值 &#x2F; 引用变量的引用值）。</li>
<li>方法调用信息（局部变量表、操作数栈、动态链接、返回地址）。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>内存小但访问快（栈帧出栈后，内存直接复用）。</li>
<li>线程隔离，不需要同步 → <strong>天然线程安全</strong>。</li>
<li>方法调用结束 → 栈帧自动销毁，无需 GC。</li>
</ul>
</li>
<li><strong>错误场景</strong>：<ul>
<li>递归过深或方法调用层次过多，会导致 <strong>StackOverflowError</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="🔹-堆（Heap）"><a href="#🔹-堆（Heap）" class="headerlink" title="🔹 堆（Heap）"></a>🔹 堆（Heap）</h4><ul>
<li><strong>定义</strong>：Java 内存最大的一块，所有线程共享。</li>
<li><strong>存放内容</strong>：<ul>
<li><strong>对象实例</strong>（无论是成员变量还是数组）。</li>
<li>对象的实例数据（字段）。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>所有线程共享，需要 GC 来管理生命周期。</li>
<li>内存分配比栈复杂（对象需要内存分配、布局、回收）。</li>
<li>大小可配置（<code>-Xmx</code> &#x2F; <code>-Xms</code>）。</li>
</ul>
</li>
<li><strong>错误场景</strong>：<ul>
<li>堆不足时 → <strong>OutOfMemoryError: Java heap space</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="🔹-对比总结"><a href="#🔹-对比总结" class="headerlink" title="🔹 对比总结"></a>🔹 对比总结</h4><table>
<thead>
<tr>
<th>对比点</th>
<th>栈</th>
<th>堆</th>
</tr>
</thead>
<tbody><tr>
<td><strong>管理</strong></td>
<td>方法调用自动分配&#x2F;销毁</td>
<td>JVM GC 管理</td>
</tr>
<tr>
<td><strong>存储内容</strong></td>
<td>基本类型的值、引用的地址</td>
<td>对象实例、成员变量</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>线程私有，安全</td>
<td>线程共享，需同步</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>方法结束自动销毁</td>
<td>对象被 GC 回收</td>
</tr>
<tr>
<td><strong>错误</strong></td>
<td><code>StackOverflowError</code></td>
<td><code>OutOfMemoryError</code></td>
</tr>
</tbody></table>
<hr>
<h4 id="🔹-常见面试追问"><a href="#🔹-常见面试追问" class="headerlink" title="🔹 常见面试追问"></a>🔹 常见面试追问</h4><h3 id="Q1-Java-中的变量存放在堆还是栈？"><a href="#Q1-Java-中的变量存放在堆还是栈？" class="headerlink" title="Q1. Java 中的变量存放在堆还是栈？"></a>Q1. Java 中的变量存放在堆还是栈？</h3><p>👉 <strong>回答要点</strong>：</p>
<ul>
<li>基本类型的局部变量 → 存在栈里。</li>
<li>引用变量（如 <code>Person p</code>） → 引用存在栈里，实际对象在堆里。</li>
<li>对象字段（即使是基本类型） → 随着对象存放在堆里。</li>
</ul>
<hr>
<h4 id="Q2-为什么栈比堆快？"><a href="#Q2-为什么栈比堆快？" class="headerlink" title="Q2. 为什么栈比堆快？"></a>Q2. 为什么栈比堆快？</h4><p>👉 <strong>回答要点</strong>：</p>
<ul>
<li>栈是顺序内存结构，分配&#x2F;释放只移动栈顶指针 → O(1)。</li>
<li>堆分配需要找合适的内存块，还要涉及 GC，成本高。</li>
</ul>
<hr>
<h4 id="Q3-栈里能存对象吗？"><a href="#Q3-栈里能存对象吗？" class="headerlink" title="Q3. 栈里能存对象吗？"></a>Q3. 栈里能存对象吗？</h4><p>👉 <strong>回答要点</strong>：</p>
<ul>
<li>严格来说，<strong>对象实例只能在堆中存</strong>。</li>
<li>栈里只能存对象引用（指向堆）。</li>
<li>但 JVM 的 JIT 优化可能会做<strong>逃逸分析</strong>，把未逃出方法的对象分配到栈上（Stack Allocation），甚至标量替换 → 提高性能。</li>
</ul>
<hr>
<h4 id="Q4-为什么要有堆和栈的区分？"><a href="#Q4-为什么要有堆和栈的区分？" class="headerlink" title="Q4. 为什么要有堆和栈的区分？"></a>Q4. 为什么要有堆和栈的区分？</h4><p>👉 <strong>回答要点</strong>：</p>
<ul>
<li>栈 → 方法调用和局部变量，高效且线程私有。</li>
<li>堆 → 对象共享，生命周期不固定，只能靠 GC。</li>
<li>各自职责清晰，才能兼顾性能和灵活性。</li>
</ul>
<hr>
<h4 id="Q5-GC-只回收堆吗？"><a href="#Q5-GC-只回收堆吗？" class="headerlink" title="Q5. GC 只回收堆吗？"></a>Q5. GC 只回收堆吗？</h4><p>👉 <strong>回答要点</strong>：</p>
<ul>
<li>对，GC 主要回收堆内存。</li>
<li>栈内存是随着方法出栈自动释放的，不需要 GC。</li>
</ul>
<hr>
<h4 id="🔹-面试快速答题版"><a href="#🔹-面试快速答题版" class="headerlink" title="🔹 面试快速答题版"></a>🔹 面试快速答题版</h4><ul>
<li><strong>栈</strong>：线程私有，存局部变量和方法调用信息，生命周期随方法，速度快但空间小，异常 <code>StackOverflowError</code>。</li>
<li><strong>堆</strong>：线程共享，存对象实例，由 GC 管理，灵活但慢，异常 <code>OutOfMemoryError</code>。</li>
</ul>
<hr>
<h3 id="2-抽象类-vs-接口"><a href="#2-抽象类-vs-接口" class="headerlink" title="2 抽象类 vs 接口"></a>2 抽象类 vs 接口</h3><ul>
<li><strong>抽象类（abstract class）</strong>：<ul>
<li>可以包含字段、构造器、具体方法和抽象方法。</li>
<li>适用于“is-a”关系且需要共享状态或实现细节的场景。</li>
<li>单继承：类只能继承一个抽象类。</li>
</ul>
</li>
<li><strong>接口（interface）</strong>：<ul>
<li>Java 8+ 支持 <code>default</code> 方法、<code>static</code> 方法；Java 9+ 支持私有方法。接口不能有实例字段（只允许 <code>public static final</code> 常量）。</li>
<li>支持多重实现（类可以实现多个接口），适合行为声明。</li>
</ul>
</li>
<li><strong>语义区别</strong>：抽象类关心“什么是”，接口关心“能做什么”。</li>
<li><strong>版本注意</strong>：由于 <code>default</code> 方法，接口现在可以携带实现，这使得“接口演进”更容易（兼容旧实现）。</li>
</ul>
<p><strong>面试要点</strong>：选择抽象类还是接口的理由；接口的多继承与菱形继承问题如何解决（Java 接口方法冲突规则）。</p>
<hr>
<h4 id="🔹-抽象类-vs-接口：如何选择？"><a href="#🔹-抽象类-vs-接口：如何选择？" class="headerlink" title="🔹 抽象类 vs 接口：如何选择？"></a>🔹 抽象类 vs 接口：如何选择？</h4><h5 id="1-抽象类的特点"><a href="#1-抽象类的特点" class="headerlink" title="1. 抽象类的特点"></a>1. 抽象类的特点</h5><ul>
<li>可以有 <strong>成员变量</strong>（实例变量、静态变量）、<strong>构造器</strong>（但不能直接实例化）。</li>
<li>可以有 <strong>方法实现</strong>（非抽象方法）。</li>
<li>可以提供 <strong>状态 + 行为</strong> 的部分实现。</li>
<li>类只能继承一个父类 → 抽象类适合<strong>类层次结构</strong>的扩展。</li>
</ul>
<p>👉 适用场景：</p>
<ul>
<li>表达 <strong>“is-a”</strong> 关系，且有 <strong>代码复用</strong>需求。</li>
<li>子类共享一些公共逻辑，但仍需要抽象定义。</li>
<li>比如 <code>AbstractList</code>、<code>HttpServlet</code>。</li>
</ul>
<hr>
<h5 id="2-接口的特点"><a href="#2-接口的特点" class="headerlink" title="2. 接口的特点"></a>2. 接口的特点</h5><ul>
<li>从 Java 8 开始，可以有 <strong>default 方法</strong> 和 <strong>static 方法</strong>（Java 9 引入 private 方法）。</li>
<li>不能有实例变量（只能有常量 <code>public static final</code>）。</li>
<li>用于定义 <strong>规范 &#x2F; 能力</strong>（行为约定），没有状态。</li>
<li>一个类可以实现多个接口 → 更灵活。</li>
</ul>
<p>👉 适用场景：</p>
<ul>
<li>表达 <strong>“can-do”</strong> 能力，不关心类的层次结构。</li>
<li>用于跨模块、跨层的解耦（如 <code>Serializable</code>、<code>Comparable</code>、<code>Runnable</code>）。</li>
<li>适合 <strong>API 设计</strong>，定义一组必须实现的功能。</li>
</ul>
<hr>
<h5 id="3-选择准则"><a href="#3-选择准则" class="headerlink" title="3. 选择准则"></a>3. 选择准则</h5><ul>
<li><strong>优先接口</strong>：如果只需定义行为，且希望解耦。</li>
<li><strong>抽象类</strong>：如果需要 <strong>共享状态</strong> 或 <strong>部分实现</strong>。</li>
<li><strong>接口 + default 方法</strong>：适合工具性扩展，不破坏已有实现。</li>
<li><strong>抽象类 + 模板方法模式</strong>：需要控制子类实现的调用顺序。</li>
</ul>
<hr>
<h4 id="🔹-接口的多继承-菱形继承问题"><a href="#🔹-接口的多继承-菱形继承问题" class="headerlink" title="🔹 接口的多继承 &amp; 菱形继承问题"></a>🔹 接口的多继承 &amp; 菱形继承问题</h4><h5 id="1-什么是菱形继承？"><a href="#1-什么是菱形继承？" class="headerlink" title="1. 什么是菱形继承？"></a>1. 什么是菱形继承？</h5><p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;C&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">B</span>, C &#123;</span><br><span class="line">    <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>D</code> 同时继承了 <code>B</code> 和 <code>C</code>，它们都从 <code>A</code> 继承了 <code>hello</code>，并且覆盖了。<br> 问题：<code>D</code> 调用 <code>hello()</code> 时，调用哪个？</p>
<p>Java 编译规则：</p>
<ol>
<li><strong>类优先</strong> → 这里 <code>D</code> 自己没写，父类也没有，所以走不到。</li>
<li><strong>子接口更具体</strong> → 但 <code>B</code> 和 <code>C</code> 是并列接口，没有继承关系，无法判断谁更具体。</li>
<li><strong>必须显示覆盖</strong> → 由于有二义性，编译器直接报错，强制 <code>D</code> 必须自己实现 <code>hello()</code>。</li>
</ol>
<hr>
<h5 id="2-Java-的规则（接口方法冲突解决）"><a href="#2-Java-的规则（接口方法冲突解决）" class="headerlink" title="2. Java 的规则（接口方法冲突解决）"></a>2. Java 的规则（接口方法冲突解决）</h5><p>Java 避免了 C++ 的“菱形继承”困境，规则如下：</p>
<ol>
<li><strong>类优先原则</strong>：<ul>
<li>如果类和接口中有同名方法，优先使用类中的方法。</li>
<li>即 <strong>类 &gt; 接口 default 方法</strong>。</li>
</ul>
</li>
<li><strong>更具体接口优先原则</strong>：<ul>
<li>如果多个接口中有冲突的 default 方法，选择继承路径更“具体”的接口。</li>
<li>例：如果 <code>B extends A</code>，<code>C extends A</code>，类实现 <code>B, C</code> → 优先 <code>B</code> 或 <code>C</code> 的覆盖方法。</li>
</ul>
</li>
<li><strong>必须显式覆盖</strong>（冲突无法自动解决时）：<ul>
<li>如果继承了多个接口，且 default 方法签名冲突，必须在实现类里 <strong>显式 override</strong>。</li>
<li>可以用 <code>X.super.method()</code> 调用指定接口的默认实现。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-例子：解决冲突"><a href="#3-例子：解决冲突" class="headerlink" title="3. 例子：解决冲突"></a>3. 例子：解决冲突</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">B</span>, C &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 必须显式解决</span></span><br><span class="line">        B.<span class="built_in">super</span>.hello(); <span class="comment">// 或 C.super.hello();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="🔹-面试快速答题版-1"><a href="#🔹-面试快速答题版-1" class="headerlink" title="🔹 面试快速答题版"></a>🔹 面试快速答题版</h4><ul>
<li><strong>抽象类 vs 接口</strong>：<ul>
<li>抽象类：有状态（字段）、有构造器、适合类层次结构，子类共享逻辑。</li>
<li>接口：定义行为规范，无状态，可多继承，解耦性更强。</li>
<li>一般 <strong>优先接口</strong>，当需要共享实现时用抽象类。</li>
</ul>
</li>
<li><strong>接口多继承的菱形问题</strong>：<ul>
<li>Java 通过 <strong>明确规则</strong>避免了 C++ 菱形继承的歧义：<ol>
<li>类优先于接口。</li>
<li>更具体的接口优先。</li>
<li>冲突时必须在实现类显式覆盖，并可用 <code>X.super.method()</code> 调用。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-final-关键字"><a href="#3-final-关键字" class="headerlink" title="3 final 关键字"></a>3 final 关键字</h3><ul>
<li><strong>final 类</strong>：不能被继承（确保行为不可扩展&#x2F;被覆盖）。</li>
<li><strong>final 方法</strong>：不能被重写（用于安全或性能提示）。</li>
<li><strong>final 变量</strong>：<ul>
<li>局部 final：必须在声明或构造器&#x2F;初始化块中初始化一次；在 lambda&#x2F;匿名内部类中要求变量为“effectively final”。</li>
<li>成员 final（字段）：在构造器中赋值后不可修改；对引用类型，final 限制的是引用不可改变，但对象状态仍可变。</li>
</ul>
</li>
<li><strong>JMM 中的 final 字段语义</strong>：final 字段有特殊的内存可见性保证：构造器中写入 final 字段并且对象正确发布后，其他线程能看到正确的 final 字段值（比普通字段更强）。但安全发布仍需注意（不要在构造器中把 <code>this</code> 逸出）。</li>
</ul>
<p><strong>面试点</strong>：final 与线程安全、final 与常量折叠（compile-time constant）、final 与继承&#x2F;多态影响。</p>
<p>很好 👌 你已经把 <strong><code>final</code> 的核心点</strong> 梳理得很完整了，我帮你再补充一些 <strong>细节 + 面试可能的追问点</strong>，这样遇到深挖问题也能答得很漂亮。</p>
<hr>
<h4 id="final-关键字总结"><a href="#final-关键字总结" class="headerlink" title="final 关键字总结"></a><strong>final 关键字总结</strong></h4><h5 id="1-final-类"><a href="#1-final-类" class="headerlink" title="1. final 类"></a>1. <code>final</code> 类</h5><ul>
<li><strong>含义</strong>：不能被继承（例如 <code>String</code>, <code>Integer</code>, <code>Math</code>）。</li>
<li><strong>设计原因</strong>：<ol>
<li>确保安全性（防止子类破坏不可变性，比如 <code>String</code>）。</li>
<li>JVM 优化（JIT 能更大胆做内联&#x2F;优化，因为知道不会被 override）。</li>
</ol>
</li>
<li><strong>面试追问</strong>：<ul>
<li>Q: 为什么 <code>String</code> 是 <code>final</code>？<ul>
<li>A: 保证不可变，避免哈希缓存、字符串池等被破坏，提升线程安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-final-方法"><a href="#2-final-方法" class="headerlink" title="2. final 方法"></a>2. <code>final</code> 方法</h5><ul>
<li><strong>含义</strong>：不能被重写（但可以被重载）。</li>
<li><strong>用途</strong>：<ul>
<li>确保某些方法的逻辑不会被子类篡改（模板方法模式常用）。</li>
<li>JVM 可做<strong>早期绑定</strong>（non-virtual call），提升性能。</li>
</ul>
</li>
<li><strong>面试追问</strong>：<ul>
<li>Q: <code>private</code> 方法能否是 <code>final</code>？<ul>
<li>A: 可以，但没有意义，因为 <code>private</code> 方法本来就不能被重写。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-final-变量"><a href="#3-final-变量" class="headerlink" title="3. final 变量"></a>3. <code>final</code> 变量</h5><h6 id="3-1-局部变量"><a href="#3-1-局部变量" class="headerlink" title="3.1 局部变量"></a>3.1 局部变量</h6><ul>
<li>必须初始化一次，之后不能改。</li>
<li><strong>lambda &amp; 匿名类</strong>：要求变量是 <strong>effectively final</strong>（未被重新赋值即可）。<ul>
<li>目的是保证闭包捕获的变量一致性。</li>
</ul>
</li>
</ul>
<h6 id="3-2-成员变量（字段）"><a href="#3-2-成员变量（字段）" class="headerlink" title="3.2 成员变量（字段）"></a>3.2 成员变量（字段）</h6><ul>
<li><p><code>final</code> 字段要么在声明时初始化，要么在构造函数&#x2F;初始化块中赋值。</p>
</li>
<li><p>对引用类型：引用本身不能修改，但对象内容可变（浅不可变）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;x&quot;</span>); <span class="comment">// ✅ 可行</span></span><br><span class="line">list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// ❌ 不行</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="3-3-常量折叠"><a href="#3-3-常量折叠" class="headerlink" title="3.3 常量折叠"></a>3.3 常量折叠</h6><ul>
<li><p><code>final static</code> 基本类型 + <code>String</code> 常量 → <strong>编译期常量</strong>，会在编译时内联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">42</span>; </span><br><span class="line">System.out.println(A); <span class="comment">// 编译时就替换成 42</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>面试追问：</p>
<ul>
<li>Q: 如果修改了常量定义，是否需要重新编译依赖的类？<ul>
<li>A: 需要，否则依赖类还用旧值（因为常量折叠到字节码里）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-JMM-中的-final-语义"><a href="#4-JMM-中的-final-语义" class="headerlink" title="4. JMM 中的 final 语义"></a>4. JMM 中的 final 语义</h5><ul>
<li><strong>特殊内存语义</strong>：<ul>
<li>构造器中对 <code>final</code> 字段的写入，对其他线程是安全可见的（只要对象正确发布）。</li>
<li>与普通字段不同，普通字段可能出现“半初始化可见”。</li>
</ul>
</li>
<li><strong>注意点</strong>：<ul>
<li>不能在构造函数中把 <code>this</code> 逃逸（比如把自己注册到全局 map），否则 <code>final</code> 语义失效。</li>
</ul>
</li>
<li><strong>面试追问</strong>：<ul>
<li>Q: <code>final</code> 字段能完全保证不可变对象的线程安全性吗？<ul>
<li>A: 如果对象状态完全由 <code>final</code> 字段决定，并且没有泄漏 <code>this</code>，是安全的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="✅-面试常见追问-答法"><a href="#✅-面试常见追问-答法" class="headerlink" title="✅ 面试常见追问 + 答法"></a>✅ 面试常见追问 + 答法</h4><ol>
<li><strong><code>final</code> 和 <code>finally</code>、<code>finalize</code> 的区别？</strong><ul>
<li><code>final</code>：修饰符</li>
<li><code>finally</code>：异常处理中的保证块</li>
<li><code>finalize()</code>：对象回收前调用的方法（已过时，不建议用）</li>
</ul>
</li>
<li><strong><code>final</code> 与不可变类的关系？</strong><ul>
<li><code>final</code> 字段是不可变类的基础；不可变类通常要求：类是 <code>final</code>，字段是 <code>final</code>，且没有 <code>setter</code>。</li>
</ul>
</li>
<li><strong>为什么 Java 要有 <code>final</code> 字段的内存模型特殊语义？</strong><ul>
<li>确保不可变对象真正安全（如 <code>String</code>、<code>Integer</code>），避免指令重排导致读到未初始化值。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-static-关键字"><a href="#4-static-关键字" class="headerlink" title="4 static 关键字"></a>4 static 关键字</h3><ul>
<li><strong>static 变量</strong>（类变量）：类加载时初始化，所有实例共享。</li>
<li><strong>static 方法</strong>：与实例无关，不能直接访问非静态成员（因为没有 this）。静态方法在子类中被“隐藏”，不是多态（不能被 override，只能被子类定义同名静态方法，调用根据编译时类型）。</li>
<li><strong>static 块</strong>：类加载时执行（用于初始化复杂静态资源）。</li>
<li><strong>静态方法能否调用非静态成员？</strong> 不能直接调用。若需要，必须先获得某个实例并通过该实例访问非静态成员。</li>
<li><strong>static synchronized</strong>：锁的是 Class 对象（<code>MyClass.class</code>），而非实例。</li>
</ul>
<p><strong>面试点</strong>：类加载时机（静态初始化顺序）、类初始化与双亲委派、静态成员与内存泄漏（大量静态缓存）、静态方法隐藏 vs 实例方法重写。</p>
<hr>
<h4 id="static-关键字详解"><a href="#static-关键字详解" class="headerlink" title="static 关键字详解"></a><strong>static 关键字详解</strong></h4><h5 id="1-static-变量（类变量）"><a href="#1-static-变量（类变量）" class="headerlink" title="1. static 变量（类变量）"></a>1. static 变量（类变量）</h5><ul>
<li><strong>生命周期</strong>：类加载时分配，JVM 在方法区（JDK8 之后是 <strong>元空间</strong> + 堆里的静态区）为类变量分配内存。</li>
<li><strong>共享性</strong>：所有实例共享同一份内存。</li>
<li><strong>初始化顺序</strong>：<ul>
<li>静态变量 &amp; 静态块 → 按源码顺序依次执行。</li>
<li>在类初始化阶段完成。</li>
</ul>
</li>
<li><strong>面试追问</strong>：<ul>
<li>Q: 静态变量存放在哪里？<ul>
<li>JDK7 之前：方法区（永久代）。</li>
<li>JDK8 之后：方法区 → 元空间，引用存放在元空间，实际对象可能在堆上。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-static-方法"><a href="#2-static-方法" class="headerlink" title="2. static 方法"></a>2. static 方法</h5><ul>
<li><p><strong>特性</strong>：</p>
<ul>
<li>属于类本身（Class），不依赖对象。</li>
<li><strong>不能访问实例成员</strong>（没有 <code>this</code>）。</li>
<li>静态方法在子类中<strong>不会覆盖</strong>父类的静态方法，而是<strong>隐藏</strong>（Static Hiding）。</li>
</ul>
</li>
<li><p><strong>多态性区别</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A&quot;</span>); &#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B&quot;</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">a.hi(); <span class="comment">// 输出 A（静态绑定，取决于引用类型）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>面试追问</strong>：</p>
<ul>
<li>Q: 静态方法能否被重写？<ul>
<li>A: 不能，静态方法是类级别的，不走虚方法表，不具备运行时多态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-static-代码块"><a href="#3-static-代码块" class="headerlink" title="3. static 代码块"></a>3. static 代码块</h5><ul>
<li><strong>执行时机</strong>：类初始化时（类加载 → 验证 → 准备 → 解析 → <strong>初始化</strong>）。</li>
<li><strong>顺序</strong>：<ul>
<li>父类静态代码块 → 子类静态代码块 → 父类构造块&#x2F;构造器 → 子类构造块&#x2F;构造器。</li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li>初始化复杂静态变量（如 <code>Map</code>、<code>Set</code>）。</li>
<li>加载 native 库。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-static-synchronized"><a href="#4-static-synchronized" class="headerlink" title="4. static synchronized"></a>4. static synchronized</h5><ul>
<li><strong>含义</strong>：锁住 <code>Class</code> 对象。</li>
<li><strong>区别</strong>：<ul>
<li><code>synchronized</code> 实例方法 → 锁住当前对象实例 (<code>this</code>)。</li>
<li><code>static synchronized</code> 方法 → 锁住当前类的 <code>Class</code> 对象。</li>
</ul>
</li>
<li><strong>面试追问</strong>：<ul>
<li>Q: 两个线程调用同一对象的实例方法（synchronized）和类方法（static synchronized），会互斥吗？<ul>
<li>A: 不会。因为前者锁的是实例对象，后者锁的是 <code>Class</code> 对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="⚡-常见面试陷阱"><a href="#⚡-常见面试陷阱" class="headerlink" title="⚡ 常见面试陷阱"></a>⚡ 常见面试陷阱</h4><h5 id="❌-1-静态成员与内存泄漏"><a href="#❌-1-静态成员与内存泄漏" class="headerlink" title="❌ 1. 静态成员与内存泄漏"></a>❌ 1. 静态成员与内存泄漏</h5><ul>
<li>若静态变量持有对象引用（尤其是集合、缓存），会导致对象无法被 GC 回收，造成 <strong>类加载器泄漏</strong>。</li>
<li>常见于 Web 容器（Tomcat）反复部署应用。</li>
</ul>
<h5 id="❌-2-静态方法调用实例方法"><a href="#❌-2-静态方法调用实例方法" class="headerlink" title="❌ 2. 静态方法调用实例方法"></a>❌ 2. 静态方法调用实例方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        g(); <span class="comment">// ❌ 编译错误，g() 是实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>👉 必须通过实例来调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">t.g(); <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure>

<h5 id="❌-3-静态内部类与非静态内部类"><a href="#❌-3-静态内部类与非静态内部类" class="headerlink" title="❌ 3. 静态内部类与非静态内部类"></a>❌ 3. 静态内部类与非静态内部类</h5><ul>
<li><strong>静态内部类</strong>：不依赖外部类实例，可以直接创建 <code>new Outer.Inner()</code></li>
<li><strong>非静态内部类</strong>：需要外部类实例 <code>new Outer().new Inner()</code></li>
</ul>
<hr>
<h4 id="✅-高频面试追问"><a href="#✅-高频面试追问" class="headerlink" title="✅ 高频面试追问"></a>✅ 高频面试追问</h4><ol>
<li><strong>static 方法能否访问 this？</strong><ul>
<li>不能，因为静态方法属于类，没有 this 指针。</li>
</ul>
</li>
<li><strong>类什么时候被加载和初始化？</strong><ul>
<li>使用到静态变量&#x2F;静态方法时；</li>
<li>new 对象时；</li>
<li>反射调用时；</li>
<li>主类（包含 <code>main</code>）被启动时。</li>
</ul>
</li>
<li><strong>静态方法能否被重写？为什么？</strong><ul>
<li>不能。静态方法编译期绑定，属于类，不属于对象。子类的同名静态方法只是隐藏父类方法。</li>
</ul>
</li>
<li><strong>静态变量是否线程安全？</strong><ul>
<li>取决于是否被并发修改。<code>static</code> 本身只保证共享，不保证安全，仍需同步控制。</li>
</ul>
</li>
</ol>
<hr>
<hr>
<h3 id="5-String-StringBuffer-StringBuilder"><a href="#5-String-StringBuffer-StringBuilder" class="headerlink" title="5 String &#x2F; StringBuffer &#x2F; StringBuilder"></a>5 String &#x2F; StringBuffer &#x2F; StringBuilder</h3><ul>
<li><strong>String</strong>：<ul>
<li><strong>不可变</strong>（immutable）。任何修改都会产生新对象。好处：线程安全、可作为 Map&#x2F;Set 的 key、可安全缓存（字符串常量池 intern）。</li>
<li>Java 9 后内部表征从 <code>char[]</code> 变为 <code>byte[] + coder</code>（节省内存）。</li>
<li><code>String.intern()</code>：将字符串放到常量池，可能影响 permgen&#x2F;metaspace 使用。</li>
</ul>
</li>
<li><strong>StringBuffer</strong>：<ul>
<li>可变字符序列，<strong>线程安全</strong>（方法使用 <code>synchronized</code>）。适合多线程频繁修改单一实例的场景（但通常用得少）。</li>
</ul>
</li>
<li><strong>StringBuilder</strong>：<ul>
<li>可变字符序列，<strong>非线程安全</strong>，性能优于 <code>StringBuffer</code>（适合大多数单线程场景，如拼接循环中的字符串构造）。</li>
</ul>
</li>
<li><strong>容量增长</strong>：<ul>
<li><code>StringBuilder</code> 的扩容策略通常为 <code>newCapacity = (oldCapacity &lt;&lt; 1) + 2</code>（约 2x），不同 JDK 版本细节稍有差异。</li>
</ul>
</li>
<li><strong>性能建议</strong>：大量拼接用 <code>StringBuilder</code>；若作为 HashMap key，用不可变 <code>String</code>。</li>
</ul>
<p><strong>面试点</strong>：为什么 String 可作为 Map key（不可变性保证 hashCode 不变）、String 常量池与内存、拼接在循环里使用 + 的问题（导致大量临时 String）。</p>
<hr>
<h4 id="1-为什么-String-可以作为-Map-的-key？"><a href="#1-为什么-String-可以作为-Map-的-key？" class="headerlink" title="1. 为什么 String 可以作为 Map 的 key？"></a>1. <strong>为什么 <code>String</code> 可以作为 <code>Map</code> 的 key？</strong></h4><ul>
<li><code>HashMap</code> 的 key 依赖 <code>hashCode()</code> 和 <code>equals()</code>。</li>
<li>如果 key 可变，放入后修改会导致：<ul>
<li><strong>hashCode 改变</strong> → 无法找到原来的 bucket。</li>
<li><strong>equals 改变</strong> → 逻辑错误。</li>
</ul>
</li>
</ul>
<p>👉 <code>String</code> 是 <strong>不可变对象</strong>：</p>
<ul>
<li><code>hashCode</code> 在第一次计算后会缓存（lazy 计算，存在 <code>hash</code> 字段里）。</li>
<li>因为内容不变，hashCode 永远一致，保证放入 Map 后可以稳定检索。</li>
<li><code>equals</code> 比较基于内容，逻辑也稳定。</li>
</ul>
<p>💡 面试点延伸：</p>
<ul>
<li>为什么 <code>String</code>、<code>Integer</code>、<code>Long</code> 等不可变对象经常作为 <code>Map</code> key？<br> 👉 因为<strong>不可变性保证了哈希一致性</strong>。</li>
</ul>
<hr>
<h4 id="2-String-常量池与内存"><a href="#2-String-常量池与内存" class="headerlink" title="2. String 常量池与内存"></a>2. <strong>String 常量池与内存</strong></h4><ul>
<li><p><strong>字符串常量池（String Pool）</strong>：</p>
<ul>
<li>存放编译期确定的字面量和运行时调用 <code>intern()</code> 的字符串。</li>
<li>在 JDK 6 以前，常量池在 <strong>永久代 (PermGen)</strong>；JDK 7+ 移到 <strong>堆</strong>；JDK 8+ <strong>完全在堆中</strong>。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;         <span class="comment">// 放入常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;         <span class="comment">// 直接引用池中的同一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 在堆中创建新对象，不会自动放入池</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>intern() 方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>).intern();</span><br><span class="line">System.out.println(s1 == s4); <span class="comment">// true，引用池对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>👉 <strong>好处</strong>：</p>
<ul>
<li>节省内存（相同字面量只存一份）。</li>
<li>提高比较性能（字符串常量池对象可以直接用 <code>==</code> 判断）。</li>
</ul>
<hr>
<h4 id="3-循环中使用-拼接字符串的问题"><a href="#3-循环中使用-拼接字符串的问题" class="headerlink" title="3. 循环中使用 + 拼接字符串的问题"></a>3. <strong>循环中使用 <code>+</code> 拼接字符串的问题</strong></h4><ul>
<li><p><code>String</code> 是不可变的，每次拼接都会生成 <strong>新的对象</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    s = s + i; <span class="comment">// 每次拼接都 new 一个新的 String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>内部相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).append(i).toString();</span><br></pre></td></tr></table></figure>
</li>
<li><p>导致创建 <strong>大量临时对象</strong>，性能极差（O(n²)）。</p>
</li>
</ul>
</li>
<li><p><strong>正确写法</strong>：使用 <code>StringBuilder</code> 或 <code>StringBuffer</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>💡 面试官可能会追问：</p>
<ul>
<li><strong>为什么 <code>&quot;a&quot; + &quot;b&quot; + &quot;c&quot;</code> 没问题？</strong><br> 👉 编译器优化，常量折叠成 <code>&quot;abc&quot;</code>，不会产生额外对象。</li>
<li><strong>为什么循环里不优化？</strong><br> 👉 循环次数不确定，编译器无法提前合并。</li>
</ul>
<hr>
<h4 id="4-面试高频追问"><a href="#4-面试高频追问" class="headerlink" title="4. 面试高频追问"></a>4. <strong>面试高频追问</strong></h4><ol>
<li><strong>为什么 <code>String</code> 设计成不可变？</strong><ul>
<li>安全性（避免泄露，例如 JDBC URL、ClassLoader 字符串）。</li>
<li>线程安全（不可变对象天然线程安全）。</li>
<li>常量池优化（相同字面量可复用）。</li>
<li>作为 HashMap key 的稳定性。</li>
</ul>
</li>
<li><strong>intern() 会造成内存泄漏吗？</strong><ul>
<li>JDK 6：常量池在永久代，<code>intern()</code> 多了可能 OOM。</li>
<li>JDK 7+：移到堆中，和 GC 一起回收，不会永久泄漏。</li>
</ul>
</li>
<li><strong>StringBuilder vs StringBuffer？</strong><ul>
<li><code>StringBuilder</code>：非线程安全，单线程高性能。</li>
<li><code>StringBuffer</code>：线程安全（方法有 <code>synchronized</code>），适合多线程环境。</li>
</ul>
</li>
</ol>
<hr>
<p>✅ <strong>简答版（面试 1 分钟答法）</strong>：</p>
<ul>
<li><code>String</code> 作为 Map key：不可变性保证 hashCode 和 equals 一致性。</li>
<li>常量池：字符串字面量和 intern() 存在池中，节省内存，提升性能。</li>
<li>循环拼接：<code>+</code> 会创建大量临时对象，应使用 <code>StringBuilder</code>。</li>
</ul>
<hr>
<h3 id="6-与-equals"><a href="#6-与-equals" class="headerlink" title="6 &#x3D;&#x3D; 与 equals()"></a>6 &#x3D;&#x3D; 与 equals()</h3><ul>
<li><strong>&#x3D;&#x3D;</strong>：<ul>
<li>基本类型：比较值。</li>
<li>引用类型：比较引用地址（是否同一对象）。</li>
</ul>
</li>
<li><strong>equals()</strong>：<ul>
<li><code>Object.equals()</code> 默认是 <code>==</code>（引用相等）。很多类（如 <code>String</code>、集合类、包装类）重写了 <code>equals()</code> 比较语义上的“等价性”。</li>
</ul>
</li>
<li><strong>常见陷阱</strong>：<ul>
<li><code>Integer a = 127; Integer b = 127; a == b // true</code>（因为 JVM 缓存 -128~127 范围的 Integer.valueOf）；<code>Integer x = 128; Integer y = 128; x == y // false</code>。</li>
<li><code>new String(&quot;x&quot;) == &quot;x&quot;</code> 为 <code>false</code>（不同对象），但 <code>new String(&quot;x&quot;).intern() == &quot;x&quot;</code> 为 <code>true</code>。</li>
</ul>
</li>
</ul>
<p><strong>面试点</strong>：何时用 equals（内容比较），何时用 &#x3D;&#x3D;（引用比较）；实现 equals 时遵守对称性、传递性、反射性、稳定性。</p>
<hr>
<h4 id="1-：比较引用-基本类型值"><a href="#1-：比较引用-基本类型值" class="headerlink" title="1. ==：比较引用&#x2F;基本类型值"></a>1. <strong><code>==</code>：比较引用&#x2F;基本类型值</strong></h4><h5 id="1-1-基本类型"><a href="#1-1-基本类型" class="headerlink" title="1.1 基本类型"></a>1.1 基本类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>, b = <span class="number">5</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true，比较值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于 <strong>基本类型</strong>，<code>==</code> 比较的是 <strong>实际存储的值</strong>。</li>
</ul>
<h5 id="1-2-引用类型"><a href="#1-2-引用类型" class="headerlink" title="1.2 引用类型"></a>1.2 引用类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false，比较引用地址</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于 <strong>对象引用</strong>，<code>==</code> 比较的是 <strong>是否指向同一内存地址</strong>（即是否同一个对象）。</li>
<li>面试常考点：<ul>
<li>常量池里的字面量 <code>String s3 = &quot;abc&quot;; String s4 = &quot;abc&quot;;</code> → <code>s3 == s4</code> 为 <code>true</code>（引用相同）。</li>
<li><code>new String(&quot;abc&quot;)</code> 每次创建新对象 → 引用不同。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-equals-：比较内容"><a href="#2-equals-：比较内容" class="headerlink" title="2. equals()：比较内容"></a>2. <strong><code>equals()</code>：比较内容</strong></h4><ul>
<li>定义在 <code>Object</code> 中：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span> == obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但大多数类（如 <code>String</code>, <code>Integer</code>, <code>List</code>）都会重写 <code>equals()</code>，<strong>比较对象的逻辑内容</strong>而不是引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true，内容相同</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-使用准则"><a href="#3-使用准则" class="headerlink" title="3. 使用准则"></a>3. <strong>使用准则</strong></h4><table>
<thead>
<tr>
<th>场景</th>
<th>使用方式</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型</td>
<td><code>==</code></td>
<td>比较值</td>
</tr>
<tr>
<td>对象引用是否同一对象</td>
<td><code>==</code></td>
<td>比较内存地址</td>
</tr>
<tr>
<td>对象内容是否相同</td>
<td><code>equals()</code></td>
<td>比较逻辑内容，需要类正确重写 equals()</td>
</tr>
<tr>
<td>容器&#x2F;Map key 比较</td>
<td><code>equals()</code></td>
<td>Map&#x2F;Set 查找时根据 equals() 决定逻辑相等</td>
</tr>
</tbody></table>
<hr>
<h4 id="4-常见面试陷阱"><a href="#4-常见面试陷阱" class="headerlink" title="4. 常见面试陷阱"></a>4. <strong>常见面试陷阱</strong></h4><ol>
<li><strong>String 比较</strong>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>包装类比较</strong>（Integer、Long）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">127</span>, i2 = <span class="number">127</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// true，-128~127 缓存池</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>, i4 = <span class="number">128</span>;</span><br><span class="line">System.out.println(i3 == i4); <span class="comment">// false，超过缓存范围</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>自定义类未重写 equals()</strong>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; String name; &#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">System.out.println(p1.equals(p2)); <span class="comment">// false，Object 默认比较引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>面试点：自定义类使用内容比较需要 <strong>重写 equals()</strong>（同时重写 hashCode()）。</li>
</ul>
<hr>
<h4 id="5-面试快捷答法"><a href="#5-面试快捷答法" class="headerlink" title="5. 面试快捷答法"></a>5. <strong>面试快捷答法</strong></h4><ul>
<li><code>==</code>：<ul>
<li>基本类型 → 值比较</li>
<li>引用类型 → 地址比较（同一个对象吗）</li>
</ul>
</li>
<li><code>equals()</code>：<ul>
<li>内容比较（逻辑相等），前提类重写了 equals()</li>
</ul>
</li>
<li>容器&#x2F;Map 使用 <code>equals()</code> 判断元素或 key 是否相等</li>
</ul>
<hr>
<p>💡 <strong>延伸小技巧</strong>：</p>
<ul>
<li>写 <code>a.equals(b)</code> 前最好检查 <code>a != null</code>，或者用 <code>Objects.equals(a, b)</code> 防止 NullPointerException。</li>
</ul>
<hr>
<h3 id="7-hashCode-与-equals"><a href="#7-hashCode-与-equals" class="headerlink" title="7 hashCode() 与 equals()"></a>7 hashCode() 与 equals()</h3><ul>
<li><p><strong>合同</strong>：</p>
<ol>
<li>如果两个对象 <code>equals()</code> 返回 <code>true</code>，那么它们的 <code>hashCode()</code> 必须相等。</li>
<li>如果 <code>equals()</code> 返回 <code>false</code>，<code>hashCode()</code> 可以相等也可以不同（哈希冲突允许）。</li>
<li><code>hashCode()</code> 在一次应用运行中应该保持稳定（对象没有修改时）。</li>
</ol>
</li>
<li><p><strong>为什么必须重写 hashCode？</strong></p>
<ul>
<li>Hash 系数据结构（<code>HashMap</code>&#x2F;<code>HashSet</code>）使用 <code>hashCode()</code> 先定位桶，再用 <code>equals()</code> 检查具体相等性。若只重写 <code>equals()</code> 而不重写 <code>hashCode()</code>，两个逻辑相等对象可能具有不同哈希，导致放入 HashSet 后无法找到或产生重复键。</li>
</ul>
</li>
<li><p><strong>实现建议</strong>：用不可变字段计算 hash，常用 <code>Objects.hash(...)</code> 或 IDE 生成；避免使用容易改变的字段（会导致键失效）。</p>
</li>
<li><p><strong>示例坑</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123; ... &#125; <span class="comment">// 基于 name、age</span></span><br><span class="line">  <span class="comment">// 忘了重写 hashCode -&gt; 在 HashSet/HashMap 中会出现问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>面试点</strong>：Mutable key 的危害（例如使用可变字段做 HashMap key，然后修改字段），如何设计正确的 hashCode（均匀分布、避免碰撞）。</p>
<hr>
<h3 id="8-包装类的自动装箱-拆箱"><a href="#8-包装类的自动装箱-拆箱" class="headerlink" title="8 包装类的自动装箱&#x2F;拆箱"></a>8 包装类的自动装箱&#x2F;拆箱</h3><ul>
<li><strong>装箱（boxing）</strong>：基本类型 → 对应包装类（编译器插入 <code>Integer.valueOf(int)</code> 等）。</li>
<li><strong>拆箱（unboxing）</strong>：包装类 → 基本类型（编译器插入 <code>intValue()</code> 等）。</li>
<li><strong>缓存</strong>：<code>Integer.valueOf</code> 缓存 <code>-128 ~ 127</code>，<code>Boolean.valueOf</code> 缓存 <code>true/false</code>。<code>Long</code> 也缓存某些小值；其他包装类行为取决实现。</li>
<li><strong>风险</strong>：<ul>
<li><code>NullPointerException</code>：<code>Integer a = null; int b = a; // NPE</code>。</li>
<li>性能损失：频繁装拆箱会产生对象分配和 GC 压力。</li>
<li><code>==</code> 在装箱时比较的是引用（可能受缓存影响）。</li>
</ul>
</li>
<li><strong>编译例子</strong>：<code>Integer a = 10; int b = a + 5;</code> → 编译器生成 <code>int b = a.intValue() + 5;</code>。</li>
</ul>
<p><strong>面试点</strong>：注意 NPE、缓存范围、避免在性能敏感路径频繁装拆箱（比如大循环中），使用原始类型或专用库（Trove、fastutil）在高性能场景下替代。</p>
<hr>
<h3 id="9-重载（Overload）-vs-重写（Override）"><a href="#9-重载（Overload）-vs-重写（Override）" class="headerlink" title="9 重载（Overload） vs 重写（Override）"></a>9 重载（Overload） vs 重写（Override）</h3><ul>
<li><strong>重载（同一类或子类中）</strong>：<ul>
<li>同名方法，参数列表不同（参数数&#x2F;类型&#x2F;顺序），返回类型可不同（但仅返回类型不同不能构成重载）。</li>
<li>解析在<strong>编译时</strong>（静态绑定），基于编译时类型与参数类型选择。</li>
</ul>
</li>
<li><strong>重写（子类对父类方法）</strong>：<ul>
<li>方法签名完全一致（Java 8 后允许不同返回类型的协变返回），访问权限不可更严格，异常声明不能扔出新的更受检的异常。</li>
<li>调用是<strong>运行时绑定</strong>（多态）。</li>
</ul>
</li>
<li><strong>面试点</strong>：不能重写 static 方法（静态方法隐藏）；不能重写 final 方法；构造器不能重写只能重载；桥接方法（bridge methods）与泛型类型擦除下的兼容。</li>
</ul>
<hr>
<h3 id="10-Java-泛型"><a href="#10-Java-泛型" class="headerlink" title="10 Java 泛型"></a>10 Java 泛型</h3><ul>
<li><p><strong>目的</strong>：提供编译时类型检查和更安全的代码复用。</p>
</li>
<li><p><strong>实现机制</strong>：类型擦除（type erasure）——在编译时移除泛型信息，插入必要的类型转换和桥接方法以兼容旧字节码。</p>
</li>
<li><p><strong>限制</strong>：</p>
<ul>
<li>不能在运行时做 <code>instanceof</code> 某个具体泛型类型（只能 <code>instanceof List</code>）。</li>
<li>不能创建泛型数组（<code>new T[10]</code> 不允许）。</li>
<li>不能有泛型的静态成员直接使用类型参数（静态上下文没有类型参数信息）。</li>
<li>泛型异常（cannot create generic array of T）和不能抛出带泛型参数的受检异常。</li>
</ul>
</li>
<li><p><strong>通配符</strong>：</p>
<ul>
<li><code>&lt;? extends T&gt;</code>（生产者，只能读，PECS：Producer Extends）</li>
<li><code>&lt;? super T&gt;</code>（消费者，只能写，PECS：Consumer Super）</li>
</ul>
</li>
<li><p><strong>泛型方法与类型参数</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">pick</span><span class="params">(T a1, T a2)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原生类型和擦除向后兼容</strong>：旧代码兼容，新代码编译会插入 casts。</p>
</li>
<li><p><strong>面试点</strong>：PECS、类型擦除造成的桥接方法、泛型与反射（通过 <code>Type</code>, <code>ParameterizedType</code> 获取泛型信息在运行时只能从声明处读取）。</p>
</li>
<li><p>好的，这三个都是 Java 泛型的深入面试考点，我帮你梳理成<strong>清晰体系 + 面试答题模板</strong>，附带底层机制和典型陷阱。</p>
<hr>
<h2 id="1️⃣-PECS-原则（Producer-Extends-Consumer-Super）"><a href="#1️⃣-PECS-原则（Producer-Extends-Consumer-Super）" class="headerlink" title="1️⃣ PECS 原则（Producer Extends, Consumer Super）"></a>1️⃣ <strong>PECS 原则（Producer Extends, Consumer Super）</strong></h2><p><strong>概念</strong>：</p>
<ul>
<li><p>针对泛型的<strong>上限、下限使用场景</strong>，由 Effective Java 提出。</p>
</li>
<li><p><strong>公式</strong>：</p>
<blockquote>
<p><code>? extends T</code> → 生产者（读取），不能写<br> <code>? super T</code> → 消费者（写入），可以写</p>
</blockquote>
</li>
<li><p>英文记忆：<strong>PECS &#x3D; Producer Extends, Consumer Super</strong></p>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="type">Number</span> <span class="variable">n</span> <span class="operator">=</span> nums.get(<span class="number">0</span>); <span class="comment">// ✅ 可以读取</span></span><br><span class="line">nums.add(<span class="number">1</span>); <span class="comment">// ❌ 编译错误，类型未知</span></span><br><span class="line"></span><br><span class="line">List&lt;? <span class="built_in">super</span> Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">list.add(<span class="number">1</span>); <span class="comment">// ✅ 可以写</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// ✅ 只能当 Object 读</span></span><br></pre></td></tr></table></figure>

<h3 id="面试追问："><a href="#面试追问：" class="headerlink" title="面试追问："></a>面试追问：</h3><ul>
<li>为什么 <code>? extends</code> 不允许写入？<ul>
<li>因为具体类型可能是 <code>Integer</code>、<code>Double</code> 等，写入不安全。</li>
</ul>
</li>
<li>为什么 <code>? super</code> 可以写入？<ul>
<li>至少可以保证写入对象是其父类类型兼容。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2️⃣-类型擦除与桥接方法（Bridge-Method）"><a href="#2️⃣-类型擦除与桥接方法（Bridge-Method）" class="headerlink" title="2️⃣ 类型擦除与桥接方法（Bridge Method）"></a>2️⃣ <strong>类型擦除与桥接方法（Bridge Method）</strong></h2><h3 id="2-1-类型擦除"><a href="#2-1-类型擦除" class="headerlink" title="2.1 类型擦除"></a>2.1 <strong>类型擦除</strong></h3><ul>
<li>Java 泛型在编译期会被 <strong>类型擦除</strong> → 编译后字节码不保留泛型信息（JVM 层面不支持泛型）。</li>
<li><strong>例子</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译后：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译器保证类型安全 → 泛型约束只在<strong>编译期</strong>检查。</li>
</ul>
<hr>
<h3 id="2-2-桥接方法（Bridge-Method）"><a href="#2-2-桥接方法（Bridge-Method）" class="headerlink" title="2.2 桥接方法（Bridge Method）"></a>2.2 <strong>桥接方法（Bridge Method）</strong></h3><ul>
<li>当子类继承泛型父类或实现泛型接口时，类型擦除可能导致 <strong>方法签名不同</strong> → 编译器生成“桥接方法”保证多态。</li>
<li><strong>例子</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;child&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译后，JVM 方法签名：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;child&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> get(); &#125; <span class="comment">// 桥接方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>桥接方法保证调用 <code>Parent</code> 的引用时多态正常。</li>
</ul>
<h3 id="面试追问：-1"><a href="#面试追问：-1" class="headerlink" title="面试追问："></a>面试追问：</h3><ul>
<li>Q: 为什么要生成桥接方法？<ul>
<li>A: 类型擦除后子类方法签名与父类不同，桥接方法保持编译期类型安全 + 运行时多态。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3️⃣-泛型与反射"><a href="#3️⃣-泛型与反射" class="headerlink" title="3️⃣ 泛型与反射"></a>3️⃣ <strong>泛型与反射</strong></h2><h3 id="3-1-普通反射获取泛型"><a href="#3-1-普通反射获取泛型" class="headerlink" title="3.1 普通反射获取泛型"></a>3.1 <strong>普通反射获取泛型</strong></h3><ul>
<li>泛型类型在运行时被擦除，只能获取 <strong>声明处信息</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    T value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Box.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">System.out.println(f.getType()); <span class="comment">// class java.lang.Object</span></span><br></pre></td></tr></table></figure>

<ul>
<li>只能看到 <code>Object</code>，实际 <code>T</code> 已被擦除。</li>
</ul>
<hr>
<h3 id="3-2-ParameterizedType-获取泛型信息"><a href="#3-2-ParameterizedType-获取泛型信息" class="headerlink" title="3.2 ParameterizedType 获取泛型信息"></a>3.2 <strong>ParameterizedType 获取泛型信息</strong></h3><ul>
<li>对方法、字段或类声明的泛型可以通过 <code>Type</code>&#x2F;<code>ParameterizedType</code> 获取：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringBox</span> <span class="keyword">extends</span> <span class="title class_">Box</span>&lt;String&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Type</span> <span class="variable">superType</span> <span class="operator">=</span> StringBox.class.getGenericSuperclass();</span><br><span class="line"><span class="keyword">if</span>(superType <span class="keyword">instanceof</span> ParameterizedType pt) &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">actualType</span> <span class="operator">=</span> pt.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    System.out.println(actualType); <span class="comment">// class java.lang.String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：只能获取<strong>继承&#x2F;声明处的泛型</strong>，运行时对象类型信息丢失：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;String&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line"><span class="type">Type</span> <span class="variable">t</span> <span class="operator">=</span> box.getClass().getGenericSuperclass(); <span class="comment">// 还是 Box&lt;T&gt;，T 无法知道</span></span><br></pre></td></tr></table></figure>

<h3 id="面试追问：-2"><a href="#面试追问：-2" class="headerlink" title="面试追问："></a>面试追问：</h3><ul>
<li>Q: 为什么 <code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在 JVM 层面是一样的？<ul>
<li>A: 泛型擦除，运行时都是 <code>List</code>，类型信息只在编译期存在。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4️⃣-面试答题模板"><a href="#4️⃣-面试答题模板" class="headerlink" title="4️⃣ 面试答题模板"></a>4️⃣ <strong>面试答题模板</strong></h2><ol>
<li><strong>PECS 原则</strong>：<ul>
<li><code>? extends T</code> → 生产者，读取安全，写入不安全</li>
<li><code>? super T</code> → 消费者，可写入，读取只能当 Object</li>
</ul>
</li>
<li><strong>类型擦除</strong>：<ul>
<li>泛型信息在编译期检查，运行期擦除成原始类型。</li>
<li>编译器通过<strong>桥接方法</strong>保持多态和类型安全</li>
</ul>
</li>
<li><strong>反射获取泛型</strong>：<ul>
<li>只能读取 <strong>声明处类型</strong></li>
<li><code>Type</code> &#x2F; <code>ParameterizedType</code> → 获取具体泛型类型</li>
<li>运行期对象泛型类型丢失</li>
</ul>
</li>
</ol>
<hr>
<p>💡 <strong>小技巧面试答法</strong>：</p>
<ul>
<li>提到桥接方法和类型擦除时，可以画一条箭头：<br> <code>Parent&lt;T&gt;</code> → <code>Child extends Parent&lt;String&gt;</code> → 编译器生成桥接方法 → JVM 方法签名多态保持一致</li>
</ul>
<hr>
</li>
</ul>
<hr>
<h3 id="11-反射"><a href="#11-反射" class="headerlink" title="11 反射"></a>11 反射</h3><ul>
<li><p><strong>作用</strong>：在运行时加载类、查看结构（字段&#x2F;方法&#x2F;构造器）、动态调用方法&#x2F;访问字段、创建对象。</p>
</li>
<li><p><strong>核心 API</strong>：<code>Class&lt;?&gt;</code>、<code>Field</code>、<code>Method</code>、<code>Constructor</code>、<code>Annotation</code>。</p>
</li>
<li><p><strong>常见用法</strong>：框架（Spring&#x2F;ORMs）、测试工具、序列化库、动态代理。</p>
</li>
<li><p><strong>性能与安全</strong>：</p>
<ul>
<li>反射调用速度比直接调用慢很多（因为涉及安全检查、解析），可以通过 <code>setAccessible(true)</code> 跳过访问检查来提高性能（但 Java 9 的模块化和安全策略会限制）。</li>
<li>替代方案：<code>MethodHandle</code> &#x2F; <code>invokeWithArguments</code>（更快），或者生成字节码（ASM）&#x2F;动态代理。</li>
</ul>
</li>
<li><p><strong>访问私有成员</strong>：<code>field.setAccessible(true)</code>（受 Java 模块化与安全管理器影响）。</p>
</li>
<li><p><strong>面试点</strong>：反射的用途与成本、如何用反射实现依赖注入、<code>Class.forName()</code> 与类加载器、类加载器三层结构与资源隔离。</p>
</li>
<li><p>好的，这几个都是 Java 核心反射和类加载面试点，我给你整理成<strong>深入剖析 + 面试答题模板</strong>，涵盖用途、成本、实现原理、类加载器机制和资源隔离。</p>
<hr>
<h2 id="1️⃣-反射的用途"><a href="#1️⃣-反射的用途" class="headerlink" title="1️⃣ 反射的用途"></a>1️⃣ <strong>反射的用途</strong></h2><p>反射是 Java 动态获取类&#x2F;对象信息、动态调用方法的机制。常用用途：</p>
<ol>
<li><strong>动态创建对象</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.User&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>动态获取&#x2F;修改属性</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">f.set(obj, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) f.get(obj);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>动态调用方法</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line">m.invoke(obj, <span class="string">&quot;Tom&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>实现依赖注入（DI）和 IoC</strong></li>
</ol>
<ul>
<li>框架在运行时扫描类，自动实例化对象、注入依赖（Spring、Guice 原理）。</li>
<li><strong>思路</strong>：<ol>
<li>扫描类路径，找到带注解的类。</li>
<li>通过 <code>Class.newInstance()</code> 或 <code>getDeclaredConstructor().newInstance()</code> 创建实例。</li>
<li>使用 <code>Field.set()</code> 注入依赖对象。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository repo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Spring 实现：<ul>
<li>利用 <code>ReflectionUtils</code> 设置私有字段可访问</li>
<li>注入 bean，实现松耦合</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2️⃣-反射的成本"><a href="#2️⃣-反射的成本" class="headerlink" title="2️⃣ 反射的成本"></a>2️⃣ <strong>反射的成本</strong></h2><ol>
<li><strong>性能开销</strong><ul>
<li>方法调用绕过静态类型检查 → JVM 无法内联优化 → 相比普通方法慢 10~20 倍</li>
<li>访问私有成员需要 <code>setAccessible(true)</code> → 打破 JIT 优化</li>
</ul>
</li>
<li><strong>安全问题</strong><ul>
<li>可访问私有字段和方法 → 可能破坏封装</li>
<li>需要 <code>SecurityManager</code> 或模块系统权限限制</li>
</ul>
</li>
<li><strong>可维护性</strong><ul>
<li>编译期无法检查成员存在 → 容易出错</li>
<li>不利于重构</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：反射强大但开销大、可读性差，一般用于框架层、工具类或动态代理，不适合业务频繁调用。</p>
<hr>
<h2 id="3️⃣-Class-forName-与类加载器"><a href="#3️⃣-Class-forName-与类加载器" class="headerlink" title="3️⃣ Class.forName() 与类加载器"></a>3️⃣ <strong>Class.forName() 与类加载器</strong></h2><ol>
<li><p><strong><code>Class.forName(String className)</code></strong></p>
<ul>
<li><p><strong>作用</strong>：加载指定类，执行静态初始化块（类初始化阶段）</p>
</li>
<li><p>常用在 JDBC：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对比：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;MyClass&gt; clazz = MyClass.class; <span class="comment">// 不触发初始化</span></span><br><span class="line">Class.forName(<span class="string">&quot;MyClass&quot;</span>); <span class="comment">// 会初始化类</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>类加载器</strong></p>
</li>
</ol>
<ul>
<li><strong>ClassLoader</strong>：负责加载 <code>.class</code> 字节码 → JVM 在内存生成 <code>Class</code> 对象</li>
<li><strong>核心方法</strong>：<ul>
<li><code>loadClass()</code> → 只加载，不初始化</li>
<li><code>defineClass()</code> → 将字节码转换成 Class 对象</li>
<li>初始化阶段触发静态块</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4️⃣-类加载器三层结构与资源隔离"><a href="#4️⃣-类加载器三层结构与资源隔离" class="headerlink" title="4️⃣ 类加载器三层结构与资源隔离"></a>4️⃣ <strong>类加载器三层结构与资源隔离</strong></h2><p>Java 类加载器采用 <strong>父委托模型（Parent Delegation Model）</strong>，常见三层：</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>典型实现</th>
<th>加载范围</th>
<th>面试要点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bootstrap（启动类加载器）</strong></td>
<td>JVM 内置</td>
<td><code>java.*</code></td>
<td>加载核心类库，无法直接获取对象</td>
</tr>
<tr>
<td><strong>Extension（扩展类加载器 &#x2F; Platform）</strong></td>
<td><code>sun.misc.Launcher$ExtClassLoader</code></td>
<td><code>jre/lib/ext</code></td>
<td>加载扩展类库</td>
</tr>
<tr>
<td><strong>Application（系统类加载器 &#x2F; AppClassLoader）</strong></td>
<td>默认</td>
<td>classpath 下应用类</td>
<td>加载业务代码和第三方依赖</td>
</tr>
</tbody></table>
<ul>
<li><strong>父委托原则</strong>：<ul>
<li>子加载器先委托父加载器</li>
<li>避免类被重复加载，保证核心类安全性</li>
</ul>
</li>
<li><strong>资源隔离</strong>：<ul>
<li>不同类加载器加载同名类是不同 <code>Class</code> 对象（内存隔离）</li>
<li>典型应用：Web 容器（Tomcat）每个 webapp 一个类加载器 → 防止类冲突和资源泄漏</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5️⃣-面试追问"><a href="#5️⃣-面试追问" class="headerlink" title="5️⃣ 面试追问"></a>5️⃣ <strong>面试追问</strong></h2><ol>
<li><strong>反射能调用 private 方法吗？</strong><ul>
<li>✅ 可以，使用 <code>setAccessible(true)</code>，破坏封装，但有安全风险。</li>
</ul>
</li>
<li><strong>为什么 Class.forName() 要抛 ClassNotFoundException？</strong><ul>
<li>因为指定的类可能不存在，加载失败时必须捕获异常。</li>
</ul>
</li>
<li><strong>为什么不同类加载器加载同名类是不同类型？</strong><ul>
<li>JVM 内存中 <code>Class</code> 对象由 <strong>类加载器 + 类全限定名</strong> 唯一确定 → 同名不同加载器，视为不同类。</li>
</ul>
</li>
<li><strong>反射创建对象和直接 new 的性能差异？</strong><ul>
<li>反射慢 10~20 倍，主要因为动态解析、绕过 JIT 优化。</li>
</ul>
</li>
</ol>
<hr>
<p>✅ <strong>快速答题模板（面试版）</strong>：</p>
<ul>
<li><strong>反射用途</strong>：动态创建对象、获取&#x2F;修改属性、调用方法 → 框架 DI&#x2F;IoC 核心</li>
<li><strong>反射成本</strong>：性能慢、破坏封装、安全风险、可维护性低</li>
<li><strong>依赖注入</strong>：扫描类 + newInstance() + Field.set()</li>
<li><strong>Class.forName()</strong>：加载类并初始化</li>
<li><strong>类加载器三层</strong>：<ul>
<li>Bootstrap → 核心类</li>
<li>Extension → 扩展类</li>
<li>App → 应用类</li>
</ul>
</li>
<li><strong>父委托 + 资源隔离</strong>：<ul>
<li>避免类重复加载，Web 容器隔离每个应用，防止冲突</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1️⃣-双亲委派（Parent-Delegation-Model）"><a href="#1️⃣-双亲委派（Parent-Delegation-Model）" class="headerlink" title="1️⃣ 双亲委派（Parent Delegation Model）"></a>1️⃣ 双亲委派（Parent Delegation Model）</h2><p><strong>核心思想</strong>：</p>
<ul>
<li><strong>类加载请求先交给父类加载器</strong>，父加载器无法加载时才由子加载器自己加载。</li>
<li>保证核心类由 <strong>Bootstrap ClassLoader</strong> 加载，避免重复加载或安全问题。</li>
</ul>
<h3 id="加载流程："><a href="#加载流程：" class="headerlink" title="加载流程："></a>加载流程：</h3><ol>
<li>子加载器收到加载请求（比如 AppClassLoader）</li>
<li>委托给父加载器（ExtClassLoader）</li>
<li>父加载器继续委托给更上层（Bootstrap）</li>
<li>Bootstrap 能加载 → 返回 Class 对象</li>
<li>父加载器无法加载 → 子加载器自己加载</li>
</ol>
<p><strong>特点</strong>：</p>
<ul>
<li>防止核心类被篡改（例如 <code>java.lang.String</code> 永远由 Bootstrap 加载）</li>
<li>保证每个类在 JVM 中唯一（Class+ClassLoader 唯一标识）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="12-线程安全的集合与使用"><a href="#12-线程安全的集合与使用" class="headerlink" title="12 线程安全的集合与使用"></a>12 线程安全的集合与使用</h3><ul>
<li><strong>同步封装</strong>（JDK Collections 工厂）：<ul>
<li><code>Collections.synchronizedList/Map/Set(...)</code>：把单个操作同步化（方法级锁）。<strong>注意</strong>：复合操作（check-then-act）仍需外部同步。</li>
</ul>
</li>
<li><strong>并发集合（java.util.concurrent）</strong>：<ul>
<li><code>ConcurrentHashMap</code>：高并发哈希表（JDK8 以 CAS + synchronized on bin 为主）。<code>putIfAbsent</code>, <code>remove(key, val)</code>, <code>replace</code> 等原子操作。迭代弱一致（weakly consistent），不会抛 ConcurrentModificationException。</li>
<li><code>CopyOnWriteArrayList/CopyOnWriteArraySet</code>：写时复制，读多写少场景优秀（读无需锁，写创建新数组）。</li>
<li><code>BlockingQueue</code>（见第 22 题）用于生产者-消费者。</li>
<li><code>ConcurrentLinkedQueue</code>（无界非阻塞队列），基于 CAS 的链表。</li>
</ul>
</li>
<li><strong>如何使用</strong>：<ul>
<li><code>ConcurrentHashMap</code> 适合频繁并发读写：使用 <code>computeIfAbsent</code> 避免 check-then-put race。</li>
<li>对于复杂事务性操作，使用外部锁或事务机制；不要依赖单个集合的同步保证跨多个集合的一致性。</li>
</ul>
</li>
</ul>
<p><strong>面试点</strong>：为什么 <code>Collections.synchronizedMap</code> 不能完全替代 <code>ConcurrentHashMap</code>（并发粒度和性能差别）；CopyOnWrite 的开销与适用场景。</p>
<hr>
<h3 id="13-HashMap-底层原理与扩容机制"><a href="#13-HashMap-底层原理与扩容机制" class="headerlink" title="13 HashMap 底层原理与扩容机制"></a>13 HashMap 底层原理与扩容机制</h3><ul>
<li><strong>主要数据结构</strong>：数组（<code>Node&lt;K,V&gt;[] table</code>） + 单向链表（发生哈希冲突时） + 当单条链表长度超过阈值时转为红黑树（<code>TreeNode</code>）。</li>
<li><strong>重要常量</strong>（JDK8）：<ul>
<li><code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（16）</li>
<li><code>MAXIMUM_CAPACITY = 1 &lt;&lt; 30</code></li>
<li><code>TREEIFY_THRESHOLD = 8</code>（链表长度超过 8 时考虑树化）</li>
<li><code>UNTREEIFY_THRESHOLD = 6</code>（树退回链表阈值）</li>
<li><code>MIN_TREEIFY_CAPACITY = 64</code>（只有当 table 长度 &gt;&#x3D; 64 时才树化，否则先扩容）</li>
<li><code>DEFAULT_LOAD_FACTOR = 0.75f</code>（负载因子）</li>
</ul>
</li>
<li><strong>hash 计算</strong>：<ul>
<li><code>static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;</code></li>
<li>通过高位与低位混合（扰动）减小冲突（高位影响到低位）。</li>
</ul>
</li>
<li><strong>索引计算</strong>：<code>index = (n - 1) &amp; hash</code>（利用容量为2的幂使位运算快速定位）。</li>
<li><strong>put 操作流程</strong>：<ol>
<li>若 table 为 null，先初始化（默认容量 16）。</li>
<li>计算 hash、定位 bucket。</li>
<li>若 bucket 为空，直接插入（用 CAS 在并发场景未锁定时也能操作）。</li>
<li>若不为空，遍历链表或树：若发现 key 相等，覆盖 value；否则追加到链表尾或在树中插入。</li>
<li>若链表长度超过 TREEIFY_THRESHOLD 并且 table 长度 &gt;&#x3D; MIN_TREEIFY_CAPACITY，则树化；否则触发 resize。</li>
<li>每次插入后检查 <code>size &gt; threshold</code>（threshold &#x3D; capacity * loadFactor），超出则触发扩容。</li>
</ol>
</li>
<li><strong>扩容（resize）</strong>：<ul>
<li>扩容为 2 倍（<code>newCap = oldCap &lt;&lt; 1</code>），计算新阈值 <code>newThr = oldThr &lt;&lt; 1</code>。</li>
<li>JDK8 中 resize 会把旧链表拆分为两个链表（low 和 high），利用节点 hash 与 oldCap 的单个位判断新索引，避免完全重新计算哈希。</li>
<li>扩容成本高（rehash），会导致短暂性能抖动；并发扩容会带来线程安全问题（HashMap 在并发写时可能造成链表成环导致 CPU 100% 等问题，故 HashMap <strong>不是线程安全</strong> 的）。</li>
</ul>
</li>
<li><strong>get 操作复杂度</strong>：平均 O(1)，最坏在所有元素冲突为同一槽且未树化时 O(n)，JDK8 树化后降为 O(log n)。</li>
</ul>
<p><strong>面试点&#x2F;常考题</strong>：</p>
<ul>
<li><p>HashMap 的扩容触发条件与默认容量；为什么使用负载因子；为什么选择 0.75（时间&#x2F;空间折中）。</p>
</li>
<li><p>为何要树化，何时树化（避免 O(n) 退化）。</p>
</li>
<li><p>在并发写入下 HashMap 会出现什么问题（死循环&#x2F;链表环），以及解决方式（使用 ConcurrentHashMap 或外部同步）。</p>
</li>
<li><p>HashMap key 应该不可变，否则查找会出问题（例如 key 的 hashCode 依赖可变字段被修改后找不到）。</p>
</li>
<li><p>好的，这些都是 Java 集合框架高频面试点，我帮你梳理得<strong>深入、详细、面试可答版</strong>，包括 HashMap 底层原理、树化机制、并发问题和 key 不可变要求。</p>
<hr>
<h2 id="1️⃣-HashMap-扩容与负载因子"><a href="#1️⃣-HashMap-扩容与负载因子" class="headerlink" title="1️⃣ HashMap 扩容与负载因子"></a>1️⃣ <strong>HashMap 扩容与负载因子</strong></h2><h3 id="1-1-扩容触发条件"><a href="#1-1-扩容触发条件" class="headerlink" title="1.1 扩容触发条件"></a>1.1 扩容触发条件</h3><ul>
<li><p><strong>默认初始容量</strong>：16（2 的幂）</p>
</li>
<li><p><strong>默认负载因子</strong>：0.75</p>
</li>
<li><p><strong>触发条件</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当 size &gt; capacity * loadFactor 时，触发扩容</span><br></pre></td></tr></table></figure>

<ul>
<li>size：当前元素个数</li>
<li>capacity：当前 table 长度</li>
</ul>
</li>
<li><p>扩容通常 <strong>容量翻倍</strong>（2 倍）</p>
</li>
</ul>
<h3 id="1-2-为什么使用负载因子？"><a href="#1-2-为什么使用负载因子？" class="headerlink" title="1.2 为什么使用负载因子？"></a>1.2 为什么使用负载因子？</h3><ul>
<li>控制 HashMap <strong>空间利用率与查找性能的折中</strong>。</li>
<li><strong>负载因子过小</strong>：<ul>
<li>table 空间浪费严重</li>
<li>扩容频繁 → 性能开销大</li>
</ul>
</li>
<li><strong>负载因子过大</strong>：<ul>
<li>链表长度增加 → 查找效率降低</li>
</ul>
</li>
<li><strong>0.75 的理由</strong>：<ul>
<li>Java 官方选择 0.75 作为折中点</li>
<li>平均查找 O(1)，空间利用率较高</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2️⃣-为什么要树化（红黑树）"><a href="#2️⃣-为什么要树化（红黑树）" class="headerlink" title="2️⃣ 为什么要树化（红黑树）"></a>2️⃣ <strong>为什么要树化（红黑树）</strong></h2><h3 id="2-1-问题背景"><a href="#2-1-问题背景" class="headerlink" title="2.1 问题背景"></a>2.1 问题背景</h3><ul>
<li>JDK8 前 HashMap 使用链表存储哈希冲突</li>
<li>当哈希碰撞严重，链表长度达到 O(n)，查找退化成 O(n)</li>
</ul>
<h3 id="2-2-树化规则"><a href="#2-2-树化规则" class="headerlink" title="2.2 树化规则"></a>2.2 树化规则</h3><ul>
<li>当链表长度 &gt; <strong>TREEIFY_THRESHOLD &#x3D; 8</strong> 且数组长度 &gt;&#x3D; <strong>MIN_TREEIFY_CAPACITY &#x3D; 64</strong></li>
<li>链表会转为 <strong>红黑树</strong></li>
<li>查找、插入、删除 → O(log n)</li>
</ul>
<h3 id="2-3-面试追问"><a href="#2-3-面试追问" class="headerlink" title="2.3 面试追问"></a>2.3 面试追问</h3><ul>
<li>为什么加数组长度限制（MIN_TREEIFY_CAPACITY）？<ul>
<li>小数组直接扩容比树化更划算</li>
</ul>
</li>
<li>为什么红黑树而不是 AVL 树？<ul>
<li>红黑树插入删除调整成本低，适合哈希表冲突场景</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3️⃣-HashMap-并发写入问题"><a href="#3️⃣-HashMap-并发写入问题" class="headerlink" title="3️⃣ HashMap 并发写入问题"></a>3️⃣ <strong>HashMap 并发写入问题</strong></h2><h3 id="3-1-并发问题表现"><a href="#3-1-并发问题表现" class="headerlink" title="3.1 并发问题表现"></a>3.1 并发问题表现</h3><ul>
<li>JDK8 前：<ul>
<li>多线程 put 时链表可能形成环 → <code>get()</code> 死循环</li>
</ul>
</li>
<li>JDK8+：<ul>
<li>仍不保证线程安全 → 写入可能丢失或覆盖</li>
</ul>
</li>
</ul>
<h3 id="3-2-解决方式"><a href="#3-2-解决方式" class="headerlink" title="3.2 解决方式"></a>3.2 解决方式</h3><ol>
<li><p><strong>使用 ConcurrentHashMap</strong> → 分段锁（JDK7）或 CAS + synchronized（JDK8+），线程安全</p>
</li>
<li><p><strong>外部同步</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;K,V&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>禁止在多线程下直接操作 HashMap</strong></p>
</li>
</ol>
<hr>
<h2 id="4️⃣-HashMap-key-应该不可变"><a href="#4️⃣-HashMap-key-应该不可变" class="headerlink" title="4️⃣ HashMap key 应该不可变"></a>4️⃣ <strong>HashMap key 应该不可变</strong></h2><h3 id="4-1-原因"><a href="#4-1-原因" class="headerlink" title="4.1 原因"></a>4.1 原因</h3><ul>
<li><p>key 的 hashCode 和 equals 必须稳定</p>
</li>
<li><p>如果 key 可变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">map.put(p, <span class="string">&quot;data&quot;</span>);</span><br><span class="line">p.setName(<span class="string">&quot;Jerry&quot;</span>); <span class="comment">// hashCode 改变</span></span><br><span class="line">map.get(p); <span class="comment">// 返回 null，找不到原 key</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap 查找依赖 <strong>hashCode → bucket → equals</strong></p>
</li>
</ul>
<h3 id="4-2-面试追问"><a href="#4-2-面试追问" class="headerlink" title="4.2 面试追问"></a>4.2 面试追问</h3><ul>
<li>可变 key 可以做什么防护？<ul>
<li>不允许修改关键字段</li>
<li>使用不可变类（String、Integer、UUID）</li>
<li>或重新 put&#x2F;update map</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5️⃣-面试快速答题模板"><a href="#5️⃣-面试快速答题模板" class="headerlink" title="5️⃣ 面试快速答题模板"></a>5️⃣ <strong>面试快速答题模板</strong></h2><ol>
<li><strong>扩容</strong><ul>
<li>默认容量 16，负载因子 0.75 → 触发扩容</li>
<li>0.75 是时间&#x2F;空间折中</li>
</ul>
</li>
<li><strong>树化</strong><ul>
<li>链表长度 &gt; 8 且容量 &gt;&#x3D; 64 → 红黑树</li>
<li>提高查找性能，避免 O(n)</li>
</ul>
</li>
<li><strong>并发写入</strong><ul>
<li>多线程 HashMap 可能死循环&#x2F;数据丢失</li>
<li>解决：ConcurrentHashMap 或外部同步</li>
</ul>
</li>
<li><strong>key 不可变</strong><ul>
<li>hashCode&#x2F;equals 稳定 → 确保 put&#x2F;get 正确</li>
</ul>
</li>
</ol>
<hr>
<p>💡 <strong>补充底层知识点</strong></p>
<ul>
<li><p><strong>扩容时 rehash</strong>：每个元素都需要重新计算桶索引</p>
</li>
<li><p><strong>hash 再扰动</strong>：</p>
<ul>
<li><p>为了减少高位相同导致冲突，JDK8 对 hash 做扰动处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>链表转树条件</strong>：</p>
<ul>
<li>链表太长 → 树化</li>
<li>树节点太少 → 链表化（UNTREEIFY_THRESHOLD &#x3D; 6）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="14-ConcurrentHashMap-的线程安全实现（深入，JDK7-vs-JDK8）"><a href="#14-ConcurrentHashMap-的线程安全实现（深入，JDK7-vs-JDK8）" class="headerlink" title="14 ConcurrentHashMap 的线程安全实现（深入，JDK7 vs JDK8）"></a>14 ConcurrentHashMap 的线程安全实现（深入，JDK7 vs JDK8）</h3><ul>
<li><strong>JDK7（老的实现）</strong>：<ul>
<li>基于分段锁（<code>Segment[] segments</code>），每个 Segment 维护一把锁，锁的粒度为 segment（可并行度 &#x3D; segment 数）；操作在单个 segment 内并发安全。</li>
</ul>
</li>
<li><strong>JDK8（重构后的实现）</strong>：<ul>
<li><strong>去掉 Segment</strong>，使用与 HashMap 类似的 <code>Node&lt;K,V&gt;[] table</code>。</li>
<li><strong>无全表锁</strong>：采用多种优化——CAS 创建节点&#x2F;置入、synchronized 仅在单个 bin 上（链表或 tree bin 上）用于插入&#x2F;修改，读取操作不加锁（volatile 可见）。</li>
<li><strong>关键概念</strong>：<ul>
<li><code>table</code> 是 volatile，节点 <code>next</code>、<code>value</code> 等字段使用 volatile&#x2F;CAS，以保证可见性和原子性。</li>
<li><code>put</code>：先 CAS 尝试把新 node 放到空桶；若失败或桶非空，采用 synchronized(binHead) 来完成插入（以避免竞争）。</li>
<li><code>putIfAbsent</code>、<code>computeIfAbsent</code> 等使用 CAS + 锁配合来保证原子性。</li>
<li><strong>树化</strong>：当单个 bucket 链表长度过大时，会转为树（与 HashMap 类似）。</li>
<li><strong>扩容</strong>：采用多线程协助搬迁（transfer），<code>sizeCtl</code> 字段控制迁移状态，多个线程可以参与一次扩容以提升效率。</li>
</ul>
</li>
<li><strong>读取</strong>：<code>get</code> 通常是无锁的，遍历链表或 tree bin，用 volatile 读取确保可见。</li>
</ul>
</li>
<li><strong>弱一致性迭代</strong>：迭代器不会抛出 <code>ConcurrentModificationException</code>，返回的是“弱一致”视图（可能看不到一些并发修改，也可能看到）。</li>
<li><strong>性能</strong>：JDK8 的实现综合使用 CAS 和局部锁，读性能非常好，写性能也较 JDK7 改进。</li>
</ul>
<p><strong>面试点</strong>：ConcurrentHashMap 为什么不需要全局锁，get 为什么不加锁安全，为什么 remove&#x2F;size 等操作不是常 O(1) 精确（需要并发统计）。</p>
<hr>
<h4 id="1️⃣-为什么-ConcurrentHashMap-不需要全局锁？"><a href="#1️⃣-为什么-ConcurrentHashMap-不需要全局锁？" class="headerlink" title="1️⃣ 为什么 ConcurrentHashMap 不需要全局锁？"></a>1️⃣ <strong>为什么 ConcurrentHashMap 不需要全局锁？</strong></h4><h5 id="1-1-JDK-7-vs-JDK-8"><a href="#1-1-JDK-7-vs-JDK-8" class="headerlink" title="1.1 JDK 7 vs JDK 8"></a>1.1 JDK 7 vs JDK 8</h5><table>
<thead>
<tr>
<th>版本</th>
<th>锁机制</th>
</tr>
</thead>
<tbody><tr>
<td>JDK 7</td>
<td>分段锁（Segment + ReentrantLock）</td>
</tr>
<tr>
<td>JDK 8+</td>
<td>Node + CAS + synchronized（链表&#x2F;红黑树节点）</td>
</tr>
</tbody></table>
<h5 id="1-2-核心思想"><a href="#1-2-核心思想" class="headerlink" title="1.2 核心思想"></a>1.2 核心思想</h5><ul>
<li><strong>细粒度锁</strong>，只锁某个桶（bucket）或链表节点，而不是整个表</li>
<li><strong>CAS（Compare-And-Swap）+ synchronized</strong>：大部分操作通过 CAS 保证原子更新，链表&#x2F;树节点操作用局部锁</li>
<li><strong>结果</strong>：并发写入多个桶时不会互相阻塞 → 高吞吐量</li>
</ul>
<hr>
<h4 id="2️⃣-为什么-get-不加锁也安全？"><a href="#2️⃣-为什么-get-不加锁也安全？" class="headerlink" title="2️⃣ 为什么 get 不加锁也安全？"></a>2️⃣ <strong>为什么 get 不加锁也安全？</strong></h4><h5 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h5><ul>
<li><strong>volatile + final 保证可见性</strong><ul>
<li>HashMap table、Node.value 都是 volatile 或 final → 线程读取总能看到最新对象</li>
</ul>
</li>
<li><strong>读取操作不修改结构</strong><ul>
<li><code>get()</code> 只是按 hash 找到 bucket，再遍历链表&#x2F;红黑树读取 value → 不改变链表结构</li>
</ul>
</li>
<li><strong>JMM 保证可见性</strong><ul>
<li>写入操作（put&#x2F;resize）保证 happens-before → get 读取安全</li>
</ul>
</li>
</ul>
<h5 id="2-2-面试要点"><a href="#2-2-面试要点" class="headerlink" title="2.2 面试要点"></a>2.2 面试要点</h5><ul>
<li>get 不加锁 → 高性能，线程安全</li>
<li>注意：<ul>
<li>遍历过程中，写入可能正在进行 → 可能 get 不到最新数据，但不会抛异常</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3️⃣-remove-size-等操作为什么不是-O-1-精确？"><a href="#3️⃣-remove-size-等操作为什么不是-O-1-精确？" class="headerlink" title="3️⃣ remove&#x2F;size 等操作为什么不是 O(1) 精确？"></a>3️⃣ <strong>remove&#x2F;size 等操作为什么不是 O(1) 精确？</strong></h4><h5 id="3-1-remove"><a href="#3-1-remove" class="headerlink" title="3.1 remove"></a>3.1 remove</h5><ul>
<li>remove 需要找到对应桶，再修改链表&#x2F;树节点</li>
<li>对每个桶局部加锁，不同线程可能同时删除 → 最终结果仍正确</li>
<li>不是全局锁 → 并发 remove 与 put&#x2F;resize 会交错，复杂度取决于链表长度（O(n&#x2F;k)）</li>
</ul>
<h5 id="3-2-size"><a href="#3-2-size" class="headerlink" title="3.2 size()"></a>3.2 size()</h5><ul>
<li>ConcurrentHashMap <strong>不维护全局计数器</strong></li>
<li>各个桶独立统计 size → 获取精确值需要遍历所有桶并累加</li>
<li>在高并发情况下，size() 可能 <strong>瞬间不精确</strong><ul>
<li>避免频繁全局锁 → 提升性能</li>
</ul>
</li>
<li>如果需要精确 size，可以用 <code>mappingCount()</code> 或外部同步</li>
</ul>
<hr>
<h4 id="4️⃣-面试答题模板-1"><a href="#4️⃣-面试答题模板-1" class="headerlink" title="4️⃣ 面试答题模板"></a>4️⃣ <strong>面试答题模板</strong></h4><ol>
<li><strong>不需要全局锁</strong><ul>
<li>JDK8 使用 <strong>CAS + synchronized（局部桶锁）</strong></li>
<li>写操作只锁部分桶 → 高并发性能</li>
</ul>
</li>
<li><strong>get 不加锁安全</strong><ul>
<li>Node.value&#x2F;next 是 volatile&#x2F;final → 线程可见性</li>
<li>读取不修改结构 → 不会破坏链表&#x2F;树</li>
</ul>
</li>
<li><strong>remove&#x2F;size 非 O(1)</strong><ul>
<li>remove → 需要遍历桶 → 复杂度取决于链表长度</li>
<li>size → 各桶统计，不加全局锁 → 可能瞬间不精确</li>
</ul>
</li>
<li><strong>总结</strong><ul>
<li>高性能 → get 无锁</li>
<li>写入局部锁 → 避免全局阻塞</li>
<li>size&#x2F;remove 不保证严格 O(1) → 设计折中性能和精确性</li>
</ul>
</li>
</ol>
<hr>
<p>💡 <strong>补充知识点</strong></p>
<ul>
<li><strong>JDK8 table resize</strong>：使用 <code>ForwardingNode</code> + CAS，保证扩容期间并发安全</li>
<li><strong>红黑树&#x2F;链表转换</strong>：在并发环境下用 synchronized 保证线程安全</li>
<li><strong>volatile 语义</strong>：<ul>
<li>避免部分线程看到旧值</li>
<li>保证 Node 节点读写顺序</li>
</ul>
</li>
</ul>
<hr>
<h3 id="15-ArrayList-vs-LinkedList"><a href="#15-ArrayList-vs-LinkedList" class="headerlink" title="15 ArrayList vs LinkedList"></a>15 ArrayList vs LinkedList</h3><ul>
<li><strong>ArrayList</strong>：<ul>
<li>内部是动态数组（<code>Object[] elementData</code>）。</li>
<li>随机访问 <code>get(i)</code> 为 O(1)。</li>
<li>插入&#x2F;删除在尾部 amortized O(1)；在中间位置插入&#x2F;删除需要移动元素 O(n)。</li>
<li>扩容策略：默认初始为空数组（jdk8之后），第一次 add 会扩容到 10；后续扩容 <code>newCapacity = old + (old &gt;&gt; 1)</code>（约 1.5x）。</li>
<li>内存紧凑，良好缓存局部性（CPU cache 友好）。</li>
</ul>
</li>
<li><strong>LinkedList</strong>：<ul>
<li>基于双向链表（<code>Node</code> 包含 prev&#x2F;next&#x2F;item）。</li>
<li>随机访问 <code>get(i)</code> 为 O(n)（需要顺序遍历）。</li>
<li>在列表中间插入&#x2F;删除为 O(1)（仅修改邻接节点指针），前提是已定位到节点（定位本身 O(n)）。</li>
<li>内存占用高（每个节点多个指针对象），GC 压力更大。</li>
</ul>
</li>
<li><strong>选择准则</strong>：<ul>
<li>频繁随机访问 → <code>ArrayList</code>。</li>
<li>频繁在列表中间插入&#x2F;删除且遍历更多 → <code>LinkedList</code>（但在多数场景 <code>ArrayList</code> 仍优，因为插入删除远不如随机访问常见，而且复制成本在局部更低）。</li>
</ul>
</li>
</ul>
<p><strong>面试点</strong>：扩容开销、ensureCapacity、trimToSize、迭代时的 fail-fast（modCount）机制。</p>
<p>好的，这些都是 Java 集合（尤其是 <strong>ArrayList</strong>）的底层性能和安全特性面试点，我帮你整理成<strong>深入、面试可答版</strong>，包括扩容开销、容量管理和迭代机制。</p>
<hr>
<h2 id="1️⃣-扩容开销"><a href="#1️⃣-扩容开销" class="headerlink" title="1️⃣ 扩容开销"></a>1️⃣ <strong>扩容开销</strong></h2><h3 id="1-1-扩容触发条件-1"><a href="#1-1-扩容触发条件-1" class="headerlink" title="1.1 扩容触发条件"></a>1.1 扩容触发条件</h3><ul>
<li><p>ArrayList 内部用 <code>Object[] elementData</code> 存储元素</p>
</li>
<li><p><strong>触发条件</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size &gt;= elementData.length</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认容量：</p>
<ul>
<li><strong>初始容量</strong>：10（无参构造）</li>
<li>构造器可指定初始容量 <code>ArrayList(int initialCapacity)</code></li>
</ul>
</li>
</ul>
<h3 id="1-2-扩容机制"><a href="#1-2-扩容机制" class="headerlink" title="1.2 扩容机制"></a>1.2 扩容机制</h3><ul>
<li>扩容时通常 <strong>1.5 倍或 2 倍</strong>（JDK 8 ArrayList 为 1.5 倍）</li>
<li>扩容开销：<ol>
<li>新数组分配 → O(n)</li>
<li>旧数组元素复制 → O(n)</li>
</ol>
</li>
<li>面试追问：<ul>
<li>批量插入大量元素时最好指定初始容量 → 避免多次扩容</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2️⃣-ensureCapacity-int-minCapacity"><a href="#2️⃣-ensureCapacity-int-minCapacity" class="headerlink" title="2️⃣ ensureCapacity(int minCapacity)"></a>2️⃣ <strong>ensureCapacity(int minCapacity)</strong></h2><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h3><ul>
<li>手动确保 ArrayList 至少有 <code>minCapacity</code> 容量</li>
<li>提前分配数组 → 避免频繁扩容</li>
</ul>
<h3 id="2-2-使用示例"><a href="#2-2-使用示例" class="headerlink" title="2.2 使用示例"></a>2.2 使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.ensureCapacity(<span class="number">1000</span>); <span class="comment">// 提前分配空间</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-面试点"><a href="#2-3-面试点" class="headerlink" title="2.3 面试点"></a>2.3 面试点</h3><ul>
<li>用于性能优化</li>
<li>避免批量添加时不断触发扩容和数组复制</li>
</ul>
<hr>
<h2 id="3️⃣-trimToSize"><a href="#3️⃣-trimToSize" class="headerlink" title="3️⃣ trimToSize()"></a>3️⃣ <strong>trimToSize()</strong></h2><h3 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h3><ul>
<li>将 <code>elementData</code> 数组容量缩减到 <strong>当前 size</strong></li>
<li>节约内存空间，特别是 ArrayList 元素较少且容量大时</li>
</ul>
<h3 id="3-2-使用示例"><a href="#3-2-使用示例" class="headerlink" title="3.2 使用示例"></a>3.2 使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.trimToSize(); <span class="comment">// 数组长度缩减为 1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-面试点"><a href="#3-3-面试点" class="headerlink" title="3.3 面试点"></a>3.3 面试点</h3><ul>
<li>用于 <strong>内存优化</strong></li>
<li>注意：之后再次 add 元素可能触发扩容 → 有性能开销</li>
</ul>
<hr>
<h2 id="4️⃣-迭代时的-fail-fast（modCount）机制"><a href="#4️⃣-迭代时的-fail-fast（modCount）机制" class="headerlink" title="4️⃣ 迭代时的 fail-fast（modCount）机制"></a>4️⃣ <strong>迭代时的 fail-fast（modCount）机制</strong></h2><h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h3><ul>
<li><p>ArrayList 内部维护 <code>modCount</code>：</p>
<ul>
<li>每次 <strong>结构性修改</strong>（add&#x2F;remove&#x2F;clear） → modCount++</li>
</ul>
</li>
<li><p>Iterator 获取 modCount 副本 <code>expectedModCount</code></p>
</li>
<li><p><strong>遍历时检查</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-触发场景"><a href="#4-2-触发场景" class="headerlink" title="4.2 触发场景"></a>4.2 触发场景</h3><ul>
<li>结构性修改 → <strong>抛 ConcurrentModificationException</strong></li>
<li><strong>非结构性修改</strong>（如 <code>set()</code> 替换元素）不会触发</li>
</ul>
<h3 id="4-3-面试点"><a href="#4-3-面试点" class="headerlink" title="4.3 面试点"></a>4.3 面试点</h3><ul>
<li><strong>目的</strong>：快速发现并发或不安全操作 → fail-fast</li>
<li><strong>注意</strong>：<ul>
<li>并发修改 ArrayList → Iterator 异常</li>
<li>并发安全 → 使用 <code>CopyOnWriteArrayList</code> 或手动同步</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5️⃣-面试快速答题模板-1"><a href="#5️⃣-面试快速答题模板-1" class="headerlink" title="5️⃣ 面试快速答题模板"></a>5️⃣ <strong>面试快速答题模板</strong></h2><ol>
<li><strong>扩容开销</strong><ul>
<li>扩容触发条件：<code>size &gt;= capacity</code></li>
<li>扩容过程：新数组 + 元素复制 → O(n)</li>
<li>优化：指定初始容量</li>
</ul>
</li>
<li><strong>ensureCapacity</strong><ul>
<li>提前分配容量，避免频繁扩容</li>
</ul>
</li>
<li><strong>trimToSize</strong><ul>
<li>缩减数组长度到当前 size → 节约内存</li>
</ul>
</li>
<li><strong>fail-fast</strong><ul>
<li><code>modCount</code> 记录结构性修改</li>
<li>Iterator 检查 <code>expectedModCount</code></li>
<li>结构修改 → <code>ConcurrentModificationException</code></li>
</ul>
</li>
</ol>
<hr>
<p>💡 <strong>补充知识点</strong></p>
<ul>
<li>ArrayList 扩容策略是 <strong>时间&#x2F;空间折中</strong></li>
<li>迭代器 fail-fast 并非严格同步机制 → <strong>只是快速失败检测</strong></li>
<li>批量插入 + ensureCapacity → 性能最佳实践</li>
</ul>
<hr>
<p>好的，我们来系统讲解 <strong>LinkedList</strong> 的底层原理、扩容（其实链表没数组那样扩容）、迭代器机制、以及 fail-fast 等面试重点，和 ArrayList 对比也方便理解。</p>
<hr>
<h2 id="1️⃣-LinkedList-基本原理"><a href="#1️⃣-LinkedList-基本原理" class="headerlink" title="1️⃣ LinkedList 基本原理"></a>1️⃣ <strong>LinkedList 基本原理</strong></h2><ul>
<li><p><strong>底层结构</strong>：<strong>双向链表（Doubly Linked List）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>存储特点</strong>：</p>
<ul>
<li>每个节点包含元素值 + 前驱 + 后继指针</li>
<li>内存分配按节点动态分配（Heap）</li>
<li>不需要预分配容量 → 没有扩容概念</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>增删快：O(1)（已定位节点时）</li>
<li>查找慢：O(n)（按索引遍历节点）</li>
<li>支持双向遍历：prev&#x2F;next</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2️⃣-插入与删除"><a href="#2️⃣-插入与删除" class="headerlink" title="2️⃣ 插入与删除"></a>2️⃣ <strong>插入与删除</strong></h2><ul>
<li><strong>add &#x2F; addFirst &#x2F; addLast</strong><ul>
<li>创建新节点 → 更新前驱&#x2F;后继 → size++</li>
<li>已知节点可在 O(1) 完成插入</li>
</ul>
</li>
<li><strong>remove &#x2F; removeFirst &#x2F; removeLast</strong><ul>
<li>更新前驱&#x2F;后继指针 → GC 回收节点 → size–</li>
</ul>
</li>
<li><strong>按索引插入&#x2F;删除</strong><ul>
<li>需遍历节点 → O(n)</li>
</ul>
</li>
</ul>
<h3 id="面试点"><a href="#面试点" class="headerlink" title="面试点"></a>面试点</h3><ul>
<li>插入删除头尾快，随机访问慢</li>
<li>对比 ArrayList：随机访问慢，尾部插入快或慢取决于是否扩容</li>
</ul>
<hr>
<h2 id="3️⃣-迭代器与-fail-fast"><a href="#3️⃣-迭代器与-fail-fast" class="headerlink" title="3️⃣ 迭代器与 fail-fast"></a>3️⃣ <strong>迭代器与 fail-fast</strong></h2><ul>
<li><p><strong>modCount 机制</strong>与 ArrayList 类似</p>
<ul>
<li>LinkedList 每次结构修改（add&#x2F;remove&#x2F;clear） → <code>modCount++</code></li>
</ul>
</li>
<li><p><strong>迭代器</strong></p>
<ul>
<li><p>创建时记录 <code>expectedModCount = modCount</code></p>
</li>
<li><p>next()&#x2F;remove() 时检查：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (modCount != expectedModCount) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>特点</strong></p>
<ul>
<li>遍历链表时结构修改 → <strong>fail-fast</strong></li>
<li>非结构性修改（修改元素值 <code>set()</code>）不触发异常</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4️⃣-LinkedList-特点总结"><a href="#4️⃣-LinkedList-特点总结" class="headerlink" title="4️⃣ LinkedList 特点总结"></a>4️⃣ <strong>LinkedList 特点总结</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>LinkedList</th>
<th>ArrayList</th>
</tr>
</thead>
<tbody><tr>
<td>底层结构</td>
<td>双向链表</td>
<td>动态数组</td>
</tr>
<tr>
<td>随机访问</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>插入&#x2F;删除</td>
<td>O(1) 已知节点</td>
<td>O(n) 平均</td>
</tr>
<tr>
<td>内存分配</td>
<td>节点动态分配</td>
<td>整体数组扩容（复制元素）</td>
</tr>
<tr>
<td>迭代器</td>
<td>fail-fast</td>
<td>fail-fast</td>
</tr>
<tr>
<td>扩容</td>
<td>不需要</td>
<td>需要复制数组（O(n)）</td>
</tr>
<tr>
<td>内存开销</td>
<td>大，每个节点多 2 个指针</td>
<td>小，连续内存</td>
</tr>
</tbody></table>
<hr>
<h2 id="5️⃣-面试追问-1"><a href="#5️⃣-面试追问-1" class="headerlink" title="5️⃣ 面试追问"></a>5️⃣ <strong>面试追问</strong></h2><ol>
<li><strong>LinkedList 和 ArrayList 何时用哪个？</strong><ul>
<li>ArrayList：随机访问多，插入删除少</li>
<li>LinkedList：频繁插入&#x2F;删除头尾，随机访问少</li>
</ul>
</li>
<li><strong>为什么 LinkedList 没有扩容？</strong><ul>
<li>每个节点单独分配，链表不需要连续内存 → 不存在数组复制开销</li>
</ul>
</li>
<li><strong>fail-fast 能保证并发安全吗？</strong><ul>
<li>❌ 不能，只是快速失败检测</li>
<li>并发操作需外部同步或使用 <code>CopyOnWriteArrayList</code>&#x2F;<code>ConcurrentLinkedDeque</code></li>
</ul>
</li>
<li><strong>为什么 LinkedList 内存占用大？</strong><ul>
<li>每个节点额外保存两个引用（prev&#x2F;next）</li>
<li>对象头 + 数据 + 两个引用 → 比 ArrayList 每元素占用多</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6️⃣-面试快速答题模板"><a href="#6️⃣-面试快速答题模板" class="headerlink" title="6️⃣ 面试快速答题模板"></a>6️⃣ <strong>面试快速答题模板</strong></h2><ul>
<li><strong>底层</strong>：双向链表 → 每节点：item&#x2F;prev&#x2F;next</li>
<li><strong>扩容</strong>：无，动态分配节点</li>
<li><strong>增删</strong>：头尾 O(1)，随机 O(n)</li>
<li><strong>迭代器</strong>：fail-fast，通过 modCount 检测结构修改</li>
<li><strong>适用场景</strong>：频繁插入&#x2F;删除，顺序遍历；随机访问少</li>
<li><strong>内存开销</strong>：比 ArrayList 高（节点指针多）</li>
</ul>
<hr>
<p>💡 <strong>补充知识点</strong></p>
<ul>
<li>Java 8 LinkedList 内部节点还是 <code>Node&lt;E&gt;</code> + 双向链表</li>
<li>支持 <strong>Deque 接口</strong> → 可以用作栈&#x2F;队列</li>
<li>fail-fast 和多线程并发同样不安全 → 外部同步或使用 <code>ConcurrentLinkedDeque</code></li>
</ul>
<hr>
<hr>
<h3 id="16-基本类型-vs-包装类型"><a href="#16-基本类型-vs-包装类型" class="headerlink" title="16 基本类型 vs 包装类型"></a>16 基本类型 vs 包装类型</h3><ul>
<li><strong>基本类型</strong>：<ul>
<li>存放值，效率高，不能为 <code>null</code>。</li>
<li>不能用于泛型（必须使用包装类），不能放入集合（需要装箱）。</li>
</ul>
</li>
<li><strong>包装类型（如 Integer）</strong>：<ul>
<li>对象，存放在堆，有对象头，有引用开销，支持 <code>null</code>。</li>
<li>提供方法（parse、valueOf 等）。</li>
</ul>
</li>
<li><strong>性能差异</strong>：包装类型会产生额外对象分配与 GC，尽量在性能敏感场景使用基本类型数组（<code>int[]</code>）或原语流&#x2F;第三方库。</li>
</ul>
<hr>
<h3 id="17-Java-的-Object-类常用方法"><a href="#17-Java-的-Object-类常用方法" class="headerlink" title="17 Java 的 Object 类常用方法"></a>17 Java 的 <code>Object</code> 类常用方法</h3><ul>
<li><code>equals(Object obj)</code>：比较逻辑相等。</li>
<li><code>hashCode()</code>：哈希码。</li>
<li><code>toString()</code>：字符串表示。</li>
<li><code>getClass()</code>：返回运行时 Class 对象。</li>
<li><code>clone()</code>：浅拷贝（需实现 <code>Cloneable</code> 才有效，通常不推荐使用 clone）。</li>
<li><code>finalize()</code>：对象回收前调用（已弃用，不可靠，JDK9+ 标记为 deprecated）。</li>
<li><code>wait()/notify()/notifyAll()</code>：对象监视器（必须在 synchronized 块中调用），用于线程间通信。</li>
<li><code>registerNatives()</code> 等（本地方法）。</li>
</ul>
<p><strong>面试点</strong>：为什么不建议使用 finalize；如何正确使用 wait&#x2F;notify（必须在同步块中，防止虚假唤醒用 while 循环判断 condition）。</p>
<p>好的，<code>wait/notify</code> 是 Java 多线程协作的核心面试点，常被问“为什么必须在同步块中”、“虚假唤醒如何处理”，我帮你系统整理，并给出例子。</p>
<hr>
<h2 id="1️⃣-wait-notify-基本原理"><a href="#1️⃣-wait-notify-基本原理" class="headerlink" title="1️⃣ wait&#x2F;notify 基本原理"></a>1️⃣ <strong>wait&#x2F;notify 基本原理</strong></h2><ul>
<li><strong>wait()</strong><ul>
<li>让当前线程进入<strong>等待状态</strong>，释放持有的锁</li>
<li>等待其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒</li>
<li>必须在 <strong>同步块&#x2F;方法中</strong>调用，否则抛 <code>IllegalMonitorStateException</code></li>
</ul>
</li>
<li><strong>notify() &#x2F; notifyAll()</strong><ul>
<li>唤醒在当前对象 monitor 上等待的线程</li>
<li>notify：随机唤醒一个</li>
<li>notifyAll：唤醒所有线程</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2️⃣-必须在同步块中的原因"><a href="#2️⃣-必须在同步块中的原因" class="headerlink" title="2️⃣ 必须在同步块中的原因"></a>2️⃣ <strong>必须在同步块中的原因</strong></h2><ul>
<li><p>每个对象有 <strong>对象监视器（monitor）</strong></p>
</li>
<li><p><code>wait/notify</code> 操作依赖持有 monitor</p>
</li>
<li><p>Java 语言规定：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">monitor.enter(); // synchronized</span><br><span class="line">wait()          // 释放 monitor，进入等待队列</span><br><span class="line">notify()        // 唤醒等待队列线程</span><br><span class="line">monitor.exit();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3️⃣-防止虚假唤醒"><a href="#3️⃣-防止虚假唤醒" class="headerlink" title="3️⃣ 防止虚假唤醒"></a>3️⃣ <strong>防止虚假唤醒</strong></h2><ul>
<li><p><strong>虚假唤醒</strong>：线程可能被唤醒，但条件不满足</p>
</li>
<li><p>因此 <strong>wait 必须放在 while 循环中检查条件</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件满足，执行任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不要用 if</strong>，因为虚假唤醒或多线程唤醒可能导致错误执行</p>
</li>
</ul>
<hr>
<h2 id="4️⃣-wait-notify-使用模板"><a href="#4️⃣-wait-notify-使用模板" class="headerlink" title="4️⃣ wait&#x2F;notify 使用模板"></a>4️⃣ <strong>wait&#x2F;notify 使用模板</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (available) &#123;       <span class="comment">// 条件不满足就等待</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Producing...&quot;</span>);</span><br><span class="line">        available = <span class="literal">true</span>;</span><br><span class="line">        notifyAll();              <span class="comment">// 唤醒消费者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!available) &#123;      <span class="comment">// 条件不满足就等待</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consuming...&quot;</span>);</span><br><span class="line">        available = <span class="literal">false</span>;</span><br><span class="line">        notifyAll();              <span class="comment">// 唤醒生产者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：<ol>
<li>条件检查放在 <code>while</code> 中 → 防虚假唤醒</li>
<li><code>wait/notifyAll</code> 都在 <strong>synchronized 方法或块</strong> 中</li>
<li><code>notifyAll</code> 通常比 <code>notify</code> 更安全，避免某些线程永远等待</li>
</ol>
</li>
</ul>
<hr>
<h2 id="5️⃣-示例：生产者-消费者"><a href="#5️⃣-示例：生产者-消费者" class="headerlink" title="5️⃣ 示例：生产者-消费者"></a>5️⃣ <strong>示例：生产者-消费者</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) r.produce();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) r.consume();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出示意</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Producing...</span><br><span class="line">Consuming...</span><br><span class="line">Producing...</span><br><span class="line">Consuming...</span><br></pre></td></tr></table></figure>

<ul>
<li>生产者和消费者轮流执行</li>
<li><code>while</code> 循环保证虚假唤醒时线程不会错误执行</li>
<li>synchronized + wait&#x2F;notifyAll 保证线程安全</li>
</ul>
<hr>
<p>✅ <strong>面试要点总结</strong></p>
<ol>
<li><strong>必须在同步块中</strong> → 持有对象 monitor</li>
<li><strong>防止虚假唤醒</strong> → <code>while(condition)</code></li>
<li><strong>notify vs notifyAll</strong><ul>
<li>notify 唤醒一个线程，效率高，但可能导致线程饿死</li>
<li>notifyAll 唤醒所有线程，更安全</li>
</ul>
</li>
<li><strong>线程安全协作</strong><ul>
<li>wait 释放锁 → allow 其他线程执行</li>
<li>条件改变后 notifyAll 唤醒等待线程</li>
</ul>
</li>
</ol>
<hr>
<h3 id="18-深拷贝-浅拷贝-引用拷贝"><a href="#18-深拷贝-浅拷贝-引用拷贝" class="headerlink" title="18 深拷贝 &#x2F; 浅拷贝 &#x2F; 引用拷贝"></a>18 深拷贝 &#x2F; 浅拷贝 &#x2F; 引用拷贝</h3><ul>
<li><strong>引用拷贝</strong>：变量复制引用，两者指向同一对象（<code>a = b</code>）。</li>
<li><strong>浅拷贝</strong>：<ul>
<li>对象本身复制一份（字段为基本类型复制值），引用类型字段复制引用（不复制引用对象）。</li>
<li><code>Object.clone()</code> 默认实现就是浅拷贝（只复制字段）。</li>
</ul>
</li>
<li><strong>深拷贝</strong>：<ul>
<li>不仅复制对象本身，还递归复制所有引用对象（或复制所需的子对象），得到完全独立的对象树。</li>
<li>实现方式：手写递归复制、通过序列化（对象-&gt;字节-&gt;对象）或使用第三方库（如 Apache Commons Lang <code>SerializationUtils.clone()</code>）&#x2F;手动 copy constructor。</li>
</ul>
</li>
<li><strong>面试点</strong>：浅拷贝带来的共享可变子对象问题；clone 的陷阱（浅拷贝导致共享、需要实现 Cloneable 并覆盖 clone、异常处理）；如何实现可扩展的深拷贝（每个类提供 copy constructor 或工厂方法）。</li>
</ul>
<hr>
<h3 id="19-JDK-动态代理-CGLIB"><a href="#19-JDK-动态代理-CGLIB" class="headerlink" title="19 JDK 动态代理 &amp; CGLIB"></a>19 JDK 动态代理 &amp; CGLIB</h3><ul>
<li><p><strong>JDK 动态代理（java.lang.reflect.Proxy）</strong>：</p>
<ul>
<li><p>基于接口：只能为实现了接口的类创建代理。</p>
</li>
<li><p>通过 <code>InvocationHandler</code> 的 <code>invoke(Object proxy, Method method, Object[] args)</code> 拦截所有方法调用。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyInterface</span> <span class="variable">proxy</span> <span class="operator">=</span> (MyInterface) Proxy.newProxyInstance(</span><br><span class="line">  loader,</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;MyInterface.class&#125;,</span><br><span class="line">  (p, m, a) -&gt; &#123; <span class="comment">/* 横切逻辑 */</span> <span class="keyword">return</span> m.invoke(target, a); &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>CGLIB（字节码生成, org.springframework.cglib 或 net.sf.cglib）</strong>：</p>
<ul>
<li>基于生成目标类的子类（继承）并重写方法，适用于没有接口的类。</li>
<li>不能为 <code>final</code> 类或 <code>final</code> 方法创建代理（因为继承时无法覆盖 final 方法）。</li>
</ul>
</li>
<li><p><strong>Spring AOP</strong>：默认使用 JDK 动态代理（若目标实现接口），否则回退到 CGLIB（或可强制使用 CGLIB）。</p>
</li>
<li><p><strong>性能</strong>：JDK Proxy 在接口较多时开销较小，CGLIB 在没有接口的情况下是必须选项；现代实现都很快，但生成字节码开销存在（通常在代理创建时发生一次）。</p>
</li>
</ul>
<p><strong>面试点</strong>：自调用（同类方法内部调用）不会触发通过代理的拦截（因为代理是外部包装）；如何绕开（用 AopContext.currentProxy() 或把逻辑放到另一个 bean）。</p>
<hr>
<h3 id="20-序列化-反序列化"><a href="#20-序列化-反序列化" class="headerlink" title="20 序列化 &#x2F; 反序列化"></a>20 序列化 &#x2F; 反序列化</h3><ul>
<li><p><strong>序列化</strong>：将对象转成字节流（保存到文件&#x2F;传输网络）。</p>
</li>
<li><p><strong>反序列化</strong>：字节流还原为对象。</p>
</li>
<li><p><strong>Java 原生序列化</strong>：</p>
<ul>
<li>对象需实现 <code>Serializable</code>。可以定义 <code>private static final long serialVersionUID</code> 控制版本兼容。</li>
<li>可标 <code>transient</code> 字段为不序列化。</li>
<li>缺点：体积大、性能差、安全风险（直接反序列化恶意数据存在 RCE 风险），版本兼容复杂。</li>
</ul>
</li>
<li><p><strong>替代协议</strong>：Protobuf、Avro、Thrift、Kryo、Hessian、JSON 等（更紧凑&#x2F;跨语言&#x2F;更安全）。</p>
</li>
<li><p><strong>面试点</strong>：serialVersionUID 作用、如何实现自定义序列化（<code>writeObject</code>&#x2F;<code>readObject</code>）、安全问题与防御（不要直接反序列化不可信数据、使用白名单、安全库）。</p>
</li>
<li><p>好的，我们来深入讲解 <strong>Java 序列化机制</strong>，cover 面试高频点：<code>serialVersionUID</code>、自定义序列化、安全问题和防御措施。</p>
<hr>
<h2 id="1️⃣-serialVersionUID-作用"><a href="#1️⃣-serialVersionUID-作用" class="headerlink" title="1️⃣ serialVersionUID 作用"></a>1️⃣ <strong>serialVersionUID 作用</strong></h2><ul>
<li><strong>定义</strong>：<code>private static final long serialVersionUID</code></li>
<li><strong>用途</strong>：序列化时标识类版本</li>
<li><strong>工作原理</strong>：<ol>
<li>序列化对象 → 在字节流中写入 <code>serialVersionUID</code></li>
<li>反序列化 → JVM 检查流中 <code>serialVersionUID</code> 与本地类是否匹配</li>
<li>不匹配 → 抛 <code>InvalidClassException</code></li>
</ol>
</li>
<li><strong>默认行为</strong>：<ul>
<li>如果没有显式声明，JVM 会根据类结构自动生成 UID</li>
<li>类结构变更 → UID 变更 → 反序列化失败</li>
</ul>
</li>
<li><strong>面试答题重点</strong>：<ul>
<li>显式声明 <code>serialVersionUID</code> → 保证类结构轻微变动后仍能兼容</li>
<li>推荐所有可序列化类都显式声明</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2️⃣-自定义序列化"><a href="#2️⃣-自定义序列化" class="headerlink" title="2️⃣ 自定义序列化"></a>2️⃣ <strong>自定义序列化</strong></h2><ul>
<li>默认实现：<ul>
<li><code>ObjectOutputStream.writeObject()</code> → 按字段顺序写入</li>
<li><code>ObjectInputStream.readObject()</code> → 按字段顺序读取</li>
</ul>
</li>
<li><strong>自定义</strong>：通过实现 <code>writeObject</code> &#x2F; <code>readObject</code> 方法</li>
</ul>
<h3 id="2-1-示例"><a href="#2-1-示例" class="headerlink" title="2.1 示例"></a>2.1 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age; <span class="comment">// transient 字段默认不序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.name = name; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream oos)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        oos.defaultWriteObject();   <span class="comment">// 写非 transient 字段</span></span><br><span class="line">        oos.writeInt(age);          <span class="comment">// 自定义写 transient 字段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ois.defaultReadObject();    <span class="comment">// 读非 transient 字段</span></span><br><span class="line">        <span class="built_in">this</span>.age = ois.readInt();   <span class="comment">// 自定义读 transient 字段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> name + <span class="string">&quot;, &quot;</span> + age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：<ul>
<li><code>defaultWriteObject()</code> &#x2F; <code>defaultReadObject()</code> → 保留默认序列化</li>
<li>可自定义处理 transient 或敏感字段</li>
<li>可以做数据加密、压缩或版本兼容处理</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3️⃣-安全问题"><a href="#3️⃣-安全问题" class="headerlink" title="3️⃣ 安全问题"></a>3️⃣ <strong>安全问题</strong></h2><h3 id="3-1-常见问题"><a href="#3-1-常见问题" class="headerlink" title="3.1 常见问题"></a>3.1 常见问题</h3><ol>
<li><strong>反序列化不可信数据</strong><ul>
<li>攻击者可以构造恶意对象 → 触发任意代码执行</li>
<li>典型 CVE：<code>CommonsCollections</code> 反序列化链攻击</li>
</ul>
</li>
<li><strong>对象注入</strong><ul>
<li>构造特殊 payload → 修改程序行为、执行任意方法</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-2-防御措施"><a href="#3-2-防御措施" class="headerlink" title="3.2 防御措施"></a>3.2 防御措施</h3><ol>
<li><p><strong>避免直接反序列化外部数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream());</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject(); <span class="comment">// 危险</span></span><br></pre></td></tr></table></figure>

<ul>
<li>尽量使用 <strong>安全库</strong> 或 <strong>数据转换格式</strong>（JSON、Protobuf）</li>
</ul>
</li>
<li><p><strong>白名单机制</strong></p>
<ul>
<li><p>JDK 9+ 提供 <code>ObjectInputFilter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputFilter</span> <span class="variable">filter</span> <span class="operator">=</span> ObjectInputFilter.Config.createFilter(<span class="string">&quot;java.base/*;!*&quot;</span>);</span><br><span class="line">ois.setObjectInputFilter(filter);</span><br></pre></td></tr></table></figure>
</li>
<li><p>只允许特定类反序列化，拒绝未知类</p>
</li>
</ul>
</li>
<li><p><strong>自定义 readObject() 验证数据</strong></p>
<ul>
<li>检查字段合法性、防止恶意 payload</li>
</ul>
</li>
<li><p><strong>序列化替代方案</strong></p>
<ul>
<li>JSON、Protobuf、Kryo（安全配置）</li>
</ul>
</li>
</ol>
<hr>
<h2 id="4️⃣-面试答题模板-2"><a href="#4️⃣-面试答题模板-2" class="headerlink" title="4️⃣ 面试答题模板"></a>4️⃣ <strong>面试答题模板</strong></h2><ol>
<li><strong>serialVersionUID</strong><ul>
<li>标识类版本</li>
<li>显式声明避免类结构改动破坏兼容</li>
</ul>
</li>
<li><strong>自定义序列化</strong><ul>
<li><code>writeObject</code> &#x2F; <code>readObject</code></li>
<li>处理 transient &#x2F; 加密 &#x2F; 压缩 &#x2F; 版本兼容</li>
</ul>
</li>
<li><strong>安全问题</strong><ul>
<li>不可信数据反序列化 → 可执行任意代码</li>
<li>防御：白名单、过滤器、自定义验证、使用安全库</li>
</ul>
</li>
<li><strong>最佳实践</strong><ul>
<li>所有 Serializable 类显式声明 UID</li>
<li>避免直接反序列化外部输入</li>
<li>对敏感数据用 transient + 自定义序列化处理</li>
</ul>
</li>
</ol>
<hr>
<p>💡 <strong>补充知识点</strong></p>
<ul>
<li><code>readResolve()</code> &#x2F; <code>writeReplace()</code> → 允许序列化替换对象</li>
<li>反序列化安全是高频面试点 → 尤其是 Java 企业安全岗</li>
</ul>
</li>
</ul>
<hr>
<h3 id="21-常见序列化协议（优缺点）"><a href="#21-常见序列化协议（优缺点）" class="headerlink" title="21 常见序列化协议（优缺点）"></a>21 常见序列化协议（优缺点）</h3><ul>
<li><strong>Java 原生</strong>：易用但臃肿、慢、安全问题。</li>
<li><strong>JSON</strong>（Jackson &#x2F; Gson）：可读、跨语言、慢于二进制、无模式（schema）。</li>
<li><strong>Protobuf（Google）</strong>：二进制、高效、需要 schema、跨语言。</li>
<li><strong>Avro</strong>：支持 schema 演进，适合大数据。</li>
<li><strong>Thrift</strong>：类似 Protobuf，支持 RPC。</li>
<li><strong>Kryo</strong>：高性能 Java 专用序列化（用于低延迟场景）。</li>
<li><strong>Hessian</strong>：二进制 Web 服务序列化，跨语言。</li>
</ul>
<p><strong>面试点</strong>：如何基于场景（跨语言&#x2F;性能&#x2F;兼容性）选择序列化协议。</p>
<hr>
<h3 id="22-BlockingQueue"><a href="#22-BlockingQueue" class="headerlink" title="22 BlockingQueue"></a>22 BlockingQueue</h3><ul>
<li><strong>定义</strong>：<code>BlockingQueue</code> 支持在队列为空时阻塞消费者；在队列为满时阻塞生产者。常用于生产者-消费者模式，线程池的 work queue。</li>
<li><strong>方法</strong>：<ul>
<li>阻塞：<code>put(E)</code>（满时阻塞）、<code>take()</code>（空时阻塞）。</li>
<li>非阻塞：<code>offer(E)</code>、<code>poll()</code>（可返回 null 或布尔）。</li>
<li>带超时：<code>offer(E, timeout, unit)</code> &#x2F; <code>poll(timeout, unit)</code>。</li>
</ul>
</li>
<li><strong>常见实现</strong>：<ul>
<li><code>ArrayBlockingQueue</code>：基于数组、固定大小、可选择公平&#x2F;非公平锁（ReentrantLock）实现。</li>
<li><code>LinkedBlockingQueue</code>：基于链表，可选边界（默认 Integer.MAX_VALUE），读写使用不同锁，吞吐量高。</li>
<li><code>PriorityBlockingQueue</code>：基于优先队列，不保证 FIFO，非公平（无阻塞 put，因为无界）。</li>
<li><code>SynchronousQueue</code>：不保存元素，每个 put 必须等待一个 take（直接交付）。适合线程间直连交互（常用在 ForkJoinPool，或 ThreadPoolExecutor 饱和策略）。</li>
<li><code>DelayQueue</code>：元素带延迟，只有到期后才能被 take（常用于定时任务）。</li>
</ul>
</li>
<li><strong>使用建议</strong>：根据吞吐与公平性选择实现；<code>LinkedBlockingQueue</code> 适合高吞吐，<code>ArrayBlockingQueue</code> 提供固定容量和可控行为。</li>
</ul>
<hr>
<h3 id="23-PriorityQueue"><a href="#23-PriorityQueue" class="headerlink" title="23 PriorityQueue"></a>23 PriorityQueue</h3><ul>
<li><strong>实现</strong>：基于二叉堆（通常是数组形式的最小堆），在 JDK 中 <code>PriorityQueue</code> 是最小堆（最小元素优先）。</li>
<li><strong>复杂度</strong>：<ul>
<li><code>offer()</code> &#x2F; <code>poll()</code>：O(log n)（上下调整堆）。</li>
<li><code>peek()</code>：O(1)。</li>
<li><code>remove(Object)</code>：O(n)（删除任意元素需要线性查找并重新堆化）。</li>
</ul>
</li>
<li><strong>元素要求</strong>：要么实现 <code>Comparable</code>，要么在构造时传入 <code>Comparator</code>。不能保存 <code>null</code>。</li>
<li><strong>非线程安全</strong>：多线程需要外部同步或使用 <code>PriorityBlockingQueue</code>。</li>
<li><strong>用途</strong>：任务调度、A* 算法的 open set、定时任务优先级管理（结合 DelayQueue&#x2F;自定义时间比较器）。</li>
<li><strong>实现细节</strong>：内部使用 <code>siftUp</code> &#x2F; <code>siftDown</code> 操作维持堆性质。</li>
</ul>
<h3 id="24-设计原则"><a href="#24-设计原则" class="headerlink" title="24 设计原则"></a>24 设计原则</h3><p>面向对象的设计模式有七大基本原则：</p>
<ul>
<li>开闭原则（Open Closed Principle，OCP）</li>
<li>单一职责原则（Single Responsibility Principle, SRP）</li>
<li>里氏代换原则（Liskov Substitution Principle，LSP）</li>
<li>依赖倒转原则（Dependency Inversion Principle，DIP）</li>
<li>接口隔离原则（Interface Segregation Principle，ISP）</li>
<li>合成&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle，CARP）</li>
<li>最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of  Demeter，LOD）</li>
</ul>
<table>
<thead>
<tr>
<th align="left">标记</th>
<th align="left">设计模式原则名称</th>
<th align="left">简单定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">OCP</td>
<td align="left">开闭原则</td>
<td align="left">对扩展开放，对修改关闭</td>
</tr>
<tr>
<td align="left">SRP</td>
<td align="left">单一职责原则</td>
<td align="left">一个类只负责一个功能领域中的相应职责</td>
</tr>
<tr>
<td align="left">LSP</td>
<td align="left">里氏代换原则</td>
<td align="left">所有引用基类的地方必须能透明地使用其子类的对象</td>
</tr>
<tr>
<td align="left">DIP</td>
<td align="left">依赖倒转原则</td>
<td align="left">依赖于抽象，不能依赖于具体实现</td>
</tr>
<tr>
<td align="left">ISP</td>
<td align="left">接口隔离原则</td>
<td align="left">类之间的依赖关系应该建立在最小的接口上</td>
</tr>
<tr>
<td align="left">CARP</td>
<td align="left">合成&#x2F;聚合复用原则</td>
<td align="left">尽量使用合成&#x2F;聚合，而不是通过继承达到复用的目的</td>
</tr>
<tr>
<td align="left">LOD</td>
<td align="left">迪米特法则</td>
<td align="left">一个软件实体应当尽可能少的与其他实体发生相互作用</td>
</tr>
</tbody></table>
<p>其中，单一职责原则、开闭原则、迪米特法则、里氏代换原则和接口隔离原则就是我们平常熟知的<strong>SOLID</strong>。</p>
<h3 id="小结-典型面试追问准备"><a href="#小结-典型面试追问准备" class="headerlink" title="小结 + 典型面试追问准备"></a><strong>小结 + 典型面试追问准备</strong></h3><ul>
<li>HashMap、ConcurrentHashMap、ArrayList&#x2F;LinkedList、String 系列、equals&#x2F;hashCode、volatile&#x2F;final&#x2F;static 是高频点；务必能画数据结构示意图与关键代码路径（比如 put&#x2F;get 的流程图）。</li>
<li>练习写出 <code>equals</code> &#x2F; <code>hashCode</code> 的正确实现样例，能解释 HashMap 的扩容和树化阈值（16&#x2F;0.75&#x2F;8&#x2F;64）。</li>
<li>熟悉 <code>synchronized</code> vs <code>Lock</code> vs <code>volatile</code> 的语义与性能差异；理解 JMM 基础（happens-before，final 字段语义）。</li>
<li>对并发集合，能解释为什么 <code>ConcurrentHashMap.get()</code> 不加锁仍安全（volatile 可见与不变性保证）。</li>
</ul>
<h2 id="数据库基础-牛客面经八股"><a href="#数据库基础-牛客面经八股" class="headerlink" title="数据库基础-牛客面经八股"></a>数据库基础-牛客面经八股</h2><hr>
<h3 id="1-MySQL-的存储引擎有哪些？它们之间有什么区别？默认使用哪个？"><a href="#1-MySQL-的存储引擎有哪些？它们之间有什么区别？默认使用哪个？" class="headerlink" title="1. MySQL 的存储引擎有哪些？它们之间有什么区别？默认使用哪个？"></a><strong>1. MySQL 的存储引擎有哪些？它们之间有什么区别？默认使用哪个？</strong></h3><p>常见引擎（并非全部）：</p>
<ul>
<li><strong>InnoDB</strong>：事务性引擎，支持 ACID、行级锁、MVCC、外键、崩溃恢复（redo&#x2F;undo、doublewrite）、自带缓冲池（buffer pool）。适合 OLTP。<strong>默认引擎（MySQL 5.5+）</strong>。</li>
<li><strong>MyISAM</strong>：非事务、表级锁、较小 IO 延迟、全文索引（早期），恢复能力弱，不支持外键。适合只读或读多写少场景。</li>
<li><strong>MEMORY</strong>（HEAP）：把数据放内存，访问极快，但断电丢失，适合临时表或高速缓存。</li>
<li><strong>CSV</strong>：把每行存为 CSV 文件，便于导&#x2F;出，但功能非常有限。</li>
<li><strong>ARCHIVE</strong>：适合归档写入（高压缩、只追加、只支持 INSERT&#x2F;SELECT），不能索引（或索引能力弱）。</li>
<li><strong>NDB（MySQL Cluster）</strong>：分布式内存存储引擎，适用于高可用、分布式场景（复杂运维）。</li>
<li><strong>其他第三方&#x2F;变体</strong>：如 MyRocks（Facebook 的 RocksDB 后端，写放大与压缩优化）、TokuDB 等。</li>
</ul>
<p><strong>区别要点</strong>：</p>
<ul>
<li>事务支持（InnoDB 支持，MyISAM 不支持）。</li>
<li>锁粒度（InnoDB 行级锁，MyISAM 表级锁）。</li>
<li>崩溃恢复（InnoDB 有 redo&#x2F;undo&#x2F;doublewrite），MyISAM 依赖修复工具。</li>
<li>存储与索引实现细节（索引类型、压缩、聚簇索引等）。</li>
<li>性能定位：InnoDB 通常更平衡适合并发写；MyISAM 在单纯读场景可能略快。</li>
</ul>
<p><strong>默认引擎</strong>：现代 MySQL（5.5 之后）默认是 <strong>InnoDB</strong>。</p>
<hr>
<h3 id="2-MyISAM-与-InnoDB-的区别？如何选择？"><a href="#2-MyISAM-与-InnoDB-的区别？如何选择？" class="headerlink" title="2. MyISAM 与 InnoDB 的区别？如何选择？"></a><strong>2. MyISAM 与 InnoDB 的区别？如何选择？</strong></h3><p><strong>关键差别</strong>：</p>
<ul>
<li>事务：InnoDB 支持事务（ACID），MyISAM 不支持。</li>
<li>锁：InnoDB 行级锁（更高并发性）；MyISAM 表级锁（写操作会阻塞读写）。</li>
<li>崩溃恢复：InnoDB 支持 redo&#x2F;undo + doublewrite（较安全）；MyISAM 恢复能力差（需 myisamchk）。</li>
<li>外键：InnoDB 支持外键约束；MyISAM 不支持。</li>
<li>存储：InnoDB 有聚簇索引（主键与数据同 B+Tree），MyISAM 主数据与索引分离（非聚簇）。</li>
<li>全文搜索：历史上 MyISAM 支持全文索引；新 MySQL 版本 InnoDB 也支持全文索引。</li>
<li>IO &amp; 性能：MyISAM 在简单读场景可能低延迟；InnoDB 在高并发写&#x2F;读混合时更好。</li>
</ul>
<p><strong>如何选择</strong>：</p>
<ul>
<li>需要事务&#x2F;并发写&#x2F;外键&#x2F;崩溃安全 → <strong>InnoDB</strong>。</li>
<li>只读或极少写、对数据一致性要求低、老系统或特殊查询（极短）→ MyISAM 可考虑，但现在建议首选 InnoDB。</li>
<li>如果是高速缓存性质短期数据可考虑 MEMORY。</li>
<li>总体建议：生产 OLTP 系统用 InnoDB。</li>
</ul>
<hr>
<h3 id="3-InnoDB-是如何存储数据的？"><a href="#3-InnoDB-是如何存储数据的？" class="headerlink" title="3. InnoDB 是如何存储数据的？"></a><strong>3. InnoDB 是如何存储数据的？</strong></h3><p>核心概念（实现层）：</p>
<ul>
<li><strong>表空间（tablespace）</strong>：InnoDB 用 tablespace 存储数据页与索引页。可以是共享系统表空间 (<code>ibdata1</code>) 或 <code>innodb_file_per_table=ON</code>（每表单文件 .ibd）。</li>
<li><strong>页（page）</strong>：默认页大小 16KB（可配置）。页是读写的最小单位，页里包含多个记录（row）与链表&#x2F;目录。</li>
<li><strong>B+ 树索引</strong>：<ul>
<li><strong>聚簇索引（clustered index）</strong>：主键索引就是数据的物理组织（叶子节点存放完整行）。若无主键，InnoDB 会选择第一个非 NULL 唯一键或内部生成隐式列作为聚簇键。</li>
<li><strong>二级索引（secondary index）</strong>：非主键索引的叶子存放索引列 + <strong>主键值</strong>（作为指向聚簇索引的“指针”）；因此二级索引查到行后还需回聚簇索引读取完整行（称回表）。</li>
</ul>
</li>
<li><strong>事务日志</strong>：<ul>
<li><strong>Redo log（重做日志）</strong>：预写日志（WAL），用于崩溃恢复（ib_logfile*）。</li>
<li><strong>Undo log（回滚&#x2F;MVCC）</strong>：用于多版本并发控制（MVCC），支持一致性读（快照读），undo 存在系统表空间或独立 undo tablespace。</li>
<li><strong>Doublewrite buffer</strong>：写入磁盘前把页写入 doublewrite 区，防止半页写入导致损坏（提高崩溃安全）。</li>
</ul>
</li>
<li><strong>Buffer Pool</strong>：InnoDB 的核心缓存区，缓存数据页和索引页，读写都尽量在 buffer pool 完成以减 IO。</li>
<li><strong>MVCC（多版本并发）</strong>：<ul>
<li>通过在行上或 undo-log 中保存旧版本来实现一致性读（Read View）。读写隔离依赖 undo 来提供快照。</li>
<li>默认隔离级别 <code>REPEATABLE-READ</code>（MySQL 特性：使用间隙锁 + next-key lock 以避免幻读）。</li>
</ul>
</li>
<li><strong>插入缓冲&#x2F;变更缓冲（change buffer&#x2F;insert buffer）</strong>：延迟索引操作合并以提高插入吞吐（针对非聚簇索引）。</li>
<li><strong>行格式</strong>：REDUNDANT&#x2F;COMPACT&#x2F;DYNAMIC&#x2F;COMPRESSED；大字段（BLOB&#x2F;TEXT 或超长 VARCHAR）可 off-page（只在行内留 20 字节指针），减少行膨胀。</li>
</ul>
<hr>
<h3 id="4-MySQL-一行记录是怎么存储的？"><a href="#4-MySQL-一行记录是怎么存储的？" class="headerlink" title="4. MySQL 一行记录是怎么存储的？"></a><strong>4. MySQL 一行记录是怎么存储的？</strong></h3><p>以 <strong>InnoDB</strong> 为例（聚簇行存放在 B+ 树叶子页）：</p>
<ul>
<li><strong>页头 + 页目录（slot） + 记录区 + 空闲区 + 页尾&#x2F;校验</strong>。页头包含 LSN、Page number 等元信息；页尾可能有校验信息。</li>
<li><strong>记录格式</strong>（简化）：<ul>
<li>记录头（记录类型、链表指针、事务信息、记录长度）。</li>
<li><strong>NULL 位图</strong>（标记哪些列为 NULL）。</li>
<li><strong>记字段数据</strong>：固定长度列（定长）先写，变长列（VARCHAR、BLOB）写长度与内容；若内容很长，InnoDB 的 DYNAMIC&#x2F;COMPRESSED 行格式会把大字段存放到外部 overflow 页，行内只保留指针（通常 20 字节）。</li>
</ul>
</li>
<li><strong>二级索引条目</strong>：只包含索引列 + 主键（作为定位聚簇行的“引用”）。因此二级索引不会重复存储全部行内容，节省空间但会导致回表。</li>
</ul>
<p><strong>MyISAM</strong>：每行存在数据文件（.MYD），索引在 .MYI；没有聚簇索引，索引里存偏移量指向数据文件中的行。</p>
<hr>
<h3 id="5-详细描述一条-SQL-在-MySQL-中的执行过程"><a href="#5-详细描述一条-SQL-在-MySQL-中的执行过程" class="headerlink" title="5. 详细描述一条 SQL 在 MySQL 中的执行过程"></a><strong>5. 详细描述一条 SQL 在 MySQL 中的执行过程</strong></h3><p>高层步骤（客户端到存储引擎）：</p>
<ol>
<li><strong>客户端层</strong>：应用通过连接（Connector&#x2F;J 等）发送 SQL 到 MySQL Server（线程池&#x2F;one-thread-per-connection）。</li>
<li><strong>连接与认证</strong>：MySQL 验证账号&#x2F;权限（authentication plugin、grant tables）。</li>
<li><strong>解析（Parser）</strong>：SQL 被词法&#x2F;语法解析器转换为解析树（parse tree），检查语法正确性。</li>
<li><strong>预处理 &#x2F; 语义分析</strong>：解析树变成 parse tree 的语义检查，解析表名、列名是否存在，权限检查。</li>
<li><strong>重写&#x2F;视图&#x2F;子查询优化</strong>：展开视图、优化子查询（视具体版本，子查询可重写为 JOIN）、派生表（derived table）处理（有时会创建临时表）。</li>
<li><strong>查询优化器（Optimizer）</strong>：<ul>
<li>根据表统计信息、索引、条件，生成若干候选执行计划（访问路径、连接顺序、连接算法）。</li>
<li>使用代价模型（cost estimates）选择最优计划。会决定是否使用索引、哪种索引、join 顺序等。</li>
</ul>
</li>
<li><strong>执行引擎（Execution Engine）&#x2F;计划执行</strong>：<ul>
<li>根据执行计划逐步执行：遍历表、应用 WHERE、做 JOIN、聚合 GROUP BY、排序 ORDER BY、生成结果行。</li>
<li>在执行过程中与**存储引擎（Handler API）**交互做实际 IO（InnoDB、MyISAM）。</li>
</ul>
</li>
<li><strong>存储引擎层</strong>（如 InnoDB）：<ul>
<li>执行页读取、索引查找、事务隔离控制（锁、MVCC）、读写缓冲、写日志（redo）等底层操作。</li>
</ul>
</li>
<li><strong>返回结果</strong>：执行引擎把结果发送回客户端；若是写操作，会提交事务（若是自动提交或显式提交），redo log 刷盘（强制或延迟由配置决定）。</li>
<li><strong>统计&#x2F;缓存更新</strong>：query cache（若启用且有效，但在新版本中已弃用&#x2F;移除），慢查询记录等。</li>
</ol>
<p><strong>注意</strong>：实际过程包含很多优化（例如谓词下推、索引条件下推、block nested loop、batched key access、histograms 等），不同 MySQL 版本细节不同，但总体流程如上。</p>
<hr>
<h3 id="6-MySQL-的查询优化器如何选择执行计划？"><a href="#6-MySQL-的查询优化器如何选择执行计划？" class="headerlink" title="6. MySQL 的查询优化器如何选择执行计划？"></a><strong>6. MySQL 的查询优化器如何选择执行计划？</strong></h3><p>核心机制：</p>
<ul>
<li><strong>基于成本的优化器（CBO）</strong>：使用统计信息（表基数、索引基数、分布直方图等）估算每个访问路径（全表扫描、索引范围、索引唯一查找等）的代价（IO、CPU）。</li>
<li><strong>统计信息来源</strong>：通过 <code>ANALYZE TABLE</code> 更新，也会由执行过程中动态采样。MySQL 8 引入了更精细的直方图支持（更好估算非均匀分布列）。</li>
<li><strong>选择因素</strong>：<ul>
<li>索引可用性（是否存在合适索引、是否为覆盖索引）。</li>
<li>选择性（selectivity）——该索引能筛掉多少行。</li>
<li>表大小（行数）、列基数。</li>
<li>连接顺序、连接算法（Nested-Loop 为主；有时使用 Index Merge、Block Nested Loop、Hash Join 在某些版本&#x2F;场景可用）。</li>
<li>是否可以进行 <code>index-only</code>（覆盖索引）避免回表。</li>
<li>物化临时表 vs on-the-fly 的成本（派生表策略）。</li>
</ul>
</li>
<li><strong>搜索策略</strong>：MySQL 会根据 join 数量与成本在一定规则下枚举 join 顺序（对较多表会采用启发式或限制性搜索以避免指数爆炸）。</li>
<li><strong>优化器提示与开关</strong>：可以通过 <code>USE INDEX</code> &#x2F; <code>FORCE INDEX</code> &#x2F; <code>STRAIGHT_JOIN</code> &#x2F; <code>OPTIMIZER_SWITCH</code> 等影响计划选择。</li>
<li><strong>上手实践</strong>：使用 <code>EXPLAIN</code> &#x2F; <code>EXPLAIN ANALYZE</code>（MySQL 8）查看执行计划、识别 full table scan、filesort、temporary 的使用，并据此调整索引&#x2F;SQL 重写&#x2F;统计信息。</li>
</ul>
<hr>
<h3 id="7-SQL-中-SELECT、FROM、JOIN、WHERE、GROUP-BY、HAVING、ORDER-BY、LIMIT-的执行顺序？"><a href="#7-SQL-中-SELECT、FROM、JOIN、WHERE、GROUP-BY、HAVING、ORDER-BY、LIMIT-的执行顺序？" class="headerlink" title="7. SQL 中 SELECT、FROM、JOIN、WHERE、GROUP BY、HAVING、ORDER BY、LIMIT 的执行顺序？"></a><strong>7. SQL 中 <code>SELECT</code>、<code>FROM</code>、<code>JOIN</code>、<code>WHERE</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>ORDER BY</code>、<code>LIMIT</code> 的执行顺序？</strong></h3><p>逻辑&#x2F;标准的<strong>处理顺序（简化）</strong>：</p>
<ol>
<li><strong>FROM</strong>（包含 JOIN，并先应用 ON 条件用于连接裁剪&#x2F;过滤）</li>
<li><strong>WHERE</strong>（行级过滤）</li>
<li><strong>GROUP BY</strong>（分组）</li>
<li><strong>HAVING</strong>（对分组结果的过滤）</li>
<li><strong>SELECT</strong>（投影、表达式计算）</li>
<li><strong>DISTINCT</strong>（去重，如果有）</li>
<li><strong>ORDER BY</strong>（排序）</li>
<li><strong>LIMIT</strong>（限制返回行数）</li>
</ol>
<p>注意：</p>
<ul>
<li><strong>子查询 &#x2F; 派生表</strong> 在其内部先执行（或由优化器重写）。</li>
<li>优化器在物理执行上可能重排序或采用更有效算法（例如把谓词下推到存储引擎），但逻辑意义遵循以上顺序。</li>
<li><code>ON</code> 与 <code>WHERE</code> 的区别：<code>ON</code> 常用于连接条件（可以影响是否为外连接保留行）；<code>WHERE</code> 在连接后对整行做最终过滤。</li>
</ul>
<hr>
<h3 id="8-MySQL-中的数据排序（ORDER-BY）是如何实现的？"><a href="#8-MySQL-中的数据排序（ORDER-BY）是如何实现的？" class="headerlink" title="8. MySQL 中的数据排序（ORDER BY）是如何实现的？"></a><strong>8. MySQL 中的数据排序（ORDER BY）是如何实现的？</strong></h3><p>两种主要方式：</p>
<ol>
<li><strong>走索引顺序</strong>（避免 filesort）：<ul>
<li>当 <code>ORDER BY</code> 的列正好与一个可用索引的左前缀相匹配，并且排序方向与索引一致，且查询没有要求额外的排序列或必须在不同表之间合并排序，优化器可以直接按照索引读取数据，<strong>无需显式排序</strong>（称为 “Using index”）。</li>
<li>覆盖索引（索引包含所有 SELECT 列）还能避免回表。</li>
</ul>
</li>
<li><strong>Filesort（外部排序）</strong>：<ul>
<li>MySQL 会把需要排序的记录（或键）取出来，放到内存（sort_buffer）里排序；如果超出内存，会使用临时文件（磁盘）进行外部排序。EXPLAIN 会显示 <code>Using filesort</code>。</li>
<li>实现常见为 quicksort&#x2F;mergesort 的变体：对于 large datasets，会分段排序并归并（外部排序）。</li>
<li>若查询还需要 group by + order by，会可能生成临时表（<code>Using temporary</code>），再排序。</li>
</ul>
</li>
<li><strong>优化点</strong>：<ul>
<li>为 ORDER BY 列建立合适的索引（左前缀），并尽量让查询使用覆盖索引，能显著避免 filesort。</li>
<li>减少 sort_buffer_size 不要盲目增大；更好的方法是优化索引与 SQL。</li>
</ul>
</li>
<li><strong>EXPLAIN 线索</strong>：<ul>
<li><code>Using filesort</code> → 排序发生（可能开销大）。</li>
<li><code>Using index</code> 与 <code>Using where</code> 等组合能提示是否能走索引避免排序。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="9-为什么阿里巴巴-Java-手册不推荐使用存储过程？"><a href="#9-为什么阿里巴巴-Java-手册不推荐使用存储过程？" class="headerlink" title="9. 为什么阿里巴巴 Java 手册不推荐使用存储过程？"></a><strong>9. 为什么阿里巴巴 Java 手册不推荐使用存储过程？</strong></h3><p>基于工程实践的常见理由（多组织采用一致性观点）：</p>
<ul>
<li><strong>可维护性差</strong>：业务逻辑分散在应用代码与数据库存储过程里，版本控制、代码 review、测试、CI&#x2F;CD 管理不便。</li>
<li><strong>可测试性差</strong>：存储过程难以做单元测试，缺少成熟的构建&#x2F;测试生态。</li>
<li><strong>可移植性差</strong>：不同数据库的存储过程语法差异大，锁定供应商（vendor lock-in）。</li>
<li><strong>复杂逻辑不适合</strong>：复杂业务逻辑写在 DB 层会降低可读性、让 DB 成为业务瓶颈。</li>
<li><strong>伸缩性限制</strong>：数据库的横向扩展（读写分离、分库分表）会使存储过程管理复杂；应用层更易于水平扩展。</li>
<li><strong>运维与安全</strong>：频繁修改存储过程需要谨慎部署，不当操作可能影响全表数据。</li>
</ul>
<p><strong>但并不是绝对禁止</strong>：存储过程在某些场景仍有价值（复杂的数据库内聚合计算、减少网络往返、一些数据临近处理），关键是权衡与团队能否做好治理（版本管理、测试与文档）。</p>
<hr>
<h3 id="10-如何实现数据库不停服迁移？"><a href="#10-如何实现数据库不停服迁移？" class="headerlink" title="10. 如何实现数据库不停服迁移？"></a><strong>10. 如何实现数据库不停服迁移？</strong></h3><p>常见做法与工具（线上敏感操作的通用流程）：</p>
<h4 id="A-Schema-变更（DDL-无停机化策略）："><a href="#A-Schema-变更（DDL-无停机化策略）：" class="headerlink" title="A. Schema 变更（DDL 无停机化策略）："></a><strong>A. Schema 变更（DDL 无停机化策略）</strong>：</h4><ul>
<li>使用在线 DDL 工具：<strong>gh-ost</strong>、<strong>pt-online-schema-change（pt-osc）</strong>（Percona），原理通常是：<ol>
<li>创建目标结构的 shadow 表（新表）。</li>
<li>全量复制旧表数据到新表（分批、无锁读取）。</li>
<li>使用触发器或 binlog 双写在复制期间捕获并应用变更（保持同步）。</li>
<li>切换（RENAME TABLE 原子操作）完成替换（极短时间锁），或利用应用层路由切换表名。</li>
<li>清理旧表与中间对象。</li>
</ol>
</li>
<li>MySQL 新版本支持 <strong>instant &#x2F; in-place DDL</strong>（对部分操作如某些 ADD COLUMN 可瞬时完成），要根据 MySQL 版本能力安排。</li>
</ul>
<h4 id="B-数据迁移（不停服搬库）："><a href="#B-数据迁移（不停服搬库）：" class="headerlink" title="B. 数据迁移（不停服搬库）："></a><strong>B. 数据迁移（不停服搬库）</strong>：</h4><ul>
<li>使用逻辑复制&#x2F;同步：<ul>
<li>使用 <strong>replica</strong>（基于 binlog）把流量从老库写到新库，切换读写角色（master-master &#x2F; master-slave 切换），或多写短期双写，最后切走流量。</li>
<li>使用工具：<strong>gh-ost</strong>, <strong>pt-osc</strong>, <strong>MaxScale</strong>, <strong>Canal</strong>, <strong>Debezium</strong>（CDC）等。</li>
</ul>
</li>
<li>使用物理复制&#x2F;备份恢复：<ul>
<li>使用 <code>Percona XtraBackup</code> 做热备恢复到新实例，再提升为主库（需注意 binlog 位点迁移与增量）。</li>
</ul>
</li>
<li><strong>切换策略</strong>：<ul>
<li>先做读切换：把只读流量切到新库进行验证。</li>
<li>再短暂降级写或使用双写&#x2F;幂等写策略，最终切换写主。</li>
<li>最后回放或同步最后的 binlog。</li>
</ul>
</li>
</ul>
<h4 id="实战注意："><a href="#实战注意：" class="headerlink" title="实战注意："></a><strong>实战注意</strong>：</h4><ul>
<li><strong>自动化、灰度</strong>：分阶段灰度切换，避免一次性切换全量流量。</li>
<li><strong>监控与回滚</strong>：详细监控（延迟、错误率），支持快速回滚方案。</li>
<li><strong>数据一致性验证</strong>：使用 checksum（pt-table-checksum）等验证数据一致性。</li>
<li><strong>schema migration 工具链</strong>：Liquibase&#x2F;Flyway 管理 schema 版本，配合在线 DDL。</li>
<li><strong>压力与资源</strong>：复制过程中会对源库添加额外负载，提前评估资源与窗口。</li>
</ul>
<hr>
<h3 id="11-UNSIGNED-属性有什么用？"><a href="#11-UNSIGNED-属性有什么用？" class="headerlink" title="11. UNSIGNED 属性有什么用？"></a><strong>11. <code>UNSIGNED</code> 属性有什么用？</strong></h3><ul>
<li>只适用于整数类型（TINYINT&#x2F;SMALLINT&#x2F;MEDIUMINT&#x2F;INT&#x2F;BIGINT）：<code>UNSIGNED</code> 表示无符号，<strong>范围从 0 到 2^N − 1</strong>（例如 INT UNSIGNED 范围 0 ~ 4294967295）。</li>
<li><strong>作用</strong>：把同样字节数的上限往正数方向翻倍（允许更大正数），但不能存负数。</li>
<li><strong>注意点</strong>：<ul>
<li>查询&#x2F;比较时注意有符号与无符号的比较规则（有时会隐式转换）。</li>
<li>与应用语言映射（Java 的 int 是有符号）要小心越界与类型不匹配。</li>
<li>存储大小（字节数）不变，只有数值范围变化。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="12-MySQL-中-int-11-的-11-表示什么？"><a href="#12-MySQL-中-int-11-的-11-表示什么？" class="headerlink" title="12. MySQL 中 int(11) 的 11 表示什么？"></a><strong>12. MySQL 中 <code>int(11)</code> 的 11 表示什么？</strong></h3><ul>
<li><strong><code>(11)</code> 只是显示宽度（display width）</strong>，仅在与 <code>ZEROFILL</code> 一起使用时生效（会用前导零补齐到显示宽度）。并<strong>不影响存储大小或范围</strong>。</li>
<li>实际存储仍由 INT 类型决定（4 字节）。</li>
<li>从 MySQL 8.0.17 起，整数显示宽度已被弃用（除了 TINYINT(1) 的布尔习惯），因此不要依赖这个数字表示精度或范围。</li>
</ul>
<hr>
<h3 id="13-CHAR-与-VARCHAR-有何区别？"><a href="#13-CHAR-与-VARCHAR-有何区别？" class="headerlink" title="13. CHAR 与 VARCHAR 有何区别？"></a><strong>13. <code>CHAR</code> 与 <code>VARCHAR</code> 有何区别？</strong></h3><ul>
<li><strong>CHAR(n)</strong>：<ul>
<li>固定长度（n 个字符），存储时不足部分用空格填充（右填充）。读取时空格可能被忽略（在比较与一些行为中）。</li>
<li>适合长度固定的小字段（例如国家码、固定码）。</li>
<li>存取更简单、性能稳定（少指针&#x2F;长度字节开销）。</li>
</ul>
</li>
<li><strong>VARCHAR(n)</strong>：<ul>
<li>可变长度，用 1 或 2 字节保存长度前缀（长度 ≤ 255 用 1 字节，≥256 用 2 字节，取决于实际定义与字符集），存储仅占用实际字符 + 前缀字节。</li>
<li>适合变长字符串（名字、描述等）。</li>
</ul>
</li>
<li><strong>存储与索引注意</strong>：<ul>
<li>InnoDB 行最大长度限制（受整行 65KB 限制影响），长 VARCHAR 可能 off-page（BLOB&#x2F;TEXT 处理类似）。</li>
<li>CHAR 比 VARCHAR 更适合短且固定的值；VARCHAR 更节省空间但带有长度前缀。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="14-VARCHAR-100-与-VARCHAR-10-的区别？"><a href="#14-VARCHAR-100-与-VARCHAR-10-的区别？" class="headerlink" title="14. VARCHAR(100) 与 VARCHAR(10) 的区别？"></a><strong>14. <code>VARCHAR(100)</code> 与 <code>VARCHAR(10)</code> 的区别？</strong></h3><ul>
<li>主要差别是<strong>允许的最大长度</strong>（100 vs 10 字符），以及索引前缀限制和潜在行大小影响。</li>
<li><strong>实际影响</strong>：<ul>
<li>若使用 UTF8&#x2F;utf8mb4，100 字符可能最多占用 400 字节（4 bytes&#x2F;char），会影响最大行大小与索引长度（索引长度以字节计算）。</li>
<li>索引时若 <code>VARCHAR(100)</code> 太长，可能需要指定索引前缀（<code>INDEX(col(50))</code>）以不超过索引长度限制。</li>
<li>性能上，若字段大且频繁被读取，IO 与缓存压力更大。</li>
</ul>
</li>
<li><strong>建议</strong>：为字段设置合理上限（既能容纳业务数据又不过分浪费），并考虑字符集的字节长度。</li>
</ul>
<hr>
<h3 id="15-DECIMAL-与-FLOAT-DOUBLE-的区别？"><a href="#15-DECIMAL-与-FLOAT-DOUBLE-的区别？" class="headerlink" title="15. DECIMAL 与 FLOAT/DOUBLE 的区别？"></a><strong>15. <code>DECIMAL</code> 与 <code>FLOAT/DOUBLE</code> 的区别？</strong></h3><ul>
<li><strong>DECIMAL</strong>：<ul>
<li><strong>定点（精确）数值</strong>，用于金融场景避免舍入误差（用人眼可理解的十进制精度）。在 MySQL 内部通常以压缩的二进制形式或 BCD packs 存储（每几个十进制位打包），不是 IEEE 浮点。</li>
<li>定义如 <code>DECIMAL(M,D)</code>：总位数 M，小数位 D（注意 M 包括小数点两侧总位数）。</li>
<li>优点：精确、适合金钱。缺点：运算可能比浮点慢，存储更复杂。</li>
</ul>
</li>
<li><strong>FLOAT &#x2F; DOUBLE</strong>：<ul>
<li><strong>浮点数（近似）</strong>，基于 IEEE 754，表示为二进制近似。<code>FLOAT</code> 单精度，<code>DOUBLE</code> 双精度。</li>
<li>适合科学计算、需要范围大但对微小舍入误差可容忍的场景。</li>
</ul>
</li>
<li><strong>结论</strong>：<strong>存金额用 DECIMAL（或整数 cents）</strong>，浮点用于近似计算。</li>
</ul>
<hr>
<h3 id="16-DATETIME-与-TIMESTAMP-的区别？"><a href="#16-DATETIME-与-TIMESTAMP-的区别？" class="headerlink" title="16. DATETIME 与 TIMESTAMP 的区别？"></a><strong>16. <code>DATETIME</code> 与 <code>TIMESTAMP</code> 的区别？</strong></h3><ul>
<li><strong>存储范围与字节</strong>：<ul>
<li><code>DATETIME</code>：可表示 <code>&#39;1000-01-01 00:00:00&#39;</code> 到 <code>&#39;9999-12-31 23:59:59&#39;</code>（8 字节传统实现；自 5.6 支持微秒扩展）。</li>
<li><code>TIMESTAMP</code>：通常以 UTC 的 Unix 时间戳为基础（较早实现 4 字节，范围受限制大约 1970-2038 在某些实现），MySQL 新版本扩展也有改进。</li>
</ul>
</li>
<li><strong>时区处理</strong>：<ul>
<li><code>TIMESTAMP</code> 会根据连接&#x2F;服务器时区进行存储时转换（存储为 UTC，显示时转换为当前会话时区），因此适合表示“瞬间（时点）”。</li>
<li><code>DATETIME</code> 不会随时区自动转换，存储的是“本地时间点”。适合表示固定本地时间，如日程表（不希望时区转换）。</li>
</ul>
</li>
<li><strong>默认值 &#x2F; CURRENT_TIMESTAMP</strong>：<code>TIMESTAMP</code> 更早支持 <code>CURRENT_TIMESTAMP</code> 作为默认值&#x2F;自动更新；现代 MySQL 已允许 <code>DATETIME</code> 使用 <code>CURRENT_TIMESTAMP</code>（从 5.6.5 起）。</li>
<li><strong>建议</strong>：<ul>
<li>表示事件时间点（跨时区）使用 <code>TIMESTAMP</code> 或统一存 UTC（并在应用层转换）。</li>
<li>表示本地日历时间或无时区语义用 <code>DATETIME</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="17-NULL-与-有什么区别？"><a href="#17-NULL-与-有什么区别？" class="headerlink" title="17. NULL 与 &#39;&#39; 有什么区别？"></a><strong>17. <code>NULL</code> 与 <code>&#39;&#39;</code> 有什么区别？</strong></h3><ul>
<li><code>NULL</code>：<strong>未知&#x2F;缺失值</strong>；不是值，表示“没有值”。<ul>
<li>与任何比较（<code>=</code>, <code>&lt;&gt;</code>）的结果为 <code>NULL</code>（即未知）；必须使用 <code>IS NULL</code> &#x2F; <code>IS NOT NULL</code> 判断。</li>
<li>聚合函数（如 <code>SUM</code>, <code>AVG</code>）通常忽略 NULL 值；<code>COUNT(col)</code> 不计 NULL，<code>COUNT(*)</code> 计行数包括 NULL 列。</li>
</ul>
</li>
<li><code>&#39;&#39;</code>：空字符串，是一种确定的值（长度 0 的字符串），不等于 NULL。</li>
<li><strong>索引与存储</strong>：NULL 在索引中有特殊表示；空字符串按照字符存储。</li>
<li><strong>实践</strong>：语义不同 — 把“未填写”与“填写为空字符串”区分开来通常更有意义。尽量选择一种约定并统一（例如允许 NULL 表示未填写）。</li>
</ul>
<hr>
<h3 id="18-Boolean-类型在-MySQL-中如何表示？"><a href="#18-Boolean-类型在-MySQL-中如何表示？" class="headerlink" title="18. Boolean 类型在 MySQL 中如何表示？"></a><strong>18. Boolean 类型在 MySQL 中如何表示？</strong></h3><ul>
<li>MySQL 中没有独立的原生 <code>BOOLEAN</code> 存储类型；<code>BOOLEAN</code> 是 <code>TINYINT(1)</code> 的别名（0 假&#x2F;false，非 0 为 true 通常视为 true）。</li>
<li>也可以用 <code>BIT(1)</code> 来代表布尔（但读写和表达上需要注意转换）。</li>
<li>实践：习惯用 <code>TINYINT(1)</code> 或在应用层把 0&#x2F;1 映射为 false&#x2F;true。</li>
</ul>
<hr>
<h3 id="19-为什么不推荐使用-TEXT-和-BLOB？"><a href="#19-为什么不推荐使用-TEXT-和-BLOB？" class="headerlink" title="19. 为什么不推荐使用 TEXT 和 BLOB？"></a><strong>19. 为什么不推荐使用 <code>TEXT</code> 和 <code>BLOB</code>？</strong></h3><p><strong>原因与权衡</strong>：</p>
<ul>
<li><strong>索引限制</strong>：不能对整列做索引（需要前缀索引），并且索引长度受限（与字符集、InnoDB 页布局相关）；全文检索需专门的全文索引或 ElasticSearch。</li>
<li><strong>性能与 IO</strong>：大对象（LOB）多数情况下会被存放到页外（off-page），增加额外 IO 与指针回访成本；排序&#x2F;分组涉及临时表时可能导致大量磁盘 I&#x2F;O（临时表落盘）。</li>
<li><strong>内存&#x2F;缓存问题</strong>：查询含大字段会拉大内存使用（临时表、buffers、网络传输），影响并发能力。</li>
<li><strong>可维护性</strong>：大对象在备份&#x2F;恢复&#x2F;复制时显著增加备份大小与时间。</li>
<li><strong>替代方案</strong>：若文件较大（图片、音频、视频），通常推荐把文件放在对象存储（S3&#x2F;OSS）或文件系统，并在 DB 中保存引用 URL&#x2F;元数据；若确实需要 DB 存储（事务性要求），可以用 BLOB，但需注意分块&#x2F;流式处理。</li>
</ul>
<p><strong>实践建议</strong>：短文本用 <code>VARCHAR</code>；长文本搜索用专门搜索引擎（Elasticsearch）或 InnoDB 的全文索引；大二进制数据建议外部存储。</p>
<hr>
<h3 id="20-在-MySQL-中存储金额应使用什么数据类型？"><a href="#20-在-MySQL-中存储金额应使用什么数据类型？" class="headerlink" title="20. 在 MySQL 中存储金额应使用什么数据类型？"></a><strong>20. 在 MySQL 中存储金额应使用什么数据类型？</strong></h3><ul>
<li><strong>推荐：<code>DECIMAL(precision, scale)</code></strong>（例如 <code>DECIMAL(13,2)</code> 或 <code>DECIMAL(10,2)</code> 视业务而定），因为 DECIMAL 提供精确的十进制表示，避免浮点舍入误差。</li>
<li><strong>备选</strong>：整型存“最小单位”（例如 cents），用 <code>INT</code> 或 <code>BIGINT</code> 存储（性能好，简单准确），显示时按 100&#x2F;1000 转换。</li>
<li><strong>建议</strong>：选定单位与精度并在全系统一致使用（数据库、API、前端）。</li>
</ul>
<hr>
<h3 id="21-MySQL-如何存储-IP-地址？"><a href="#21-MySQL-如何存储-IP-地址？" class="headerlink" title="21. MySQL 如何存储 IP 地址？"></a><strong>21. MySQL 如何存储 IP 地址？</strong></h3><ul>
<li><p><strong>IPv4</strong>：</p>
<ul>
<li><p>存为整数：<code>INT UNSIGNED</code> + <code>INET_ATON()</code> &#x2F; <code>INET_NTOA()</code> 函数转换。优点：占用 4 字节、索引速度快。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> t (ip) <span class="keyword">VALUES</span> (INET_ATON(<span class="string">&#x27;192.168.0.1&#x27;</span>));</span><br><span class="line"><span class="keyword">SELECT</span> INET_NTOA(ip) <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>IPv6</strong>：</p>
<ul>
<li>使用 <code>VARBINARY(16)</code>（或 <code>BINARY(16)</code>），使用 <code>INET6_ATON()</code> &#x2F; <code>INET6_NTOA()</code> 进行转换（兼容 IPv4&#x2F;IPv6）。也可用 <code>CHAR(39)</code> 存文本表现，但二进制更紧凑且便于索引。</li>
</ul>
</li>
<li><p><strong>注意</strong>：比较与排序最好保持二进制&#x2F;整数形式，减少字符串处理开销；存储时要考虑字节序（INET_ATON&#x2F;NTOA 处理好）。</p>
</li>
</ul>
<hr>
<h3 id="22-什么是数据库视图？"><a href="#22-什么是数据库视图？" class="headerlink" title="22. 什么是数据库视图？"></a><strong>22. 什么是数据库视图？</strong></h3><ul>
<li><strong>视图（VIEW）</strong>：基于 SQL 查询的虚拟表，定义后可以像表一样查询。视图并不总是存储数据（除非是物化视图，MySQL 本身不原生支持物化视图）。</li>
<li><strong>用途</strong>：<ul>
<li>抽象复杂查询、封装业务逻辑、权限控制（给用户只读视图）、简化客户端查询。</li>
</ul>
</li>
<li><strong>类型</strong>：<ul>
<li><strong>可更新视图</strong>：在满足一定条件时（单表、无聚合、无 DISTINCT、无 GROUP BY、无 LIMIT 等）可以通过视图执行 INSERT&#x2F;UPDATE&#x2F;DELETE。</li>
<li><strong>不可更新视图</strong>：含聚合、分组、连接等，不能直接更新。</li>
</ul>
</li>
<li><strong>性能</strong>：视图是查询的“别名”，执行时会把视图展开为真实查询，复杂视图会带来性能影响；对于频繁计算的大查询，可以考虑物化策略（手工维护的物化表）。</li>
</ul>
<hr>
<h3 id="23-什么是数据库游标？"><a href="#23-什么是数据库游标？" class="headerlink" title="23. 什么是数据库游标？"></a><strong>23. 什么是数据库游标？</strong></h3><ul>
<li><strong>游标（Cursor）</strong>：在存储过程&#x2F;函数或数据库会话中用于逐行处理结果集的机制。游标允许你在 PL&#x2F;SQL&#x2F;存储过程里按顺序取出行并逐行处理。</li>
<li><strong>MySQL 游标特点</strong>：<ul>
<li>在存储过程中 <code>DECLARE cursor_name CURSOR FOR select_statement; OPEN cursor_name; FETCH cursor_name INTO ...; CLOSE cursor_name;</code></li>
<li>MySQL 的游标通常是<strong>只进&#x2F;只读（forward-only, read-only）</strong>，不像高级 DB（Oracle）支持可滚动游标。</li>
</ul>
</li>
<li><strong>使用场景</strong>：需要逐行处理复杂逻辑、触发器或批量逐行迁移（但通常行处理效率差，优先考虑集合式 SQL 方案）。</li>
<li><strong>性能提示</strong>：尽量避免在大数据量上使用游标逐行处理，改为批量 SQL 或应用层并行处理更高效。</li>
</ul>
<hr>
<h3 id="24-为什么不建议直接存储大对象（图片-音频-视频）？"><a href="#24-为什么不建议直接存储大对象（图片-音频-视频）？" class="headerlink" title="24. 为什么不建议直接存储大对象（图片 &#x2F; 音频 &#x2F; 视频）？"></a><strong>24. 为什么不建议直接存储大对象（图片 &#x2F; 音频 &#x2F; 视频）？</strong></h3><p><strong>主要问题</strong>：</p>
<ul>
<li><strong>备份&#x2F;恢复压力</strong>：数据库备份会包含这些大文件，导致备份体积和恢复时间急剧上升。</li>
<li><strong>性能与 IO</strong>：读写 BLOB 需大量 IO，影响数据库的整体响应性能；大对象导致内存&#x2F;网络传输压力。</li>
<li><strong>可扩展性</strong>：数据库扩容成本高；通常对象存储（S3&#x2F;OSS）更易横向扩展、CDN 分发。</li>
<li><strong>费用</strong>：托管 DB 存储成本高于对象存储系统。</li>
<li><strong>替代方案</strong>：将大对象存对象存储或 CDN，数据库仅保存元数据（文件路径&#x2F;URL、校验信息、版本）。</li>
</ul>
<p><strong>但有例外</strong>：若强事务一致性要求非常高或小文件数量有限，存 BLOB 有时更方便（例如需要事务回滚把文件也回滚），需评估权衡与方案。</p>
<hr>
<h3 id="25-数据库的三大范式（1NF-2NF-3NF）是什么？"><a href="#25-数据库的三大范式（1NF-2NF-3NF）是什么？" class="headerlink" title="25. 数据库的三大范式（1NF &#x2F; 2NF &#x2F; 3NF）是什么？"></a><strong>25. 数据库的三大范式（1NF &#x2F; 2NF &#x2F; 3NF）是什么？</strong></h3><p><strong>第一范式（1NF）</strong>：</p>
<ul>
<li>要求表中每个字段都是原子值（atomic），不能是集合或重复列。</li>
<li>例如，不应该有 <code>phones</code> 字段保存多个电话号码（而应该拆成多行或独立表）。</li>
</ul>
<p><strong>第二范式（2NF）</strong>：</p>
<ul>
<li>在满足 1NF 的前提下，<strong>每个非主属性完全依赖于主键</strong>（解决部分依赖）。</li>
<li>针对复合主键：不能让非主属性只依赖于部分键。若有部分依赖，应拆表。</li>
</ul>
<p><strong>第三范式（3NF）</strong>：</p>
<ul>
<li>在 2NF 基础上，<strong>消除传递依赖</strong>（非主属性不能依赖于其他非主属性）。即每个非主属性直接依赖主键。</li>
<li>例如表 <code>order(order_id, customer_id, customer_name)</code>，<code>customer_name</code> 依赖于 <code>customer_id</code>（非主属性→非主属性依赖），应拆成 <code>customer</code> 表。</li>
</ul>
<p><strong>补充</strong>：</p>
<ul>
<li><strong>BCNF（Boyce–Codd NF）</strong> 更强，要求每个决定因素都是候选键。</li>
<li><strong>范式优点</strong>：减少数据冗余，避免更新异常（插入&#x2F;删除&#x2F;更新异常），提高数据一致性。</li>
<li><strong>范式代价 &#x2F; 实战</strong>：<ul>
<li>过度范式化会导致大量 join（性能开销），在 OLTP&#x2F;OLAP&#x2F;高性能场景常采用 <strong>适度反范式化</strong>（为查询性能牺牲部分冗余），并通过应用&#x2F;触发器保证一致性或使用 ETL 保持数据同步。</li>
<li>实际设计通常是「第三范式为主，针对性能热点做有控制的反范式化或采用缓存&#x2F;聚合表」。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="最后：实战建议（综合）"><a href="#最后：实战建议（综合）" class="headerlink" title="最后：实战建议（综合）"></a>最后：实战建议（综合）</h3><ul>
<li>生产数据库首选 <strong>InnoDB</strong>，设计表时优先考虑事务一致性与索引策略。</li>
<li>对 SQL 性能：学会用 <code>EXPLAIN</code> &#x2F; <code>EXPLAIN ANALYZE</code>、慢查询日志、profiling 工具（pt-query-digest）定位问题；避免 SELECT *、滥用子查询；合理设计索引与覆盖索引。</li>
<li>对大数据&#x2F;大对象：避免将大量二进制内容放 DB；使用对象存储 + DB 存元数据。</li>
<li>Schema 变更：使用 gh-ost&#x2F;pt-osc&#x2F;ONLINE DDL 工具实现不停服。</li>
<li>金额用 DECIMAL 或 integer cents；IP 用整型或 VARBINARY(16)；时间点用 TIMESTAMP（或统一存 UTC）。</li>
</ul>
<h2 id="JVM-牛客面经八股"><a href="#JVM-牛客面经八股" class="headerlink" title="JVM-牛客面经八股"></a>JVM-牛客面经八股</h2><h3 id="JVM结构图"><a href="#JVM结构图" class="headerlink" title="JVM结构图"></a>JVM结构图</h3><p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/16f4750982daa7b6%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/16f47509829e2b5b%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/16f4750983bf3620%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p>
<h3 id="创建一个新对象-内存分配流程"><a href="#创建一个新对象-内存分配流程" class="headerlink" title="创建一个新对象 内存分配流程"></a>创建一个新对象 内存分配流程</h3><p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/16f4750983d600e5%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/charlotte030710/blog_images/main/0082zybply1gc6fz21n8kj30u00wpn5v.jpg" alt="JVM 基础- JVM 内存结构| Java 全栈知识体系"></p>
<hr>
<h3 id="1-JVM-内存模型（运行时数据区）——深入"><a href="#1-JVM-内存模型（运行时数据区）——深入" class="headerlink" title="1) JVM 内存模型（运行时数据区）——深入"></a>1) JVM 内存模型（运行时数据区）——深入</h3><p>JVM 将运行时数据区分为<strong>线程私有</strong>和<strong>多线程共享</strong>两类。</p>
<p><strong>线程私有区域</strong></p>
<ul>
<li><strong>程序计数器（PC）</strong>：每线程一份，记录下一条要执行的字节码指令地址（用于执行字节码的分支控制）。如果线程在执行本地方法，该寄存器值为 undefined。</li>
<li><strong>虚拟机栈（JVM Stack）</strong>：每个线程一个栈，栈帧包含局部变量表、操作数栈、动态连接和方法返回地址。局部变量表保存基本类型和对象引用。栈溢出会抛出 <code>StackOverflowError</code>。</li>
<li><strong>本地方法栈（Native Stack）</strong>：专门用于处理本地方法（C&#x2F;C++实现）调用的栈（HotSpot 在实际实现上可与 JVM Stack 合并或分开实现）。</li>
</ul>
<p><strong>多线程共享区域</strong></p>
<ul>
<li><strong>堆（Heap）</strong>：存放对象实例与数组，是 GC 管理的主要区域。堆细分为**年轻代（Eden + Survivor0&#x2F;1）*<em>和*<em>老年代</em></em>（Tenured）。堆还可能包含永久代或元空间（见下）。</li>
<li><strong>方法区（Method Area）&#x2F;元空间（Metaspace）</strong>：存放类的元数据（Class 对象、常量池、静态变量、方法字节码）。JDK 8 起把 PermGen 替换为 Metaspace（在本地内存），可以通过 <code>-XX:MaxMetaspaceSize</code> 限制。</li>
<li><strong>直接内存（Direct Memory）</strong>：不在 JVM 堆中，由 <code>ByteBuffer.allocateDirect()</code> 等分配。虽然不在堆中，但会被本地内存耗尽导致 OOME（需要监控 native memory）。</li>
</ul>
<p><strong>重要细节</strong></p>
<ul>
<li>对象头（Mark Word + Klass Pointer）包含 GC 元信息（锁标记、哈希码、分代年龄等）和类指针（或 compressed klass pointer）。</li>
<li>对齐与压缩：<code>-XX:+UseCompressedOops</code>（默认常开）影响对象引用大小与堆布局。</li>
<li>类加载器与类元数据泄露：类无法卸载的常见原因是类加载器仍有引用（静态集合、线程池、ThreadLocal 导致的 classloader leak）。</li>
</ul>
<hr>
<h3 id="2-JVM-的垃圾回收算法"><a href="#2-JVM-的垃圾回收算法" class="headerlink" title="2) JVM 的垃圾回收算法"></a>2) JVM 的垃圾回收算法</h3><p>JVM 中常用&#x2F;经典的 GC 算法原则与实现：</p>
<p><strong>基础算法</strong></p>
<ul>
<li><strong>引用计数（Reference Counting）</strong>：为每个对象维护引用计数，计数为 0 时回收。缺点：无法处理循环引用。<em>HotSpot 不采用此算法</em>。</li>
<li><strong>可达性分析（Trace-based）</strong>：从 GC Roots 开始通过引用图遍历，标记活对象，未标记即回收。HotSpot 采用此方法。</li>
</ul>
<p><strong>回收策略</strong></p>
<ul>
<li><strong>标记-清除（Mark-Sweep）</strong>：标记所有可达对象，然后清除未标记对象。优点：实现简单；缺点：产生内存碎片。</li>
<li><strong>标记-整理（Mark-Compact）</strong>：标记活对象，然后将活对象压缩到一端，更新引用，消除碎片。适合老年代。</li>
<li><strong>复制（Copying）</strong>：把活对象从一个空间复制到另一个空间（两块半区或多个区），空出整个区域，避免碎片。优点：简单高效。常用于年轻代（Eden&#x2F;Survivor）。</li>
<li><strong>分代收集（Generational）</strong>：根据对象存活期长短分代（年轻代&#x2F;老年代）。年轻代使用复制算法（低成本），老年代使用标记-清除或标记-整理。因为大多数对象寿命短（弱生成假设），分代策略能显著提高性能。</li>
</ul>
<p><strong>现代收集器（概述）</strong></p>
<ul>
<li><strong>Serial GC</strong>：单线程收集，STW（Stop The World），适用于单核或小内存场景。</li>
<li><strong>Parallel（Throughput）GC</strong>：多线程并行回收，追求吞吐量，适合 batch、后台服务。</li>
<li><strong>CMS（Concurrent Mark-Sweep）</strong>：并发标记清理，低暂停，使用并发阶段来减少 STW。已在新版 JDK 中被标注为过时&#x2F;删除。</li>
<li><strong>G1（Garbage-First）</strong>：把堆划分为 region，进行 region 级别回收与并行压缩，设计目标是可预测的暂停与高吞吐，现代服务器应用默认或推荐使用。</li>
<li><strong>ZGC &#x2F; Shenandoah</strong>：以并发压缩为目标，追求极低停顿（几毫秒级甚至微秒级），适合超大堆与低延迟需求。</li>
</ul>
<hr>
<h3 id="3-GC-的可达性分析"><a href="#3-GC-的可达性分析" class="headerlink" title="3) GC 的可达性分析"></a>3) GC 的可达性分析</h3><p><strong>根（GC Roots）来源</strong></p>
<ul>
<li>Java 虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中的静态引用（静态变量）。</li>
<li>本地方法栈或 JNI 中的引用。</li>
<li>运行时常量池中直接引用（部分实现）。</li>
<li>其他 JVM 内部持有的引用（例如 ClassLoader 的引用）。</li>
</ul>
<p><strong>引用类型的语义</strong></p>
<ul>
<li><strong>强引用（StrongReference）</strong>：普通引用，GC 不会回收强引用对象。</li>
<li><strong>软引用（SoftReference）</strong>：在内存不足时回收，适用于缓存（<code>SoftReference</code>）。</li>
<li><strong>弱引用（WeakReference）</strong>：在下一次 GC 时就可能回收，适用于 canonicalized mappings 等。</li>
<li><strong>虚引用（PhantomReference）</strong>：对象被回收后会把引用加入引用队列，可用于在对象被回收后做清理（配合 ReferenceQueue），并且 <code>get()</code> 返回 null。</li>
</ul>
<p><strong>遍历算法</strong></p>
<ul>
<li>从 GC Roots 开始做图遍历（BFS&#x2F;DFS）标记所有可达对象；未标记即为垃圾。</li>
<li>优点：能处理循环引用（与引用计数对比），是 HotSpot 的主流做法。</li>
<li>一些优化：<ul>
<li><strong>增量&#x2F;并发标记</strong>：把标记工作分阶段与应用线程并发执行，以减少 STW。</li>
<li><strong>卡表（Card Table）跟踪写入屏障</strong>：在分代收集中用于记录跨代引用（例如老-&gt;新），推动并行或并发回收优化。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-CMS-Concurrent-Mark-Sweep-垃圾回收器-——-细节与调优"><a href="#4-CMS-Concurrent-Mark-Sweep-垃圾回收器-——-细节与调优" class="headerlink" title="4) CMS (Concurrent Mark Sweep) 垃圾回收器 —— 细节与调优"></a>4) CMS (Concurrent Mark Sweep) 垃圾回收器 —— 细节与调优</h3><p><strong>目标</strong>：尽量减少与应用线程的 STW 停顿（低延迟），主要用于老年代收集（年轻代通常用并行收集 <code>ParNew</code>）。</p>
<p><strong>CMS 工作阶段（常见实现顺序）</strong></p>
<ol>
<li><strong>初始标记（Initial Mark）</strong> — STW：标记直接可达的对象（通常从根开始快速标记与 GC Roots 直接关联的对象）；时间较短。</li>
<li><strong>并发标记（Concurrent Mark）</strong> — 与应用线程并发：遍历引用图标记可达对象。</li>
<li><strong>并发预清理（Concurrent Preclean）</strong> —（可选）修正并发期间的部分浮动垃圾。</li>
<li><strong>重新标记（Remark）</strong> — STW：修正并发标记期间因应用线程持有或释放引用导致的漏标（这一步相对短于传统全量标记，因为大部分工作已并发完成）。</li>
<li><strong>并发清理（Concurrent Sweep）</strong> — 与应用线程并发：清理未标记对象并维护空闲链表。</li>
<li><strong>并发重置&#x2F;重组（Concurrent Reset）</strong>：准备下一次 GC。</li>
</ol>
<p><strong>实现细节与问题</strong></p>
<ul>
<li><strong>不做压缩（默认）</strong>：CMS 清理不会压缩老年代，因此会留下内存碎片。碎片问题可能导致“内存足够但无法满足连续大对象分配”从而触发 Full GC。</li>
<li><strong>并发模式失败（Concurrent Mode Failure）</strong>：如果 CMS 无法在合理时间内完成并发回收（例如分配速率非常高或堆碎片太多），会触发 fallback：做一次 STW 的 Full GC（通常由 Serial GC 或 Parallel Old 执行），其停顿可能很长。</li>
<li><strong>并发标记期间的“floating garbage”</strong>：由于并发执行，某些对象在标记时刚好变为不可达或变得可达，需要 re-mark 来修正。</li>
<li><strong>配套 Young Collector</strong>：CMS 常与 <code>ParNew</code>（并行年轻代收集器）配合使用以减少年轻代停顿。</li>
</ul>
<p><strong>常见调优参数（典型）</strong></p>
<ul>
<li><code>-XX:+UseConcMarkSweepGC</code>：开启 CMS（旧 JDK）。</li>
<li><code>-XX:+UseParNewGC</code>：并行年轻代与 CMS 协同。</li>
<li><code>-XX:CMSInitiatingOccupancyFraction=XX</code>：触发 CMS 的老年代占用率阈值（百分比）。默认例如 68 或 75，通常设置为 60~75，视应用而定。</li>
<li><code>-XX:+UseCMSInitiatingOccupancyOnly</code>：只使用指定阈值（避免 JVM 自适应更改）。</li>
<li><code>-XX:+CMSParallelRemarkEnabled</code>：并行 re-mark，减少 remark 停顿。</li>
<li><code>-XX:+CMSClassUnloadingEnabled</code>：允许 CMS 在并发过程中卸载类并回收元空间中无用的 class 元数据（防止 metaspace 泄漏）。</li>
</ul>
<p><strong>排查 CMS 问题</strong></p>
<ul>
<li><strong>频繁 Full GC &#x2F; Concurrent Mode Failure</strong>：查看 GC 日志（<code>-Xlog:gc*</code> 或 <code>-XX:+PrintGCDetails</code>），识别是否为 CMS 失败导致的 Full GC；增大堆或调高 <code>CMSInitiatingOccupancyFraction</code>，或减少老年代占用速率（减少晋升&#x2F;减少内存占用）。</li>
<li><strong>碎片问题</strong>：增加老年代大小，或在 Full GC 时触发压缩（Full GC 通常会做 compact）；考虑切换到 G1（自带整理能力）。</li>
<li><strong>已被弃用&#x2F;移除</strong>：注意在新版本 JDK（例如 JDK 14+）CMS 已被移除或标记弃用，应优先考虑 G1、ZGC 或 Shenandoah。</li>
</ul>
<hr>
<h3 id="5-G1-收集器（Garbage-First）"><a href="#5-G1-收集器（Garbage-First）" class="headerlink" title="5) G1 收集器（Garbage-First）"></a>5) G1 收集器（Garbage-First）</h3><p><strong>目标</strong>：在大堆场景下提供可预测的停顿目标（低延迟）与高吞吐，同时减少碎片。JDK9+ 的默认回收器通常为 G1（视 JVM 版本而定）。</p>
<p><strong>核心思想</strong></p>
<ul>
<li><strong>Region（区域）</strong>：G1 把堆划分为等大小的 region（通常 1MB~32MB，自动根据堆大小选择），每个 region 可以被逻辑地视为 Eden&#x2F;Survivor&#x2F;Old。</li>
<li><strong>记忆集（Remembered Sets, RSet）</strong>：为了记录跨 region 的引用（比如老区指向年轻区），G1 使用 RSet 来快速定位哪些 region 可能引用某 region 的对象，以便并发&#x2F;并行回收时正确处理根集合。</li>
<li><strong>并发标记阶段 + 混合回收</strong>：<ol>
<li><strong>初始标记（STW）</strong>：短暂停顿做 root scanning（与 Eden GC 同步）。</li>
<li><strong>并发标记（Concurrent Mark）</strong>：并发地标记可达对象，构建 liveness 信息和 region 的垃圾率估算。</li>
<li><strong>重新标记（Remark）</strong>：STW，修正并发期间变更。</li>
<li><strong>并发清理（Cleanup）</strong>：确定哪些 region 应该被回收&#x2F;合并（形成 Evacuation Set）。</li>
<li><strong>混合回收（Mixed GC）</strong>：在并发阶段之后执行若干次混合回收，回收年轻代 region 以及一些老年代 region，直到满足堆回收目标。</li>
</ol>
</li>
<li><strong>Evacuation（搬迁）</strong>：G1 回收采用“复制&#x2F;搬迁”策略，把选中的 region 中的存活对象复制到其他空闲 region（可合并 region），以避免碎片并保持连续可用空间。</li>
<li><strong>Humongous objects</strong>：大对象（大于 region size&#x2F;2）被视为 humongous，会占用连续多个 region，并直接交付给老年代（并采用专门策略回收）。</li>
</ul>
<p><strong>G1 的优点</strong></p>
<ul>
<li>区域化管理，支持并行、并发、压缩（搬迁）操作，降低碎片概率。</li>
<li>可以设置 <code>-XX:MaxGCPauseMillis</code> 作为目标，G1 会尝试在此暂停目标下选择回收区域集合以满足目标（并不能保证严格实现）。</li>
<li>支持并发标记并回收老年代（mixed GC），提高可预测性。</li>
</ul>
<p><strong>重要参数与调优</strong></p>
<ul>
<li><code>-XX:+UseG1GC</code>：启用 G1（现代 JDK 常为默认）。</li>
<li><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code>：G1 尝试将停顿控制到 N ms（软目标）。</li>
<li><code>-XX:InitiatingHeapOccupancyPercent=&lt;pct&gt;</code>（默认 ~45）：并发标记触发阈值（当堆占用达到此百分比时启动 concurrent marking）。</li>
<li><code>-XX:G1HeapRegionSize=&lt;size&gt;</code>：region 大小，自动调整但可显式设置（1MB~32MB），影响 humongous 阈值与 remembered set 管理开销。</li>
<li><code>-XX:ConcGCThreads</code> &#x2F; <code>-XX:ParallelGCThreads</code>：并发&#x2F;并行线程数目，通常与 CPU core 配置有关。</li>
<li><code>-XX:MaxTenuringThreshold</code>：对象晋升阈值控制（与 Survivor 区的年龄策略相关）。</li>
</ul>
<p><strong>诊断与问题</strong></p>
<ul>
<li><strong>Humongous 分配问题</strong>：大量 humongous 对象可能导致 region 被大量占用并影响 G1 的效率；可考虑调整 region size 或改用分块存储。</li>
<li><strong>Remembered Set 开销</strong>：对于很多跨 region 引用（即对象分布极为分散或写入热点多），RSet 更新开销高。</li>
<li><strong>GC 日志分析</strong>：使用 <code>-Xlog:gc*:file=gc.log</code>（JDK9+）或 <code>-XX:+PrintGCDetails</code>（老方式），并用 GC 分析工具（GCEasy、GCViewer、JClarity）查看 pause、mixed GC 次数、humongous 比例等。</li>
</ul>
<hr>
<h3 id="6-类加载机制（加载、链接、初始化）"><a href="#6-类加载机制（加载、链接、初始化）" class="headerlink" title="6) 类加载机制（加载、链接、初始化）"></a>6) 类加载机制（加载、链接、初始化）</h3><p><strong>加载（Loading）</strong></p>
<ul>
<li>ClassLoader 读取类的二进制字节流，将其转换为 <code>Class</code> 对象（在方法区&#x2F;MetaSpace 存储元数据），并在 JVM 的方法区中创建相应的数据结构（方法、常量池、字段布局等）。</li>
</ul>
<p><strong>链接（Linking）</strong></p>
<ul>
<li><strong>验证（Verification）</strong>：确保字节流符合 JVM 规范（格式正确、语义不违背安全约束）。</li>
<li><strong>准备（Preparation）</strong>：为类的静态变量分配内存并赋默认值（但不执行显式初始值）。</li>
<li><strong>解析（Resolution）</strong>：把符号引用解析成直接引用（如类的全限定名解析为直接内存地址或指针）。解析可以是懒解析（首次使用时解析）。</li>
</ul>
<p><strong>初始化（Initialization）</strong></p>
<ul>
<li>执行类的 <code>&lt;clinit&gt;</code> 方法（由编译器合成，包含 static 初始化器和静态字段的赋值语句），这是执行静态初始化的阶段。初始化由 VM 控制（线程安全，按需触发）。</li>
<li><strong>什么时候触发初始化</strong>（例子）：<ul>
<li>首次主动使用（new、调用静态方法、读取&#x2F;写入静态字段、反射调用 Class.forName 等）。</li>
<li><code>Class.forName()</code> 会强制初始化（除非用 <code>Class.forName(name, false, loader)</code>）。</li>
</ul>
</li>
</ul>
<p><strong>类加载器层次</strong></p>
<ul>
<li><strong>Bootstrap（启动）类加载器</strong>：加载核心类库（JRE&#x2F;lib） — C&#x2F;C++ 实现，不是 Java 对象。</li>
<li><strong>Platform &#x2F; Extension 类加载器</strong>（JDK 9+ 为 Platform loader）：负责加载平台类。</li>
<li><strong>Application &#x2F; System 类加载器</strong>：加载应用类路径（-classpath 指定路径）。</li>
<li><strong>自定义类加载器</strong>：通过继承 <code>ClassLoader</code> 覆盖 <code>findClass</code> 或 <code>loadClass</code> 来实现自定义行为（隔离、热部署、沙箱等）。</li>
</ul>
<p><strong>类卸载</strong></p>
<ul>
<li>类及其 ClassLoader 可以被卸载，前提是：<ul>
<li>所有该类由其 ClassLoader 加载的类实例、静态引用、线程上下文等均被回收（ClassLoader 没有活跃引用）。</li>
<li>在 HotSpot 中，类卸载由垃圾回收触发（常在 Full GC 或并发标记期间进行）；一些 GC（如 CMS、G1）支持类卸载（需要相应参数，如 <code>CMSClassUnloadingEnabled</code> 在 CMS 中）。</li>
</ul>
</li>
<li><strong>常见导致类无法卸载问题</strong>：线程池未停止的线程持有 ThreadLocal 的引用、静态单例、JDBC 驱动未注销等。</li>
</ul>
<hr>
<h3 id="7-双亲委派模型-如何打破"><a href="#7-双亲委派模型-如何打破" class="headerlink" title="7) 双亲委派模型 &amp; 如何打破"></a>7) 双亲委派模型 &amp; 如何打破</h3><p><strong>双亲委派（Parent Delegation）机制</strong></p>
<ul>
<li>加载类的请求先委托给父加载器，如果父加载器无法加载再由子加载器尝试加载。目的：<ul>
<li>保证核心类优先由 Bootstrap Loader 加载（安全性，避免自定义类覆盖 java.lang.*）。</li>
<li>简化类的唯一性管理，避免重复加载核心类。</li>
</ul>
</li>
</ul>
<p><strong>实现流程（High-level）</strong></p>
<ul>
<li><code>ClassLoader.loadClass(name)</code>：<ol>
<li>检查缓存是否已加载。</li>
<li>如果未加载，委托给 parent.loadClass(name)（若 parent 存在）。</li>
<li>如果 parent 无法找到，再调用本地 <code>findClass(name)</code> 去加载（子加载器）。</li>
</ol>
</li>
</ul>
<p><strong>打破双亲委派的理由与方法</strong></p>
<ul>
<li><strong>为什么要打破</strong>：某些容器（如应用服务器、插件框架、OSGi、Tomcat 的 webapp classloader）需要实现“子优先（child-first）”加载策略以隔离应用或实现热部署。</li>
<li><strong>如何打破</strong>：<ul>
<li><strong>覆盖 <code>loadClass</code></strong>：自定义 <code>ClassLoader</code> 重写 <code>loadClass</code> 方法，先尝试 <code>findLoadedClass</code> 和 <code>findClass</code>（子加载器），若找不到再委托 parent。注意处理 <code>java.*</code> 或核心类仍应委托父加载器以避免安全风险。</li>
<li><strong>在容器实现中使用 child-first 策略</strong>（Tomcat 中有设置），以便在 webapp 中优先加载 WEB-INF&#x2F;lib&#x2F; classes。</li>
</ul>
</li>
<li><strong>风险 &amp; 问题</strong>：<ul>
<li><strong>类卸载与类型不兼容</strong>：若相同的类由不同 ClassLoader 加载，类的“身份”不同，会出现 <code>ClassCastException</code>（即使类名相同）。</li>
<li><strong>安全风险</strong>：子加载器加载 core 类可能覆盖 JDK 内部类，带来安全隐患。</li>
<li><strong>复杂性</strong>：对依赖关系的管理更复杂，特别是 native library 绑定与单例行为。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8-出现-Full-GC-的场景"><a href="#8-出现-Full-GC-的场景" class="headerlink" title="8) 出现 Full GC 的场景"></a>8) 出现 Full GC 的场景</h3><p>Full GC（通常指触发了老年代回收和可能会做类&#x2F;元空间回收或堆压缩的 STW）可由多种原因触发，常见包含：</p>
<p><strong>内存与分配相关</strong></p>
<ul>
<li><strong>老年代空间不足</strong>（老年代无法容纳晋升对象）：当晋升失败或老年代碎片严重导致无法找到连续空间分配大对象。</li>
<li><strong>空间被大量持久对象占满</strong>（例如缓存过大、未释放的集合、内存泄漏）。</li>
<li><strong>Promotion Failure &#x2F; Allocation Failure</strong>：年轻代 GC 后向老年代晋升对象失败，可能触发 Full GC。</li>
<li><strong>太多 Humongous 对象（G1 &#x2F; region-based）</strong>：大对象占据大量 region，影响分配&#x2F;回收，进而触发 Full GC。</li>
</ul>
<p><strong>元空间（Metaspace）或永久代（PermGen）</strong></p>
<ul>
<li><strong>Metaspace&#x2F;PermGen 用尽</strong>：类&#x2F;字节码元数据分配失败会触发 Full GC 来尝试回收类并卸载无用类（如果成功则释放空间），否则抛出 <code>OutOfMemoryError: Metaspace</code>。</li>
</ul>
<p><strong>显式或系统触发</strong></p>
<ul>
<li><strong>System.gc() &#x2F; 显式垃圾回收请求</strong>：若未禁用显式 GC，会触发一次 Full GC（可通过 <code>-XX:+DisableExplicitGC</code> 忽略）。</li>
<li><strong>某些 VM 操作</strong>（如类卸载、某些 JNI 操作、资源限制检查）需要 Full GC。</li>
</ul>
<p><strong>GC 内部</strong></p>
<ul>
<li><strong>并发回收器失败（Concurrent Mode Failure）</strong>：例如 CMS 无法并发完成回收，会回退为 Full GC（STW）。</li>
<li><strong>碎片化</strong>：尤其 CMS 未压缩导致碎片，分配大对象失败导致 Full GC。</li>
<li><strong>Native 内存压力或直接内存用尽</strong>：某些场景下 JVM 为回收资源触发 Full GC（例如清理 PhantomReference &#x2F; finalizer 队列）。</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><strong>Finalizer 队列阻塞</strong>：对象有 <code>finalize()</code> 且 finalizer 执行滞后，可能导致大量对象等待 finalization，从而触发更多 GC。</li>
<li><strong>虚拟机内建的阈值&#x2F;策略</strong>：某些 GC 收集器根据内部策略在阈值到达时触发 Full 回收。</li>
</ul>
<hr>
<h3 id="9-常见的-JVM-参数"><a href="#9-常见的-JVM-参数" class="headerlink" title="9) 常见的 JVM 参数"></a>9) 常见的 JVM 参数</h3><p>下面按功能分类给出常见参数、作用与典型取值建议：</p>
<p><strong>堆内存与分代</strong></p>
<ul>
<li><code>-Xms&lt;size&gt;</code>：初始堆大小（建议与 -Xmx 一致以避免扩容开销）。</li>
<li><code>-Xmx&lt;size&gt;</code>：最大堆大小。</li>
<li><code>-Xmn&lt;size&gt;</code>：年轻代大小（也可用 <code>-XX:NewSize</code> &#x2F; <code>-XX:MaxNewSize</code>）。</li>
<li><code>-XX:NewRatio=n</code>：老年代与年轻代比率（老:新 &#x3D; n:1）。</li>
<li><code>-XX:SurvivorRatio=n</code>：Eden 与 Survivor 的比例。</li>
<li><code>-XX:MaxTenuringThreshold=&lt;n&gt;</code>：最大晋升年龄（决定对象在 Survivor 区停留的代数）。</li>
</ul>
<p><strong>GC 选择</strong></p>
<ul>
<li><code>-XX:+UseG1GC</code>：使用 G1 收集器（现代推荐）。</li>
<li><code>-XX:+UseParallelGC</code> &#x2F; <code>-XX:+UseParallelOldGC</code>：并行 GC，追求吞吐。</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：CMS（旧）。</li>
<li><code>-XX:+UseSerialGC</code>：串行 GC（小堆、单线程场景）。</li>
<li><code>-XX:+UseZGC</code> &#x2F; <code>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</code>：新一代低停顿收集器（视 JDK 版本）。</li>
</ul>
<p><strong>GC 日志</strong></p>
<ul>
<li>JDK8 及更早：<ul>
<li><code>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/path/gc.log</code></li>
</ul>
</li>
<li>JDK9+（统一日志）：<ul>
<li><code>-Xlog:gc*:file=/path/gc.log:time,uptime,level,tags</code></li>
</ul>
</li>
<li>辅助：<code>-XX:+PrintTenuringDistribution</code>、<code>-XX:+PrintGCApplicationStoppedTime</code>。</li>
</ul>
<p><strong>元空间 &#x2F; 类加载</strong></p>
<ul>
<li><code>-XX:MetaspaceSize=&lt;n&gt;</code>：触发第一次扩展的阈值（非上限）。</li>
<li><code>-XX:MaxMetaspaceSize=&lt;n&gt;</code>：最大元空间大小（否则可能导致 OOME）。</li>
<li><code>-XX:+TraceClassLoading</code> &#x2F; <code>-XX:+TraceClassUnloading</code>：调试类加载&#x2F;卸载。</li>
</ul>
<p><strong>诊断 &amp; 堆转储</strong></p>
<ul>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：OOM 时自动 dump heap。</li>
<li><code>-XX:HeapDumpPath=/path/dump.hprof</code>。</li>
<li><code>-XX:+DisableExplicitGC</code>：忽略 <code>System.gc()</code> 调用。</li>
<li><code>-XX:+PrintFlagsFinal</code>：打印最终生效的 JVM 参数。</li>
</ul>
<p><strong>JIT 与调优</strong></p>
<ul>
<li><code>-XX:+PrintCompilation</code>、<code>-XX:+LogCompilation</code>、<code>-XX:+PrintInlining</code>、<code>-XX:CompileThreshold</code>（编译阈值）。</li>
<li><code>-XX:+AggressiveOpts</code>（试验性，不推荐在生产）。</li>
</ul>
<p><strong>线程与并行</strong></p>
<ul>
<li><code>-XX:ParallelGCThreads=&lt;n&gt;</code>：GC 并行线程数（与 CPU 相关）。</li>
<li><code>-XX:ConcGCThreads=&lt;n&gt;</code>：并发 GC 的线程数（G1&#x2F;ZGC 等适用）。</li>
<li><code>-Xss&lt;size&gt;</code>：每个线程栈大小（注意线程数多时总内存消耗）。</li>
</ul>
<p><strong>容器 &#x2F; 限制相关</strong></p>
<ul>
<li><code>-XX:+UseContainerSupport</code> &#x2F; <code>-XX:MaxRAMPercentage</code> &#x2F; <code>-XX:InitialRAMPercentage</code>：针对容器和 cgroup 的内存配额支持（现代 JDK）。</li>
</ul>
<p><strong>性能增强</strong></p>
<ul>
<li><code>-XX:+UseCompressedOops</code>：压缩指针（默认通常启用），降低内存占用。</li>
<li><code>-XX:+UseStringDeduplication</code>（G1）：启用字符串去重，降低堆中重复字符串内存占用（需要配合 G1）。</li>
</ul>
<hr>
<h3 id="10-JDK-的监控工具-线上处理实战案例（诊断步骤与-runbook）"><a href="#10-JDK-的监控工具-线上处理实战案例（诊断步骤与-runbook）" class="headerlink" title="10) JDK 的监控工具 &amp; 线上处理实战案例（诊断步骤与 runbook）"></a>10) JDK 的监控工具 &amp; 线上处理实战案例（诊断步骤与 runbook）</h3><p>下面用常见问题场景（CPU、内存泄漏、频繁 Full GC、死锁）来给出可复用的线上诊断步骤、命令与处置策略。</p>
<h4 id="常用工具（一句话）"><a href="#常用工具（一句话）" class="headerlink" title="常用工具（一句话）"></a>常用工具（一句话）</h4><ul>
<li><code>jps</code>：列出 Java 进程（PID）。</li>
<li><code>jstack &lt;pid&gt;</code>：线程栈（死锁&#x2F;线程阻塞&#x2F;CPU 占用）。</li>
<li><code>jmap -histo[:live] &lt;pid&gt;</code>：堆中对象统计（按类计数，<code>live</code> 只列存活对象）。</li>
<li><code>jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</code> 或 <code>jcmd &lt;pid&gt; GC.heap_dump file</code>：导出堆快照（用于 MAT 分析）。</li>
<li><code>jcmd</code>：功能强大，可触发 GC、打印系统属性、堆信息、执行诊断命令（<code>jcmd &lt;pid&gt; GC.heap_info</code>、<code>VM.system_properties</code>、<code>Thread.print</code> 等）。</li>
<li><code>jstat -gc &lt;pid&gt; &lt;interval&gt;</code>：实时查看 GC 活动（年轻代、老年代使用情况）。</li>
<li><code>jconsole</code> &#x2F; <code>VisualVM</code>：图形化监控（JMX）。</li>
<li><code>jcmd GC.run</code>：触发 GC。</li>
<li><code>jcmd VM.native_memory summary</code>：查看 native 内存使用（需要 <code>-XX:NativeMemoryTracking=detail</code> 启动）。</li>
<li>第三方工具：<strong>Arthas</strong>（线上探查、方法级追踪、实时 heapdump）、async-profiler（采样 CPU &#x2F; JIT 火焰图）、MAT（Heap分析）。</li>
</ul>
<h4 id="场景-1：CPU-突增"><a href="#场景-1：CPU-突增" class="headerlink" title="场景 1：CPU 突增"></a>场景 1：CPU 突增</h4><p><strong>诊断步骤</strong></p>
<ol>
<li><code>top</code> &#x2F; <code>ps</code> 确认 Java 进程 CPU 占用。</li>
<li><code>jstack -l &lt;pid&gt; &gt; threaddump.txt</code>（收集多个间隔 5s 的线程快照更有价值）。</li>
<li>分析线程 dump：找出 RUNNABLE 的热点方法（循环、I&#x2F;O、锁竞争）。</li>
<li>若需要更精确调用占比，使用 <code>async-profiler</code> 生成火焰图，或 <code>perf</code>（Linux）做系统级采样。</li>
</ol>
<p><strong>快速处置</strong></p>
<ul>
<li>若是 GC 占用：查看 GC 日志（<code>jstat</code> &#x2F; gc.log），若频繁 GC，考虑增加堆、调整 genç 大小或切换收集器。</li>
<li>若是代码热点：优化代码（减少同步、减少阻塞 I&#x2F;O、提高并行度），使用缓存或限流策略。</li>
</ul>
<h4 id="场景-2：内存泄漏（持续内存增长-OOM）"><a href="#场景-2：内存泄漏（持续内存增长-OOM）" class="headerlink" title="场景 2：内存泄漏（持续内存增长 &#x2F; OOM）"></a>场景 2：内存泄漏（持续内存增长 &#x2F; OOM）</h4><p><strong>诊断步骤</strong></p>
<ol>
<li>查看内存使用趋势（<code>jstat -gc</code> 或监控系统）。</li>
<li>导出堆快照（<code>jcmd &lt;pid&gt; GC.heap_dump file</code> 或 <code>jmap -dump</code>）。<strong>注意</strong>：堆 dump 操作可能会消耗大量 IO 和临时内存，生产上谨慎执行并提前协调维护窗口&#x2F;流量降级。</li>
<li>用 MAT（Eclipse Memory Analyzer）分析 dominator tree，找出最大的保留者（retained size）并沿引用链定位泄漏源（常见是静态集合、ThreadLocal、缓存、未关闭的资源）。</li>
<li>查看类加载器统计（<code>jcmd &lt;pid&gt; VM.class_histo</code> 或 <code>jmap -clstats</code>），判断是否类或 classloader 泄漏（热部署后的 webapp 卸载失败常见）。</li>
</ol>
<p><strong>处置</strong></p>
<ul>
<li>释放占用：清除缓存、关闭连接、停止线程，以便对象可被收集。</li>
<li>修复代码：使用弱引用或显式资源管理（try-with-resources）、确保在 webapp undeploy 时清理静态引用与线程。</li>
<li>监控回归，增加单元&#x2F;集成测试覆盖内存留存场景。</li>
</ul>
<h4 id="场景-3：频繁-Full-GC-GC-瘫痪（应用停顿）"><a href="#场景-3：频繁-Full-GC-GC-瘫痪（应用停顿）" class="headerlink" title="场景 3：频繁 Full GC &#x2F; GC 瘫痪（应用停顿）"></a>场景 3：频繁 Full GC &#x2F; GC 瘫痪（应用停顿）</h4><p><strong>诊断</strong></p>
<ol>
<li>检查 GC 日志：<code>-Xlog:gc*</code> 或 <code>-XX:+PrintGCDetails</code>。识别是 Full GC、CMS ConcurrentModeFailure、还是晋升失败。</li>
<li><code>jstat -gc</code> 查看年轻代&#x2F;老年代使用比例、晋升速率。</li>
<li><code>jmap -histo</code> 看增长的对象类型（是否有大量短期大对象导致频繁晋升）。</li>
<li>检查 Metaspace 是否耗尽（<code>jcmd &lt;pid&gt; VM.system_properties</code> + <code>-XX:MaxMetaspaceSize</code>）。</li>
</ol>
<p><strong>处置</strong></p>
<ul>
<li>增加堆或调整分代大小（<code>-Xmx</code>, <code>-Xmn</code>）、或切换 G1 并调 <code>InitiatingHeapOccupancyPercent</code>。</li>
<li>若是碎片化（CMS 特有），考虑暂时触发 Full GC 以 compact，或迁移到 G1。</li>
<li>优化代码以减少大对象分配、减少晋升速率（晋升失败），或使用对象池。</li>
<li>禁用显式 GC（<code>-XX:+DisableExplicitGC</code>）。</li>
</ul>
<h4 id="场景-4：死锁-线程阻塞"><a href="#场景-4：死锁-线程阻塞" class="headerlink" title="场景 4：死锁 &#x2F; 线程阻塞"></a>场景 4：死锁 &#x2F; 线程阻塞</h4><p><strong>诊断</strong></p>
<ol>
<li><code>jstack -l &lt;pid&gt;</code>：查看 BLOCKED&#x2F;WAITING&#x2F; TIMED_WAITING 线程，寻找循环等待锁的线程堆栈。</li>
<li><code>jstack</code> 输出中 <code>Found one Java-level deadlock</code> 会标明死锁详情。</li>
</ol>
<p><strong>处置</strong></p>
<ul>
<li>临时：重启受影响线程或整个服务（如果可承受）。</li>
<li>根治：查找锁顺序，改进锁策略（减少锁持有时间、使用更细粒度锁或无锁结构），增加超时与监控报警。</li>
</ul>
<h4 id="现场常用命令模板（示例）"><a href="#现场常用命令模板（示例）" class="headerlink" title="现场常用命令模板（示例）"></a>现场常用命令模板（示例）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出 Java 进程</span></span><br><span class="line">jps -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程转储（多次）</span></span><br><span class="line">jstack -l &lt;pid&gt; &gt; /tmp/threads-1.txt</span><br><span class="line"><span class="built_in">sleep</span> 5</span><br><span class="line">jstack -l &lt;pid&gt; &gt; /tmp/threads-2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆对象统计（按类）</span></span><br><span class="line">jmap -histo:live &lt;pid&gt; &gt; /tmp/histo.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出堆快照（谨慎）</span></span><br><span class="line">jcmd &lt;pid&gt; GC.heap_dump /tmp/heap-$(<span class="built_in">date</span> +%s).hprof</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 GC stats（实时）</span></span><br><span class="line">jstat -gc &lt;pid&gt; 1000 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 native memory（需 NMT 启动）</span></span><br><span class="line">jcmd &lt;pid&gt; VM.native_memory summary</span><br></pre></td></tr></table></figure>

<p><strong>生产注意事项</strong></p>
<ul>
<li>堆 dump、jmap 等可能引起停顿并占用额外磁盘&#x2F;内存；在高可用场景下先流量降级或在副本上运行诊断。</li>
<li>建议在生产环境启用可控 GC 日志（并定期轮转）与 JMX 暴露指标，结合监控平台（Prometheus&#x2F;Grafana）和 APM（比如 Pinpoint, SkyWalking）做长期趋势分析。</li>
<li>使用 <code>jcmd</code> 的命令集优于老旧 <code>jmap/jstack</code> 功能更强，且适配新 JVM。</li>
</ul>
<hr>
<h4 id="总结与推荐（面试与线上实战要点）"><a href="#总结与推荐（面试与线上实战要点）" class="headerlink" title="总结与推荐（面试与线上实战要点）"></a>总结与推荐（面试与线上实战要点）</h4><ul>
<li><strong>理解内存模型</strong> 是定位 OOM、内存泄漏与调优 GC 的基础（知道对象在哪、什么时候晋升、元空间的影响）。</li>
<li><strong>分代策略</strong> 解释了为什么年轻代短 GC（复制）与老年代不同（标记&#x2F;清理&#x2F;整理）。</li>
<li><strong>CMS 与 G1 的差异</strong>：CMS 低停顿但易碎片；G1 更适合大堆与可控停顿，企业建议以 G1 为首选（或在更低停顿需求下考虑 ZGC&#x2F;Shenandoah）。</li>
<li><strong>线上诊断</strong>：熟练使用 <code>jstack</code>, <code>jcmd</code>, <code>jmap</code>, <code>jstat</code>，并结合 GC 日志与堆分析工具（MAT &#x2F; async-profiler）是工程师必备能力。</li>
<li><strong>工程实践</strong>：默认把 <code>Xms=Xmx</code>、启用 GC 日志（统一日志 <code>-Xlog</code>），避免 System.gc，监控元空间与直接内存，做好容器&#x2F;VM 限制适配（cgroup-aware flags）。</li>
</ul>
<h2 id="Redis-牛客面经八股"><a href="#Redis-牛客面经八股" class="headerlink" title="Redis-牛客面经八股"></a>Redis-牛客面经八股</h2><h3 id="1-Redis-的数据类型"><a href="#1-Redis-的数据类型" class="headerlink" title="1. Redis 的数据类型"></a>1. Redis 的数据类型</h3><p>Redis 提供多种内建数据类型与高级数据结构（模块除外）：</p>
<ol>
<li><strong>String</strong><ul>
<li>二进制安全，最大可达 512MB。</li>
<li>用途：缓存、计数器、序列化对象、分布式限流&#x2F;锁等。</li>
</ul>
</li>
<li><strong>List</strong><ul>
<li>双端链表（old impl）→ 现在是 <strong>quicklist</strong>（ziplist&#x2F;listpack + linked list 的混合实现）。</li>
<li>支持 <code>LPUSH/RPUSH</code>、<code>LPOP/RPOP</code>、<code>LRANGE</code> 等，适合消息队列（阻塞 <code>BLPOP</code>）。</li>
</ul>
</li>
<li><strong>Set</strong><ul>
<li>无序集合，内部用哈希表实现。</li>
<li>支持集合运算 <code>SINTER/SUNION/SDIFF</code>。</li>
</ul>
</li>
<li><strong>Sorted Set (ZSet)</strong><ul>
<li>有序集合：每个 member 有一个 score，支持按 score 排序。</li>
<li>内部实现：<strong>跳表 (skiplist)</strong> + <strong>哈希表(dict)</strong>（hash: member→score；skiplist 用于按 score 快速范围查询）。</li>
</ul>
</li>
<li><strong>Hash</strong><ul>
<li>字段集合（类似小型对象 &#x2F; map）。</li>
<li>小 hash 使用紧凑编码（ziplist &#x2F; listpack）；大 hash 使用哈希表。</li>
</ul>
</li>
<li><strong>Bitmap</strong><ul>
<li>用 String 的位操作实现（<code>SETBIT/GETBIT/BITCOUNT/BITOP</code>）。常用于海量用户标记、UV&#x2F;活跃用户统计（配合 bitset）。</li>
</ul>
</li>
<li><strong>HyperLogLog</strong><ul>
<li>基数估算（基于概率，固定内存 ~ 12KB），用于 UV 去重估算（<code>PFADD</code>, <code>PFCOUNT</code>）。</li>
</ul>
</li>
<li><strong>Stream</strong><ul>
<li>Redis Streams（日志式数据结构）支持 append-only 记录、ID、Consumer Groups（可靠消费、ACK、pending）、适合消息队列&#x2F;事件流。</li>
<li>内部：<strong>rax（radix tree）</strong> 映射 ID-&gt;listpack，entry 存于 listpack（紧凑结构）。</li>
</ul>
</li>
<li><strong>Geo</strong><ul>
<li>基于 Sorted Set 的地理位置 API（<code>GEOADD/GEORADIUS</code>），score 存编码后的经纬度。</li>
</ul>
</li>
<li><strong>Modules</strong><ul>
<li>可以通过模块增加类型（RedisJSON、RedisTimeSeries、RediSearch 等）。</li>
</ul>
</li>
</ol>
<p><strong>工程要点</strong></p>
<ul>
<li>小集合尽量利用紧凑编码（减少内存），但超过阈值会切换成普通哈希&#x2F;zip 切换（可通过配置调整阈值）。</li>
<li>用正确类型匹配场景：排行榜用 ZSet；计数器与短字符串用 String；High-cardinality 用 HyperLogLog。</li>
</ul>
<hr>
<h3 id="2-Redis-单线程架构（详解-现代补充）"><a href="#2-Redis-单线程架构（详解-现代补充）" class="headerlink" title="2. Redis 单线程架构（详解 + 现代补充）"></a>2. Redis 单线程架构（详解 + 现代补充）</h3><p><strong>核心点</strong></p>
<ul>
<li>Redis 在命令的<strong>解析与执行</strong>上是<strong>单线程</strong>的：所有命令的逻辑执行（读写内存、更新数据结构）都在主线程顺序执行，这带来两个重要效果：<ul>
<li>简化并发控制：无需对象级锁，避免竞态与复杂锁逻辑。</li>
<li>单个请求执行不会被其它命令打断（除非调用阻塞或 fork 等）。</li>
</ul>
</li>
<li><strong>I&#x2F;O 多路复用</strong>：单线程用 <code>epoll</code> &#x2F; <code>kqueue</code> &#x2F; <code>select</code> 等事件机制处理网络连接（read&#x2F;write 的 readiness）。常见实现为 <code>ae</code> 事件库。</li>
<li><strong>耗时&#x2F;阻塞操作处理</strong>：<ul>
<li>持久化操作（RDB save、AOF rewrite）通过 <strong>fork 子进程</strong> 在后台做，子进程写文件；父进程继续服务（写入过程会 copy-on-write 增加内存）。</li>
<li>从 Redis 6 开始，引入了<strong>I&#x2F;O 线程（networking threads）</strong> 可选地并行处理 socket read&#x2F;write（把网络 IO 的读写解包&#x2F;组包放到 IO 线程），但命令执行仍在主线程；这可以提升高并发小命令场景下的吞吐。</li>
<li>Redis 也可能使用后台线程做某些任务（例如 RDB&#x2F;AOF rewrite、lazy free、lazy migration 等），但数据结构修改仍是单线程保证原子。</li>
</ul>
</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li>优点：实现简单、命令原子性强、易预测。</li>
<li>缺点：单线程 CPU 瓶颈（但实际 Redis 单命令耗时很短、并可以用多实例&#x2F;分片&#x2F;Cluster 横向扩展）。</li>
</ul>
<hr>
<h3 id="3-Redis-的持久化策略（RDB-AOF-混合）"><a href="#3-Redis-的持久化策略（RDB-AOF-混合）" class="headerlink" title="3. Redis 的持久化策略（RDB &#x2F; AOF &#x2F; 混合）"></a>3. Redis 的持久化策略（RDB &#x2F; AOF &#x2F; 混合）</h3><ol>
<li><strong>RDB（快照）</strong><ul>
<li><code>SAVE</code>&#x2F;<code>BGSAVE</code> 生成数据集快照（RDB 文件）。</li>
<li>优点：文件紧凑、恢复速度快、对 Redis 运行影响小（BGSAVE 使用 fork，父进程继续服务）。</li>
<li>缺点：可能丢失自上次快照以来的写（数据不够实时）；fork 时内存复制（写时复制）会消耗内存。</li>
</ul>
</li>
<li><strong>AOF（Append Only File）</strong><ul>
<li>将写命令追加到文件（每条命令的 Redis 协议表示）。</li>
<li>持久化策略（fsync）：<ul>
<li><code>always</code>（每次命令 fsync）——最安全但最慢；</li>
<li><code>everysec</code>（默认）——每秒 fsync，一致性稍弱，但性能好；</li>
<li><code>no</code>（操作系统决定）——最快但最不安全。</li>
</ul>
</li>
<li>AOF 支持重写（rewrite）来压缩历史命令（生成紧凑的 AOF），这个过程在后台 <code>bgrewriteaof</code> 实现。</li>
<li>优点：更小的数据丢失窗口，恢复时以 AOF 重演命令（可设置 <code>no-appendfsync-on-rewrite</code>）。</li>
<li>缺点：文件大、重写会开销大，恢复速度比 RDB 慢（但可配置重写和重写压缩）。</li>
</ul>
</li>
<li><strong>RDB + AOF</strong><ul>
<li>你可以同时开启 RDB 与 AOF；常见做法：以 RDB 为主备份、AOF 提升数据安全性。也可在 AOF 重写和 RDB 快照间做权衡。</li>
</ul>
</li>
<li><strong>持久化选型建议</strong><ul>
<li>对可接受少量数据丢失（例如缓存）可只用 RDB 或关闭持久化；</li>
<li>要求高可靠性和最小数据丢失 → AOF (<code>everysec</code>)+定期 RDB 快照；</li>
<li>生产上通常开 AOF everysec，并同时配置 RDB 作为备份点。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-Redis-的缓存淘汰策略（maxmemory-policy）"><a href="#4-Redis-的缓存淘汰策略（maxmemory-policy）" class="headerlink" title="4. Redis 的缓存淘汰策略（maxmemory-policy）"></a>4. Redis 的缓存淘汰策略（maxmemory-policy）</h3><p>当达到 <code>maxmemory</code> 限制时，根据 <code>maxmemory-policy</code> 采取淘汰：</p>
<ul>
<li><code>noeviction</code>：不淘汰，写操作返回错误（默认）。</li>
<li><code>allkeys-lru</code>：对所有 key 使用 LRU（近似实现）。</li>
<li><code>volatile-lru</code>：对设置了 TTL 的 key 使用 LRU。</li>
<li><code>allkeys-lfu</code>：LFU（频度）算法。</li>
<li><code>volatile-lfu</code>：对有 TTL 的 key 使用 LFU。</li>
<li><code>allkeys-random</code> &#x2F; <code>volatile-random</code>：随机淘汰。</li>
<li><code>volatile-ttl</code>：优先淘汰 TTL 更短的 key。</li>
</ul>
<p><strong>实现细节</strong></p>
<ul>
<li>Redis 的 LRU&#x2F;LFU 都是<strong>近似实现</strong>，采用采样和时间戳&#x2F;频率计数的方式（不是精确维护全局 LRU 双链表，以节省内存开销）。</li>
<li>LFU 采用一个小计数器并周期性衰减（防止旧热点一直占用）。</li>
</ul>
<p><strong>工程建议</strong></p>
<ul>
<li>选择 <code>allkeys-lfu</code> 可在热点稳定时取得较好效果，但注意对不同 workload 的适配。</li>
<li>对数据重要性不同的 key 可设置 TTL（结合 <code>volatile-*</code> 策略）。</li>
<li>监控 <code>maxmemory</code>、evicted_keys、used_memory_policy 等指标。</li>
</ul>
<hr>
<h3 id="5-Redis-高可用实现（主从-Sentinel-Cluster-third-party）"><a href="#5-Redis-高可用实现（主从-Sentinel-Cluster-third-party）" class="headerlink" title="5. Redis 高可用实现（主从 + Sentinel &#x2F; Cluster &#x2F; third-party）"></a>5. Redis 高可用实现（主从 + Sentinel &#x2F; Cluster &#x2F; third-party）</h3><ol>
<li><strong>主从复制 + Sentinel（自动故障转移）</strong><ul>
<li><strong>复制</strong>：主（master）将写操作通过异步复制到从（replica）。从可以做读操作（读写分离）。</li>
<li><strong>Sentinel</strong>：监控 master 和 replicas，自动故障检测与选举（当 master 挂掉时，Sentinel 会选举新的 master 并通知客户端或客户端重试）。</li>
<li>优点：成熟、简单；缺点：异步复制可能丢失主未同步到 replica 的数据（数据丢失风险）。</li>
</ul>
</li>
<li><strong>Redis Cluster</strong><ul>
<li>内置分片与高可用：将 key 空间划分成 <strong>16384 hash slots</strong>，多个 master 分布这些 slot，每个 master 可以有多个 replica。</li>
<li>客户端通过 MOVED&#x2F;ASK 重定向与 cluster topology 通讯；自动故障转移由 cluster 协议处理（基于投票）。</li>
<li>优点：水平扩展（sharding） + 高可用；缺点：跨 slot 的 multi-key 操作有限制（需要放在同 slot，或者使用 hash tag）。</li>
</ul>
</li>
<li><strong>数据一致性 &amp; 可用性权衡</strong><ul>
<li>默认复制是异步（主进写时不会阻塞等待 replica ack），可能数据丢失。可以用 <code>WAIT</code> 命令等待 master 把写传播到 N 个 replicas。</li>
<li>对强一致性要求高的场景，建议使用外部一致性系统（ZooKeeper&#x2F;etcd）或 Redis-on-Raft 实现（例如 RedisRaft、Dragonfly 堆栈等）。</li>
</ul>
</li>
<li><strong>工程实践</strong><ul>
<li>使用 Sentinel 时确保多个 Sentinel 分布在不同机器&#x2F;可用区。</li>
<li>使用 Cluster 时确保键划分合理，避免跨 slot 多键事务。</li>
<li>备份策略 + 监控 + 自动报警必不可少。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-利用-Redis-实现分布式锁（正确方式与注意）"><a href="#6-利用-Redis-实现分布式锁（正确方式与注意）" class="headerlink" title="6. 利用 Redis 实现分布式锁（正确方式与注意）"></a>6. 利用 Redis 实现分布式锁（正确方式与注意）</h3><p><strong>最常见的简单实现</strong></p>
<ul>
<li>取得锁：<code>SET lockKey token NX PX 30000</code><ul>
<li>NX：仅当键不存在时设置（原子），PX：过期时间（毫秒）</li>
<li><code>token</code> 用唯一值（UUID），用于后续释放判断所有权。</li>
</ul>
</li>
<li>释放锁（必须先校验 token，再 DEL）要原子执行，建议用 Lua：</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- release.lua</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;GET&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&quot;DEL&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>调用：<code>EVALSHA sha1 1 lockKey token</code></p>
<p><strong>Redlock（多实例分布式锁，Antirez 提出）</strong></p>
<ul>
<li>在多个独立 Redis 实例上分别尝试获取锁（SET NX PX），在大多数实例成功（例如 3&#x2F;5）视为获得锁。加锁与释放需在最短时间内完成以避免时钟不同步、网络延迟问题。</li>
<li><strong>争议</strong>：Redlock 在网络分区与异步复制场景下的安全性有争议；某些专家认为它不满足强一致性的分布式锁需求。使用前要评估需求。</li>
</ul>
<p><strong>工程建议</strong></p>
<ul>
<li>对强一致性要求较高的分布式锁场景（例如分布式协调&#x2F;leader election），建议使用专门的一致性系统（ZooKeeper&#x2F;etcd）或使用 Redis Raft。</li>
<li>使用 Redis 做锁时请保证：<ul>
<li>设置合理的过期时间（避免死锁），</li>
<li>释放锁时校验 token（防止误删别人的锁），</li>
<li>对长时间执行的任务可用续租机制（延长过期），但续租也要很小心（线程崩溃导致续租失败）。</li>
</ul>
</li>
<li>注意 Redis 单实例的复制延迟会带来风险；最好配合 <code>WAIT</code> 或使用 <code>SET</code> NX PX 在主节点直接获得。</li>
</ul>
<hr>
<h3 id="7-Redis-怎么实现延时消息"><a href="#7-Redis-怎么实现延时消息" class="headerlink" title="7. Redis 怎么实现延时消息"></a>7. Redis 怎么实现延时消息</h3><p><strong>常见实现 1 — Sorted Set（延时队列）</strong></p>
<ul>
<li>用 <code>ZADD delayQueue score=timestamp member=payloadId</code>（score 为可处理时间）。</li>
<li>消费者轮询：<ol>
<li><code>ZRANGEBYSCORE delayQueue -inf now LIMIT 0 1</code> 得到到期条目 id。</li>
<li>尝试用 Lua 原子地 <code>ZREM</code> 并把 payload 推到处理队列（或直接处理）。</li>
</ol>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- pop_due.lua</span></span><br><span class="line"><span class="keyword">local</span> zkey = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> items = redis.call(<span class="string">&quot;ZRANGEBYSCORE&quot;</span>, zkey, <span class="string">&quot;-inf&quot;</span>, now, <span class="string">&quot;LIMIT&quot;</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> #items == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> item = items[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> removed = redis.call(<span class="string">&quot;ZREM&quot;</span>, zkey, item)</span><br><span class="line"><span class="keyword">if</span> removed == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<ul>
<li>优点：实现简单，顺序可控。</li>
<li>缺点：轮询成本（可用 <code>BRPOPLPUSH</code> 与 list 组合或在消费端做 sleep&#x2F;backoff），并发时要用 Lua 保证原子移除。</li>
</ul>
<p><strong>常见实现 2 — 使用 Streams + consumer groups</strong></p>
<ul>
<li>将消息写入 streams，携带 <code>deliver_at</code> 字段，消费者检查 <code>deliver_at</code> 并在到期时处理（或使用 XAUTOCLAIM &#x2F; XCLAIM 来抢占未 ACK 的消息）。</li>
<li>Streams 提供 ACK、PENDING、重试功能，比 ZSet 更适合可靠消费&#x2F;重试场景。</li>
</ul>
<p><strong>工程建议</strong></p>
<ul>
<li>如果需要精确的延时（毫秒级）并发处理，使用专门消息队列（Kafka&#x2F; Pulsar &#x2F; RabbitMQ + delayed plugin）可能更稳健。</li>
<li>Redis 实现适合中等规模的延时任务和简单可靠性场景；要考虑并发锁与去重、一定的重复消费&#x2F;幂等处理。</li>
</ul>
<hr>
<h3 id="8-Redis-中的-String-是怎么实现的？"><a href="#8-Redis-中的-String-是怎么实现的？" class="headerlink" title="8. Redis 中的 String 是怎么实现的？"></a>8. Redis 中的 String 是怎么实现的？</h3><p><strong>SDS（Simple Dynamic String）</strong></p>
<ul>
<li>Redis <code>String</code> 的底层使用 <strong>SDS</strong> 而不是 C 的 NUL-terminated <code>char*</code>。SDS 提供：<ul>
<li>二进制安全（可以包含 <code>\0</code>）；</li>
<li>存储长度（O(1) 获取），避免每次 <code>strlen</code>；</li>
<li>预留空间（free 字段），减少重复 realloc。</li>
</ul>
</li>
<li><strong>Object encoding</strong>：<ul>
<li><strong>RAW</strong>：标准 SDS 存储。</li>
<li><strong>EMBSTR</strong>：当字符串短时，将 SDS 与 Redis 对象 header 一起分配在一个内存块（减少内存碎片、提升效率）。</li>
<li><strong>INT</strong>：对于纯数字字符串，Redis 可以把对象以 long long int 存储为整数编码以节约空间&#x2F;加速。</li>
</ul>
</li>
<li><strong>指令语义</strong>：<code>SET</code>&#x2F;<code>GET</code>&#x2F;<code>INCR</code>&#x2F;<code>APPEND</code> 等直接操作 SDS。</li>
</ul>
<hr>
<h3 id="9-Redis-中-ZSet（有序集合）怎么实现的？"><a href="#9-Redis-中-ZSet（有序集合）怎么实现的？" class="headerlink" title="9. Redis 中 ZSet（有序集合）怎么实现的？"></a>9. Redis 中 ZSet（有序集合）怎么实现的？</h3><p><strong>双结构实现</strong></p>
<ul>
<li><strong>跳表（skiplist）</strong>：按 score 排序，支持按 score 范围查询、分页、顺序遍历。skiplist 使得范围查询与插入复杂度 O(log N)。</li>
<li><strong>哈希表（dict）</strong>：<code>member -&gt; score</code> 映射，用于 O(1) 校验 member 是否存在 &amp; 直接更新 score。</li>
<li>操作流程：<ul>
<li><code>ZADD</code>：先在 dict 看是否存在 member：若存在则更新跳表（先删除旧 score 再插入新 score）；否则新插入到 dict 且插入跳表。</li>
<li><code>ZRANGE</code> &#x2F; <code>ZRANGEBYSCORE</code>：跳表定位起点，然后按链表遍历返回 M 个元素（复杂度 O(log N + M)）。</li>
</ul>
</li>
<li><strong>优势</strong>：结合哈希表及跳表兼顾了 O(1) 查找与 O(log N) 排序操作。</li>
</ul>
<hr>
<h3 id="10-使用-Redis-实现排行榜（Leaderboard）"><a href="#10-使用-Redis-实现排行榜（Leaderboard）" class="headerlink" title="10. 使用 Redis 实现排行榜（Leaderboard）"></a>10. 使用 Redis 实现排行榜（Leaderboard）</h3><p><strong>Simple（单实例）</strong></p>
<ul>
<li>使用 ZSet，member&#x3D;用户ID，score&#x3D;分值。<ul>
<li>加分&#x2F;设置分数：<code>ZINCRBY leaderboard delta userId</code> 或 <code>ZADD leaderboard score userId</code></li>
<li>获取排名（倒序，分值高为第一）：<code>ZREVRANK leaderboard userId</code>（返回索引，从0开始）</li>
<li>获取 top N：<code>ZREVRANGE leaderboard 0 N-1 WITHSCORES</code></li>
<li>获取范围分页：<code>ZREVRANGE leaderboard start stop WITHSCORES</code></li>
</ul>
</li>
<li>注意分数精度：Redis score 是 double 浮点；若需要精确整数，直接存整数或把分数放大（乘 100）存为 double。</li>
</ul>
<p><strong>带用户信息</strong></p>
<ul>
<li>存分数在 ZSet，用户详情放 in Hash <code>user:userid</code>。</li>
<li>在返回 top N 时 <code>ZREVRANGE ... WITHSCORES</code> 得到 ids，再批量 <code>HMGET</code> 拉取信息（pipeline）。</li>
</ul>
<p><strong>并发&#x2F;多实例&#x2F;集群</strong></p>
<ul>
<li>在 Cluster 模式确保访问同一 key（slot）或者使用客户端支持跨 slot 聚合。</li>
<li>若写入非常频繁并导致单点瓶颈，可考虑分片或以时间段为单位分 ZSet 再合并（复杂）。</li>
</ul>
<p><strong>大规模与历史榜</strong></p>
<ul>
<li>使用 time-windowed sorted sets（例如按日&#x2F;周&#x2F;月 leaderboard）来实现历史和滚动排名。</li>
</ul>
<hr>
<h3 id="11-用-Redis-实现注册中心（Service-Registry）"><a href="#11-用-Redis-实现注册中心（Service-Registry）" class="headerlink" title="11. 用 Redis 实现注册中心（Service Registry）"></a>11. 用 Redis 实现注册中心（Service Registry）</h3><p><strong>思路（轻量）</strong></p>
<ul>
<li>每个服务实例启动时 <code>SET service:&#123;name&#125;:&#123;instanceId&#125; metadata NX PX heartbeatInterval*...</code> 或 <code>HSET service:&#123;name&#125; &#123;instanceId&#125; metadata</code> 并配合 <code>EXPIRE</code> 或定时续租心跳。</li>
<li>客户端注册：<code>SET</code> 或 <code>HSET</code> + TTL，每隔 <code>t</code> 秒心跳延长 TTL（或重新 <code>SET</code>）。</li>
<li>服务发现：客户端查询 <code>SCAN</code>&#x2F;<code>KEYS service:&#123;name&#125;*</code> 或使用 <code>SMEMBERS services:&#123;name&#125;</code>（如果用集合管理）。</li>
<li>监听变更：使用 Pub&#x2F;Sub 或 Redis Stream 发布 <code>service-up</code> &#x2F; <code>service-down</code> 事件；或者消费者轮询 TTL 变化。</li>
</ul>
<p><strong>优点&#x2F;缺点</strong></p>
<ul>
<li>优点：简单、延迟低。</li>
<li>缺点：<ul>
<li>Redis 仍是单点（需 Sentinel&#x2F;Cluster 做 HA），</li>
<li>对于强一致性（leader 选举、分布式锁）不如 ZooKeeper&#x2F;etcd 可靠（但可做）。</li>
</ul>
</li>
<li><strong>改进</strong>：使用 Redis + Sentinel&#x2F;Cluster + 客户端缓存 + watch&#x2F;notify 来降低读延时与感知延迟。</li>
</ul>
<hr>
<h3 id="12-Redis-的线程模型"><a href="#12-Redis-的线程模型" class="headerlink" title="12. Redis 的线程模型"></a>12. Redis 的线程模型</h3><ul>
<li>单主线程处理命令（event-loop），I&#x2F;O 多路复用。</li>
<li>背景线程&#x2F;进程：<ul>
<li><strong>子进程 fork</strong>：RDB 保存与 AOF rewrite 用 fork 的子进程做 IO 操作；</li>
<li><strong>后台线程</strong>（某些版本）用于异步删除（lazyfree）、部分模块、RDB&#x2F;AOF rewrite 辅助；</li>
<li><strong>I&#x2F;O 线程</strong>（自 Redis 6 起）可并行化 socket read&#x2F;write，但命令处理仍在主线程。</li>
</ul>
</li>
<li>写时复制（COW）在 fork 时会复制页面，可能导致内存短期上涨。</li>
<li>因为命令执行单线程，所以任何阻塞式命令或慢命令（例如 <code>KEYS</code>、大 <code>SORT</code>、遍历超大集合）会阻塞整个服务。要避免这些慢命令或使用 <code>SCAN</code> &#x2F; <code>SSCAN</code> &#x2F; <code>ZSCAN</code> &#x2F; <code>HSCAN</code> 做渐进式遍历。</li>
</ul>
<hr>
<h3 id="13-Redis-的事务（MULTI-EXEC-WATCH）"><a href="#13-Redis-的事务（MULTI-EXEC-WATCH）" class="headerlink" title="13. Redis 的事务（MULTI&#x2F;EXEC&#x2F;WATCH）"></a>13. Redis 的事务（MULTI&#x2F;EXEC&#x2F;WATCH）</h3><ul>
<li><strong>MULTI &#x2F; EXEC &#x2F; DISCARD</strong><ul>
<li><code>MULTI</code> 开始事务（只是命令排队）。</li>
<li>客户端在 <code>EXEC</code> 时，队列中的命令会被一次性执行（单线程原子性：中间不会被其他命令插入），但 <strong>如果命令内部失败，事务不会回滚</strong>，失败的只是那条命令。</li>
</ul>
</li>
<li><strong>WATCH</strong>（乐观锁）<ul>
<li><code>WATCH key1 key2</code> 监视 key，如果在 <code>EXEC</code> 前这些 key 被其他客户端改动，则 <code>EXEC</code> 返回 null，事务失败（可重试）。</li>
<li><code>UNWATCH</code> 取消监视。</li>
</ul>
</li>
<li><strong>局限</strong><ul>
<li>Redis 事务不是关系型数据库意义上的事务（没有隔离级别、没有回滚机制）；只是命令批量的“原子提交”。</li>
<li>在 Cluster 上，MULTI&#x2F;EXEC 要求所有 key 属于同一 hash slot（否则会报错）。</li>
</ul>
</li>
<li><strong>替代</strong>：Lua 脚本（EVAL）在 Redis 中是原子执行、能做复杂原子操作、支持返回值；在多数场景下比 MULTI 更强大与安全。</li>
</ul>
<hr>
<h3 id="14-Redis-IO-多路复用模型（实现细节）"><a href="#14-Redis-IO-多路复用模型（实现细节）" class="headerlink" title="14. Redis IO 多路复用模型（实现细节）"></a>14. Redis IO 多路复用模型（实现细节）</h3><ul>
<li>使用 <code>ae</code> 事件库封装系统调用：<code>select</code> &#x2F; <code>poll</code> &#x2F; <code>epoll</code> &#x2F; <code>kqueue</code>。在 Linux 下主要使用 <code>epoll</code>。</li>
<li>事件循环做两件事：处理读&#x2F;写&#x2F;accept 等事件 &amp; 执行命令。网络读到完整请求后放到客户端上下文，主线程解析命令并执行。</li>
<li>Redis 采用<strong>非阻塞 IO</strong>与事件驱动来实现高并发连接处理。</li>
</ul>
<hr>
<h3 id="15-Redis-的大-key（big-key）以及原因"><a href="#15-Redis-的大-key（big-key）以及原因" class="headerlink" title="15. Redis 的大 key（big key）以及原因"></a>15. Redis 的大 key（big key）以及原因</h3><p><strong>什么是大 key</strong></p>
<ul>
<li>指一个 key 本身内部的数据量很大（如一个包含数百万元素的 list&#x2F;hash&#x2F;zset 或非常大的 string），导致对该 key 的任何操作都很耗时且可能阻塞服务。</li>
</ul>
<p><strong>为什么产生</strong></p>
<ul>
<li>不合理的数据模型（把太多用户或日志塞入单个 list&#x2F;hash）。</li>
<li>未分片或未分块地存储大量数据（例如把百万级别日志存在一个 list）。</li>
<li>忽用 <code>KEYS</code> &#x2F; <code>SMEMBERS</code> 等一次性返回全量接口。</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li>操作该 key（如 <code>LRANGE</code>、<code>DEL</code>、<code>HGETALL</code>）将占用大量 CPU &#x2F; 内存并可能阻塞主线程，导致延迟飙升。</li>
<li><code>DEL</code> 可能会阻塞；现代 Redis 有 <code>UNLINK</code>（异步删除后台释放内存）来缓解。</li>
</ul>
<p><strong>检测大 key</strong></p>
<ul>
<li><code>redis-cli --bigkeys</code>（工具）会扫描样本并报告大 key。</li>
<li><code>MEMORY USAGE key</code> 查看内存占用。</li>
<li><code>DEBUG OBJECT key</code>（谨慎）或 <code>OBJECT encoding key</code> 查看编码&#x2F;结构。</li>
</ul>
<p><strong>对策</strong></p>
<ul>
<li>设计分片，比如把单个 list 分成为 <code>list:YYYYMMDD:shardId</code>。</li>
<li>使用流（Streams）或外部存储（对象存储）分离非常大的二进制数据。</li>
<li>使用 <code>UNLINK</code> 替代 <code>DEL</code> 做异步删除。</li>
<li>避免一次性全量操作，使用 <code>SCAN/SSCAN/ZSCAN/HSCAN</code> 进行增量遍历。</li>
</ul>
<hr>
<h3 id="16-Redis-的集群模式（工作原理）"><a href="#16-Redis-的集群模式（工作原理）" class="headerlink" title="16. Redis 的集群模式（工作原理）"></a>16. Redis 的集群模式（工作原理）</h3><p><strong>核心概念</strong></p>
<ul>
<li>将 key 空间分为 <strong>16384 slots</strong>，每个 master 负责若干 slot。</li>
<li><strong>节点角色</strong>：master + optional replicas（replica 用于 failover）。</li>
<li><strong>重定向</strong>：客户端访问非本节点的 slot 会收到 <code>MOVED</code>（静态重定位）或 <code>ASK</code>（重分配临时重定向）。</li>
<li><strong>数据迁移（resharding）</strong>：通过 <code>MIGRATE</code> 或 <code>CLUSTER</code> 命令把 slot 从一个节点迁到另一个节点（期间会产生 <code>ASK</code> 临时指令）。</li>
<li><strong>故障转移</strong>：<ul>
<li>Cluster 各节点通过 gossip 协议互相通告状态，若 master 挂掉且多数 replicas 同意（based on configEpoch &amp; votes），会选举一个 replica 为新的 master（自动 failover）。</li>
</ul>
</li>
<li><strong>事务与 multi-key 操作</strong><ul>
<li>多 key 命令要求所有 key 在同一 slot（或使用 <code>&#123;hash-tag&#125;</code> 把相关 key 放入同 slot），否则报错。</li>
</ul>
</li>
<li><strong>客户端</strong><ul>
<li>Cluster-aware 客户端会缓存 cluster slots 映射并自动跟随 <code>MOVED</code> 重定向。</li>
</ul>
</li>
<li><strong>工程注意</strong><ul>
<li>设计时尽量把相关 key 放同 slot（hash tag）。</li>
<li>监控 cluster slots 分布、replication lag、failover 次数。</li>
<li>节点拓扑要冗余部署（不同机房&#x2F;可用区）。</li>
</ul>
</li>
</ul>
<h2 id="Mybatis-牛客面经八股"><a href="#Mybatis-牛客面经八股" class="headerlink" title="Mybatis-牛客面经八股"></a>Mybatis-牛客面经八股</h2><h3 id="1-与-的区别"><a href="#1-与-的区别" class="headerlink" title="1. $ 与 # 的区别"></a>1. <code>$</code> 与 <code>#</code> 的区别</h3><ul>
<li><code>#&#123;param&#125;</code>：使用 JDBC 的 <code>PreparedStatement</code> 占位符 <code>?</code> 绑定参数，会进行 <strong>类型转换 &amp; 自动转义</strong>（防 SQL 注入），例如 <code>WHERE name = #&#123;name&#125;</code> 生成 <code>WHERE name = ?</code>。</li>
<li><code>$&#123;param&#125;</code>：直接字符串替换（文本替换），相当于把 param 拼进 SQL；用于列名 &#x2F; 表名等动态 SQL 片段，但<strong>存在 SQL 注入风险</strong>。<br> <strong>建议</strong>：优先用 <code>#&#123;&#125;</code>，只有在必须动态拼字段&#x2F;表名时且经过严格白名单校验时才用 <code>$&#123;&#125;</code>。</li>
</ul>
<hr>
<h3 id="2-MyBatis-的缓存机制"><a href="#2-MyBatis-的缓存机制" class="headerlink" title="2. MyBatis 的缓存机制"></a>2. MyBatis 的缓存机制</h3><ul>
<li><strong>一级缓存（Local Cache）</strong><ul>
<li>作用域：<code>SqlSession</code> 级别（会话级），默认开启。</li>
<li>行为：相同 <code>SqlSession</code> 内重复执行同一查询会命中缓存，直到 <code>SqlSession</code> 关闭或执行更新操作（UPDATE&#x2F;INSERT&#x2F;DELETE）导致缓存失效。</li>
</ul>
</li>
<li><strong>二级缓存（Global Cache）</strong><ul>
<li>作用域：namespace（mapper）级别，跨 SqlSession 共享。</li>
<li>需要在 <code>mapper.xml</code> 中 <code>&lt;cache/&gt;</code> 显式开启（或配置实现），也可以自定义 Cache 实现。</li>
<li>缓存 key 由 <code>CacheKey</code> 生成（含 mappedStatement id、SQL、param、分页、环境等）。</li>
<li>写操作会清空（flush）对应 namespace 的二级缓存（默认行为）。</li>
</ul>
</li>
<li><strong>实现细节</strong><ul>
<li>二级缓存会序列化&#x2F;反序列化对象（默认 Java 序列化），可插入更高效的序列化（Kryo、FST）或用外部存储（Redis）实现二级缓存。</li>
<li>若对象含有可变字段，缓存可能产生 stale 数据；要慎重设计缓存失效策略。</li>
</ul>
</li>
<li><strong>常见优化</strong><ul>
<li>使用二级缓存时需确保对象可序列化并合理设置 <code>flushInterval</code>、<code>size</code>、<code>readWrite</code>（readWrite&#x3D;true 表示序列化读写以保证线程安全）。</li>
<li>对于频繁变更的数据不适合二级缓存。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-MyBatis-实现一对多关联查询（两种主要方式）"><a href="#3-MyBatis-实现一对多关联查询（两种主要方式）" class="headerlink" title="3. MyBatis 实现一对多关联查询（两种主要方式）"></a>3. MyBatis 实现一对多关联查询（两种主要方式）</h3><ol>
<li><p><strong>一条 SQL 联表查询 + resultMap 映射</strong></p>
<ul>
<li>使用 <code>JOIN</code>，配置 <code>&lt;resultMap&gt;</code>，其中 <code>&lt;collection property=&quot;orders&quot; ofType=&quot;Order&quot;&gt;</code> 映射子集合，通过 <code>resultMap</code> 的 <code>column</code> 指定关联字段。</li>
<li>优点：只一次数据库往返；缺点：如果主表 N 行、子表 M 行，返回的行数为笛卡尔展开，可能造成重复主对象需要去重（MyBatis 自动处理但会消耗内存）。</li>
</ul>
</li>
<li><p><strong>分两次查询（N+1 问题的改良）</strong></p>
<ul>
<li><p>先查询主表集合，得到 id 列表；再用 <code>IN</code> 查询子表 <code>WHERE fk IN (...)</code>，然后在 Java 层组装。</p>
</li>
<li><p>MyBatis 提供 <code>&lt;select&gt;</code> 的 <code>resultMap</code> 嵌套 <code>&lt;collection&gt;</code> 的 <code>fetchType=&quot;lazy&quot;</code> 或 <code>select</code> 属性（嵌套查询）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Order&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectOrdersByUserId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：避免单次大联表重复数据，适合主从表一对多规模较大场景。<br> <strong>工程建议</strong>：对于小表&#x2F;数据量少，用单表 JOIN；对于大数据量&#x2F;分页场景，用两步查询（单次 IN 查询）并注意限制 IN 的长度或分批查询。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-MyBatis-如何防止-SQL-注入"><a href="#4-MyBatis-如何防止-SQL-注入" class="headerlink" title="4. MyBatis 如何防止 SQL 注入"></a>4. MyBatis 如何防止 SQL 注入</h3><ul>
<li><strong>首要原则</strong>：使用 <code>#&#123;&#125;</code> 参数绑定（PreparedStatement）代替字符串拼接。</li>
<li>对必须拼接的元数据（表名、列名）使用白名单校验（只允许已知的列名&#x2F;表名），不要直接把来自用户的原始值放到 <code>$&#123;&#125;</code>。</li>
<li>使用数据库权限最小化策略、审核 SQL 日志、在应用层做参数校验与类型检查。</li>
<li>对动态 SQL 执行做好限制（分页参数必须是整型、限制 pageSize 最大值等）。</li>
</ul>
<hr>
<h3 id="5-MyBatis-和-MyBatis-Plus-的区别"><a href="#5-MyBatis-和-MyBatis-Plus-的区别" class="headerlink" title="5. MyBatis 和 MyBatis-Plus 的区别"></a>5. MyBatis 和 MyBatis-Plus 的区别</h3><ul>
<li><strong>MyBatis</strong><ul>
<li>更轻量、原始、需要手写 SQL&#x2F;映射。</li>
<li>灵活性高，适合复杂 SQL 与精确控制。</li>
</ul>
</li>
<li><strong>MyBatis-Plus (MP)</strong><ul>
<li>在 MyBatis 基础上提供<strong>增强功能</strong>：通用 CRUD（无需写 SQL）、代码生成器、Wrapper 条件构造器、分页插件、逻辑删除、性能分析插件等。</li>
<li>优点：提高开发效率，减少重复 CRUD 代码。</li>
<li>缺点：抽象层更多，可能隐藏 SQL 细节（需要关注生成 SQL 性能）；对复杂 SQL 还是需要自定义。<br> <strong>选择</strong>：如果项目是标准 CRUD 大量重复，使用 MP 可以大幅提升效率；对复杂查询&#x2F;性能敏感的模块仍应手写 Mapper SQL。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-MyBatis-如何实现分页查询"><a href="#6-MyBatis-如何实现分页查询" class="headerlink" title="6. MyBatis 如何实现分页查询"></a>6. MyBatis 如何实现分页查询</h3><ul>
<li><p><strong>RowBounds（物理分页）</strong>：MyBatis 提供 <code>RowBounds</code> 类用于客户端分页。缺点：默认实现会在内存中做分页（取出全部结果再截取），不适合大量数据。</p>
</li>
<li><p><strong>数据库分页（推荐）</strong>：使用 <code>LIMIT/OFFSET</code>（MySQL&#x2F;Postgres），或相应 DB dialect 的分页语法。通常使用分页插件（例如 PageHelper）或 MyBatis-Plus 的 <code>IPage</code>&#x2F;<code>Page</code> 对象自动注入分页 SQL。</p>
</li>
<li><p><strong>步骤示例（MySQL）</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users</span><br><span class="line">WHERE ...</span><br><span class="line">ORDER BY created_at DESC</span><br><span class="line">LIMIT #&#123;offset&#125;, #&#123;pageSize&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>高级</strong>：对于大偏移（offset 大），建议使用基于索引的分页（记录上次最后 id）避免 OFFSET 扫描开销。</p>
</li>
</ul>
<hr>
<h3 id="7-MyBatis-中动态-SQL-的作用"><a href="#7-MyBatis-中动态-SQL-的作用" class="headerlink" title="7. MyBatis 中动态 SQL 的作用"></a>7. MyBatis 中动态 SQL 的作用</h3><ul>
<li><p>使用 XML 标签（<code>&lt;if&gt;</code>, <code>&lt;where&gt;</code>, <code>&lt;trim&gt;</code>, <code>&lt;foreach&gt;</code>, <code>&lt;choose&gt;</code> 等）根据传入参数动态拼装 SQL。</p>
</li>
<li><p>作用：</p>
<ul>
<li>避免手写大量 SQL 变体。</li>
<li>提高复用性：同一 mapper 方法根据条件生成不同 where 子句。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUsers&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM user</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>AND name = #&#123;name&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span>AND age = #&#123;age&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="8-MyBatis-的插件原理（Interceptor）"><a href="#8-MyBatis-的插件原理（Interceptor）" class="headerlink" title="8. MyBatis 的插件原理（Interceptor）"></a>8. MyBatis 的插件原理（Interceptor）</h3><ul>
<li>MyBatis 提供插件接口 <code>org.apache.ibatis.plugin.Interceptor</code>，可以拦截：<ul>
<li><code>Executor</code>（执行器）、</li>
<li><code>StatementHandler</code>（SQL 执行）、</li>
<li><code>ParameterHandler</code>（参数处理）、</li>
<li><code>ResultSetHandler</code>（结果处理）。</li>
</ul>
</li>
<li>插件通过 <code>Plugin.wrap(target, this)</code> 返回代理对象（JDK 动态代理）。拦截器的 <code>intercept(Invocation invocation)</code> 可以在调用前&#x2F;后做增强，或替换执行逻辑。</li>
<li>插件在配置文件中注册并按顺序生效。典型应用：分页插件、性能监控、动态数据源切换等。</li>
</ul>
<h4 id="PageHelper-插件原理分析"><a href="#PageHelper-插件原理分析" class="headerlink" title="PageHelper 插件原理分析"></a><strong>PageHelper 插件原理分析</strong></h4><p>PageHelper 是一个 <strong>MyBatis 插件（Interceptor）</strong>，它的核心思想是：<br> 通过 <strong>拦截 SQL 执行过程</strong>，在执行真正的 SQL 前后，动态修改 SQL 语句，在 SQL 中追加 <code>LIMIT</code>（MySQL）&#x2F; <code>ROWNUM</code>（Oracle） 等分页语法，从而实现物理分页。</p>
<hr>
<h5 id="1-PageHelper-的使用方式"><a href="#1-PageHelper-的使用方式" class="headerlink" title="1. PageHelper 的使用方式"></a><strong>1. PageHelper 的使用方式</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);  <span class="comment">// 开始分页（第 1 页，每页 10 条）</span></span><br><span class="line">List&lt;User&gt; list = userMapper.selectAll();</span><br><span class="line">PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(list);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PageHelper.startPage()</code> 并不是直接分页，而是 <strong>设置分页参数到 ThreadLocal</strong>。</li>
<li>当 MyBatis 执行查询 SQL 时，PageHelper 插件会 <strong>检测到当前线程存在分页参数</strong>，拦截 SQL 并修改。</li>
</ul>
<hr>
<h5 id="2-PageHelper-的拦截点"><a href="#2-PageHelper-的拦截点" class="headerlink" title="2. PageHelper 的拦截点"></a><strong>2. PageHelper 的拦截点</strong></h5><p>PageHelper 是基于 MyBatis 的插件机制实现的，主要拦截：</p>
<ul>
<li><strong>Executor.query</strong><br> MyBatis 执行 SQL 查询的入口点。</li>
<li>具体类：<code>PageInterceptor</code>，实现了 <code>Interceptor</code> 接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">  @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Intercepts</code> 注解表示拦截 <code>Executor.query()</code> 方法。</li>
<li>当执行 Mapper 的 <code>select</code> 方法时，会被拦截。</li>
</ul>
<hr>
<h5 id="3-PageHelper-的核心流程"><a href="#3-PageHelper-的核心流程" class="headerlink" title="3. PageHelper 的核心流程"></a><strong>3. PageHelper 的核心流程</strong></h5><h6 id="1-PageHelper-startPage"><a href="#1-PageHelper-startPage" class="headerlink" title="(1) PageHelper.startPage()"></a>(1) <code>PageHelper.startPage()</code></h6><ul>
<li>把分页参数（页码 pageNum，每页大小 pageSize，是否统计 count）放入 <code>ThreadLocal</code>。</li>
<li>这样就可以在后续 SQL 执行时，读取到这些分页参数。</li>
</ul>
<hr>
<h6 id="2-PageInterceptor-拦截-query"><a href="#2-PageInterceptor-拦截-query" class="headerlink" title="(2) PageInterceptor 拦截 query()"></a>(2) PageInterceptor 拦截 <code>query()</code></h6><p>拦截到 SQL 执行时，会做几件事：</p>
<ol>
<li><p><strong>获取分页参数</strong>（从 <code>ThreadLocal</code>）。</p>
</li>
<li><p><strong>解析原始 SQL</strong>，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生成分页 SQL</strong>（根据不同数据库方言，比如 MySQL &#x2F; Oracle）：</p>
<ul>
<li><p>MySQL:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">0</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Oracle:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> rownum rn, t.<span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>) t <span class="keyword">WHERE</span> rownum <span class="operator">&lt;=</span> <span class="number">10</span></span><br><span class="line">) <span class="keyword">WHERE</span> rn <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>PostgreSQL:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>生成 count SQL（可选）</strong>，如果需要分页总数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>PageHelper 会先执行 count SQL，得到总记录数。</li>
<li>然后再执行分页 SQL，得到当前页数据。</li>
</ul>
</li>
</ol>
<hr>
<h6 id="3-执行分页-SQL-返回结果"><a href="#3-执行分页-SQL-返回结果" class="headerlink" title="(3) 执行分页 SQL &amp; 返回结果"></a>(3) 执行分页 SQL &amp; 返回结果</h6><ul>
<li>PageHelper 执行改写后的分页 SQL。</li>
<li>把结果封装成 <code>Page</code> 或 <code>PageInfo</code> 对象，包含：<ul>
<li><code>pageNum</code>（当前页）</li>
<li><code>pageSize</code>（每页大小）</li>
<li><code>total</code>（总记录数）</li>
<li><code>pages</code>（总页数）</li>
<li><code>list</code>（当前页数据）</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-PageHelper-的核心类"><a href="#4-PageHelper-的核心类" class="headerlink" title="4. PageHelper 的核心类"></a><strong>4. PageHelper 的核心类</strong></h5><ul>
<li><code>PageHelper</code>：入口工具类，负责设置分页参数（存入 ThreadLocal）。</li>
<li><code>Page</code>：继承 <code>ArrayList</code>，存放分页结果，同时保存分页信息（total, pageNum, pageSize）。</li>
<li><code>PageInterceptor</code>：MyBatis 插件拦截器，核心逻辑在这里。</li>
<li><code>Dialect</code>：方言类，不同数据库分页 SQL 的实现（MySQLDialect、OracleDialect 等）。</li>
</ul>
<hr>
<h5 id="5-PageHelper-的优势"><a href="#5-PageHelper-的优势" class="headerlink" title="5. PageHelper 的优势"></a><strong>5. PageHelper 的优势</strong></h5><ul>
<li>使用方便：只需 <code>startPage()</code> 即可，不用手写分页 SQL。</li>
<li>支持多数据库：内部有方言适配器。</li>
<li>支持自动 count，总页数计算简单。</li>
<li>基于 MyBatis 插件机制，不需要改动 SQL。</li>
</ul>
<hr>
<h5 id="6-PageHelper-的局限性"><a href="#6-PageHelper-的局限性" class="headerlink" title="6. PageHelper 的局限性"></a><strong>6. PageHelper 的局限性</strong></h5><ol>
<li><strong>线程绑定问题</strong><ul>
<li><code>startPage()</code> 依赖 <code>ThreadLocal</code>，必须在查询语句之前调用，否则无效。</li>
<li>如果一个线程执行多个分页，可能会出现混乱，需要注意调用顺序。</li>
</ul>
</li>
<li><strong>count 性能问题</strong><ul>
<li>大表 <code>COUNT(*)</code> 代价很高，可能导致分页慢。</li>
<li>可通过优化 SQL 或冗余字段来避免。</li>
</ul>
</li>
<li><strong>复杂 SQL 的 count 不准确</strong><ul>
<li>比如包含 <code>GROUP BY</code> &#x2F; <code>DISTINCT</code> 时，count 语句可能需要手动优化。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h5><p>👉 <strong>PageHelper 的核心原理：</strong></p>
<ul>
<li>基于 MyBatis 插件机制，拦截 <code>Executor.query()</code>。</li>
<li>利用 <code>ThreadLocal</code> 传递分页参数。</li>
<li>动态改写 SQL，生成 <code>count SQL + limit SQL</code>。</li>
<li>执行后封装结果集为分页对象返回。</li>
</ul>
<hr>
<h3 id="9-MyBatis-底层原理（请求执行全流程）"><a href="#9-MyBatis-底层原理（请求执行全流程）" class="headerlink" title="9. MyBatis 底层原理（请求执行全流程）"></a>9. MyBatis 底层原理（请求执行全流程）</h3><p><strong>核心组件与调用链（简化）</strong></p>
<ol>
<li><strong>Configuration</strong>：解析 mapper XML &#x2F; 注解，构建 <code>MappedStatement</code>、<code>ResultMap</code>、<code>SqlSource</code> 等。</li>
<li><strong>SqlSessionFactory</strong>：负责创建 <code>SqlSession</code>。</li>
<li><strong>SqlSession</strong>：一切 DB 操作入口，提供 <code>select/insert/update/delete</code> 等方法。</li>
<li><strong>Mapper Proxy</strong>：<code>Mapper</code> 接口通过 JDK Proxy（或 CGLIB）生成，调用 mapper 方法会转发到 <code>MapperProxy</code>，最终调用 <code>SqlSession</code> 执行对应 <code>MappedStatement</code>。</li>
<li><strong>Executor</strong>：执行器负责缓存策略、调用 <code>StatementHandler</code> 执行 JDBC。<ul>
<li>Executor -&gt; <code>StatementHandler.prepare()</code> -&gt; <code>ParameterHandler.setParameters()</code> -&gt; <code>Statement.executeQuery()</code> -&gt; <code>ResultSetHandler.handleResultSets()</code>。</li>
</ul>
</li>
<li><strong>StatementHandler &#x2F; ParameterHandler &#x2F; ResultSetHandler</strong><ul>
<li><code>StatementHandler</code> 负责创建 JDBC Statement（PreparedStatement）、设置分页 SQL（如果 RowBounds）或其他变换。</li>
<li><code>ParameterHandler</code> 负责把参数绑定到 PreparedStatement 的 <code>?</code> 上（依赖 TypeHandler）。</li>
<li><code>ResultSetHandler</code> 把 JDBC <code>ResultSet</code> 映射成 Java 对象（使用 <code>ResultMap</code> 的映射规则）。</li>
</ul>
</li>
<li><strong>TypeHandler</strong><ul>
<li>用于 Java 类型与 JDBC 类型映射（可以自定义，例如 JSON 序列化）。</li>
</ul>
</li>
<li><strong>动态 SQL 处理</strong><ul>
<li>Mapper XML 中的 <code>&lt;if&gt;</code>&#x2F;<code>&lt;foreach&gt;</code> 在构建 <code>SqlSource</code> 时会被解析为 <code>DynamicSqlSource</code>，执行时生成 <code>BoundSql</code>（最终 SQL + 参数映射）。</li>
</ul>
</li>
<li><strong>缓存</strong><ul>
<li>Executor 在执行前会根据 <code>CacheKey</code> 进行一级&#x2F;二级缓存查询。</li>
</ul>
</li>
<li><strong>事务</strong><ul>
<li><code>SqlSession</code> 管理事务（底层使用 JDBC 事务或 Spring 的 DataSource 事务管理）。</li>
</ul>
</li>
</ol>
<p><strong>关键点</strong></p>
<ul>
<li>MyBatis 把 SQL 与 Java 映射隔离，运行时通过配置构建执行计划。</li>
<li>动态 SQL 在解析时产生一颗语法树，在执行时按参数生成真实 SQL。</li>
<li>MyBatis 允许自定义拦截器、TypeHandler、插件扩展点。</li>
</ul>
<h2 id="SQL-牛客面经八股"><a href="#SQL-牛客面经八股" class="headerlink" title="SQL-牛客面经八股"></a>SQL-牛客面经八股</h2><p>好 —— 我把你 1–31 每一条都<strong>逐项放大解读</strong>，把原理、实现细节、面试要点、常见例子、实践建议和可复制的解决办法都写清楚。篇幅较长，但这是一次把知识“掰开揉碎”到能直接答面试与做线上定位的版本。每一节都尽量包含：<strong>原理 → 行为&#x2F;例子 → 故障&#x2F;失效场景 → 优化&#x2F;修复办法</strong>。</p>
<hr>
<h3 id="1-什么是索引？索引有哪些分类？"><a href="#1-什么是索引？索引有哪些分类？" class="headerlink" title="1. 什么是索引？索引有哪些分类？"></a>1. 什么是索引？索引有哪些分类？</h3><p><strong>概念（本质）</strong><br> 索引是为表中一列或多列建立的 <strong>辅助数据结构</strong>，用于快速定位满足某些条件的记录，减少磁盘 I&#x2F;O 和全表扫描。数据库把索引看成“查表的导航”。</p>
<p><strong>按维度分类（并扩展解释）</strong></p>
<ul>
<li><strong>按数据结构</strong><ul>
<li><strong>B+Tree（B+ 树）</strong>：最常见。支持范围查询、排序、分页；磁盘&#x2F;页友好（一次读回多个 key）。</li>
<li><strong>Hash</strong>：O(1) 等值查询，不能做范围&#x2F;排序。MySQL InnoDB 没有用户可见 Hash index，但 MEMORY 存储引擎提供 hash 索引。InnoDB 有 <strong>Adaptive Hash Index（自适应哈希索引）</strong> 作为优化。</li>
<li><strong>Fulltext</strong>：倒排索引，用于全文检索（MATCH…AGAINST）。</li>
<li><strong>R-Tree &#x2F; GiST &#x2F; SPATIAL</strong>：用于空间数据（GIS）。</li>
</ul>
</li>
<li><strong>按逻辑用途</strong><ul>
<li><strong>主键索引（PRIMARY KEY）</strong>：唯一，不能为 NULL，InnoDB 中是聚簇索引。</li>
<li><strong>唯一索引（UNIQUE）</strong>：保证列唯一性。</li>
<li><strong>普通索引（INDEX）</strong></li>
</ul>
</li>
<li><strong>按物理存放与访问</strong><ul>
<li><strong>聚簇索引（Clustered）</strong>：叶子存整行（InnoDB 主键）。</li>
<li><strong>非聚簇索引（Secondary）</strong>：叶子存主键值（回表）。</li>
</ul>
</li>
<li><strong>按列数</strong><ul>
<li><strong>单列索引</strong>、<strong>联合（复合）索引</strong>。</li>
</ul>
</li>
</ul>
<p><strong>面试&#x2F;实践要点</strong>：<br> 索引不是越多越好。索引是读优化并以写代价换取的：每次写&#x2F;更新都要维护索引（开销 + 额外 IO + 可能的锁）。</p>
<hr>
<h3 id="2-Hash-索引-与-BTree-索引-的详细区别（含-InnoDB-特例）"><a href="#2-Hash-索引-与-BTree-索引-的详细区别（含-InnoDB-特例）" class="headerlink" title="2. Hash 索引 与 BTree 索引 的详细区别（含 InnoDB 特例）"></a>2. Hash 索引 与 BTree 索引 的详细区别（含 InnoDB 特例）</h3><p><strong>Hash 索引</strong></p>
<ul>
<li>查找：哈希表根据 key 直接定位桶 → 平均 O(1)。</li>
<li>适用：等值查找（<code>=</code>、<code>IN</code>）。</li>
<li>不适用：范围查询（<code>BETWEEN</code>、<code>&gt;</code>、<code>LIKE &#39;a%&#39;</code> 也不能排序&#x2F;范围）。</li>
<li>MySQL 场景：MEMORY 引擎的 hash index。InnoDB 本身没有对用户表提供持久 Hash index，但内部会根据热数据构建自适应哈希索引（AHI）提升热点范围访问速度（AHI 是运行时构建的）。</li>
</ul>
<p><strong>B+Tree（B+ 树）</strong></p>
<ul>
<li>查找：O(logN)，每层读一个节点（磁盘页），节点 fanout 高，层数小。</li>
<li>优点：支持前缀匹配、范围查询、顺序扫描、order by 利用索引避免 filesort。</li>
<li>叶子节点链表使顺序遍历非常快（适合范围、分页）。</li>
</ul>
<p><strong>举例</strong></p>
<ul>
<li><code>WHERE username = &#39;alice&#39;</code>：Hash 和 B+ 树都可以很快。</li>
<li><code>WHERE age BETWEEN 20 AND 30</code>：Hash 无解，B+ 树优选。</li>
<li><code>ORDER BY created_at DESC LIMIT 10</code>：若有 B+ 树按 created_at 排序，能直接用索引返回；Hash 无法帮助排序。</li>
</ul>
<p><strong>实战提示</strong>：当查询只做大量简单等值并且无需排序&#x2F;范围时 MEMORY+Hash 或缓存（Redis）是合适的，但对于持久化大表与混合查询，B+Tree 是通用选择。</p>
<hr>
<h3 id="3-为什么-MySQL-采用-B-树？"><a href="#3-为什么-MySQL-采用-B-树？" class="headerlink" title="3. 为什么 MySQL 采用 B+ 树？"></a>3. 为什么 MySQL 采用 B+ 树？</h3><p><strong>关键原因</strong></p>
<ol>
<li><strong>磁盘&#x2F;页导向</strong>：B+ 树节点能容纳多个 key，单次磁盘读取可获得更多 key（高 fanout，低高度），极大减少磁盘 IO。</li>
<li><strong>范围&#x2F;排序原生支持</strong>：叶子节点链表可 O(1) 地从一个叶子顺序遍历到下一个叶子，范围查询&#x2F;排序&#x2F;分页高效。</li>
<li><strong>稳定的页型组织</strong>：内、外节点分工明确（内节点索引，叶节点记录或指针），便于磁盘&#x2F;缓存优化。</li>
<li><strong>顺序插入&#x2F;删除代价较低</strong>：相比红黑树的每一次调整（指针微调），B+ 树整体在磁盘环境下的重排更可控。</li>
</ol>
<p><strong>对比红黑树（或 AVL）</strong></p>
<ul>
<li>红黑树每个节点只含几个 key，深度更高，磁盘访问更多，IO 不友好。</li>
<li>B+ 树将所有 key 放在叶子并形成链表，范围扫描复杂度低且局部性好。</li>
</ul>
<hr>
<h3 id="4-B-树查询数据的全过程"><a href="#4-B-树查询数据的全过程" class="headerlink" title="4. B+ 树查询数据的全过程"></a>4. B+ 树查询数据的全过程</h3><p>以 InnoDB 的二级索引查询为例 <code>SELECT col1,col2 FROM t WHERE idx_col = ?</code>：</p>
<p><strong>步骤</strong></p>
<ol>
<li><strong>从根节点读取内存页</strong>：读取节点内的索引范围信息，根据 key 找到对应 child 指针（页 id）。</li>
<li><strong>递归下钻</strong>：在内节点根据 key 比较决定下一跳，直到叶子节点。</li>
<li><strong>叶子节点定位</strong>：<ul>
<li><strong>二级索引（非聚簇）</strong>：叶子 node 存储 <code>(indexed_key, PRIMARY_KEY)</code>。</li>
<li>找到匹配叶子项后获得主键值，<strong>回表</strong>（再走聚簇索引）以读取完整记录。</li>
<li><strong>聚簇索引（主键）</strong>：叶子直接存储完整行（或指向行在页中的偏移），无需回表。</li>
</ul>
</li>
<li><strong>返回结果</strong>：把结果发送给上层 SQL 引擎。</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li>回表成本是二级索引的一项主要开销（每命中二级索引都可能触发一或多次聚簇索引访问）。</li>
<li><strong>覆盖索引</strong>（索引包含查询所需列）可以避免回表，大幅提升效率。</li>
</ul>
<hr>
<h3 id="5-三层-B-树能存多少数据？"><a href="#5-三层-B-树能存多少数据？" class="headerlink" title="5. 三层 B+ 树能存多少数据？"></a>5. 三层 B+ 树能存多少数据？</h3><p><strong>公式法</strong></p>
<ul>
<li>假设 page（页）大小 P（常见 16KB），每个索引条目占用 S 字节（S &#x3D; key_length + pointer_length + overhead）。</li>
<li><strong>fanout ≈ floor(P &#x2F; S)</strong>（每个节点可指向 fanout 个子节点）。</li>
<li>如果高度为 h（根为第 1 层、叶为第 h 层），能表达的叶子条目数 ≈ fanout^(h-1) * entries_per_leaf（approx）。</li>
</ul>
<p><strong>举例（简化前面例子）</strong></p>
<ul>
<li>P &#x3D; 16KB &#x3D; 16384 bytes</li>
<li>S ≈ 16 bytes (8B key + 8B pointer)</li>
<li>fanout ≈ 1024</li>
<li>三层（root + level2 + leaf level）大致能表达 1024^2 ≈ 1,048,576 leaf pages，每页可包含多条记录（或 1 条 row pointer），合并到记录数上可达到亿级甚至十亿级，取决于 leaf 的条目数。</li>
</ul>
<p><strong>现实中</strong></p>
<ul>
<li>InnoDB 的 leaf 存储的是索引条目（可能多个列、变长），因此每页条目数受字符集和列长度影响。</li>
<li>实际层高通常较低（3–4），能支撑数 10^8 到 10^10 级别的记录。</li>
</ul>
<hr>
<h3 id="6-聚簇索引（Clustered）-vs-非聚簇索引（Secondary）"><a href="#6-聚簇索引（Clustered）-vs-非聚簇索引（Secondary）" class="headerlink" title="6. 聚簇索引（Clustered） vs 非聚簇索引（Secondary）"></a>6. 聚簇索引（Clustered） vs 非聚簇索引（Secondary）</h3><p><strong>聚簇索引（InnoDB 主键）</strong></p>
<ul>
<li>叶子节点存整行数据（实际数据页即为 B+ 树叶子）。</li>
<li>表的物理顺序以主键顺序组织（插入大量随机主键会导致随机写&#x2F;页面分裂）。</li>
<li>好处：<ul>
<li>主键范围查询、ORDER BY&#x2F;绿色扫描很快。</li>
<li>访问主键直接命中无需回表。</li>
</ul>
</li>
<li>坏处：<ul>
<li>每个表只能有一个聚簇索引（即只有一个物理排序方式）。</li>
<li>主键变更代价高，因为行必须移动。</li>
</ul>
</li>
</ul>
<p><strong>非聚簇索引（Secondary）</strong></p>
<ul>
<li>叶子节点存索引列 + <strong>主键</strong>（作为 row identifier）。</li>
<li>访问二级索引后需回表（通过主键再走聚簇索引获取整行）。</li>
<li>好处：<ul>
<li>可建立多种不同访问路径（多个二级索引）。</li>
</ul>
</li>
<li>坏处：<ul>
<li>回表开销，尤其是命中很多条且非覆盖时。</li>
</ul>
</li>
</ul>
<p><strong>实践建议</strong></p>
<ul>
<li>设计主键尽量使用 <strong>自增或有序主键</strong>（减少页分裂），或使用 <code>UUID</code> 的有序变体（ULID）。</li>
<li>对于频繁的聚合&#x2F;查询字段，考虑建立<strong>覆盖索引</strong>（把能覆盖查询的列都加入索引）。</li>
</ul>
<hr>
<h3 id="7-联合索引的存储结构与“最左前缀”原则"><a href="#7-联合索引的存储结构与“最左前缀”原则" class="headerlink" title="7. 联合索引的存储结构与“最左前缀”原则"></a>7. 联合索引的存储结构与“最左前缀”原则</h3><p><strong>结构</strong><br> 索引 <code>(a,b,c)</code> 在 B+ 树中是按 <code>(a,b,c)</code> 的字典序排列。索引条目的 key 为复合值。</p>
<p><strong>最左前缀原则</strong><br> 索引可用于以下查询：</p>
<ul>
<li><code>WHERE a = ?</code></li>
<li><code>WHERE a = ? AND b = ?</code></li>
<li><code>WHERE a = ? AND b BETWEEN ? AND ?</code> （b 的范围仍能使用）</li>
<li><code>WHERE a LIKE &#39;prefix%&#39;</code>（前缀匹配）</li>
<li><code>ORDER BY a, b</code>（与索引顺序匹配的排序可避免 filesort）</li>
</ul>
<p><strong>被阻断的情形（典型例子）</strong></p>
<ul>
<li><code>WHERE b = ?</code>（没有 a 的条件）不能直接利用 <code>(a,b,c)</code> 索引寻找单个 b。</li>
<li><code>WHERE a &gt; ? AND b = ? AND c = ?</code>：当对 a 使用范围（<code>&gt;</code>、<code>BETWEEN</code>），索引只能使用到 a 的范围定位，<code>b</code>&#x2F;<code>c</code> 的等值后续列不能用于索引访问（但仍可用于过滤或排序优化取决于引擎）。</li>
</ul>
<p><strong>补救办法</strong></p>
<ul>
<li>如果业务常按 b 查询，应加单列索引 <code>b</code> 或把联合索引换为 <code>(b,a,c)</code> 之类，按访问频率与选择性设计。</li>
<li>使用 <strong>索引覆盖</strong> 并合理排序联合索引字段以匹配常见 WHERE&#x2F;ORDER BY。</li>
</ul>
<hr>
<h3 id="8-SELECT-IN-模糊查询-中如何使用索引"><a href="#8-SELECT-IN-模糊查询-中如何使用索引" class="headerlink" title="8. SELECT IN &#x2F; 模糊查询 中如何使用索引"></a>8. SELECT IN &#x2F; 模糊查询 中如何使用索引</h3><p><strong>IN</strong></p>
<ul>
<li><code>col IN (v1, v2, v3)</code> 等价于多个等值条件的 OR，MySQL 可以利用索引做多个快速定位（多次索引查找或范围查找），性能通常好于多个 OR，但是具体行为可在执行计划中查看。</li>
</ul>
<p><strong>LIKE 模糊查询</strong></p>
<ul>
<li><code>LIKE &#39;abc%&#39;</code>：前缀匹配，<strong>能走索引</strong>（B+ 树从 ‘abc’ 起定位并顺序扫描）。</li>
<li><code>LIKE &#39;%abc&#39;</code>：前导通配符导致索引失效（无法从索引开始定位，因为任意前缀）。</li>
<li><code>LIKE &#39;%abc%&#39;</code>：同上，不能利用 B+ 树索引；解决方式：全文索引（FULLTEXT）或外部搜索（Elasticsearch）；或倒排索引&#x2F;三gram。</li>
</ul>
<p><strong>优化思路</strong></p>
<ul>
<li>将模糊搜索重构为前缀匹配或使用全文索引。</li>
<li>对 IN 的大集合要小心，如果 IN 列表非常长，优先把常用值放入临时表并 <code>IN (SELECT)</code> 或使用 join。</li>
</ul>
<hr>
<h3 id="9-建索引注意事项"><a href="#9-建索引注意事项" class="headerlink" title="9. 建索引注意事项"></a>9. 建索引注意事项</h3><p><strong>何时建</strong></p>
<ul>
<li>经常出现在 WHERE &#x2F; JOIN &#x2F; ORDER BY &#x2F; GROUP BY 中的列。</li>
<li>作为外键引用的列（保证 join 性能）。</li>
</ul>
<p><strong>字段选择与顺序（联合索引）</strong></p>
<ul>
<li>把选择性高（distinct 值多）的列放在前面。</li>
<li>把经常用于 range 的字段放在后面（因为范围会停止利用后续列）。</li>
</ul>
<p><strong>索引类型 &#x2F; 编码注意</strong></p>
<ul>
<li>字符串字符集影响索引长度（utf8mb4 每字符最多 4 字节），索引前缀长度受限（历史上 InnoDB 有 767&#x2F;3072 字节限制）；使用 <code>VARCHAR(255)</code> 在 utf8mb4 下可能需要更短的前缀或压缩。</li>
<li>对大文本列使用前缀索引：<code>INDEX(name(50))</code>（节省空间，但会降低准确性）。</li>
</ul>
<p><strong>尽量避免</strong></p>
<ul>
<li>在低选择性的列（如性别、布尔标志）上建立单列索引（索引命中率低）。</li>
<li>在频繁写入、更新的列上建立过多索引（维护成本高）。</li>
<li>盲目建立冗余索引（比如已有 <code>(a,b)</code> 就无需再建 <code>(a)</code> 一般情形可省，除非单列查询高频）。</li>
</ul>
<p><strong>覆盖索引</strong></p>
<ul>
<li>将查询所需字段都放在索引中（select 列为索引列）能避免回表，显著提速。</li>
</ul>
<p><strong>面试追问要点</strong></p>
<ul>
<li>讨论索引的空间&#x2F;写入开销、选择性和基数（cardinality），以及如何用 <code>SHOW INDEX</code> &#x2F; <code>ANALYZE TABLE</code> 来获取统计信息。</li>
</ul>
<hr>
<h3 id="10-如何评估-判断索引是否生效？常见索引失效场景详尽列举"><a href="#10-如何评估-判断索引是否生效？常见索引失效场景详尽列举" class="headerlink" title="10. 如何评估 &#x2F; 判断索引是否生效？常见索引失效场景详尽列举"></a>10. 如何评估 &#x2F; 判断索引是否生效？常见索引失效场景详尽列举</h3><p><strong>判断索引是否生效（步骤）</strong></p>
<ol>
<li>使用 <code>EXPLAIN &lt;SQL&gt;</code>（或 <code>EXPLAIN FORMAT=JSON</code>）查看：<code>key</code>（使用的索引）、<code>type</code>（访问类型）、<code>rows</code>（估算扫描行数）、<code>Extra</code>（filesort&#x2F;Using temporary&#x2F;Using index）。</li>
<li>查看实际执行时间与 <code>EXPLAIN ANALYZE</code>（MySQL 8+）的真实耗时、IO。</li>
<li><code>SHOW INDEX FROM table_name</code> 查看索引定义及 cardinality。</li>
<li><code>ANALYZE TABLE table_name</code> 更新统计信息后再用 EXPLAIN 检查（有时统计失真会让优化器选择差计划）。</li>
</ol>
<p><strong>常见索引失效场景（详述）</strong></p>
<ul>
<li><p><strong>对索引列做函数&#x2F;表达式</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> <span class="type">DATE</span>(created_at) <span class="operator">=</span> <span class="string">&#x27;2025-10-01&#x27;</span>  <span class="comment">-- 索引失效</span></span><br></pre></td></tr></table></figure>

<p>修复：写作 <code>WHERE created_at &gt;= &#39;2025-10-01&#39; AND created_at &lt; &#39;2025-10-02&#39;</code>。</p>
</li>
<li><p><strong>隐式类型转换</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>  <span class="comment">-- 如果 id 是 INT，隐式转换可能导致索引不使用</span></span><br></pre></td></tr></table></figure>

<p>修复：确保参数类型匹配或强制类型转换在常量上。</p>
</li>
<li><p><strong>Leading wildcard（前导通配符）</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>  <span class="comment">-- 无法用索引</span></span><br></pre></td></tr></table></figure>

<p>修复：避免前导 <code>%</code>，或使用 FULLTEXT&#x2F;倒排索引。</p>
</li>
<li><p><strong>OR 條件中没有共同索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> b <span class="operator">=</span> <span class="number">2</span>  <span class="comment">-- 若 a,b 都有索引，查询可能会采用 index_merge，但复杂情况仍可能全表扫描</span></span><br></pre></td></tr></table></figure>

<p>修复：用 UNION 优化（<code>SELECT ... WHERE a=1 UNION SELECT ... WHERE b=2</code>），或添加合适联合索引。</p>
</li>
<li><p><strong>范围搜索切断联合索引后续列</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> a <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">3</span>  <span class="comment">-- 如果 a 是范围条件，后续 b,c 通常不能利用索引进行定位（但可以作为过滤）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>NOT</code>、<code>&lt;&gt;</code>、<code>IS NULL</code>（依赖场景）</strong>：<code>NOT</code> 和 <code>&lt;&gt;</code> 通常导致全表扫描。<code>IS NULL</code> 可用索引但要看实现与数据分布。</p>
</li>
<li><p><strong>隐含返回过多列导致不能使用覆盖索引</strong>：<code>SELECT *</code> 会导致回表。</p>
</li>
<li><p><strong>统计信息过期或不准确</strong>：优化器基于统计，如果统计不准会选错索引，使用 <code>ANALYZE TABLE</code> 更新。</p>
</li>
</ul>
<p><strong>演练：如何修复某常见失效</strong><br> 场景：<code>WHERE DATE(ts) = &#39;2025-10-01&#39;</code>。<br> 解决：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 改写为范围</span></span><br><span class="line"><span class="keyword">WHERE</span> ts <span class="operator">&gt;=</span> <span class="string">&#x27;2025-10-01&#x27;</span> <span class="keyword">AND</span> ts <span class="operator">&lt;</span> <span class="string">&#x27;2025-10-02&#x27;</span></span><br></pre></td></tr></table></figure>

<p>好处：能利用 ts 上的索引，避免函数计算。</p>
<hr>
<h3 id="11-索引失效后怎么办？"><a href="#11-索引失效后怎么办？" class="headerlink" title="11. 索引失效后怎么办？"></a>11. 索引失效后怎么办？</h3><ul>
<li><strong>第一步：EXPLAIN</strong> 看当前计划与 <code>key</code> 列。</li>
<li><strong>第二步：确认 WHERE &#x2F; ORDER BY &#x2F; JOIN</strong> 中列的表达式是否会破坏索引（函数、类型转换、范围切断）。</li>
<li><strong>第三步：重写 SQL</strong>：<ul>
<li>把函数移动到常量端或使用等价的区间（日期函数改为区间）。</li>
<li>避免 SELECT *，改为需要列（利于覆盖索引）。</li>
<li>对 OR 用 UNION 或添加合适索引。</li>
</ul>
</li>
<li><strong>第四步：增加或调整索引</strong>：<ul>
<li>做覆盖索引或按查询列顺序建立复合索引。</li>
<li>对 TEXT&#x2F;VARCHAR 做前缀索引（必要时）。</li>
</ul>
</li>
<li><strong>第五步：统计&#x2F;版本</strong>：<ul>
<li><code>ANALYZE TABLE</code> 后再次 EXPLAIN。</li>
<li>了解 MySQL 版本的优化器行为（例如 5.7 vs 8.0 在 subquery rewrite 上有差别）。</li>
</ul>
</li>
<li><strong>第六步：测试与回滚</strong>：<ul>
<li>在预发布&#x2F;测试环境验证索引是否改善查询计划和实际耗时。</li>
<li>使用慢查询日志对比。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="12-数据库索引重构过程（线上零停机实践）"><a href="#12-数据库索引重构过程（线上零停机实践）" class="headerlink" title="12. 数据库索引重构过程（线上零停机实践）"></a>12. 数据库索引重构过程（线上零停机实践）</h3><p><strong>目标</strong>：修改索引（添加&#x2F;删除&#x2F;重建）而<strong>不影响线上业务</strong>。</p>
<p><strong>常用工具与策略</strong></p>
<ul>
<li><p><strong>ALTER TABLE … ADD INDEX</strong>：在较新 MySQL 支持 <code>ALGORITHM=INPLACE, LOCK=NONE</code> 可在线加索引（不阻塞读写）。但并非所有场景都支持（依赖表引擎、列类型、已有 DDL 状态）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> t <span class="keyword">ADD</span> INDEX idx_col(col) ALGORITHM<span class="operator">=</span>INPLACE, LOCK<span class="operator">=</span><span class="keyword">NONE</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>pt-online-schema-change（Percona Toolkit）</strong>：原理：创建一个新表（目标结构），用触发器&#x2F;复制把变更期间的数据同步到新表，最后原子 RENAME 表交换。优点成熟，适用范围广，但在高写场景触发器开销大。</p>
</li>
<li><p><strong>gh-ost（GitHub）</strong>：基于 binlog 的在线 schema change，低风险、对主库影响小；更适合高并发写表。原理类似：复制数据到 ghost table 并实时追赶 binlog，然后切换。</p>
</li>
<li><p><strong>手工方案（可用于大批量重建索引）</strong>：</p>
<ol>
<li>在 off-peak 期间创建新索引副本表（若可行）。</li>
<li>使用分批迁移或分区交换（PARTITION EXCHANGE）来减少停机。</li>
<li>使用 <code>ALTER TABLE ... DISABLE KEYS</code>（MyISAM）或 <code>pt-online-schema-change</code>。</li>
</ol>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>在线建索引会额外占用 IO &#x2F; CPU &#x2F; binlog，有流量控制（Throttle）。</li>
<li>在多主&#x2F;主从拓扑中，要考虑 Replica 上的 DDL 是否也会执行、binlog_format（ROW&#x2F;STATEMENT）影响。</li>
<li>切换前务必备份与验证。</li>
</ul>
<hr>
<h3 id="13-为什么数据库用-B-树不使用红黑树"><a href="#13-为什么数据库用-B-树不使用红黑树" class="headerlink" title="13. 为什么数据库用 B+ 树不使用红黑树"></a>13. 为什么数据库用 B+ 树不使用红黑树</h3><ul>
<li><strong>磁盘页角度</strong>：B+ 树内节点可包含许多 key→降低树高度→减少磁盘页读写次数（关键点：磁盘 IO 是瓶颈）。</li>
<li><strong>顺序遍历</strong>：B+ 树叶子链表提供顺序遍历，非常适合范围扫描和排序操作；红黑树的中序遍历需更多随机 IO。</li>
<li><strong>空间局部性</strong>：B+ 树把叶子节点放在连续页中（或缓存友好），提高 cache 命中率。</li>
<li><strong>写放与页分裂</strong>：B+ 树专门为页管理设计，插入造成页分裂的代价在磁盘系统中更可控。</li>
</ul>
<hr>
<h3 id="14-数据库分页的实现方式"><a href="#14-数据库分页的实现方式" class="headerlink" title="14. 数据库分页的实现方式"></a>14. 数据库分页的实现方式</h3><p><strong>方法 A：LIMIT OFFSET（通用）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>问题</strong>：数据库需要扫描并跳过前 1,000,000 行（或者移动游标），成本与 offset 线性增长（O(offset)）。</li>
</ul>
<p><strong>方法 B：基于索引的 Keyset &#x2F; Seek Pagination（推荐）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 前端保存上页最后 id = last_id</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> (order_col, id) <span class="operator">&gt;</span> (last_order_col, last_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_col, id</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：避免 large offset，随机访问对索引友好，稳定性好。</li>
<li><strong>限制</strong>：不能随意跳到任意页（只支持“下一页&#x2F;上一页”或基于 cursor 的跳转），不适合“跳到第 N 页”的场景。</li>
</ul>
<p><strong>方法 C：预先计算&#x2F;物化分页结果</strong></p>
<ul>
<li>对于复杂查询或热点分页，预计算并把排名&#x2F;页结果写到缓存（Redis、materialized view）。</li>
</ul>
<p><strong>方法 D：使用索引覆盖 + 子查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">10</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这在某些场景下，子查询只返回 id（索引列）能稍微减轻代价，但仍要注意 offset 开销。</p>
<p><strong>方法 E：使用窗口函数（MySQL 8）</strong></p>
<ul>
<li>可用 <code>ROW_NUMBER()</code> 辅助复杂场景，但底层仍需要扫描&#x2F;排序。</li>
</ul>
<hr>
<h3 id="15-LIMIT-100000000-10-与-LIMIT-10-性能差异"><a href="#15-LIMIT-100000000-10-与-LIMIT-10-性能差异" class="headerlink" title="15. LIMIT 100000000,10 与 LIMIT 10 性能差异"></a>15. LIMIT 100000000,10 与 LIMIT 10 性能差异</h3><p><strong>原因</strong></p>
<ul>
<li>MySQL 的 OFFSET 会找到行数然后弃掉前面 N 行（游标移动、IO 扫描），实质上做了大量无用工作。</li>
<li><code>LIMIT 10</code> 可在索引上迅速返回起始几行。</li>
</ul>
<p><strong>解决办法</strong></p>
<ul>
<li>用 keyset 分页（上一节）。</li>
<li>如果必须跳转到大 offset，考虑预计算（cache）或分区查询、倒排索引、物化。</li>
</ul>
<hr>
<h3 id="16-如何使用-EXPLAIN-分析查询？关注哪些列与含义"><a href="#16-如何使用-EXPLAIN-分析查询？关注哪些列与含义" class="headerlink" title="16. 如何使用 EXPLAIN 分析查询？关注哪些列与含义"></a>16. 如何使用 EXPLAIN 分析查询？关注哪些列与含义</h3><p>执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> ...;</span><br><span class="line"><span class="comment">-- 或 MySQL8: EXPLAIN FORMAT=JSON SELECT ...;</span></span><br><span class="line"><span class="comment">-- 或 EXPLAIN ANALYZE SELECT ...; (8.0+, 会实际执行并给出真实时间)</span></span><br></pre></td></tr></table></figure>

<p><strong>关键列解释</strong></p>
<ul>
<li><code>id</code>：查询序号，越大越早执行（子查询&#x2F;union 时重要）。</li>
<li><code>select_type</code>：SIMPLE&#x2F;PRIMARY&#x2F;DERIVED&#x2F;SUBQUERY&#x2F;UNION 等。</li>
<li><code>table</code>：当前访问的表 (NULL&#x2F;const&#x2F;table name)。</li>
<li><code>type</code>（最重要的性能指标之一）：<ul>
<li><code>system</code>、<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>range</code>、<code>index</code>、<code>ALL</code>（由好到差）。</li>
<li><code>ALL</code> &#x3D; 全表扫描，<code>range</code> &#x3D; 范围扫描（走索引），<code>ref/eq_ref</code> &#x3D; 精确匹配索引。</li>
</ul>
</li>
<li><code>possible_keys</code>：优化器认为可能使用的索引。</li>
<li><code>key</code>：实际使用的索引（NULL 表示没有使用）。</li>
<li><code>key_len</code>：使用的索引长度（字节），表明索引使用了多少前缀。</li>
<li><code>ref</code>：索引列与哪些值比较（常数或其他列）。</li>
<li><code>rows</code>：优化器估算需要扫描的行数（越小越好）。</li>
<li><code>Extra</code>：其他信息（<code>Using where</code>、<code>Using index</code>、<code>Using temporary</code>、<code>Using filesort</code>、<code>Using join buffer</code>）。<ul>
<li><code>Using index</code> &#x3D; 覆盖索引（好）；</li>
<li><code>Using filesort</code> 或 <code>Using temporary</code> 说明排序&#x2F;分组需要额外资源（可能慢）。</li>
</ul>
</li>
</ul>
<p><strong>实践步骤</strong></p>
<ol>
<li><code>EXPLAIN</code> 看 <code>type</code> &#x2F; <code>key</code> &#x2F; <code>rows</code>。若 <code>type=ALL</code> 或 <code>rows</code> 很大 → 优先优化。</li>
<li>若 <code>Using filesort</code> 或 <code>Using temporary</code> → 检查 ORDER BY&#x2F;GROUP BY 是否能用索引或是否导致临时表（改索引&#x2F;改SQL）。</li>
<li>用 <code>EXPLAIN ANALYZE</code> 获取真实执行耗时和行数（有时估算与真实差异大）。</li>
</ol>
<hr>
<h3 id="17-COUNT-、COUNT-1-、COUNT-列-的区别"><a href="#17-COUNT-、COUNT-1-、COUNT-列-的区别" class="headerlink" title="17. COUNT(*)、COUNT(1)、COUNT(列) 的区别"></a>17. COUNT(*)、COUNT(1)、COUNT(列) 的区别</h3><ul>
<li><strong>COUNT(*)</strong>：计数 <em>行数</em>（计数所有行，包括 NULL 列），对于 MyISAM 引擎是 O(1)（有表元数据），InnoDB 则通常需要扫描或走索引统计（没有存储全表行计数）。</li>
<li><strong>COUNT(1)</strong>：语义与 <code>COUNT(*)</code> 相同，MySQL 优化器会把它处理为计数行。</li>
<li><strong>COUNT(col)</strong>：只计数该列非 NULL 的行数（忽略 NULL）。</li>
</ul>
<p><strong>优化点</strong></p>
<ul>
<li>若需要对全表计数并且不带 WHERE，使用 MyISAM（历史）会更快，但现代 InnoDB 下 <code>COUNT(*)</code> 需要扫描索引或全表（可用一列非 NULL 索引优化）。</li>
<li>若要快速统计大表某条件的行数，考虑维护计数缓存或实时物化表。</li>
</ul>
<hr>
<h3 id="18-SQL-聚合函数"><a href="#18-SQL-聚合函数" class="headerlink" title="18. SQL 聚合函数"></a>18. SQL 聚合函数</h3><ul>
<li><strong>聚合函数</strong>：<code>COUNT()</code>、<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>、<code>MIN()</code>、<code>GROUP_CONCAT()</code>。</li>
<li><strong>实现细节</strong>：<ul>
<li>GROUP BY 会触发临时表和排序（若没有索引辅助），大数据量上会产生 <code>Using temporary; Using filesort</code>。</li>
<li>对于 <code>SUM</code>&#x2F;<code>AVG</code> 等，利用合适索引或预聚合表（materialized view）能显著提速。</li>
</ul>
</li>
<li><strong>优化</strong>：<ul>
<li>对 group by 列建立联合索引可避免 filesort。</li>
<li>对频繁统计的维度表考虑预计算或 OLAP 引擎（ClickHouse、Druid、Presto）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="19-WHERE-与-HAVING-的区别）"><a href="#19-WHERE-与-HAVING-的区别）" class="headerlink" title="19. WHERE 与 HAVING 的区别）"></a>19. WHERE 与 HAVING 的区别）</h3><ul>
<li><strong>WHERE</strong>：在分组前对行做过滤（作用于源数据）。性能高，尽量把能在 WHERE 过滤的条件写在 WHERE。</li>
<li><strong>HAVING</strong>：在 <code>GROUP BY</code> 后对分组后的聚合结果过滤（可以使用聚合函数，如 <code>HAVING SUM(x) &gt; 100</code>）。HAVING 需要先产生分组结果，成本较高。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_id, <span class="built_in">SUM</span>(amount) total</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;paid&#x27;</span>  <span class="comment">-- 先过滤行</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(amount) <span class="operator">&gt;</span> <span class="number">1000</span>;  <span class="comment">-- 再过滤分组</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="20-EXISTS-与-IN-的区别（含-NULL-语义差异）"><a href="#20-EXISTS-与-IN-的区别（含-NULL-语义差异）" class="headerlink" title="20. EXISTS 与 IN 的区别（含 NULL&#x2F;语义差异）"></a>20. EXISTS 与 IN 的区别（含 NULL&#x2F;语义差异）</h3><p><strong>语义</strong></p>
<ul>
<li><code>IN</code>（子查询）通常会先执行子查询（或优化成半连接）并在结果集上做匹配。</li>
<li><code>EXISTS</code> 是相关子查询逐行判断，只要子查询对外层行存在匹配就返回 true（内层子查询常以 correlated subquery 形式出现）。</li>
</ul>
<p><strong>执行差异</strong></p>
<ul>
<li>对于非相关子查询，优化器可能将 <code>IN</code> 重写成 semi-join（性能接近）。</li>
<li>对于相关子查询，<code>EXISTS</code> 通常更高效（提前短路），尤其当内层表有合适索引能快速定位时。</li>
</ul>
<p><strong>NULL 语义</strong></p>
<ul>
<li><code>IN</code> 的子查询结果中若存在 <code>NULL</code>，在某些情况下会改变逻辑（导致不直观的行为），需谨慎。</li>
<li>示例差异：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设 subquery 返回 (1, NULL)</span></span><br><span class="line">a <span class="keyword">IN</span> (<span class="keyword">SELECT</span> b <span class="keyword">FROM</span> t)  <span class="comment">-- 结果的真值取决于 a 与 NULL 的比较，可能为 UNKNOWN</span></span><br></pre></td></tr></table></figure>

<p><strong>实践建议</strong></p>
<ul>
<li>对于子查询较大或有相关情况，偏好 <code>EXISTS</code> 或改写为 JOIN&#x2F;SEMI-JOIN。</li>
<li>对于小静态列表（常量 list），<code>IN (v1,v2,...)</code> 非常合适。</li>
</ul>
<hr>
<h3 id="21-SQL-注入-及-防范"><a href="#21-SQL-注入-及-防范" class="headerlink" title="21. SQL 注入 及 防范"></a>21. SQL 注入 及 防范</h3><p><strong>原理</strong></p>
<ul>
<li>直接拼接字符串会把用户输入当成 SQL 代码执行，例如 <code>&quot;... WHERE id = &quot; + userInput</code>，若用户输入 <code>1 OR 1=1</code>，将变为总是为真的条件。</li>
</ul>
<p><strong>防护措施</strong></p>
<ol>
<li><p><strong>参数化查询 &#x2F; PreparedStatement</strong>（最重要）：使用占位符 <code>?</code>，数据库驱动负责转义与类型校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE login = ?&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">1</span>, userInput);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>白名单校验</strong>：对于列名、表名、排序字段等必须是字符串拼接处，先用白名单校验（只允许预定义值）。</p>
</li>
<li><p><strong>最小权限原则</strong>：数据库账号只授予必要权限（应用不能用 root）。</p>
</li>
<li><p><strong>防火墙&#x2F;代理</strong>：使用 SQL 防火墙、WAF、审计机制。</p>
</li>
<li><p><strong>ORM&#x2F;框架功能</strong>：使用框架的查询构建器减少手写 SQL。</p>
</li>
<li><p><strong>日志与检测</strong>：监控异常模式、慢查询、尝试注入字符串。</p>
</li>
</ol>
<p><strong>面试点</strong>：能举出具体注入示例、解释 PreparedStatement 原理（预编译、参数绑定）并能说明白名单的作用。</p>
<p>下面把<strong>面试要点</strong>拆成清晰的小节：原理（含典型注入类型与示例）、PreparedStatement 原理与为什么能防注入、白名单的作用与用法、以及补充的实践防护措施与面试常见追问要点。答得既能过面试官的基础考察，又能应对深挖。</p>
<h1 id="SQL-注入-—-原理与典型示例"><a href="#SQL-注入-—-原理与典型示例" class="headerlink" title="SQL 注入 — 原理与典型示例"></a>SQL 注入 — 原理与典型示例</h1><p><strong>原理（本质）</strong>：当把不可信输入直接拼接到 SQL 文本里时，攻击者可以构造输入，使其成为 SQL 语句的一部分（即“把数据当成代码”），从而改变语句逻辑或执行额外命令。</p>
<p><strong>常见注入类型与示例</strong>：</p>
<ol>
<li><p><strong>基于布尔&#x2F;联合（Union &#x2F; OR）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vulnerable</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE id = &quot;</span> + userInput;</span><br><span class="line"><span class="comment">// userInput = &quot;1 OR 1=1&quot; -&gt; SELECT * FROM users WHERE id = 1 OR 1=1</span></span><br></pre></td></tr></table></figure>

<p>结果：泄露全表数据或绕过认证。</p>
</li>
<li><p><strong>基于错误（Error-based）</strong><br> 构造使 DB 抛错误，从错误信息中泄露数据&#x2F;结构。</p>
</li>
<li><p><strong>联合查询（UNION）注入</strong><br> 在查询后追加 <code>UNION SELECT ...</code> 来读取其它表数据。</p>
</li>
<li><p><strong>时间盲注 &#x2F; 布尔盲注</strong><br> 无直接输出时通过 <code>IF(condition, SLEEP(5), 0)</code> 等观察响应延迟或真假分支来抽取数据。</p>
</li>
<li><p><strong>存储&#x2F;二次注入</strong><br> 恶意 payload 存入 DB，后续在另一处被拼接执行造成注入。</p>
</li>
</ol>
<h1 id="防护措施（核心与实践）"><a href="#防护措施（核心与实践）" class="headerlink" title="防护措施（核心与实践）"></a>防护措施（核心与实践）</h1><h2 id="1-参数化查询-PreparedStatement（最重要）"><a href="#1-参数化查询-PreparedStatement（最重要）" class="headerlink" title="1. 参数化查询 &#x2F; PreparedStatement（最重要）"></a>1. 参数化查询 &#x2F; PreparedStatement（最重要）</h2><p><strong>示例（Java）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE login = ?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, userInput);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br></pre></td></tr></table></figure>

<p><strong>为什么能防注入</strong>：</p>
<ul>
<li><strong>分离代码与数据</strong>：占位符 <code>?</code> 在 SQL 语法中固定，参数作为数据绑定，不会被解析为 SQL 关键字或语句片段。</li>
<li><strong>类型和转义由驱动&#x2F;数据库负责</strong>：参数在发送到 DB 前&#x2F;或由 DB 端绑定为常量值。</li>
<li><strong>预编译（可缓存执行计划）</strong>：数据库通常把 SQL 模板编译成执行计划，再把参数绑定执行（这也是性能加成）。注意：某些 JDBC 驱动对 PreparedStatement 可能做客户端仿真，但即便仿真也会做正确的转义&#x2F;绑定，仍比拼接安全得多。</li>
</ul>
<p><strong>面试加分点</strong>：</p>
<ul>
<li>说明预编译的细节：服务器端预编译 + 参数绑定，可防止注入并提升性能（减少解析开销）。</li>
<li>补充：某些驱动&#x2F;DB 在网络层实现参数化或驱动端模拟，仍能防止注入，但最好确认驱动实现。</li>
</ul>
<h2 id="2-白名单校验（用于标识符、排序字段等不能用占位符的场景）"><a href="#2-白名单校验（用于标识符、排序字段等不能用占位符的场景）" class="headerlink" title="2. 白名单校验（用于标识符、排序字段等不能用占位符的场景）"></a>2. 白名单校验（用于标识符、排序字段等不能用占位符的场景）</h2><ul>
<li><p>占位符不能替换 SQL 标识符（如列名、表名、ORDER BY 字段）——这些必须在 SQL 文本中写出或拼接。此时<strong>必须用白名单</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; allowedSort = Set.of(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;created_at&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!allowedSort.contains(userSort)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users ORDER BY &quot;</span> + userSort;</span><br></pre></td></tr></table></figure>
</li>
<li><p>白名单保证只允许预期的、安全的标识符，拒绝任意输入。</p>
</li>
</ul>
<h2 id="3-最小权限原则"><a href="#3-最小权限原则" class="headerlink" title="3. 最小权限原则"></a>3. 最小权限原则</h2><ul>
<li>应用使用的 DB 账户应只授予必要权限（SELECT&#x2F;INSERT&#x2F;UPDATE&#x2F;DELETE 的子集），不要用 <code>root</code> 或高权限账号执行应用 SQL，限制损害面。</li>
</ul>
<h2 id="4-输入验证与输出转义（辅助）"><a href="#4-输入验证与输出转义（辅助）" class="headerlink" title="4. 输入验证与输出转义（辅助）"></a>4. 输入验证与输出转义（辅助）</h2><ul>
<li>对长度、格式、字符集做验证（但不要把它当作唯一防线）。</li>
<li>对动态生成给 UI 的内容做适当转义（防 XSS），与注入防护属于不同层。</li>
</ul>
<h2 id="5-使用-ORM-查询构建器（并正确使用参数化-API）"><a href="#5-使用-ORM-查询构建器（并正确使用参数化-API）" class="headerlink" title="5. 使用 ORM &#x2F; 查询构建器（并正确使用参数化 API）"></a>5. 使用 ORM &#x2F; 查询构建器（并正确使用参数化 API）</h2><ul>
<li>现代 ORM（Hibernate、MyBatis）提供参数化接口和占位符，正确使用能避免绝大多数注入问题。</li>
<li><strong>但注意</strong>：不要把用户输入直接拼接成 HQL&#x2F;SQL&#x2F;OrderBy 字符串。</li>
</ul>
<h2 id="6-防火墙-监控-审计"><a href="#6-防火墙-监控-审计" class="headerlink" title="6. 防火墙 &#x2F; 监控 &#x2F; 审计"></a>6. 防火墙 &#x2F; 监控 &#x2F; 审计</h2><ul>
<li>使用 WAF&#x2F;数据库防火墙检测异常 SQL 模式（如 <code>UNION SELECT</code>、注入特征）并阻断。</li>
<li>日志与告警：监控异常查询、慢查询、重复错误模式。</li>
</ul>
<h2 id="7-不要直接反序列化不可信数据-避免-eval"><a href="#7-不要直接反序列化不可信数据-避免-eval" class="headerlink" title="7. 不要直接反序列化不可信数据 &#x2F; 避免 eval"></a>7. 不要直接反序列化不可信数据 &#x2F; 避免 eval</h2><ul>
<li>不要 eval 字符串形成 SQL 或通过反序列化直接执行任意语句。</li>
</ul>
<h1 id="示例对比（易读）"><a href="#示例对比（易读）" class="headerlink" title="示例对比（易读）"></a>示例对比（易读）</h1><p><strong>易被注入</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE name = &#x27;&quot;</span> + userInput + <span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>若 <code>userInput = &quot;a&#39; OR &#39;1&#39;=&#39;1&quot;</code> -&gt; 成为 SQL</p>
<p><strong>安全写法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE name = ?&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">1</span>, userInput);</span><br></pre></td></tr></table></figure>

<h1 id="其他面试可能追问与简洁回答要点"><a href="#其他面试可能追问与简洁回答要点" class="headerlink" title="其他面试可能追问与简洁回答要点"></a>其他面试可能追问与简洁回答要点</h1><ul>
<li><strong>Stored procedures 能否防注入？</strong><ul>
<li>如果所有输入都作为参数传入存储过程，并在 DB 端使用参数化执行，能降低风险；但存储过程内部若动态拼接 SQL 仍存在注入风险。不是万灵药。</li>
</ul>
</li>
<li><strong>为何不能对所有输入只做简单转义？</strong><ul>
<li>转义容易出错、依赖数据库方言、容易遗漏边界条件；参数化更稳健。</li>
</ul>
</li>
<li><strong>如何防盲注（time-based）？</strong><ul>
<li>参数化 + 严格 SQL 构造；WAF 可检测可疑延时查询；限制返回信息和错误信息。</li>
</ul>
</li>
<li><strong>PreparedStatement 性能问题？</strong><ul>
<li>预编译使数据库可以缓存执行计划（提升性能）。在高并发 &#x2F; 批量场景下，PreparedStatement 通常更快。</li>
</ul>
</li>
<li><strong>如何处理动态列&#x2F;表名？</strong><ul>
<li>只能用白名单或映射表（不要直接用用户输入）。</li>
</ul>
</li>
</ul>
<h2 id="面试一分种快速答法（可背）"><a href="#面试一分种快速答法（可背）" class="headerlink" title="面试一分种快速答法（可背）"></a>面试一分种快速答法（可背）</h2><ul>
<li><strong>原理</strong>：注入是把用户数据当作 SQL 代码执行。</li>
<li><strong>首要防护</strong>：使用参数化查询 &#x2F; PreparedStatement（分离代码与数据）。</li>
<li><strong>补充策略</strong>：白名单（用于列名&#x2F;排序等标识符）、最小权限、ORM + 参数化 API、WAF&#x2F;监控、不要反序列化&#x2F;执行不可信输入。</li>
<li><strong>示例</strong>：展示一个拼接示例导致 <code>OR 1=1</code>，再给出 PreparedStatement 安全写法。</li>
</ul>
<hr>
<h3 id="22-将一张表部分数据更新到另一张表（多种方式）"><a href="#22-将一张表部分数据更新到另一张表（多种方式）" class="headerlink" title="22. 将一张表部分数据更新到另一张表（多种方式）"></a>22. 将一张表部分数据更新到另一张表（多种方式）</h3><p><strong>场景</strong>：用 tableA 的某列更新 tableB。</p>
<p><strong>写法 A：JOIN 更新（常见且高效）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tableB b</span><br><span class="line"><span class="keyword">JOIN</span> tableA a <span class="keyword">ON</span> a.id <span class="operator">=</span> b.id</span><br><span class="line"><span class="keyword">SET</span> b.col <span class="operator">=</span> a.col</span><br><span class="line"><span class="keyword">WHERE</span> a.some_condition;</span><br></pre></td></tr></table></figure>

<p><strong>写法 B：子查询方式</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tableB b</span><br><span class="line"><span class="keyword">SET</span> b.col <span class="operator">=</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> a.col <span class="keyword">FROM</span> tableA a <span class="keyword">WHERE</span> a.id <span class="operator">=</span> b.id LIMIT <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> tableA a <span class="keyword">WHERE</span> a.id <span class="operator">=</span> b.id <span class="keyword">AND</span> a.some_condition);</span><br></pre></td></tr></table></figure>

<p><strong>写法 C：INSERT … ON DUPLICATE KEY UPDATE</strong>（当要插入或更新）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> tableB (id, col)</span><br><span class="line"><span class="keyword">SELECT</span> id, col <span class="keyword">FROM</span> tableA <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> col <span class="operator">=</span> <span class="keyword">VALUES</span>(col);</span><br></pre></td></tr></table></figure>

<p><strong>实践说明</strong></p>
<ul>
<li>JOIN 方式通常速度更快（单次扫描，优化器能做更好 join order）。</li>
<li>注意事务与锁（大批量更新建议分批处理）。</li>
</ul>
<hr>
<h3 id="23-如何将行转成列（行列转换-Pivot）——常见-SQL-模式"><a href="#23-如何将行转成列（行列转换-Pivot）——常见-SQL-模式" class="headerlink" title="23. 如何将行转成列（行列转换 &#x2F; Pivot）——常见 SQL 模式"></a>23. 如何将行转成列（行列转换 &#x2F; Pivot）——常见 SQL 模式</h3><p><strong>方式 A：聚合 + CASE（最通用）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> type<span class="operator">=</span><span class="string">&#x27;A&#x27;</span> <span class="keyword">THEN</span> val <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> A,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> type<span class="operator">=</span><span class="string">&#x27;B&#x27;</span> <span class="keyword">THEN</span> val <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">FROM</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> id;</span><br></pre></td></tr></table></figure>

<p><strong>方式 B：使用 GROUP_CONCAT（拼接）</strong>（当列类型多样且不定时）<br> <strong>方式 C：动态列 Pivot（需要动态 SQL）</strong></p>
<ul>
<li>若列类型不可预知，生成动态 SQL（查询 distinct 值并拼接 CASE 子句）。</li>
</ul>
<p><strong>性能考虑</strong></p>
<ul>
<li>Pivot 多数需要扫描并分组，依赖 group by 索引&#x2F;分区来加速；对大表要慎用或基于物化视图&#x2F;ETL 做离线计算。</li>
</ul>
<hr>
<h3 id="24-表之间如何关联（关联方式详解）"><a href="#24-表之间如何关联（关联方式详解）" class="headerlink" title="24. 表之间如何关联（关联方式详解）"></a>24. 表之间如何关联（关联方式详解）</h3><p><strong>常用方式</strong></p>
<ul>
<li><strong>JOIN（内联&#x2F;外联）</strong>：按条件联表（最常见）。</li>
<li><strong>外键（FK）约束</strong>：数据库层面保障参照完整性（但大量外键在高并发写场景会影响性能）。</li>
<li><strong>应用层关联</strong>：在代码层把多个小查询组装（用于跨库或性能考量）。</li>
<li><strong>基于索引的查找（子查询&#x2F;EXISTS）</strong>：有时 <code>EXISTS</code> 更高效。</li>
</ul>
<p><strong>实践选择</strong></p>
<ul>
<li>小表 join 大表用 hash join &#x2F; nested loop 视执行计划；对分库分表场景，避免跨库 join（改在应用层做聚合或使用分布式查询引擎）。</li>
</ul>
<hr>
<h3 id="25-INNER-LEFT-RIGHT-JOIN-的区别（带例子）"><a href="#25-INNER-LEFT-RIGHT-JOIN-的区别（带例子）" class="headerlink" title="25. INNER &#x2F; LEFT &#x2F; RIGHT JOIN 的区别（带例子）"></a>25. INNER &#x2F; LEFT &#x2F; RIGHT JOIN 的区别（带例子）</h3><ul>
<li><strong>INNER JOIN</strong>：返回两表交集（满足 join 条件的行）。</li>
<li><strong>LEFT JOIN</strong>：返回左表所有行 + 匹配右表的行（右表无匹配则为 NULL）。</li>
<li><strong>RIGHT JOIN</strong>：返回右表所有行 + 匹配左表的行（左表无匹配则为 NULL）。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- inner</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.aid;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- left</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.aid;</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong>：LEFT JOIN 很多时候在逻辑上需要做 <code>WHERE B.id IS NULL</code> 来实现“左表存在右表不存在”的 anti-join（查找孤立记录），性能会受影响，建议用 <code>NOT EXISTS</code> 或 <code>NOT IN</code>（注意 NULL 行）做替代。</p>
<hr>
<h3 id="26-为什么不推荐多表-JOIN？"><a href="#26-为什么不推荐多表-JOIN？" class="headerlink" title="26. 为什么不推荐多表 JOIN？"></a>26. 为什么不推荐多表 JOIN？</h3><p><strong>问题多出自以下几点</strong></p>
<ol>
<li><strong>成本指数增长</strong>：多表 join（尤其大表）会产生巨大的中间集（笛卡尔扩展风险），优化器不得当时性能爆炸。</li>
<li><strong>跨库无法 JOIN</strong>：分库分表后跨库 JOIN 太昂贵或不支持。</li>
<li><strong>可维护性差</strong>：SQL 复杂、难读、难改，调试困难。</li>
<li><strong>优化器依赖统计</strong>：索引&#x2F;统计不准时，join 顺序选择差导致大代价执行计划。</li>
</ol>
<p><strong>替代方案</strong></p>
<ul>
<li><strong>应用层聚合</strong>：逐表查询并在应用层合并（适合分布式场景）。</li>
<li><strong>预计算&#x2F;物化</strong>：把复杂 join 结果写入聚合表（定期 ETL）。</li>
<li><strong>使用 OLAP 引擎 &#x2F; 搜索引擎</strong>：对于分析场景，使用专门的数据仓库（ClickHouse&#x2F;Presto）或搜索（Elasticsearch）。</li>
</ul>
<hr>
<h3 id="27-SQL-调优常见方法"><a href="#27-SQL-调优常见方法" class="headerlink" title="27. SQL 调优常见方法"></a>27. SQL 调优常见方法</h3><ol>
<li><strong>索引策略</strong><ul>
<li>建覆盖索引、联合索引（按查询顺序）、避免冗余。</li>
</ul>
</li>
<li><strong>重写 SQL</strong><ul>
<li>避免函数作用于索引列，避免 <code>SELECT *</code>，拆分复杂查询。</li>
</ul>
</li>
<li><strong>分区&#x2F;分库分表</strong><ul>
<li>水平分表（sharding）、分区表（MySQL partition）减少扫描边界。</li>
</ul>
</li>
<li><strong>缓存</strong><ul>
<li>热点数据用缓存（Redis）；页面&#x2F;查询使用缓存策略。</li>
</ul>
</li>
<li><strong>物化&#x2F;预聚合</strong><ul>
<li>预计算汇总表&#x2F;物化视图。</li>
</ul>
</li>
<li><strong>避免大事务</strong><ul>
<li>小批量提交，避免锁膨胀与 undo&#x2F;redo 压力。</li>
</ul>
</li>
<li><strong>使用批量操作</strong><ul>
<li>批量 insert&#x2F;replace&#x2F;insert…on duplicate，使用 LOAD DATA INFILE。</li>
</ul>
</li>
<li><strong>避免无索引排序&#x2F;分组</strong><ul>
<li>为 ORDER BY&#x2F;GROUP BY 列建立索引，使之成为 index-only 操作。</li>
</ul>
</li>
<li><strong>分析执行计划</strong><ul>
<li>EXPLAIN&#x2F;EXPLAIN ANALYZE、慢查询日志、pt-query-digest 来定位瓶颈。</li>
</ul>
</li>
<li><strong>硬件与配置</strong><ul>
<li>调整 Buffer Pool（InnoDB）、innodb_flush_log_at_trx_commit、innodb_buffer_pool_instances、tmp_table_size、max_heap_table_size 等。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="28-如何监控并优化慢-SQL）"><a href="#28-如何监控并优化慢-SQL）" class="headerlink" title="28. 如何监控并优化慢 SQL）"></a>28. 如何监控并优化慢 SQL）</h3><p><strong>监控</strong></p>
<ul>
<li>打开 <code>slow_query_log</code> 并设置合适阈值与日志轮转。</li>
<li>使用 <code>pt-query-digest</code> 或线上 APM（Pinpoint、SkyWalking、Datadog）做聚合分析。</li>
</ul>
<p><strong>分析流程</strong></p>
<ol>
<li>收集慢 SQL（按耗时&#x2F;锁&#x2F;scan 行数排序）。</li>
<li>对单条慢 SQL 执行 <code>EXPLAIN</code> 分析，关注 <code>type</code> 与 <code>rows</code>。</li>
<li>检查索引覆盖性、是否 filesort 或 temporary。</li>
<li>若是锁等待导致慢，查看 <code>SHOW ENGINE INNODB STATUS</code> 或 <code>INNODB_TRX</code>、<code>PROCESSLIST</code> 诊断锁冲突。</li>
<li>重写 SQL 或加索引并用 <code>EXPLAIN</code> 验证。</li>
</ol>
<p><strong>线上处置</strong></p>
<ul>
<li>在高峰直接用 <code>pt-kill</code>&#x2F;慢查询阻断&#x2F;限流短时缓解（谨慎）。</li>
<li>对于极耗时的聚合，建议用异步&#x2F;批处理&#x2F;预计算。</li>
</ul>
<hr>
<h3 id="29-如何高效批量插入数据"><a href="#29-如何高效批量插入数据" class="headerlink" title="29. 如何高效批量插入数据"></a>29. 如何高效批量插入数据</h3><ol>
<li><p><strong>多值 INSERT</strong>（比逐条插入快很多）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> t (a,b) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LOAD DATA INFILE</strong>（最快，适合导入 CSV）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">&#x27;/tmp/data.csv&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> t FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> (a,b,c);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>禁用索引&#x2F;约束后导入</strong>（谨慎）：</p>
<ul>
<li>对 MyISAM 可 <code>ALTER TABLE t DISABLE KEYS</code> 导入后 <code>ENABLE KEYS</code>，对 InnoDB 不适用同样方式，建议分批或临时删除二级索引后导入再重建。</li>
</ul>
</li>
<li><p><strong>控制事务大小</strong>：大批量分成多个事务（如每 5k 行一提交）以避免过大 undo&#x2F;redo。</p>
</li>
<li><p><strong>关闭二进制日志（临时）</strong>：在可接受风险下短时关闭 binlog 可提速，但会丢失复制&#x2F;恢复能力（通常不建议在生产主库上做）。</p>
</li>
<li><p><strong>使用并发导入</strong>：分表并发导入，每个线程导入不同数据段（受 IO&#x2F;CPU 限制）。</p>
</li>
</ol>
<hr>
<h3 id="30-大表（千万级）查询-维护"><a href="#30-大表（千万级）查询-维护" class="headerlink" title="30. 大表（千万级）查询 &#x2F; 维护"></a>30. 大表（千万级）查询 &#x2F; 维护</h3><p><strong>设计阶段</strong></p>
<ul>
<li>逻辑分库分表：按业务或哈希分片分布数据，减少单表压力。</li>
<li>分区表（range&#x2F;list&#x2F;hash）用于热冷分离与分区裁剪（partition pruning）。</li>
</ul>
<p><strong>索引与查询</strong></p>
<ul>
<li>给热点查询建覆盖索引，避免回表。</li>
<li>使用分区键&#x2F;分片键作为查询条件以利用分区 &#x2F; 分片定向扫描。</li>
</ul>
<p><strong>维护</strong></p>
<ul>
<li><strong>分批删除</strong>（不要一次性 delete 大量行）：<ul>
<li>分段删除 <code>DELETE FROM t WHERE id BETWEEN x AND y</code> 每次限制 batch size。</li>
<li>或使用 <code>ALTER TABLE ... DROP PARTITION</code>（若按时间分区）来快速删除历史数据。</li>
</ul>
</li>
<li><strong>重建索引</strong>：在线工具（gh-ost &#x2F; pt-online-schema-change）做 index rebuild。</li>
<li><strong>归档</strong>：将历史冷数据移出到分析库或对象存储。</li>
<li><strong>监控</strong>：慢查询、表扫描、锁等待、IO 使用情况。</li>
</ul>
<p><strong>备份</strong></p>
<ul>
<li>使用物理备份（XtraBackup）做热备份，避免在线 mysqldump 导致性能问题。</li>
</ul>
<hr>
<h3 id="31-DELETE、TRUNCATE、DROP-区别"><a href="#31-DELETE、TRUNCATE、DROP-区别" class="headerlink" title="31. DELETE、TRUNCATE、DROP 区别"></a>31. DELETE、TRUNCATE、DROP 区别</h3><p><strong>DELETE</strong></p>
<ul>
<li>DML 操作，逐行删除（执行 DELETE 语句会为每行生成 undo&#x2F;redo），触发器触发，事务可回滚。</li>
<li>对大表慢且会产生大量 undo&#x2F;log。</li>
</ul>
<p><strong>TRUNCATE</strong></p>
<ul>
<li>DDL 操作（在 MySQL 中通常为 drop + create 或快速清空表），效果等同于删除所有数据并重置 AUTO_INCREMENT（实现依引擎不同）。</li>
<li>通常不可回滚（会隐式提交当前事务）。</li>
<li>快速、不会逐行触发 DELETE 触发器（因为不是逐行删除）。</li>
</ul>
<p><strong>DROP</strong></p>
<ul>
<li>删除整个表结构与数据，删除后元数据也不存在。</li>
<li>同样通常是 DDL、会释放表空间（取决于引擎&#x2F;配置）。</li>
</ul>
<p><strong>实践建议</strong></p>
<ul>
<li>需要可回滚删除历史数据：做分批 DELETE 并通过事务或备份策略应对回滚需求。</li>
<li>需要快速清空表（并接受隐式提交）：用 TRUNCATE。</li>
<li>需要删除表与结构：DROP。</li>
</ul>
<h2 id="Java多线程-牛客面经八股"><a href="#Java多线程-牛客面经八股" class="headerlink" title="Java多线程-牛客面经八股"></a>Java多线程-牛客面经八股</h2><hr>
<h3 id="1-线程的创建方式（Java-中常见-4-种、及实际工程常用模式）"><a href="#1-线程的创建方式（Java-中常见-4-种、及实际工程常用模式）" class="headerlink" title="1. 线程的创建方式（Java 中常见 4 种、及实际工程常用模式）"></a>1. 线程的创建方式（Java 中常见 4 种、及实际工程常用模式）</h3><p><strong>方式 A — 继承 <code>Thread</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：直观。</li>
<li>缺点：无法共享 Runnable，再继承受限。</li>
</ul>
<p><strong>方式 B — 实现 <code>Runnable</code></strong>（最常用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; <span class="comment">/* ... */</span> &#125; &#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyTask</span>()).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：任务与线程分离，能被线程池复用。</li>
</ul>
<p><strong>方式 C — 实现 <code>Callable&lt;V&gt;</code> + <code>FutureTask</code></strong>（可返回值、可抛异常）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; c = () -&gt; <span class="number">42</span>;</span><br><span class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(c);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(ft).start();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();</span><br></pre></td></tr></table></figure>

<ul>
<li>常与 <code>ExecutorService.submit(callable)</code> 配合使用。</li>
</ul>
<p><strong>方式 D — 通过 <code>ExecutorService</code> &#x2F; 线程池</strong>（推荐）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">pool.submit(() -&gt; &#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>生产环境首选；管理线程生命周期、复用、任务队列、异常处理。</li>
</ul>
<p><strong>补充：Fork&#x2F;Join 与虚拟线程</strong></p>
<ul>
<li><code>ForkJoinPool</code> &#x2F; <code>RecursiveTask</code>：用于分治并行计算。</li>
<li>JDK 19+ Project Loom：虚拟线程（轻量级，数十万并发）——尚在演进，注意与同步&#x2F;阻塞交互。</li>
</ul>
<hr>
<h3 id="2-线程的生命周期和状态（Java-Thread-State）"><a href="#2-线程的生命周期和状态（Java-Thread-State）" class="headerlink" title="2. 线程的生命周期和状态（Java Thread.State）"></a>2. 线程的生命周期和状态（Java Thread.State）</h3><p><strong>六种状态</strong>（Java 枚举 <code>Thread.State</code>）：</p>
<ul>
<li><code>NEW</code>：刚创建，未调用 <code>start()</code>。</li>
<li><code>RUNNABLE</code>：可运行或正在运行（在 JVM&#x2F;OS 中可能是 runnable 或 running）。</li>
<li><code>BLOCKED</code>：阻塞在 monitor（即等待进入 <code>synchronized</code> 的监视器）。</li>
<li><code>WAITING</code>：等待另一个线程显式唤醒（<code>Object.wait()</code> &#x2F; <code>Thread.join()</code> &#x2F; <code>LockSupport.park()</code>）——无限期等待。</li>
<li><code>TIMED_WAITING</code>：带超时的等待（<code>sleep(ms)</code>、带 timeout 的 <code>wait</code>&#x2F;<code>join</code>&#x2F;<code>parkNanos</code>）。</li>
<li><code>TERMINATED</code>：已执行完毕或发生未捕获异常导致终止。</li>
</ul>
<p><strong>典型状态转移</strong></p>
<ul>
<li><code>NEW</code> -&gt; <code>start()</code> -&gt; <code>RUNNABLE</code></li>
<li><code>RUNNABLE</code> -&gt; <code>sleep()</code> -&gt; <code>TIMED_WAITING</code> -&gt; 超时 -&gt; <code>RUNNABLE</code></li>
<li><code>RUNNABLE</code> -&gt; <code>synchronized</code> 被其他线程持有 -&gt; <code>BLOCKED</code> -&gt; 获得锁 -&gt; <code>RUNNABLE</code></li>
<li><code>RUNNABLE</code> -&gt; <code>wait()</code> -&gt; <code>WAITING</code> -&gt; <code>notify()</code> -&gt; <code>RUNNABLE</code></li>
<li><code>RUNNABLE</code> -&gt; 结束执行 -&gt; <code>TERMINATED</code></li>
</ul>
<p><strong>面试点</strong>：<code>RUNNABLE</code> 在 JVM 层既包含“可运行队列”也包含“正在运行（OS thread）”两种含义；<code>BLOCKED</code> 专指等待 monitor。</p>
<hr>
<h3 id="3-wait-与-sleep-的区别（关键点）"><a href="#3-wait-与-sleep-的区别（关键点）" class="headerlink" title="3. wait() 与 sleep() 的区别（关键点）"></a>3. <code>wait()</code> 与 <code>sleep()</code> 的区别（关键点）</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>wait()</code>（Object）</th>
<th><code>sleep()</code>（Thread）</th>
</tr>
</thead>
<tbody><tr>
<td>是否释放锁</td>
<td><strong>释放当前对象监视器锁</strong>（必须在同步块&#x2F;方法内调用）</td>
<td><strong>不释放锁</strong>（不需要在同步块）</td>
</tr>
<tr>
<td>所在类</td>
<td><code>Object</code>（每个对象有 wait set）</td>
<td><code>Thread</code></td>
</tr>
<tr>
<td>被唤醒方式</td>
<td><code>notify()</code> &#x2F; <code>notifyAll()</code> 或 InterruptedException</td>
<td>超时或被中断（<code>interrupt()</code>）</td>
</tr>
<tr>
<td>适用场景</td>
<td>线程间协调（生产&#x2F;消费），需要条件等待</td>
<td>线程暂停，不用于线程间协作（定时）</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!condition) lock.wait(); <span class="comment">// releases lock</span></span><br><span class="line">  <span class="comment">// 被唤醒且重获锁后继续</span></span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>); <span class="comment">// 不释放锁</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-线程同步方式"><a href="#4-线程同步方式" class="headerlink" title="4. 线程同步方式"></a>4. 线程同步方式</h3><ol>
<li><strong>内置锁（synchronized）</strong>：基于对象监视器（monitor），支持重入、wait&#x2F;notify、JVM 优化（偏向、轻量级、重量级）。</li>
<li><strong>显式锁（<code>java.util.concurrent.locks.Lock</code>）</strong>：<code>ReentrantLock</code>、<code>ReadWriteLock</code>，支持可中断锁获取、<code>tryLock</code>、<code>Condition</code>。</li>
<li><strong>AQS（AbstractQueuedSynchronizer）+ 基于队列的同步器</strong>：ReentrantLock、Semaphore、CountDownLatch、FutureTask 等底层支持类。</li>
<li><strong>原子变量（<code>java.util.concurrent.atomic</code>）</strong>：CAS（<code>AtomicInteger</code>、<code>AtomicReference</code>）、乐观并发，不阻塞。</li>
<li><strong>并发集合</strong>：<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>BlockingQueue</code> 等内部有并发控制。</li>
<li><strong>并发工具类</strong>：<code>Semaphore</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Phaser</code>（协调线程）等。</li>
<li><strong>线程间通信</strong>：<code>wait/notify</code>、<code>Lock</code> + <code>Condition</code>、<code>BlockingQueue</code>（生产-消费模式里推荐<code>BlockingQueue</code>）。</li>
</ol>
<p><strong>建议</strong>：尽可能使用 <code>java.util.concurrent</code> 提供的高层抽象（线程池 + 阻塞队列 + 原子类）而不用自己低级实现。</p>
<hr>
<h3 id="5-synchronized-与-Lock-的区别"><a href="#5-synchronized-与-Lock-的区别" class="headerlink" title="5. synchronized 与 Lock 的区别"></a>5. <code>synchronized</code> 与 <code>Lock</code> 的区别</h3><p><strong>共同点</strong>：都能保证互斥与可见性（互斥与内存可见性由 JMM 和实现共同保证）。</p>
<p><strong><code>synchronized</code>（内置监视器）</strong></p>
<ul>
<li>优点：用法简单、异常安全（自动释放锁）、JVM 优化强（偏向锁、轻量级锁、锁消除&#x2F;合并）。</li>
<li>缺点：功能有限（不支持 <code>tryLock</code>、超时、可中断），不支持多个条件队列。</li>
</ul>
<p><strong><code>Lock</code>（显式锁）</strong></p>
<ul>
<li>优点：支持 <code>tryLock</code>、<code>lockInterruptibly</code>、可中断、支持超时、多个 <code>Condition</code>（类似多个 wait-set），更灵活。</li>
<li>缺点：编程复杂，必须在 finally 中 <code>unlock()</code>，否则易死锁；性能在低争用时可能和 <code>synchronized</code> 相近或稍慢，但高争用时 <code>ReentrantLock</code> 可优于 <code>synchronized</code>（尤其是公平&#x2F;非公平策略控制）。</li>
</ul>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">/* critical section */</span> &#125;</span><br><span class="line"><span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-synchronized-的用法及原理"><a href="#6-synchronized-的用法及原理" class="headerlink" title="6. synchronized 的用法及原理"></a>6. <code>synchronized</code> 的用法及原理</h3><p><strong>用法</strong></p>
<ul>
<li>修饰实例方法：<code>synchronized void m()</code> → 锁住 <code>this</code></li>
<li>修饰静态方法：<code>synchronized static void m()</code> → 锁住 Class 对象 (<code>Class&lt;?&gt;</code>)</li>
<li>同步代码块：<code>synchronized(lockObj) &#123; ... &#125;</code> → 锁住 <code>lockObj</code></li>
</ul>
<p><strong>实现原理（HotSpot）</strong></p>
<ul>
<li>JVM 层面：对象头（Mark Word）中存有锁标记，JVM 通过 CAS 操作对象头来尝试获取锁。</li>
<li>锁优化流程（热点优化）：<ol>
<li><strong>偏向锁</strong>（偏向单线程场景，避免 CAS）</li>
<li><strong>轻量级锁</strong>（使用 CAS 在栈上记录锁记录）</li>
<li><strong>重量级锁（monitor）</strong>（线程竞争时进入操作系统互斥锁，使用 OS mutex&#x2F;park&#x2F;unpark）</li>
</ol>
</li>
<li><code>monitorenter</code> &#x2F; <code>monitorexit</code> 字节码对应 JVM 的锁进入&#x2F;释放操作。</li>
<li><code>wait()</code>：会把线程放入对象的 wait-set，释放 monitor 并进入 WAITING；<code>notify()</code> 会把某线程从 wait-set 移入到 entry-list（竞争 monitor）。</li>
</ul>
<p><strong>重入性</strong>：同一线程重复获得同一 monitor，JVM 内部会记录递归计数，释放时减少计数。</p>
<p><strong>JVM 优化</strong>：JIT 可做锁消除（如逃逸分析）或锁粗化（合并多次临近锁）以减少开销。</p>
<hr>
<h3 id="7-对-AQS（AbstractQueuedSynchronizer）的理解（关键概念、内部结构与工作流程）"><a href="#7-对-AQS（AbstractQueuedSynchronizer）的理解（关键概念、内部结构与工作流程）" class="headerlink" title="7. 对 AQS（AbstractQueuedSynchronizer）的理解（关键概念、内部结构与工作流程）"></a>7. 对 AQS（AbstractQueuedSynchronizer）的理解（关键概念、内部结构与工作流程）</h3><p><strong>用途</strong>：AQS 是 JDK 提供的用于构建锁和同步器的基础框架（基于 FIFO 队列），<code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>FutureTask</code> 等都基于 AQS。</p>
<p><strong>核心字段</strong></p>
<ul>
<li><code>volatile int state</code>：表示同步状态（不同同步器含义不同，例如 <code>ReentrantLock</code> 用低位计重入，<code>Semaphore</code> 用作许可计数）。</li>
<li><code>volatile Node head, tail</code>：双向队列头尾，队列实现 CLH 风格（FIFO），节点代表线程等待队列。</li>
<li><code>Node</code> 的 <code>waitStatus</code>（CANCELLED,SIGNAL,CONDITION,PROPAGATE等）。</li>
</ul>
<p><strong>两种模式</strong></p>
<ul>
<li><strong>独占模式（Exclusive）</strong>：只有一个线程能占有（例如 <code>ReentrantLock</code> 的 writeLock）。<ul>
<li>API hook：<code>tryAcquire(int)</code>、<code>tryRelease(int)</code>、<code>isHeldExclusively()</code>。</li>
</ul>
</li>
<li><strong>共享模式（Shared）</strong>：多个线程可同时占有（例如 <code>Semaphore</code>, <code>ReadLock</code> 的一些实现）。<ul>
<li>API hook：<code>tryAcquireShared(int)</code>、<code>tryReleaseShared(int)</code>。</li>
</ul>
</li>
</ul>
<p><strong>获取锁的高层流程（独占）</strong></p>
<ol>
<li>调用 <code>acquire(arg)</code>。首先尝试 <code>tryAcquire(arg)</code>（子类实现）——若成功，直接返回。</li>
<li>若失败，线程封装为 Node 并入队（CAS 设置 tail）。</li>
<li>线程在队列中循序等待，前驱释放时唤醒后继线程（<code>unpark</code>），然后重试 <code>tryAcquire</code>，直到成功或超时&#x2F;中断。</li>
<li>释放时 <code>tryRelease</code> 被调用，成功后会 <code>unpark</code> 下一个等待线程。</li>
</ol>
<p><strong>Condition（条件队列）</strong><br> AQS 提供 <code>ConditionObject</code>，将等待线程放到 Condition 队列（与 AQS 队列分开），<code>await()</code> 会把当前线程迁移到 Condition 队列并释放同步状态，<code>signal()</code> 会把线程移回同步队列，等待获取锁。</p>
<p><strong>实现细节亮点</strong></p>
<ul>
<li>使用 <code>Unsafe.compareAndSwapInt</code> 做 state、head、tail 的原子更新（CAS）。</li>
<li><code>LockSupport.park/unpark</code> 用于线程挂起&#x2F;唤醒（比 <code>wait/notify</code> 更灵活，不要求持有 monitor）。</li>
<li>AQS 还处理中断、超时、取消节点、队列清理等复杂逻辑。</li>
</ul>
<hr>
<h3 id="8-如何创建线程池？线程池常见参数有哪些？（ThreadPoolExecutor-深入）"><a href="#8-如何创建线程池？线程池常见参数有哪些？（ThreadPoolExecutor-深入）" class="headerlink" title="8. 如何创建线程池？线程池常见参数有哪些？（ThreadPoolExecutor 深入）"></a>8. 如何创建线程池？线程池常见参数有哪些？（<code>ThreadPoolExecutor</code> 深入）</h3><p><strong>推荐方式</strong>：直接使用 <code>ThreadPoolExecutor</code> 构造（不要盲用 <code>Executors</code> 的工厂方法在生产环境，因其某些返回队列为无界会隐藏风险）。</p>
<p><strong>常用构造器参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(</span><br><span class="line">  <span class="type">int</span> corePoolSize,</span><br><span class="line">  <span class="type">int</span> maximumPoolSize,</span><br><span class="line">  <span class="type">long</span> keepAliveTime,</span><br><span class="line">  TimeUnit unit,</span><br><span class="line">  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">  ThreadFactory threadFactory,</span><br><span class="line">  RejectedExecutionHandler handler</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>corePoolSize</code>：核心线程数（默认维护即使空闲也不回收，除非 <code>allowCoreThreadTimeOut(true)</code>）。</li>
<li><code>maximumPoolSize</code>：最大线程数。</li>
<li><code>keepAliveTime</code>：非核心线程空闲存活时间。</li>
<li><code>workQueue</code>：任务队列（<code>ArrayBlockingQueue</code> &#x2F; <code>LinkedBlockingQueue</code> &#x2F; <code>SynchronousQueue</code> &#x2F; <code>PriorityBlockingQueue</code> 等）。</li>
<li><code>threadFactory</code>：创建线程（可定制名字、daemon、优先级、异常处理）。</li>
<li><code>handler</code>：拒绝策略（<code>AbortPolicy</code>、<code>CallerRunsPolicy</code>、<code>DiscardPolicy</code>、<code>DiscardOldestPolicy</code> 或自定义）。</li>
</ul>
<p><strong>执行策略（重要）</strong></p>
<ol>
<li>如果运行中的线程数 &lt; <code>corePoolSize</code>，立即启动新线程处理任务；</li>
<li>else 如果工作队列未满，任务入队；</li>
<li>else 如果线程数 &lt; <code>maximumPoolSize</code>，启动新线程处理任务；</li>
<li>else 拒绝任务（触发 <code>RejectedExecutionHandler</code>）。</li>
</ol>
<p><strong>线程池与队列配合示例</strong></p>
<ul>
<li><code>LinkedBlockingQueue</code>（默认无界）+ <code>maximumPoolSize</code> 无效（因为队列不满就入队）</li>
<li><code>SynchronousQueue</code>（零容量）强制快速扩展线程数，常与 <code>maximumPoolSize</code> 配合（适合短任务高并发）</li>
</ul>
<p><strong>线程池参数调优建议</strong></p>
<ul>
<li>CPU 密集型：<code>poolSize ≈ Ncpu</code> 或 <code>Ncpu+1</code>。</li>
<li>IO 密集型：<code>poolSize ≈ Ncpu * (1 + wait/io ratio)</code>。</li>
<li>使用 bounded queue + proper rejection handling + metrics（队列长度、活跃线程数、任务提交速率）才安全。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">  <span class="number">8</span>,  <span class="comment">// core</span></span><br><span class="line">  <span class="number">32</span>, <span class="comment">// max</span></span><br><span class="line">  <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">NamedThreadFactory</span>(<span class="string">&quot;worker-&quot;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="9-volatile-的用法及原理（Java-内存语义）"><a href="#9-volatile-的用法及原理（Java-内存语义）" class="headerlink" title="9. volatile 的用法及原理（Java 内存语义）"></a>9. <code>volatile</code> 的用法及原理（Java 内存语义）</h3><p><strong>语义</strong></p>
<ul>
<li><code>volatile</code> 变量具有 <strong>可见性</strong>：写入一个 volatile 变量后，对该变量的写入对随后读取该变量的所有线程可见（建立 <code>happens-before</code>）。</li>
<li>禁止指令重排序（部分）：volatile 写有 <strong>释放（release）语义</strong>，volatile 读有 <strong>获取（acquire）语义</strong>。写 <code>volatile</code> 之前的操作不会被搬到写之后；读 <code>volatile</code> 之后的操作不会被搬到读之前（强制内存屏障）。</li>
<li><strong>不保证原子性</strong>（复合操作如 <code>i++</code> 不是原子）。</li>
</ul>
<p><strong>实现原理（HotSpot）</strong></p>
<ul>
<li>Java 编译器&#x2F;CPU 内存屏障（fence）+ JVM intrinsics：volatile 写会产生 StoreStore + StoreLoad 屏障（或更严格），volatile 读会产生 LoadLoad + LoadStore 屏障，保证内存可见性和一定顺序。</li>
</ul>
<p><strong>典型使用场景</strong></p>
<ul>
<li>状态标志（<code>volatile boolean running</code>），用于停止线程。</li>
<li>双重检查锁（DCL）中 <code>volatile</code> 修饰单例（防止构造对象引用外逃）。</li>
<li>轻量级的可见性需求，不需完整锁开销的场景。</li>
</ul>
<p><strong>示例（停止线程）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (running) &#123; doWork(); &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123; running = <span class="literal">false</span>; &#125; <span class="comment">// 其他线程可立即看到</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10-ThreadLocal-的用法和实现原理（ThreadLocalMap）"><a href="#10-ThreadLocal-的用法和实现原理（ThreadLocalMap）" class="headerlink" title="10. ThreadLocal 的用法和实现原理（ThreadLocalMap）"></a>10. <code>ThreadLocal</code> 的用法和实现原理（ThreadLocalMap）</h3><p><strong>用途</strong></p>
<ul>
<li>为每个线程维护独立的变量副本（例如：用户上下文、SimpleDateFormat、DB session 等），避免锁竞争。</li>
</ul>
<p><strong>使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; TL =</span><br><span class="line">    ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line"></span><br><span class="line">Date <span class="title function_">parse</span><span class="params">(String s)</span> &#123; <span class="keyword">return</span> TL.get().parse(s); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必要时清理</span></span><br><span class="line">TL.remove();</span><br></pre></td></tr></table></figure>

<p><strong>实现原理</strong></p>
<ul>
<li>每个 <code>Thread</code> 对象内部维护一个 <code>ThreadLocalMap</code>（不是全局 map），键是 <code>ThreadLocal&lt;?&gt;</code> 的弱引用（<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>），值是强引用到实际对象。</li>
<li><code>ThreadLocalMap</code> 是数组 + open addressing（线性探测）实现，<code>ThreadLocal</code> 有自己的 hash（threadLocalHashCode）。</li>
</ul>
<p><strong>内存泄露风险（关键点）</strong></p>
<ul>
<li><code>ThreadLocal</code> 的 <strong>key</strong> 是弱引用，若你把 <code>ThreadLocal</code> 变量设为局部变量或在某个类中只保存弱引用并丢弃强引用，key 可能被 GC，但 <code>ThreadLocalMap</code> 中的该 entry 的 <strong>value</strong> 是强引用，<strong>不会自动被清理</strong>（直到下一次 <code>ThreadLocal</code> 操作或某次 <code>ThreadLocalMap</code> 执行 expungeStaleEntries）。</li>
<li>在使用线程池时线程不会死亡，ThreadLocal 的 value 若不显式 <code>remove()</code> 会一直占用内存 → 导致内存泄漏。<br> <strong>防范</strong>：在 <code>finally</code> 中调用 <code>remove()</code>，避免把 <code>ThreadLocal</code> 设为静态且不清理。</li>
</ul>
<hr>
<h3 id="11-Java-里的-CAS（Compare-And-Swap）（概念-使用）"><a href="#11-Java-里的-CAS（Compare-And-Swap）（概念-使用）" class="headerlink" title="11. Java 里的 CAS（Compare-And-Swap）（概念 + 使用）"></a>11. Java 里的 CAS（Compare-And-Swap）（概念 + 使用）</h3><p><strong>概念</strong></p>
<ul>
<li>CAS 是无锁编程的原子操作：比较内存中的某个位置的当前值 <code>V</code> 与期望值 <code>A</code>，若相等则将其更新为 <code>B</code>；否则不更新。返回是否成功。</li>
<li>Java 通过 <code>Unsafe.compareAndSwapInt/Long/Object</code> 或 <code>VarHandle</code> 提供 CAS。</li>
</ul>
<p><strong>常见用法</strong></p>
<ul>
<li><code>AtomicInteger</code>、<code>AtomicReference</code> 的 <code>compareAndSet()</code>。</li>
<li>在自旋循环中：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> expect, update;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  expect = atomic.get();</span><br><span class="line">  update = compute(expect);</span><br><span class="line">&#125; <span class="keyword">while</span> (!atomic.compareAndSet(expect, update));</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：避免阻塞、低延迟（无上下文切换）<br> <strong>缺点</strong>：高并发下自旋会浪费 CPU、需要重试（活跃性 vs 饥饿可能），存在 ABA 问题。</p>
<hr>
<h3 id="12-CAS-会出现什么问题？ABA-问题如何解决？"><a href="#12-CAS-会出现什么问题？ABA-问题如何解决？" class="headerlink" title="12. CAS 会出现什么问题？ABA 问题如何解决？"></a>12. CAS 会出现什么问题？ABA 问题如何解决？</h3><p><strong>问题</strong></p>
<ol>
<li><strong>ABA 问题</strong>：线程 T1 读取值 A；T2 把 A -&gt; B -&gt; A（短时间内）；T1 执行 CAS 发现仍为 A，误以为未被修改过。</li>
<li><strong>自旋开销</strong>：长时间重试浪费 CPU。</li>
<li><strong>只解决单变量原子性</strong>：复杂更新需要分步或额外同步。</li>
</ol>
<p><strong>解决 ABA 的常见方法</strong></p>
<ul>
<li><strong>版本号（带标记）</strong>：把值与版本（stamp）一起 CAS（<code>AtomicStampedReference</code>），每次修改版本号+1。CAS 检查不仅值还检查版本。</li>
<li><strong><code>AtomicMarkableReference</code>&#x2F;<code>AtomicStampedReference</code></strong>：JDK 提供两种封装用于区分状态。</li>
<li><strong>垃圾回收&#x2F;内存管理策略</strong>：在某些场景中使用 GC 或引用计数减少 ABA 可能性（语言&#x2F;平台相关）。</li>
</ul>
<hr>
<h3 id="13-Java-线程与操作系统线程区别（概念与-HotSpot-实现）"><a href="#13-Java-线程与操作系统线程区别（概念与-HotSpot-实现）" class="headerlink" title="13. Java 线程与操作系统线程区别（概念与 HotSpot 实现）"></a>13. Java 线程与操作系统线程区别（概念与 HotSpot 实现）</h3><p><strong>Java 线程（<code>java.lang.Thread</code>）</strong></p>
<ul>
<li>Java 层的抽象，描述执行单元。</li>
<li>HotSpot 自 JDK1.3 之后使用 <strong>1:1 映射</strong> 到 OS 原生线程（native threads）。早期某些 JVM 可能使用 green threads（用户级线程），但现在主流 JVM 都用 native threads。</li>
</ul>
<p><strong>区别&#x2F;联系</strong></p>
<ul>
<li><strong>调度</strong>：实际由操作系统调度（time slice, priority）；JVM 可以调用 <code>park</code>&#x2F;<code>unpark</code> &#x2F; <code>suspend</code>(deprecated) 来配合。</li>
<li><strong>资源</strong>：OS 线程有系统栈、线程控制块等，开销大；虚拟线程（Loom）是 JVM 层的轻量线程，调度由 JVM 管理、挂起成本低。</li>
<li><strong>中断与同步语义</strong>：Java 定义了一套线程中断、锁语义、内存模型（JMM）抽象，这些由 JVM 映射成 OS 调用与内存屏障实现。</li>
</ul>
<hr>
<h3 id="14-Java-中如何检测死锁？如何预防和避免线程死锁？"><a href="#14-Java-中如何检测死锁？如何预防和避免线程死锁？" class="headerlink" title="14. Java 中如何检测死锁？如何预防和避免线程死锁？"></a>14. Java 中如何检测死锁？如何预防和避免线程死锁？</h3><p><strong>检测死锁方法</strong></p>
<ul>
<li><strong>ThreadMXBean</strong>（JMX）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadMXBean</span> <span class="variable">tm</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line"><span class="type">long</span>[] ids = tm.findDeadlockedThreads(); <span class="comment">// 或 findMonitorDeadlockedThreads()</span></span><br><span class="line"><span class="keyword">if</span> (ids != <span class="literal">null</span>) &#123;</span><br><span class="line">  ThreadInfo[] infos = tm.getThreadInfo(ids,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 分析 stack trace 和 locked monitors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>jstack</strong>：在生产上拿多份线程 dump（间隔几秒）观察是否多线程相互持有对方锁并等待 <code>Found one Java-level deadlock</code>。</li>
</ul>
<p><strong>死锁产生条件（四必要条件）</strong></p>
<ol>
<li>互斥（至少一个资源被独占）</li>
<li>占有且等待（线程持有资源且等待其他资源）</li>
<li>不可抢占（资源不能被强行从线程拿走）</li>
<li>环路等待（A 等待 B，B 等待 C，…，Z 等待 A）</li>
</ol>
<p><strong>预防与避免策略</strong></p>
<ul>
<li><strong>统一加锁顺序</strong>：保证多个线程按固定顺序获取锁（最简单有效）。</li>
<li><strong>使用 <code>tryLock(timeout)</code></strong>：若没有获得锁，回退并重试或按其它逻辑处理，防止永远等待。</li>
<li><strong>减少锁粒度&#x2F;持有时间</strong>：尽量把临界区缩小。</li>
<li><strong>资源分配策略</strong>：一次性申请全部需要的锁或使用锁分层。</li>
<li><strong>避免嵌套锁</strong>：尽量减少持有锁时去请求别的锁。</li>
<li><strong>使用无锁&#x2F;乐观算法</strong>：如 CAS、Concurrent Collections 等。</li>
</ul>
<hr>
<h3 id="15-写一个-Java-死锁的例子（示例代码）"><a href="#15-写一个-Java-死锁的例子（示例代码）" class="headerlink" title="15. 写一个 Java 死锁的例子（示例代码）"></a>15. 写一个 Java 死锁的例子（示例代码）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t1 acquired A and B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t2 acquired B and A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start(); t2.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> ms)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(ms); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果：可能出现 t1 持有 A 等待 B，t2 持有 B 等待 A → 永久阻塞（死锁）。</li>
</ul>
<hr>
<h3 id="16-volatile-可以保证原子性么？"><a href="#16-volatile-可以保证原子性么？" class="headerlink" title="16. volatile 可以保证原子性么？"></a>16. <code>volatile</code> 可以保证原子性么？</h3><p><strong>结论</strong>：<strong>不能</strong>保证复合操作的原子性（例如 <code>i++</code> 不是原子）。</p>
<ul>
<li>单次读&#x2F;写 <code>volatile</code> 对象或基本类型（除 long&#x2F;double 在早期 JVM）是原子性的（JMM 保证对 <code>volatile long/double</code> 的写也是原子的）。</li>
<li>若需要原子复合操作，使用 <code>synchronized</code> 或 <code>AtomicInteger</code> &#x2F; <code>AtomicLong</code>。</li>
</ul>
<hr>
<h3 id="17-公平锁与非公平锁有什么区别？"><a href="#17-公平锁与非公平锁有什么区别？" class="headerlink" title="17. 公平锁与非公平锁有什么区别？"></a>17. 公平锁与非公平锁有什么区别？</h3><p><strong>公平锁</strong>：线程获取锁的顺序按照请求顺序（FIFO）。能防止饥饿，但吞吐量较低（因为每次释放后必须唤醒队列头部线程，且上下文切换频率更高）。<code>new ReentrantLock(true)</code> 表示公平锁。</p>
<p><strong>非公平锁</strong>（默认）：释放锁后线程可以“插队”再次获取（即有竞争时当前线程更可能再次拿到锁），可提高吞吐量但可能导致某些线程饥饿。</p>
<p><strong>synchronized</strong> 在 HotSpot 实现中是<strong>非公平</strong>的（存在偏向锁、轻量级锁优化）。</p>
<hr>
<h3 id="18-乐观锁与悲观锁（思想-典型实现）"><a href="#18-乐观锁与悲观锁（思想-典型实现）" class="headerlink" title="18. 乐观锁与悲观锁（思想 + 典型实现）"></a>18. 乐观锁与悲观锁（思想 + 典型实现）</h3><p><strong>悲观锁</strong></p>
<ul>
<li>假设并发会导致冲突，进入临界区前先加锁（阻塞其他线程）。</li>
<li>典型实现：<code>synchronized</code>、<code>ReentrantLock</code>（独占锁）。</li>
</ul>
<p><strong>乐观锁</strong></p>
<ul>
<li>假设并发冲突少，用无锁方式尝试更新，冲突发生时回退重试。</li>
<li>典型实现：CAS（<code>Atomic*</code> 类）、数据库中的 <code>version</code> 字段 + <code>WHERE version = ?</code>（乐观更新）</li>
<li>优点：在读多写少时能极大提高并发；缺点：高冲突时会频繁重试，性能下降。</li>
</ul>
<p><strong>实际选择</strong>：大并发读、少量写可选乐观锁；高冲突写密集场景选悲观锁。</p>
<hr>
<h3 id="19-synchronized-和-volatile-的区别（再对比）"><a href="#19-synchronized-和-volatile-的区别（再对比）" class="headerlink" title="19. synchronized 和 volatile 的区别（再对比）"></a>19. <code>synchronized</code> 和 <code>volatile</code> 的区别（再对比）</h3><ul>
<li><code>synchronized</code>：互斥 + 可见性（保证原子性、互斥进入临界区、自动释放锁），并且实现了内存可见性（通过 monitorenter&#x2F;monitorexit）。</li>
<li><code>volatile</code>：只保证<strong>可见性与一定的指令序</strong>（禁止某些重排序），<strong>不保证原子性</strong>。不能用来保护复合操作。</li>
</ul>
<p><strong>总结</strong>：<code>volatile</code> 适合标志位等轻量同步；<code>synchronized</code> 适合需要原子修改共享状态的场景。</p>
<hr>
<h3 id="20-ReentrantLock-的定义和特性"><a href="#20-ReentrantLock-的定义和特性" class="headerlink" title="20. ReentrantLock 的定义和特性"></a>20. <code>ReentrantLock</code> 的定义和特性</h3><p><strong>定义</strong>：<code>ReentrantLock</code> 是 <code>Lock</code> 接口的可重入实现（基于 AQS）。</p>
<p><strong>主要特性</strong></p>
<ul>
<li><strong>可重入</strong>：同一线程可多次获取，AQS <code>state</code> 记录重入次数。</li>
<li><strong>可中断获取锁</strong>：<code>lockInterruptibly()</code> 支持响应中断。</li>
<li><strong>支持超时获取</strong>：<code>tryLock(long timeout, TimeUnit unit)</code>。</li>
<li><strong>支持公平&#x2F;非公平策略</strong>：构造器接受 <code>fair</code> 标志。</li>
<li><strong>Condition 支持</strong>：<code>lock.newCondition()</code> 提供比 Object.wait&#x2F;notify 更灵活的多个条件队列。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">cond</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (!condition) cond.await(); <span class="comment">// 可响应 interrupt</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="21-ReentrantReadWriteLock-的使用场景"><a href="#21-ReentrantReadWriteLock-的使用场景" class="headerlink" title="21. ReentrantReadWriteLock 的使用场景"></a>21. <code>ReentrantReadWriteLock</code> 的使用场景</h3><p><strong>用途</strong>：读多写少场景：允许多个线程并发读，但写时独占（读写互斥）。<br> <strong>使用场景</strong>：</p>
<ul>
<li>缓存&#x2F;内存共享资源频繁读、偶尔写：例如配置缓存、只读数据查询等。<br> <strong>注意点</strong>：</li>
<li>写锁获取时会等待所有读锁释放，读锁在写等待时可导致写饥饿（默认实现有写锁优先或公平选项可用）。</li>
<li>读锁内部实现较复杂（基于 AQS 的 state 高 16 位或低位用于计数，实际设计细节会随 JDK 版本微调）。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">rw.readLock().lock();</span><br><span class="line"><span class="keyword">try</span> &#123; read(); &#125; <span class="keyword">finally</span> &#123; rw.readLock().unlock(); &#125;</span><br><span class="line">rw.writeLock().lock();</span><br><span class="line"><span class="keyword">try</span> &#123; write(); &#125; <span class="keyword">finally</span> &#123; rw.writeLock().unlock(); &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="22-ThreadLocal-内存泄露如何导致的？"><a href="#22-ThreadLocal-内存泄露如何导致的？" class="headerlink" title="22. ThreadLocal 内存泄露如何导致的？"></a>22. <code>ThreadLocal</code> 内存泄露如何导致的？</h3><p><strong>具体机理</strong>：</p>
<ul>
<li><code>Thread</code> 对象持有 <code>ThreadLocalMap</code>，该 map 的 key 是 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，value 是强引用。</li>
<li>若 ThreadLocal 实例被外部丢弃（例如设置为 null），key 弱引用会被 GC 回收 → <code>ThreadLocalMap</code> 中该 entry 的 key 变为 <code>null</code>，但 value 仍然是强引用，不会被回收，导致内存泄露。</li>
<li>在使用线程池时，线程会被复用，不会结束，entry 永远存在，产生长期泄露。</li>
</ul>
<p><strong>防范</strong></p>
<ul>
<li>在使用 <code>ThreadLocal</code> 的地方确保 <code>remove()</code>（尤其在线程池中使用时）。</li>
<li>避免把 ThreadLocal 当成静态缓存存放大量对象，或确保在任务结束时清理。</li>
<li>使用 try&#x2F;finally：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(obj);</span><br><span class="line"><span class="keyword">try</span> &#123; ... &#125; <span class="keyword">finally</span> &#123; threadLocal.remove(); &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="23-线程池常用的阻塞队列（BlockingQueue）"><a href="#23-线程池常用的阻塞队列（BlockingQueue）" class="headerlink" title="23. 线程池常用的阻塞队列（BlockingQueue）"></a>23. 线程池常用的阻塞队列（BlockingQueue）</h3><ul>
<li><code>ArrayBlockingQueue</code>：有界、基于数组、固定容量、可选择公平策略。</li>
<li><code>LinkedBlockingQueue</code>：常用，可有界或无界（默认无界），吞吐高。</li>
<li><code>SynchronousQueue</code>：不存储元素，直接交接，适合短任务，配合 <code>maximumPoolSize</code> 扩展线程。</li>
<li><code>PriorityBlockingQueue</code>：优先级队列，元素需实现 <code>Comparable</code>（或传入 Comparator），注意是无界队列（默认）。</li>
<li><code>DelayQueue</code>：延迟队列（任务带延迟），常和调度&#x2F;延时任务配合。</li>
<li><code>LinkedTransferQueue</code>：高性能无界队列，支持 transfer semantics。</li>
</ul>
<p><strong>要点</strong>：队列的选择强烈影响线程池行为（是否会扩容、是否会阻塞生产者等）。</p>
<hr>
<h3 id="24-设计一个线程池，使其按任务优先级运行（思路-注意）"><a href="#24-设计一个线程池，使其按任务优先级运行（思路-注意）" class="headerlink" title="24. 设计一个线程池，使其按任务优先级运行（思路 + 注意）"></a>24. 设计一个线程池，使其按任务优先级运行（思路 + 注意）</h3><p><strong>思路</strong>：使用 <code>PriorityBlockingQueue&lt;Runnable&gt;</code> 作为任务队列，任务实现 <code>Comparable</code>（或包装一个 <code>PriorityRunnable</code>）。<br> <strong>问题&#x2F;注意</strong>：</p>
<ul>
<li><code>PriorityBlockingQueue</code> 默认是无界的，可能导致 <code>maximumPoolSize</code> 无效（因为队列永远不满，不会触发扩容），通常搭配 bounded wrapper 或自定义拒绝策略。</li>
<li>由于优先级队列不保证相同优先级的 FIFO 顺序，若需要稳定顺序需在比较器中包含序号。</li>
</ul>
<p><strong>实现示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Comparable&lt;PriorityRunnable&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> priority;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> seq;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</span><br><span class="line">  <span class="comment">// constructor...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PriorityRunnable o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Integer.compare(o.priority, <span class="built_in">this</span>.priority); <span class="comment">// higher priority first</span></span><br><span class="line">    <span class="keyword">return</span> r != <span class="number">0</span> ? r : Long.compare(<span class="built_in">this</span>.seq, o.seq);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; task.run(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">PriorityBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>&lt;&gt;();</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">  core, max, keepAlive, TimeUnit.SECONDS, queue, threadFactory, handler);</span><br></pre></td></tr></table></figure>

<p><strong>更好方案</strong>：若要有界行为且保持优先级，使用 <code>PriorityBlockingQueue</code> + <code>Semaphore</code> 或自定义 bounded priority queue。</p>
<hr>
<h3 id="25-Callable-和-Future（区别与使用）"><a href="#25-Callable-和-Future（区别与使用）" class="headerlink" title="25. Callable 和 Future（区别与使用）"></a>25. <code>Callable</code> 和 <code>Future</code>（区别与使用）</h3><ul>
<li><code>Callable&lt;V&gt;</code>：任务接口，<code>V call()</code> 可返回结果并抛异常。</li>
<li><code>Future&lt;V&gt;</code>：表示异步计算的结果句柄，常用方法：<code>get()</code>（阻塞拿结果）、<code>cancel()</code>、<code>isDone()</code>、<code>isCancelled()</code>。</li>
<li><code>FutureTask&lt;V&gt;</code>：同时实现 <code>Runnable</code> 和 <code>Future</code>，可被 <code>Executor</code> 执行并支持 <code>get()</code>。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Future&lt;Integer&gt; f = pool.submit(() -&gt; &#123;</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> f.get(); <span class="comment">// 阻塞直到结果或异常</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="26-Semaphore-有什么用？（原理与常见用途）"><a href="#26-Semaphore-有什么用？（原理与常见用途）" class="headerlink" title="26. Semaphore 有什么用？（原理与常见用途）"></a>26. <code>Semaphore</code> 有什么用？（原理与常见用途）</h3><p><strong>概念</strong>：信号量，用来控制访问某类资源的并发数量（许可数 permits）。可以公平或非公平。内部基于 AQS（共享模式）。</p>
<p><strong>常见用途</strong></p>
<ul>
<li>连接池并发控制：限制同时获取 DB 连接的线程数。</li>
<li>限流：例如并发请求数控制。</li>
<li>保护稀缺资源。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">sem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>);</span><br><span class="line">sem.acquire();</span><br><span class="line"><span class="keyword">try</span> &#123; accessResource(); &#125; <span class="keyword">finally</span> &#123; sem.release(); &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="27-CountDownLatch-有什么用？（用途、内部与示例）"><a href="#27-CountDownLatch-有什么用？（用途、内部与示例）" class="headerlink" title="27. CountDownLatch 有什么用？（用途、内部与示例）"></a>27. <code>CountDownLatch</code> 有什么用？（用途、内部与示例）</h3><p><strong>概念</strong>：一次性计数器，初始化一个计数 N，调用 <code>countDown()</code> 将计数减 1；<code>await()</code> 阻塞直到计数为 0。底层基于 AQS（共享模式）。</p>
<p><strong>用途</strong></p>
<ul>
<li>等待多个初始化任务完成（主线程等待多个子线程加载资源）。</li>
<li>简单的线程同步点（一次性的 barrier）。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    doWork();</span><br><span class="line">    latch.countDown();</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">latch.await(); <span class="comment">// 等 3 个任务完成</span></span><br></pre></td></tr></table></figure>

<p><strong>不可重用</strong>：CountDownLatch 一旦计数到 0 就不能复位（若需复用用 <code>CyclicBarrier</code> 或 <code>Phaser</code>）。</p>
<hr>
<h3 id="附：一些常见面试问答扩展（精选应答）"><a href="#附：一些常见面试问答扩展（精选应答）" class="headerlink" title="附：一些常见面试问答扩展（精选应答）"></a>附：一些常见面试问答扩展（精选应答）</h3><ul>
<li><strong>如何检测死锁</strong>：用 <code>ThreadMXBean.findDeadlockedThreads()</code> 或 <code>jstack</code> 多份堆栈分析。</li>
<li><strong>如何避免索引&#x2F;线程池级别死锁或线程饥饿</strong>：统一锁顺序、使用 <code>tryLock(timeout)</code>、合理配置池大小和队列。</li>
<li><strong>何时用 volatile vs Atomic vs synchronized</strong>：<ul>
<li><code>volatile</code>：只需可见性&#x2F;禁止重排序的标志位；</li>
<li><code>Atomic*</code>：需要原子更新但无复杂互斥；</li>
<li><code>synchronized</code>&#x2F;<code>Lock</code>：需要复杂的互斥逻辑、条件等待或复合操作原子性时使用。</li>
</ul>
</li>
<li><strong>为什么 prefer ExecutorService</strong>：线程复用、统一异常处理、资源控制、监控与伸缩。</li>
</ul>
<h2 id="测试理论基础-牛客面经八股"><a href="#测试理论基础-牛客面经八股" class="headerlink" title="测试理论基础-牛客面经八股"></a>测试理论基础-牛客面经八股</h2><p>好的 ✅，这一组问题涉及 <strong>软件测试基础、测试设计方法、Bug管理、性能测试、接口测试</strong> 等核心知识点。我会逐题展开，保证细节和深度，适合面试八股 + 实际场景。</p>
<hr>
<h3 id="1、黑盒测试与白盒测试的区别是什么？"><a href="#1、黑盒测试与白盒测试的区别是什么？" class="headerlink" title="1、黑盒测试与白盒测试的区别是什么？"></a><strong>1、黑盒测试与白盒测试的区别是什么？</strong></h3><ul>
<li><strong>黑盒测试</strong>（功能测试）<ul>
<li><strong>关注点</strong>：功能是否符合需求说明书，<strong>不关心内部实现</strong>。</li>
<li><strong>特点</strong>：输入 → 输出，测试员像用户一样。</li>
<li><strong>方法</strong>：等价类划分、边界值、因果图、判定表。</li>
<li><strong>优点</strong>：贴近用户，容易发现功能缺陷。</li>
<li><strong>缺点</strong>：覆盖率有限，不能发现内部逻辑错误。</li>
</ul>
</li>
<li><strong>白盒测试</strong>（结构测试）<ul>
<li><strong>关注点</strong>：程序代码逻辑、语句、分支、条件。</li>
<li><strong>特点</strong>：需要了解源码。</li>
<li><strong>方法</strong>：语句覆盖、分支覆盖、条件覆盖、路径覆盖。</li>
<li><strong>优点</strong>：能发现隐藏的逻辑漏洞。</li>
<li><strong>缺点</strong>：需要开发技能，难以覆盖大规模系统。<br> 👉 实际项目中：<strong>黑盒为主，白盒为辅</strong>。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2、什么是冒烟测试？</strong></p>
<ul>
<li><strong>定义</strong>：冒烟测试是一种<strong>快速验证构建质量</strong>的测试方式，验证核心功能是否正常。</li>
<li><strong>目标</strong>：确保系统的基本功能可用，构建稳定，适合进一步测试。</li>
<li><strong>特点</strong>：<ul>
<li>测试范围小，但覆盖核心功能。</li>
<li>常常自动化（CI&#x2F;CD 中构建后立即跑冒烟测试）。</li>
</ul>
</li>
<li><strong>比喻</strong>：像开机时先通电 → 如果冒烟，就说明问题大，没必要继续测试。</li>
</ul>
<hr>
<h3 id="3、测试用例设计时需要注意什么？提Bug需要注意哪些点？"><a href="#3、测试用例设计时需要注意什么？提Bug需要注意哪些点？" class="headerlink" title="3、测试用例设计时需要注意什么？提Bug需要注意哪些点？"></a><strong>3、测试用例设计时需要注意什么？提Bug需要注意哪些点？</strong></h3><ul>
<li><strong>测试用例注意点</strong>：<ul>
<li>覆盖需求的每个点。</li>
<li>既考虑正常场景（正向用例），也考虑异常输入（逆向用例）。</li>
<li>优先级划分（P0&#x2F;P1&#x2F;P2）。</li>
<li>可复现、可执行、结果可验证。</li>
</ul>
</li>
<li><strong>提Bug注意点</strong>：<ul>
<li><strong>完整性</strong>：复现步骤、期望结果、实际结果、环境信息。</li>
<li><strong>准确性</strong>：确认是 Bug，而不是需求不符或环境问题。</li>
<li><strong>复现率</strong>：提供最小复现条件。</li>
<li><strong>影响评估</strong>：说明 Bug 的严重性、优先级。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4、了解Bug的逃逸率吗？怎么降低？"><a href="#4、了解Bug的逃逸率吗？怎么降低？" class="headerlink" title="4、了解Bug的逃逸率吗？怎么降低？"></a><strong>4、了解Bug的逃逸率吗？怎么降低？</strong></h3><ul>
<li><strong>Bug逃逸率</strong>：指 <strong>测试未发现而用户发现的Bug &#x2F; 总Bug数</strong>。</li>
<li><strong>公式</strong>：Bug逃逸率 &#x3D; 生产环境发现的Bug数 ÷ 总Bug数 × 100%</li>
<li><strong>降低方法</strong>：<ul>
<li>需求评审：保证需求清晰。</li>
<li>测试用例设计全面，覆盖边界、异常场景。</li>
<li>加强自动化测试（单测、接口、UI）。</li>
<li>增加性能、兼容、异常测试。</li>
<li>回归测试保证修复不引入新Bug。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5、测试报告是怎么写的？"><a href="#5、测试报告是怎么写的？" class="headerlink" title="5、测试报告是怎么写的？"></a><strong>5、测试报告是怎么写的？</strong></h3><p>一个完整的 <strong>测试报告</strong> 包括：</p>
<ol>
<li><strong>背景</strong>：测试版本、时间、测试范围。</li>
<li><strong>测试内容</strong>：功能点列表，覆盖情况。</li>
<li><strong>测试执行结果</strong>：<ul>
<li>用例数：总数 &#x2F; 执行数 &#x2F; 通过 &#x2F; 失败。</li>
<li>Bug数量：总数、已解决、未解决、按严重级别分类。</li>
</ul>
</li>
<li><strong>风险与遗留问题</strong>：哪些Bug未解决，可能影响哪些功能。</li>
<li><strong>结论与建议</strong>：是否建议上线，注意事项。</li>
</ol>
<hr>
<h3 id="6、你有没有接触一些和AI相关的自动化测试？"><a href="#6、你有没有接触一些和AI相关的自动化测试？" class="headerlink" title="6、你有没有接触一些和AI相关的自动化测试？"></a><strong>6、你有没有接触一些和AI相关的自动化测试？</strong></h3><ul>
<li><strong>AI在自动化测试中的应用</strong>：<ul>
<li><strong>智能元素识别</strong>：传统 UI 自动化容易因 DOM 变化失败，AI 可做视觉识别（OCR + 图像识别）。</li>
<li><strong>智能用例生成</strong>：基于需求文档、日志分析，自动生成测试用例。</li>
<li><strong>异常检测</strong>：AI 可基于日志或监控，自动识别异常模式。</li>
<li><strong>智能 Bug 分析</strong>：根据历史数据，预测 Bug 可能的根因。<br> 👉 越来越多企业用 <strong>AI + 自动化测试平台（Selenium、Appium + AI 辅助）</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7、性能测试怎么做？需要关注哪些指标？"><a href="#7、性能测试怎么做？需要关注哪些指标？" class="headerlink" title="7、性能测试怎么做？需要关注哪些指标？"></a><strong>7、性能测试怎么做？需要关注哪些指标？</strong></h3><ul>
<li><strong>性能测试目标</strong>：验证系统在高并发、大数据量情况下的表现。</li>
<li><strong>方法</strong>：<ul>
<li>使用工具：JMeter、LoadRunner、Locust。</li>
<li>模拟用户请求，逐步加压。</li>
</ul>
</li>
<li><strong>关注指标</strong>：<ol>
<li><strong>吞吐量（TPS&#x2F;QPS）</strong></li>
<li><strong>响应时间（RT，P90&#x2F;P95&#x2F;P99）</strong></li>
<li><strong>并发用户数</strong></li>
<li><strong>CPU、内存、IO、带宽</strong></li>
<li><strong>错误率</strong></li>
</ol>
</li>
<li><strong>场景</strong>：<ul>
<li>压力测试：极限承载。</li>
<li>负载测试：逐渐增加并发。</li>
<li>稳定性测试：长时间运行。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8、如何判断一个Bug是前端还是后端引起的？"><a href="#8、如何判断一个Bug是前端还是后端引起的？" class="headerlink" title="8、如何判断一个Bug是前端还是后端引起的？"></a><strong>8、如何判断一个Bug是前端还是后端引起的？</strong></h3><ul>
<li><strong>判断思路</strong>：<ol>
<li><strong>接口测试</strong>：<ul>
<li>如果接口返回异常 → 后端问题。</li>
<li>接口正常但页面展示错误 → 前端问题。</li>
</ul>
</li>
<li><strong>抓包 &#x2F; 调试工具</strong>：Fiddler、Postman、浏览器 Network。</li>
<li><strong>日志分析</strong>：<ul>
<li>前端控制台报错。</li>
<li>后端日志报错（异常栈、SQL错误）。</li>
</ul>
</li>
<li><strong>复现路径</strong>：<ul>
<li>单接口调试通过，前端渲染有问题 → 前端。</li>
<li>单接口调试失败 → 后端。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="9、接口测试工具及方法、接口自动化框架搭建及参数化实现"><a href="#9、接口测试工具及方法、接口自动化框架搭建及参数化实现" class="headerlink" title="9、接口测试工具及方法、接口自动化框架搭建及参数化实现"></a><strong>9、接口测试工具及方法、接口自动化框架搭建及参数化实现</strong></h3><ul>
<li><strong>接口测试工具</strong>：Postman、JMeter、Swagger、Apifox。</li>
<li><strong>方法</strong>：<ul>
<li>验证请求参数、返回值、状态码。</li>
<li>验证业务逻辑、异常处理。</li>
<li>安全性（SQL注入、越权访问）。</li>
</ul>
</li>
<li><strong>接口自动化框架</strong>：<ul>
<li>语言：Java（RestAssured + TestNG）、Python（pytest + requests）。</li>
<li><strong>框架结构</strong>：用例层 → 数据驱动层 → 公共方法层 → 报告层。</li>
<li><strong>参数化实现</strong>：用 Excel&#x2F;CSV&#x2F;JSON&#x2F;YAML 存储数据，框架读取并循环执行。<br> 👉 最终实现 <strong>持续集成（CI）+ 持续交付（CD）</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10、除了功能测试、性能测试，还有什么测试类型？"><a href="#10、除了功能测试、性能测试，还有什么测试类型？" class="headerlink" title="10、除了功能测试、性能测试，还有什么测试类型？"></a><strong>10、除了功能测试、性能测试，还有什么测试类型？</strong></h3><ul>
<li><strong>安全测试</strong>：SQL注入、XSS、CSRF。</li>
<li><strong>兼容性测试</strong>：不同浏览器、不同设备。</li>
<li><strong>可用性测试</strong>：用户体验。</li>
<li><strong>接口测试</strong>。</li>
<li><strong>回归测试</strong>。</li>
<li><strong>可靠性测试</strong>。</li>
<li><strong>并发测试</strong>。</li>
<li><strong>灰度测试 &#x2F; A&#x2F;B 测试</strong>。</li>
</ul>
<hr>
<h3 id="11、发现了支付成功但后台订单未生成的问题，从发现到提交Bug会做哪些工作？"><a href="#11、发现了支付成功但后台订单未生成的问题，从发现到提交Bug会做哪些工作？" class="headerlink" title="11、发现了支付成功但后台订单未生成的问题，从发现到提交Bug会做哪些工作？"></a><strong>11、发现了支付成功但后台订单未生成的问题，从发现到提交Bug会做哪些工作？</strong></h3><ol>
<li><strong>确认现象</strong>：<ul>
<li>支付是否真实成功（第三方支付回调成功？）。</li>
<li>是否是单次还是批量问题。</li>
</ul>
</li>
<li><strong>排查前端</strong>：<ul>
<li>看请求是否正确发出。</li>
<li>参数是否正确传递。</li>
</ul>
</li>
<li><strong>排查后端</strong>：<ul>
<li>查看日志（支付回调、订单生成流程）。</li>
<li>是否卡在消息队列 &#x2F; 数据库。</li>
</ul>
</li>
<li><strong>复现Bug</strong>：<ul>
<li>在测试环境复现，确认稳定。</li>
</ul>
</li>
<li><strong>提交Bug</strong>：<ul>
<li>标题：支付成功订单未生成。</li>
<li>复现步骤：支付流程、支付工具。</li>
<li>期望结果：支付成功后生成订单。</li>
<li>实际结果：未生成。</li>
<li>环境信息：测试环境 &#x2F; 生产环境。</li>
<li>附加信息：接口请求&#x2F;响应、日志。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="HTTP-HTTPS-牛客面经八股"><a href="#HTTP-HTTPS-牛客面经八股" class="headerlink" title="HTTP&#x2F;HTTPS-牛客面经八股"></a>HTTP&#x2F;HTTPS-牛客面经八股</h2><p>太好了 ✅，这组题目涉及 <strong>HTTP 协议全家桶</strong>（1.0 → 3.0 演进、状态码、缓存、HTTPS、WebSocket、SSE），是前端&#x2F;后端&#x2F;运维面试的高频考点。我逐个给你讲，保证深入、细节全，既能应对面试，也能真正理解。</p>
<hr>
<h3 id="1、HTTP-1-0、HTTP-1-1、HTTP-2-0、HTTP-3-0-的区别？"><a href="#1、HTTP-1-0、HTTP-1-1、HTTP-2-0、HTTP-3-0-的区别？" class="headerlink" title="1、HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2.0、HTTP&#x2F;3.0 的区别？"></a><strong>1、HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2.0、HTTP&#x2F;3.0 的区别？</strong></h3><ul>
<li><strong>HTTP&#x2F;1.0</strong>（1996）<ul>
<li><strong>短连接</strong>：每次请求都要建立 TCP 连接。</li>
<li>只支持 <code>GET/POST/HEAD</code> 方法。</li>
<li>缺少 Host 头，不支持虚拟主机。</li>
</ul>
</li>
<li><strong>HTTP&#x2F;1.1</strong>（1999）<ul>
<li><strong>长连接（Connection: keep-alive）</strong>，复用 TCP。</li>
<li>新增方法：<code>PUT/DELETE/OPTIONS</code>。</li>
<li>支持 <strong>管道化（Pipelining）</strong>，但容易队头阻塞。</li>
<li><strong>缓存控制</strong>：<code>Cache-Control</code>。</li>
</ul>
</li>
<li><strong>HTTP&#x2F;2.0</strong>（2015，基于 SPDY）<ul>
<li><strong>二进制分帧</strong>，效率更高。</li>
<li><strong>多路复用</strong>：一个 TCP 连接上并发多个请求，解决队头阻塞（但仍受 TCP 队头阻塞影响）。</li>
<li><strong>头部压缩（HPACK）</strong>，减少带宽。</li>
<li><strong>服务端推送</strong>。</li>
</ul>
</li>
<li><strong>HTTP&#x2F;3.0</strong>（2022，基于 QUIC&#x2F;UDP）<ul>
<li><strong>QUIC 协议（UDP + TLS 1.3）</strong>，彻底解决 TCP 队头阻塞。</li>
<li>连接迁移（换 IP 也不中断）。</li>
<li>更快的握手（1-RTT &#x2F; 0-RTT）。</li>
</ul>
</li>
</ul>
<p>👉 总结：<strong>1.0 短连接 → 1.1 长连接 → 2.0 多路复用 → 3.0 基于 UDP。</strong></p>
<hr>
<h3 id="2、HTTP-常见状态码有哪些？"><a href="#2、HTTP-常见状态码有哪些？" class="headerlink" title="2、HTTP 常见状态码有哪些？"></a><strong>2、HTTP 常见状态码有哪些？</strong></h3><ul>
<li><strong>1xx</strong>：信息（100 Continue）</li>
<li><strong>2xx</strong>：成功（200 OK，201 Created，204 No Content）</li>
<li><strong>3xx</strong>：重定向（301 永久，302 临时，304 Not Modified）</li>
<li><strong>4xx</strong>：客户端错误（400 Bad Request，401 Unauthorized，403 Forbidden，404 Not Found，405 Method Not Allowed）</li>
<li><strong>5xx</strong>：服务端错误（500 Internal Server Error，502 Bad Gateway，503 Service Unavailable，504 Gateway Timeout）</li>
</ul>
<hr>
<h3 id="3、HTTP-请求头中到底包含什么？"><a href="#3、HTTP-请求头中到底包含什么？" class="headerlink" title="3、HTTP 请求头中到底包含什么？"></a><strong>3、HTTP 请求头中到底包含什么？</strong></h3><p>常见请求头分为几类：</p>
<ul>
<li><strong>通用头</strong>：<code>Date</code>，<code>Connection</code></li>
<li><strong>请求头</strong>：<code>Host</code>，<code>User-Agent</code>，<code>Accept</code>，<code>Referer</code>，<code>Cookie</code></li>
<li><strong>响应头</strong>：<code>Server</code>，<code>Set-Cookie</code>，<code>Location</code></li>
<li><strong>实体头</strong>：<code>Content-Type</code>，<code>Content-Length</code>，<code>Content-Encoding</code></li>
</ul>
<hr>
<h3 id="4、HTTP-是基于-TCP-还是-UDP？"><a href="#4、HTTP-是基于-TCP-还是-UDP？" class="headerlink" title="4、HTTP 是基于 TCP 还是 UDP？"></a><strong>4、HTTP 是基于 TCP 还是 UDP？</strong></h3><ul>
<li><strong>HTTP&#x2F;1.0 &amp; HTTP&#x2F;1.1 &amp; HTTP&#x2F;2.0 → 基于 TCP</strong></li>
<li><strong>HTTP&#x2F;3.0 → 基于 QUIC（UDP）</strong><br> 👉 所以，HTTP <strong>主要基于 TCP</strong>，但最新版本用 UDP。</li>
</ul>
<hr>
<h3 id="5、HTTP-常见字段有哪些？"><a href="#5、HTTP-常见字段有哪些？" class="headerlink" title="5、HTTP 常见字段有哪些？"></a><strong>5、HTTP 常见字段有哪些？</strong></h3><ul>
<li><strong>缓存相关</strong>：<code>Cache-Control</code>，<code>Expires</code>，<code>ETag</code>，<code>Last-Modified</code></li>
<li><strong>内容相关</strong>：<code>Content-Type</code>，<code>Content-Length</code>，<code>Content-Encoding</code></li>
<li><strong>连接相关</strong>：<code>Connection</code>，<code>Keep-Alive</code></li>
<li><strong>安全相关</strong>：<code>Cookie</code>，<code>Set-Cookie</code>，<code>Authorization</code></li>
</ul>
<hr>
<h3 id="6、HTTP-的缓存机制，服务器如何判断缓存是否过期？"><a href="#6、HTTP-的缓存机制，服务器如何判断缓存是否过期？" class="headerlink" title="6、HTTP 的缓存机制，服务器如何判断缓存是否过期？"></a><strong>6、HTTP 的缓存机制，服务器如何判断缓存是否过期？</strong></h3><ol>
<li><strong>强制缓存（Expires &#x2F; Cache-Control）</strong><ul>
<li><code>Expires: Wed, 21 Oct 2025 07:28:00 GMT</code>（绝对时间）</li>
<li><code>Cache-Control: max-age=3600</code>（相对时间）<br> 👉 未过期 → 直接用本地缓存。</li>
</ul>
</li>
<li><strong>协商缓存（ETag &#x2F; Last-Modified）</strong><ul>
<li><code>ETag</code>（文件唯一标识） → If-None-Match</li>
<li><code>Last-Modified</code> → If-Modified-Since<br> 👉 服务器校验后返回 <strong>304 Not Modified</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="7、HTTP-长连接-vs-短连接的区别是？"><a href="#7、HTTP-长连接-vs-短连接的区别是？" class="headerlink" title="7、HTTP 长连接 vs 短连接的区别是？"></a><strong>7、HTTP 长连接 vs 短连接的区别是？</strong></h3><ul>
<li><strong>短连接（1.0）</strong>：一次请求&#x2F;响应就关闭连接。</li>
<li><strong>长连接（1.1 Keep-Alive）</strong>：多个请求复用一个 TCP 连接，减少握手开销。</li>
</ul>
<hr>
<h3 id="8、从「敲下一个-URL」到「页面出现在屏幕」整条链路全景"><a href="#8、从「敲下一个-URL」到「页面出现在屏幕」整条链路全景" class="headerlink" title="8、从「敲下一个 URL」到「页面出现在屏幕」整条链路全景"></a><strong>8、从「敲下一个 URL」到「页面出现在屏幕」整条链路全景</strong></h3><ol>
<li>浏览器解析 URL，检查缓存（强缓存&#x2F;协商缓存）。</li>
<li>DNS 解析域名 → 得到 IP。</li>
<li>建立 TCP&#x2F;UDP 连接（TLS 握手）。</li>
<li>发送 HTTP 请求。</li>
<li>服务器处理请求，返回响应（HTML&#x2F;CSS&#x2F;JS）。</li>
<li>浏览器解析 HTML，构建 DOM 树、CSSOM 树 → 渲染树。</li>
<li>执行 JS，可能发起 AJAX 请求。</li>
<li>页面渲染到屏幕。</li>
</ol>
<hr>
<h3 id="9、什么是重定向？重定向与请求转发的区别？"><a href="#9、什么是重定向？重定向与请求转发的区别？" class="headerlink" title="9、什么是重定向？重定向与请求转发的区别？"></a><strong>9、什么是重定向？重定向与请求转发的区别？</strong></h3><ul>
<li><strong>重定向（Redirect）</strong>：<ul>
<li>服务器返回 <code>3xx</code>，告诉浏览器去新地址。</li>
<li><strong>二次请求</strong>，地址栏改变。</li>
</ul>
</li>
<li><strong>请求转发（Forward，服务端内部行为）</strong>：<ul>
<li>Web 服务器内部转发到另一个资源。</li>
<li><strong>一次请求</strong>，地址栏不变。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10、GET-与-POST-有什么区别"><a href="#10、GET-与-POST-有什么区别" class="headerlink" title="10、GET 与 POST 有什么区别?"></a><strong>10、GET 与 POST 有什么区别?</strong></h3><h4 id="1-语义（核心区别）"><a href="#1-语义（核心区别）" class="headerlink" title="1. 语义（核心区别）"></a>1. <strong>语义（核心区别）</strong></h4><ul>
<li><strong>GET</strong>：获取资源<ul>
<li>语义上用于“查询 &#x2F; 读取”资源，不会修改服务器状态。</li>
<li>要求是<strong>幂等</strong>（多次请求结果一样）和<strong>安全</strong>（不会改变数据）。</li>
</ul>
</li>
<li><strong>POST</strong>：提交资源<ul>
<li>语义上用于“新增 &#x2F; 修改”资源，会对服务器状态造成影响。</li>
<li>通常<strong>非幂等</strong>（多次提交会重复写入数据）。</li>
</ul>
</li>
</ul>
<p>👉 <strong>面试回答点</strong>：<br> HTTP 语义层面，GET 与 POST 的区别远大于“参数放在 URL 还是 Body”，核心是幂等性与安全性。</p>
<hr>
<h4 id="2-参数传递方式"><a href="#2-参数传递方式" class="headerlink" title="2. 参数传递方式"></a>2. <strong>参数传递方式</strong></h4><ul>
<li><strong>GET</strong><ul>
<li>参数拼接在 <strong>URL</strong>，格式为 <code>?key=value&amp;key2=value2</code>。</li>
<li><strong>长度限制</strong>：HTTP 协议本身无限制，但 <strong>浏览器 &#x2F; 服务器 &#x2F; 代理</strong> 一般限制在 2KB ~ 8KB。</li>
<li>适合少量参数、查询条件。</li>
</ul>
</li>
<li><strong>POST</strong><ul>
<li>参数放在 <strong>请求体 (Body)</strong>，理论上无限制，适合大数据提交。</li>
<li>但部分服务器或代理仍会限制 Body 大小（通常在 2MB ~ 50MB）。</li>
</ul>
</li>
</ul>
<p>👉 <strong>总结</strong>：GET 传输小数据（查询），POST 传输大数据（表单、文件）。</p>
<hr>
<h4 id="3-缓存机制"><a href="#3-缓存机制" class="headerlink" title="3. 缓存机制"></a>3. <strong>缓存机制</strong></h4><ul>
<li><strong>GET</strong><ul>
<li>天生支持缓存：浏览器、CDN、代理服务器可缓存 GET 请求结果。</li>
<li>结合 <strong>Etag、Last-Modified、Cache-Control</strong> 等头部，减少重复请求。</li>
</ul>
</li>
<li><strong>POST</strong><ul>
<li>默认<strong>不缓存</strong>，每次都会提交到服务器。</li>
<li>可以强行配置缓存（但很少这样做）。</li>
</ul>
</li>
</ul>
<p>👉 <strong>考点</strong>：为什么搜索接口一般用 GET？——为了利用浏览器 &#x2F; CDN 缓存，提高性能。</p>
<hr>
<h4 id="4-安全性"><a href="#4-安全性" class="headerlink" title="4. 安全性"></a>4. <strong>安全性</strong></h4><ul>
<li><strong>GET</strong><ul>
<li>参数暴露在 URL，可能被浏览器历史记录、日志、书签记录。</li>
<li>不适合传输敏感信息（密码、token）。</li>
</ul>
</li>
<li><strong>POST</strong><ul>
<li>参数在请求体里，不会出现在 URL，但仍然可能被抓包工具获取。</li>
<li>只是<strong>安全性略好</strong>，并不是绝对安全。</li>
<li>真正安全要依赖 <strong>HTTPS 加密传输</strong>。</li>
</ul>
</li>
</ul>
<p>👉 面试时要强调：<strong>GET 和 POST 安全性本质上没有区别，安全取决于 HTTPS，而不是请求方法。</strong></p>
<hr>
<h4 id="5-性能与-TCP-层面"><a href="#5-性能与-TCP-层面" class="headerlink" title="5. 性能与 TCP 层面"></a>5. <strong>性能与 TCP 层面</strong></h4><ul>
<li><strong>TCP 层面</strong>：<ul>
<li>GET 与 POST <strong>底层都是 TCP</strong>，没有性能差异。</li>
<li>区别只在于 <strong>请求格式</strong> 和 <strong>浏览器处理</strong>。</li>
</ul>
</li>
<li><strong>性能差异的根源</strong>：<ul>
<li><strong>GET</strong> 请求更容易被缓存，性能更高。</li>
<li><strong>POST</strong> 请求每次都要到服务器处理，性能稍差。</li>
</ul>
</li>
</ul>
<p>👉 <strong>面试陷阱</strong>：有人说“POST 会比 GET 多一次 TCP 握手”其实是 <strong>误解</strong>。</p>
<ul>
<li>事实是：<strong>HTTP&#x2F;1.1 默认长连接</strong>，不会重复握手。</li>
</ul>
<hr>
<h4 id="6-应用场景"><a href="#6-应用场景" class="headerlink" title="6. 应用场景"></a>6. <strong>应用场景</strong></h4><ul>
<li><strong>GET</strong><ul>
<li>查询数据、获取资源（如搜索、文章详情）。</li>
<li>可被书签保存，可直接分享 URL。</li>
</ul>
</li>
<li><strong>POST</strong><ul>
<li>提交数据（如表单提交、文件上传、支付下单）。</li>
<li>需要传输复杂或大量数据。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="🔑-面试高频总结回答"><a href="#🔑-面试高频总结回答" class="headerlink" title="🔑 面试高频总结回答"></a><strong>🔑 面试高频总结回答</strong></h4><blockquote>
<p><strong>面试官常问：“GET 和 POST 有什么区别？” 你</strong>可以这样答：</p>
</blockquote>
<ol>
<li><strong>语义不同</strong>：GET 用于获取资源（幂等、安全），POST 用于提交资源（非幂等）。</li>
<li><strong>参数传递不同</strong>：GET 参数在 URL，有长度限制；POST 在 Body，适合大数据。</li>
<li><strong>缓存机制</strong>：GET 默认可缓存，POST 默认不缓存。</li>
<li><strong>安全性</strong>：GET 参数暴露在 URL，POST 参数在 Body，安全性稍高，但真正安全要靠 HTTPS。</li>
<li><strong>性能</strong>：底层都是 TCP，无本质性能差异，GET 主要因缓存而更快。</li>
<li><strong>应用场景</strong>：GET 用于查询，POST 用于提交和修改数据。</li>
</ol>
<hr>
<h3 id="11、HTTP-vs-HTTPS-有什么区别"><a href="#11、HTTP-vs-HTTPS-有什么区别" class="headerlink" title="11、HTTP vs. HTTPS 有什么区别?"></a><strong>11、HTTP vs. HTTPS 有什么区别?</strong></h3><ul>
<li><strong>HTTP</strong>：明文传输，不安全。</li>
<li><strong>HTTPS</strong>：HTTP + TLS&#x2F;SSL，数据加密。</li>
<li><strong>区别</strong>：<ul>
<li>端口不同（80 vs 443）。</li>
<li>HTTPS 需要证书。</li>
<li>HTTPS 有握手过程，性能略低。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="12、HTTPS-的「秘钥交换-证书校验」全流程"><a href="#12、HTTPS-的「秘钥交换-证书校验」全流程" class="headerlink" title="12、HTTPS 的「秘钥交换 + 证书校验」全流程"></a><strong>12、HTTPS 的「秘钥交换 + 证书校验」全流程</strong></h3><ol>
<li>浏览器请求 HTTPS 网站。</li>
<li>服务器返回 <strong>证书（包含公钥 + 签名）</strong>。</li>
<li>浏览器验证证书合法性（CA 签发、域名匹配、未过期）。</li>
<li>客户端生成 <strong>随机对称密钥</strong>，用服务器公钥加密，发给服务器。</li>
<li>服务器用私钥解密，得到对称密钥。</li>
<li>后续通信用 <strong>对称加密</strong>（AES）。</li>
</ol>
<hr>
<h3 id="13、HTTPS（TLS）里都用到了哪些加密算法？"><a href="#13、HTTPS（TLS）里都用到了哪些加密算法？" class="headerlink" title="13、HTTPS（TLS）里都用到了哪些加密算法？"></a><strong>13、HTTPS（TLS）里都用到了哪些加密算法？</strong></h3><ul>
<li><strong>对称加密</strong>：AES、ChaCha20（数据加密）。</li>
<li><strong>非对称加密</strong>：RSA、ECC（秘钥交换）。</li>
<li><strong>摘要算法</strong>：SHA-256（完整性校验）。</li>
<li><strong>数字签名</strong>：RSA-SHA256 &#x2F; ECDSA。</li>
</ul>
<hr>
<h3 id="14、WebSocket-简介-与-HTTP-的核心区别"><a href="#14、WebSocket-简介-与-HTTP-的核心区别" class="headerlink" title="14、WebSocket 简介 &amp; 与 HTTP 的核心区别"></a><strong>14、WebSocket 简介 &amp; 与 HTTP 的核心区别</strong></h3><ul>
<li><strong>WebSocket</strong>：全双工通信协议，运行在 TCP 之上。</li>
<li><strong>与 HTTP 的区别</strong>：<ul>
<li>HTTP 是 <strong>请求-响应模式</strong>。</li>
<li>WebSocket 是 <strong>双向通信</strong>，服务端可主动推送数据。</li>
<li>建立时通过 HTTP <strong>Upgrade</strong> 头，从 HTTP 升级为 WebSocket。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="15、WebSocket-的工作过程是什么样的？"><a href="#15、WebSocket-的工作过程是什么样的？" class="headerlink" title="15、WebSocket 的工作过程是什么样的？"></a><strong>15、WebSocket 的工作过程是什么样的？</strong></h3><ol>
<li>客户端发起 HTTP 请求，带 <code>Upgrade: websocket</code>。</li>
<li>服务器同意，返回 101 Switching Protocols。</li>
<li>双方升级为 WebSocket 协议，保持 TCP 长连接。</li>
<li>客户端 &amp; 服务端可以互相发送消息（Text&#x2F;Binary Frame）。</li>
</ol>
<hr>
<h3 id="16、SSE（Server-Sent-Events）与-WebSocket-有什么区别"><a href="#16、SSE（Server-Sent-Events）与-WebSocket-有什么区别" class="headerlink" title="16、SSE（Server-Sent Events）与 WebSocket 有什么区别?"></a><strong>16、SSE（Server-Sent Events）与 WebSocket 有什么区别?</strong></h3><ul>
<li><strong>SSE</strong>（服务器推送事件）：<ul>
<li>基于 HTTP 协议。</li>
<li>单向：服务器 → 客户端。</li>
<li>适合实时数据推送（股票、消息提醒）。</li>
</ul>
</li>
<li><strong>WebSocket</strong>：<ul>
<li>独立协议。</li>
<li>双向通信（客户端 &amp; 服务端都能主动发送）。</li>
<li>适合聊天室、在线游戏。</li>
</ul>
</li>
</ul>
<p>👉 <strong>总结</strong>：</p>
<ul>
<li><strong>SSE</strong>：轻量级，单向推送。</li>
<li><strong>WebSocket</strong>：强大，双向通信。</li>
</ul>
<hr>
<h2 id="分布式-牛客面经八股"><a href="#分布式-牛客面经八股" class="headerlink" title="分布式-牛客面经八股"></a>分布式-牛客面经八股</h2><hr>
<h3 id="1-缓存穿透-缓存击穿-缓存雪崩-—-区别与防护"><a href="#1-缓存穿透-缓存击穿-缓存雪崩-—-区别与防护" class="headerlink" title="1. 缓存穿透 &#x2F; 缓存击穿 &#x2F; 缓存雪崩 — 区别与防护"></a><strong>1. 缓存穿透 &#x2F; 缓存击穿 &#x2F; 缓存雪崩 — 区别与防护</strong></h3><ul>
<li><p><strong>定义</strong></p>
<ul>
<li><strong>缓存穿透</strong>：请求查询的 key 在缓存未命中且数据库也不存在（或是恶意请求大量不存在 key），导致大量请求直接打到 DB。</li>
<li><strong>缓存击穿</strong>（又称 cache breakdown）：某个热点 key 的缓存过期或被淘汰，短时间内大量并发请求同时去读 DB，造成 DB 峰值压力。</li>
<li><strong>缓存雪崩</strong>：缓存层在短时间内大量 key 同时失效（例如同一 TTL 或重启导致），整体流量穿透到 DB，造成服务雪崩。</li>
</ul>
</li>
<li><p><strong>防护策略（实战）</strong></p>
<ul>
<li><strong>穿透</strong>：<ul>
<li>使用 <strong>布隆过滤器</strong> 预过滤不存在的 key（内存小、允许一定误报），把合法 key 的集合放入布隆过滤器。</li>
<li>对不存在的结果做 <strong>负缓存（empty cache）</strong>：把空结果也缓存，但 TTL 较短（例如 30s~5min），避免无限缓存错误数据。注意 TTL 应短且带随机抖动避免同时过期。</li>
</ul>
</li>
<li><strong>击穿</strong>：<ul>
<li>使用 <strong>互斥锁 &#x2F; singleflight</strong>：一个请求去 DB 构建缓存，其他请求等待或返回旧值；例如 Redis 的 <code>SETNX</code> + value-token + Lua 验证释放锁。</li>
<li><strong>提前重建 &#x2F; 热点预热</strong>：对已知热点提前刷新或延长 TTL。</li>
<li>使用 <strong>永不过期缓存 + 后台刷新</strong>（主动刷新策略）。</li>
</ul>
</li>
<li><strong>雪崩</strong>：<ul>
<li>给 TTL 加 <strong>随机抖动</strong>（使 key 不会同一时刻失效）。</li>
<li>限制缓存穿透到 DB 的 QPS（熔断&#x2F;降级、限流）。</li>
<li>多级缓存（本地 + 分布式）与冷备（备用 DB 副本、读副本）。</li>
<li>Cache warming（重启后先行预热重要 key）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实现要点 &#x2F; 伪代码</strong></p>
<ul>
<li><p>负缓存示例（伪）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">val = redis.get(key)</span><br><span class="line">if val != null:</span><br><span class="line">  if val == &quot;__EMPTY__&quot;:</span><br><span class="line">    return 404</span><br><span class="line">  return val</span><br><span class="line">// miss</span><br><span class="line">lock = redis.set(&quot;lock:&quot;+key, uuid, NX, PX, 30000)</span><br><span class="line">if lock:</span><br><span class="line">  val = db.query(key)</span><br><span class="line">  if val:</span><br><span class="line">    redis.set(key, val, TTL)</span><br><span class="line">  else:</span><br><span class="line">    redis.set(key, &quot;__EMPTY__&quot;, shortTTL)</span><br><span class="line">  redis.del(&quot;lock:&quot;+key)</span><br><span class="line">  return val</span><br><span class="line">else:</span><br><span class="line">  sleep(50ms) // 或者等待 singleflight 返回</span><br><span class="line">  retry get from cache</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>常见面试追问</strong>：布隆误报率如何计算？NX+PX 的锁为什么还要校验 value？为什么负缓存 TTL 要短？singleflight 的实现细节。</p>
</li>
</ul>
<hr>
<h3 id="2-Redis-与数据库保持双写一致性的常见方案（权衡与实现）"><a href="#2-Redis-与数据库保持双写一致性的常见方案（权衡与实现）" class="headerlink" title="2. Redis 与数据库保持双写一致性的常见方案（权衡与实现）"></a><strong>2. Redis 与数据库保持双写一致性的常见方案（权衡与实现）</strong></h3><ul>
<li><strong>几类常见模式</strong><ul>
<li><strong>Cache-Aside（旁路缓存）</strong>（最常见）<ul>
<li>应用先读缓存（miss 去 DB 并回填缓存）；写操作先写 DB，再删除&#x2F;更新缓存（delete-then-write 或 write-then-delete 都有争议）。</li>
</ul>
</li>
<li><strong>Write-Through &#x2F; Read-Through</strong><ul>
<li>Write-through：应用写缓存，由缓存层负责同步写 DB（同步或异步）。优点：简单的一致性模型；缺点：写延迟高或缓存写失败复杂。</li>
<li>Read-through：缓存 miss 自动去 DB 并回填（由 cache 框架处理）。</li>
</ul>
</li>
<li><strong>Write-Behind（异步回写）</strong><ul>
<li>写入缓存并异步写入 DB（高吞吐但风险：崩溃可能丢数据）。</li>
</ul>
</li>
<li><strong>消息队列 + Eventual Consistency（推荐在分布式系统中）</strong><ul>
<li>写 DB -&gt; 产生事件（消息） -&gt; 异步消费者更新&#x2F;失效缓存。或写 DB 后删除 cache，再通过队列异步再次确认&#x2F;回写。</li>
</ul>
</li>
</ul>
</li>
<li><strong>常见一致性问题（race 条件）</strong><ul>
<li>写 DB 后竞争：A 写 DB 并删除缓存；B 并发读 DB 后写回旧值到缓存（导致缓存旧数据）。解决方法：<ul>
<li><strong>操作顺序</strong>：常见做法是 <code>DB write</code> -&gt; <code>delete cache</code>，但需要加锁或使用版本号&#x2F;时间戳来避免竞态。</li>
<li><strong>利用消息队列</strong>：DB 写完成后发消息，消费者串行&#x2F;有序地更新缓存或删除；保证缓存更新顺序。</li>
<li><strong>带版本号的数据</strong>：在缓存中存入版本号或时间戳，写入时比较版本仅写入更新的值。</li>
<li><strong>分布式锁</strong>：在更新缓存&#x2F;DB 时获得锁，防止并发回写旧数据（但影响并发性能）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>推荐实践</strong><ul>
<li>优先采用 <strong>Cache-Aside + 消息队列</strong>：对写操作先写 DB，产生日志&#x2F;事件，缓存由消费者异步处理（保证最终一致）。读路径仍是先缓存。</li>
<li>对强一致性要求极高的场景考虑 <strong>数据库为主、缓存为辅</strong>（或使用 DB 的二级索引、Materialized View）。</li>
<li>使用 <strong>幂等、重试与版本控制</strong> 来降低竞态带来的不一致风险。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-布隆过滤器（Bloom-Filter）原理、公式、变体与实战"><a href="#3-布隆过滤器（Bloom-Filter）原理、公式、变体与实战" class="headerlink" title="3. 布隆过滤器（Bloom Filter）原理、公式、变体与实战"></a><strong>3. 布隆过滤器（Bloom Filter）原理、公式、变体与实战</strong></h3><ul>
<li><p><strong>基本原理</strong></p>
<ul>
<li>使用一段位数组（m 位）和 k 个独立哈希函数。添加元素时对 k 个哈希位设为 1；查询时检查对应的 k 个位是否都为 1。如果有位为 0，则肯定不存在（无假阴性）。若全部为 1，说明“可能存在”（存在假阳性）。</li>
</ul>
</li>
<li><p><strong>关键公式</strong></p>
<ul>
<li><p>在插入 n 个元素，使用 m 位和 k 个哈希下，假阳性率近似为：<br>$$<br>p \approx \left(1 - e^{-kn&#x2F;m}\right)^k<br>$$</p>
</li>
<li><p>最优 k（使 p 最小）约等于 </p>
<p>$$<br>(k &#x3D; \frac{m}{n} \ln 2)<br>$$<br>。</p>
</li>
</ul>
</li>
<li><p><strong>变体</strong></p>
<ul>
<li><strong>Counting Bloom Filter</strong>：计数器代替位数组，支持删除（通过减计数），但内存大。</li>
<li><strong>Scalable Bloom Filter</strong>：当元素增长时，动态增加子过滤器来控制误报率。</li>
<li><strong>Partitioned Bloom &#x2F; Blocked Bloom</strong>：减少缓存行冲突、提高并发性能。</li>
</ul>
</li>
<li><p><strong>实现与应用</strong></p>
<ul>
<li>常用于：缓存穿透防护、数据库去重、web 去重、分布式系统快速判断存在性。</li>
<li><strong>实现注意</strong>：哈希函数必须分布均匀、独立（可用双哈希技术衍生多个哈希）。</li>
</ul>
</li>
<li><p><strong>示例（伪）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="number">10_000_000</span></span><br><span class="line">k = <span class="number">7</span></span><br><span class="line">bitarray = [<span class="number">0</span>]*m</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">    idx = hash_i(x, i) % m</span><br><span class="line">    bitarray[idx] = <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">might_contain</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">    <span class="keyword">if</span> bitarray[hash_i(x,i)%m] == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>面试追问</strong>：如何选择 m,k？怎样在分布式环境共享布隆过滤器（位图分片、Redis bitmap）？</p>
</li>
</ul>
<hr>
<p><strong>4. 消息队列如何保证顺序消费？（策略与代价）</strong></p>
<ul>
<li><strong>保证顺序的基本思路</strong><ul>
<li>顺序消费需要对一组相关消息在单一顺序流（partition&#x2F;queue）中处理：<strong>把同 key 的消息映射到同一个分区&#x2F;队列</strong>，并由该 partition 的单一消费者或单线程序列化消费。</li>
</ul>
</li>
<li><strong>常见实现</strong><ul>
<li><strong>Kafka</strong>：按 <code>key</code> 分区，单个 partition 内消息有序；由同一 consumer instance 顺序消费（注意重平衡时可能短暂中断）。</li>
<li><strong>RabbitMQ</strong> &#x2F; 传统队列：把相关消息放在同一队列，由单一消费者顺序消费（但单一消费者可能成为瓶颈）。</li>
<li><strong>SQS FIFO</strong>：提供 <code>MessageGroupId</code> 保证组内顺序。</li>
</ul>
</li>
<li><strong>要点与陷阱</strong><ul>
<li>顺序与吞吐量冲突：单 partition&#x2F;单消费者限制吞吐量；为兼顾吞吐需要分 key 粒度切分。</li>
<li>消费失败与重试：若失败导致重复消费或延迟，会影响全局顺序（需要 careful 设计，如顺序重试队列或把失败消息单独挪出）。</li>
<li>消费者水平扩展时要保持 key 到 partition 的映射稳定（避免重分区导致不必要的重新排序）。</li>
</ul>
</li>
<li><strong>实践建议</strong><ul>
<li>分配合适的 partition 数量与 key 设计（热点 key 可能成为瓶颈）。</li>
<li>对需要严格全局顺序的场景（较少）考虑单线程处理或全局序列号系统。</li>
<li>使用幂等消费逻辑与事务&#x2F;offset 管理保证在重试时仍能正确处理。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>5. 消息队列如何保证消息不丢？（持久化、复制、ACK）</strong></p>
<ul>
<li><strong>关键机制</strong><ul>
<li><strong>持久化（durable）</strong>：消息写入磁盘（或持久日志），即使 Broker 重启消息仍在。</li>
<li><strong>副本&#x2F;复制</strong>：将消息复制到多个 broker 节点（例如 Kafka 的 ISR），至少写入多数副本才算成功（降低单点丢失）。</li>
<li><strong>确认机制（ACK）</strong>：消费者处理后返回 ACK；Broker 在确认后才删除消息（或提交 offset）。</li>
<li><strong>重试与死信队列（DLQ）</strong>：失败的消息重试若超过阈值发往 DLQ。</li>
<li><strong>事务&#x2F;幂等生产者</strong>：保证生产端的重复发送不会丢或重复计数（Kafka 的幂等 producer + transactional）。</li>
</ul>
</li>
<li><strong>系统参数（以 Kafka 为例）</strong><ul>
<li><code>acks=all</code>（生产者要求 leader 等待 ISR 中多数副本确认）</li>
<li><code>min.insync.replicas</code>（要求写入的最小同步副本数）</li>
<li><code>replication.factor</code>（副本数）</li>
</ul>
</li>
<li><strong>设计权衡</strong><ul>
<li>更高的持久性 → 写延迟上升、吞吐下降。</li>
<li>同步复制 vs 异步复制的选择：异步快但有丢数据风险。</li>
</ul>
</li>
<li><strong>实战建议</strong><ul>
<li>对关键数据启用同步复制、持久化、且配置合适的 <code>min.insync.replicas</code>。</li>
<li>使用事务&#x2F;幂等保证端到端一致性（当需要 exactly-once 或低丢失）。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>6. 消息队列如何保证不重复消费？（幂等、去重、事务）</strong></p>
<ul>
<li><p><strong>常见目标与模式</strong></p>
<ul>
<li>通常消息传递模型是 <strong>at-least-once</strong>（可能重复），需要消费者保证幂等或使用外部去重。</li>
</ul>
</li>
<li><p><strong>实现方法</strong></p>
<ul>
<li><strong>幂等处理</strong>：业务操作本身设计为幂等（例如使用 PUT 替代增量操作，或根据消息 id 做一次性处理）。</li>
<li><strong>去重表（Dedup store）</strong>：消费者在处理消息前检查消息 ID（例如 <code>msgId</code> 存入 Redis&#x2F;DB 的集合&#x2F;表），若已存在则跳过。需要 TTL 或清理策略。</li>
<li><strong>事务性写入 + 提交 offset 的原子性</strong>（exactly-once）：<ul>
<li>Kafka 提供事务 API：消费者读取、处理并把结果写回 Kafka，再原子提交 offset（实现端到端 exactly-once 在一定场景下）。</li>
<li><strong>Outbox Pattern</strong>：在 DB 事务中把消息写入 outbox 表，事务提交后异步将 outbox 的消息发到消息队列；消费者消费幂等写入到 DB。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复杂性与代价</strong></p>
<ul>
<li>去重存储是状态式，可能成为瓶颈；需要高性能的去重存储（Redis、Cassandra）。</li>
<li>完全 exactly-once 跨服务极难，通常用幂等+去重+事务组合来实现近似 exactly-once。</li>
</ul>
</li>
<li><p><strong>示例（伪）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if redis.sismember(&quot;processed&quot;, msg.id):</span><br><span class="line">    ack and return</span><br><span class="line">process business</span><br><span class="line">record = db.write(...)</span><br><span class="line">redis.sadd(&quot;processed&quot;, msg.id); set TTL</span><br><span class="line">ack</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>7. 消息队列：Push（推）与 Pull（拉）使用场景对比</strong></p>
<ul>
<li><strong>Push（Broker 推送到 Consumer）</strong><ul>
<li>优点：低延迟、实现简单（事件驱动），适用于消费端能快速处理或有背压机制的场景；常见于 RabbitMQ（broker push 模式）、webhooks。</li>
<li>缺点：消费者容易被突发流量压垮（需要流量控制、限速、QoS）。</li>
<li>场景：实时通知、webhook、低延迟实时事件。</li>
</ul>
</li>
<li><strong>Pull（Consumer 拉取消息）</strong><ul>
<li>优点：消费者控制消费速率（自然背压），易于扩展消费者并发；适合高吞吐、批量处理场景。常见于 Kafka、SQS。</li>
<li>缺点：拉取轮询或长轮询会增加实现复杂度、延迟稍高。</li>
<li>场景：日志收集、大数据批量处理、消费者需要控制批量大小或处理速度（例如按窗口消费）。</li>
</ul>
</li>
<li><strong>混合&#x2F;折中</strong><ul>
<li>长轮询（SQS long polling）或 push + client-side window 控制提供折中方案。</li>
<li>Broker 可以根据 consumer 的能力调整推送速率（Flow control &#x2F; QoS）。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>8. 分布式锁：原理与常见实现</strong></p>
<ul>
<li><p><strong>核心目标</strong>：在分布式环境下对共享资源做互斥控制（同一时刻只有一个客户端持有锁）。</p>
</li>
<li><p><strong>常见实现方式</strong></p>
<ul>
<li><strong>Redis + SET NX PX</strong>：<ul>
<li><code>SET key value NX PX ttl</code>：原子取得锁并设置超时，释放锁需检查 value（防止误删别人的锁）。</li>
<li>释放锁用 Lua 脚本保证原子性（先比较 value，再删除）。</li>
</ul>
</li>
<li><strong>RedLock</strong>（多 Redis 实例交叉锁定）：<ul>
<li>在多个独立 Redis 节点上尝试加锁，过半成功则认为获得锁；争议：理论上在网络分区下可能不安全，需谨慎使用。</li>
</ul>
</li>
<li><strong>Zookeeper</strong>：<ul>
<li>使用临时顺序节点（ephemeral sequential）实现锁，节点删除或会话断开时自动释放锁；ZK 提供强一致性（推荐用于强一致性场景）。</li>
</ul>
</li>
<li><strong>etcd &#x2F; Consul</strong>：<ul>
<li>基于 Lease + Compare-And-Swap（CAS）实现，且有自动延续 lease 的机制。</li>
</ul>
</li>
<li><strong>数据库行锁</strong>（SELECT … FOR UPDATE &#x2F; update with condition）：<ul>
<li>简单但可能影响 DB 性能，适用于不高并发或已有 DB 保证版场景。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意点</strong></p>
<ul>
<li>锁超时要合理，避免持有锁的客户端长时间阻塞（但若过短又可能被误抢）。</li>
<li>锁的可重入、可续租（renew）、可释放性设计。</li>
<li>要保证释放锁的操作是原子且只释放自己的锁（比较 value）。</li>
</ul>
</li>
<li><p><strong>示例：Redis 释放 Lua（伪）</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>面试追问</strong>：RedLock 的争议是什么？为什么 ZK&#x2F;etcd 更安全（因为它们使用强一致的 consensus）？</p>
</li>
</ul>
<hr>
<p><strong>9. 分布式事务与常见解决方案</strong></p>
<ul>
<li><strong>问题定义</strong>：跨多个服务 &#x2F; 数据源的事务一致性（ACID）难以直接用单体数据库事务保证。</li>
<li><strong>常见方案</strong><ul>
<li><strong>2PC（Two-Phase Commit）</strong>：<ul>
<li>协调者先询问参与者是否准备提交（prepare），若都准备则提交（commit）；问题：阻塞、实现复杂、对性能影响大。</li>
</ul>
</li>
<li><strong>3PC（Three-Phase Commit）</strong>：在 2PC 基础上缓解阻塞，但复杂性更高，实际少用。</li>
<li><strong>Saga 模式</strong>（推荐）：<ul>
<li>把一个长事务拆成多个本地事务，各自提交并通过补偿事务回滚（两类实现：choreography（事件驱动）或 orchestration（集中编排器））。</li>
<li>优点：无全局锁、易扩展；缺点：实现补偿逻辑复杂、最终一致性而非强一致。</li>
</ul>
</li>
<li><strong>TCC（Try-Confirm-Cancel）</strong>：<ul>
<li>三阶段：try（资源预留），confirm（实际提交），cancel（回滚）。适合需要明确资源预占的场景。</li>
</ul>
</li>
<li><strong>Outbox Pattern + Message Relay &#x2F; CDC</strong>：<ul>
<li>在本地 DB 事务中写入业务数据 + outbox 表（原子），事务提交后异步把 outbox 发送给消息总线，其他服务消费。避免消息丢失与跨服务事务问题。</li>
</ul>
</li>
<li><strong>基于事件驱动的最终一致性</strong>：事件来源（event sourcing）+消费端对事件进行处理。</li>
</ul>
</li>
<li><strong>选择标准</strong><ul>
<li>强一致性 vs 可用性权衡：业务是否能容忍最终一致性？</li>
<li>复杂度和运维成本：2PC 很难扩展到微服务环境，Saga&#x2F;Outbox 更现实。</li>
</ul>
</li>
<li><strong>面试追问</strong>：如何保证 Saga 的补偿能成功？如何处理补偿失败（人工干预&#x2F;补偿队列）？</li>
</ul>
<hr>
<p><strong>10. CAP 理论（与扩展 PACELC）</strong></p>
<ul>
<li><strong>CAP 三要素</strong><ul>
<li><strong>Consistency（一致性）</strong>：所有节点在同一时间看到相同数据（读到最新写入）。</li>
<li><strong>Availability（可用性）</strong>：每个请求都能在有限时间内得到成功或失败响应（系统持续可用）。</li>
<li><strong>Partition tolerance（分区容忍性）</strong>：系统在出现网络分区（分节点间通信失败）下仍可继续运行。</li>
</ul>
</li>
<li><strong>定理结论</strong>：在网络分区发生时，分布式系统只能在一致性（C）和可用性（A）间做权衡（只能保证其中之一 + partition）。</li>
<li><strong>现实系统的取舍</strong><ul>
<li><strong>CP 系统</strong>（优先一致性）：例如 HBase 在分区期选择不可用以保证一致性。</li>
<li><strong>AP 系统</strong>（优先可用性）：例如 Cassandra 在分区期仍提供服务，但数据可能最终一致。</li>
</ul>
</li>
<li><strong>PACELC 扩展</strong><ul>
<li>PACELC：在 Partition（P）发生时在 A 与 C 之间取舍；Else（E）在正常情况下在 Latency（L）和 Consistency（C）之间取舍。</li>
</ul>
</li>
<li><strong>面试要点</strong><ul>
<li>不要直接说某系统“遵循 CAP”，而是说明在何种故障场景选择了哪种折中。</li>
<li>系统常采用复制策略、Quorum 写&#x2F;读策略来在一致性&#x2F;可用性间做灵活配置（例如 quorum 写多数策略）。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>11. 数据库连接池：是什么、为何需要、关键配置项</strong></p>
<ul>
<li><strong>概念</strong>：在应用中维护一组可复用的数据库连接，避免频繁创建&#x2F;销毁连接的开销。</li>
<li><strong>为什么需要</strong><ul>
<li>建立数据库连接开销大（TCP 握手、认证、会话建立）。</li>
<li>限制并发连接数，防止 DB 被过多连接冲垮。</li>
<li>提高性能（连接复用、预热好处），并可缓存 PreparedStatements。</li>
</ul>
</li>
<li><strong>重要配置</strong><ul>
<li><code>maxPoolSize</code>（最大连接数）、<code>minIdle</code>、<code>maxIdle</code>、<code>connectionTimeout</code>、<code>idleTimeout</code>、<code>validationQuery</code>、<code>leakDetectionThreshold</code>。</li>
<li><code>testOnBorrow/testOnReturn</code>（是否在借出&#x2F;归还时检测连接健康）。</li>
</ul>
</li>
<li><strong>实现注意</strong><ul>
<li><strong>连接泄露监测</strong>：若开发者忘记关闭连接需能检测并回收。</li>
<li><strong>事务边界</strong>：确保在事务结束时释放连接（尤其在框架&#x2F;中间件层）。</li>
<li><strong>Pool 与 DB 的匹配</strong>：maxPoolSize 不应超过 DB 能支持的最大并发连接数。</li>
</ul>
</li>
<li><strong>常见连接池实现</strong>：HikariCP（推荐，性能优）、Tomcat JDBC pool、Druid、c3p0。</li>
<li><strong>面试追问</strong>：为什么 <code>maxPoolSize</code> 不能设太大？如何排查连接泄漏？如何检测连接是否活着（validation）？</li>
</ul>
<hr>
<p><strong>12. 一致性哈希（Consistent Hashing）详解</strong></p>
<ul>
<li><strong>问题背景</strong>：节点增删时，如何尽量减少 key 重映射（降低缓存失效带来的重建压力）。</li>
<li><strong>基本机制</strong><ul>
<li>把整个哈希空间想成环（0..2^32-1），每个节点映射到环上的若干位置（虚拟节点 vnodes）。Key 的 hash 决定它在环上的位置，向顺时针找到第一个节点作为该 key 的负责节点。</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>节点加入&#x2F;删除只影响相邻片段的 key（只需迁移少部分 key）。</li>
<li>使用虚拟节点能均衡负载（一个真实节点挂多个 vnode）。</li>
</ul>
</li>
<li><strong>实现要点</strong><ul>
<li>选择稳定且分布均匀的哈希函数（例如 MurmurHash）。</li>
<li>使用足够多的虚拟节点根据节点权重分配（权重高的节点分配更多 vnode）。</li>
<li>支持副本（复制到环上连续的下 k 个 vnode）保证容错。</li>
</ul>
</li>
<li><strong>应用场景</strong><ul>
<li>缓存分片（Memcached&#x2F;Ketama）、分布式存储&#x2F;查找（DHT）。</li>
</ul>
</li>
<li><strong>面试追问</strong>：如何处理节点权重？为什么需要虚拟节点？如何在一致性哈希上做数据迁移？</li>
</ul>
<hr>
<p><strong>13. 负载均衡（LB） — 类型、策略与实现细节</strong></p>
<ul>
<li><strong>分类</strong><ul>
<li><strong>DNS 负载均衡</strong>：把域名解析到多个 IP（粗粒度，受 DNS 缓存影响）。</li>
<li><strong>L4（传输层）负载均衡</strong>：基于 IP&#x2F;端口（如 LVS、Nginx 的 stream 模式）。</li>
<li><strong>L7（应用层）负载均衡</strong>：基于 HTTP 信息（URI、Header、Cookie）做路由（如 Nginx、Envoy、Traefik）。</li>
<li><strong>全局负载均衡（GSLB）</strong>：跨区域&#x2F;数据中心调度。</li>
</ul>
</li>
<li><strong>常见调度算法</strong><ul>
<li>轮询（Round Robin）、加权轮询、最少连接、源地址哈希（IP hash）、一致性哈希、响应时间加权。</li>
</ul>
</li>
<li><strong>功能</strong><ul>
<li>健康检查（主动 probe、被动探测）、会话保持（sticky session）、SSL 终止、速率限制、熔断、路由规则。</li>
</ul>
</li>
<li><strong>实现细节</strong><ul>
<li>健康检查频率、超时和失败阈值设定直接影响可用性和故障转移速度。</li>
<li>粘性会话：通过 cookie 或源 IP 维持会话，但影响水平扩展和容错。</li>
<li>与自动扩缩结合：LB 应感知实例的加入&#x2F;移除（服务发现）。</li>
</ul>
</li>
<li><strong>面试点</strong>：L4 与 L7 的区别、何时使用粘性会话、负载均衡的瓶颈与调优参数（连接池、keepalive）。</li>
</ul>
<hr>
<p><strong>14. 限流算法（详述：Token Bucket, Leaky Bucket, Fixed Window, Sliding Window）</strong></p>
<ul>
<li><strong>Fixed Window（固定窗口计数）</strong><ul>
<li>将时间划分到固定窗口（例如每分钟），用计数器统计请求数。实现简单但边界窗口会导致突发流量（例如窗口末尾+窗口开始）。</li>
</ul>
</li>
<li><strong>Sliding Window Log（滑动窗口日志）</strong><ul>
<li>记录每个请求时间戳，精确但内存消耗大。</li>
</ul>
</li>
<li><strong>Sliding Window Counter（滑动计数器）</strong><ul>
<li>把时间分成多个小桶，近似滑动窗口精度与性能的折中。</li>
</ul>
</li>
<li><strong>Token Bucket（令牌桶）</strong>（常用）<ul>
<li>系统以固定速率向桶中放令牌，消费请求取令牌；允许短时间突发（桶有存量）。</li>
</ul>
</li>
<li><strong>Leaky Bucket（漏桶）</strong><ul>
<li>请求进桶，按恒定速率漏出消费；更偏向平滑输出，抑制突发。</li>
</ul>
</li>
<li><strong>分布式实现</strong><ul>
<li>Redis + 原子脚本（Lua）实现计数与令牌发放，或使用内置限流中间件（Envoy rate limit）。</li>
<li>要保证原子性（避免 race），通常使用 Lua 脚本在 Redis 上实现令牌桶。</li>
</ul>
</li>
<li><strong>示例 Redis Lua（令牌桶思路，伪）</strong><ul>
<li>检查并更新时间戳与令牌计数，返回允许&#x2F;拒绝。</li>
</ul>
</li>
<li><strong>选择建议</strong><ul>
<li>需要短突发能力用 Token Bucket；要求严格平滑输出用 Leaky Bucket；简单限速可用 Fixed Window。</li>
</ul>
</li>
<li><strong>面试追问</strong>：如何在分布式部署下实现全局限流？（使用 centralized Redis、或 local token + periodic refill）</li>
</ul>
<hr>
<p><strong>15. 分布式 ID（生成方案：UUID &#x2F; Snowflake &#x2F; DB sequence &#x2F; Redis）</strong></p>
<ul>
<li><strong>常用方案对比</strong><ul>
<li><strong>UUID</strong>：全局唯一，冲突概率极低，但长度大、不可顺序排序（影响索引）。</li>
<li><strong>Snowflake（Twitter）</strong>：时间戳 + dataCenterId + workerId + sequence —— 有序（按时间近似排序），高吞吐，常见实现。<ul>
<li>优点：有序、短小、可解码（包含时间），高性能。</li>
<li>风险：时间回退会导致 ID 冲突，机器 ID 管理困难，sequence 溢出需要等待下一毫秒。</li>
</ul>
</li>
<li><strong>数据库 Sequence</strong>：简单、强一致（如果用单 DB），但单点与性能受限。</li>
<li><strong>Redis INCR</strong>：高性能、分布式，但跨实例同步与持久性需注意（及分区问题）。</li>
<li><strong>KSUID &#x2F; ULID &#x2F; Sonyflake</strong>：支持排序与更长时间范围的变种。</li>
</ul>
</li>
<li><strong>Snowflake 典型位分配（示例）</strong><ul>
<li>1 bit unused | 41 bits timestamp | 10 bits machine id | 12 bits sequence</li>
</ul>
</li>
<li><strong>实践注意</strong><ul>
<li><strong>时间回退</strong>问题：使用 NTP，要对时钟回退做防护（拒绝、等待或使用逻辑时钟）。</li>
<li><strong>机器 ID 分配</strong>：静态配置或通过注册中心分配；需避免冲突。</li>
<li><strong>高可用</strong>：可使用多个发号服务并保证不同范围&#x2F;前缀来避免冲突。</li>
</ul>
</li>
<li><strong>面试追问</strong>：如何解决 Snowflake 在时钟回退情况下的冲突？如何保证全局唯一与高性能并行发号？</li>
</ul>
<hr>
<p><strong>16. 服务降级与熔断（如何实现、度量与实践）</strong></p>
<ul>
<li><strong>目标</strong>：当下游或某功能异常时，迅速降级&#x2F;保护系统，保证核心功能可用并快速恢复。</li>
<li><strong>常见机制</strong><ul>
<li><strong>超时与重试</strong>：设置合理超时，避免请求挂死。重试配合指数退避。</li>
<li><strong>熔断器（Circuit Breaker）</strong>：典型三态（Closed&#x2F;Open&#x2F;Half-Open）<ul>
<li>当失败率或响应延迟高于阈值，熔断器打开（Open），停止调用下游并立即返回降级结果；过一段时间进入 Half-Open 试探。</li>
</ul>
</li>
<li><strong>降级策略</strong>：返回缓存数据、默认值、功能降级（只展示基础信息）或返回错误提示。</li>
<li><strong>隔离（Bulkhead）</strong>：资源隔离（线程池&#x2F;连接池）防止一个服务耗尽整个系统资源。</li>
</ul>
</li>
<li><strong>实现工具</strong>：Hystrix（已停止维护）、Resilience4j、Istio&#x2F;Envoy 等服务网格提供熔断与限流能力。</li>
<li><strong>监控指标</strong><ul>
<li>错误率、延迟 P95&#x2F;P99、并发&#x2F;线程使用率、熔断打开次数。</li>
</ul>
</li>
<li><strong>实战建议</strong><ul>
<li>熔断阈值不要设得太敏感；结合业务重要度定制降级策略（核心业务更保守）。</li>
<li>使用自动回退 &amp; 慢启动（half-open 试探时限流）。</li>
</ul>
</li>
<li><strong>面试追问</strong>：熔断与限流的不同？如何设计 Half-Open 的试探策略？</li>
</ul>
<hr>
<p><strong>17. 单体架构 vs 微服务架构（区别、优劣、迁移策略）</strong></p>
<ul>
<li><strong>单体（Monolith）</strong><ul>
<li>单一部署包（应用 + UI + DB schema）。开发简单、事务管理方便、性能调优集中。</li>
<li>缺点：团队协作瓶颈、难以按模块独立扩展、发布周期长、代码库复杂。</li>
</ul>
</li>
<li><strong>微服务（Microservices）</strong><ul>
<li>按业务域拆分为多个小服务，独立部署、独立扩缩、独立数据库（去中心化数据）。</li>
<li>优点：团队自治、按服务扩展、技术选型灵活、故障隔离。</li>
<li>缺点：分布式系统复杂（网络延迟、分布式事务、观察性、部署复杂度、运维成本）。</li>
</ul>
</li>
<li><strong>选择建议</strong><ul>
<li>初创&#x2F;小团队或产品早期：倾向单体（快速迭代）。</li>
<li>业务复杂、团队规模大、需要独立扩展与技术异构：考虑微服务。</li>
</ul>
</li>
<li><strong>迁移技巧</strong><ul>
<li>Strangler Pattern：逐步把单体功能提取到微服务，外层路由切换到新服务。</li>
<li>先做服务划分、定义清晰的边界与 API，建立统一的服务发现、认证和监控体系。</li>
</ul>
</li>
<li><strong>面试追问</strong>：微服务如何做事务？怎么做服务发现与熔断？如何做日志聚合与链路追踪？</li>
</ul>
<hr>
<p><strong>18. 防抖（Debounce）与 节流（Throttle）及适用场景</strong></p>
<ul>
<li><p><strong>防抖（Debounce）</strong></p>
<ul>
<li><p>含义：在事件停止触发后等待一段时间才执行函数；多次触发只执行最后一次。</p>
</li>
<li><p>场景：输入联想、搜索框（用户停止输入后才触发搜索）。</p>
</li>
<li><p>JS 伪代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> t;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(t);</span><br><span class="line">    t = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args), wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>节流（Throttle）</strong></p>
<ul>
<li><p>含义：在固定时间间隔内只执行一次函数（如果持续触发则按间隔执行）。</p>
</li>
<li><p>场景：滚动、窗口 resize、按键长按等需要限制频率的操作。</p>
</li>
<li><p>JS 伪代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, limit</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> inThrottle = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!inThrottle) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      inThrottle = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> inThrottle = <span class="literal">false</span>, limit);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>选择原则</strong>：需在事件结束后执行 → 用防抖；需均匀限制调用频率 → 用节流。</p>
</li>
</ul>
<hr>
<p><strong>19. CDN（内容分发网络）详解：原理、优化与安全</strong></p>
<ul>
<li><strong>基本原理</strong>：把静态资源缓存到离用户更近的边缘节点（PoP），用户请求被路由到最近&#x2F;最优节点，降低延迟、减轻源站压力。</li>
<li><strong>主要能力</strong><ul>
<li>静态内容缓存（图片、JS&#x2F;CSS、视频分片）、动态内容加速（通过智能路由&#x2F;连接复用）、SSL 终止、WAF、DDoS 防护、负载均衡、边缘计算（边缘函数&#x2F;Workers）。</li>
</ul>
</li>
<li><strong>缓存控制</strong><ul>
<li><code>Cache-Control</code>（max-age, public&#x2F;private, s-maxage），<code>ETag</code>&#x2F;<code>Last-Modified</code>，<code>stale-while-revalidate</code>。</li>
<li>缓存失效策略：基于 URL 版本（内容哈希）、时间 TTL、手动 purge。</li>
</ul>
</li>
<li><strong>优化技巧</strong><ul>
<li>用内容哈希做文件名（避免复杂的 purge）。</li>
<li>使用 <code>prefetch</code> &#x2F; <code>preload</code> &#x2F; <code>edge caching</code> 提升体验（尤其首屏）。</li>
<li>Origin Shield（中间层缓存）保护源站免击穿。</li>
</ul>
</li>
<li><strong>安全</strong><ul>
<li>边缘 WAF、速率限制、地理封禁、签名 URL（短期授权）保护私有资源。</li>
</ul>
</li>
<li><strong>面试追问</strong>：如何缓存动态内容？CDN 缓存穿透到源站怎么办？如何做 CDN cache invalidation 最优策略？</li>
</ul>
<hr>
<p><strong>20. RBAC（Role-Based Access Control）详解</strong><br> （你写成 RABC，我按常用 RBAC 解释）</p>
<ul>
<li><strong>核心概念</strong><ul>
<li><strong>角色（Role）</strong>：代表一组权限（Permission）。</li>
<li><strong>权限（Permission）</strong>：通常是对资源的操作（read&#x2F;write&#x2F;delete）。</li>
<li><strong>用户（User）</strong>：被赋予角色，从而继承权限。</li>
</ul>
</li>
<li><strong>模型特性</strong><ul>
<li>支持 <strong>角色继承&#x2F;层级</strong>（例如 Admin 包含 User 权限）。</li>
<li>强调最小权限原则（least privilege）。</li>
</ul>
</li>
<li><strong>设计要点</strong><ul>
<li>把权限映射到资源&#x2F;操作（资源 + 操作作为权限单元）。</li>
<li>支持动态权限（例如 ABAC）用于属性&#x2F;上下文判断（时间、IP 等）。</li>
<li>缓存权限（例如 ACL cache）以加速鉴权，但需处理权限变更的失效。</li>
</ul>
</li>
<li><strong>实现数据库模式（简化）</strong><ul>
<li>tables: users, roles, permissions, user_roles, role_permissions。</li>
</ul>
</li>
<li><strong>扩展</strong>：ABAC（Attribute-Based）、PBAC（Policy-Based）当权限复杂时使用策略引擎（OPA）。</li>
<li><strong>面试点</strong>：RBAC 的优缺点、如何在分布式系统快速授权（token 携带权限&#x2F;JWT、或网关做中央鉴权）。</li>
</ul>
<hr>
<p><strong>21. Cookie（概念、属性、安全实践）</strong></p>
<ul>
<li><strong>概念</strong>：浏览器用来在客户端储存和跨请求携带少量数据（如 session id、偏好设置）。</li>
<li><strong>重要属性</strong><ul>
<li><code>Name=Value</code>、<code>Domain</code>、<code>Path</code>、<code>Expires/Max-Age</code>、<code>Secure</code>（仅 HTTPS）、<code>HttpOnly</code>（JS 不能访问）、<code>SameSite</code>（None&#x2F;Lax&#x2F;Strict）。</li>
</ul>
</li>
<li><strong>安全实践</strong><ul>
<li><code>HttpOnly</code> 防止 XSS 直接窃取 Cookie（但 CSRF 仍可能触发）。</li>
<li><code>SameSite</code> 设置合理值减少 CSRF（Strict 最严格但影响跨站场景，Lax 常用）。</li>
<li>与 <code>Secure</code> 配合，Cookie 只在 HTTPS 下传输。</li>
<li>对敏感数据不直接存储在 Cookie 中（只存 session id 或 token 的引用）。</li>
</ul>
</li>
<li><strong>大小与数量限制</strong>：浏览器对单个 cookie 与域名下的 cookie 数量有上限（实现时要注意）。</li>
<li><strong>面试追问</strong>：Cookie 与 localStorage 的区别？如何用 SameSite 防 CSRF？</li>
</ul>
<hr>
<p><strong>22. Session（服务器端会话管理）</strong></p>
<ul>
<li><strong>基本模式</strong><ul>
<li><strong>服务器端 Session</strong>：服务器保存 session 状态（内存、Redis、DB），客户端仅持有 session id（cookie）。</li>
<li><strong>无状态 Token（如 JWT）</strong>：状态保存在 token 本身，服务器不保存 session（但牺牲了即时下线&#x2F;撤销能力）。</li>
</ul>
</li>
<li><strong>Session 存储</strong><ul>
<li>本地内存（单实例）、共享存储（Redis 常用）、数据库（持久但慢）。</li>
<li>对于分布式多实例，建议用 Redis 或数据库持久化 session，或使用 sticky session（不推荐）。</li>
</ul>
</li>
<li><strong>安全与实践</strong><ul>
<li>Session 固定攻击防护（Session Fixation）：登录后旋转 session id。</li>
<li>会话过期、滑动过期（每次活动延长过期时间），并支持登出时的立即失效（需要服务端存储）。</li>
<li>持久化&#x2F;清理旧 session：TTL + 定期清理。</li>
</ul>
</li>
<li><strong>面试追问</strong>：为什么 JWT 无法轻易实现强撤销？如何在微服务中共享 session（Token 认证 + introspection 或集中认证服务）？</li>
</ul>
<hr>
<p><strong>23. Token（JWT、Opaque Token、OAuth2、刷新与安全）</strong></p>
<ul>
<li><strong>Token 类型</strong><ul>
<li><strong>Opaque token（不透明）</strong>：随机字符串，服务器需校验&#x2F;查询（例如 introspection endpoint）。</li>
<li><strong>JWT（JSON Web Token）</strong>：自包含，<code>header.payload.signature</code>，服务可离线验证签名并读取声明（claims）。</li>
</ul>
</li>
<li><strong>JWT 结构</strong><ul>
<li>Header（类型、算法） | Payload（claims：sub, exp, iat, scopes） | Signature（HMAC 或 RSA&#x2F;ECDSA）。</li>
</ul>
</li>
<li><strong>优缺点</strong><ul>
<li>JWT：无状态验证、性能好；缺点：难以即时撤销（需黑名单&#x2F;JTI）、token 体积较大、滥用风险高。</li>
<li>Opaque token：撤销&#x2F;控制更容易（服务器查），但需状态存储和额外网络开销。</li>
</ul>
</li>
<li><strong>OAuth2 &amp; Flow</strong><ul>
<li>常见 flows：Authorization Code（推荐带 PKCE 用于 browser + SPAs）、Client Credentials（服务间）、Resource Owner Password（不推荐）。</li>
<li>使用 refresh token 刷新 access token（短期 access token + 更长 refresh token）。</li>
</ul>
</li>
<li><strong>安全实践</strong><ul>
<li>Access token 短期有效、Refresh token 使用 rotation（每次刷新发新 refresh token 并使旧一个失效）。</li>
<li>存储在浏览器：若放 Cookie，应用 <code>HttpOnly</code> + <code>Secure</code> + <code>SameSite</code>；若放 localStorage 则易被 XSS 窃取。</li>
<li>使用 <code>jti</code> 或 token 黑名单&#x2F;撤销机制在必要时撤销 token。</li>
<li>签名算法使用非对称（RS256）可以方便公钥验证；密钥管理与轮换非常重要。</li>
</ul>
</li>
<li><strong>实现细节</strong><ul>
<li>在微服务中常使用 <strong>Token Introspection &#x2F; Auth Service</strong>：服务接到 token 时向 auth server 校验或直接验证 JWT 签名。</li>
<li>结合 OAuth scopes 与 RBAC 做精细权限控制。</li>
</ul>
</li>
<li><strong>面试追问</strong>：如何安全存储 refresh token？JWT 怎么做 token 撤销？什么是 token binding？</li>
</ul>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Charlotte</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/10/01/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/">http://example.com/2025/10/01/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">浮生若梦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/img/title.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/09/23/%E7%AE%80%E6%98%93%E7%89%88%E9%A2%98%E7%9B%AE/" title="简易版题目"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">简易版题目</div></div><div class="info-2"><div class="info-item-1">📚 数据库题库答案1、OSI 七层模型 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 功能：自下而上分别负责传输介质、链路控制、路由转发、端到端传输、会话管理、数据格式转换、应用服务。   2、TCP 的三次握手 客户端 → 服务端：SYN&#x3D;1（请求建立连接）。 服务端 → 客户端：SYN&#x3D;1, ACK&#x3D;1（确认并同意建立）。 客户端 → 服务端：ACK&#x3D;1（确认）。 👉 作用：确保双方具备收发能力，并同步初始序列号。   3、TCP 的四次挥手 客户端 → 服务端：FIN&#x3D;1（我没数据了）。 服务端 → 客户端：ACK&#x3D;1（收到）。 服务端 → 客户端：FIN&#x3D;1（我也没数据了）。 客户端 → 服务端：ACK&#x3D;1（收到）。 👉 双方各自独立关闭。   4、SQL 语言和方言的区别 SQL 语言：标准 SQL（ANSI&#x2F;ISO 定义），如 SELECT * FROM table;。 SQL 方言：不同数据库厂商在标准 SQL 基础上扩展的特性，如 MySQL 的 LIM...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/title.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Charlotte</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/charlotte030710"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Das Leben schwingt wie ein Pendel, hin und her, zwischen dem Schmerz und der Langeweile.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F%E5%85%AB%E8%82%A1"><span class="toc-number">1.</span> <span class="toc-text">Spring-牛客面经八股</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B4%E8%AF%B4-Spring-Boot-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">1. 说说 Spring Boot 常用的注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Spring-Boot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2.Spring Boot 启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-SpringApplication-run"><span class="toc-number">1.2.1.</span> <span class="toc-text">调用 SpringApplication.run(...)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91-SpringApplicationRunListeners-%E7%9A%84-starting"><span class="toc-number">1.2.2.</span> <span class="toc-text">触发 SpringApplicationRunListeners 的 starting()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87-Environment"><span class="toc-number">1.2.3.</span> <span class="toc-text">准备 Environment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%87%86%E5%A4%87-ApplicationContext"><span class="toc-number">1.2.4.</span> <span class="toc-text">创建并准备 ApplicationContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-ApplicationContextInitializer"><span class="toc-number">1.2.5.</span> <span class="toc-text">调用 ApplicationContextInitializer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.6.</span> <span class="toc-text">加载自动配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C-BeanFactoryPostProcessor"><span class="toc-number">1.2.7.</span> <span class="toc-text">执行 BeanFactoryPostProcessor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8D%95%E4%BE%8B-Bean"><span class="toc-number">1.2.8.</span> <span class="toc-text">创建并实例化单例 Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8-refresh-%E5%AE%8C%E6%88%90"><span class="toc-number">1.2.9.</span> <span class="toc-text">容器 refresh() 完成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%8E%A5%E5%8F%97%E8%AF%B7%E6%B1%82-%E5%90%AF%E5%8A%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.2.10.</span> <span class="toc-text">应用接受请求 &#x2F; 启动异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%91-%E9%87%8D%E8%A6%81%E6%89%A9%E5%B1%95%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.11.</span> <span class="toc-text">🔑 重要扩展点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9-IoC%EF%BC%88Inversion-of-Control-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">3. 对 IoC（Inversion of Control &#x2F; 依赖注入）的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AF%B9-AOP%EF%BC%88%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.4.</span> <span class="toc-text">4. 对 AOP（面向切面编程）的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4%E4%B8%8E%E9%92%A9%E5%AD%90%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">5. Bean 的生命周期（主要步骤与钩子）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Autowired-%E5%92%8C-Resource-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">6. @Autowired 和 @Resource 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">7. Spring 事务管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Spring-MVC-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%88%E8%AF%B7%E6%B1%82%E5%88%B0%E5%93%8D%E5%BA%94%E7%9A%84%E5%AE%8C%E6%95%B4%E9%93%BE%E8%B7%AF%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">8. Spring MVC 的执行流程（请求到响应的完整链路）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Component-%E5%92%8C-Bean-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">9. @Component 和 @Bean 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Spring-%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.10.</span> <span class="toc-text">10. Spring 中用到的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%8B%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">1.11.</span> <span class="toc-text">11. Spring 循环依赖是什么？介绍下三级缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Spring-Security-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">12. Spring Security 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Spring%E3%80%81Spring-MVC%E3%80%81Spring-Boot-%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.13.</span> <span class="toc-text">13. Spring、Spring MVC、Spring Boot 三者之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Spring-Boot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0%EF%BC%89"><span class="toc-number">1.14.</span> <span class="toc-text">14. Spring Boot 自动配置原理（原理概述）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Spring-Cloud-%E7%9A%84%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9D%97%E4%B8%8E%E4%BD%9C%E7%94%A8%EF%BC%89"><span class="toc-number">1.15.</span> <span class="toc-text">15. Spring Cloud 的组件有哪些？（常见模块与作用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%9C%A8-REQUIRES-NEW-%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E5%AD%90%E4%BA%8B%E5%8A%A1%E5%90%8C%E6%97%B6%E6%93%8D%E4%BD%9C%E5%90%8C%E4%B8%80%E6%95%B0%E6%8D%AE%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">16. 在 REQUIRES_NEW 场景下，子事务同时操作同一数据会发生什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88A%EF%BC%89REQUIRES-NEW-%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%88%E5%AE%9E%E7%8E%B0%E5%B1%82%E9%9D%A2%EF%BC%89"><span class="toc-number">1.16.1.</span> <span class="toc-text">（A）REQUIRES_NEW 的行为（实现层面）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88B%EF%BC%89%E8%8B%A5%E5%AD%90%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%A4%96%E5%B1%82-%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%90%E4%BA%8B%E5%8A%A1%E2%80%9C%E5%90%8C%E6%97%B6%E2%80%9D%E6%93%8D%E4%BD%9C%E5%90%8C%E4%B8%80%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.16.2.</span> <span class="toc-text">（B）若子事务和外层&#x2F;另一个子事务“同时”操作同一数据，会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88C%EF%BC%89%E4%B8%8E-NESTED-%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.16.3.</span> <span class="toc-text">（C）与 NESTED 的对比（重要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88D%EF%BC%89JPA-Hibernate-%E7%BB%86%E8%8A%82%EF%BC%88ORM-%E5%B1%82%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">1.16.4.</span> <span class="toc-text">（D）JPA&#x2F;Hibernate 细节（ORM 层的问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88E%EF%BC%89%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF%EF%BC%88%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%AF%B4%E6%98%8E%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0%EF%BC%89%EF%BC%9A"><span class="toc-number">1.16.5.</span> <span class="toc-text">（E）示例场景（伪代码，说明丢失更新）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88F%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BA%A7%E5%88%AB%E7%9A%84%E5%BC%82%E5%B8%B8%EF%BC%88%E6%AD%BB%E9%94%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%A4%B1%E8%B4%A5%E7%AD%89%EF%BC%89"><span class="toc-number">1.16.6.</span> <span class="toc-text">（F）数据库级别的异常（死锁、序列化失败等）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88G%EF%BC%89%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.16.7.</span> <span class="toc-text">（G）最佳实践与建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%88%E5%85%B3%E4%BA%8E%E7%AC%AC16%E9%A2%98%E7%9A%84%E5%AE%9E%E6%88%98%E6%8F%90%E9%86%92%EF%BC%89"><span class="toc-number">1.16.8.</span> <span class="toc-text">小结（关于第16题的实战提醒）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80-%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F%E5%85%AB%E8%82%A1"><span class="toc-number">2.</span> <span class="toc-text">Java基础-牛客面经八股</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1 Java 基本数据类型与引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%88Primitive-Types-8-%E7%A7%8D%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 基本类型（Primitive Types, 8 种）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88Reference-Types%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 引用类型（Reference Types）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. 内存结构对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q1-%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E6%9C%89%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%A8%E9%83%A8%E7%94%A8%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.1.4.</span> <span class="toc-text">Q1. 为什么 Java 有基本类型而不是全部用对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q2-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.5.</span> <span class="toc-text">Q2. 基本类型和包装类型的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q3-%E4%B8%BA%E4%BB%80%E4%B9%88-Integer-i1-127-Integer-i2-127-i1-i2-%E8%BF%94%E5%9B%9E-true%EF%BC%8C%E8%80%8C%E6%8D%A2%E6%88%90-128-%E8%BF%94%E5%9B%9E-false%EF%BC%9F"><span class="toc-number">2.1.6.</span> <span class="toc-text">Q3. 为什么 Integer i1 &#x3D; 127; Integer i2 &#x3D; 127; i1 &#x3D;&#x3D; i2 返回 true，而换成 128 返回 false？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q4-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">2.1.7.</span> <span class="toc-text">Q4. 对象在堆中的内存布局是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q5-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E7%94%A8%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%EF%BC%88String-Integer-Long-%E7%AD%89%EF%BC%89%E4%BD%9C%E4%B8%BA%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">2.1.8.</span> <span class="toc-text">Q5. 为什么建议用不可变对象（String, Integer, Long 等）作为共享数据？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q6-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">2.1.9.</span> <span class="toc-text">Q6. 什么时候用基本类型，什么时候用包装类型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q7-%E4%B8%BA%E4%BB%80%E4%B9%88-boolean-%E5%A4%A7%E5%B0%8F%E6%9C%AA%E5%AE%9A%E4%B9%89%EF%BC%9FJVM-%E5%AE%9E%E9%99%85%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F"><span class="toc-number">2.1.10.</span> <span class="toc-text">Q7. 为什么 boolean 大小未定义？JVM 实际是怎么处理的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%BB%93"><span class="toc-number">2.1.11.</span> <span class="toc-text">🔹 面试小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E6%A0%88%EF%BC%88Stack%EF%BC%89"><span class="toc-number">2.1.12.</span> <span class="toc-text">🔹 栈（Stack）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E5%A0%86%EF%BC%88Heap%EF%BC%89"><span class="toc-number">2.1.13.</span> <span class="toc-text">🔹 堆（Heap）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.14.</span> <span class="toc-text">🔹 对比总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE"><span class="toc-number">2.1.15.</span> <span class="toc-text">🔹 常见面试追问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1-Java-%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%AD%98%E6%94%BE%E5%9C%A8%E5%A0%86%E8%BF%98%E6%98%AF%E6%A0%88%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">Q1. Java 中的变量存放在堆还是栈？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Q2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%88%E6%AF%94%E5%A0%86%E5%BF%AB%EF%BC%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">Q2. 为什么栈比堆快？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q3-%E6%A0%88%E9%87%8C%E8%83%BD%E5%AD%98%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">Q3. 栈里能存对象吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%86%EF%BC%9F"><span class="toc-number">2.2.3.</span> <span class="toc-text">Q4. 为什么要有堆和栈的区分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q5-GC-%E5%8F%AA%E5%9B%9E%E6%94%B6%E5%A0%86%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text">Q5. GC 只回收堆吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E7%AD%94%E9%A2%98%E7%89%88"><span class="toc-number">2.2.5.</span> <span class="toc-text">🔹 面试快速答题版</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E7%B1%BB-vs-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.</span> <span class="toc-text">2 抽象类 vs 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E6%8A%BD%E8%B1%A1%E7%B1%BB-vs-%E6%8E%A5%E5%8F%A3%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">🔹 抽象类 vs 接口：如何选择？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">1. 抽象类的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">2. 接口的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%80%89%E6%8B%A9%E5%87%86%E5%88%99"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">3. 选择准则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.2.</span> <span class="toc-text">🔹 接口的多继承 &amp; 菱形继承问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">1. 什么是菱形继承？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Java-%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%88%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%EF%BC%89"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">2. Java 的规则（接口方法冲突解决）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BE%8B%E5%AD%90%EF%BC%9A%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">3. 例子：解决冲突</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E7%AD%94%E9%A2%98%E7%89%88-1"><span class="toc-number">2.3.3.</span> <span class="toc-text">🔹 面试快速答题版</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.4.</span> <span class="toc-text">3 final 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.1.</span> <span class="toc-text">final 关键字总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-final-%E7%B1%BB"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">1. final 类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-final-%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">2. final 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-final-%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">3. final 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.1.3.1.</span> <span class="toc-text">3.1 局部变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%88%E5%AD%97%E6%AE%B5%EF%BC%89"><span class="toc-number">2.4.1.3.2.</span> <span class="toc-text">3.2 成员变量（字段）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-3-%E5%B8%B8%E9%87%8F%E6%8A%98%E5%8F%A0"><span class="toc-number">2.4.1.3.3.</span> <span class="toc-text">3.3 常量折叠</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-JMM-%E4%B8%AD%E7%9A%84-final-%E8%AF%AD%E4%B9%89"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">4. JMM 中的 final 语义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E8%BF%BD%E9%97%AE-%E7%AD%94%E6%B3%95"><span class="toc-number">2.4.2.</span> <span class="toc-text">✅ 面试常见追问 + 答法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.5.</span> <span class="toc-text">4 static 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.5.1.</span> <span class="toc-text">static 关键字详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-static-%E5%8F%98%E9%87%8F%EF%BC%88%E7%B1%BB%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">1. static 变量（类变量）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-static-%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">2. static 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-static-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">2.5.1.3.</span> <span class="toc-text">3. static 代码块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-static-synchronized"><span class="toc-number">2.5.1.4.</span> <span class="toc-text">4. static synchronized</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A1-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%99%B7%E9%98%B1"><span class="toc-number">2.5.2.</span> <span class="toc-text">⚡ 常见面试陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%9D%8C-1-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">❌ 1. 静态成员与内存泄漏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%9D%8C-2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">❌ 2. 静态方法调用实例方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%9D%8C-3-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.5.2.3.</span> <span class="toc-text">❌ 3. 静态内部类与非静态内部类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE"><span class="toc-number">2.5.3.</span> <span class="toc-text">✅ 高频面试追问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-String-StringBuffer-StringBuilder"><span class="toc-number">2.6.</span> <span class="toc-text">5 String &#x2F; StringBuffer &#x2F; StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88-String-%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA-Map-%E7%9A%84-key%EF%BC%9F"><span class="toc-number">2.6.1.</span> <span class="toc-text">1. 为什么 String 可以作为 Map 的 key？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-String-%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-number">2.6.2.</span> <span class="toc-text">2. String 常量池与内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8-%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.3.</span> <span class="toc-text">3. 循环中使用 + 拼接字符串的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E8%BF%BD%E9%97%AE"><span class="toc-number">2.6.4.</span> <span class="toc-text">4. 面试高频追问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%8E-equals"><span class="toc-number">2.7.</span> <span class="toc-text">6 &#x3D;&#x3D; 与 equals()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%EF%BC%9A%E6%AF%94%E8%BE%83%E5%BC%95%E7%94%A8-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%80%BC"><span class="toc-number">2.7.1.</span> <span class="toc-text">1. &#x3D;&#x3D;：比较引用&#x2F;基本类型值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">1.1 基本类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">1.2 引用类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-equals-%EF%BC%9A%E6%AF%94%E8%BE%83%E5%86%85%E5%AE%B9"><span class="toc-number">2.7.2.</span> <span class="toc-text">2. equals()：比较内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%87%86%E5%88%99"><span class="toc-number">2.7.3.</span> <span class="toc-text">3. 使用准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%99%B7%E9%98%B1"><span class="toc-number">2.7.4.</span> <span class="toc-text">4. 常见面试陷阱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%9D%A2%E8%AF%95%E5%BF%AB%E6%8D%B7%E7%AD%94%E6%B3%95"><span class="toc-number">2.7.5.</span> <span class="toc-text">5. 面试快捷答法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-hashCode-%E4%B8%8E-equals"><span class="toc-number">2.8.</span> <span class="toc-text">7 hashCode() 与 equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-%E6%8B%86%E7%AE%B1"><span class="toc-number">2.9.</span> <span class="toc-text">8 包装类的自动装箱&#x2F;拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89-vs-%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89"><span class="toc-number">2.10.</span> <span class="toc-text">9 重载（Overload） vs 重写（Override）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Java-%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.11.</span> <span class="toc-text">10 Java 泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-PECS-%E5%8E%9F%E5%88%99%EF%BC%88Producer-Extends-Consumer-Super%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">1️⃣ PECS 原则（Producer Extends, Consumer Super）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE%EF%BC%9A"><span class="toc-number">3.2.</span> <span class="toc-text">面试追问：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E4%B8%8E%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95%EF%BC%88Bridge-Method%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">2️⃣ 类型擦除与桥接方法（Bridge Method）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">4.1.</span> <span class="toc-text">2.1 类型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95%EF%BC%88Bridge-Method%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">2.2 桥接方法（Bridge Method）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE%EF%BC%9A-1"><span class="toc-number">4.3.</span> <span class="toc-text">面试追问：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="toc-number">5.</span> <span class="toc-text">3️⃣ 泛型与反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%99%AE%E9%80%9A%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">3.1 普通反射获取泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-ParameterizedType-%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">5.2.</span> <span class="toc-text">3.2 ParameterizedType 获取泛型信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE%EF%BC%9A-2"><span class="toc-number">5.3.</span> <span class="toc-text">面试追问：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.</span> <span class="toc-text">4️⃣ 面试答题模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%8F%8D%E5%B0%84"><span class="toc-number">6.1.</span> <span class="toc-text">11 反射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E5%8F%8D%E5%B0%84%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">7.</span> <span class="toc-text">1️⃣ 反射的用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E5%8F%8D%E5%B0%84%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-number">8.</span> <span class="toc-text">2️⃣ 反射的成本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-Class-forName-%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">3️⃣ Class.forName() 与类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84%E4%B8%8E%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB"><span class="toc-number">10.</span> <span class="toc-text">4️⃣ 类加载器三层结构与资源隔离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE"><span class="toc-number">11.</span> <span class="toc-text">5️⃣ 面试追问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%EF%BC%88Parent-Delegation-Model%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">1️⃣ 双亲委派（Parent Delegation Model）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">12.1.</span> <span class="toc-text">加载流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">12.2.</span> <span class="toc-text">12 线程安全的集合与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-HashMap-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">12.3.</span> <span class="toc-text">13 HashMap 底层原理与扩容机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-HashMap-%E6%89%A9%E5%AE%B9%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90"><span class="toc-number">13.</span> <span class="toc-text">1️⃣ HashMap 扩容与负载因子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%89%A9%E5%AE%B9%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">13.1.</span> <span class="toc-text">1.1 扩容触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%EF%BC%9F"><span class="toc-number">13.2.</span> <span class="toc-text">1.2 为什么使用负载因子？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%A0%91%E5%8C%96%EF%BC%88%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">2️⃣ 为什么要树化（红黑树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="toc-number">14.1.</span> <span class="toc-text">2.1 问题背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A0%91%E5%8C%96%E8%A7%84%E5%88%99"><span class="toc-number">14.2.</span> <span class="toc-text">2.2 树化规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE"><span class="toc-number">14.3.</span> <span class="toc-text">2.3 面试追问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-HashMap-%E5%B9%B6%E5%8F%91%E5%86%99%E5%85%A5%E9%97%AE%E9%A2%98"><span class="toc-number">15.</span> <span class="toc-text">3️⃣ HashMap 并发写入问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E8%A1%A8%E7%8E%B0"><span class="toc-number">15.1.</span> <span class="toc-text">3.1 并发问题表现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="toc-number">15.2.</span> <span class="toc-text">3.2 解决方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-HashMap-key-%E5%BA%94%E8%AF%A5%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">16.</span> <span class="toc-text">4️⃣ HashMap key 应该不可变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8E%9F%E5%9B%A0"><span class="toc-number">16.1.</span> <span class="toc-text">4.1 原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE"><span class="toc-number">16.2.</span> <span class="toc-text">4.2 面试追问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF"><span class="toc-number">17.</span> <span class="toc-text">5️⃣ 面试快速答题模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-ConcurrentHashMap-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%B7%B1%E5%85%A5%EF%BC%8CJDK7-vs-JDK8%EF%BC%89"><span class="toc-number">17.1.</span> <span class="toc-text">14 ConcurrentHashMap 的线程安全实现（深入，JDK7 vs JDK8）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E4%B8%BA%E4%BB%80%E4%B9%88-ConcurrentHashMap-%E4%B8%8D%E9%9C%80%E8%A6%81%E5%85%A8%E5%B1%80%E9%94%81%EF%BC%9F"><span class="toc-number">17.1.1.</span> <span class="toc-text">1️⃣ 为什么 ConcurrentHashMap 不需要全局锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-JDK-7-vs-JDK-8"><span class="toc-number">17.1.1.1.</span> <span class="toc-text">1.1 JDK 7 vs JDK 8</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">17.1.1.2.</span> <span class="toc-text">1.2 核心思想</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E4%B8%BA%E4%BB%80%E4%B9%88-get-%E4%B8%8D%E5%8A%A0%E9%94%81%E4%B9%9F%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">17.1.2.</span> <span class="toc-text">2️⃣ 为什么 get 不加锁也安全？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E5%8E%9F%E7%90%86"><span class="toc-number">17.1.2.1.</span> <span class="toc-text">2.1 原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9"><span class="toc-number">17.1.2.2.</span> <span class="toc-text">2.2 面试要点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-remove-size-%E7%AD%89%E6%93%8D%E4%BD%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF-O-1-%E7%B2%BE%E7%A1%AE%EF%BC%9F"><span class="toc-number">17.1.3.</span> <span class="toc-text">3️⃣ remove&#x2F;size 等操作为什么不是 O(1) 精确？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-remove"><span class="toc-number">17.1.3.1.</span> <span class="toc-text">3.1 remove</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-size"><span class="toc-number">17.1.3.2.</span> <span class="toc-text">3.2 size()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF-1"><span class="toc-number">17.1.4.</span> <span class="toc-text">4️⃣ 面试答题模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-ArrayList-vs-LinkedList"><span class="toc-number">17.2.</span> <span class="toc-text">15 ArrayList vs LinkedList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E6%89%A9%E5%AE%B9%E5%BC%80%E9%94%80"><span class="toc-number">18.</span> <span class="toc-text">1️⃣ 扩容开销</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%89%A9%E5%AE%B9%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6-1"><span class="toc-number">18.1.</span> <span class="toc-text">1.1 扩容触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">18.2.</span> <span class="toc-text">1.2 扩容机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-ensureCapacity-int-minCapacity"><span class="toc-number">19.</span> <span class="toc-text">2️⃣ ensureCapacity(int minCapacity)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BD%9C%E7%94%A8"><span class="toc-number">19.1.</span> <span class="toc-text">2.1 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">19.2.</span> <span class="toc-text">2.2 使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%9D%A2%E8%AF%95%E7%82%B9"><span class="toc-number">19.3.</span> <span class="toc-text">2.3 面试点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-trimToSize"><span class="toc-number">20.</span> <span class="toc-text">3️⃣ trimToSize()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BD%9C%E7%94%A8"><span class="toc-number">20.1.</span> <span class="toc-text">3.1 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">20.2.</span> <span class="toc-text">3.2 使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%9D%A2%E8%AF%95%E7%82%B9"><span class="toc-number">20.3.</span> <span class="toc-text">3.3 面试点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E8%BF%AD%E4%BB%A3%E6%97%B6%E7%9A%84-fail-fast%EF%BC%88modCount%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-number">21.</span> <span class="toc-text">4️⃣ 迭代时的 fail-fast（modCount）机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8E%9F%E7%90%86"><span class="toc-number">21.1.</span> <span class="toc-text">4.1 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="toc-number">21.2.</span> <span class="toc-text">4.2 触发场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%9D%A2%E8%AF%95%E7%82%B9"><span class="toc-number">21.3.</span> <span class="toc-text">4.3 面试点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF-1"><span class="toc-number">22.</span> <span class="toc-text">5️⃣ 面试快速答题模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-LinkedList-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">23.</span> <span class="toc-text">1️⃣ LinkedList 基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">24.</span> <span class="toc-text">2️⃣ 插入与删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E7%82%B9"><span class="toc-number">24.1.</span> <span class="toc-text">面试点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E-fail-fast"><span class="toc-number">25.</span> <span class="toc-text">3️⃣ 迭代器与 fail-fast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-LinkedList-%E7%89%B9%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">26.</span> <span class="toc-text">4️⃣ LinkedList 特点总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE-1"><span class="toc-number">27.</span> <span class="toc-text">5️⃣ 面试追问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%B8%8F%E2%83%A3-%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF"><span class="toc-number">28.</span> <span class="toc-text">6️⃣ 面试快速答题模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-vs-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">28.1.</span> <span class="toc-text">16 基本类型 vs 包装类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Java-%E7%9A%84-Object-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">28.2.</span> <span class="toc-text">17 Java 的 Object 类常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-wait-notify-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">29.</span> <span class="toc-text">1️⃣ wait&#x2F;notify 基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">30.</span> <span class="toc-text">2️⃣ 必须在同步块中的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E9%98%B2%E6%AD%A2%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="toc-number">31.</span> <span class="toc-text">3️⃣ 防止虚假唤醒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-wait-notify-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="toc-number">32.</span> <span class="toc-text">4️⃣ wait&#x2F;notify 使用模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">33.</span> <span class="toc-text">5️⃣ 示例：生产者-消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D-%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D"><span class="toc-number">33.1.</span> <span class="toc-text">18 深拷贝 &#x2F; 浅拷贝 &#x2F; 引用拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-CGLIB"><span class="toc-number">33.2.</span> <span class="toc-text">19 JDK 动态代理 &amp; CGLIB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%BA%8F%E5%88%97%E5%8C%96-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">33.3.</span> <span class="toc-text">20 序列化 &#x2F; 反序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-serialVersionUID-%E4%BD%9C%E7%94%A8"><span class="toc-number">34.</span> <span class="toc-text">1️⃣ serialVersionUID 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">35.</span> <span class="toc-text">2️⃣ 自定义序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%A4%BA%E4%BE%8B"><span class="toc-number">35.1.</span> <span class="toc-text">2.1 示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">36.</span> <span class="toc-text">3️⃣ 安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">36.1.</span> <span class="toc-text">3.1 常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="toc-number">36.2.</span> <span class="toc-text">3.2 防御措施</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF-2"><span class="toc-number">37.</span> <span class="toc-text">4️⃣ 面试答题模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%B8%B8%E8%A7%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%89"><span class="toc-number">37.1.</span> <span class="toc-text">21 常见序列化协议（优缺点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-BlockingQueue"><span class="toc-number">37.2.</span> <span class="toc-text">22 BlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-PriorityQueue"><span class="toc-number">37.3.</span> <span class="toc-text">23 PriorityQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">37.4.</span> <span class="toc-text">24 设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE%E5%87%86%E5%A4%87"><span class="toc-number">37.5.</span> <span class="toc-text">小结 + 典型面试追问准备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F%E5%85%AB%E8%82%A1"><span class="toc-number">38.</span> <span class="toc-text">数据库基础-牛客面经八股</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MySQL-%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="toc-number">38.1.</span> <span class="toc-text">1. MySQL 的存储引擎有哪些？它们之间有什么区别？默认使用哪个？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MyISAM-%E4%B8%8E-InnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-number">38.2.</span> <span class="toc-text">2. MyISAM 与 InnoDB 的区别？如何选择？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-InnoDB-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F"><span class="toc-number">38.3.</span> <span class="toc-text">3. InnoDB 是如何存储数据的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-MySQL-%E4%B8%80%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">38.4.</span> <span class="toc-text">4. MySQL 一行记录是怎么存储的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E6%9D%A1-SQL-%E5%9C%A8-MySQL-%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">38.5.</span> <span class="toc-text">5. 详细描述一条 SQL 在 MySQL 中的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-MySQL-%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%9F"><span class="toc-number">38.6.</span> <span class="toc-text">6. MySQL 的查询优化器如何选择执行计划？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-SQL-%E4%B8%AD-SELECT%E3%80%81FROM%E3%80%81JOIN%E3%80%81WHERE%E3%80%81GROUP-BY%E3%80%81HAVING%E3%80%81ORDER-BY%E3%80%81LIMIT-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">38.7.</span> <span class="toc-text">7. SQL 中 SELECT、FROM、JOIN、WHERE、GROUP BY、HAVING、ORDER BY、LIMIT 的执行顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-MySQL-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F%EF%BC%88ORDER-BY%EF%BC%89%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">38.8.</span> <span class="toc-text">8. MySQL 中的数据排序（ORDER BY）是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-Java-%E6%89%8B%E5%86%8C%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">38.9.</span> <span class="toc-text">9. 为什么阿里巴巴 Java 手册不推荐使用存储过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%81%9C%E6%9C%8D%E8%BF%81%E7%A7%BB%EF%BC%9F"><span class="toc-number">38.10.</span> <span class="toc-text">10. 如何实现数据库不停服迁移？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Schema-%E5%8F%98%E6%9B%B4%EF%BC%88DDL-%E6%97%A0%E5%81%9C%E6%9C%BA%E5%8C%96%E7%AD%96%E7%95%A5%EF%BC%89%EF%BC%9A"><span class="toc-number">38.10.1.</span> <span class="toc-text">A. Schema 变更（DDL 无停机化策略）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%EF%BC%88%E4%B8%8D%E5%81%9C%E6%9C%8D%E6%90%AC%E5%BA%93%EF%BC%89%EF%BC%9A"><span class="toc-number">38.10.2.</span> <span class="toc-text">B. 数据迁移（不停服搬库）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">38.10.3.</span> <span class="toc-text">实战注意：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-UNSIGNED-%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">38.11.</span> <span class="toc-text">11. UNSIGNED 属性有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-MySQL-%E4%B8%AD-int-11-%E7%9A%84-11-%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">38.12.</span> <span class="toc-text">12. MySQL 中 int(11) 的 11 表示什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-CHAR-%E4%B8%8E-VARCHAR-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">38.13.</span> <span class="toc-text">13. CHAR 与 VARCHAR 有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-VARCHAR-100-%E4%B8%8E-VARCHAR-10-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">38.14.</span> <span class="toc-text">14. VARCHAR(100) 与 VARCHAR(10) 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-DECIMAL-%E4%B8%8E-FLOAT-DOUBLE-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">38.15.</span> <span class="toc-text">15. DECIMAL 与 FLOAT&#x2F;DOUBLE 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-DATETIME-%E4%B8%8E-TIMESTAMP-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">38.16.</span> <span class="toc-text">16. DATETIME 与 TIMESTAMP 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-NULL-%E4%B8%8E-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">38.17.</span> <span class="toc-text">17. NULL 与 &#39;&#39; 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Boolean-%E7%B1%BB%E5%9E%8B%E5%9C%A8-MySQL-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%EF%BC%9F"><span class="toc-number">38.18.</span> <span class="toc-text">18. Boolean 类型在 MySQL 中如何表示？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-TEXT-%E5%92%8C-BLOB%EF%BC%9F"><span class="toc-number">38.19.</span> <span class="toc-text">19. 为什么不推荐使用 TEXT 和 BLOB？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%9C%A8-MySQL-%E4%B8%AD%E5%AD%98%E5%82%A8%E9%87%91%E9%A2%9D%E5%BA%94%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">38.20.</span> <span class="toc-text">20. 在 MySQL 中存储金额应使用什么数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-MySQL-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8-IP-%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">38.21.</span> <span class="toc-text">21. MySQL 如何存储 IP 地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%86%E5%9B%BE%EF%BC%9F"><span class="toc-number">38.22.</span> <span class="toc-text">22. 什么是数据库视图？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B8%B8%E6%A0%87%EF%BC%9F"><span class="toc-number">38.23.</span> <span class="toc-text">23. 什么是数据库游标？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%A4%A7%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9B%BE%E7%89%87-%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%EF%BC%89%EF%BC%9F"><span class="toc-number">38.24.</span> <span class="toc-text">24. 为什么不建议直接存储大对象（图片 &#x2F; 音频 &#x2F; 视频）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%EF%BC%881NF-2NF-3NF%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">38.25.</span> <span class="toc-text">25. 数据库的三大范式（1NF &#x2F; 2NF &#x2F; 3NF）是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BB%BA%E8%AE%AE%EF%BC%88%E7%BB%BC%E5%90%88%EF%BC%89"><span class="toc-number">38.26.</span> <span class="toc-text">最后：实战建议（综合）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F%E5%85%AB%E8%82%A1"><span class="toc-number">39.</span> <span class="toc-text">JVM-牛客面经八股</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">39.1.</span> <span class="toc-text">JVM结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E5%AF%B9%E8%B1%A1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="toc-number">39.2.</span> <span class="toc-text">创建一个新对象 内存分配流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%89%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5"><span class="toc-number">39.3.</span> <span class="toc-text">1) JVM 内存模型（运行时数据区）——深入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JVM-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">39.4.</span> <span class="toc-text">2) JVM 的垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-GC-%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">39.5.</span> <span class="toc-text">3) GC 的可达性分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CMS-Concurrent-Mark-Sweep-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-%E2%80%94%E2%80%94-%E7%BB%86%E8%8A%82%E4%B8%8E%E8%B0%83%E4%BC%98"><span class="toc-number">39.6.</span> <span class="toc-text">4) CMS (Concurrent Mark Sweep) 垃圾回收器 —— 细节与调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-G1-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88Garbage-First%EF%BC%89"><span class="toc-number">39.7.</span> <span class="toc-text">5) G1 收集器（Garbage-First）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E5%8A%A0%E8%BD%BD%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89"><span class="toc-number">39.8.</span> <span class="toc-text">6) 类加载机制（加载、链接、初始化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B-%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4"><span class="toc-number">39.9.</span> <span class="toc-text">7) 双亲委派模型 &amp; 如何打破</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%87%BA%E7%8E%B0-Full-GC-%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">39.10.</span> <span class="toc-text">8) 出现 Full GC 的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%B8%B8%E8%A7%81%E7%9A%84-JVM-%E5%8F%82%E6%95%B0"><span class="toc-number">39.11.</span> <span class="toc-text">9) 常见的 JVM 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-JDK-%E7%9A%84%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7-%E7%BA%BF%E4%B8%8A%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%88%E8%AF%8A%E6%96%AD%E6%AD%A5%E9%AA%A4%E4%B8%8E-runbook%EF%BC%89"><span class="toc-number">39.12.</span> <span class="toc-text">10) JDK 的监控工具 &amp; 线上处理实战案例（诊断步骤与 runbook）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%EF%BC%88%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%89"><span class="toc-number">39.12.1.</span> <span class="toc-text">常用工具（一句话）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-1%EF%BC%9ACPU-%E7%AA%81%E5%A2%9E"><span class="toc-number">39.12.2.</span> <span class="toc-text">场景 1：CPU 突增</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-2%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88%E6%8C%81%E7%BB%AD%E5%86%85%E5%AD%98%E5%A2%9E%E9%95%BF-OOM%EF%BC%89"><span class="toc-number">39.12.3.</span> <span class="toc-text">场景 2：内存泄漏（持续内存增长 &#x2F; OOM）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-3%EF%BC%9A%E9%A2%91%E7%B9%81-Full-GC-GC-%E7%98%AB%E7%97%AA%EF%BC%88%E5%BA%94%E7%94%A8%E5%81%9C%E9%A1%BF%EF%BC%89"><span class="toc-number">39.12.4.</span> <span class="toc-text">场景 3：频繁 Full GC &#x2F; GC 瘫痪（应用停顿）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-4%EF%BC%9A%E6%AD%BB%E9%94%81-%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E"><span class="toc-number">39.12.5.</span> <span class="toc-text">场景 4：死锁 &#x2F; 线程阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%9C%BA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%A8%A1%E6%9D%BF%EF%BC%88%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">39.12.6.</span> <span class="toc-text">现场常用命令模板（示例）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E6%8E%A8%E8%8D%90%EF%BC%88%E9%9D%A2%E8%AF%95%E4%B8%8E%E7%BA%BF%E4%B8%8A%E5%AE%9E%E6%88%98%E8%A6%81%E7%82%B9%EF%BC%89"><span class="toc-number">39.12.7.</span> <span class="toc-text">总结与推荐（面试与线上实战要点）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F%E5%85%AB%E8%82%A1"><span class="toc-number">40.</span> <span class="toc-text">Redis-牛客面经八股</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">40.1.</span> <span class="toc-text">1. Redis 的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9E%B6%E6%9E%84%EF%BC%88%E8%AF%A6%E8%A7%A3-%E7%8E%B0%E4%BB%A3%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">40.2.</span> <span class="toc-text">2. Redis 单线程架构（详解 + 现代补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5%EF%BC%88RDB-AOF-%E6%B7%B7%E5%90%88%EF%BC%89"><span class="toc-number">40.3.</span> <span class="toc-text">3. Redis 的持久化策略（RDB &#x2F; AOF &#x2F; 混合）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Redis-%E7%9A%84%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%88maxmemory-policy%EF%BC%89"><span class="toc-number">40.4.</span> <span class="toc-text">4. Redis 的缓存淘汰策略（maxmemory-policy）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%BB%E4%BB%8E-Sentinel-Cluster-third-party%EF%BC%89"><span class="toc-number">40.5.</span> <span class="toc-text">5. Redis 高可用实现（主从 + Sentinel &#x2F; Cluster &#x2F; third-party）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%88%A9%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%88%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%B3%A8%E6%84%8F%EF%BC%89"><span class="toc-number">40.6.</span> <span class="toc-text">6. 利用 Redis 实现分布式锁（正确方式与注意）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Redis-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">40.7.</span> <span class="toc-text">7. Redis 怎么实现延时消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Redis-%E4%B8%AD%E7%9A%84-String-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">40.8.</span> <span class="toc-text">8. Redis 中的 String 是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Redis-%E4%B8%AD-ZSet%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">40.9.</span> <span class="toc-text">9. Redis 中 ZSet（有序集合）怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BD%BF%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E6%8E%92%E8%A1%8C%E6%A6%9C%EF%BC%88Leaderboard%EF%BC%89"><span class="toc-number">40.10.</span> <span class="toc-text">10. 使用 Redis 实现排行榜（Leaderboard）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%88Service-Registry%EF%BC%89"><span class="toc-number">40.11.</span> <span class="toc-text">11. 用 Redis 实现注册中心（Service Registry）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Redis-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">40.12.</span> <span class="toc-text">12. Redis 的线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Redis-%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%88MULTI-EXEC-WATCH%EF%BC%89"><span class="toc-number">40.13.</span> <span class="toc-text">13. Redis 的事务（MULTI&#x2F;EXEC&#x2F;WATCH）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Redis-IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%EF%BC%89"><span class="toc-number">40.14.</span> <span class="toc-text">14. Redis IO 多路复用模型（实现细节）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Redis-%E7%9A%84%E5%A4%A7-key%EF%BC%88big-key%EF%BC%89%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0"><span class="toc-number">40.15.</span> <span class="toc-text">15. Redis 的大 key（big key）以及原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Redis-%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-number">40.16.</span> <span class="toc-text">16. Redis 的集群模式（工作原理）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis-%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F%E5%85%AB%E8%82%A1"><span class="toc-number">41.</span> <span class="toc-text">Mybatis-牛客面经八股</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">41.1.</span> <span class="toc-text">1. $ 与 # 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MyBatis-%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">41.2.</span> <span class="toc-text">2. MyBatis 的缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-MyBatis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%A4%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">41.3.</span> <span class="toc-text">3. MyBatis 实现一对多关联查询（两种主要方式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-MyBatis-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">41.4.</span> <span class="toc-text">4. MyBatis 如何防止 SQL 注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-MyBatis-%E5%92%8C-MyBatis-Plus-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">41.5.</span> <span class="toc-text">5. MyBatis 和 MyBatis-Plus 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-MyBatis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">41.6.</span> <span class="toc-text">6. MyBatis 如何实现分页查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-MyBatis-%E4%B8%AD%E5%8A%A8%E6%80%81-SQL-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">41.7.</span> <span class="toc-text">7. MyBatis 中动态 SQL 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-MyBatis-%E7%9A%84%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%EF%BC%88Interceptor%EF%BC%89"><span class="toc-number">41.8.</span> <span class="toc-text">8. MyBatis 的插件原理（Interceptor）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PageHelper-%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">41.8.1.</span> <span class="toc-text">PageHelper 插件原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-PageHelper-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">41.8.1.1.</span> <span class="toc-text">1. PageHelper 的使用方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-PageHelper-%E7%9A%84%E6%8B%A6%E6%88%AA%E7%82%B9"><span class="toc-number">41.8.1.2.</span> <span class="toc-text">2. PageHelper 的拦截点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-PageHelper-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B"><span class="toc-number">41.8.1.3.</span> <span class="toc-text">3. PageHelper 的核心流程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-PageHelper-startPage"><span class="toc-number">41.8.1.3.1.</span> <span class="toc-text">(1) PageHelper.startPage()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-PageInterceptor-%E6%8B%A6%E6%88%AA-query"><span class="toc-number">41.8.1.3.2.</span> <span class="toc-text">(2) PageInterceptor 拦截 query()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%89%A7%E8%A1%8C%E5%88%86%E9%A1%B5-SQL-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-number">41.8.1.3.3.</span> <span class="toc-text">(3) 执行分页 SQL &amp; 返回结果</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-PageHelper-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">41.8.1.4.</span> <span class="toc-text">4. PageHelper 的核心类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-PageHelper-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">41.8.1.5.</span> <span class="toc-text">5. PageHelper 的优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-PageHelper-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">41.8.1.6.</span> <span class="toc-text">6. PageHelper 的局限性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-number">41.8.1.7.</span> <span class="toc-text">7. 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-MyBatis-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C%E5%85%A8%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">41.9.</span> <span class="toc-text">9. MyBatis 底层原理（请求执行全流程）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F%E5%85%AB%E8%82%A1"><span class="toc-number">42.</span> <span class="toc-text">SQL-牛客面经八股</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-number">42.1.</span> <span class="toc-text">1. 什么是索引？索引有哪些分类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Hash-%E7%B4%A2%E5%BC%95-%E4%B8%8E-BTree-%E7%B4%A2%E5%BC%95-%E7%9A%84%E8%AF%A6%E7%BB%86%E5%8C%BA%E5%88%AB%EF%BC%88%E5%90%AB-InnoDB-%E7%89%B9%E4%BE%8B%EF%BC%89"><span class="toc-number">42.2.</span> <span class="toc-text">2. Hash 索引 与 BTree 索引 的详细区别（含 InnoDB 特例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88-MySQL-%E9%87%87%E7%94%A8-B-%E6%A0%91%EF%BC%9F"><span class="toc-number">42.3.</span> <span class="toc-text">3. 为什么 MySQL 采用 B+ 树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-B-%E6%A0%91%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">42.4.</span> <span class="toc-text">4. B+ 树查询数据的全过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%89%E5%B1%82-B-%E6%A0%91%E8%83%BD%E5%AD%98%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">42.5.</span> <span class="toc-text">5. 三层 B+ 树能存多少数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88Clustered%EF%BC%89-vs-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88Secondary%EF%BC%89"><span class="toc-number">42.6.</span> <span class="toc-text">6. 聚簇索引（Clustered） vs 非聚簇索引（Secondary）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E2%80%9C%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E2%80%9D%E5%8E%9F%E5%88%99"><span class="toc-number">42.7.</span> <span class="toc-text">7. 联合索引的存储结构与“最左前缀”原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-SELECT-IN-%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">42.8.</span> <span class="toc-text">8. SELECT IN &#x2F; 模糊查询 中如何使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">42.9.</span> <span class="toc-text">9. 建索引注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0-%E5%88%A4%E6%96%AD%E7%B4%A2%E5%BC%95%E6%98%AF%E5%90%A6%E7%94%9F%E6%95%88%EF%BC%9F%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%E8%AF%A6%E5%B0%BD%E5%88%97%E4%B8%BE"><span class="toc-number">42.10.</span> <span class="toc-text">10. 如何评估 &#x2F; 判断索引是否生效？常见索引失效场景详尽列举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%90%8E%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">42.11.</span> <span class="toc-text">11. 索引失效后怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E9%87%8D%E6%9E%84%E8%BF%87%E7%A8%8B%EF%BC%88%E7%BA%BF%E4%B8%8A%E9%9B%B6%E5%81%9C%E6%9C%BA%E5%AE%9E%E8%B7%B5%EF%BC%89"><span class="toc-number">42.12.</span> <span class="toc-text">12. 数据库索引重构过程（线上零停机实践）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%A8-B-%E6%A0%91%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">42.13.</span> <span class="toc-text">13. 为什么数据库用 B+ 树不使用红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E9%A1%B5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">42.14.</span> <span class="toc-text">14. 数据库分页的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-LIMIT-100000000-10-%E4%B8%8E-LIMIT-10-%E6%80%A7%E8%83%BD%E5%B7%AE%E5%BC%82"><span class="toc-number">42.15.</span> <span class="toc-text">15. LIMIT 100000000,10 与 LIMIT 10 性能差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-EXPLAIN-%E5%88%86%E6%9E%90%E6%9F%A5%E8%AF%A2%EF%BC%9F%E5%85%B3%E6%B3%A8%E5%93%AA%E4%BA%9B%E5%88%97%E4%B8%8E%E5%90%AB%E4%B9%89"><span class="toc-number">42.16.</span> <span class="toc-text">16. 如何使用 EXPLAIN 分析查询？关注哪些列与含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-COUNT-%E3%80%81COUNT-1-%E3%80%81COUNT-%E5%88%97-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">42.17.</span> <span class="toc-text">17. COUNT(*)、COUNT(1)、COUNT(列) 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-SQL-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">42.18.</span> <span class="toc-text">18. SQL 聚合函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-WHERE-%E4%B8%8E-HAVING-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-number">42.19.</span> <span class="toc-text">19. WHERE 与 HAVING 的区别）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-EXISTS-%E4%B8%8E-IN-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%90%AB-NULL-%E8%AF%AD%E4%B9%89%E5%B7%AE%E5%BC%82%EF%BC%89"><span class="toc-number">42.20.</span> <span class="toc-text">20. EXISTS 与 IN 的区别（含 NULL&#x2F;语义差异）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-SQL-%E6%B3%A8%E5%85%A5-%E5%8F%8A-%E9%98%B2%E8%8C%83"><span class="toc-number">42.21.</span> <span class="toc-text">21. SQL 注入 及 防范</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5-%E2%80%94-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%85%B8%E5%9E%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number"></span> <span class="toc-text">SQL 注入 — 原理与典型示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD%EF%BC%88%E6%A0%B8%E5%BF%83%E4%B8%8E%E5%AE%9E%E8%B7%B5%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">防护措施（核心与实践）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8F%82%E6%95%B0%E5%8C%96%E6%9F%A5%E8%AF%A2-PreparedStatement%EF%BC%88%E6%9C%80%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">1. 参数化查询 &#x2F; PreparedStatement（最重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%99%BD%E5%90%8D%E5%8D%95%E6%A0%A1%E9%AA%8C%EF%BC%88%E7%94%A8%E4%BA%8E%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E6%8E%92%E5%BA%8F%E5%AD%97%E6%AE%B5%E7%AD%89%E4%B8%8D%E8%83%BD%E7%94%A8%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">2. 白名单校验（用于标识符、排序字段等不能用占位符的场景）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%80%E5%B0%8F%E6%9D%83%E9%99%90%E5%8E%9F%E5%88%99"><span class="toc-number">3.</span> <span class="toc-text">3. 最小权限原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%BE%93%E5%87%BA%E8%BD%AC%E4%B9%89%EF%BC%88%E8%BE%85%E5%8A%A9%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">4. 输入验证与输出转义（辅助）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8-ORM-%E6%9F%A5%E8%AF%A2%E6%9E%84%E5%BB%BA%E5%99%A8%EF%BC%88%E5%B9%B6%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0%E5%8C%96-API%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">5. 使用 ORM &#x2F; 查询构建器（并正确使用参数化 API）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%98%B2%E7%81%AB%E5%A2%99-%E7%9B%91%E6%8E%A7-%E5%AE%A1%E8%AE%A1"><span class="toc-number">6.</span> <span class="toc-text">6. 防火墙 &#x2F; 监控 &#x2F; 审计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%B8%8D%E8%A6%81%E7%9B%B4%E6%8E%A5%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8D%E5%8F%AF%E4%BF%A1%E6%95%B0%E6%8D%AE-%E9%81%BF%E5%85%8D-eval"><span class="toc-number">7.</span> <span class="toc-text">7. 不要直接反序列化不可信数据 &#x2F; 避免 eval</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%AF%B9%E6%AF%94%EF%BC%88%E6%98%93%E8%AF%BB%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">示例对比（易读）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E5%8F%AF%E8%83%BD%E8%BF%BD%E9%97%AE%E4%B8%8E%E7%AE%80%E6%B4%81%E5%9B%9E%E7%AD%94%E8%A6%81%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">其他面试可能追问与简洁回答要点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E4%B8%80%E5%88%86%E7%A7%8D%E5%BF%AB%E9%80%9F%E7%AD%94%E6%B3%95%EF%BC%88%E5%8F%AF%E8%83%8C%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">面试一分种快速答法（可背）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%B0%86%E4%B8%80%E5%BC%A0%E8%A1%A8%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%88%B0%E5%8F%A6%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%88%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">22. 将一张表部分数据更新到另一张表（多种方式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%A6%82%E4%BD%95%E5%B0%86%E8%A1%8C%E8%BD%AC%E6%88%90%E5%88%97%EF%BC%88%E8%A1%8C%E5%88%97%E8%BD%AC%E6%8D%A2-Pivot%EF%BC%89%E2%80%94%E2%80%94%E5%B8%B8%E8%A7%81-SQL-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">23. 如何将行转成列（行列转换 &#x2F; Pivot）——常见 SQL 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E8%A1%A8%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94%EF%BC%88%E5%85%B3%E8%81%94%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">24. 表之间如何关联（关联方式详解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-INNER-LEFT-RIGHT-JOIN-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%B8%A6%E4%BE%8B%E5%AD%90%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">25. INNER &#x2F; LEFT &#x2F; RIGHT JOIN 的区别（带例子）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E5%A4%9A%E8%A1%A8-JOIN%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">26. 为什么不推荐多表 JOIN？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-SQL-%E8%B0%83%E4%BC%98%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">27. SQL 调优常见方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%B9%B6%E4%BC%98%E5%8C%96%E6%85%A2-SQL%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">28. 如何监控并优化慢 SQL）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.</span> <span class="toc-text">29. 如何高效批量插入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E5%A4%A7%E8%A1%A8%EF%BC%88%E5%8D%83%E4%B8%87%E7%BA%A7%EF%BC%89%E6%9F%A5%E8%AF%A2-%E7%BB%B4%E6%8A%A4"><span class="toc-number">1.9.</span> <span class="toc-text">30. 大表（千万级）查询 &#x2F; 维护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-DELETE%E3%80%81TRUNCATE%E3%80%81DROP-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.</span> <span class="toc-text">31. DELETE、TRUNCATE、DROP 区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F%E5%85%AB%E8%82%A1"><span class="toc-number">2.</span> <span class="toc-text">Java多线程-牛客面经八股</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%88Java-%E4%B8%AD%E5%B8%B8%E8%A7%81-4-%E7%A7%8D%E3%80%81%E5%8F%8A%E5%AE%9E%E9%99%85%E5%B7%A5%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">1. 线程的创建方式（Java 中常见 4 种、及实际工程常用模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81%EF%BC%88Java-Thread-State%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2. 线程的生命周期和状态（Java Thread.State）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-wait-%E4%B8%8E-sleep-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">3. wait() 与 sleep() 的区别（关键点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">4. 线程同步方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-synchronized-%E4%B8%8E-Lock-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">5. synchronized 与 Lock 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-synchronized-%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.</span> <span class="toc-text">6. synchronized 的用法及原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AF%B9-AQS%EF%BC%88AbstractQueuedSynchronizer%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E3%80%81%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">7. 对 AQS（AbstractQueuedSynchronizer）的理解（关键概念、内部结构与工作流程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88ThreadPoolExecutor-%E6%B7%B1%E5%85%A5%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">8. 如何创建线程池？线程池常见参数有哪些？（ThreadPoolExecutor 深入）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-volatile-%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%EF%BC%88Java-%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">9. volatile 的用法及原理（Java 内存语义）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-ThreadLocal-%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88ThreadLocalMap%EF%BC%89"><span class="toc-number">2.10.</span> <span class="toc-text">10. ThreadLocal 的用法和实现原理（ThreadLocalMap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Java-%E9%87%8C%E7%9A%84-CAS%EF%BC%88Compare-And-Swap%EF%BC%89%EF%BC%88%E6%A6%82%E5%BF%B5-%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">11. Java 里的 CAS（Compare-And-Swap）（概念 + 使用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-CAS-%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9FABA-%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">12. CAS 会出现什么问题？ABA 问题如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Java-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB%EF%BC%88%E6%A6%82%E5%BF%B5%E4%B8%8E-HotSpot-%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">2.13.</span> <span class="toc-text">13. Java 线程与操作系统线程区别（概念与 HotSpot 实现）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Java-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81%EF%BC%9F%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">14. Java 中如何检测死锁？如何预防和避免线程死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%86%99%E4%B8%80%E4%B8%AA-Java-%E6%AD%BB%E9%94%81%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%88%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-number">2.15.</span> <span class="toc-text">15. 写一个 Java 死锁的例子（示例代码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-volatile-%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B9%88%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">16. volatile 可以保证原子性么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">17. 公平锁与非公平锁有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88%E6%80%9D%E6%83%B3-%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">2.18.</span> <span class="toc-text">18. 乐观锁与悲观锁（思想 + 典型实现）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%86%8D%E5%AF%B9%E6%AF%94%EF%BC%89"><span class="toc-number">2.19.</span> <span class="toc-text">19. synchronized 和 volatile 的区别（再对比）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-ReentrantLock-%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">2.20.</span> <span class="toc-text">20. ReentrantLock 的定义和特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-ReentrantReadWriteLock-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.21.</span> <span class="toc-text">21. ReentrantReadWriteLock 的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%A6%82%E4%BD%95%E5%AF%BC%E8%87%B4%E7%9A%84%EF%BC%9F"><span class="toc-number">2.22.</span> <span class="toc-text">22. ThreadLocal 内存泄露如何导致的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%88BlockingQueue%EF%BC%89"><span class="toc-number">2.23.</span> <span class="toc-text">23. 线程池常用的阻塞队列（BlockingQueue）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E4%BD%BF%E5%85%B6%E6%8C%89%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%E8%BF%90%E8%A1%8C%EF%BC%88%E6%80%9D%E8%B7%AF-%E6%B3%A8%E6%84%8F%EF%BC%89"><span class="toc-number">2.24.</span> <span class="toc-text">24. 设计一个线程池，使其按任务优先级运行（思路 + 注意）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-Callable-%E5%92%8C-Future%EF%BC%88%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">2.25.</span> <span class="toc-text">25. Callable 和 Future（区别与使用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-Semaphore-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BC%88%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%94%A8%E9%80%94%EF%BC%89"><span class="toc-number">2.26.</span> <span class="toc-text">26. Semaphore 有什么用？（原理与常见用途）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-CountDownLatch-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BC%88%E7%94%A8%E9%80%94%E3%80%81%E5%86%85%E9%83%A8%E4%B8%8E%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">2.27.</span> <span class="toc-text">27. CountDownLatch 有什么用？（用途、内部与示例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%EF%BC%9A%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94%E6%89%A9%E5%B1%95%EF%BC%88%E7%B2%BE%E9%80%89%E5%BA%94%E7%AD%94%EF%BC%89"><span class="toc-number">2.28.</span> <span class="toc-text">附：一些常见面试问答扩展（精选应答）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F%E5%85%AB%E8%82%A1"><span class="toc-number">3.</span> <span class="toc-text">测试理论基础-牛客面经八股</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1、黑盒测试与白盒测试的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F%E6%8F%90Bug%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E7%82%B9%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">3、测试用例设计时需要注意什么？提Bug需要注意哪些点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BA%86%E8%A7%A3Bug%E7%9A%84%E9%80%83%E9%80%B8%E7%8E%87%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E9%99%8D%E4%BD%8E%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">4、了解Bug的逃逸率吗？怎么降低？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E6%98%AF%E6%80%8E%E4%B9%88%E5%86%99%E7%9A%84%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">5、测试报告是怎么写的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E4%BD%A0%E6%9C%89%E6%B2%A1%E6%9C%89%E6%8E%A5%E8%A7%A6%E4%B8%80%E4%BA%9B%E5%92%8CAI%E7%9B%B8%E5%85%B3%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">6、你有没有接触一些和AI相关的自动化测试？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E5%93%AA%E4%BA%9B%E6%8C%87%E6%A0%87%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">7、性能测试怎么做？需要关注哪些指标？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AABug%E6%98%AF%E5%89%8D%E7%AB%AF%E8%BF%98%E6%98%AF%E5%90%8E%E7%AB%AF%E5%BC%95%E8%B5%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">8、如何判断一个Bug是前端还是后端引起的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%8F%82%E6%95%B0%E5%8C%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.8.</span> <span class="toc-text">9、接口测试工具及方法、接口自动化框架搭建及参数化实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E9%99%A4%E4%BA%86%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E3%80%81%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E6%B5%8B%E8%AF%95%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">10、除了功能测试、性能测试，还有什么测试类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E5%8F%91%E7%8E%B0%E4%BA%86%E6%94%AF%E4%BB%98%E6%88%90%E5%8A%9F%E4%BD%86%E5%90%8E%E5%8F%B0%E8%AE%A2%E5%8D%95%E6%9C%AA%E7%94%9F%E6%88%90%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%8E%E5%8F%91%E7%8E%B0%E5%88%B0%E6%8F%90%E4%BA%A4Bug%E4%BC%9A%E5%81%9A%E5%93%AA%E4%BA%9B%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">11、发现了支付成功但后台订单未生成的问题，从发现到提交Bug会做哪些工作？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-HTTPS-%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F%E5%85%AB%E8%82%A1"><span class="toc-number">4.</span> <span class="toc-text">HTTP&#x2F;HTTPS-牛客面经八股</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81HTTP-1-0%E3%80%81HTTP-1-1%E3%80%81HTTP-2-0%E3%80%81HTTP-3-0-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1、HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2.0、HTTP&#x2F;3.0 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81HTTP-%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2、HTTP 常见状态码有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81HTTP-%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD%E5%88%B0%E5%BA%95%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3、HTTP 请求头中到底包含什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81HTTP-%E6%98%AF%E5%9F%BA%E4%BA%8E-TCP-%E8%BF%98%E6%98%AF-UDP%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">4、HTTP 是基于 TCP 还是 UDP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81HTTP-%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">5、HTTP 常见字段有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81HTTP-%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%BC%93%E5%AD%98%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">6、HTTP 的缓存机制，服务器如何判断缓存是否过期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81HTTP-%E9%95%BF%E8%BF%9E%E6%8E%A5-vs-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">4.7.</span> <span class="toc-text">7、HTTP 长连接 vs 短连接的区别是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E4%BB%8E%E3%80%8C%E6%95%B2%E4%B8%8B%E4%B8%80%E4%B8%AA-URL%E3%80%8D%E5%88%B0%E3%80%8C%E9%A1%B5%E9%9D%A2%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%B1%8F%E5%B9%95%E3%80%8D%E6%95%B4%E6%9D%A1%E9%93%BE%E8%B7%AF%E5%85%A8%E6%99%AF"><span class="toc-number">4.8.</span> <span class="toc-text">8、从「敲下一个 URL」到「页面出现在屏幕」整条链路全景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%9F%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.9.</span> <span class="toc-text">9、什么是重定向？重定向与请求转发的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81GET-%E4%B8%8E-POST-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.10.</span> <span class="toc-text">10、GET 与 POST 有什么区别?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%AD%E4%B9%89%EF%BC%88%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-number">4.10.1.</span> <span class="toc-text">1. 语义（核心区别）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-number">4.10.2.</span> <span class="toc-text">2. 参数传递方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">4.10.3.</span> <span class="toc-text">3. 缓存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">4.10.4.</span> <span class="toc-text">4. 安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%80%A7%E8%83%BD%E4%B8%8E-TCP-%E5%B1%82%E9%9D%A2"><span class="toc-number">4.10.5.</span> <span class="toc-text">5. 性能与 TCP 层面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.10.6.</span> <span class="toc-text">6. 应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%91-%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%80%BB%E7%BB%93%E5%9B%9E%E7%AD%94"><span class="toc-number">4.10.7.</span> <span class="toc-text">🔑 面试高频总结回答</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81HTTP-vs-HTTPS-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.11.</span> <span class="toc-text">11、HTTP vs. HTTPS 有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81HTTPS-%E7%9A%84%E3%80%8C%E7%A7%98%E9%92%A5%E4%BA%A4%E6%8D%A2-%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C%E3%80%8D%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">4.12.</span> <span class="toc-text">12、HTTPS 的「秘钥交换 + 证书校验」全流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81HTTPS%EF%BC%88TLS%EF%BC%89%E9%87%8C%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">4.13.</span> <span class="toc-text">13、HTTPS（TLS）里都用到了哪些加密算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81WebSocket-%E7%AE%80%E4%BB%8B-%E4%B8%8E-HTTP-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-number">4.14.</span> <span class="toc-text">14、WebSocket 简介 &amp; 与 HTTP 的核心区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81WebSocket-%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">4.15.</span> <span class="toc-text">15、WebSocket 的工作过程是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81SSE%EF%BC%88Server-Sent-Events%EF%BC%89%E4%B8%8E-WebSocket-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.16.</span> <span class="toc-text">16、SSE（Server-Sent Events）与 WebSocket 有什么区别?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F%E5%85%AB%E8%82%A1"><span class="toc-number">5.</span> <span class="toc-text">分布式-牛客面经八股</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E2%80%94-%E5%8C%BA%E5%88%AB%E4%B8%8E%E9%98%B2%E6%8A%A4"><span class="toc-number">5.1.</span> <span class="toc-text">1. 缓存穿透 &#x2F; 缓存击穿 &#x2F; 缓存雪崩 — 区别与防护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Redis-%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E6%8C%81%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%A1%88%EF%BC%88%E6%9D%83%E8%A1%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">2. Redis 与数据库保持双写一致性的常见方案（权衡与实现）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88Bloom-Filter%EF%BC%89%E5%8E%9F%E7%90%86%E3%80%81%E5%85%AC%E5%BC%8F%E3%80%81%E5%8F%98%E4%BD%93%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="toc-number">5.3.</span> <span class="toc-text">3. 布隆过滤器（Bloom Filter）原理、公式、变体与实战</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/01/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/" title="牛客面试题">牛客面试题</a><time datetime="2025-09-30T16:00:00.000Z" title="发表于 2025-10-01 00:00:00">2025-10-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/23/%E7%AE%80%E6%98%93%E7%89%88%E9%A2%98%E7%9B%AE/" title="简易版题目">简易版题目</a><time datetime="2025-09-22T16:00:00.000Z" title="发表于 2025-09-23 00:00:00">2025-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/22/go/" title="go">go</a><time datetime="2025-09-21T16:00:00.000Z" title="发表于 2025-09-22 00:00:00">2025-09-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/22/%E6%80%BB%E7%BB%93/" title="要点提纲">要点提纲</a><time datetime="2025-09-21T16:00:00.000Z" title="发表于 2025-09-22 00:00:00">2025-09-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/22/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" title="文件上传">文件上传</a><time datetime="2025-09-21T16:00:00.000Z" title="发表于 2025-09-22 00:00:00">2025-09-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bg.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Charlotte</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
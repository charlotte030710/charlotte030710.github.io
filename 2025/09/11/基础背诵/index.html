<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基础背诵 | 浮生若梦</title><meta name="author" content="Charlotte"><meta name="copyright" content="Charlotte"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网络基础OSI七层模型OSI (Open Systems Interconnection) 参考模型是一个抽象的、概念性的框架，旨在定义网络通信的功能分层，促进不同系统之间的互操作性。它将网络通信过程分为七个独立的层次，每层负责特定的功能。数据在发送端从上层向下层传输，每层添加自己的控制信息（封装），在接收端则从下层向上层传输，每层剥离对应的控制信息（解封装）。  物理层 (Physical La">
<meta property="og:type" content="article">
<meta property="og:title" content="基础背诵">
<meta property="og:url" content="http://example.com/2025/09/11/%E5%9F%BA%E7%A1%80%E8%83%8C%E8%AF%B5/index.html">
<meta property="og:site_name" content="浮生若梦">
<meta property="og:description" content="网络基础OSI七层模型OSI (Open Systems Interconnection) 参考模型是一个抽象的、概念性的框架，旨在定义网络通信的功能分层，促进不同系统之间的互操作性。它将网络通信过程分为七个独立的层次，每层负责特定的功能。数据在发送端从上层向下层传输，每层添加自己的控制信息（封装），在接收端则从下层向上层传输，每层剥离对应的控制信息（解封装）。  物理层 (Physical La">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/title.jpg">
<meta property="article:published_time" content="2025-09-11T10:29:28.000Z">
<meta property="article:modified_time" content="2025-09-11T10:29:28.011Z">
<meta property="article:author" content="Charlotte">
<meta property="article:tag" content="Hexo, Markdown">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/title.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基础背诵",
  "url": "http://example.com/2025/09/11/%E5%9F%BA%E7%A1%80%E8%83%8C%E8%AF%B5/",
  "image": "http://example.com/img/title.jpg",
  "datePublished": "2025-09-11T10:29:28.000Z",
  "dateModified": "2025-09-11T10:29:28.011Z",
  "author": [
    {
      "@type": "Person",
      "name": "Charlotte",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="http://example.com/2025/09/11/%E5%9F%BA%E7%A1%80%E8%83%8C%E8%AF%B5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基础背诵',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="浮生若梦" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/title.jpg" alt="Logo"><span class="site-name">浮生若梦</span></a><a class="nav-page-title" href="/"><span class="site-name">基础背诵</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">基础背诵</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-11T10:29:28.011Z" title="更新于 2025-09-11 18:29:28">2025-09-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>OSI (Open Systems Interconnection) 参考模型是一个抽象的、概念性的框架，旨在定义网络通信的功能分层，促进不同系统之间的互操作性。它将网络通信过程分为七个独立的层次，每层负责特定的功能。数据在发送端从上层向下层传输，每层添加自己的控制信息（封装），在接收端则从下层向上层传输，每层剥离对应的控制信息（解封装）。</p>
<ol>
<li><h3 id="物理层-Physical-Layer"><a href="#物理层-Physical-Layer" class="headerlink" title="物理层 (Physical Layer)"></a>物理层 (Physical Layer)</h3></li>
</ol>
<ul>
<li>功能：负责传输比特流，即原始的二进制数据。定义了物理媒介的电气特性、机械特性、功能特性和过程特性。</li>
<li>工作方式：不关心比特的含义，只负责将其从一个节点传输到另一个节点。例如，规定网络的接口形状、电压、传输速率等。</li>
<li>协议&#x2F;设备：网线 (Ethernet Cable)、光纤 (Fiber Optic)、集线器 (Hub)、中继器 (Repeater)、网卡 (NIC) 的物理部分。</li>
<li>数据单位：比特 (Bit)。</li>
</ul>
<ol start="2">
<li><h3 id="数据链路层-Data-Link-Layer"><a href="#数据链路层-Data-Link-Layer" class="headerlink" title="数据链路层 (Data Link Layer)"></a>数据链路层 (Data Link Layer)</h3></li>
</ol>
<ul>
<li>功能：在物理层提供的不可靠比特流服务的基础上，将比特组合成帧，提供节点到节点之间的数据传输。负责差错控制（检测和纠正帧传输错误）、流量控制（防止发送方传输速度过快）和物理寻址 (MAC 地址）。</li>
<li>子层：通常分为 LLC (Logical Link Control) 子层（负责逻辑链路控制，向上层提供服务接口）和 MAC (Media Access Control) 子层（负责媒体访问控制，处理共享介质的访问，例如 CSMA&#x2F;CD 协议）。</li>
<li>工作方式：在局域网内，通过 MAC 地址识别不同的设备，确保数据能够正确地在相邻节点之间传输。</li>
<li>协议&#x2F;设备：Ethernet、PPP (Point-to-Point Protocol)、交换机 (Switch)、网桥 (Bridge)。</li>
<li>数据单位：帧 (Frame)。</li>
</ul>
<ol start="3">
<li><h3 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层 (Network Layer)"></a>网络层 (Network Layer)</h3></li>
</ol>
<ul>
<li>功能：负责将数据包从源主机传输到目标主机，可能需要跨越多个网络（即路由）。主要功能包括逻辑寻址 (IP 地址)、路由选择（确定数据包传输路径）和拥塞控制。</li>
<li>工作方式：根据数据包中的 IP 地址，通过路由表决定数据包的转发路径，使其能够跨越不同的网络到达最终目的地。</li>
<li>协议&#x2F;设备：IP (Internet Protocol)、ICMP (Internet Control Message Protocol，用于错误报告和查询)、IGMP (Internet Group Management Protocol，用于多播组管理)、路由器 (Router)。</li>
<li>数据单位：数据包 (Packet) 或 数据报 (Datagram)。</li>
</ul>
<ol start="4">
<li><h3 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层 (Transport Layer)"></a>传输层 (Transport Layer)</h3></li>
</ol>
<ul>
<li>功能：负责端到端 (End-to-End) 的数据传输，即从源主机上的某个进程到目标主机上的某个进程的通信。提供分段与重组、错误检测、流量控制和拥塞控制。</li>
<li>工作方式：通过端口号来标识应用进程，使得数据能够正确地交付给目标主机上的特定应用程序。</li>
<li>协议&#x2F;设备：<ul>
<li>TCP (Transmission Control Protocol)：面向连接、可靠的、基于字节流的服务，提供顺序、无损的数据传输。</li>
<li>UDP (User Datagram Protocol)：无连接、不可靠的数据报服务，速度快，开销小，适用于对实时性要求高但允许少量丢包的应用（如音视频传输）。</li>
</ul>
</li>
<li>数据单位：报文段 (Segment) (TCP) 或 用户数据报 (Datagram) (UDP)。</li>
</ul>
<ol start="5">
<li><h3 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层 (Session Layer)"></a>会话层 (Session Layer)</h3></li>
</ol>
<ul>
<li>功能：负责管理和协调应用程序之间的会话(对话)。包括建立、管理和终止会话，以及数据同步(如设置同步点，在网络故障时从上一个同步点恢复)。</li>
<li>工作方式：提供了一种机制，使得应用程序可以有条不紊地进行通信，例如，在一次文件传输中，可以在传输中断后从断点续传。</li>
<li>协议&#x2F;设备：NetBIOS, RPC (Remote Procedure Call), SQL, NFS。</li>
<li>数据单位：会话数据 (Session Data)。</li>
</ul>
<ol start="6">
<li><h3 id="表示层-Presentation-Layer"><a href="#表示层-Presentation-Layer" class="headerlink" title="表示层 (Presentation Layer)"></a>表示层 (Presentation Layer)</h3></li>
</ol>
<ul>
<li>功能：负责处理两个系统之间的数据表示，确保应用程序层接收到的信息是可用的。包括数据格式化、数据加密&#x2F;解密、数据压缩&#x2F;解压缩。</li>
<li>工作方式：将应用层的数据转换为网络标准格式(如 ASCII 转 EBCDIC)，或将网络格式的数据转换为应用层可用的格式。例如，JPEG, MPEG 等图像视频格式的处理，以及 SSL&#x2F;TLS 加密解密。</li>
<li>协议&#x2F;设备：JPEG, MPEG, ASCII, Unicode, TLS&#x2F;SSL (通常认为 TLS&#x2F;SSL 位于会话层与表示层之间，或独立于此)。</li>
<li>数据单位：表示数据 (Presentation Data)。</li>
</ul>
<ol start="7">
<li><h3 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层 (Application Layer)"></a>应用层 (Application Layer)</h3></li>
</ol>
<ul>
<li>功能：最靠近用户的一层，为用户提供网络服务。直接与用户应用程序进行交互，负责处理特定的应用程序细节。</li>
<li>工作方式：定义了应用程序如何访问网络服务，以及不同应用程序之间如何交换数据。</li>
<li>协议&#x2F;设备：HTTP (Web 浏览)、FTP (文件传输)、SMTP (电子邮件发送)、POP3&#x2F;IMAP (电子邮件接收)、DNS (域名解析)、Telnet, SNMP (简单网络管理协议)等。</li>
<li>数据单位：应用数据 (Application Data)。</li>
</ul>
<h2 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP&#x2F;IP 协议族"></a>TCP&#x2F;IP 协议族</h2><p>TCP&#x2F;IP 模型是互联网的基础，它简化了 OSI 模型，通常分为四层：应用层、传输层、网络层、网络接口层（数据链路层和物理层合并）。我重点阐述其中的核心协议：</p>
<ul>
<li>TCP（传输控制协议）：我理解 TCP 是一种可靠的、面向连接的、基于字节流的传输协议。其可靠性通过以下机制实现：<ul>
<li><p>三次握手：这是 TCP 建立连接的过程，旨在确保通信双方都能正常收发数据，并协商初始序列号。这个过程就像打电话：</p>
<ol>
<li>第一次握手 (SYN)：</li>
</ol>
<ul>
<li>发起方：客户端。</li>
<li>报文类型：SYN 报文段 (SYN_FLAG&#x3D;1)。SYN 标志位表示请求建立连接。</li>
<li>序列号 (Sequence Number)：客户端随机生成一个初始序列号 client_ISN。这个序列号代表客户端接下来发送数据的第一个字节的序号。</li>
<li>确认号 (Acknowledgment Number)：0（或随机值，但在此次请求中无实际意义，因为是首次请求，尚未收到对方的数据）。</li>
<li>窗口大小 (Window Size)：客户端告知服务器自己的接收窗口大小 W1，用于流量控制。</li>
<li>客户端状态变化：客户端从 CLOSED 状态转换到 SYN_SENT 状态。</li>
<li>作用：客户端向服务器发送连接请求，并告知服务器自己发送数据时将使用的起始序列号 client_ISN。此时客户端进入同步发送状态，等待服务器确认。</li>
</ul>
<ol start="2">
<li>第二次握手 (SYN-ACK)：</li>
</ol>
<ul>
<li>发起方：服务器。</li>
<li>报文类型：SYN-ACK 报文段 (SYN_FLAG&#x3D;1, ACK_FLAG&#x3D;1)。SYN 标志位表示同意建立连接并发送自己的初始序列号，ACK 标志位表示确认收到客户端的请求。</li>
<li>序列号 (Sequence Number)：服务器随机生成一个初始序列号 server_ISN。这个序列号代表服务器接下来发送数据的第一个字节的序号。</li>
<li>确认号 (Acknowledgment Number)：服务器发送 ack &#x3D; client_ISN + 1。这表示服务器已成功接收到客户端的 SYN 报文（其序列号为 client_ISN），并期望接收客户端的下一个字节的序列号是 client_ISN + 1。</li>
<li>窗口大小 (Window Size)：服务器告知客户端自己的接收窗口大小 W2，用于流量控制。</li>
<li>服务器状态变化：服务器收到客户端的 SYN 后，从 LISTEN 状态转换到 SYN_RCVD 状态。发送 SYN-ACK 后，服务器仍然处于 SYN_RCVD 状态。</li>
<li>作用：服务器确认已收到客户端端的 SYN 请求，并同意建立连接，同时告知客户端自己发送数据时将使用的起始序列号 server_ISN，并确认收到了客户端的 SYN 报文。</li>
</ul>
<ol start="3">
<li>第三次握手（ACK）：</li>
</ol>
<ul>
<li>发起方：客户端。</li>
<li>报文类型：ACK 报文段（ACK_FLAG&#x3D;1）。ACK 标志位表示确认收到服务器的响应。</li>
<li>序列号（Sequence Number）：客户端发送 seq &#x3D; client_ISN + 1。这表示客户端的 SYN 报文已经消耗了一个序列号，现在数据将从 client_ISN + 1 开始发送。</li>
<li>确认号（Acknowledgment Number）：客户端发送 ack &#x3D; server_ISN + 1。这表示客户端已成功接收到服务器的 SYN-ACK 报文（其序列号为 server_ISN），并期望接收服务器的下一个字节的序列号是 server_ISN + 1。</li>
<li>客户端状态变化：客户端收到服务器的 SYN-ACK 后，从 SYN_SENT 状态转换到 ESTABLISHED 状态。</li>
<li>服务器状态变化：服务器收到客户端的 ACK 后，从 SYN_RCVD 状态转换到 ESTABLISHED 状态。</li>
<li>作用：客户端确认已收到服务器的 SYN-ACK，并告知服务器已经准备好发送和接收数据。至此，客户端和服务器都确认了对方的收发能力，以及彼此的初始序列号。连接正式建立，可以开始数据传输。</li>
</ul>
</li>
<li><p>为什么需要三次握手？</p>
<ul>
<li>防止已失效的连接请求报文段突然又传到服务器，导致错误建立连接。如果只有两次握手，客户端发送的第一个连接请求（SYN报文）因网络延迟迟迟未到服务器，客户端随时重传并成功建立了连接并传输了数据。旧的SYN报文在某个时刻到达了服务器，服务器收到后会以为是新的连接请求，发送SYN-ACK给客户端。如果只有两次握手，服务器会认为连接建立成功并进入ESTABLISHED状态，但客户端已经处理完之前的连接并关闭，不会理会服务器。这会导致服务器一直等待客户端发送数据，浪费资源。三次握手确保客户端能识别出这是旧的SYN，从而不发送ACK，服务器也就不会进入ESTABLISHED。</li>
<li>确保双方都具备发送和接收能力。<ul>
<li>第一次握手：客户端发送 SYN，服务器收到。服务器能确认客户端能发。</li>
<li>第二次握手：服务器发送 SYN-ACK，客户端收到。客户端能确认服务器能收也能发。</li>
<li>第三次握手：客户端发送 ACK，服务器收到。服务器能确认客户端能收。</li>
<li>至此，双方都确认了对方的“发”和“收”能力，实现了双向的同步确认。</li>
</ul>
</li>
</ul>
</li>
<li><p>四次握手：这是 TCP 终止连接的过程，目的是确保全双工连接的两个方向都能独立、优雅地关闭，避免数据丢失。由于 TCP 是全双工的，每个方向的数据传输都需要独立关闭。</p>
<ul>
<li><p>全双工特性：TCP 连接是全双工的，这意味着数据可以在两个方向上独立传输。当一方完成数据发送时，另一方可能仍然有数据需要发送。</p>
</li>
<li><p>假设客户端主动关闭连接：</p>
<ol>
<li>第一次挥手（FIN）：</li>
</ol>
<ul>
<li>发起方：客户端（数据发送完毕，想关闭发送方向）。</li>
<li>报文类型：FIN 报文段（FIN_FLAG&#x3D;1, ACK_FLAG&#x3D;1）。FIN 标志位表示发送方没有数据要发送了。</li>
<li>序列号（Sequence Number）：seq &#x3D; u（其中 u 是客户端上次发送的最后一个字节的序列号加 1）。</li>
<li>确认号（Acknowledgment Number）：ack &#x3D; v（如果之前收到了服务器的数据，这是对服务器最近一次发送数据包的确认号）。</li>
<li>客户端状态变化：客户端从 ESTABLISHED 状态转换到 FIN_WAIT_1 状态。</li>
<li>作用：客户端告知服务器，它已经没有数据要发送了，它单方面地关闭了发送方向的连接。但是，客户端仍然可以接收服务器发送的数据。</li>
</ul>
<ol start="2">
<li>第二次挥手（ACK）：</li>
</ol>
<ul>
<li>发起方：服务器。</li>
<li>报文类型：ACK 报文段（ACK_FLAG&#x3D;1）。</li>
<li>序列号（Sequence Number）：seq &#x3D; v（服务器上次发送的最后一个字节的序列号加 1）。</li>
<li>确认号（Acknowledgment Number）：ack &#x3D; u + 1。这表示服务器已成功接收到客户端的 FIN 报文段，并期望接收客户端的下一个字节的序列号是 u + 1（尽管客户端已经表示不再发送数据，这只是一个确认）。</li>
<li>服务器状态变化：服务器收到客户端的 FIN 后，从 ESTABLISHED 状态转换到 CLOSE_WAIT 状态。</li>
<li>客户端状态变化：客户端收到服务器的 ACK 后，从 FIN_WAIT_1 状态转换到 FIN_WAIT_2 状态。</li>
<li>作用：服务器确认已收到客户端的关闭请求。此时，客户端到服务器方向的连接已半关闭。服务器处于 CLOSE_WAIT 状态，这意味着服务器应用层还在处理数据或者还有数据需要发送给客户端。这个状态会持续到服务器端也准备好关闭连接。</li>
</ul>
<ol start="3">
<li>第三次挥手（FIN）：</li>
</ol>
<ul>
<li>发起方：服务器（当服务器也发送完所有数据，并且准备关闭自己的发送方向时）。</li>
<li>报文类型：FIN 报文段 (FIN_FLAG&#x3D;1, ACK_FLAG&#x3D;1)。</li>
<li>序列号 (Sequence Number)：seq &#x3D; w (服务器上次发送的最后一个字节的序列号加 1, w 可能等于 v, 如果服务器在发送 ACK 后没有再发送数据)。</li>
<li>确认号 (Acknowledgment Number)：ack &#x3D; u + 1 (再次确认客户端 FIN, 表示服务器对客户端发送的数据已经全部接收并确认)。</li>
<li>服务器状态变化：服务器发送 FIN 后，从 CLOSE_WAIT 状态转换到 LAST_ACK 状态。</li>
<li>作用：服务器告知客户端，它也没有数据要发送了，并请求关闭服务器到客户端方向的连接。</li>
</ul>
<ol start="4">
<li>第四次挥手 (ACK)：</li>
</ol>
<ul>
<li>发起方：客户端。</li>
<li>报文类型：ACK 报文段 (ACK_FLAG&#x3D;1)。</li>
<li>序列号 (Sequence Number)：seq &#x3D; u + 1。</li>
<li>确认号 (Acknowledgment Number)：ack &#x3D; w + 1。这表示客户端已成功接收到服务器的 FIN 报文段，并期望接收服务器的下一个字节的序列号是 w + 1 (尽管服务器也表示不再发送数据)。</li>
<li>客户端状态变化：客户端收到服务器的 FIN 后，从 FIN_WAIT_2 状态转换到 TIME_WAIT 状态。</li>
<li>服务器状态变化：服务器收到客户端的 ACK 后，从 LAST_ACK 状态转换到 CLOSED 状态。</li>
<li>作用：客户端确认已收到服务器的 FIN。</li>
</ul>
</li>
</ul>
</li>
<li><p>TIME_WAIT 状态的必要性：客户端在发送最后一个 ACK 后会进入 TIME_WAIT 状态，并持续等待 2MSL (Maximum Segment Lifetime, 最长报文段寿命) 的时间才进入 CLOSED 状态。MSL 是一个报文在网络中能够存活的最长时间。通常设置为 30 秒或 1 分钟。</p>
<ul>
<li>确保可靠关闭：为了确保最后一个 ACK 报文段能够到达服务器。如果这个 ACK 在网络中丢失了，服务器将因为没有收到确认而超时并重传第三次挥手的 FIN 报文。客户端处于 TIME_WAIT 状态时，可以接收到这个重传的 FIN，并再次发送 ACK，从而保证服务器能够可靠地关闭连接。如果客户端立即进入 CLOSED 状态，它就无法响应服务器重传的 FIN，服务器将永远停留在 LAST_ACK 状态。</li>
<li>避免旧连接的报文干扰新连接：在 2MSL 时间内，确保本连接中所有可能在网络中滞留的报文(如迟到的数据包或重传的 FIN)都已从网络中消失。这可以防止它们在连接关闭后被一个新的、使用相同源端口和目标端口的连接接收到，从而避免数据混乱。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h1><p>我对 MySQL 数据库有丰富的操作经验和深入的理解，包括 SQL 操作、事务特性、索引原理以及存储引擎。</p>
<h2 id="SQL-操作与优化"><a href="#SQL-操作与优化" class="headerlink" title="SQL 操作与优化"></a>SQL 操作与优化</h2><p>SQL (Structured Query Language) 是用于管理关系型数据库的标准语言。我熟练掌握各种 SQL 操作，并能进行性能优化。</p>
<ul>
<li><p>**DML (Data Manipulation Language)：**用于操作数据库中的数据。</p>
<ul>
<li>SELECT：查询数据。<ul>
<li><pre><code class="language-sql">SELECT column1, column2 FROM table_name WHERE condition ORDER BY column DESC/ASC LIMIT offset, count;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 聚合函数：COUNT(), SUM(), AVG(), MAX(), MIN()。</span><br><span class="line"></span><br><span class="line">  - 分组查询：GROUP BY, HAVING (用于过滤分组)。</span><br><span class="line"></span><br><span class="line">  - 联接查询 **(JOIN)**：</span><br><span class="line">    - INNER JOIN：只返回两个表中都匹配的行。</span><br><span class="line">    - LEFT JOIN / LEFT OUTER JOIN：返回左表所有行，以及右表中匹配的行。如果右表没有匹配，则右表列为 NULL。</span><br><span class="line">    - RIGHT JOIN / RIGHT OUTER JOIN：返回右表所有行，以及左表中匹配的行。如果左表没有匹配，则左表列为 NULL。</span><br><span class="line">    - FULL JOIN / FULL OUTER JOIN (MySQL 不直接支持，通常通过 LEFT JOIN UNION ALL RIGHT JOIN 模拟)：返回两个表中的所有行，不匹配的行用 NULL 填充。</span><br><span class="line">- INSERT：插入数据。</span><br><span class="line">  - ```sql</span><br><span class="line">    - INSERT INTO table_name (column1, column2) VALUES (value1, value2);</span><br><span class="line">    - INSERT INTO table_name VALUES (value1, value2, ...); (所有列)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li>UPDATE: 更新数据。<ul>
<li><pre><code class="language-sql">UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- DELETE: 删除数据。</span><br><span class="line">  - ```sql</span><br><span class="line">    DELETE FROM table_name WHERE condition; (不带 WHERE 子句将删除所有行，但不会释放空间，比 TRUNCATE TABLE 慢)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>DDL (Data Definition Language):</strong> 用于定义数据库对象，如表、索引、视图等。</p>
<ul>
<li><pre><code class="language-sql">- CREATE DATABASE database_name;
- CREATE TABLE table_name (column1 datatype constraints, column2 datatype constraints, PRIMARY KEY (column_name));
- ALTER TABLE table_name ADD column_name datatype;
- ALTER TABLE table_name DROP COLUMN column_name;
- ALTER TABLE table_name MODIFY COLUMN column_name datatype;
- DROP TABLE table_name;
- CREATE INDEX index_name ON table_name (column_name);
- DROP INDEX index_name ON table_name;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **DCL (Data Control Language):** 用于控制数据库的访问权限。</span><br><span class="line">  - ```sql</span><br><span class="line">    - GRANT privileges ON database.table TO &#x27;user&#x27;@&#x27;host&#x27;;</span><br><span class="line">    - REVOKE privileges ON database.table FROM &#x27;user&#x27;@&#x27;host&#x27;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>TCL (Transaction Control Language):</strong> 用于管理事务。</p>
<ul>
<li><pre><code class="language-sql">- START TRANSACTION; (或 BEGIN;)
- COMMIT;
- ROLLBACK;
- SAVEPOINT savepoint_name;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **EXPLAIN 命令深入分析：**</span><br><span class="line">  - EXPLAIN 是 MySQL SQL 优化的核心工具，它显示了 MySQL 如何执行 SELECT 查询（以及 INSERT, UPDATE, DELETE 语句的执行计划）。通过分析 EXPLAIN 的输出，可以判断查询是否使用了索引，以及索引使用的情况，从而进行性能优化。</span><br><span class="line">  - id: SELECT 查询的序列号。一个大的 SELECT 查询可以被分解为多个子查询，每个子查询都有一个唯一的 id。id 越大，执行优先级越高（优先级高的先执行）；如果 id 相同，则从上到下顺序执行。</span><br><span class="line">  - select_type: 查询的类型。</span><br><span class="line">    - SIMPLE: 简单的 SELECT 查询，不包含子查询或 UNION。</span><br><span class="line">    - PRIMARY: 最外层的 SELECT 查询（对于包含子查询或 UNION 的查询）。</span><br><span class="line">    - SUBQUERY: 子查询中的第一个 SELECT。</span><br><span class="line">    - DEPENDENT SUBQUERY: 依赖外部查询结果的子查询。</span><br><span class="line">    - UNION: UNION 中的第二个或后面的 SELECT 语句。</span><br><span class="line">    - DEPENDENT UNION: UNION 中的第二个或后面的 SELECT 语句，且依赖外部查询。</span><br><span class="line">    - UNION RESULT: UNION 的结果。</span><br><span class="line">    - DERIVED: 派生表（FROM 子句中的子查询）。table: 正在访问的表名。</span><br><span class="line">  - partitions: 匹配到的分区信息（如果表有分区）。</span><br><span class="line">  - type: 最重要的指标，表示连接类型，即 MySQL 查找数据的方式。这是评估查询性能的关键，从好到差依次是：</span><br><span class="line">    - system: 表中只有一行记录(系统表)。const 的特例，性能极高。</span><br><span class="line">    - const: 通过主键或唯一索引查找，最多匹配一行。非常快。例如 SELECT * FROM users WHERE id = 1;</span><br><span class="line">    - eq_ref: 对于前一个表的每个行组合，从表中读取一行。通常用于连接操作，主键或唯一索引的所有列都被用于连接条件。例如 SELECT * FROM orders o JOIN users u ON o.user_id = u.id; (假设 u.id 是主键或唯一索引)。</span><br><span class="line">    - ref: 非唯一索引的等值查找。可能找到多行。例如 SELECT * FROM orders WHERE user_id = 100; (假设 user_id 是普通索引)。</span><br><span class="line">    - range: 范围查找，使用索引来检索给定范围的行。例如 WHERE id &gt; 100 AND id &lt; 200; 或 BETWEEN, IN。</span><br><span class="line">    - index: 全索引扫描。遍历整个索引树，比 ALL 好，因为索引通常比数据文件小，且索引是按顺序存储的，可以避免随机 I/O。如果使用了覆盖索引，效率会更高。</span><br><span class="line">    - ALL: 全索引扫描。扫描整个表来查找匹配的行。性能最差，数据量大时应极力避免。</span><br><span class="line">  - possible_keys: MySQL 认为可能用于查询的索引。</span><br><span class="line">  - key: MySQL 实际决定使用的索引。如果为 NULL，表示没有使用索引。</span><br><span class="line">  - key_len: 实际使用的索引的长度(字节数)。这个值越小越好，表示使用的索引越短。对于复合索引，可以判断索引哪些列被用到了。</span><br><span class="line">  - ref: 表示使用哪个列或常量来和 key 所指的索引列做比较。</span><br><span class="line">  - rows: MySQL 估计要扫描的行数。这是最重要的指标之一，越少越好。</span><br><span class="line">  - filtered: 表示查询条件过滤掉的行数的百分比。越高越好，表示过滤效率高。</span><br><span class="line">  - Extra: 额外信息，对查询的解释提供了额外细节，非常重要。</span><br><span class="line">    - Using filesort: 表示 MySQL 需要对结果进行外部排序(即不在索引中排序)。这通常发生在 ORDER BY 或 GROUP BY 的列没有索引或索引无法被有效利用时。会增加 CPU 开销和 I/O，应尽量通过创建合适的索引或调整查询来避免。</span><br><span class="line">    - Using temporary: 表示 MySQL 需要创建临时表来处理查询。通常发生在 GROUP BY 或 ORDER BY 中包含不相关列，或者 DISTINCT 和 ORDER BY 混用时。临时表可能在内存中，也可能在磁盘上，都会增加性能开销，应尽量避免。</span><br><span class="line">    - Using index: 表示使用了覆盖索引 (Covering Index)。查询所需的所有列都可以在索引中找到，无需回表访问数据行。这是最有效的索引使用方式。</span><br><span class="line">    - Using where: 表示使用了 WHERE 子句进行过滤。这是正常的，但如果 type 是 ALL，说明 WHERE 过滤是基于全表扫描的，效率不高。</span><br><span class="line">    - Using index condition: MySQL 5.6+ 引入的索引条件下推 (Index Condition Pushdown, ICP) 优化。它将 WHERE 子句中的部分条件下推到存储引擎层，在索引扫描过程中就进行过滤，减少了回表次数和从存储引擎层返回给服务层的数据量。</span><br><span class="line">    - Using join buffer (Block Nested Loop): 当关联查询无法使用索引时，MySQL 会使用连接缓存来优化。</span><br><span class="line"></span><br><span class="line">## 事务 (Transaction)</span><br><span class="line"></span><br><span class="line">事务是一组操作的集合，这些操作要么全部成功，要么全部失败。它具有四大特性 (ACID)。</span><br><span class="line"></span><br><span class="line">- **ACID 特性：**</span><br><span class="line">  1. **原子性 (Atomicity)**: 事务是最小的执行单位，不可再分割。事务中的所有操作要么全部成功提交，要么全部失败回滚到事务开始前的状态。</span><br><span class="line">  2. **一致性 (Consistency)**: 事务执行前后，数据库的完整性约束 (如主键唯一性、外键约束、检查约束、自定义业务规则 ) 没有被破坏，数据从一个一致性状态转换到另一个一致性状态。</span><br><span class="line">  3. **隔离性 (Isolation)**: 并发执行的事务之间是隔离的，一个事务的执行不应影响其他事务的执行，反之亦然。事务的中间状态对其他事务是不可见的。</span><br><span class="line">  4. **持久性 (Durability)**: 一旦事务提交，它对数据库中数据的改变就是永久性的，即使系统崩溃也不会丢失。</span><br><span class="line"></span><br><span class="line">- **并发事务带来的问题：**</span><br><span class="line">  1. **脏读 (Dirty Read)**: 一个事务读取了另一个未提交事务的数据。如果这个未提交事务最终回滚，那么之前读取的数据就是“脏数据”。</span><br><span class="line">  2. **不可重复读 (Non-Repeatable Read)**：一个事务在两次相同的查询中，读取到了不同的数据。通常是因为另一个已提交事务对这些数据进行了 UPDATE 或 DELETE 操作。</span><br><span class="line">  3. **幻读 (Phantom Read)**：一个事务在两次相同的查询中，读取到了不同数量的行。通常是因为另一个已提交事务对数据进行了 INSERT 操作，导致第二次查询出现了之前没有的行。</span><br><span class="line">  4. **丢失更新 (Lost Update)**：当两个事务都读取同一数据并进行修改时，其中一个事务的修改覆盖了另一个事务的修改，导致数据丢失。</span><br><span class="line"></span><br><span class="line">- **事务隔离级别 (从低到高)：**</span><br><span class="line">  1. **READ UNCOMMITTED (读未提交)：**</span><br><span class="line">    - 最低的隔离级别。</span><br><span class="line">    - 允许脏读、不可重复读和幻读。</span><br><span class="line">    - 性能最高，但数据一致性最差。</span><br><span class="line">  2. **READ COMMITTED (读已提交)：**</span><br><span class="line">    - 解决了脏读问题。一个事务只能看到其他事务已经提交的数据。</span><br><span class="line">    - 仍然存在不可重复读和幻读问题。</span><br><span class="line">    - 多数数据库 (如 Oracle, SQL Server) 的默认隔离级别。</span><br><span class="line">  3. **REPEATABLE READ (可重复读)：**</span><br><span class="line">    - MySQL (InnoDB 存储引擎) 的默认隔离级别。</span><br><span class="line">    - 解决了脏读和不可重复读问题。在同一个事务中，多次读取同一数据会得到相同的结果 (通过 MVCC - 多版本并发控制)。</span><br><span class="line">    - 仍然可能存在幻读问题 (但在 InnoDB 默认隔离级别下，通过间隙锁解决了大部分幻读问题)。</span><br><span class="line">  4. **SERIALIZABLE (串行化):**</span><br><span class="line">    - 最高的隔离级别。</span><br><span class="line">    - 完全解决了脏读、不可重复读和幻读问题。</span><br><span class="line">    - 强制事务串行执行，避免所有并发问题。</span><br><span class="line">    - 性能最低，因为它牺牲了并发性。</span><br><span class="line"></span><br><span class="line">## 索引 (Index)</span><br><span class="line"></span><br><span class="line">索引是帮助 MySQL 高效获取数据的数据结构。它类似于书籍的目录，可以快速定位到所需的数据，而无需扫描整个表。</span><br><span class="line"></span><br><span class="line">- **索引的优点:**</span><br><span class="line">  - 大大加快数据检索速度。</span><br><span class="line">  - 减少服务器的 I/O 次数。</span><br><span class="line">  - 在分组 (GROUP BY) 和排序 (ORDER BY) 操作中减少 CPU 消耗。</span><br><span class="line"></span><br><span class="line">- **索引的缺点:**</span><br><span class="line">  - 创建和维护索引需要时间成本，数据增加时需要更新索引。</span><br><span class="line">  - 索引需要占用磁盘空间。</span><br><span class="line">  - 虽然查询性能提升，但对写入操作有一定性能损耗。</span><br><span class="line"></span><br><span class="line">- **索引的底层实现: B+ 树**</span><br><span class="line">  - B+ 树 (B+Tree):</span><br><span class="line">    - 所有数据都存储在叶子节点上，非叶子节点只存储键值 (索引) 用于导航。</span><br><span class="line">    - 叶子节点之间通过链表连接，方便范围查询和遍历。</span><br><span class="line">    - 树的层高更低：相比 B 树，B+ 树的非叶子节点不存储数据，因此一个节点可以存储更多的索引键，使得树的高度更低，从而减少磁盘 I/O 次数。</span><br><span class="line">    - 适用于磁盘存储：磁盘 I/O 是数据库操作的主要瓶颈，B+ 树的设计（节点大小与磁盘块大小匹配）能够最大程度地减少磁盘寻道次数。</span><br><span class="line"></span><br><span class="line">- **索引的分类：**</span><br><span class="line">  1. 主键索引 (Primary Key Index)：</span><br><span class="line">    - 一种特殊的唯一索引，一个表只能有一个主键。</span><br><span class="line">    - 不允许有空值 (NULL)。</span><br><span class="line">    - 通常是聚集索引 (InnoDB)。</span><br><span class="line">  2. 唯一索引 (Unique Index)：</span><br><span class="line">    - 索引列的值必须唯一，但允许有空值 (NULL)，且可以有多个 NULL 值。</span><br><span class="line">    - CREATE UNIQUE INDEX index_name ON table_name (column_name):</span><br><span class="line">  3. 普通索引 (Normal Index / Non-Unique Index)：</span><br><span class="line">    - 最基本的索引，没有任何限制。</span><br><span class="line">    - CREATE INDEX index_name ON table_name (column_name):</span><br><span class="line">  4. 全文索引 (Fulltext Index)：</span><br><span class="line">    - 用于文本内容的模糊查询，在大文本字段上进行高效搜索。</span><br><span class="line">    - 只支持 MyISAM 和 InnoDB 存储引擎。</span><br><span class="line">    - CREATE FULLTEXT INDEX index_name ON table_name (column_name):</span><br><span class="line">  5. 复合索引 (Composite Index / Multi-Column Index)：</span><br><span class="line">    - 在多个列上创建的索引。</span><br><span class="line">    - 遵循“最左前缀原则”：如果查询条件使用了复合索引的第一个列，则整个索引会被利用；如果只使用了非第一个列，则索引可能无法完全利用。</span><br><span class="line">    - CREATE INDEX index_name ON table_name (column1, column2, column3);</span><br><span class="line"></span><br><span class="line">- **聚集索引（Clustered Index）与 非聚集索引（Non-Clustered Index）：**</span><br><span class="line">  - 聚集索引：</span><br><span class="line">    - 索引的叶子节点存储的就是完整的数据行。</span><br><span class="line">    - 一个表只能有一个聚集索引（通常是主键）。</span><br><span class="line">    - 数据物理存储的顺序与索引的逻辑顺序一致。</span><br><span class="line">    - 查询效率高，因为找到索引叶子节点就找到了数据。</span><br><span class="line">    - 对数据插入、更新和删除有一定影响，因为需要维护数据的物理顺序。</span><br><span class="line">    - 在 InnoDB 存储引擎中，主键索引就是聚集索引。如果我没有显式定义主键，InnoDB 会选择一个唯一非空索引作为聚集索引；如果没有，则会自动创建一个隐藏的 6 字节的行 ID 作为聚集索引。</span><br><span class="line">  - 非聚集索引：</span><br><span class="line">    - 索引的叶子节点存储的是主键值或指向数据行的指针。</span><br><span class="line">    - 一个表可以有多个非聚集索引。</span><br><span class="line">    - 数据物理存储顺序与非聚集索引的逻辑顺序无关。</span><br><span class="line">    - 查询需要回表：如果查询的列不在非聚集索引中，需要通过索引找到主键值，再通过主键索引（聚集索引）找到完整的数据行。</span><br><span class="line">    - 在 InnoDB 中，所有非主键索引都是非聚集索引。</span><br><span class="line"></span><br><span class="line">- **索引优化策略：**</span><br><span class="line">  - 选择合适的列创建索引：</span><br><span class="line">    - 在 WHERE 子句、JOIN 子句、ORDER BY 子句中经常出现的列。</span><br><span class="line">    - 选择区分度高（唯一值多）的列。</span><br><span class="line">    - 不为小型表、频繁更新的表、重复值多的列创建索引。</span><br><span class="line">  - 遵循最左前缀原则：对于复合索引 (a, b, c)，查询条件 WHERE a = 1，WHERE a = 1 AND b = 2 会使用索引，但 WHERE b = 2 或 WHERE c = 3 不会完全使用索引。</span><br><span class="line">  - 避免索引失效：</span><br><span class="line">    - 在索引列上进行函数运算或表达式运算（如 WHERE YEAR(date_column) = 2023）。</span><br><span class="line">    - 对索引列进行隐式类型转换。</span><br><span class="line">    - 使用 OR 连接条件（除非 OR 的两边都有索引，并且优化器认为合并索引更高效）。</span><br><span class="line">    - 使用 LIKE &#x27;%keyword&#x27;（左模糊匹配）会导致全索引扫描或全表扫描。</span><br><span class="line">    - 使用 NOT IN 或 != 通常无法使用索引。</span><br><span class="line">  - 覆盖索引：查询只从索引中获取数据，无需回表。</span><br><span class="line">    - SELECT column_in_index FROM table_name WHERE indexed_column = value;</span><br><span class="line">  - 防止回表：尽可能让 SELECT 语句中的列都被索引覆盖，或者只查询主键。</span><br><span class="line">  - 定期维护索引：重建或优化碎片化的索引。</span><br><span class="line"></span><br><span class="line">- #### SQL优化</span><br><span class="line"></span><br><span class="line">  ![图片](https://i-blog.csdnimg.cn/blog_migrate/bfe55c106fb1ceb9316542c424cecf9f.png) </span><br><span class="line"></span><br><span class="line">## 存储引擎</span><br><span class="line"></span><br><span class="line">MySQL 是一个关系型数据库管理系统，它的独特之处在于支持多种可插拔的存储引擎。存储引擎负责 MySQL 中数据的存储和提取。</span><br><span class="line"></span><br><span class="line">- **InnoDB (默认)：**</span><br><span class="line">  - 特性：</span><br><span class="line">    - 支持事务（ACID 特性）。</span><br><span class="line">    - 支持行级锁定：在并发写入时，只锁定需要修改的行，而不是整个表，大大提高了并发性能。</span><br><span class="line">    - 支持外键约束：维护数据完整性。</span><br><span class="line">    - 支持崩溃恢复：通过事务日志（redo log 和 undo log）保证数据持久性。</span><br><span class="line">    - 默认使用聚集索引：数据存储在 B+ 树的叶子节点中，数据行和主键一起存储，查询效率高。</span><br><span class="line">    - MVCC（多版本并发控制）：通过快照读取实现非阻塞的读操作，提高并发性能。</span><br><span class="line">  - 适用场景：事务性应用、高并发读写、对数据完整性和一致性要求要求高的场景（如电商、金融系统）。</span><br><span class="line"></span><br><span class="line">- **MyISAM（非事务性）：**</span><br><span class="line">  - 特性：</span><br><span class="line">    - 不支持事务。</span><br><span class="line">    - 支持表级锁定：并发写入时，需要锁定整个表，并发性能差。</span><br><span class="line">    - 不支持外键约束。</span><br><span class="line">    - 不支持崩溃恢复：可能导致数据丢失。</span><br><span class="line">    - 非聚集索引：数据和索引是分离的，索引叶子节点存储的是数据行的地址。</span><br><span class="line">    - SELECT COUNT(*) 效率高，因为表的总行数存储在内存中。</span><br><span class="line">  - 适用场景：只读或读多写少，对事务性要求不高，需要频繁执行 COUNT(*) 的应用（如一些日志记录、数据仓库）。在 MySQL 5.5 后，InnoDB 逐渐替代 MyISAM 成为默认和首选。</span><br><span class="line"></span><br><span class="line">- **其他存储引擎（了解）：**</span><br><span class="line">  - Memory (HEAP)：数据存储在内存中，速度极快，但重启服务器数据会丢失。适用于临时表或缓存。</span><br><span class="line">  - Archive：用于存储大量不常访问的历史数据，支持高速插入和查询（不支持更新和删除）。数据会被高度压缩。</span><br><span class="line">  - CSV：以 CSV 文件格式存储数据，便于与其他应用程序进行数据交换。</span><br><span class="line"></span><br><span class="line">## MVCC（多版本并发控制）：</span><br><span class="line"></span><br><span class="line">好的，我们来深入探讨一下 **MVCC (Multi-Version Concurrency Control)**，并分析一些常见的面试题。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **什么是 MVCC？**</span><br><span class="line"></span><br><span class="line">**MVCC**，即**多版本并发控制**，是一种在数据库中用于解决并发访问问题的方法。它不是通过加锁的方式来控制并发，而是通过**为每个事务生成一个数据快照**，让读操作在快照上进行。</span><br><span class="line"></span><br><span class="line">你可以把它想象成一个“时光机”。当一个事务开始时，数据库会为它“拍一张照片”，也就是生成一个数据快照。这个事务的所有读操作都只会看到这个快照里的数据，而不会受到其他并发事务修改的影响。这样，读操作就不需要等待写锁释放，从而实现了**读写分离**，大大提高了并发性能。</span><br><span class="line"></span><br><span class="line">简而言之，MVCC 的核心思想是：</span><br><span class="line"></span><br><span class="line">- **读不加锁**：读取数据时，直接从数据的历史版本中读取，不需要等待其他事务的写锁。</span><br><span class="line">- **写不阻塞读**：写操作修改数据时，会创建一个新的版本，而旧版本依然保留，供其他读事务使用。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **MVCC 的实现原理**</span><br><span class="line"></span><br><span class="line">MVCC 的实现通常依赖于以下几个核心要素：</span><br><span class="line"></span><br><span class="line">1. 隐藏列（Hidden Columns）：</span><br><span class="line"></span><br><span class="line">   每个表都会有几个隐藏的列，用于记录版本信息：</span><br><span class="line"></span><br><span class="line">   - **DB_TRX_ID**：事务 ID，记录最近一次修改数据的事务 ID。</span><br><span class="line">   - **DB_ROLL_PTR**：回滚指针，指向这条记录的上一个版本。</span><br><span class="line">   - **DB_ROW_ID**：行 ID，是插入新行时分配的隐藏 ID，当主键是字符串时，可能用于辅助索引。</span><br><span class="line"></span><br><span class="line">2. Undo Log (回滚日志)：</span><br><span class="line"></span><br><span class="line">   Undo Log 记录了数据在被修改之前的值。每次修改数据时，都会将修改前的数据版本记录在 Undo Log 中，并通过回滚指针 DB_ROLL_PTR 将新版本与旧版本连接起来，形成一个版本链。这样，通过版本链，我们就可以追溯到这条数据的历史版本。</span><br><span class="line"></span><br><span class="line">3. Read View (读视图)：</span><br><span class="line"></span><br><span class="line">   Read View 是 MVCC 的核心，它是一个在事务启动时生成的、用来判断某个数据版本对当前事务是否可见的数据快照。它主要包含以下几个关键信息：</span><br><span class="line"></span><br><span class="line">   - `m_ids`：在生成 `Read View` 时，当前系统中**所有活跃事务**的 ID 列表。</span><br><span class="line">   - `min_trx_id`：在生成 `Read View` 时，`m_ids` 中最小的事务 ID。</span><br><span class="line">   - `max_trx_id`：在生成 `Read View` 时，系统将要分配给下一个事务的 ID。</span><br><span class="line">   - `creator_trx_id`：创建 `Read View` 的事务 ID。</span><br><span class="line"></span><br><span class="line">   当一个事务想要读取一条数据时，会根据 `Read View` 的规则来判断这条数据的**`DB_TRX_ID`**是否可见。</span><br><span class="line"></span><br><span class="line">   - 如果 `DB_TRX_ID` 小于 `min_trx_id`，说明这个修改操作在当前事务启动前就已经提交了，数据**可见**。</span><br><span class="line">   - 如果 `DB_TRX_ID` 大于等于 `max_trx_id`，说明这个修改操作是在当前事务启动后才发生的，数据**不可见**。</span><br><span class="line">   - 如果 `DB_TRX_ID` 在 `min_trx_id` 和 `max_trx_id` 之间，那么需要判断 `DB_TRX_ID` 是否在 `m_ids` 列表中。如果在，说明这个修改操作是和当前事务同时启动的，数据**不可见**；如果不在，说明这个修改操作在当前事务启动前就已经提交了，数据**可见**。</span><br><span class="line"></span><br><span class="line">   如果当前版本不可见，事务就会通过回滚指针 `DB_ROLL_PTR` 沿着版本链找到上一版本，直到找到一个**可见**的版本。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **面试题分析**</span><br><span class="line"></span><br><span class="line">#### **1. 什么是 MVCC？它解决了什么问题？**</span><br><span class="line"></span><br><span class="line">**回答要点：**</span><br><span class="line"></span><br><span class="line">- **概念**：多版本并发控制，通过维护数据历史版本实现并发。</span><br><span class="line">- **解决问题**：在数据库隔离级别为**读已提交（RC）**和**可重复读（RR）**时，实现了读写不冲突。它解决了 **读写锁冲突** 和 **脏读** 问题，但无法完全解决幻读。</span><br><span class="line">- **核心思想**：读操作读取数据快照，写操作创建新版本。</span><br><span class="line"></span><br><span class="line">#### **2. MVCC 是如何实现可重复读（Repeatable Read）的？**</span><br><span class="line"></span><br><span class="line">**回答要点：**</span><br><span class="line"></span><br><span class="line">- **核心**：`Read View` 的创建时机。</span><br><span class="line">- **可重复读**：事务在第一次读操作时创建 `Read View`，并且在**整个事务的生命周期内都使用这个 Read View**。这意味着无论事务中执行多少次读，看到的都是同一个数据快照，所以能保证多次读取结果一致。</span><br><span class="line">- **读已提交**：相比之下，读已提交的隔离级别是**每次执行读操作时都重新生成一个 Read View**。因此，如果其他事务在两次读操作之间提交了修改，第二次读就能看到新数据，导致不可重复读。</span><br><span class="line"></span><br><span class="line">#### **3. MVCC 能解决幻读吗？**</span><br><span class="line"></span><br><span class="line">**回答要点：**</span><br><span class="line"></span><br><span class="line">- **部分解决，但不能完全解决。**</span><br><span class="line">- **幻读（Phantom Read）**：当一个事务在两次查询之间，另一个事务插入了新的数据，导致第一次查询不存在的数据，第二次查询却出现了。</span><br><span class="line">- **MVCC 的作用**：MVCC 可以防止**更新幻读**（即一个事务在两次查询之间，另一个事务更新了数据），因为它总是读取事务启动时的快照。</span><br><span class="line">- **无法解决**：MVCC 无法完全解决**插入幻读**。例如，事务 A 两次查询 `WHERE id &gt; 10`，但在两次查询之间，事务 B 插入了一条 `id=11` 的记录并提交。虽然事务 A 的 `Read View` 看不到这条新记录，但如果事务 A 执行 `UPDATE ... WHERE id &gt; 10` 时，它会发现这条新记录并对其加锁，从而更新成功。这会打破可重复读的承诺。</span><br><span class="line">- **InnoDB 的解决方案**：InnoDB 数据库在 `可重复读` 隔离级别下，除了 MVCC，还会结合**间隙锁（Gap Lock）**来彻底解决幻读问题。</span><br><span class="line"></span><br><span class="line">#### **4. Undo Log 和 Redo Log 有什么区别？**</span><br><span class="line"></span><br><span class="line">**回答要点：**</span><br><span class="line"></span><br><span class="line">- **Undo Log (回滚日志)**：</span><br><span class="line">  - **作用**：用于**回滚事务**和实现 **MVCC**。</span><br><span class="line">  - **记录内容**：记录的是**数据修改前**的版本。</span><br><span class="line">  - **生命周期**：在事务提交后，如果数据有其他事务在使用（用于 MVCC），`Undo Log` 依然保留；如果没有，`Undo Log` 会被清除。</span><br><span class="line">- **Redo Log (重做日志)**：</span><br><span class="line">  - **作用**：用于保证事务的**持久性**。</span><br><span class="line">  - **记录内容**：记录的是**数据修改后**的日志，比如“某某页的某某偏移量改成了某某值”。</span><br><span class="line">  - **生命周期**：在数据同步到磁盘后，`Redo Log` 就会被清除。</span><br><span class="line">  - **作用点**：`Redo Log` 作用于**崩溃恢复**。当数据库发生宕机时，可以根据 `Redo Log` 将已提交但尚未写入磁盘的数据重新写入，以保证数据不丢失。</span><br><span class="line"></span><br><span class="line">## MySQL日志</span><br><span class="line"></span><br><span class="line">MySQL的日志系统是其数据库管理系统(DBMS)中至关重要的组成部分，扮演着监控、审计、故障恢复和数据复制等多种关键角色。用户提到的错误日志、查询日志、慢查询日志、事务日志和二进制日志构成了MySQL日志体系的核心。下面将对这些主要日志进行详细的梳理和解析。</span><br><span class="line"></span><br><span class="line">## 1. 错误日志(Error Log)</span><br><span class="line"></span><br><span class="line">错误日志是MySQL中最基础的日志之一，它记录了mysqld服务器启动、运行和关闭过程中遇到的所有严重错误和警告。</span><br><span class="line"></span><br><span class="line">- 主要内容：</span><br><span class="line">  - 服务器启动和关闭的详细信息。</span><br><span class="line">  - 运行过程中发生的错误，例如表损坏、无法访问特定文件等。</span><br><span class="line">  - 事件调度器运行出错时的信息。</span><br><span class="line">  - 在主从复制架构中，从服务器上启动和关闭复制线程，连接主服务器时发生的错误等。</span><br><span class="line">- 作用：错误日志是诊断和解决MySQL服务器问题的首要工具。当数据库无法启动或运行异常时，应首先检查此日志。</span><br><span class="line">- 配置：默认情况下，错误日志是开启的。其文件名通常为&lt;hostname&gt;.err，位于数据目录(datadir)下。可以通过在my.cnf或my.ini配置文件中设置log_error变量来指定其路径。</span><br><span class="line"></span><br><span class="line">## 2. 查询日志(Query Log)/通用查询日志(General Query Log)</span><br><span class="line"></span><br><span class="line">通用查询日志记录了MySQL服务器接收到的每一个客户端连接和执行的每一条SQL语句。</span><br><span class="line"></span><br><span class="line">- 主要内容：</span><br><span class="line">  - 客户端的连接信息，包括连接时间、用户名和主机。</span><br><span class="line">  - 客户端发送给服务器的所有SQL语句，无论其是否正确执行。</span><br><span class="line">- 作用：该日志对于数据库的审计和问题排查非常有用，可以精确复现用户的操作序列。然而，由于它会记录所有操作，对系统性能会产生显著影响，并会迅速占用大量磁盘空间。因此，不建议在生产环境中长期开启。</span><br><span class="line">- 配置：默认关闭。可以通过设置general_log为ON来启用，并使用general_log_file指定日志文件路径。</span><br><span class="line"></span><br><span class="line">## 3. 慢查询日志(Slow Query Log)</span><br><span class="line"></span><br><span class="line">慢查询日志用于记录执行时间超过指定阈值的SQL查询语句，是数据库性能优化的关键工具。</span><br><span class="line"></span><br><span class="line">- 主要内容：</span><br><span class="line">  - 执行时间超过long_query_time阈值的SQL语句。</span><br><span class="line">  - 查询执行时的相关信息，如执行时间、锁定时间、扫描的行数、返回的行数以及执行该查询的用户和主机。</span><br><span class="line">- 作用：通过分析慢查询日志，开发者和数据库管理员(DBA)可以定位到效率低下的SQL语句，并针对性地进行优化，例如添加索引、改写查询等。</span><br><span class="line">- 配置：默认关闭。需在配置文件中设置slow_query_log为ON开启。long_query_time参数用于设定慢查询的时间阈值(单位：秒)，slow_query_log_file用于指定日志文件位置。log_queries_not_using_indexes参数还可以记录未使用索引的查询。</span><br><span class="line"></span><br><span class="line">## 4. 事务日志(Transaction Log)</span><br><span class="line"></span><br><span class="line">用户提到的&quot;事务日志&quot;在InnoDB存储引擎中，主要由两种日志构成：重做日志(Redo Log)和回滚日志(Undo Log)。它们共同保证了事务的ACID特性(原子性、一致性、隔离性、持久性)。</span><br><span class="line"></span><br><span class="line">- 重做日志(Redo Log):</span><br><span class="line">  - 作用：保证事务的持久性。它记录了数据被修改后的物理变化。当事务提交后，即使数据尚未完全写入数据文件，只要Redo Log已经持久化，在数据库发生崩溃时，也可以通过重放Redo Log来恢复已提交的事务，确保数据不丢失。这种技术被称为预写日志(Write-Ahead Logging, WAL)。</span><br><span class="line">  - 特点：Redo Log是以循环写的方式记录在连续的物理文件中，大小固定。</span><br><span class="line">- 回滚日志(Undo Log):</span><br><span class="line">  - 作用：保证事务的原子性和实现多版本并发控制(MVCC)。Undo Log记录的是数据被修改前的状态。当事务需要回滚时，可以通过Undo Log将数据恢复到修改之前的版本。同时，在读已提交(Read Committed)和可重复读(Repeatable Read)隔离级别下，当一个事务需要读取被另一个未提交事务修改的行时，会通过Undo Log读取该行之前的版本，从而实现非锁定读。</span><br><span class="line">  - 特点：Undo Log逻辑上记录了每个修改操作的逆操作。</span><br><span class="line"></span><br><span class="line">## 5. 二进制日志(Binary Log/Binlog)</span><br><span class="line"></span><br><span class="line">二进制日志是MySQL中功能最强大、用途最广泛的日志之一。它以二进制格式记录了所有修改数据库数据的操作(DML)以及数据定义语言(DDL)的操作，但不包括SELECT和SHOW等不修改数据的查询。</span><br><span class="line"></span><br><span class="line">- 主要内容：记录了导致数据发生更改的所有事件。根据格式不同，可以记录为SQL语句(STATEMENT格式)、行的变更(ROW格式)或两者的混合(MIXED格式)。</span><br><span class="line">- 主要作用：</span><br><span class="line">  - 数据恢复(Point-in-Time Recovery)：通过备份的数据文件和之后的二进制日志，可以将数据库恢复到过去的任意一个时间点。</span><br><span class="line">  - 主从复制(Replication)：在主从架构中，主服务器将二进制日志传送给从服务器，从服务器重放这些日志中的事件，从而实现与主服务器的数据同步。</span><br><span class="line">- 配置：默认情况下可能关闭，需要通过配置文件中的log_bin选项来启用。启用后，会生成一个索引文件(默认为&lt;hostname&gt;-bin.index)和一系列的二进制日志文件。</span><br><span class="line"></span><br><span class="line">## 扩展：中继日志(Relay Log)</span><br><span class="line"></span><br><span class="line">在主从复制环境中，还有一个重要的日志类型——中继日志。</span><br><span class="line"></span><br><span class="line">- 作用：从服务器的I/O线程从主服务器获取二进制日志，并将其写入本地的中继日志中。然后，从服务器的SQL线程读取中继日志中的事件，并在从服务器上执行，以实现数据同步。</span><br><span class="line">- 特点：中继日志的格式与二进制日志完全相同。它的存在使得从服务器的I/O和SQL执行可以解耦，即使在网络不稳定的情况下，只要I/O线程将日志拉到本地，SQL线程就可以持续执行。</span><br><span class="line"></span><br><span class="line">## 总结</span><br><span class="line"></span><br><span class="line">| 日志类型   | 主要作用                                 | 生产环境建议                                 |</span><br><span class="line">| ---------- | ---------------------------------------- | -------------------------------------------- |</span><br><span class="line">| 错误日志   | 记录服务器启停和运行错误                 | 始终开启                                     |</span><br><span class="line">| 查询日志   | 记录所有连接和SQL语句，用于审计          | 默认关闭，仅在调试时短期开启                 |</span><br><span class="line">| 慢查询日志 | 记录执行缓慢的SQL，用于性能优化          | 建议开启                                     |</span><br><span class="line">| 事务日志   |                                          |                                              |</span><br><span class="line">| - Redo Log | 保证事务持久性，用于崩溃恢复             | InnoDB引擎核心组件，始终开启                 |</span><br><span class="line">| - Undo Log | 保证事务原子性，支持MVCC                 | InnoDB引擎核心组件，始终开启                 |</span><br><span class="line">| 二进制日志 | 数据恢复、主从复制                       | 强烈建议开启，尤其是需要数据恢复和复制的场景 |</span><br><span class="line">| 中继日志   | 主从复制中，从库用于暂存主库的二进制日志 | 在从服务器上自动创建和管理                   |</span><br><span class="line"></span><br><span class="line">## MySQL中的锁</span><br><span class="line"></span><br><span class="line">## 第一部分：数据库锁系统</span><br><span class="line"></span><br><span class="line">### 1. 锁的分类体系</span><br><span class="line"></span><br><span class="line">#### 1.1 按锁粒度的层次分类</span><br><span class="line"></span><br><span class="line">**表级锁（Table-Level Lock）** 表级锁是最粗粒度的锁机制，一次锁定整个表的所有数据。MyISAM存储引擎主要使用表级锁，其内部维护一个全局的表锁列表。当线程需要访问表时，首先检查表锁状态，如果表已被其他线程以不兼容模式锁定，则当前线程进入等待队列。表级锁的优势在于锁管理开销极小，只需要维护少量的锁对象；缺点是并发度极低，即使访问不同行的操作也会相互阻塞。</span><br><span class="line"></span><br><span class="line">**页级锁（Page-Level Lock）** 页级锁锁定数据页，是表级锁和行级锁的折中方案。BDB存储引擎使用页级锁，每个数据页通常包含多条记录。页级锁的实现需要在页头维护锁信息，包括锁模式、持有者信息等。这种锁粒度在空间局部性较好的应用中表现优秀，因为相关的数据通常存储在相邻的页面中。</span><br><span class="line"></span><br><span class="line">**行级锁（Row-Level Lock）** 行级锁是最细粒度的锁机制，InnoDB存储引擎的核心特性。行锁的实现依赖于索引结构，实际上锁定的是索引记录而不是数据行本身。当查询没有使用索引时，InnoDB会扫描整个表并对所有记录加锁，退化为类似表锁的行为。行级锁提供最高的并发度，但也带来最大的管理开销。</span><br><span class="line"></span><br><span class="line">#### 1.2 按锁模式的功能分类</span><br><span class="line"></span><br><span class="line">**共享锁（Shared Lock, S锁）** 共享锁允许多个事务同时读取同一资源，但阻止任何事务修改该资源。在InnoDB中，共享锁通过在锁对象的type_mode字段中设置LOCK_S标志位来标识。多个共享锁可以并存，这是通过锁兼容性矩阵来判断的。共享锁的获取相对简单，只需要检查是否存在冲突的排他锁。</span><br><span class="line"></span><br><span class="line">**排他锁（Exclusive Lock, X锁）** 排他锁提供独占访问，同一时间只能有一个事务持有资源的排他锁。排他锁与任何其他锁都不兼容，包括共享锁和其他排他锁。在InnoDB实现中，排他锁的获取需要等待所有现有的锁释放，这通过等待队列机制来实现。</span><br><span class="line"></span><br><span class="line">**意向锁（Intention Lock）** 意向锁是一种表级锁，用于表明事务在表的某些行上持有或即将请求某种类型的锁。意向共享锁（IS）表示事务意图在某些行上获取共享锁，意向排他锁（IX）表示事务意图在某些行上获取排他锁。意向锁的引入大大简化了表级操作的锁冲突检测，避免了遍历所有行锁的开销。</span><br><span class="line"></span><br><span class="line">#### 1.3 按锁算法的实现分类</span><br><span class="line"></span><br><span class="line">**记录锁（Record Lock）** 记录锁锁定索引中的一条具体记录，是最基本的行级锁形式。在InnoDB的实现中，记录锁通过在B+树的叶子节点记录上设置锁标记来实现。锁对象中的heap_no字段精确标识被锁定的记录在页面中的位置。记录锁只能防止其他事务修改或删除该记录，但不能防止在该记录前后插入新记录。</span><br><span class="line"></span><br><span class="line">**间隙锁（Gap Lock）** 间隙锁锁定索引记录之间的间隙，防止其他事务在该间隙中插入新记录。间隙锁的范围是开区间，不包含边界记录本身。InnoDB通过比较索引键值来确定间隙的边界，对于复合索引，间隙的比较需要考虑所有键值列的组合。间隙锁之间不冲突，多个事务可以同时持有相同间隙的间隙锁。</span><br><span class="line"></span><br><span class="line">**临键锁（Next-Key Lock）** 临键锁是记录锁和间隙锁的组合，锁定一个记录以及该记录前面的间隙。这是InnoDB在可重复读隔离级别下的默认锁算法。临键锁有效解决了幻读问题，因为它不仅锁定已存在的记录，还锁定了可能插入新记录的位置。临键锁的范围是左开右闭区间。</span><br><span class="line"></span><br><span class="line">### 2. InnoDB锁系统的深层实现</span><br><span class="line"></span><br><span class="line">#### 2.1 锁对象的数据结构设计</span><br><span class="line"></span><br></pre></td></tr></table></figure>
struct lock_t &#123;
trx_t* trx;           // 拥有该锁的事务
UT_LIST_NODE_T(lock_t) trx_locks; // 事务锁链表节点
dict_table_t* tab_lock; // 表锁信息
dict_index_t* index;    // 索引信息
hash_node_t hash;       // 哈希表节点
ulint type_mode;        // 锁类型和模式
ulint n_bits;          // 位图大小
ulint n_granted_locks; // 已授予的锁数量
ulint n_waiting_locks; // 等待的锁数量
&#125;;
</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**锁哈希表的设计：** InnoDB使用一个全局的锁哈希表来管理所有的锁对象，哈希函数基于space_id和page_no计算。每个哈希桶包含一个锁对象链表，相同页面的所有锁对象都链接在同一个桶中。这种设计支持快速的锁查找和冲突检测，时间复杂度接近O(1)。</span><br><span class="line"></span><br><span class="line">**锁位图的精巧设计：** 对于页面级别的锁管理，InnoDB使用位图来标识页面中哪些记录被锁定。每个记录对应位图中的一位，设置为1表示该记录被锁定。这种压缩表示法大大节省了内存空间，特别是在锁定大量记录时。位图操作使用高效的位运算指令，支持快速的锁状态查询和更新。</span><br><span class="line"></span><br><span class="line">#### 2.2 死锁检测的高级算法</span><br><span class="line"></span><br><span class="line">**增量式死锁检测：** InnoDB不是每次都重新构建整个等待图，而是采用增量式检测。当新的等待关系建立时，算法只检查从新等待者开始的路径是否形成环。这种优化大大减少了检测的计算开销，特别是在高并发场景下效果显著。</span><br><span class="line"></span><br><span class="line">**死锁检测的优先级调度：** 死锁检测器运行在独立的后台线程中，具有较高的调度优先级。检测频率根据系统负载动态调整：在高并发时增加检测频率，在低负载时降低频率以节省CPU资源。检测器还会维护统计信息，包括死锁发生频率、平均解决时间等，用于系统调优。</span><br><span class="line"></span><br><span class="line">**复杂死锁场景的处理：** 实际生产环境中可能出现涉及多个资源类型的复杂死锁，比如同时涉及行锁、表锁、和外键约束锁的死锁。InnoDB的死锁检测器需要构建一个多层次的等待图，包含不同类型的资源节点和等待边。解决这类死锁时，需要考虑不同锁类型的回滚代价。</span><br><span class="line"></span><br><span class="line">#### 2.3 MVCC与锁的深度集成</span><br><span class="line"></span><br><span class="line">**ReadView的内部结构：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>struct ReadView {<br>    trx_id_t low_limit_id;    &#x2F;&#x2F; 生成ReadView时的下一个事务ID<br>    trx_id_t up_limit_id;     &#x2F;&#x2F; 生成ReadView时最小的活跃事务ID<br>    trx_id_t creator_trx_id;  &#x2F;&#x2F; 创建ReadView的事务ID<br>    trx_ids_t m_ids;          &#x2F;&#x2F; 生成ReadView时的活跃事务ID列表<br>    m_low_limit_no;           &#x2F;&#x2F; 最大的事务编号<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**版本可见性的判断算法：** 当事务读取记录时，需要判断记录的某个版本是否对当前事务可见。判断逻辑基于记录的DB_TRX_ID字段和ReadView的信息：如果DB_TRX_ID小于up_limit_id，则该版本对所有事务可见；如果DB_TRX_ID大于等于low_limit_id，则该版本对当前事务不可见；如果DB_TRX_ID在两者之间，则需要检查是否在活跃事务列表中。</span><br><span class="line"></span><br><span class="line">**undo log的链式结构：** 每个事务的undo log形成一个链式结构，记录了该事务的所有修改操作。undo log不仅用于事务回滚，还用于MVCC的版本构建。当需要构建某个历史版本时，InnoDB会从当前版本开始，沿着undo log链向前回溯，逐步应用逆向操作直到达到目标版本。</span><br><span class="line"></span><br><span class="line">### 3. 数据库锁的性能优化策略</span><br><span class="line"></span><br><span class="line">#### 3.1 锁等待的自适应策略</span><br><span class="line"></span><br><span class="line">**等待时间的动态调整：** InnoDB实现了自适应的锁等待策略，根据系统负载和锁竞争情况动态调整等待超时时间。在低负载时延长等待时间以减少不必要的回滚，在高负载时缩短等待时间以快速释放资源。这种策略通过维护系统级的统计信息来实现，包括平均锁持有时间、锁竞争频率等。</span><br><span class="line"></span><br><span class="line">**等待队列的优先级管理：** 对于同一资源的多个等待者，InnoDB可以根据事务的重要性、等待时间、资源消耗等因素进行优先级排序。高优先级的事务可以优先获得锁，这对于关键业务操作特别重要。优先级的计算考虑多个维度，包括事务的年龄、修改的数据量、是否为只读事务等。</span><br><span class="line"></span><br><span class="line">#### 3.2 索引设计对锁性能的影响</span><br><span class="line"></span><br><span class="line">**覆盖索引与锁范围优化：** 当查询能够通过覆盖索引获取所有需要的数据时，InnoDB只需要在二级索引上加锁，而不需要回表访问聚簇索引。这大大减少了锁的数量和范围，提高了并发性能。覆盖索引的设计需要仔细分析查询模式，将经常一起访问的列组合成复合索引。</span><br><span class="line"></span><br><span class="line">**索引前缀长度对锁粒度的影响：** 对于字符串类型的索引，前缀长度的选择直接影响锁的粒度。较短的前缀可能导致多个不同的值映射到相同的索引前缀，从而扩大锁的范围；较长的前缀提供更精确的锁定，但增加了索引的存储开销。最优前缀长度需要在锁粒度和存储效率之间平衡。</span><br><span class="line"></span><br><span class="line">#### 3.3 事务设计对锁性能的优化</span><br><span class="line"></span><br><span class="line">**事务边界的精细控制：** 事务边界的设计直接影响锁的持有时间。长事务会长时间持有锁，阻塞其他事务的执行。优化策略包括：将大事务拆分为多个小事务，减少每个事务的锁持有时间；将只读操作和写操作分离，只读操作使用快照读避免加锁；在事务中优先执行可能失败的操作，减少无效锁持有。</span><br><span class="line"></span><br><span class="line">**批量操作的锁优化：** 对于批量插入、更新、删除操作，可以采用特殊的锁策略。比如批量插入时可以使用INSERT ... ON DUPLICATE KEY UPDATE语法，减少锁冲突；批量更新时可以按照索引顺序进行，避免死锁；批量删除时可以分批进行，避免长时间持有大量锁。</span><br><span class="line"></span><br><span class="line">## 行锁（Row Lock）</span><br><span class="line"></span><br><span class="line">## InnoDB的行锁实现</span><br><span class="line"></span><br><span class="line">InnoDB是MySQL中支持行锁的主要存储引擎：</span><br><span class="line">实现原理：</span><br><span class="line"></span><br><span class="line">1. 当事务需要锁定某行时，InnoDB会在该行对应的索引记录上加锁</span><br><span class="line">2. 如果没有索引，会锁定整个表（实际是锁定所有行）</span><br><span class="line">3. 锁信息存储在内存中的哈希表结构中</span><br><span class="line"></span><br><span class="line">## 表锁（Table Lock）</span><br><span class="line"></span><br><span class="line">## MyISAM的表锁实现</span><br><span class="line"></span><br><span class="line">MyISAM只支持表级锁</span><br><span class="line"></span><br><span class="line">1. 维护一个全局的表锁队列</span><br><span class="line">2. 写锁具有更高优先级</span><br><span class="line">3. 锁信息存储在服务器层面</span><br><span class="line"></span><br><span class="line"># Java 核心技术</span><br><span class="line"></span><br><span class="line">## 数据类型</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **八个基本数据类型（Primitive Data Types）**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### **1. 整型**</span><br><span class="line"></span><br><span class="line">整型用于存储不带小数的整数。Java 提供了四种整型，它们的区别在于所占内存空间的大小，从而影响可存储的数值范围。</span><br><span class="line"></span><br><span class="line">- **byte**</span><br><span class="line">  - 大小：1 字节（8 位）</span><br><span class="line">  - 范围：−128 到 127</span><br><span class="line">  - 用途：主要用于节省内存，尤其是在处理大量数据时，例如在文件或网络传输中。</span><br><span class="line">- **short**</span><br><span class="line">  - 大小：2 字节（16 位）</span><br><span class="line">  - 范围：−32768 到 32767</span><br><span class="line">  - 用途：同样用于节省内存，比 `byte` 的范围更大。</span><br><span class="line">- **int**</span><br><span class="line">  - 大小：4 字节（32 位）</span><br><span class="line">  - 范围：约 −2.1×109 到 2.1×109</span><br><span class="line">  - 用途：这是**最常用**的整型，通常用来表示普通的整数。</span><br><span class="line">- **long**</span><br><span class="line">  - 大小：8 字节（64 位）</span><br><span class="line">  - 范围：约 −9.2×1018 到 9.2×1018</span><br><span class="line">  - 用途：当 `int` 类型的范围不足以存储一个大数时使用，例如处理时间戳、文件大小等。在数值后面需要加上 `L` 或 `l` 来表示，例如 `long myLong = 100L;`。</span><br><span class="line"></span><br><span class="line">#### **2. 浮点型**</span><br><span class="line"></span><br><span class="line">浮点型用于存储带有小数点的数值。</span><br><span class="line"></span><br><span class="line">- **float**</span><br><span class="line">  - 大小：4 字节（32 位）</span><br><span class="line">  - 用途：单精度浮点数，有效位数为 6-7 位。在数值后面需要加上 `F` 或 `f` 来表示，例如 `float myFloat = 3.14f;`。</span><br><span class="line">- **double**</span><br><span class="line">  - 大小：8 字节（64 位）</span><br><span class="line">  - 用途：双精度浮点数，有效位数为 15-16 位。这是**最常用**的浮点型，Java 默认的浮点数类型就是 `double`。</span><br><span class="line"></span><br><span class="line">&gt; **注意**：浮点数存在精度问题，不适合用于精确的金融计算。如果需要精确计算，应使用 `java.math.BigDecimal` 类。</span><br><span class="line"></span><br><span class="line">#### **3. 字符型**</span><br><span class="line"></span><br><span class="line">- **char**</span><br><span class="line">  - 大小：2 字节（16 位）</span><br><span class="line">  - 用途：存储单个字符。在 Java 中，`char` 采用 Unicode 编码，可以表示包括中文在内的所有字符。它可以用单引号 `&#x27;` 括起来，例如 `char myChar = &#x27;A&#x27;;`。</span><br><span class="line"></span><br><span class="line">#### **4. 布尔型**</span><br><span class="line"></span><br><span class="line">- **boolean**</span><br><span class="line">  - 大小：在内存中通常被视为 1 位，但在数组中会占用 1 字节。</span><br><span class="line">  - 用途：用于存储 `true` 或 `false`，表示逻辑值。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **String 类型**</span><br><span class="line"></span><br><span class="line">`String` 是一个非常特殊的类型，它**不是基本数据类型**，而是一个**引用数据类型（Reference Data Type）**。</span><br><span class="line"></span><br><span class="line">#### **String 的核心特性**</span><br><span class="line"></span><br><span class="line">1. **不可变性（Immutability）**</span><br><span class="line">   - `String` 对象一旦被创建，它的值就不能被改变。</span><br><span class="line">   - 当你对 `String` 进行修改操作时，比如拼接字符串，实际上是**创建了一个新的 String 对象**，而原始对象没有改变。</span><br><span class="line">   - 这种不可变性使得 `String` 对象是线程安全的，可以在多线程环境中被安全地共享。</span><br><span class="line">2. **String 的创建**</span><br><span class="line">   - **字面量方式**：`String s = &quot;hello&quot;;`</span><br><span class="line">     - 这种方式创建的字符串会被存储在**字符串常量池（String Pool）**中。</span><br><span class="line">     - 当创建第二个值为 `&quot;hello&quot;` 的字符串时，JVM 会直接从常量池中返回已存在的对象引用，而不会创建新的对象。这是一种重要的内存优化。</span><br><span class="line">   - **new 关键字方式**：`String s = new String(&quot;hello&quot;);`</span><br><span class="line">     - 这种方式会创建一个新的 `String` 对象在堆（Heap）中。即使常量池中已经存在 `&quot;hello&quot;`，也会在堆中再创建一个新的对象。</span><br><span class="line"></span><br><span class="line">#### **String 的常用方法**</span><br><span class="line"></span><br><span class="line">- **拼接**：</span><br><span class="line">  - 使用 `+` 运算符：`String s3 = s1 + s2;`</span><br><span class="line">  - 使用 `concat()` 方法：`s1.concat(s2);`</span><br><span class="line">  - 推荐使用 `StringBuilder` 或 `StringBuffer` 进行大量字符串拼接，因为它们是可变的，效率更高。</span><br><span class="line">- **比较**：</span><br><span class="line">  - `equals()`：比较字符串的内容，返回 `boolean` 类型。</span><br><span class="line">  - `equalsIgnoreCase()`：忽略大小写比较字符串内容。</span><br><span class="line">  - `==`：比较的是**对象的引用地址**，只有当两个引用指向同一个对象时才为 `true`。</span><br><span class="line">- **查找**：</span><br><span class="line">  - `indexOf(char)`：查找字符第一次出现的索引。</span><br><span class="line">  - `contains(String)`：判断是否包含某个子字符串。</span><br><span class="line">- **修改**：</span><br><span class="line">  - `replace(oldChar, newChar)`：替换字符串中的字符。</span><br><span class="line">  - `substring(beginIndex, endIndex)`：截取子字符串。</span><br><span class="line"></span><br><span class="line">#### **为什么不用 char 数组代替 String？**</span><br><span class="line"></span><br><span class="line">虽然 `String` 内部也是用 `char` 数组实现的，但 `String` 的不可变性提供了很多优势：</span><br><span class="line"></span><br><span class="line">- **安全性**：作为方法参数时，可以防止方法内部修改原始字符串。</span><br><span class="line">- **线程安全**：可以在多线程环境下共享。</span><br><span class="line">- **哈希码缓存**：`String` 的哈希码会被缓存，在作为 `HashMap` 的键时，性能更好。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **基本类型与 String 的转换**</span><br><span class="line"></span><br><span class="line">- **基本类型转 String**：</span><br><span class="line">  - `String.valueOf(int i)`</span><br><span class="line">  - `Integer.toString(int i)`</span><br><span class="line">  - `&quot;&quot; + i`</span><br><span class="line">- **String 转基本类型**：</span><br><span class="line">  - `Integer.parseInt(&quot;123&quot;)`</span><br><span class="line">  - `Double.parseDouble(&quot;3.14&quot;)`</span><br><span class="line">  - `Float.parseFloat(&quot;1.23&quot;)`</span><br><span class="line">  - 等等。</span><br><span class="line"></span><br><span class="line">&gt; **注意**：`String` 转基本类型时，如果字符串格式不正确，会抛出 `NumberFormatException`。</span><br><span class="line"></span><br><span class="line">## 锁</span><br><span class="line"></span><br><span class="line">### 1. 内置锁：`synchronized` 关键字</span><br><span class="line"></span><br><span class="line">`synchronized`是Java语言层面的同步机制，使用起来相对简单。它可以修饰方法或代码块，由JVM负责加锁和释放锁，开发者不需要手动管理。</span><br><span class="line"></span><br><span class="line">- **同步方法：** 当你用`synchronized`修饰一个非静态方法时，锁对象是这个方法的实例对象（`this`）。当一个线程进入这个同步方法时，它会获得该实例的锁，其他线程就无法进入这个实例的任何同步方法，直到它释放锁。</span><br><span class="line">- **同步静态方法：** 当`synchronized`修饰一个静态方法时，锁对象是该类的`Class`对象。这意味着所有线程在访问这个类的任何同步静态方法时都会争抢同一把锁，无论有多少个实例。</span><br><span class="line">- **同步代码块：** `synchronized (object)`。这是最灵活的使用方式，你可以指定任何对象作为锁。通过缩小同步范围，可以减少锁的持有时间，从而提高程序的并发性能。</span><br><span class="line"></span><br><span class="line">**synchronized的特点：**</span><br><span class="line"></span><br><span class="line">- **可重入性（Reentrant）：** 一个线程可以重复获取它已经持有的锁，避免死锁。</span><br><span class="line">- **非公平性（Unfair）：** 默认情况下，线程获取锁的顺序是不确定的，先来的不一定先得到。</span><br><span class="line">- **锁的升级：** 为了优化性能，`synchronized`锁的实现经历了从**偏向锁**、**轻量级锁**到**重量级锁**的升级过程。这使得在竞争不激烈的情况下，加锁的开销非常小。</span><br><span class="line">- **内存可见性（Visibility）：** `synchronized`可以保证当一个线程释放锁时，它对共享变量所做的修改会立即刷新到主内存，而当另一个线程获取锁时，它会从主内存中读取最新的变量值。这是由Java内存模型（JMM）的`happens-before`规则保证的。</span><br><span class="line"></span><br><span class="line">### 底层实现机制</span><br><span class="line"></span><br><span class="line">synchronized本质上是基于JVM的**内置锁（Intrinsic Lock）**实现的。每个Java对象都天生具备一个监视器锁（Monitor），这是JVM级别的原生支持。</span><br><span class="line"></span><br><span class="line">**监视器的工作原理：**</span><br><span class="line"></span><br><span class="line">- 当线程进入synchronized代码块时，会执行monitorenter指令获取对象的监视器</span><br><span class="line">- 当线程退出时，执行monitorexit指令释放监视器</span><br><span class="line">- 如果获取失败，线程会被阻塞在操作系统级别</span><br><span class="line"></span><br><span class="line">### 锁升级的演进过程</span><br><span class="line"></span><br><span class="line">synchronized的性能优化经历了一个复杂的演进过程，从最初的重量级锁逐步优化：</span><br><span class="line"></span><br><span class="line">**偏向锁阶段：**</span><br><span class="line">当只有一个线程反复进入同步块时，JVM会将锁偏向于这个线程。此时的开销极低，几乎等同于无锁操作。对象头中会记录偏向的线程ID，后续该线程进入时直接通过简单的比较就能获取锁。</span><br><span class="line"></span><br><span class="line">**轻量级锁阶段：**</span><br><span class="line">当有其他线程开始竞争时，偏向锁会升级为轻量级锁。JVM在当前线程的栈帧中创建锁记录（Lock Record），通过CAS操作尝试将对象头的Mark Word替换为指向锁记录的指针。这个过程避免了操作系统层面的阻塞。</span><br><span class="line"></span><br><span class="line">**重量级锁阶段：**</span><br><span class="line">当CAS操作失败次数过多或者有多个线程同时竞争时，锁会膨胀为重量级锁。此时会创建Monitor对象，利用操作系统的互斥量（Mutex）来实现同步，涉及用户态和内核态的切换。</span><br><span class="line"></span><br><span class="line">### 自动化的特点</span><br><span class="line"></span><br><span class="line">synchronized的最大特点是**完全自动化**。程序员无需关心锁的获取和释放时机，JVM会自动处理所有细节。即使在异常情况下，JVM也能保证锁的正确释放，这大大降低了死锁和资源泄露的风险。</span><br><span class="line"></span><br><span class="line">### 2. 显式锁：`java.util.concurrent.locks.Lock`</span><br><span class="line"></span><br><span class="line">从JDK 1.5开始，`java.util.concurrent.locks`包提供了更灵活、更强大的锁机制，其核心是`Lock`接口。最常用的实现类是**`ReentrantLock`**。</span><br><span class="line"></span><br><span class="line">使用`Lock`需要手动进行加锁和解锁操作，通常是在`try...finally`块中进行，以确保锁在任何情况下都能被释放，防止死锁。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    // 访问共享资源的代码</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lock相比synchronized的优势：</strong></p>
<ul>
<li><strong>中断锁（Interruptibly）：</strong> <code>Lock</code>提供了<code>lockInterruptibly()</code>方法，允许在等待锁的过程中响应中断。而<code>synchronized</code>的线程如果陷入等待锁的状态，是无法被中断的。</li>
<li><strong>尝试获取锁（tryLock）：</strong> <code>Lock</code>提供了<code>tryLock()</code>和<code>tryLock(long timeout, TimeUnit unit)</code>方法，可以尝试获取锁，如果失败则立即返回或在指定时间内放弃，避免无限等待。</li>
<li><strong>公平锁与非公平锁：</strong> <code>ReentrantLock</code>可以创建公平锁（Fair Lock）。公平锁会按照线程请求锁的顺序来分配锁，虽然这可能会带来一些性能开销。而<code>synchronized</code>只能是非公平锁。</li>
<li><strong>绑定多个条件（Condition）：</strong> <code>Lock</code>配合<code>Condition</code>接口，可以实现更灵活的线程等待和唤醒机制，类似<code>Object</code>的<code>wait()</code>和<code>notify()</code>，但功能更强大，一个锁可以有多个等待队列。</li>
<li><strong>读写锁（ReadWriteLock）：</strong> <code>ReadWriteLock</code>是<code>Lock</code>的另一个重要实现，它维护了一对锁：一个用于读操作，一个用于写操作。在读多写少的场景下，多个线程可以同时获取读锁，大大提高了并发性能，只有写操作才需要获取独占的写锁。<code>ReentrantReadWriteLock</code>是其具体实现。</li>
</ul>
<h3 id="Lock接口的设计理念"><a href="#Lock接口的设计理念" class="headerlink" title="Lock接口的设计理念"></a>Lock接口的设计理念</h3><h3 id="显式锁机制"><a href="#显式锁机制" class="headerlink" title="显式锁机制"></a>显式锁机制</h3><p>Lock接口代表了Java并发包中<strong>显式锁</strong>的设计思想。与synchronized的隐式锁不同，Lock要求程序员明确控制锁的生命周期，这带来了更大的灵活性，同时也增加了使用的复杂性。</p>
<h3 id="AQS框架的核心思想"><a href="#AQS框架的核心思想" class="headerlink" title="AQS框架的核心思想"></a>AQS框架的核心思想</h3><p>Lock接口的实现基于AbstractQueuedSynchronizer（AQS）框架，这是Doug Lea设计的一个并发框架的杰作。</p>
<p><strong>同步状态的抽象：</strong><br>AQS使用一个int值来表示同步状态，不同的锁实现可以赋予这个状态不同的含义。比如ReentrantLock用它表示重入次数，Semaphore用它表示许可证数量。</p>
<p><strong>队列化的等待机制：</strong><br>当线程无法获取锁时，AQS会将其包装成节点加入到一个FIFO队列中。这个队列使用双向链表实现，每个节点都包含了线程引用和等待状态信息。</p>
<p><strong>自旋与阻塞的平衡：</strong><br>AQS巧妙地结合了自旋和阻塞两种等待策略。线程在入队后会先进行有限次数的自旋尝试，只有在确定无法获取锁时才会调用LockSupport.park()进入阻塞状态。</p>
<h3 id="3-volatile-关键字"><a href="#3-volatile-关键字" class="headerlink" title="3. volatile 关键字"></a>3. <code>volatile</code> 关键字</h3><p><code>volatile</code>关键字并不是一个锁，它是一种轻量级的同步机制，主要用于保证共享变量的<strong>可见性</strong>和<strong>有序性</strong>。</p>
<ul>
<li><strong>可见性（Visibility）：</strong> 当一个变量被<code>volatile</code>修饰后，一个线程对它的修改会立即被其他线程可见。这是通过在写操作后添加内存屏障，强制将修改后的值刷新到主内存，并在读操作前添加内存屏障，强制从主内存中读取最新值来实现的。</li>
<li><strong>有序性（Ordering）：</strong> <code>volatile</code>可以禁止指令重排序，确保代码的执行顺序不会被打乱。</li>
<li><strong>无法保证原子性（Atomicity）：</strong> <code>volatile</code>无法保证复合操作（如<code>i++</code>）的原子性，因为<code>i++</code>实际上是读、加、写三个操作的组合，这三个操作并非一次完成。如果要保证原子性，需要使用<code>synchronized</code>、<code>Lock</code>或<code>java.util.concurrent.atomic</code>包下的原子类。</li>
</ul>
<p><strong>总结一下：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>synchronized</code></th>
<th><code>Lock</code> (如<code>ReentrantLock</code>)</th>
<th><code>volatile</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>功能</strong></td>
<td>独占锁，保证原子性、可见性、有序性</td>
<td>独占锁，功能更强大，保证原子性、可见性、有序性</td>
<td>轻量级同步，只保证可见性和有序性</td>
</tr>
<tr>
<td><strong>使用方式</strong></td>
<td>关键字，自动加锁和解锁</td>
<td>接口，需要手动加锁和解锁，必须在<code>finally</code>块中释放</td>
<td>关键字，修饰变量</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>较差，功能固定</td>
<td>强，提供了更多高级功能，如可中断、超时、公平锁等</td>
<td>较差，只针对变量</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>JVM优化后性能较高，开销相对较小</td>
<td>高性能，在竞争激烈时通常优于<code>synchronized</code></td>
<td>非常高，几乎没有开销</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单的同步需求，大部分情况都适用</td>
<td>高级同步需求，需要灵活控制锁的获取和释放</td>
<td>变量的写操作不依赖于当前值，需要保证变量的可见性。</td>
</tr>
</tbody></table>
<h3 id="4-乐观锁-Optimistic-Locking"><a href="#4-乐观锁-Optimistic-Locking" class="headerlink" title="4. 乐观锁 (Optimistic Locking)"></a>4. 乐观锁 (Optimistic Locking)</h3><p>与之前讨论的<strong>悲观锁</strong>（<code>synchronized</code>和<code>Lock</code>）不同，乐观锁并非一个具体的Java关键字或类，而是一种<strong>并发控制的思想和策略</strong>。悲观锁认为“总会有其他线程来修改数据”，所以在访问共享资源前，先对资源加锁，确保独占访问。而乐观锁则认为“数据冲突发生的概率很小”，所以它<strong>不加锁</strong>，而是假设所有线程都能正常执行，只有在数据更新提交时，才去检查在此期间数据是否被其他线程修改过。</p>
<p>如果检查到数据没有被修改，则更新成功。如果发现数据已经被修改，则更新失败。处理失败的方式通常有两种：</p>
<ol>
<li><strong>重试：</strong> 循环尝试，直到更新成功为止。</li>
<li><strong>放弃：</strong> 抛出异常或直接返回失败，由调用方处理。</li>
</ol>
<p><strong>乐观锁的实现方式：</strong></p>
<p>乐观锁的核心在于如何“检查数据是否被修改”。在Java中，常见的实现方式有两种：</p>
<ul>
<li><p>版本号（Version Number）：</p>
<p>在数据表中增加一个version字段。每次读取数据时，也把version字段读出来。当要进行数据更新时，带上之前读取的version值，在更新语句中加入WHERE version &#x3D; &lt;当前版本号&gt;的条件。如果更新成功，同时把version值加1。</p>
<ul>
<li><p><strong>SQL示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE products <span class="type">SET</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">100</span>, version = version + <span class="number">1</span></span><br><span class="line"><span class="type">WHERE</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">123</span> <span class="type">AND</span> <span class="variable">version</span> <span class="operator">=</span> &lt;之前读取的版本号&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原理：</strong> 如果在更新时，其他线程已经修改了这条数据，那么<code>version</code>值已经改变，上述<code>UPDATE</code>语句的<code>WHERE</code>条件将不成立，导致更新失败，影响行数为0。此时，你可以选择重试或放弃。</p>
</li>
</ul>
</li>
<li><p>CAS (Compare-And-Swap) 算法：</p>
<p>这是乐观锁在硬件层面的支持，也是Java中实现乐观锁的核心机制。CAS是一种原子操作，它包含三个操作数：</p>
<ul>
<li><strong>V (Value)：</strong> 内存地址中存放的旧值。</li>
<li><strong>A (Expected)：</strong> 预期的旧值。</li>
<li><strong>B (New)：</strong> 想要写入的新值。</li>
</ul>
<p>CAS的操作逻辑是：</p>
<p>如果内存地址V中的值等于预期值A，那么就将V的值更新为新值B。否则，什么都不做。整个操作是原子性的，由CPU指令直接完成。</p>
<p>Java中<code>java.util.concurrent.atomic</code>包下的所有原子类，如<code>AtomicInteger</code>、<code>AtomicLong</code>等，都是基于CAS实现的。</p>
<p><strong>AtomicInteger示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="comment">// 假设多个线程同时执行以下操作</span></span><br><span class="line">count.incrementAndGet(); <span class="comment">// 内部就是CAS操作</span></span><br></pre></td></tr></table></figure>

<p><code>incrementAndGet()</code>方法的内部实现类似于一个自旋重试的循环：</p>
<ol>
<li>获取当前值<code>current</code>。</li>
<li>计算新值<code>next = current + 1</code>。</li>
<li>使用CAS尝试将<code>current</code>更新为<code>next</code>。</li>
<li>如果更新失败（说明<code>current</code>已经被其他线程修改），则重新回到第一步，再次获取最新值并尝试更新。</li>
</ol>
</li>
</ul>
<p><strong>悲观锁与乐观锁的比较：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>悲观锁 (<code>synchronized</code>, <code>Lock</code>)</th>
<th>乐观锁 (CAS, 版本号)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>加锁方式</strong></td>
<td>独占资源时先加锁，阻止其他线程访问</td>
<td>不加锁，只在提交时进行冲突检测</td>
</tr>
<tr>
<td><strong>冲突处理</strong></td>
<td>线程排队等待锁，串行执行</td>
<td>线程失败后重试或放弃，并发执行</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td><strong>写操作多、竞争激烈</strong>的场景。数据冲突概率高。</td>
<td><strong>读操作多、写操作少</strong>的场景。数据冲突概率低。</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>在高竞争环境下，线程切换和上下文开销大，性能下降。</td>
<td>在低竞争环境下，无锁开销，性能极高。在高竞争环境下，大量重试可能导致CPU开销增加。</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<p>在Java中，<strong>悲观锁</strong>和<strong>乐观锁</strong>是两种截然不同的并发控制策略。悲观锁（<code>synchronized</code>, <code>Lock</code>）适合<strong>写多读少</strong>的场景，能够保证数据的一致性，但会牺牲一定的性能。而乐观锁（<strong>CAS</strong>、<strong>版本号</strong>）则适合<strong>读多写少</strong>的场景，通过无锁的并发操作提高了性能，但在高竞争下可能导致频繁重试，反而降低效率。理解这两种锁的思想，可以帮助你根据具体的业务场景选择最合适的并发控制方案。</p>
<p>好的，我们来继续完善Java中关于锁的介绍，增加<strong>死锁</strong>及其解决方案的内容。</p>
<hr>
<h3 id="5-死锁-Deadlock"><a href="#5-死锁-Deadlock" class="headerlink" title="5. 死锁 (Deadlock)"></a>5. 死锁 (Deadlock)</h3><p><strong>死锁</strong>是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法继续执行。</p>
<p><strong>死锁的产生</strong>是一个非常经典的多线程问题，通常发生在线程需要同时持有多个锁的场景中。一个简单的死锁场景是：线程A持有锁1，想获取锁2；而线程B持有锁2，想获取锁1。此时两个线程都无法继续执行，从而进入死锁状态。</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 线程A</span><br><span class="line">synchronized (lock1) &#123;</span><br><span class="line">    synchronized (lock2) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 线程B</span><br><span class="line">synchronized (lock2) &#123;</span><br><span class="line">    synchronized (lock1) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h4><p>死锁的发生需要同时满足以下四个条件，缺一不可：</p>
<ol>
<li><strong>互斥条件（Mutual Exclusion）：</strong> 至少有一个资源是独占的，即一次只能被一个线程使用。这是锁本身的基本特性。</li>
<li><strong>请求与保持条件（Hold and Wait）：</strong> 一个线程因请求资源而阻塞时，它对自己已获得的资源保持不放。</li>
<li><strong>不剥夺条件（No Preemption）：</strong> 线程已获得的资源在未使用完之前，不能被强行剥夺，只能由该线程自己释放。</li>
<li><strong>循环等待条件（Circular Wait）：</strong> 存在一个线程等待链，其中每个线程都持有下一个线程所需的资源。例如：线程A等待线程B，线程B等待线程C，线程C又等待线程A。</li>
</ol>
<h4 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h4><p>解决死锁的根本思想是<strong>破坏上述四个必要条件之一或多个</strong>。通常，我们无法破坏互斥条件（因为资源就是独占的），因此主要从其他三个条件入手。</p>
<ol>
<li><strong>破坏“请求与保持”条件：</strong><ul>
<li><strong>一次性获取所有锁：</strong> 线程在开始执行时，就一次性获取所有需要的锁。如果获取不成功，则释放所有已获得的锁，然后等待一段时间后再次尝试。</li>
<li><strong>优点：</strong> 简单有效。</li>
<li><strong>缺点：</strong> 可能会降低并发性，因为线程在很早就持有了锁，即使这些锁在后面才被使用。</li>
</ul>
</li>
<li><strong>破坏“不剥夺”条件：</strong><ul>
<li><strong>使用可中断的锁：</strong> 使用<code>Lock</code>接口提供的<code>tryLock()</code>方法。当一个线程尝试获取锁失败时，它可以选择放弃并释放已持有的锁，而不是一直等待。<code>Lock.tryLock(long time, TimeUnit unit)</code>方法可以在指定时间内尝试获取锁，超时后会放弃。</li>
<li><strong>优点：</strong> 提高了灵活性，线程可以响应中断或超时，避免无限等待。</li>
<li><strong>缺点：</strong> 实现起来相对复杂，需要开发者手动处理获取锁失败的情况。</li>
</ul>
</li>
<li><strong>破坏“循环等待”条件：</strong><ul>
<li><strong>按顺序获取锁：</strong> 对所有的锁进行排序，并强制所有线程都按照相同的顺序获取锁。</li>
<li><strong>示例：</strong> 如果线程A和线程B都需要<code>lock1</code>和<code>lock2</code>，那么它们都必须先获取<code>lock1</code>，再获取<code>lock2</code>。这样就杜绝了线程A持有<code>lock1</code>等待<code>lock2</code>，同时线程B持有<code>lock2</code>等待<code>lock1</code>的循环。</li>
<li><strong>优点：</strong> 这是最常用、最有效的死锁解决方案，实现起来也相对简单。</li>
<li><strong>缺点：</strong> 有时很难对所有锁进行全局排序，特别是在代码模块化程度较高、依赖关系复杂的情况下。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>在实际开发中，预防死锁的最佳实践通常是<strong>破坏循环等待条件</strong>，即<strong>统一锁的获取顺序</strong>。这是最简单且最有效的方案。如果业务场景需要更灵活的控制，可以考虑使用<code>Lock</code>接口，利用<code>tryLock()</code>方法来破坏“不剥夺”条件，实现更复杂的死锁处理逻辑。</p>
<p>好的，我们来详细介绍<strong>银行家算法 (Banker’s Algorithm)</strong>。</p>
<hr>
<h3 id="银行家算法概述"><a href="#银行家算法概述" class="headerlink" title="银行家算法概述"></a>银行家算法概述</h3><p>银行家算法是一种著名的<strong>死锁避免算法</strong>，由荷兰计算机科学家Dijkstra在1965年提出。它的核心思想是：在每次分配资源之前，先进行一次<strong>安全性检查</strong>。如果分配后系统仍然处于<strong>安全状态</strong>，则分配资源；否则，不予分配，线程需要等待。</p>
<ul>
<li>优点：比死锁预防更灵活，能提高资源利用率。</li>
<li>缺点：算法复杂，需要预知进程的最大资源需求，并且系统开销大。</li>
</ul>
<p>之所以叫“银行家算法”，是因为它的工作原理类似于银行管理贷款。银行家在发放贷款时，会先确保这笔贷款发放后，自己还有足够的资金来满足所有客户可能提出的最大取款需求，从而避免因无法支付而破产的风险。</p>
<p>简单来说，银行家算法通过以下两个步骤来避免死锁：</p>
<ol>
<li><strong>安全状态的定义：</strong> 系统能够找到一个<strong>安全序列</strong>，使得所有线程都能按照这个序列执行完毕。</li>
<li><strong>资源分配策略：</strong> 当一个线程请求资源时，算法会先假设分配成功，然后检查系统是否仍处于安全状态。如果安全，就真的分配；如果不安全，就拒绝分配。</li>
</ol>
<hr>
<h3 id="银行家算法中的几个重要数据结构"><a href="#银行家算法中的几个重要数据结构" class="headerlink" title="银行家算法中的几个重要数据结构"></a>银行家算法中的几个重要数据结构</h3><p>为了实现算法，需要维护以下几个关键数据结构，假设系统中有<code>n</code>个线程和<code>m</code>种资源：</p>
<ul>
<li><strong>Available (可用资源矩阵)：</strong> 一个长度为<code>m</code>的向量。<code>Available[j]</code>表示第<code>j</code>种资源目前可用的数量。</li>
<li><strong>Max (最大需求矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Max[i, j]</code>表示线程<code>i</code>最多需要第<code>j</code>种资源多少个。</li>
<li><strong>Allocation (已分配资源矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Allocation[i, j]</code>表示线程<code>i</code>目前已拥有第<code>j</code>种资源多少个。</li>
<li><strong>Need (需求矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Need[i, j]</code>表示线程<code>i</code>还需要第<code>j</code>种资源多少个才能完成任务。<ul>
<li><code>Need[i, j] = Max[i, j] - Allocation[i, j]</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="银行家算法的核心：安全状态的判断"><a href="#银行家算法的核心：安全状态的判断" class="headerlink" title="银行家算法的核心：安全状态的判断"></a>银行家算法的核心：安全状态的判断</h3><p>判断系统是否处于安全状态是银行家算法的核心。一个系统处于<strong>安全状态</strong>，当且仅当存在一个<strong>安全序列</strong><code>&lt;P1, P2, ..., Pn&gt;</code>。这个序列满足：对于序列中每一个线程<code>Pi</code>，它所需要的资源都能由系统中当前可用的资源，以及前面所有已完成的线程释放的资源来满足。</p>
<p><strong>安全性检查算法的步骤：</strong></p>
<ol>
<li><strong>初始化：</strong><ul>
<li>创建一个<code>Work</code>向量，初始化为<code>Available</code>（即当前可用资源）。</li>
<li>创建一个<code>Finish</code>向量，初始化为<code>false</code>，表示所有线程都未完成。</li>
</ul>
</li>
<li><strong>寻找安全线程：</strong><ul>
<li>从所有线程中找到一个线程<code>i</code>，满足以下两个条件：<ul>
<li><code>Finish[i]</code>为<code>false</code>。</li>
<li><code>Need[i]</code>向量中的每一个值都小于或等于<code>Work</code>向量中对应的值。</li>
<li>换句话说，线程<code>i</code>所需要的资源小于或等于当前可用的资源。</li>
</ul>
</li>
</ul>
</li>
<li><strong>释放资源：</strong><ul>
<li>如果找到了这样的线程<code>i</code>，则认为它可以顺利执行完毕。</li>
<li>模拟该线程执行完毕并释放资源，更新<code>Work</code>向量：<code>Work = Work + Allocation[i]</code>。</li>
<li>将<code>Finish[i]</code>设置为<code>true</code>。</li>
</ul>
</li>
<li><strong>循环检查：</strong><ul>
<li>重复步骤2和步骤3，直到找不到满足条件的线程。</li>
</ul>
</li>
<li><strong>判断结果：</strong><ul>
<li>如果最终所有线程的<code>Finish</code>都为<code>true</code>，则说明找到了一个安全序列，系统处于<strong>安全状态</strong>。</li>
<li>如果还有线程的<code>Finish</code>为<code>false</code>，则说明系统处于<strong>不安全状态</strong>，可能存在死锁。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="银行家算法的流程：资源分配"><a href="#银行家算法的流程：资源分配" class="headerlink" title="银行家算法的流程：资源分配"></a>银行家算法的流程：资源分配</h3><p>当一个线程<code>P</code>请求资源时，银行家算法会执行以下步骤：</p>
<ol>
<li><strong>请求检查：</strong> 检查线程<code>P</code>请求的资源数量是否小于或等于其<code>Need</code>向量中的需求量。如果不是，说明线程<code>P</code>的请求不合理，拒绝分配。</li>
<li><strong>可用性检查：</strong> 检查线程<code>P</code>请求的资源数量是否小于或等于当前<code>Available</code>中的资源数量。如果不是，说明资源不足，线程<code>P</code>需要等待。</li>
<li><strong>预分配并进行安全性检查：</strong><ul>
<li>假设资源可以分配，<strong>临时</strong>进行以下操作：<ul>
<li><code>Available = Available - Request</code></li>
<li><code>Allocation[P] = Allocation[P] + Request</code></li>
<li><code>Need[P] = Need[P] - Request</code></li>
</ul>
</li>
<li>调用上面的<strong>安全性检查算法</strong>，判断系统是否处于安全状态。</li>
</ul>
</li>
<li><strong>正式分配或拒绝：</strong><ul>
<li>如果安全性检查的结果是<strong>安全</strong>，则正式分配资源，并保留步骤3中的修改。</li>
<li>如果安全性检查的结果是<strong>不安全</strong>，则回滚步骤3中的所有临时修改，拒绝分配资源，线程<code>P</code>需要等待。</li>
</ul>
</li>
</ol>
<h3 id="银行家算法的优缺点"><a href="#银行家算法的优缺点" class="headerlink" title="银行家算法的优缺点"></a>银行家算法的优缺点</h3><ul>
<li><strong>优点：</strong><ul>
<li>可以有效地避免死锁的发生，保证系统的安全性。</li>
<li>通过提前检查，可以最大化地利用资源，提高系统的并发性。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>计算开销大：</strong> 每次分配资源都需要运行安全性检查算法，增加了系统的开销。</li>
<li><strong>过于保守：</strong> 安全状态不等于无死锁，不安全状态也不等于一定发生死锁。算法为了确保安全，可能会拒绝一些本可以成功分配的请求，从而降低了系统的吞吐量。</li>
<li><strong>条件苛刻：</strong> 算法要求线程在开始前就声明其所需的最大资源量，这在实际应用中很难做到。</li>
<li><strong>资源数量固定：</strong> 算法假设系统中资源的数量是固定的，不能动态增减。</li>
</ul>
</li>
</ul>
<p>因此，银行家算法虽然在理论上非常完美，但在实际操作系统中很少被直接完整地实现。然而，它的核心思想——<strong>通过安全性检查来避免死锁</strong>——仍然是许多并发控制策略的重要理论基础。</p>
<h3 id="实际应用中的死锁处理"><a href="#实际应用中的死锁处理" class="headerlink" title="实际应用中的死锁处理"></a>实际应用中的死锁处理</h3><p>在实际的并发编程和数据库系统中，最常见的死锁处理方式是：</p>
<ul>
<li><p>死锁预防(通过编程规范)：</p>
<ul>
<li>加锁顺序一致：规定所有线程在获取多个锁时，必须按照相同的顺序。这是最有效的预防死锁的编程实践。</li>
<li>使用超时锁：尝试获取锁时设置一个超时时间，如果超时未获取到锁，则放弃本次操作并释放已持有的锁，然后重试。这破坏了”请求与保持”条件。例如Java的ReentrantLocktryLock(timeout)。</li>
<li>避免嵌套锁：尽量减少持有多个锁的情况。</li>
</ul>
</li>
<li><p>死锁检测与恢复(数据库系统)：</p>
<ul>
<li>大多数关系型数据库(如MySQL InnoDB)都实现了死锁检测机制。当检测到死锁时，数据库会自动选择一个成本较低的事务(“牺牲品”)进行回滚，从而解除死锁。客户端应用会收到相应的错误码(例如MySQL中的Deadlock found when trying to get lock; try restarting transaction)。应用程序通常需要捕获这个错误并重试事务。理解死锁的四个必要条件是关键，因为解决死锁的根本方法就是破坏其中一个或多个条件。</li>
</ul>
</li>
</ul>
<h2 id="多线程与线程池"><a href="#多线程与线程池" class="headerlink" title="多线程与线程池"></a>多线程与线程池</h2><p>在 Java 中，多线程是实现并发编程的关键技术，它允许程序同时执行多个任务。线程池则是管理和复用线程的重要机制，能有效提升系统性能和资源利用率。</p>
<h3 id="线程（Thread）的概念与生命周期"><a href="#线程（Thread）的概念与生命周期" class="headerlink" title="线程（Thread）的概念与生命周期"></a>线程（Thread）的概念与生命周期</h3><p>线程是操作系统调度的最小单位，是进程中的一个执行路径。一个进程可以包含多个线程，这些线程共享进程的内存空间。</p>
<p>线程的生命周期通常包含以下六种状态（定义在 java.lang.Thread.State 枚举中）：</p>
<ul>
<li><p>NEW（新建）：线程被创建但尚未启动。当使用 new Thread() 创建一个线程实例后，它就处于此状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello from a new thread!&quot;</span>));</span><br><span class="line"><span class="comment">// 此时 myThread 处于 NEW 状态，尚未执行 start()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>RUNNABLE（可运行）：线程已调用 start() 方法，正在 JVM 中运行（可能正在执行，也可能在等待 CPU 调度）。一个 RUNNABLE 状态的线程可能正在运行，也可能并没有运行，它仅仅是具备了运行的资格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myThread.start();</span><br><span class="line"><span class="comment">// 此时 myThread 进入 RUNNABLE 状态，等待 CPU 调度执行 run() 方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BLOCKED (阻塞)：线程正在等待获取一个监视器锁(例如，进入 synchronized 块或方法)。当一个线程试图访问被其他线程锁定的资源时，它会进入此状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 线程已经持有 lock 对象的锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// ... 线程 A 正在执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程 B 尝试获取 lock 对象的锁，但被线程 A 占用，会进入 BLOCKED 状态</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WAITING (等待)：线程无限制地等待另一个线程执行特定操作。例如，调用 Object.wait(), Thread.join() (无参数) 或 LockSupport.park().这些方法会使线程放弃 CPU 使用权，并进入无限制等待，直到被其他线程 notify(), notifyAll() 或 unpark() 唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">sharedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 线程 A:</span></span><br><span class="line"><span class="keyword">synchronized</span> (sharedObject) &#123;</span><br><span class="line">    sharedObject.wait(); <span class="comment">// 线程 A 进入 WAITING 状态，并释放 sharedObject 的锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程 B:</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line">threadA.start();</span><br><span class="line">threadA.join(); <span class="comment">// 线程 B 等待 threadA 执行完毕，进入 WAITING 状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TIMED_WAITING (有时限等待)：线程在指定的时间内等待另一个线程执行特定操作，或者休眠。例如，调用 Thread.sleep(long millis)、Object.wait(long timeout)、Thread.join(long millis)、LockSupport.parkNanos() 或 LockSupport.parkUntil()。一旦超时间到达，线程会自动从等待状态唤醒，并尝试重新进入 RUNNABLE 状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 线程进入 TIMED_WAITING 状态 1 秒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TERMINATED (终止): 线程已执行完毕其 run() 方法, 或者因未捕获的异常退出。线程一旦进入此状态, 就不能再被重新启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程的 run() 方法执行完毕</span></span><br><span class="line"><span class="comment">// 线程在执行过程中抛出未捕获的异常</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类:"></a>继承 Thread 类:</h4><ul>
<li>通过创建 Thread 类的子类, 并重写其 run() 方法, 在该方法中定义线程执行的任务。</li>
<li>创建 Thread 子类的实例, 并调用其 start() 方法来启动线程。调用 start() 方法会使线程进入 RUNNABLE 状态, 并由 JVM 调度执行 run() 方法; 直接调用 run() 方法则只是在当前线程中执行普通方法, 不会启动新线程。</li>
<li>优点: 实现简单直观, 代码结构清晰。</li>
<li>缺点: Java 是单继承的, 如果你的类已经继承了其他类, 就不能再继承 Thread 类。这限制了类的灵活性。此外, 任务 (run() 方法中的逻辑 ) 与线程本身 (Thread 对象) 紧密耦合, 不利于任务的复用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyThread.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + threadName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running via extending Thread.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread: &quot;</span> + threadName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">                <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + threadName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> + threadName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadCreationDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCreationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread started.&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;MyThread-1&quot;</span>);</span><br><span class="line">        thread1.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;MyThread-2&quot;</span>);</span><br><span class="line">        thread2.start(); <span class="comment">// 启动另一个新线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished starting other threads.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现-Runnable-接口："><a href="#实现-Runnable-接口：" class="headerlink" title="实现 Runnable 接口："></a>实现 <strong>Runnable</strong> 接口：</h4><ul>
<li>定义一个类实现 <strong>Runnable</strong> 接口，并实现其抽象方法 public void run()。run() 方法中包含线程执行的具体任务。</li>
<li>创建 <strong>Runnable</strong> 实现类的实例，然后将其作为参数传入 Thread 类的构造器 (new Thread(Runnable target))，再调用 Thread 实例的 start() 方法。</li>
<li>优点：<ul>
<li>推荐方式：避免了 Java 单继承的限制，你的类可以同时继承其他类来实现 <strong>Runnable</strong> 接口。</li>
<li>任务与线程解耦：Runnable 对象只负责定义任务，而 Thread 对象负责执行任务。这意味着同一个 <strong>Runnable</strong> 对象可以被多个 Thread 实例共享执行，从而更好地实现资源的共享和任务的复用。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyRunnable.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + taskName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running via implementing Runnable.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task: &quot;</span> + taskName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task &quot;</span> + taskName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task &quot;</span> + taskName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadCreationDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCreationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread started.&quot;</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;Runnable-Task-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable1);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;Runnable-Task-2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable2, <span class="string">&quot;Custom-Thread-Name&quot;</span>); <span class="comment">// 可以给线程命名</span></span><br><span class="line">        thread4.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished starting runnable threads.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><p><code>Callable</code> 是 Java 并发编程中一个非常重要的接口，它与 <code>Runnable</code> 类似，都用于定义一个可在线程中执行的任务。但 <code>Callable</code> 提供了更强大的功能，主要体现在两个方面：</p>
<ol>
<li><strong>可以返回结果：</strong> <code>Callable</code> 的 <code>call()</code> 方法可以返回一个泛型类型的结果。</li>
<li><strong>可以抛出异常：</strong> <code>Callable</code> 的 <code>call()</code> 方法可以声明抛出任何 <code>Exception</code>。</li>
</ol>
<p>这与 <code>Runnable</code> 接口形成了鲜明对比，<code>Runnable</code> 的 <code>run()</code> 方法没有返回值，也不能抛出受检异常（checked exception）。</p>
<ul>
<li><h3 id="Callable-的基本结构"><a href="#Callable-的基本结构" class="headerlink" title="Callable 的基本结构"></a><code>Callable</code> 的基本结构</h3></li>
</ul>
<p><code>Callable</code> 接口是一个泛型接口，定义如下：</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 计算并返回结果，或在无法做到时抛出异常。</span><br><span class="line">     * @return 计算结果</span><br><span class="line">     * @throws Exception 如果无法计算结果</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;V&gt;</code>：泛型参数，代表 <code>call()</code> 方法将要返回的结果类型。</p>
</li>
<li><p><code>V call()</code>：<code>call()</code> 方法的签名，它返回一个 <code>V</code> 类型的结果，并且可以抛出异常。</p>
</li>
<li><h3 id="如何使用-Callable"><a href="#如何使用-Callable" class="headerlink" title="如何使用 Callable"></a>如何使用 <code>Callable</code></h3></li>
</ul>
<p><code>Callable</code> 接口本身并不能直接作为 <code>Thread</code> 的构造参数。它需要配合 <code>ExecutorService</code> 线程池和 <code>Future</code> 接口一起使用。</p>
<p><strong>典型使用流程：</strong></p>
<ol>
<li><p><strong>创建 Callable 任务：</strong> 实现 <code>Callable</code> 接口，并在 <code>call()</code> 方法中编写具体的业务逻辑，返回一个结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务执行完毕，返回结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 ExecutorService 线程池：</strong> 使用 <code>Executors</code> 工厂类创建线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提交 Callable 任务：</strong> 使用 <code>ExecutorService</code> 的 <code>submit()</code> 方法提交任务。<code>submit()</code> 方法会返回一个 <code>Future</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">MyCallableTask</span>();</span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取任务结果：</strong> 通过 <code>Future</code> 对象的 <code>get()</code> 方法来获取 <code>Callable</code> 任务的执行结果。</p>
<ul>
<li><code>future.get()</code> 是一个<strong>阻塞</strong>方法，它会一直等待，直到任务执行完毕并返回结果。</li>
<li>如果任务执行过程中抛出了异常，<code>get()</code> 方法也会将这个异常包装在 <code>ExecutionException</code> 中重新抛出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 阻塞等待结果</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 线程被中断</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 任务执行过程中抛出的异常</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><h3 id="Callable-与-Runnable-的区别"><a href="#Callable-与-Runnable-的区别" class="headerlink" title="Callable 与 Runnable 的区别"></a><code>Callable</code> 与 <code>Runnable</code> 的区别</h3></li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>Callable</code></th>
<th><code>Runnable</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>返回值</strong></td>
<td><code>call()</code> 方法有返回值（泛型 <code>V</code>）</td>
<td><code>run()</code> 方法没有返回值（<code>void</code>）</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td><code>call()</code> 方法可以抛出受检异常</td>
<td><code>run()</code> 方法不能直接抛出受检异常</td>
</tr>
<tr>
<td><strong>执行方式</strong></td>
<td>必须配合 <code>ExecutorService.submit()</code> 执行</td>
<td>可以直接作为 <code>Thread</code> 构造函数的参数，也可以通过 <code>ExecutorService.execute()</code> 或 <code>submit()</code> 执行</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>适用于需要返回计算结果或可能抛出异常的异步任务</td>
<td>适用于简单的异步任务，不需要返回结果</td>
</tr>
</tbody></table>
<hr>
<ul>
<li><h3 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a><code>Future</code> 接口</h3></li>
</ul>
<p><code>Future</code> 接口是 <code>Callable</code> 的重要伴侣，它代表一个<strong>异步计算的结果</strong>。它提供了检查任务是否完成、等待任务完成以及获取任务结果的方法。</p>
<p><code>Future</code> 接口的主要方法：</p>
<ul>
<li><p><code>V get()</code>: 阻塞式地等待任务完成，并返回结果。</p>
</li>
<li><p><code>V get(long timeout, TimeUnit unit)</code>: 在指定时间内等待任务完成，超时则抛出 <code>TimeoutException</code>。</p>
</li>
<li><p><code>boolean isDone()</code>: 检查任务是否已经完成。</p>
</li>
<li><p><code>boolean cancel(boolean mayInterruptIfRunning)</code>: 尝试取消任务。</p>
</li>
<li><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
</ul>
<p><code>Callable</code> 是 Java 并发编程中一个更高级的任务抽象，它解决了 <code>Runnable</code> 接口无法返回结果和处理受检异常的痛点。通过与 <code>ExecutorService</code> 和 <code>Future</code> 接口的组合使用，<code>Callable</code> 使得异步编程变得更加简单和灵活，非常适合那些需要耗时计算并返回结果的场景，比如网络请求、数据处理等。</p>
<h4 id="线程池-Thread-Pool"><a href="#线程池-Thread-Pool" class="headerlink" title="线程池 (Thread Pool)"></a>线程池 (Thread Pool)</h4><p>线程池是一种基于池化思想的线程管理机制，用于管理和复用线程，而不是在每次需要执行任务时都创建新线程。</p>
<ul>
<li><p><strong>为什么使用线程池？</strong></p>
<ul>
<li>降低资源消耗:通过重复利用已创建的线程，降低线程创建和销毁的开销。</li>
<li>提高响应速度:当任务到达时，任务可以直接执行，无需等待线程创建。</li>
<li>提高线程的可管理性:线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配、调优和监控。</li>
<li>提供更多功能:如定时执行、周期执行、单线程化等。</li>
</ul>
</li>
<li><p><strong>线程池的核心参数 (ThreadPoolExecutor 构造方法)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">    TimeUnit unit,</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize: 核心线程数。线程池中始终保持的线程数量，即使它们处于空闲状态，除非设置了 allowCoreThreadTimeOut(true)。</li>
<li>maximumPoolSize: 最大线程数。线程池中允许存在的最大线程数量。当工作队列已满且核心线程都在忙碌时，线程池会创建新的非核心线程，直到达到这个数量。</li>
<li>keepAliveTime: 当线程池中的线程数量超过 corePoolSize 时，这些空闲的非核心线程在终止之前等待新任务的最长时间。</li>
<li>unit: keepAliveTime 参数的时间单位。</li>
<li>workQueue: 任务队列 (阻塞队列)。用于存放等待执行的任务。<ul>
<li>ArrayBlockingQueue: 基于数组的有界阻塞队列，需要指定容量。</li>
<li>LinkedBlockingQueue: 基于链表的阻塞队列，容量可以指定，也可以是无界的（默认）。如果使用无界队列，maximumPoolSize 参数将失效。</li>
<li>SynchronousQueue: 一个不存储元素的阻塞队列。每个插入操作必须等待一个对应的移除操作，反之亦然。</li>
<li>PriorityBlockingQueue: 支持优先级的无界阻塞队列，按照自然顺序或自定义比较器排序。</li>
</ul>
</li>
<li>threadFactory: 线程工厂。用于创建新线程，可以自定义线程的命名、优先级等。</li>
<li>handler: 拒绝策略 (当线程池和工作队列都已满时，新的任务到来时的处理方式)。<ul>
<li>ThreadPoolExecutor.AbortPolicy (默认): 直接抛出 RejectedExecutionException 异常。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy: 由调用线程 (提交任务的线程) 执行任务。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy: 丢弃队列中最老的任务，然后尝试提交当前任务。</li>
<li>ThreadPoolExecutor.DiscardPolicy: 直接丢弃当前新提交的任务。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线程池的执行流程</strong></p>
<ol>
<li>当一个任务提交到线程池时，如果当前运行的线程数小于 corePoolSize，即使有空闲线程，也会创建并启动一个新线程来执行任务。</li>
<li>如果当前运行的线程数大于或等于 corePoolSize，但任务队列 workQueue 未满，任务会被添加到 workQueue 中等待执行。</li>
<li>如果 workQueue 已满，但当前运行的线程数小于 maximumPoolSize，线程池会创建新的非核心线程来执行任务。</li>
<li>如果当前运行的线程数等于 maximumPoolSize 且 workQueue 已满，线程池会根据拒绝策略来处理新提交的任务。</li>
</ol>
</li>
<li><p><strong>Java 内置的四种常用线程池 (通过 Executors 工厂类创建)</strong></p>
<ul>
<li>FixedThreadPool (固定大小线程池)<ul>
<li>Executors.newFixedThreadPool(int nThreads)</li>
<li>corePoolSize &#x3D; maximumPoolSize &#x3D; nThreads</li>
<li>使用无界 LinkedBlockingQueue。</li>
<li>特点：可控制并发的线程数，超出的任务会在队列中等待。</li>
<li>问题：当任务提交速度远大于处理速度时，队列会不断增长，可能导致 OOM。</li>
</ul>
</li>
<li>SingleThreadExecutor (单线程线程池)<ul>
<li>Executors.newSingleThreadExecutor()</li>
<li>corePoolSize &#x3D; maximumPoolSize &#x3D; 1</li>
<li>使用无界 LinkedBlockingQueue。</li>
<li>特点：保证所有任务都在一个线程中按顺序执行。</li>
<li>问题：同 FixedThreadPool，队列无限增长可能导致 OOM。</li>
</ul>
</li>
<li>CachedThreadPool（可缓存线程池）<ul>
<li>Executors.newCachedThreadPool()</li>
<li>corePoolSize &#x3D; 0, maximumPoolSize &#x3D; Integer.MAX_VALUE</li>
<li>使用 SynchronousQueue。</li>
<li>keepAliveTime &#x3D; 60s</li>
<li>特点：当任务到来时，有空闲线程则复用，无空闲线程则创建新线程。适用于大量短时任务。</li>
<li>问题：maximumPoolSize 过大，当任务并发量极高时，可能创建大量线程，导致系统资源耗尽 (OOM)。</li>
</ul>
</li>
<li>ScheduledThreadPool（定时任务线程池）<ul>
<li>Executors.newScheduledThreadPool(int corePoolSize)</li>
<li>特点：支持定时及周期性任务执行。</li>
<li>内部使用 DelayedWorkQueue，一个无界队列，可以按时间进行排序。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>阿里巴巴开发手册建议：不推荐使用 Executors 创建线程池，而是手动通过 ThreadPoolExecutor 的构造方法创建，以明确线程池的运行规则，避免资源耗尽的风险。</strong></p>
</li>
</ul>
<h2 id="ThreadLocal："><a href="#ThreadLocal：" class="headerlink" title="ThreadLocal："></a>ThreadLocal：</h2><p>好的，我们来详细聊聊 <code>ThreadLocal</code>。</p>
<h3 id="ThreadLocal-是什么？"><a href="#ThreadLocal-是什么？" class="headerlink" title="ThreadLocal 是什么？"></a><code>ThreadLocal</code> 是什么？</h3><p><code>ThreadLocal</code>（线程本地变量）并不是用来解决线程间共享数据问题的，它的核心作用是<strong>为每个使用该变量的线程都提供一个独立的、隔离的副本</strong>。</p>
<p>你可以把 <code>ThreadLocal</code> 想象成一个“线程专属的储物柜”。每个线程都可以往这个储物柜里存东西（通过 <code>set()</code> 方法），取东西（通过 <code>get()</code> 方法），但它只能看到自己储物柜里的东西，无法访问其他线程的。</p>
<p><code>ThreadLocal</code> 内部其实是通过一个 <code>ThreadLocalMap</code> 来实现的。这个 Map 的键是 <code>ThreadLocal</code> 对象本身，值就是你存入的那个变量。每个线程都有一个属于自己的 <code>ThreadLocalMap</code>。</p>
<hr>
<h3 id="为什么需要-ThreadLocal？"><a href="#为什么需要-ThreadLocal？" class="headerlink" title="为什么需要 ThreadLocal？"></a>为什么需要 <code>ThreadLocal</code>？</h3><p>我们通常在开发中会遇到两种数据共享问题：</p>
<ol>
<li><strong>多个线程共享一个变量</strong>：这种情况下，需要通过 <code>synchronized</code>、<code>volatile</code> 或 <code>Lock</code> 来保证线程安全。</li>
<li><strong>每个线程需要一个独立的变量</strong>：这是 <code>ThreadLocal</code> 的主要应用场景。</li>
</ol>
<p>如果不用 <code>ThreadLocal</code>，我们可能需要自己手动维护一个 <code>Map&lt;Thread, Object&gt;</code>，每次存取数据时都以当前线程作为键。这样不仅麻烦，还容易出错。<code>ThreadLocal</code> 帮我们封装了这些细节，让使用变得非常简单。</p>
<hr>
<h3 id="ThreadLocal-的常见应用场景"><a href="#ThreadLocal-的常见应用场景" class="headerlink" title="ThreadLocal 的常见应用场景"></a><code>ThreadLocal</code> 的常见应用场景</h3><p><code>ThreadLocal</code> 最常见的应用场景是在 Web 开发中，用于<strong>存储与当前请求相关的上下文信息</strong>。</p>
<p>例如，一个 HTTP 请求从进入服务器到返回响应，可能由多个方法或组件来处理，但它们都属于同一个线程。如果需要传递一些请求相关的状态（比如用户身份、事务 ID、数据库连接），我们有很多种做法：</p>
<ul>
<li><strong>参数传递</strong>：将这些信息作为参数层层传递。这会导致方法签名变得臃肿，并且增加了代码的耦合性。</li>
<li><strong>静态变量</strong>：如果用静态变量，多个请求同时到达时会互相覆盖，导致线程不安全。</li>
<li><strong>ThreadLocal</strong>：这是最优雅的解决方案。你可以把这些信息存入 <code>ThreadLocal</code>，然后在任何需要的地方直接通过 <code>get()</code> 方法获取，无需在方法间显式传递。</li>
</ul>
<p><strong>典型的例子：</strong></p>
<ul>
<li><strong>Spring 的事务管理</strong>：Spring 框架在处理事务时，会使用 <code>ThreadLocal</code> 来保存每个线程的数据库连接，确保在同一个事务中的所有操作都使用同一个连接。</li>
<li><strong>上下文信息</strong>：例如，在请求处理链中，将用户登录信息、语言偏好等数据存入 <code>ThreadLocal</code>，下游的业务逻辑可以随时获取。</li>
</ul>
<hr>
<h3 id="ThreadLocal-可能带来的问题"><a href="#ThreadLocal-可能带来的问题" class="headerlink" title="ThreadLocal 可能带来的问题"></a><code>ThreadLocal</code> 可能带来的问题</h3><p>虽然 <code>ThreadLocal</code> 很好用，但如果使用不当，也可能导致一些问题。</p>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><strong>内存泄漏</strong></h4><p><code>ThreadLocal</code> 可能会导致<strong>内存泄漏</strong>。这是一个非常重要的问题。</p>
<p><code>ThreadLocalMap</code> 使用的是<strong>弱引用（Weak Reference）</strong> 作为键。这意味着，当 <code>ThreadLocal</code> 对象没有其他强引用时，即使它还在 <code>ThreadLocalMap</code> 中，垃圾回收器也会回收它。</p>
<p>但是，<code>ThreadLocalMap</code> 的值（也就是你存入的对象）是<strong>强引用</strong>。如果线程一直存活，但你不再使用 <code>ThreadLocal</code> 对象，<code>ThreadLocalMap</code> 中的键就会变成 <code>null</code>，但值还在。这样，值对象就无法被回收，导致内存泄漏。</p>
<p>如何避免？</p>
<p>解决这个问题的关键在于：在 ThreadLocal 使用完毕后，务必调用 remove() 方法。</p>
<p>在 Web 应用中，请求处理结束后，线程会被放回线程池。如果 <code>ThreadLocal</code> 没有被清除，那么下一次其他请求再拿到这个线程时，它会读取到上一个请求残留的数据，导致业务逻辑出错。因此，<strong>正确使用模式</strong>通常是：</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    threadLocal.set(&quot;My Data&quot;);</span><br><span class="line">    // do some work</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 确保在任何情况下都执行清理操作</span><br><span class="line">    threadLocal.remove(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a><strong>继承问题</strong></h4><p><code>ThreadLocal</code> 的值不会自动传递给子线程。如果你需要父线程创建子线程时，让子线程也能访问父线程的 <code>ThreadLocal</code> 值，你需要使用 <code>InheritableThreadLocal</code>。不过，<code>InheritableThreadLocal</code> 同样需要注意内存泄漏问题，并且在线程池环境下使用时可能会有意外行为，需要格外小心。</p>
<h2 id="Collection-集合框架"><a href="#Collection-集合框架" class="headerlink" title="Collection (集合框架):"></a>Collection (集合框架):</h2><ul>
<li>核心接口: Collection (父接口), List, Set, Map。</li>
<li>Iterable 接口: Collection 接口继承了 Iterable 接口,使得所有集合都可以通过增强for 循环(foreach)进行遍历。</li>
</ul>
<h4 id="A-List-接口及其实现类"><a href="#A-List-接口及其实现类" class="headerlink" title="A. List 接口及其实现类"></a>A. List 接口及其实现类</h4><p>List 是一种有序集合,可以包含重复元素。</p>
<h5 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h5><ul>
<li><p>底层实现:基于动态数组(Object[] elementData)实现。</p>
</li>
<li><p>特点:</p>
<ul>
<li>有序:元素有插入顺序,可以通过索引访问(get(index))。</li>
<li>可重复:允许存储重复元素。</li>
<li>随机访问效率高:通过索引访问元素(get(index))速度非常快,时间复杂度为O(1)。这是因为数组在内存中是连续存储的,可以通过基地址和偏移量直接计算出元素的内存地址。</li>
<li>插入和删除效率低:<ul>
<li>在数组末尾添加或删除元素效率较高(平均O(1))。</li>
<li>在数组中间插入或删除元素时,需要使用System.arraycopy()移动被影响位置之后的所有元素,时间复杂度为 O(n)。</li>
</ul>
</li>
<li>线程不安全:在多线程环境下,如果一个线程正在修改 ArrayList,而另一个线程正在读取或修改它,可能会导致数据不一致或 ConcurrentModificationException(在使用迭代器时)。</li>
</ul>
</li>
<li><p>扩容机制:</p>
<ul>
<li>初始容量:默认情况下,当你创建一个无参的ArrayList时,它的底层数组是空的(DEFAULTCAPACITY_EMPTY_ELEMENTDATA, 即 new Object[0])。首次添加元素时,内部数组会被初始化为默认容量 DEFAULT_CAPACITY (JDK8为10)。如果你在创建时指定了容量(new ArrayList&lt;&gt;(capacity)),则初始容量就是你指定的。</li>
<li>扩容时机:当ArrayList 的当前元素个数(size)等于底层数组的容量(elementData.length)时,就会触发扩容。</li>
<li>扩容方式:扩容逻辑位于grow()方法中。<ul>
<li>计算新的容量:newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),即新容量是旧容量的1.5倍。</li>
<li>如果计算出的新容量仍然小于需要的最小容量(minCapacity,即当前元素个数 size + 1),则直接将 minCapacity 作为新容量。</li>
<li>如果新容量超出了MAX_ARRAY_SIZE(通常是 Integer.MAX_VALUE-8),则会尝试使用 Integer.MAX_VALUE,如果仍不足则抛出 OutOfMemoryError。</li>
<li>创建一个新数组,并将旧数组中的元素复制到新数组中(Arrays.copyOf()内部调用 System.arraycopy())。</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么这么扩容(1.5倍):</p>
<ul>
<li>平衡空间与时间:<ul>
<li>相比于每次只增加1个元素,1.5倍的扩容策略减少了扩容的次数,从而减少了频繁进行数组复制带来的性能开销(数组复制是O(n)操作)。</li>
<li>相比于2倍扩容,1.5倍的策略在空间利用率上更优,避免了过度分配和浪费过多内存。</li>
</ul>
</li>
<li>这是一个在时间和空间之间权衡的选择,旨在提供一个相对高效且内存友好的动态数组实现。</li>
</ul>
</li>
<li><p>可能出现的问题:</p>
<ul>
<li>ConcurrentModificationException: 在多线程环境中,如果一个线程正在遍历 ArrayList(通过迭代器或增强 for循环),而另一个线程同时对其进行结构性修改(添加、删除元素等),就会抛出此异常。这是因为ArrayList 的迭代器是快速失败(fail-fast)的,它会检查 modCount(修改次数)是否与迭代器创建时一致。不一致则抛出异常。</li>
<li>内存开销:如果预估容量不准确,频繁扩容会导致多次数组复制,增加 CPU和内存开销。</li>
<li>内存浪费:如果初始容量设置过大,而实际使用的元素很少,会导致内存浪费。</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>add(E e): 在列表末尾添加元素。</li>
<li>add(int index, E e): 在指定位置插入元素。</li>
<li>remove(int index) &#x2F; remove(Object o): 删除指定位置或指定元素的第一个匹配项。</li>
<li>get(int index):获取指定位置的元素。</li>
<li>set(int index, E e): 替换指定位置的元素。</li>
<li>size(): 返回列表中元素的个数。</li>
<li>indexOf(Object o) &#x2F; lastIndexOf(Object o):返回元素第一次&#x2F;最后一次出现的索引。</li>
<li>contains(Object o): 判断是否包含某个元素。</li>
<li>clear(): 清空列表。</li>
</ul>
</li>
<li><p>遍历方式:</p>
<ol>
<li><p>传统 for 循环:</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增强 for 循环(foreach):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (E element: list) &#123; //内部使用迭代器</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器(Iterator):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">    // 如果需要删除元素,必须使用 it.remove(),否则会抛出</span><br><span class="line">    // ConcurrentModificationException</span><br><span class="line">    // it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8 Stream API:</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br><span class="line">// 或</span><br><span class="line">list.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h5 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h5><ul>
<li><p>底层实现:基于双向链表(Doubly Linked List)实现。每个节点都包含数据,以及指向前一个节点和后一个节点的引用。</p>
</li>
<li><p>特点:</p>
<ul>
<li>有序:元素有插入顺序。</li>
<li>可重复:允许存储重复元素。</li>
<li>插入和删除效率高:在链表的任何位置插入或删除元素,只需修改前后节点的引用,时间复杂度为O(1)。</li>
<li>随机访问效率低:get(index)操作需要从头节点或尾节点开始遍历链表直到目标索引,时间复杂度为O(n)。</li>
<li>内存开销大:每个节点除了存储数据本身,还需要额外的内存空间存储两个指针(prev 和 next),因此相比 ArrayList,在存储相同数量元素时, LinkedList 占用更多内存。</li>
<li>线程不安全:与ArrayList 类似,在多线程环境下不安全,可能抛出 ConcurrentModificationException。</li>
</ul>
</li>
<li><p>扩容机制:</p>
<ul>
<li>LinkedList 基于链表实现,没有固定容量的概念,也无需进行扩容。每次添加元素就是创建一个新节点并连接到链表中。因此不存在 ArrayList 那样的数组复制开销。</li>
</ul>
</li>
<li><p>可能出现的问题:</p>
<ul>
<li>ConcurrentModification Exception:同样在多线程环境下使用迭代器进行修改时可能发生。</li>
<li>内存碎片&#x2F;开销:频繁的节点创建和销毁,以及每个节点额外的指针开销,可能导致一定的内存碎片和更高的内存占用。</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>add(E e) &#x2F; addFirst(E e) &#x2F; addLast(E e): 添加元素。</li>
<li>remove() &#x2F; removeFirst() &#x2F; removeLast():删除元素。</li>
<li>get(int index) &#x2F; getFirst() &#x2F; getLast(): 获取元素(get(int index)效率低)。</li>
<li>peek() &#x2F; peekFirst() &#x2F; peekLast(): 获取但不移除头部&#x2F;尾部元素。</li>
<li>offer(E e) &#x2F; offerFirst(E e) &#x2F; offerLast (E e): 添加元素到队列&#x2F;双端队列(通常不抛异常)。</li>
<li>poll() &#x2F; pollFirst() &#x2F; pollLast(): 获取并移除头部&#x2F;尾部元素(为空返回null)。</li>
<li>push(E e) &#x2F; pop():实现栈的入栈和出栈操作。</li>
<li>size(), isEmpty(), contains(Object o), clear().</li>
</ul>
</li>
<li><p>遍历方式:</p>
<ol>
<li><p>传统 for 循环: <code>for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125;</code>(不推荐,效率低)</p>
</li>
<li><p>增强 for 循环(foreach): <code>for (E element: list) &#123; System.out.println(element); &#125;</code>(推荐)</p>
</li>
<li><p>迭代器(Iterator):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8 Stream API: <code>list.forEach(System.out::println);</code></p>
</li>
</ol>
</li>
</ul>
<h5 id="3-Vector"><a href="#3-Vector" class="headerlink" title="3. Vector"></a>3. Vector</h5><ul>
<li>底层实现:基于动态数组实现,与ArrayList 类似。</li>
<li>特点:<ul>
<li>线程安全:所有公共方法都使用了synchronized 关键字进行同步,因此是线程安全的。</li>
<li>效率低:因为所有操作都被同步,在单线程或并发读多写少的场景下,性能比 ArrayList 差。</li>
<li>扩容机制: Vector 的扩容策略与 ArrayList 类似,但默认是翻倍扩容(即新容量是旧容量的2倍)。可以通过构造函数指定扩容增量。</li>
</ul>
</li>
<li>可能出现的问题:<ul>
<li>性能瓶颈:全局锁导致并发性能差。</li>
</ul>
</li>
<li>使用场景:已经被 java.util.concurrent 包中的并发集合(如 CopyOnWriteArrayList)取代,基本不再推荐使用。</li>
</ul>
<h5 id="4-Stack"><a href="#4-Stack" class="headerlink" title="4. Stack"></a>4. Stack</h5><ul>
<li>底层实现:继承自Vector,因此也是基于数组实现,并具有Vector 的线程安全性。</li>
<li>特点:实现了后进先出(LIFO)的栈结构。</li>
<li>常用方法:<ul>
<li>push(E item):元素入栈。</li>
<li>pop():元素出栈。</li>
<li>peek(): 查看栈顶元素但不移除。</li>
<li>empty(): 判断栈是否为空。</li>
<li>search(Object o): 查找元素并返回离栈顶的距离。</li>
</ul>
</li>
<li>使用场景:不推荐使用,因为Stack 继承了Vector,而 Vector 本身有很多不适合栈操作的方法。通常使用 Deque 接口的实现类(如ArrayDeque 或 LinkedList)来代替栈,它们更灵活高效。</li>
</ul>
<h4 id="小结-List"><a href="#小结-List" class="headerlink" title="小结 List:"></a>小结 List:</h4><ul>
<li>ArrayList: 随机访问多,插入删除少(尤其末尾操作)的场景。</li>
<li>LinkedList: 插入删除多,随机访问少的场景;或需要作为队列&#x2F;栈使用的场景。</li>
<li>Vector &#x2F; Stack:不推荐在现代Java开发中使用,除非有特殊历史兼容需求。</li>
</ul>
<h4 id="B-Set-接口及其实现类"><a href="#B-Set-接口及其实现类" class="headerlink" title="B. Set 接口及其实现类"></a>B. Set 接口及其实现类</h4><p>Set 是一种无序集合,不允许重复元素。</p>
<h5 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h5><ul>
<li><p>底层实现:基于HashMap 实现。HashSet 内部使用一个 HashMap 实例来存储元素,HashSet 的元素作为HashMap的键(Key),而HashMap 的值(Value)则是一个固定的、无关紧要的 PRESENT 静态 Object 对象。</p>
</li>
<li><p>特点:</p>
<ul>
<li>无序:不保证元素的存储顺序和迭代顺序。</li>
<li>不可重复:元素唯一。通过元素的hashCode() 和 equals() 方法来判断元素的唯一性。当添加元素时,首先计算元素的hashCode(),然后根据哈希值找到对应的“桶”,再在该桶中遍历,如果存在 equals()为true 的元素,则不添加。</li>
<li>允许 null元素:允许且只能存储一个 null 元素。</li>
<li>查询、添加、删除的平均时间复杂度为(1) (在不发生哈希冲突或冲突较少的情况下)。最坏情况下(所有元素哈希冲突到同一个桶),会退化为 O(n)。</li>
<li>线程不安全:与HashMap 类似,非同步。</li>
</ul>
</li>
<li><p>扩容机制:</p>
<ul>
<li>由于底层是HashMap,其扩容机制与 HashMap 完全相同。</li>
<li>初始容量:默认初始容量为16。</li>
<li>负载因子:默认负载因子为0.75。</li>
<li>扩容时机:当HashSet 中存储的元素数量达到容量*负载因子时,就会进行扩容,新容量是旧容量的2倍。</li>
<li>扩容过程:创建一个新的两倍大小的底层数组,然后遍历旧数组中的所有元素,重新计算它们的哈希值,并将它们放入新数组的正确位置。</li>
</ul>
</li>
<li><p>可能出现的问题:</p>
<ul>
<li>性能下降: 如果自定义类作为元素存储在 HashSet 中，但没有正确重写 hashCode() 和 equals() 方法，可能会导致元素重复，或者哈希冲突严重，从而导致性能急剧下降。</li>
<li>ConcurrentModicationException: 同步性问题，在多线程环境下使用迭代器修改集合时会抛出。</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>add(E e): 添加元素。</li>
<li>remove(Object o): 删除元素。</li>
<li>contains(Object o): 判断是否包含元素。</li>
<li>size(): 返回集合中元素的个数。</li>
<li>isEmpty(), clear().</li>
</ul>
</li>
<li><p>遍历方式:</p>
<ol>
<li><p>增强 for 循环 (foreach): <code>for (E element : set) &#123; System.out.println(element); &#125;</code></p>
</li>
<li><p>迭代器 (Iterator):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = set.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8 Stream API: <code>set.forEach(System.out::println);</code></p>
</li>
</ol>
</li>
</ul>
<h5 id="2-LinkedHashSet"><a href="#2-LinkedHashSet" class="headerlink" title="2. LinkedHashSet"></a>2. LinkedHashSet</h5><ul>
<li>底层实现: 继承自 HashSet，内部使用 LinkedHashMap 实现。</li>
<li>特点:<ul>
<li>除了具备 HashSet 的所有特性外，最大的特点是保持元素的插入顺序（或者访问顺序，如果配置为 LRU 缓存）。这意味着遍历 LinkedHashSet时，元素的顺序与它们被添加到集合中的顺序一致。</li>
<li>维护了一个双向链表，用于维护元素的插入顺序。</li>
</ul>
</li>
<li>扩容机制: 与 HashSet 和 HashMap 相同。</li>
<li>使用场景: 需要去重，同时又需要保持元素插入顺序的场景。</li>
</ul>
<h5 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3. TreeSet"></a>3. TreeSet</h5><ul>
<li>底层实现: 基于 TreeMap 实现。TreeSet 内部使用一个 TreeMap 实例来存储元素，TreeSet 的元素作为 TreeMap 的键，而值则是一个固定的 Object。</li>
<li>特点:<ul>
<li>有序: 元素会根据其自然排序（元素必须实现 Comparable 接口）或者在创建 TreeSet 时提供的 Comparator 进行排序。</li>
<li>不可重复: 元素唯一，唯一性通过比较结果判断（compareTo() 或 compare() 方法返回 0）。</li>
<li>不允许 null 元素: 不允许存储 null 元素（因为 null 无法进行比较）。</li>
<li>查询、添加、删除的时间复杂度为 O(log n)，因为底层是红黑树。</li>
<li>线程不安全: 非同步。</li>
</ul>
</li>
<li>扩容机制:<ul>
<li>由于底层是红黑树，没有传统意义上的扩容机制。每次添加元素就是增加一个节点，并根据红黑树的平衡规则进行调整（旋转和变色）来保持树的平衡。</li>
</ul>
</li>
<li>可能出现的问题:<ul>
<li>性能: 相比 HashSet，性能略低，因为涉及比较和树的平衡操作。</li>
<li>元素必须可比较: 如果存储的元素没有实现 Comparable 接口，或者创建 TreeSet 时没有提供 Comparator，则会抛出 ClassCastException。</li>
<li>ConcurrentModicationException: 同步性问题。</li>
</ul>
</li>
<li>常用方法:<ul>
<li>与 HashSet 类似，但额外提供了与排序相关的方法，如 rst(), last(), headSet(), tailSet(), subSet() 等。</li>
</ul>
</li>
</ul>
<h4 id="小结-Set"><a href="#小结-Set" class="headerlink" title="小结 Set:"></a>小结 Set:</h4><ul>
<li>HashSet: 最常用，需要快速查找、去重，不关心元素顺序的场景。</li>
<li>LinkedHashSet: 需要去重，同时又需要保持元素插入顺序的场景。</li>
<li>TreeSet: 需要去重，并且希望元素自动按照自然顺序或自定义顺序排序的场景。</li>
</ul>
<h4 id="C-Map-接口及其实现类"><a href="#C-Map-接口及其实现类" class="headerlink" title="C. Map 接口及其实现类"></a>C. Map 接口及其实现类</h4><p>Map 存储键值对，键是唯一的，值可以重复。</p>
<h5 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h5><ul>
<li><p>底层实现: 基于哈希表实现，JDK 8 及以后是数组 + 链表 + 红黑树。</p>
<ul>
<li>数组: Node</li>
<li>链表: 用于解决哈希冲突，将哈希到同一个索引位置的键值对以链表形式连接。</li>
<li>红黑树: 当链表长度达到一定阈值（JDK 8 默认为 8）时，为了提高查找效率，该链表会转换为红黑树。当红黑树节点数少于一定阈值（JDK 8 默认为 6）时，会退化为链表。</li>
</ul>
</li>
<li><p>特点:</p>
<ul>
<li>无序: 不保证键值对的存储和迭代顺序。</li>
<li>键唯一，值可重复: 键通过 hashCode() 和 equals() 方法确定唯一性。</li>
<li>允许 null 键和 null 值: 只能有一个 null 键（存储在索引 0 的位置），可以有多个 null 值。</li>
<li>查询、添加、删除的平均时间复杂度为 O(1)，最坏情况下为 O(n)（链表）或 O(logn)（红黑树，JDK 8 及以后）。</li>
</ul>
</li>
<li><p>扩容机制:</p>
<ul>
<li><p>初始容量 (initialCapacity): 默认值为 16。最好在创建 HashMap 时预估并指定一个合适的初始容量，以减少扩容次数。</p>
</li>
<li><p>负载因子 (loadFactor): 默认值为 0.75。表示哈希表在进行扩容前的填充比例。</p>
</li>
<li><p>扩容时机: 当 HashMap 中存储的元素数量 (size) 达到 容量 * 负载因子 (即 threshold) 时，就会触发扩容。</p>
</li>
<li><p>扩容方式: resize() 方法。</p>
<ol>
<li>创建一个新的两倍大小的底层数组。</li>
<li>遍历旧数组中的所有键值对。</li>
<li>重新计算每个键的哈希值，并根据新的容量大小，将其放入新数组的正确位置。这个过程被称为再哈希 (rehash)。</li>
</ol>
<ul>
<li>JDK 8 优化: 在链表转换时，避免了每个节点单独重新计算哈希值，而是根据原索引和新容量的关系，直接判断节点在新数组中的位置，提高了效率。</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么这么扩容 (2 倍):</p>
<ul>
<li>位运算优化: 容量始终保持 2 的幂次方，可以利用位运算 (h &amp; (length - 1)) 来替代取模运算 h % length，提高哈希值到索引的映射效率。</li>
<li>减少哈希冲突: 扩容为 2 倍可以有效分散哈希冲突，使得更多的键能够映射到不同的桶，从而降低链表&#x2F;红黑树的长度，保持 O(1) 的平均性能。</li>
</ul>
</li>
<li><p>为什么负载因子是 0.75:</p>
<ul>
<li>这是一个在“空间利用率”和“查询效率”之间的权衡。</li>
<li>如果负载因子过小，会频繁扩容，浪费空间。</li>
<li>如果负载因子过大，哈希冲突会增加，链表&#x2F;红黑树变长，导致查询效率下降。</li>
<li>0.75 这个值是经过实践验证，在大多数情况下能够提供较好性能的平衡点。</li>
</ul>
</li>
<li><p>可能出现的问题:</p>
<ul>
<li>性能下降: 如果自定义类作为键存储在 HashMap 中，但没有正确重写 hashCode() 和 equals() 方法，会导致元素重复，或者哈希冲突严重，从而导致性能急剧下降。</li>
<li>多线程问题: 在多线程环境下，对 HashMap 进行修改操作可能导致数据丢失、死循环（JDK 7 及以前），或 ConcurrentModicationException。这是其最大的问题。</li>
<li>内存开销: 频繁扩容会带来数组复制的开销。</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>put(K key, V value): 关联键值对。</li>
<li>get(Object key):</li>
</ul>
</li>
<li><p>遍历方式:</p>
<ol>
<li><p>遍历键集 (keySet()):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (K key : map.keySet()) &#123;</span><br><span class="line">    V value = map.get(key);</span><br><span class="line">    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历键值对集 (entrySet()) - 推荐，效率最高:</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Value: &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历值集 (values()):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (V value : map.values()) &#123;</span><br><span class="line">    System.out.println(&quot;Value: &quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器 (Iterator):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = it.next();</span><br><span class="line">    System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Value: &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8 Stream API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h5 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2. LinkedHashMap"></a>2. LinkedHashMap</h5><ul>
<li>底层实现: 继承自 HashMap，额外维护了一个双向链表，用于维护插入顺序或访问顺序。</li>
<li>特点:<ul>
<li>除了具备 HashMap 的所有特性外，最大的特点是保持键值对的插入顺序（或访问顺序）。这意味着遍历 LinkedHashMap 时，元素的顺序与它们被添加到 Map 中的顺序一致。</li>
<li>可以用于实现 LRU (Least Recently Used) 缓存策略，通过覆盖 removeEldestEntry 方法并设置访问顺序为 true。</li>
</ul>
</li>
<li>扩容机制: 与 HashMap 相同。</li>
<li>使用场景: 需要快速查找，同时又需要保持插入顺序的场景。</li>
</ul>
<h5 id="3-TreeMap"><a href="#3-TreeMap" class="headerlink" title="3. TreeMap"></a>3. TreeMap</h5><ul>
<li>底层实现: 基于红黑树（Red-Black Tree）实现。</li>
<li>特点:<ul>
<li>有序: 键会根据其自然排序（键的类型必须实现 Comparable 接口）或者在创建 TreeMap 时提供的 Comparator 进行排序。</li>
<li>键唯一，值可重复: 唯一性判断依赖于键的比较结果（compareTo() 或 compare() 方法返回 0）。</li>
<li>不允许 null 键: 不允许存储 null 键（因为 null 无法进行比较），但允许 null 值。</li>
<li>查询、添加、删除的时间复杂度为 O(log n)，因为底层是红黑树。</li>
<li>线程不安全: 非同步。</li>
</ul>
</li>
<li>扩容机制:<ul>
<li>由于底层是红黑树，没有传统意义上的扩容机制。每次添加键值对就是增加一个节点，并根据红黑树的平衡规则进行调整（旋转和变色）来保持树的平衡。</li>
</ul>
</li>
<li>可能出现的问题:<ul>
<li>性能: 相比 HashMap，性能略低，因为涉及比较和树的平衡操作。</li>
<li>键必须可比较: 如果键没有实现 Comparable 接口，或者创建 TreeMap 时没有提供 Comparator，则会抛出 ClassCastException。</li>
<li>ConcurrentModicationException: 同步性问题。</li>
</ul>
</li>
<li>常用方法:<ul>
<li>与 HashMap 类似，但额外提供了与排序相关的方法，如 rstKey(), lastKey(), ceilingEntry(), oorEntry() 等。</li>
</ul>
</li>
</ul>
<h5 id="4-Hashtable"><a href="#4-Hashtable" class="headerlink" title="4. Hashtable"></a>4. Hashtable</h5><ul>
<li>底层实现: 基于哈希表实现，与 HashMap 类似，但所有方法都使用了 synchronized 关键字。</li>
<li>特点:<ul>
<li>线程安全: 所有公共方法都进行了同步处理。</li>
<li>效率低: 全局锁导致并发性能差。</li>
<li>不允许 null 键和 null 值。</li>
<li>初始容量和扩容机制: 默认初始容量 11，负载因子 0.75。扩容时新容量是旧容量的 2 倍 + 1。</li>
</ul>
</li>
<li>使用场景: 已被 ConcurrentHashMap 取代，基本不再推荐使用。</li>
</ul>
<h5 id="5-ConcurrentHashMap-JUC-包中的并发集合"><a href="#5-ConcurrentHashMap-JUC-包中的并发集合" class="headerlink" title="5. ConcurrentHashMap (JUC 包中的并发集合)"></a>5. ConcurrentHashMap (JUC 包中的并发集合)</h5><ul>
<li><p>底层实现:</p>
<ul>
<li>JDK 7 及以前: 采用分段锁 (Segment) 的方式，将 HashMap 内部数据分成多个段（Segment），每个段是一个独立的 ReentrantLock。锁住某个段时，不影响其他段的操作。</li>
<li>JDK 8 及以后: 放弃了分段锁，改为使用 CAS (Compare-And-Swap) 操作和 synchronized 关键字（只在链表&#x2F;红黑树头节点发生竞争时才使用，锁住的范围更小）来保证线程安全。</li>
</ul>
</li>
<li><p>特点:</p>
<ul>
<li>线程安全: 高并发环境下性能优异。</li>
<li>不允许 null 键和 null 值。</li>
<li>读操作基本无锁。</li>
</ul>
</li>
<li><p>扩容机制: 与 HashMap 类似，JDK 8 中，每个 Node 数组的扩容是独立的，通过 transfer 方法实现。</p>
</li>
<li><p>使用场景: 高并发场景下替代 HashMap 和 Hashtable 的首选。</p>
</li>
<li><p><code>java.util.concurrent</code> (JUC) 包是 Java 并发编程的高级工具包，它提供了比传统 <code>synchronized</code> 关键字和 <code>wait/notify</code> 机制更强大、更灵活的并发控制手段。</p>
<p><strong>并发工具类</strong></p>
<p>这些工具类都是为了解决特定场景下的线程协作问题而设计的，它们是 JUC 包的精华所在。</p>
<ul>
<li><strong>CountDownLatch (倒计时器)</strong>：就像一个比赛的倒计时牌。主线程在等待，而其他多个子线程在执行自己的任务。每完成一个任务，倒计时就减一。当倒计时减到零时，主线程才能继续执行。这非常适合“一等多”的场景，比如主线程需要等待所有子线程的数据加载完成后再开始处理。</li>
<li><strong>CyclicBarrier (循环屏障)</strong>：可以看作是一个“集合点”。多个线程都跑到这里，互相等待。当所有线程都到达集合点后，它们才会一起继续前进。这个过程可以重复使用（“循环”），适合需要多个线程分阶段同步执行的场景。</li>
<li><strong>Semaphore (信号量)</strong>：用来控制同时访问某个资源的线程数量。你可以把它想象成一个拥有固定数量许可证的停车场。当一个线程需要访问资源时，它就获取一个许可证。当许可证用完时，其他线程就必须等待。线程用完资源后归还许可证，下一个线程才能进入。这可以用来限制并发连接数，比如数据库连接池。</li>
<li><strong>Exchanger (交换器)</strong>：提供一个两个线程间的数据交换点。当两个线程都运行到这个同步点时，它们会互相交换数据。这通常用于两个线程互相传递数据的场景，比如生产者和消费者线程之间的协作。</li>
</ul>
<p><strong>原子操作类</strong></p>
<ul>
<li><strong>AtomicInteger, AtomicLong 等原子类</strong>：这些类提供了一些“原子性”的操作，意思是这些操作是不可分割的。例如，<code>i++</code> 在多线程环境下不是一个原子操作，可能导致数据不一致。而 <code>AtomicInteger</code> 的 <code>incrementAndGet()</code> 方法就能保证自增操作是线程安全的，并且性能比使用 <code>synchronized</code> 关键字要高。它们通常用于需要对单个变量进行安全、高效地更新的场景。</li>
</ul>
</li>
</ul>
<h4 id="小结-Map"><a href="#小结-Map" class="headerlink" title="小结 Map:"></a>小结 Map:</h4><ul>
<li>HashMap: 最常用，需要快速查找，不关心键值对顺序，且在单线程或由外部同步机制保证线程安全的场景。</li>
<li>LinkedHashMap: 需要快速查找，同时需要保持插入顺序或访问顺序的场景（如实现 LRU 缓存）。</li>
<li>TreeMap: 需要根据键的自然顺序或自定义顺序排序的场景。</li>
<li>ConcurrentHashMap: 高并发场景下对 Map 进行读写操作的首选。</li>
<li>Hashtable: 已被淘汰，不推荐使用。</li>
</ul>
<h2 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO 流"></a>Java IO 流</h2><p>Java IO (Input&#x2F;Output) 流是用于处理计算机与外部设备之间数据传输的抽象概念。它将数据抽象为流 (Stream)，通过流可以实现数据的输入和输出。</p>
<h3 id="IO-流的分类"><a href="#IO-流的分类" class="headerlink" title="IO 流的分类"></a>IO 流的分类</h3><p>Java IO 流根据不同的标准有多种分类方式：</p>
<ul>
<li>按数据类型分：<ul>
<li>字节流：处理字节数据，所有文件类型（文本、图片、音视频等）都可以用字节流处理。<ul>
<li>抽象基类：InputStream（输入流）、OutputStream（输出流）。</li>
<li>常用实现：FileInputStream&#x2F;FileOutputStream（文件操作），BufferedInputStream&#x2F;BufferedOutputStream（带缓冲），ObjectInputStream&#x2F;ObjectOutputStream（对象序列化），ByteArrayInputStream&#x2F;ByteArrayOutputStream（内存操作），DataInputStream&#x2F;DataOutputStream（基本数据类型操作）。</li>
</ul>
</li>
<li>字符流：处理字符数据，专门用于处理文本文件。<ul>
<li>抽象基类：Reader（输入流）、Writer（输出流）。</li>
<li>常用实现：FileReader&#x2F;FileWriter（文件操作），BufferedReader&#x2F;BufferedWriter（带缓冲），InputStreamReader&#x2F;OutputStreamWriter（字节流与字符流的转换）。</li>
</ul>
</li>
</ul>
</li>
<li>按流向分：<ul>
<li>输入流：从数据源读取数据到程序中。</li>
<li>输出流：从程序中写入数据到目的地。</li>
</ul>
</li>
<li>按功能分：<ul>
<li>节点流（或源头流）：直接与数据源（如文件、内存、网络连接）连接的流。例如FileInputStream、FileReader。</li>
<li>处理流（或包装流）：对已存在的节点流进行包装，增加新的功能或提升性能。例如BufferedInputStream、BufferedReader。</li>
</ul>
</li>
</ul>
<h3 id="常用-IO-操作"><a href="#常用-IO-操作" class="headerlink" title="常用 IO 操作"></a>常用 IO 操作</h3><ul>
<li><p>文件读写（字节流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    fos.write(<span class="string">&quot;Hello, World!&quot;</span>.getBytes());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">while</span> ((data = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件读写（字符流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output_char.txt&quot;</span>)) &#123;</span><br><span class="line">    fw.write(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;output_char.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">while</span> ((data = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓冲流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用缓冲字节流复制文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.txt&quot;</span>));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;destination.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个可序列化的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 序列化版本UID</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">transient</span> String password; <span class="comment">// transient 关键字修饰的字段不参与序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User(name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, password=&quot;</span> + password + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    oos.writeObject(user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;user.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">deserializedUser</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">    System.out.println(deserializedUser); <span class="comment">// password 字段将为 null</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="NIO-New-Input-Output"><a href="#NIO-New-Input-Output" class="headerlink" title="NIO (New Input&#x2F;Output)"></a>NIO (New Input&#x2F;Output)</h3><p>Java NIO (New I&#x2F;O) 是在 JDK 1.4 中引入的一套新的 I&#x2F;O API，它提供了非阻塞 I&#x2F;O 的能力，并引入了“通道 (Channel)”和“缓冲区 (Buffer)”的概念，与传统的基于流 (Stream) 的 I&#x2F;O 相比，NIO 更加高效。</p>
<p><strong>核心组件：</strong></p>
<ul>
<li>Channel (通道): 类似于传统 IO 中的流，但可以双向读写。数据总是通过通道读入缓冲区或从缓冲区写入通道。<ul>
<li>常用实现: FileChannel (文件), SocketChannel (TCP 客户端), ServerSocketChannel (TCP 服务器), DatagramChannel (UDP)。</li>
</ul>
</li>
<li>Buffer (缓冲区): 用于存储数据 (字节数组)，与通道进行交互。所有数据读写都是通过缓冲区完成的。缓冲区有多种类型，如 ByteBuffer、CharBuffer、IntBuffer 等。<ul>
<li>核心属性：<ul>
<li>capacity: 缓冲区可容纳的最大数据量。一旦创建，容量不可变。</li>
<li>limit: 缓冲区中可读或可写的上限。</li>
<li>position: 下一个读或写的位置。</li>
<li>mark: 标记当前 position，可以通过 reset() 恢复到 mark 的位置。</li>
</ul>
</li>
<li>主要方法：<ul>
<li>put(): 向缓冲区写入数据。</li>
<li>get(): 从缓冲区读取数据。</li>
<li>flip(): 将缓冲区从写模式切换到读模式。limit 会设置为当前的 position, position 会重置为 0。</li>
<li>clear(): 清空缓冲区，为新的写入做准备。position 设为 0, limit 设为 capacity。</li>
<li>compact(): 压缩缓冲区，将未读的数据移到缓冲区开头，position 设为未读数据数量，limit 设为 capacity。</li>
<li>rewind(): 将 position 设为 0，可以重复读取缓冲区中的数据。</li>
</ul>
</li>
</ul>
</li>
<li>Selector (选择器): 用于监听多个通道上的事件 (如连接就绪、读就绪、写就绪等)。一个单线程可以管理多个通道，从而实现非阻塞 I&#x2F;O。</li>
</ul>
<p><strong>NIO 与传统 IO 的区别：</strong></p>
<ul>
<li>I&#x2F;O 模式:传统 IO 是阻塞式 I&#x2F;O, NIO 是非阻塞式 I&#x2F;O。</li>
<li>流与缓冲区:传统 IO 基于流(单向), NIO 基于通道和缓冲区(双向)。</li>
<li>同步与异步:传统 IO 是同步阻塞的, NIO 是同步非阻塞的(在多路复用模型下)。</li>
</ul>
<p><strong>NIO 文件复制示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">     <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;destination_nio.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> fos.getChannel()) &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (inChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buffer.flip(); <span class="comment">// 切换到读模式</span></span><br><span class="line">        outChannel.write(buffer); <span class="comment">// 从缓冲区写入通道</span></span><br><span class="line">        buffer.clear(); <span class="comment">// 清空缓冲区, 为下次写入做准备</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AIO-Asynchronous-Input-Output"><a href="#AIO-Asynchronous-Input-Output" class="headerlink" title="AIO (Asynchronous Input&#x2F;Output)"></a>AIO (Asynchronous Input&#x2F;Output)</h3><p>Java AIO (Asynchronous I&#x2F;O) 是在 JDK 7 中引入的，也称为 NIO 2.0。它提供了真正的异步非阻塞 I&#x2F;O，通过回调机制来处理 I&#x2F;O 操作的结果。与 NIO 的同步非阻塞不同，AIO 在 I&#x2F;O 操作完成后会主动通知应用程序。</p>
<ul>
<li><p><strong>核心概念:</strong></p>
<ul>
<li>AsynchronousFileChannel:异步文件通道。</li>
<li>AsynchronousSocketChannel:异步 Socket 通道。</li>
<li>AsynchronousServerSocketChannel:异步 Server Socket 通道。</li>
<li>CompletionHandler:回调处理器接口，定义了 completed() (操作成功) 和 failed() (操作失败) 方法。</li>
<li>Future:也可以通过返回 Future 对象来获取异步操作的结果。</li>
</ul>
</li>
<li><p>**工作原理:**当发起一个 I&#x2F;O 操作时，不再需要等待操作完成，而是立即返回。I&#x2F;O 操作由操作系统在后台完成，完成后通过回调函数通知应用程序。</p>
</li>
<li><p><strong>AIO 优势:</strong></p>
<ul>
<li>真正的异步非阻塞:应用程序不需要等待 I&#x2F;O 操作，可以将 CPU 资源用于其他任务。</li>
<li>提高并发性:特别适合高并发、长连接的网络应用。</li>
</ul>
</li>
<li><p><strong>AIO 劣势:</strong></p>
<ul>
<li>复杂性:编程模型相对于 NIO 更复杂，需要处理回调逻辑。</li>
<li>适用场景:对于连接数较多且连接时间长的应用，如聊天服务器，AIO 表现优异。对于短连接、高并发的场景，NIO（基于 Selector）可能表现更好。</li>
</ul>
</li>
<li><p><strong>AIO 读文件示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">file</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;async_read.txt&quot;</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(file, StandardOpenOption.READ)) &#123;</span><br><span class="line">    fileChannel.read(buffer, <span class="number">0</span>, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Read &quot;</span> + result + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">            attachment.flip();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[attachment.remaining()];</span><br><span class="line">            attachment.get(data);</span><br><span class="line">            System.out.println(<span class="string">&quot;Content: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Read failed: &quot;</span> + exc.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 为了让主线程不立即退出，等待异步操作完成</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Java-反射-Reflection"><a href="#Java-反射-Reflection" class="headerlink" title="Java 反射 (Reflection)"></a>Java 反射 (Reflection)</h2><p>Java 反射机制是指在程序运行时，能够动态地获取类的信息（包括类的属性、方法、构造器等），并能够动态地操作类或对象（如创建对象、调用方法、修改属性）。</p>
<ul>
<li><p><strong>核心类与接口：</strong></p>
<ul>
<li>Class 类：代表类的字节码文件，是反射的入口。</li>
<li>Constructor 类：代表类的构造器。</li>
<li>Method 类：代表类的方法。</li>
<li>Field 类：代表类的成员变量（属性）。</li>
<li>AccessibleObject：Field, Method, Constructor 的共同父类，提供了 setAccessible(true) 方法，用于抑制 Java 语言访问检查，从而访问私有成员。</li>
</ul>
</li>
<li><p><strong>获取 Class 对象的三种方式：</strong></p>
<ol>
<li>Class.forName(“全限定类名”)：最常用，动态加载类。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>类名.class：已知具体类名时使用，编译时加载。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = String.class;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>对象.getClass()：通过对象实例获取，运行时获取。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Class&lt;?&gt; clazz = s.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反射的应用：</strong></p>
<ul>
<li>动态创建对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance(); <span class="comment">// 调用无参构造器</span></span><br><span class="line"><span class="comment">// 或者调用指定构造器</span></span><br><span class="line">Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person2</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure></li>
<li>动态调用方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">setNameMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">setNameMethod.invoke(person, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// 调用 setName 方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getNameMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) getNameMethod.invoke(person); <span class="comment">// 调用 getName 方法</span></span><br></pre></td></tr></table></figure></li>
<li>动态操作属性：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance();</span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">// 获取私有属性</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>); <span class="comment">// 允许访问私有属性</span></span><br><span class="line">nameField.set(person, <span class="string">&quot;Charlie&quot;</span>); <span class="comment">// 设置属性值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) nameField.get(person); <span class="comment">// 获取属性值</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>反射的优缺点：</strong></p>
<ul>
<li>优点：<ul>
<li>灵活性和动态性:在运行时动态获取类信息和操作对象,大大增强了程序的灵活性,是许多框架(如Spring、ORM框架)和工具(如JSON解析库)的基础。</li>
<li>解耦:允许代码在编译时不知道具体的类,只在运行时加载和使用,实现高度解耦。</li>
</ul>
</li>
<li>缺点:<ul>
<li>性能开销:反射操作比直接调用有更高的性能开销,因为涉及到动态解析和查找。</li>
<li>安全性问题:setAccessible(true)可以绕过Java的访问控制,可能破坏封装性。</li>
<li>可维护性差:反射代码通常比直接调用更复杂,更难调试和维护。</li>
<li>编译时检查缺失:反射操作在编译时无法检查类型错误,只能在运行时发现。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="JVM内存结构与垃圾收集器"><a href="#JVM内存结构与垃圾收集器" class="headerlink" title="JVM内存结构与垃圾收集器"></a>JVM内存结构与垃圾收集器</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>JVM(Java Virtual Machine)在执行Java程序时,会将内存划分为几个不同的区域,这些区域有各自的用途和生命周期。</p>
<ul>
<li><p><strong>程序计数器 (Program Counter Register)</strong></p>
<ul>
<li>功能:一块较小的内存空间,用于存储当前线程所执行的字节码的行号指示器。</li>
<li>特点:<ul>
<li>每个线程私有,生命周期与线程一致。</li>
<li>JVM规范中唯一没有规定任何OutOfMemoryError情况的区域。</li>
<li>在多线程切换时,程序计数器记录了当前线程的执行位置,使得线程切换回来后能够知道从哪里继续执行。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Java虚拟机栈 (Java Virtual Machine Stacks)</strong></p>
<ul>
<li>功能:每个线程私有的内存区域,用于存储栈帧(Stack Frame)。每个方法被执行时都会创建一个栈帧,用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>
<li>特点:<ul>
<li>生命周期与线程一致。</li>
<li>局部变量表:存储方法参数和方法内部定义的局部变量。</li>
<li>操作数栈:用于存放方法执行时的操作数和中间结果。</li>
<li>动态链接:指向运行时常量池中该栈帧所属方法的引用。</li>
<li>方法出口:记录方法执行完后回到哪里。</li>
<li>可能抛出StackOverflowError(栈深度超过虚拟机允许的深度)或OutOfMemoryError(栈扩展时无法申请到足够的内存)。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>本地方法栈 (Native Method Stacks)</strong></p>
<ul>
<li>功能:与虚拟机栈类似,但是为JVM执行Native方法(即用C&#x2F;C++等语言实现的方法)服务。</li>
<li>特点：<ul>
<li>每个线程私有。</li>
<li>可能抛出 StackOverflowError 或 OutOfMemoryError。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Java 堆 (Java Heap)</strong></p>
<ul>
<li>功能:JVM 管理的最大一块内存区域，被所有线程共享，用于存放对象实例和数组。</li>
<li>特点：<ul>
<li><p>是垃圾收集器管理的主要区域 (GC 堆)。</p>
</li>
<li><p>是 Java 应用程序对象存放的“老家”。</p>
</li>
<li><p>根据垃圾回收的特性，可以分为新生代 (Young Generation) 和老年代 (Old Generation)。</p>
</li>
<li><p>新生代:通常分为 Eden 空间和两个 Survivor 空间 (From 和 To)。新创建的对象优先在 Eden 区分配，经过 Minor GC 后存活的对象进入 Survivor 区，多次 GC 后仍存活的对象进入老年代。</p>
</li>
<li><p>老年代:存放生命周期较长的对象。</p>
</li>
<li><p>在 JVM 内存模型中，新生代被划分为三个区域，默认的比例通常是 <strong>8:1:1</strong>。</p>
<ul>
<li><strong>Eden 区</strong>：占比 <strong>80%</strong>。这是新创建对象的主要分配区域。</li>
<li><strong>Survivor S0 区</strong>：占比 <strong>10%</strong>。</li>
<li><strong>Survivor S1 区</strong>：占比 <strong>10%</strong>。</li>
</ul>
<hr>
<h3 id="为什么要这样划分？"><a href="#为什么要这样划分？" class="headerlink" title="为什么要这样划分？"></a><strong>为什么要这样划分？</strong></h3><p>这种划分是为了配合 Minor GC 的垃圾回收流程，从而提高垃圾回收的效率。</p>
<h4 id="新生代的垃圾回收流程"><a href="#新生代的垃圾回收流程" class="headerlink" title="新生代的垃圾回收流程"></a><strong>新生代的垃圾回收流程</strong></h4><ol>
<li><strong>对象创建</strong>：新创建的对象首先在 <strong>Eden 区</strong> 分配。</li>
<li><strong>Minor GC</strong>：当 <strong>Eden 区</strong> 满了之后，会触发一次 Minor GC（也叫 Young GC）。</li>
<li><strong>存活对象转移</strong>：<ul>
<li>在 Eden 区和其中一个 Survivor 区（比如 S0）中，所有存活的对象会被复制到另一个空的 Survivor 区（比如 S1）。</li>
<li>同时，对象的年龄（age）会加一。</li>
</ul>
</li>
<li><strong>清空 Eden 和 S0</strong>：垃圾回收后，Eden 区和 S0 区都会被清空。</li>
<li><strong>角色互换</strong>：下一次 Minor GC 时，Eden 区和 S1 区中存活的对象会被复制到 S0 区。S0 和 S1 两个 Survivor 区会不断地进行角色互换。</li>
<li><strong>晋升老年代</strong>：<ul>
<li>当对象的年龄达到一个设定的阈值（默认为 15），或者 Survivor 区中同一年龄段的对象大小超过了一定比例，这些对象就会被移动到<strong>老年代</strong>。</li>
<li>这种设计也被称为<strong>复制算法（Copying Algorithm）</strong>，它在新生代存活对象较少的情况下，效率非常高。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="为什么是-8-1-1？"><a href="#为什么是-8-1-1？" class="headerlink" title="为什么是 8:1:1？"></a><strong>为什么是 8:1:1？</strong></h3><p>这个比例是一个经验值，基于大多数 Java 应用的特点：</p>
<ul>
<li><strong>大多数对象都是朝生夕灭的</strong>。因此，将 Eden 区设置得更大，可以容纳更多的新对象，减少 Minor GC 的频率。</li>
<li>两个 Survivor 区只需要用来暂存存活的对象，因此不需要太大。10% 的空间通常足以容纳一次 Minor GC 后存活的对象。</li>
</ul>
<p>当然，这个比例不是固定的。在某些特殊情况下，如果新生代存活对象较多，导致 Survivor 区无法容纳所有存活对象，JVM 会发生<strong>空间分配担保</strong>，将这些对象直接晋升到老年代。</p>
<p>你可以通过 JVM 参数来调整这个比例，例如： <code>java -Xmn100m -XX:SurvivorRatio=8</code></p>
<p>这个命令设置新生代总大小为 100MB，Eden 区和 Survivor 区的比例为 8:1:1。</p>
</li>
<li><p>可能抛出 OutOfMemoryError。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>方法区 (Method Area)</strong></p>
<ul>
<li>功能:被所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
<li>特点：<ul>
<li>在 JDK 1.7 及之前，方法区被称为“永久代 (Permanent Generation)”，它属于堆内存的一部分。</li>
<li>在 JDK 1.8 及之后，永久代被移除，方法区的实现改为“元空间 (Metaspace)”，并且元空间不使用 JVM 内存，而是直接使用本地内存 (Native Memory)。</li>
<li>可能抛出 OutOfMemoryError。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>运行时常量池 (Runtime Constant Pool)</strong></p>
<ul>
<li>功能:方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</li>
<li>特点：<ul>
<li>动态性:Java 语言并不要求常量池在编译期就全部确定，运行时也可以将新的常量放入池中 (如 String.intern())。</li>
<li>可能抛出 OutOfMemoryError。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="JVM-调优参数"><a href="#JVM-调优参数" class="headerlink" title="JVM 调优参数"></a>JVM 调优参数</h3><ul>
<li><p><strong>堆内存大小设置:</strong></p>
<ul>
<li>-Xms<size>:设置 JVM 堆的初始内存大小。</li>
<li>-Xmx<size>:设置 JVM 堆的最大内存大小。</li>
<li>最佳实践:通常建议 -Xms 和 -Xmx 设置为相同值，以避免 JVM 在运行时动态调整堆大小带来的额外开销和 GC 停顿。例如 -Xms4g -Xmx4g。</li>
</ul>
</li>
<li><p><strong>新生代大小设置:</strong></p>
<ul>
<li>-Xmn<size>:设置新生代内存大小。</li>
<li>-XX:NewRatio&#x3D;<ratio>:设置老年代与新生代的比例，例如 -XX:NewRatio&#x3D;2 表示老年代:新生代 &#x3D; 2:1。</li>
<li>考量:<ul>
<li>新生代过小:频繁 Minor GC, 导致对象过早进入老年代。</li>
<li>新生代过大:Minor GC 间隔长, 但每次 GC 耗时可能长。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>元空间大小设置 (JDK 1.8+):</strong></p>
<ul>
<li>-XX:MetaspaceSize&#x3D;<size>:设置元空间的初始大小。</li>
<li>-XX:MaxMetaspaceSize&#x3D;<size>:设置元空间的最大大小。</li>
<li>考量:如果应用加载大量类或使用动态代码生成, 可能需要调大。</li>
</ul>
</li>
<li><p><strong>选择垃圾收集器:</strong></p>
<ul>
<li>-XX:+UseG1GC:启用 G1 垃圾收集器。这是 JDK 9+ 的默认收集器。</li>
<li>-XX:MaxGCPauseMillis&#x3D;<ms>:设置 G1 收集器可接受的最大停顿时间(G1 会尽量接近这个目标, 但不保证完全达到)。例如 -XX:MaxGCPauseMillis&#x3D;200。</li>
</ul>
</li>
</ul>
<h3 id="垃圾收集器-Garbage-Collector"><a href="#垃圾收集器-Garbage-Collector" class="headerlink" title="垃圾收集器 (Garbage Collector)"></a>垃圾收集器 (Garbage Collector)</h3><p>垃圾收集器是 JVM 的一个重要组成部分, 负责自动管理 Java 堆内存中的对象的生命周期, 回收不再使用的对象所占用的内存。</p>
<h4 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法:"></a><strong>垃圾判断算法:</strong></h4><ul>
<li>引用计数算法:当一个对象被引用一次, 计数器加1;引用失效, 计数器减1。当计数器为0时, 对象被判定为可回收。<ul>
<li>缺点:难以解决对象之间的循环引用问题。Java 虚拟机不采用此算法。</li>
</ul>
</li>
<li>可达性分析算法 (Root Tracing):通过一系列称为 “GC Roots” 的对象作为起始点, 从这些节点向下搜索, 搜索所走过的路径称为引用链 (Reference Chain)。当一个对象到 GC Roots 没有任何引用链相连时, 则证明此对象是不可用的。<ul>
<li>可作为 GC Roots 的对象:<ul>
<li>虚拟机栈 (栈帧中的局部变量表) 中引用的对象。</li>
<li>本地方法栈 (Native 方法) 中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>被同步锁持有的对象。</li>
<li>JVM 内部的引用 (如基本数据类型对应的 Class 对象)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器:"></a><strong>常见垃圾收集器:</strong></h4><ul>
<li><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器:"></a>Serial 收集器:</h5><ul>
<li>特点:单线程, 工作时需要停止所有用户线程 (“Stop The World”, STW)。简单高效, 适用于单核 CPU 或内存较小的客户端应用。</li>
<li>新生代使用:复制算法。</li>
<li>老年代使用:标记-整理算法。</li>
</ul>
</li>
<li><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器:"></a>ParNew 收集器:</h5><ul>
<li>特点:Serial 收集器的多线程版本, 用于新生代。并行收集时也需要 STW。</li>
<li>新生代使用:复制算法。</li>
<li>常与 CMS 收集器配合使用。</li>
</ul>
</li>
<li><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器:"></a>Parallel Scavenge 收集器:</h5><ul>
<li>特点：关注吞吐量（Throughput &#x3D; 用户代码执行时间 &#x2F; (用户代码执行时间 + GC 时间)），可以设置最大吞吐量或最大 GC 停顿时间。</li>
<li>新生代使用：复制算法。</li>
<li>老年代使用：与 Parallel Old 配合使用，使用标记-整理算法。</li>
</ul>
</li>
<li><h5 id="CMS-Concurrent-Mark-Sweep-收集器："><a href="#CMS-Concurrent-Mark-Sweep-收集器：" class="headerlink" title="CMS (Concurrent Mark Sweep) 收集器："></a>CMS (Concurrent Mark Sweep) 收集器：</h5><ul>
<li>特点：以获取最短回收停顿时间为目标，并发收集（与用户线程一起执行）。适用于对响应时间要求高的应用（如 Web 服务器）。</li>
<li>工作步骤：<ol>
<li>初始标记 (Initial Mark)：STW，标记 GC Roots 能直接关联到的对象，速度快。</li>
<li>并发标记 (Concurrent Mark)：与用户线程并发执行，进行 GC Roots Tracing 过程，耗时最长。</li>
<li>重新标记 (Remark)：STW，修正并发标记期间因用户程序继续运行而导致标记产生变动的对象，比初始标记耗时长，但远比并发标记短。</li>
<li>并发清除 (Concurrent Sweep)：与用户线程并发执行，清除已标记为垃圾的对象。</li>
</ol>
</li>
<li>缺点：<ul>
<li>对 CPU 资源敏感：并发阶段会占用一部分 CPU。</li>
<li>无法处理浮动垃圾：并发清除阶段产生的垃圾（新生成的对象）只能下次 GC 再处理。</li>
<li>可能产生大量空间碎片：采用“标记-清除”算法，不进行整理，可能导致大对象无法分配空间而提前触发 Full GC。</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="G1-Garbage-First-收集器："><a href="#G1-Garbage-First-收集器：" class="headerlink" title="G1 (Garbage-First) 收集器："></a>G1 (Garbage-First) 收集器：</h5><ul>
<li>特点：JDK 9+ 的默认垃圾收集器。面向服务端应用，分区（将 Java 堆划分为多个独立区域 Region)，可预测的停顿时间模型。</li>
<li>工作原理：<ul>
<li>将堆内存划分为多个大小相等的 Region。</li>
<li>G1 跟踪每个 Region 的垃圾回收价值 (Garbage-First)，优先回收垃圾最多的 Region。</li>
<li>年轻化和老年代不再是物理隔离，而是逻辑上的概念，Region 可以动态地成为 Eden、Survivor 或 Old 区域。</li>
<li>并发与并行兼容：并发标记，但回收阶段并行。</li>
<li>基本无碎片：采用复制和标记-整理算法结合。</li>
</ul>
</li>
<li>工作步骤：<ol>
<li>初始标记 (Initial Mark)：STW，标记 GC Roots 能直接关联的对象。</li>
<li>并发标记 (Concurrent Mark)：与用户线程并发，遍历对象图。</li>
<li>最终标记 (Final Mark)：STW，处理并发标记阶段结束后仍然存活的对象。</li>
<li>筛选回收 (Evacuation)：STW，对各个 Region 的回收价值进行排序，根据预期停顿时间来回收 Region，采用复制算法将存活对象复制到新的 Region。</li>
</ol>
</li>
<li>优势：在保持高吞吐量的同时，降低了 GC 停顿时间，适合大内存、多核处理器场景。</li>
</ul>
</li>
<li><h5 id="zGC-Z-Garbage-Collector-和-Shenandoah-收集器："><a href="#zGC-Z-Garbage-Collector-和-Shenandoah-收集器：" class="headerlink" title="zGC (Z Garbage Collector) 和 Shenandoah 收集器："></a>zGC (Z Garbage Collector) 和 Shenandoah 收集器：</h5><ul>
<li>特点：低延迟、并发 GC 收集器，旨在实现毫秒级的 GC 停顿。</li>
<li>ZGC: JDK 11 引入，支持 TB 级别的堆内存，停顿时间与堆大小无关。</li>
<li>Shenandoah: JDK 12 引入，与 G1 类似，但能进一步降低停顿时间。</li>
<li>应用场景：对延迟要求极高的应用</li>
</ul>
</li>
</ul>
<h2 id="类加载机制-Class-Loading-Mechanism"><a href="#类加载机制-Class-Loading-Mechanism" class="headerlink" title="类加载机制 (Class Loading Mechanism)"></a>类加载机制 (Class Loading Mechanism)</h2><ul>
<li><p><strong>作用</strong>: 将 .class 文件中的字节码加载到 JVM 内存中，并转换为运行时数据结构。  </p>
</li>
<li><p><strong>生命周期</strong>: 加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载。  </p>
</li>
<li><p><strong>主要阶段</strong>:  </p>
<ul>
<li><strong>加载 (Loading)</strong>:  <ul>
<li>通过类的全限定名获取该类的二进制字节流。  </li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  </li>
<li>在内存中生成一个代表该类的 java.lang.Class 对象。</li>
</ul>
</li>
<li><strong>验证 (Verification)</strong>: 确保 Class 文件的字节流符合 JVM 规范，没有安全问题。  </li>
<li><strong>准备 (Preparation)</strong>: 为类的静态变量（static fields）分配内存并初始化为默认值（如 int 变量为 0，引用类型为 null）。  </li>
<li><strong>解析 (Resolution)</strong>: 将常量池中的符号引用替换为直接引用。  </li>
<li><strong>初始化 (Initialization)</strong>: 执行类的构造器 <code>&lt;clinit&gt;()</code> 方法，真正开始执行类中定义的 Java 程序代码（为静态变量赋予初始值，执行静态代码块）。</li>
</ul>
</li>
<li><p><strong>类加载器 (Class Loaders)</strong>:  </p>
<ul>
<li><p>类加载器的分类：</p>
<p>（1）Bootstrap class loader （使用C++编写的）</p>
<p>​    简称：启动类加载器</p>
<p>​    <strong>加载路径</strong>：JAVA_HOME&#x2F;jre&#x2F;lib</p>
<p>​    显示形式：null</p>
<p>（2）Platform class loader（由Java编写的）</p>
<p>​    简称：扩展类加载器</p>
<p>​    <strong>加载路径</strong>：JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</p>
<p>​    显示形式：ExtClassLoader</p>
<p>（3）System class loader（由Java编写的）</p>
<p>​    简称：应用程序类加载器</p>
<p>​    <strong>加载路径</strong>：类路径（src目录）</p>
<p>​    显示形式：AppClassLoader   &#x2F;&#x2F;sun.misc.Launcher$AppClassLoader@18b4aac2</p>
<p>（4）自定义类加载器（由Java编写的）</p>
<p>​    简称：自定义类加载器</p>
<p>​    加载路径：自定义</p>
<h4 id="1-启动类加载器-Bootstrap-ClassLoader"><a href="#1-启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="1. 启动类加载器 (Bootstrap ClassLoader)"></a><strong>1. 启动类加载器 (Bootstrap ClassLoader)</strong></h4><ul>
<li><strong>作用</strong>：它负责加载 Java 核心库，比如 <code>rt.jar</code>（包含 <code>java.lang.*</code>, <code>java.util.*</code> 等核心类）。</li>
<li><strong>实现</strong>：它不是用 Java 写的，而是由 C++ 实现的，是 JVM 自身的一部分。因此，你无法在 Java 代码中直接获取到它的对象，调用 <code>getClassLoader()</code> 得到的会是 <code>null</code>。</li>
<li><strong>父加载器</strong>：它没有父加载器。它是类加载器层次结构的顶端。</li>
</ul>
<h4 id="2-扩展类加载器-Extension-ClassLoader"><a href="#2-扩展类加载器-Extension-ClassLoader" class="headerlink" title="2. 扩展类加载器 (Extension ClassLoader)"></a><strong>2. 扩展类加载器 (Extension ClassLoader)</strong></h4><ul>
<li><strong>作用</strong>：它负责加载 JVM 扩展目录中的所有 jar 包，通常是 <code>JRE/lib/ext</code> 目录下的库。</li>
<li><strong>实现</strong>：它是由 Java 语言实现的。</li>
<li><strong>父加载器</strong>：它的父加载器是<strong>启动类加载器</strong>。</li>
</ul>
<h4 id="3-应用程序类加载器-Application-ClassLoader"><a href="#3-应用程序类加载器-Application-ClassLoader" class="headerlink" title="3. 应用程序类加载器 (Application ClassLoader)"></a><strong>3. 应用程序类加载器 (Application ClassLoader)</strong></h4><ul>
<li><strong>作用</strong>：它负责加载我们自己编写的 Java 程序中的类，也就是你项目中 <code>classpath</code> 路径下的所有类。</li>
<li><strong>实现</strong>：它也是由 Java 语言实现的。</li>
<li><strong>父加载器</strong>：它的父加载器是<strong>扩展类加载器</strong>。</li>
</ul>
<hr>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h3><p>除了上面三个，你也可以根据自己的需求创建<strong>自定义类加载器</strong>。</p>
<ul>
<li><strong>作用</strong>：当你需要加载一些特定来源的类时（比如从网络下载的类、对字节码进行加密或解密），自定义类加载器就很有用。例如，Web 服务器（如 Tomcat）就是通过自定义类加载器来隔离不同 Web 应用的类。</li>
<li><strong>如何实现</strong>：通常，你需要继承 <code>java.lang.ClassLoader</code> 类，并重写 <code>findClass()</code> 方法。在 <code>findClass()</code> 方法中，你需要自己定义如何获取类的字节码（比如从文件系统、网络或数据库），然后调用 <code>defineClass()</code> 方法将字节码转换为 <code>Class</code> 对象。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>双亲委派模型 (Parents Delegation Model)</strong>:  </p>
<ul>
<li><strong>原理</strong>: 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。  </li>
<li><strong>优点</strong>: 避免类的重复加载，保证 Java 核心库的类型安全。</li>
</ul>
</li>
</ul>
<h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><p>为什么需要四个类加载器，而不是一个？</p>
<p>这是一个很好的问题。为什么 Java 要设计多个类加载器，而不是用一个大一统的加载器呢？这背后主要有三个核心原因：<strong>隔离性</strong>、<strong>安全性</strong>和<strong>可扩展性</strong>。</p>
<hr>
<h3 id="1-隔离性（Isolation）"><a href="#1-隔离性（Isolation）" class="headerlink" title="1. 隔离性（Isolation）"></a>1. 隔离性（Isolation）</h3><p>多类加载器的最大优势就是实现了<strong>类隔离</strong>。</p>
<p>想象一下，你有一个 Web 服务器，上面部署了两个不同的 Web 应用（比如一个博客系统和一个论坛）。这两个应用可能依赖同一个第三方库的不同版本（例如，博客用的是 Spring 框架的 5.x 版本，而论坛用的是 4.x 版本）。</p>
<p>如果只有一个类加载器，它会把所有 <code>classpath</code> 上的类都加载到同一个内存空间。这样一来，两个不同版本的 Spring 框架就会产生冲突，JVM 根本无法区分它们，程序就会报错。</p>
<p>而有了自定义类加载器，服务器就可以为每个 Web 应用创建一个独立的类加载器。每个加载器负责加载自己应用目录下的类，这样两个应用即使使用了同一个库的不同版本，也能在内存中和谐共存，互不干扰。</p>
<hr>
<h3 id="2-安全性（Security）"><a href="#2-安全性（Security）" class="headerlink" title="2. 安全性（Security）"></a>2. 安全性（Security）</h3><p>Java 的核心库（如 <code>java.lang</code>, <code>java.util</code> 等）对 JVM 的稳定和安全至关重要。</p>
<p><strong>双亲委派模型</strong>正是为了保护这些核心库不被恶意代码或普通用户代码所篡改。</p>
<p>例如，如果你尝试自己写一个 <code>java.lang.String</code> 类并把它放在应用的 <code>classpath</code> 下，双亲委派机制会确保这个类不会被加载。因为当加载请求到达应用程序类加载器时，它会先委派给它的父加载器——扩展类加载器，然后再委派给最顶层的<strong>启动类加载器</strong>。启动类加载器会优先加载 JDK 自带的 <code>java.lang.String</code>，从而你的恶意代码就永远没有机会被执行。</p>
<hr>
<h3 id="3-可扩展性（Extensibility）"><a href="#3-可扩展性（Extensibility）" class="headerlink" title="3. 可扩展性（Extensibility）"></a>3. 可扩展性（Extensibility）</h3><p>Java 是一种非常灵活的语言，需要适应各种复杂的运行时环境。</p>
<p>如果只有一个类加载器，所有的类都必须来自文件系统。但在现实世界中，类可能来自各种地方：</p>
<ul>
<li>从网络上下载的字节码。</li>
<li>通过数据库存储和加载。</li>
<li>对字节码进行加密和解密。</li>
</ul>
<p>自定义类加载器让 Java 能够<strong>动态地加载</strong>和<strong>处理非标准来源的类</strong>。例如，热部署技术（在不重启应用的情况下更新代码）就是通过自定义类加载器实现的。它会创建一个新的加载器来加载新版本的类，而旧的加载器和它的类则可以被垃圾回收。</p>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>所以，一个大一统的类加载器虽然简单，但它无法解决复杂的<strong>类版本冲突</strong>、<strong>核心库安全</strong>和<strong>动态加载</strong>等问题。通过分层设计和双亲委派模型，Java 的类加载器体系变得既安全又灵活，能够满足从简单的桌面应用到复杂的企业级服务器等各种场景的需求。</p>
<h2 id="常见的-OOM-OutOfMemoryError-和-StackOverflowError"><a href="#常见的-OOM-OutOfMemoryError-和-StackOverflowError" class="headerlink" title="常见的 OOM (OutOfMemoryError) 和 StackOverflowError"></a>常见的 OOM (OutOfMemoryError) 和 StackOverflowError</h2><ul>
<li><strong>Java heap space</strong>: 堆内存不足，最常见。通常通过调整 JVM 启动参数 <code>-Xms</code> (初始堆大小) 和 <code>-Xmx</code> (最大堆大小) 来解决。  </li>
<li><strong>StackOverflowError</strong>: 虚拟机栈溢出。通常是递归调用过深导致栈帧不断入栈。  </li>
<li><strong>PermGen space &#x2F; Metaspace</strong>: 方法区溢出。通常是加载的类过多，或者存在大量字符串常量。通过 <code>-XX:MaxPermSize</code> (JDK 1.7) 或 <code>-XX:MaxMetaspaceSize</code> (JDK 1.8) 调整。  </li>
<li><strong>Direct buffer memory</strong>: 直接内存溢出。通常是使用了 NIO 或 Netty 等直接操作堆外内存的库。  </li>
<li><strong>unable to create new native thread</strong>: 无法创建新线程。通常是系统线程数达到上限或内存不足以分配新线程的栈空间。</li>
</ul>
<h2 id="OOM常见场景："><a href="#OOM常见场景：" class="headerlink" title="OOM常见场景："></a>OOM常见场景：</h2><hr>
<h3 id="1-java-lang-OutOfMemoryError-Java-heap-space"><a href="#1-java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="1. java.lang.OutOfMemoryError: Java heap space"></a><strong>1. java.lang.OutOfMemoryError: Java heap space</strong></h3><p>这是最常见、也最广为人知的内存溢出错误。它表示 <strong>Java 堆（Heap）</strong> 中没有足够的空间来分配新的对象。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong>内存泄漏（Memory Leak）</strong>：这是最主要的原因。你的程序中创建了对象，但本应被垃圾回收器（GC）回收的对象却因为某些原因（比如被一个长生命周期的对象引用着）而无法被回收。例如：<ul>
<li>一个静态的 <code>Map</code> 或 <code>List</code> 集合，不断地往里面添加对象，但从不删除。</li>
<li>监听器或回调函数没有正确移除，导致被监听的对象无法被回收。</li>
<li>数据库连接或文件流没有正确关闭，长时间占用资源。</li>
</ul>
</li>
<li><strong>内存使用不当</strong>：一次性加载大量数据到内存中。例如，从数据库查询数百万条记录，并把它们全部加载到一个 <code>List</code> 中；或者处理一个超大的图片或文件，导致瞬间占用大量内存。</li>
<li><strong>配置问题</strong>：JVM 的堆内存设置得太小，无法满足程序的正常运行需求。这在部署应用时很常见，可以通过调整 <code>-Xmx</code> 参数来解决。</li>
</ul>
<hr>
<h3 id="2-java-lang-StackOverflowError"><a href="#2-java-lang-StackOverflowError" class="headerlink" title="2. java.lang.StackOverflowError"></a><strong>2. java.lang.StackOverflowError</strong></h3><p>这个错误表示 <strong>虚拟机栈（Stack）</strong> 溢出。每个线程都有一个独立的栈，用于存储方法调用的栈帧。当栈的深度超过了 JVM 允许的最大深度时，就会抛出此错误。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><p><strong>无限递归（Infinite Recursion）</strong>：这是最典型的场景。一个方法不断地调用自身，且没有正确的退出条件。例如：</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void recursiveMethod() &#123;</span><br><span class="line">    // 没有退出条件</span><br><span class="line">    recursiveMethod(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子是两个方法互相调用，形成循环：A 调用 B，B 又调用 A。</p>
</li>
<li><p><strong>递归调用层级过深</strong>：即使递归有正确的退出条件，如果数据量过大，导致递归调用层级非常深，也可能导致栈溢出。例如，处理一个深度非常大的树形结构。</p>
</li>
</ul>
<hr>
<h3 id="3-java-lang-OutOfMemoryError-PermGen-space-或-Metaspace"><a href="#3-java-lang-OutOfMemoryError-PermGen-space-或-Metaspace" class="headerlink" title="3. java.lang.OutOfMemoryError: PermGen space 或 Metaspace"></a><strong>3. java.lang.OutOfMemoryError: PermGen space 或 Metaspace</strong></h3><p>这个错误发生在 <strong>方法区</strong> 溢出。方法区用于存储类的元数据信息，如类的结构、字段、方法、常量池等。</p>
<ul>
<li><strong>JDK 1.7 及之前</strong>：方法区在堆中，被称为<strong>永久代（PermGen）</strong>。溢出错误为 <code>PermGen space</code>。</li>
<li><strong>JDK 1.8 及之后</strong>：永久代被移除，方法区改为使用<strong>元空间（Metaspace）</strong>，并且默认使用本地内存。溢出错误为 <code>Metaspace</code>。</li>
</ul>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong>动态生成大量类</strong>：在运行时生成大量新的类。这在一些使用字节码增强技术的框架（如 CGLib）或动态代理的场景中很常见。</li>
<li><strong>热部署</strong>：在像 Tomcat 这样的 Web 服务器中进行频繁的热部署操作，如果没有正确清理旧的类加载器，会导致旧的类元数据无法被回收，从而逐渐耗尽方法区内存。</li>
<li><strong>常量池溢出</strong>：在 JDK 1.7 之前，字符串常量池也在永久代中。如果程序创建了大量不同的字符串（例如在循环中不断生成新的字符串），也可能导致永久代溢出。</li>
</ul>
<hr>
<h3 id="4-java-lang-OutOfMemoryError-Direct-buffer-memory"><a href="#4-java-lang-OutOfMemoryError-Direct-buffer-memory" class="headerlink" title="4. java.lang.OutOfMemoryError: Direct buffer memory"></a><strong>4. java.lang.OutOfMemoryError: Direct buffer memory</strong></h3><p>这个错误与 <strong>直接内存（Direct Memory）</strong> 相关，它不是 Java 堆的一部分，而是通过 <code>ByteBuffer.allocateDirect()</code> 在堆外分配的内存。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong>NIO 和网络编程</strong>：在使用 Java NIO、Netty、或者其他依赖堆外内存的库时，如果频繁地分配直接内存但没有及时释放，就可能导致此错误。</li>
<li><strong>内存泄漏</strong>：直接内存的回收不像堆内存那样由 GC 自动管理。如果程序中没有调用 <code>ByteBuffer</code> 的 <code>cleaner()</code> 方法，或者在没有关闭资源的情况下直接内存泄漏，就会耗尽系统的直接内存。</li>
</ul>
<hr>
<h3 id="5-java-lang-OutOfMemoryError-unable-to-create-new-native-thread"><a href="#5-java-lang-OutOfMemoryError-unable-to-create-new-native-thread" class="headerlink" title="5. java.lang.OutOfMemoryError: unable to create new native thread"></a><strong>5. java.lang.OutOfMemoryError: unable to create new native thread</strong></h3><p>这个错误通常不是因为 Java 堆内存不足，而是因为<strong>系统资源耗尽</strong>。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong>线程创建过多</strong>：程序中创建了大量的线程，导致系统无法为新的线程分配内存空间。每个线程除了 Java 堆中的栈空间外，还需要分配一些本地内存。</li>
<li><strong>系统限制</strong>：操作系统对单个进程创建的线程数有限制。如果达到了这个上限，JVM 就会抛出此错误。在 Linux 系统中，你可以通过 <code>ulimit -u</code> 命令查看这个限制。</li>
<li><strong>内存不足</strong>：系统内存（包括堆外内存）已经所剩无几，JVM 无法为新的线程栈分配足够的内存  r。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Charlotte</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/%E5%9F%BA%E7%A1%80%E8%83%8C%E8%AF%B5/">http://example.com/2025/09/11/%E5%9F%BA%E7%A1%80%E8%83%8C%E8%AF%B5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">浮生若梦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Hexo-Markdown/">Hexo, Markdown</a></div><div class="post-share"><div class="social-share" data-image="/img/title.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/2025/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" title="计算机基础面试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">计算机基础面试</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/" title="手写答案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">手写答案</div></div><div class="info-2"><div class="info-item-1">1.实现单例模式 (Singleton Pattern)懒汉式：使用双重检查锁定 (DCL) 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。 1234567891011121314151617181920212223242526272829class Singleton &#123;    // 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到    private static volatile Singleton instance;    // 2. 私有化构造器，防止外部直接 new 实例    private Singleton() &#123;&#125;    // 3. 提供一个全局访问点，使用 DCL 确保线程安全    public static Singleton getInstance() &#123;        // 第一次检查：如果实例已经存在，直接返回，避免不必要的同步        if (instance == null) &#12...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" title="命令大全"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">命令大全</div></div></div></a><a class="pagination-related" href="/2025/09/11/8.21%E5%AD%A6%E4%BC%9A/" title="8.21学会"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">8.21学会</div></div><div class="info-2"><div class="info-item-1">1.实现单例模式 (Singleton Pattern)懒汉式：使用双重检查锁定 (DCL) 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。 1234567891011121314151617181920212223242526272829class Singleton &#123;    // 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到    private static volatile Singleton instance;    // 2. 私有化构造器，防止外部直接 new 实例    private Singleton() &#123;&#125;    // 3. 提供一个全局访问点，使用 DCL 确保线程安全    public static Singleton getInstance() &#123;        // 第一次检查：如果实例已经存在，直接返回，避免不必要的同步        if (instance == null) &#12...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">分布式</div></div><div class="info-2"><div class="info-item-1">1. Spring Cloud 体系核心思想Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的规范和解决方案的集合。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。 Netflix OSS 常用组件（部分进入维护模式） 服务注册与发现 (Service Discovery): Eureka 作用: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。 使用: 服务端添加 spring-cloud-starter-netflix-eureka-server 依赖，并使用 @EnableEurekaServer 注解。客...</div></div></div></a><a class="pagination-related no-desc" href="/2025/09/11/%E6%A1%86%E6%9E%B6/" title="框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">框架</div></div></div></a><a class="pagination-related no-desc" href="/2025/09/11/%E7%AE%97%E6%B3%95/" title="算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">算法</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%A1%86%E6%9E%B6%E8%83%8C%E8%AF%B5/" title="框架背诵"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">框架背诵</div></div><div class="info-2"><div class="info-item-1">Java框架核心知识详解一、Spring框架深入解析1.1 Spring核心概念与原理Spring框架是一个分层的企业级应用开发框架，其核心是控制反转（IoC）和面向切面编程（AOP）。 IoC容器原理深入分析IoC（控制反转）的本质： 传统开发中，对象的创建和依赖关系由程序代码直接控制，而IoC将这个控制权交给了外部容器。Spring通过依赖注入（DI）来实现IoC。 IoC容器的实现机制：  BeanFactory: 基础容器，提供基本的IoC功能 ApplicationContext: 高级容器，继承BeanFactory，提供更多企业级功能  Bean的生命周期详解： 1实例化 → 属性赋值 → 初始化前处理 → 初始化 → 初始化后处理 → 使用 → 销毁前处理 → 销毁  详细生命周期步骤：  Bean元数据解析（XML、注解、Java配置） 调用Bean构造函数实例化 依赖注入（setter方法、构造函数、字段注入） 如果实现了BeanNameAware，调用setBeanName() 如果实现了BeanFactoryAware，调用setBeanFactory()...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/title.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Charlotte</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/charlotte030710"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">网络基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">OSI七层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82-Physical-Layer"><span class="toc-number">1.1.1.</span> <span class="toc-text">物理层 (Physical Layer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-Data-Link-Layer"><span class="toc-number">1.1.2.</span> <span class="toc-text">数据链路层 (Data Link Layer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82-Network-Layer"><span class="toc-number">1.1.3.</span> <span class="toc-text">网络层 (Network Layer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82-Transport-Layer"><span class="toc-number">1.1.4.</span> <span class="toc-text">传输层 (Transport Layer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%B1%82-Session-Layer"><span class="toc-number">1.1.5.</span> <span class="toc-text">会话层 (Session Layer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%B1%82-Presentation-Layer"><span class="toc-number">1.1.6.</span> <span class="toc-text">表示层 (Presentation Layer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82-Application-Layer"><span class="toc-number">1.1.7.</span> <span class="toc-text">应用层 (Application Layer)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP-%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="toc-number">1.2.</span> <span class="toc-text">TCP&#x2F;IP 协议族</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.</span> <span class="toc-text">MySQL 数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E6%93%8D%E4%BD%9C%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">SQL 操作与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">Lock接口的设计理念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">显式锁机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">2.1.3.</span> <span class="toc-text">AQS框架的核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.4.</span> <span class="toc-text">3. volatile 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B9%90%E8%A7%82%E9%94%81-Optimistic-Locking"><span class="toc-number">2.1.5.</span> <span class="toc-text">4. 乐观锁 (Optimistic Locking)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%AD%BB%E9%94%81-Deadlock"><span class="toc-number">2.1.6.</span> <span class="toc-text">5. 死锁 (Deadlock)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">死锁的四个必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">死锁的解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.7.</span> <span class="toc-text">银行家算法概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.8.</span> <span class="toc-text">银行家算法中的几个重要数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%9A%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">2.1.9.</span> <span class="toc-text">银行家算法的核心：安全状态的判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9A%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D"><span class="toc-number">2.1.10.</span> <span class="toc-text">银行家算法的流程：资源分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.11.</span> <span class="toc-text">银行家算法的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86"><span class="toc-number">2.1.12.</span> <span class="toc-text">实际应用中的死锁处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.2.</span> <span class="toc-text">多线程与线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">线程（Thread）的概念与生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">创建线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">继承 Thread 类:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">实现 Runnable 接口：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">实现Callable接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.3.</span> <span class="toc-text">Callable 的基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Callable"><span class="toc-number">2.2.4.</span> <span class="toc-text">如何使用 Callable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable-%E4%B8%8E-Runnable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.5.</span> <span class="toc-text">Callable 与 Runnable 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.6.</span> <span class="toc-text">Future 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.7.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-Thread-Pool"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">线程池 (Thread Pool)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">ThreadLocal：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">ThreadLocal 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-ThreadLocal%EF%BC%9F"><span class="toc-number">2.3.2.</span> <span class="toc-text">为什么需要 ThreadLocal？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal-%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.3.</span> <span class="toc-text">ThreadLocal 的常见应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal-%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.4.</span> <span class="toc-text">ThreadLocal 可能带来的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">继承问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">2.4.</span> <span class="toc-text">Collection (集合框架):</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-List-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">2.4.0.1.</span> <span class="toc-text">A. List 接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ArrayList"><span class="toc-number">2.4.0.1.1.</span> <span class="toc-text">1. ArrayList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-LinkedList"><span class="toc-number">2.4.0.1.2.</span> <span class="toc-text">2. LinkedList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Vector"><span class="toc-number">2.4.0.1.3.</span> <span class="toc-text">3. Vector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Stack"><span class="toc-number">2.4.0.1.4.</span> <span class="toc-text">4. Stack</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-List"><span class="toc-number">2.4.0.2.</span> <span class="toc-text">小结 List:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Set-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">2.4.0.3.</span> <span class="toc-text">B. Set 接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-HashSet"><span class="toc-number">2.4.0.3.1.</span> <span class="toc-text">1. HashSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-LinkedHashSet"><span class="toc-number">2.4.0.3.2.</span> <span class="toc-text">2. LinkedHashSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-TreeSet"><span class="toc-number">2.4.0.3.3.</span> <span class="toc-text">3. TreeSet</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-Set"><span class="toc-number">2.4.0.4.</span> <span class="toc-text">小结 Set:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Map-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">2.4.0.5.</span> <span class="toc-text">C. Map 接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-HashMap"><span class="toc-number">2.4.0.5.1.</span> <span class="toc-text">1. HashMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-LinkedHashMap"><span class="toc-number">2.4.0.5.2.</span> <span class="toc-text">2. LinkedHashMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-TreeMap"><span class="toc-number">2.4.0.5.3.</span> <span class="toc-text">3. TreeMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Hashtable"><span class="toc-number">2.4.0.5.4.</span> <span class="toc-text">4. Hashtable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-ConcurrentHashMap-JUC-%E5%8C%85%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88"><span class="toc-number">2.4.0.5.5.</span> <span class="toc-text">5. ConcurrentHashMap (JUC 包中的并发集合)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-Map"><span class="toc-number">2.4.0.6.</span> <span class="toc-text">小结 Map:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO-%E6%B5%81"><span class="toc-number">2.5.</span> <span class="toc-text">Java IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.5.1.</span> <span class="toc-text">IO 流的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-IO-%E6%93%8D%E4%BD%9C"><span class="toc-number">2.5.2.</span> <span class="toc-text">常用 IO 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-New-Input-Output"><span class="toc-number">2.5.3.</span> <span class="toc-text">NIO (New Input&#x2F;Output)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AIO-Asynchronous-Input-Output"><span class="toc-number">2.5.4.</span> <span class="toc-text">AIO (Asynchronous Input&#x2F;Output)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%8F%8D%E5%B0%84-Reflection"><span class="toc-number">2.6.</span> <span class="toc-text">Java 反射 (Reflection)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.</span> <span class="toc-text">JVM内存结构与垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.7.1.</span> <span class="toc-text">JVM内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E5%88%92%E5%88%86%EF%BC%9F"><span class="toc-number">2.7.2.</span> <span class="toc-text">为什么要这样划分？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">新生代的垃圾回收流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-8-1-1%EF%BC%9F"><span class="toc-number">2.7.3.</span> <span class="toc-text">为什么是 8:1:1？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="toc-number">2.7.4.</span> <span class="toc-text">JVM 调优参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-Garbage-Collector"><span class="toc-number">2.7.5.</span> <span class="toc-text">垃圾收集器 (Garbage Collector)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95"><span class="toc-number">2.7.5.1.</span> <span class="toc-text">垃圾判断算法:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.5.2.</span> <span class="toc-text">常见垃圾收集器:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.5.2.1.</span> <span class="toc-text">Serial 收集器:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.5.2.2.</span> <span class="toc-text">ParNew 收集器:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.5.2.3.</span> <span class="toc-text">Parallel Scavenge 收集器:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CMS-Concurrent-Mark-Sweep-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">2.7.5.2.4.</span> <span class="toc-text">CMS (Concurrent Mark Sweep) 收集器：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1-Garbage-First-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">2.7.5.2.5.</span> <span class="toc-text">G1 (Garbage-First) 收集器：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#zGC-Z-Garbage-Collector-%E5%92%8C-Shenandoah-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">2.7.5.2.6.</span> <span class="toc-text">zGC (Z Garbage Collector) 和 Shenandoah 收集器：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-Class-Loading-Mechanism"><span class="toc-number">2.8.</span> <span class="toc-text">类加载机制 (Class Loading Mechanism)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Bootstrap-ClassLoader"><span class="toc-number">2.8.0.1.</span> <span class="toc-text">1. 启动类加载器 (Bootstrap ClassLoader)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Extension-ClassLoader"><span class="toc-number">2.8.0.2.</span> <span class="toc-text">2. 扩展类加载器 (Extension ClassLoader)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Application-ClassLoader"><span class="toc-number">2.8.0.3.</span> <span class="toc-text">3. 应用程序类加载器 (Application ClassLoader)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.8.1.</span> <span class="toc-text">自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="toc-number">2.9.</span> <span class="toc-text">面试题：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88Isolation%EF%BC%89"><span class="toc-number">2.9.1.</span> <span class="toc-text">1. 隔离性（Isolation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%88Security%EF%BC%89"><span class="toc-number">2.9.2.</span> <span class="toc-text">2. 安全性（Security）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%EF%BC%88Extensibility%EF%BC%89"><span class="toc-number">2.9.3.</span> <span class="toc-text">3. 可扩展性（Extensibility）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.9.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-OOM-OutOfMemoryError-%E5%92%8C-StackOverflowError"><span class="toc-number">2.10.</span> <span class="toc-text">常见的 OOM (OutOfMemoryError) 和 StackOverflowError</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOM%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">2.11.</span> <span class="toc-text">OOM常见场景：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-java-lang-OutOfMemoryError-Java-heap-space"><span class="toc-number">2.11.1.</span> <span class="toc-text">1. java.lang.OutOfMemoryError: Java heap space</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-java-lang-StackOverflowError"><span class="toc-number">2.11.2.</span> <span class="toc-text">2. java.lang.StackOverflowError</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-java-lang-OutOfMemoryError-PermGen-space-%E6%88%96-Metaspace"><span class="toc-number">2.11.3.</span> <span class="toc-text">3. java.lang.OutOfMemoryError: PermGen space 或 Metaspace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-java-lang-OutOfMemoryError-Direct-buffer-memory"><span class="toc-number">2.11.4.</span> <span class="toc-text">4. java.lang.OutOfMemoryError: Direct buffer memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-java-lang-OutOfMemoryError-unable-to-create-new-native-thread"><span class="toc-number">2.11.5.</span> <span class="toc-text">5. java.lang.OutOfMemoryError: unable to create new native thread</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" title="命令大全">命令大全</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/8.21%E5%AD%A6%E4%BC%9A/" title="8.21学会">8.21学会</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式">分布式</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E6%A1%86%E6%9E%B6/" title="框架">框架</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E7%AE%97%E6%B3%95/" title="算法">算法</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bg.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Charlotte</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java知识点 | 浮生若梦</title><meta name="author" content="Charlotte"><meta name="copyright" content="Charlotte"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、网络基础概念 网络的定义 网络是多个计算机及通信设备通过通信介质互联的系统，用于信息传输、资源共享、协同工作。 核心目标：可靠、高效、可扩展的数据传输。 设计原则：分层、模块化、接口标准化。   数据传输方式 单工：单向传输（电视广播）。 半双工：双向传输，但不能同时发送（对讲机）。 全双工：双向同时传输（电话、以太网交换机端口）。   通信方式 点对点：两个节点直接通信（PPP）。 广播：单">
<meta property="og:type" content="article">
<meta property="og:title" content="java知识点">
<meta property="og:url" content="http://example.com/2025/09/11/java%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="浮生若梦">
<meta property="og:description" content="一、网络基础概念 网络的定义 网络是多个计算机及通信设备通过通信介质互联的系统，用于信息传输、资源共享、协同工作。 核心目标：可靠、高效、可扩展的数据传输。 设计原则：分层、模块化、接口标准化。   数据传输方式 单工：单向传输（电视广播）。 半双工：双向传输，但不能同时发送（对讲机）。 全双工：双向同时传输（电话、以太网交换机端口）。   通信方式 点对点：两个节点直接通信（PPP）。 广播：单">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/title.jpg">
<meta property="article:published_time" content="2025-09-11T10:29:00.000Z">
<meta property="article:modified_time" content="2025-09-12T07:48:44.278Z">
<meta property="article:author" content="Charlotte">
<meta property="article:tag" content="Hexo, Markdown">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/title.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "java知识点",
  "url": "http://example.com/2025/09/11/java%E7%9F%A5%E8%AF%86%E7%82%B9/",
  "image": "http://example.com/img/title.jpg",
  "datePublished": "2025-09-11T10:29:00.000Z",
  "dateModified": "2025-09-12T07:48:44.278Z",
  "author": [
    {
      "@type": "Person",
      "name": "Charlotte",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="http://example.com/2025/09/11/java%E7%9F%A5%E8%AF%86%E7%82%B9/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java知识点',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="浮生若梦" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/title.jpg" alt="Logo"><span class="site-name">浮生若梦</span></a><a class="nav-page-title" href="/"><span class="site-name">java知识点</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">java知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T10:29:00.000Z" title="发表于 2025-09-11 18:29:00">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-12T07:48:44.278Z" title="更新于 2025-09-12 15:48:44">2025-09-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一、网络基础概念"><a href="#一、网络基础概念" class="headerlink" title="一、网络基础概念"></a>一、网络基础概念</h1><ol>
<li><strong>网络的定义</strong><br> 网络是多个计算机及通信设备通过通信介质互联的系统，用于信息传输、资源共享、协同工作。<ul>
<li>核心目标：可靠、高效、可扩展的数据传输。</li>
<li>设计原则：分层、模块化、接口标准化。</li>
</ul>
</li>
<li><strong>数据传输方式</strong><ul>
<li><strong>单工</strong>：单向传输（电视广播）。</li>
<li><strong>半双工</strong>：双向传输，但不能同时发送（对讲机）。</li>
<li><strong>全双工</strong>：双向同时传输（电话、以太网交换机端口）。</li>
</ul>
</li>
<li><strong>通信方式</strong><ul>
<li><strong>点对点</strong>：两个节点直接通信（PPP）。</li>
<li><strong>广播</strong>：单点发送，多点接收（Ethernet）。</li>
<li><strong>组播</strong>：单点发送，特定组接收（IP 多播）。</li>
</ul>
</li>
<li><strong>网络分类</strong><ul>
<li><strong>按地理范围</strong>：LAN、MAN、WAN。</li>
<li><strong>按拓扑结构</strong>：星型、总线型、环型、混合型。</li>
<li><strong>按访问控制方式</strong>：CSMA&#x2F;CD（Ethernet）、令牌环（Token Ring）。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="二、OSI-七层模型"><a href="#二、OSI-七层模型" class="headerlink" title="二、OSI 七层模型"></a>二、OSI 七层模型</h1><p>OSI 模型将网络通信划分为七层，每层负责特定功能，确保模块化与互操作性。</p>
<table>
<thead>
<tr>
<th>层</th>
<th>功能</th>
<th>数据单位</th>
<th>典型协议&#x2F;设备</th>
<th>面试易问点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>物理层</strong></td>
<td>比特流传输，电气&#x2F;光学&#x2F;机械接口</td>
<td>比特 Bit</td>
<td>网线、光纤、集线器、网卡物理部分、调制解调器</td>
<td>电压、传输速率、双工模式、光纤与铜缆区别</td>
</tr>
<tr>
<td><strong>数据链路层</strong></td>
<td>节点间帧传输，差错控制、流量控制、MAC 地址</td>
<td>帧 Frame</td>
<td>以太网、PPP、交换机、网桥</td>
<td>CSMA&#x2F;CD 工作原理、MAC 地址格式、VLAN</td>
</tr>
<tr>
<td><strong>网络层</strong></td>
<td>主机到主机传输，逻辑寻址、路由、拥塞控制</td>
<td>数据包 Packet</td>
<td>IP、ICMP、IGMP、路由器</td>
<td>路由选择算法（RIP&#x2F;OSPF&#x2F;BGP）、子网掩码计算、NAT</td>
</tr>
<tr>
<td><strong>传输层</strong></td>
<td>端到端通信，端口映射、分段重组、流量控制</td>
<td>报文段 Segment (TCP)、数据报 Datagram (UDP)</td>
<td>TCP、UDP</td>
<td>TCP 三次握手、四次挥手、滑动窗口、端口号分类</td>
</tr>
<tr>
<td><strong>会话层</strong></td>
<td>管理应用会话，数据同步</td>
<td>会话数据</td>
<td>NetBIOS、RPC、NFS、SQL</td>
<td>断点续传、会话保持机制</td>
</tr>
<tr>
<td><strong>表示层</strong></td>
<td>数据表示、编码、加密压缩</td>
<td>表示数据</td>
<td>JPEG、MPEG、ASCII、Unicode、TLS&#x2F;SSL</td>
<td>大端&#x2F;小端、编码转换、加密&#x2F;解密流程</td>
</tr>
<tr>
<td><strong>应用层</strong></td>
<td>提供用户服务，直接与应用交互</td>
<td>应用数据</td>
<td>HTTP、FTP、SMTP、POP3&#x2F;IMAP、DNS、Telnet、SNMP</td>
<td>HTTP 请求&#x2F;响应报文结构、DNS 查询流程、FTP 主动&#x2F;被动模式</td>
</tr>
</tbody></table>
<h3 id="1-物理层深度"><a href="#1-物理层深度" class="headerlink" title="1. 物理层深度"></a>1. 物理层深度</h3><ul>
<li><strong>电气特性</strong>：电压幅值、频率、信号调制。</li>
<li><strong>传输介质差异</strong>：<ul>
<li>铜缆（双绞线、同轴）: 成本低、易干扰。</li>
<li>光纤: 高速、长距离、抗电磁干扰。</li>
</ul>
</li>
<li><strong>面试常问</strong>：光纤单模和多模区别、网卡速率、半双工&#x2F;全双工。</li>
</ul>
<h3 id="2-数据链路层深度"><a href="#2-数据链路层深度" class="headerlink" title="2. 数据链路层深度"></a>2. 数据链路层深度</h3><ul>
<li><strong>MAC 地址</strong>：唯一标识网卡，48 位（前 24 位厂商号，后 24 位设备号）。</li>
<li><strong>流量控制</strong>：<ul>
<li>停止等待（Stop-and-Wait）</li>
<li>滑动窗口（Sliding Window）</li>
</ul>
</li>
<li><strong>差错控制</strong>：CRC 校验、帧校验序列 (FCS)。</li>
<li><strong>VLAN</strong>：逻辑分隔网络，减少广播风暴。</li>
</ul>
<h3 id="3-网络层深度"><a href="#3-网络层深度" class="headerlink" title="3. 网络层深度"></a>3. 网络层深度</h3><ul>
<li><strong>逻辑寻址</strong>：IPv4&#x2F;IPv6</li>
<li><strong>子网划分</strong>：CIDR、VLSM。</li>
<li><strong>路由协议</strong>：<ul>
<li><strong>RIP</strong>：跳数最短，收敛慢。</li>
<li><strong>OSPF</strong>：链路状态，快速收敛。</li>
<li><strong>BGP</strong>：自治系统间，策略路由。</li>
</ul>
</li>
<li><strong>NAT</strong>：私网 IP 转换为公网 IP，节约 IP。</li>
</ul>
<h3 id="4-传输层深度"><a href="#4-传输层深度" class="headerlink" title="4. 传输层深度"></a>4. 传输层深度</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul>
<li><strong>可靠性机制</strong>：<ul>
<li>序列号与确认号。</li>
<li>滑动窗口。</li>
<li>重传机制（超时&#x2F;快速重传）。</li>
</ul>
</li>
<li><strong>三次握手（建立连接）</strong><ul>
<li><strong>第一次 (SYN)</strong>：客户端请求，seq&#x3D;client_ISN。</li>
<li><strong>第二次 (SYN-ACK)</strong>：服务器确认客户端，seq&#x3D;server_ISN, ack&#x3D;client_ISN+1。</li>
<li><strong>第三次 (ACK)</strong>：客户端确认服务器，ack&#x3D;server_ISN+1。</li>
</ul>
</li>
<li><strong>四次挥手（断开连接）</strong><ul>
<li>FIN&#x2F;ACK 交替关闭双向。</li>
<li>TIME_WAIT: 2MSL，保证最后 ACK 到达并避免旧报文干扰。</li>
</ul>
</li>
<li><strong>流量控制</strong>：滑动窗口</li>
<li><strong>拥塞控制</strong>：慢启动、拥塞避免、快速重传、快速恢复。</li>
</ul>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul>
<li><strong>特点</strong>：无连接、无序、不保证到达。</li>
<li><strong>应用</strong>：DNS、VoIP、视频直播。</li>
<li><strong>优点</strong>：低延迟、开销小。</li>
</ul>
<h3 id="5-会话层深度"><a href="#5-会话层深度" class="headerlink" title="5. 会话层深度"></a>5. 会话层深度</h3><ul>
<li><strong>会话管理</strong>：<ul>
<li>会话建立、保持、终止。</li>
<li>数据同步点（断点续传）。</li>
</ul>
</li>
<li><strong>面试点</strong>：HTTP 是无状态协议，如何实现会话保持？（Cookie&#x2F;Session&#x2F;Token）</li>
</ul>
<h3 id="6-表示层深度"><a href="#6-表示层深度" class="headerlink" title="6. 表示层深度"></a>6. 表示层深度</h3><ul>
<li><strong>数据格式化</strong>：ASCII、Unicode、EBCDIC。</li>
<li><strong>压缩&#x2F;解压</strong>：JPEG、MPEG、ZIP。</li>
<li><strong>加密&#x2F;解密</strong>：TLS&#x2F;SSL，实现安全通信。</li>
<li><strong>面试点</strong>：大端小端，Base64 编码。</li>
</ul>
<h3 id="7-应用层深度"><a href="#7-应用层深度" class="headerlink" title="7. 应用层深度"></a>7. 应用层深度</h3><ul>
<li><strong>HTTP</strong>：<ul>
<li>请求方法：GET&#x2F;POST&#x2F;PUT&#x2F;DELETE&#x2F;OPTIONS。</li>
<li>状态码：1xx-5xx。</li>
</ul>
</li>
<li><strong>DNS</strong>：<ul>
<li>查询类型：A&#x2F;AAAA&#x2F;CNAME&#x2F;MX。</li>
<li>递归&#x2F;迭代查询。</li>
</ul>
</li>
<li><strong>SMTP&#x2F;POP3&#x2F;IMAP</strong>：<ul>
<li>发送与接收流程。</li>
</ul>
</li>
<li><strong>面试点</strong>：<ul>
<li>FTP 主动&#x2F;被动模式差异。</li>
<li>HTTPS 握手流程（证书交换 + 对称密钥）。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三、TCP-IP-协议族（详细版）"><a href="#三、TCP-IP-协议族（详细版）" class="headerlink" title="三、TCP&#x2F;IP 协议族（详细版）"></a>三、TCP&#x2F;IP 协议族（详细版）</h1><table>
<thead>
<tr>
<th>层</th>
<th>功能</th>
<th>协议</th>
<th>特点</th>
<th>面试易问点</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>用户应用服务</td>
<td>HTTP、DNS、FTP、SMTP</td>
<td>与用户交互</td>
<td>HTTP 状态码、DNS 查询过程</td>
</tr>
<tr>
<td>传输层</td>
<td>端到端通信</td>
<td>TCP、UDP</td>
<td>TCP 可靠、UDP 高效</td>
<td>三次握手、四次挥手、流量控制</td>
</tr>
<tr>
<td>网络层</td>
<td>主机到主机</td>
<td>IP、ICMP、ARP</td>
<td>IP 无连接、路由选择</td>
<td>子网划分、NAT、ICMP 报文</td>
</tr>
<tr>
<td>网络接口层</td>
<td>物理链路传输</td>
<td>Ethernet、PPP</td>
<td>比特传输</td>
<td>MAC 地址、冲突检测</td>
</tr>
</tbody></table>
<hr>
<h3 id="TCP-三次握手总结"><a href="#TCP-三次握手总结" class="headerlink" title="TCP 三次握手总结"></a>TCP 三次握手总结</h3><ol>
<li>客户端发送 SYN，告知初始序列号。</li>
<li>服务器返回 SYN-ACK，确认收到 SYN 并告知自身序列号。</li>
<li>客户端 ACK 确认，双方 ESTABLISHED。</li>
</ol>
<h3 id="TCP-四次挥手总结"><a href="#TCP-四次挥手总结" class="headerlink" title="TCP 四次挥手总结"></a>TCP 四次挥手总结</h3><ol>
<li>主动方 FIN，关闭发送。</li>
<li>被动方 ACK，确认。</li>
<li>被动方 FIN，关闭发送。</li>
<li>主动方 ACK，进入 TIME_WAIT，等待 2MSL。</li>
</ol>
<hr>
<h2 id="一、TCP-与-UDP-区别（深入版）"><a href="#一、TCP-与-UDP-区别（深入版）" class="headerlink" title="一、TCP 与 UDP 区别（深入版）"></a>一、TCP 与 UDP 区别（深入版）</h2><table>
<thead>
<tr>
<th>特性</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接方式</strong></td>
<td>面向连接，需要三次握手建立连接</td>
<td>无连接，直接发送数据报</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>可靠传输，确保数据完整、有序、不丢失</td>
<td>不可靠传输，不能保证顺序和到达</td>
</tr>
<tr>
<td><strong>数据单位</strong></td>
<td>报文段 (Segment)</td>
<td>数据报 (Datagram)</td>
</tr>
<tr>
<td><strong>速度</strong></td>
<td>较慢，需要建立连接、确认和重传机制</td>
<td>快，无握手和重传，开销小</td>
</tr>
<tr>
<td><strong>传输顺序</strong></td>
<td>保证顺序，序列号 + ACK 确认</td>
<td>不保证顺序，独立发送</td>
</tr>
<tr>
<td><strong>拥塞控制</strong></td>
<td>有，TCP 拥塞控制算法（慢启动、拥塞避免、快速重传、快速恢复）</td>
<td>无</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>文件传输 (FTP)、网页访问 (HTTP&#x2F;HTTPS)、邮件 (SMTP&#x2F;POP3)</td>
<td>实时视频&#x2F;语音 (VoIP、直播)、DNS 查询、DHCP</td>
</tr>
<tr>
<td><strong>面试拓展点</strong></td>
<td>TCP 适合可靠性要求高的场景</td>
<td>UDP 适合低延迟、可容忍丢包的场景</td>
</tr>
</tbody></table>
<p><strong>面试问法示例：</strong></p>
<ul>
<li>“TCP 为什么可靠，UDP 为什么不可靠？”<br> <strong>回答要点</strong>：TCP 使用序列号、ACK 确认、重传机制、流量控制和拥塞控制来保证可靠性；UDP 没有这些机制，直接发送报文，速度快，但不保证到达和顺序。</li>
</ul>
<hr>
<h2 id="二、三次握手的意义（深入版）"><a href="#二、三次握手的意义（深入版）" class="headerlink" title="二、三次握手的意义（深入版）"></a>二、三次握手的意义（深入版）</h2><p><strong>三次握手步骤复习</strong>：</p>
<ol>
<li><strong>客户端 → 服务器</strong>：SYN 报文，请求建立连接，发送 client_ISN。</li>
<li><strong>服务器 → 客户端</strong>：SYN-ACK 报文，确认客户端 SYN，并发送 server_ISN。</li>
<li><strong>客户端 → 服务器</strong>：ACK 报文，确认 server_ISN，连接建立。</li>
</ol>
<p><strong>为什么需要三次握手？</strong></p>
<ol>
<li><strong>防止旧连接报文误建</strong><ul>
<li>如果只有两次握手，旧的 SYN 报文可能延迟到达，服务器误认为是新连接。</li>
<li>三次握手确保客户端主动确认，服务器不会因为旧报文进入 ESTABLISHED。</li>
</ul>
</li>
<li><strong>双向确认收发能力</strong><ul>
<li>第一次握手：客户端告诉服务器它能发。</li>
<li>第二次握手：服务器告诉客户端它能发，也确认客户端能发。</li>
<li>第三次握手：客户端确认服务器能收。</li>
<li><strong>面试常问拓展</strong>：为什么第一次握手服务器不直接进入 ESTABLISHED？<br> <strong>答案</strong>：服务器不能确定客户端已经准备好接收数据，需第三次握手确认。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="三、TIME-WAIT-的意义（深入版）"><a href="#三、TIME-WAIT-的意义（深入版）" class="headerlink" title="三、TIME_WAIT 的意义（深入版）"></a>三、TIME_WAIT 的意义（深入版）</h2><ul>
<li><strong>TCP 四次挥手后客户端进入 TIME_WAIT</strong></li>
<li><strong>作用</strong>：<ol>
<li><strong>确保最后 ACK 能到达服务器</strong><ul>
<li>如果 ACK 丢失，服务器会重发 FIN，客户端在 TIME_WAIT 状态可以重新响应。</li>
</ul>
</li>
<li><strong>防止旧报文干扰新连接</strong><ul>
<li>2MSL（Maximum Segment Lifetime）内保证网络中旧报文被清除。</li>
</ul>
</li>
</ol>
</li>
<li><strong>典型面试问法</strong>：<ul>
<li>“为什么客户端主动关闭连接进入 TIME_WAIT，而服务器不进入？”<br> <strong>答案</strong>：主动关闭方需要确保 ACK 能到达被动关闭方并防止旧报文干扰新连接；被动关闭方在收到 ACK 后即可关闭。</li>
<li>“TIME_WAIT 为什么要等待 2MSL？”<br> <strong>答案</strong>：MSL 是报文在网络中的最大生存时间，等待 2MSL 可以确保所有可能滞留的报文消失。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="四、OSI-七层-vs-TCP-IP-模型（深入版）"><a href="#四、OSI-七层-vs-TCP-IP-模型（深入版）" class="headerlink" title="四、OSI 七层 vs TCP&#x2F;IP 模型（深入版）"></a>四、OSI 七层 vs TCP&#x2F;IP 模型（深入版）</h2><table>
<thead>
<tr>
<th>模型</th>
<th>层数</th>
<th>功能</th>
<th>面试关注点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OSI</strong></td>
<td>7 层：应用、表示、会话、传输、网络、数据链路、物理</td>
<td>理论模型，描述网络通信的完整功能</td>
<td>面试常考“每层功能、数据单位、协议、典型设备”</td>
</tr>
<tr>
<td><strong>TCP&#x2F;IP</strong></td>
<td>4 层：应用、传输、网络、网络接口</td>
<td>实际互联网使用的模型，简化 OSI，结合实际协议</td>
<td>面试常考“TCP&#x2F;IP 与 OSI 的对应关系、核心协议、应用场景”</td>
</tr>
</tbody></table>
<p><strong>OSI 与 TCP&#x2F;IP 对应关系</strong>：</p>
<ul>
<li>OSI 应用&#x2F;表示&#x2F;会话层 → TCP&#x2F;IP 应用层</li>
<li>OSI 传输层 → TCP&#x2F;IP 传输层</li>
<li>OSI 网络层 → TCP&#x2F;IP 网络层</li>
<li>OSI 数据链路层 + 物理层 → TCP&#x2F;IP 网络接口层</li>
</ul>
<p><strong>面试拓展点</strong>：</p>
<ol>
<li>TCP&#x2F;IP 为什么只有 4 层？<ul>
<li>因为实际应用中，表示层与会话层功能通常由应用层实现，硬件设备的物理和链路层可合并。</li>
</ul>
</li>
<li>OSI 模型为什么重要？<ul>
<li>理论指导，帮助理解网络通信分层设计、模块化、互操作性。</li>
</ul>
</li>
<li>面试常问：OSI 七层模型每层面试问法示例<ul>
<li><strong>物理层</strong>：双绞线和光纤区别？全双工和半双工区别？</li>
<li><strong>数据链路层</strong>：MAC 地址格式？交换机与网桥区别？VLAN 原理？</li>
<li><strong>网络层</strong>：IP 地址分类？子网掩码？RIP vs OSPF？</li>
<li><strong>传输层</strong>：TCP&#x2F;UDP 区别？三次握手流程？滑动窗口原理？</li>
<li><strong>会话层</strong>：HTTP 无状态如何实现会话保持？</li>
<li><strong>表示层</strong>：编码转换？大端小端？TLS 加密流程？</li>
<li><strong>应用层</strong>：HTTP 状态码？FTP 主动&#x2F;被动模式？DNS 查询过程？</li>
</ul>
</li>
</ol>
<hr>
<h2 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1. 物理层"></a>1. 物理层</h2><p><strong>Q1：双绞线和光纤区别？</strong><br> <strong>A1</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>双绞线</th>
<th>光纤</th>
</tr>
</thead>
<tbody><tr>
<td>传输介质</td>
<td>铜线</td>
<td>光纤（玻璃或塑料）</td>
</tr>
<tr>
<td>传输方式</td>
<td>电信号</td>
<td>光信号</td>
</tr>
<tr>
<td>抗干扰性</td>
<td>容易受电磁干扰</td>
<td>抗电磁干扰强</td>
</tr>
<tr>
<td>传输距离</td>
<td>短（100米左右）</td>
<td>长（可达数公里）</td>
</tr>
<tr>
<td>传输速率</td>
<td>10Mbps~10Gbps</td>
<td>1Gbps~400Gbps</td>
</tr>
<tr>
<td>成本</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td><strong>面试要点</strong>：光纤适合高速、长距离、数据中心或核心网，双绞线适合局域网。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Q2：全双工和半双工区别？</strong><br> <strong>A2</strong>：</p>
<ul>
<li><strong>半双工</strong>：数据双向传输，但同一时间只能一个方向（如对讲机）。</li>
<li><strong>全双工</strong>：数据双向传输，可同时收发（如现代交换机端口）。<br> <strong>面试要点</strong>：半双工容易冲突，需要 CSMA&#x2F;CD，降低效率；全双工无需冲突检测，速率翻倍。</li>
</ul>
<hr>
<h2 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2. 数据链路层"></a>2. 数据链路层</h2><p><strong>Q1：MAC 地址格式？</strong><br> <strong>A1</strong>：</p>
<ul>
<li>48 位二进制，通常写作 6 组十六进制：<code>00:1A:2B:3C:4D:5E</code></li>
<li>前 24 位：厂商标识（OUI）</li>
<li>后 24 位：网卡序列号</li>
<li>唯一标识网卡设备<br> <strong>面试要点</strong>：MAC 地址用于局域网内通信，交换机通过 MAC 表转发帧。</li>
</ul>
<p><strong>Q2：交换机与网桥区别？</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>网桥 (Bridge)</th>
<th>交换机 (Switch)</th>
</tr>
</thead>
<tbody><tr>
<td>端口数</td>
<td>少</td>
<td>多</td>
</tr>
<tr>
<td>功能</td>
<td>转发帧、过滤广播</td>
<td>转发帧、学习 MAC、分割冲突域</td>
</tr>
<tr>
<td>性能</td>
<td>较低</td>
<td>高</td>
</tr>
<tr>
<td><strong>面试要点</strong>：交换机可以理解为多端口网桥，隔离冲突域，效率更高。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Q3：VLAN 原理？</strong><br> <strong>A3</strong>：</p>
<ul>
<li>虚拟局域网（Virtual LAN）在同一物理交换机上划分不同逻辑网段。</li>
<li>通过 <strong>802.1Q 标签</strong> 给帧打标签，实现逻辑隔离。</li>
<li>优点：隔离广播域，提高安全性和管理性。<br> <strong>面试要点</strong>：同一交换机内不同 VLAN 之间通信需要路由器或三层交换机。</li>
</ul>
<hr>
<h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h2><p><strong>Q1：IP 地址分类？</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>起始位</th>
<th>范围</th>
<th>默认子网掩码</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
<td>1.0.0.0–126.255.255.255</td>
<td>255.0.0.0</td>
<td>大型网络</td>
</tr>
<tr>
<td>B</td>
<td>10</td>
<td>128.0.0.0–191.255.255.255</td>
<td>255.255.0.0</td>
<td>中型网络</td>
</tr>
<tr>
<td>C</td>
<td>110</td>
<td>192.0.0.0–223.255.255.255</td>
<td>255.255.255.0</td>
<td>小型网络</td>
</tr>
<tr>
<td>D</td>
<td>1110</td>
<td>224.0.0.0–239.255.255.255</td>
<td>N&#x2F;A</td>
<td>多播</td>
</tr>
<tr>
<td>E</td>
<td>1111</td>
<td>240.0.0.0–255.255.255.255</td>
<td>N&#x2F;A</td>
<td>实验&#x2F;保留</td>
</tr>
</tbody></table>
<p><strong>Q2：子网掩码作用？</strong></p>
<ul>
<li>用于区分网络号和主机号。</li>
<li>通过按位与运算确定同一网段内主机。</li>
<li>面试问法：给 IP&#x2F;子网掩码计算可用主机数或广播地址。</li>
</ul>
<p><strong>Q3：RIP vs OSPF</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>RIP</th>
<th>OSPF</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>距离矢量</td>
<td>链路状态</td>
</tr>
<tr>
<td>收敛速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>度量</td>
<td>跳数</td>
<td>带宽&#x2F;延迟</td>
</tr>
<tr>
<td>缺点</td>
<td>路径可能环路</td>
<td>配置复杂</td>
</tr>
<tr>
<td><strong>面试要点</strong>：RIP 简单、适合小网络；OSPF 复杂、适合大型网络。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4. 传输层"></a>4. 传输层</h2><p><strong>Q1：TCP&#x2F;UDP 区别</strong><br> 详见上条回答。</p>
<p><strong>Q2：三次握手流程</strong><br> 详见上条回答，可画图辅助说明。</p>
<p><strong>Q3：滑动窗口原理</strong></p>
<ul>
<li>TCP 使用滑动窗口进行流量控制。</li>
<li><strong>发送方</strong>可发送窗口大小内的数据而不必等待 ACK。</li>
<li><strong>接收方</strong>通过窗口大小告知可接收缓冲区容量。</li>
<li><strong>好处</strong>：提高链路利用率，避免频繁等待确认。</li>
<li>面试问法：滑动窗口与停止等待区别？答案：滑动窗口一次可发送多段，停止等待一次只能发送一段。</li>
</ul>
<hr>
<h2 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5. 会话层"></a>5. 会话层</h2><p><strong>Q1：HTTP 无状态如何实现会话保持？</strong></p>
<ul>
<li>HTTP 本身无状态，每次请求独立。</li>
<li><strong>实现方式</strong>：<ol>
<li><strong>Cookie</strong>：客户端保存会话 ID，随请求发送。</li>
<li><strong>Session</strong>：服务端保存用户状态，客户端发送标识。</li>
<li><strong>Token&#x2F;JWT</strong>：无状态方式，将用户信息加密放在客户端。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6. 表示层"></a>6. 表示层</h2><p><strong>Q1：编码转换</strong></p>
<ul>
<li>ASCII、UTF-8、Unicode 等，用于不同系统间字符表示兼容。</li>
<li>面试问法：中文 UTF-8 编码占多少字节？<br> <strong>答案</strong>：汉字 3 字节，英文 1 字节。</li>
</ul>
<p><strong>Q2：大端小端</strong></p>
<ul>
<li><strong>大端</strong>（Big Endian）：高位字节存放在低地址。</li>
<li><strong>小端</strong>（Little Endian）：低位字节存放在低地址。</li>
<li>面试问法：网络传输使用哪种？<br> <strong>答案</strong>：大端（网络字节序）。</li>
</ul>
<p><strong>Q3：TLS 加密流程</strong></p>
<ol>
<li>客户端发送 ClientHello（支持加密算法）。</li>
<li>服务器返回 ServerHello，发送证书。</li>
<li>客户端验证证书，生成会话密钥。</li>
<li>双方用会话密钥加密通信。</li>
</ol>
<ul>
<li>面试要点：讲清楚“证书验证”和“对称密钥加密数据”。</li>
</ul>
<hr>
<h2 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7. 应用层"></a>7. 应用层</h2><p><strong>Q1：HTTP 状态码</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>100 Continue</td>
<td>信息性响应</td>
</tr>
<tr>
<td>2xx</td>
<td>200 OK</td>
<td>成功</td>
</tr>
<tr>
<td>3xx</td>
<td>301 Moved Permanently</td>
<td>重定向</td>
</tr>
<tr>
<td>4xx</td>
<td>404 Not Found</td>
<td>客户端错误</td>
</tr>
<tr>
<td>5xx</td>
<td>500 Internal Server Error</td>
<td>服务器错误</td>
</tr>
</tbody></table>
<p><strong>Q2：FTP 主动&#x2F;被动模式</strong></p>
<ul>
<li><strong>主动模式</strong>：客户端建立控制连接，服务器主动建立数据连接。</li>
<li><strong>被动模式</strong>：客户端建立控制连接和数据连接，服务器被动监听。</li>
<li>面试要点：被动模式用于客户端在防火墙后的情况。</li>
</ul>
<p><strong>Q3：DNS 查询过程</strong></p>
<ol>
<li>客户端向本地 DNS 发起递归查询。</li>
<li>本地 DNS 如果缓存没有，向根 DNS 查询 → 顶级域 → 权威 DNS。</li>
<li>权威 DNS 返回解析结果到本地 DNS，本地返回给客户端。</li>
</ol>
<ul>
<li>面试要点：递归查询 vs 迭代查询区别。</li>
</ul>
<hr>
<hr>
<h2 id="一、前后端交互的基本流程"><a href="#一、前后端交互的基本流程" class="headerlink" title="一、前后端交互的基本流程"></a><strong>一、前后端交互的基本流程</strong></h2><ol>
<li><strong>前端发起请求</strong><ul>
<li>用户在浏览器或客户端操作，比如点击按钮、提交表单。</li>
<li>前端通过 HTTP&#x2F;HTTPS 或 WebSocket 向后端发送请求。</li>
<li>请求包含：URL、请求方法（GET&#x2F;POST&#x2F;PUT&#x2F;DELETE 等）、请求头（Header）、请求体（Body，POST&#x2F;PUT 时）和参数。</li>
</ul>
</li>
<li><strong>后端接收请求</strong><ul>
<li>后端服务器（如 Java&#x2F;Spring、Node.js、Python Flask&#x2F;Django）解析请求。</li>
<li>后端根据 URL 路径、HTTP 方法匹配路由到对应的处理函数（Controller&#x2F;Handler）。</li>
</ul>
</li>
<li><strong>后端处理请求</strong><ul>
<li>后端进行业务逻辑处理：<ul>
<li>数据库查询&#x2F;更新（CRUD）</li>
<li>调用其他服务或 API</li>
<li>数据验证、权限校验</li>
</ul>
</li>
<li>处理完成后，生成响应数据（通常为 JSON、XML、HTML 或二进制文件）。</li>
</ul>
</li>
<li><strong>后端返回响应</strong><ul>
<li>响应包含：状态码（HTTP Status Code）、响应头、响应体（Body）。</li>
<li>状态码示例：<ul>
<li>200 OK：请求成功</li>
<li>201 Created：资源创建成功</li>
<li>400 Bad Request：请求错误</li>
<li>401 Unauthorized：未授权</li>
<li>500 Internal Server Error：服务器错误</li>
</ul>
</li>
</ul>
</li>
<li><strong>前端接收响应</strong><ul>
<li>前端根据状态码判断请求结果。</li>
<li>前端解析响应体并更新界面（UI），例如渲染数据表格、显示提示信息。</li>
<li>如果是异步请求（AJAX&#x2F;Fetch&#x2F;axios），前端可以在回调或 Promise 中处理响应。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="二、前后端交互方式"><a href="#二、前后端交互方式" class="headerlink" title="二、前后端交互方式"></a><strong>二、前后端交互方式</strong></h2><h3 id="1-HTTP-请求-响应模式"><a href="#1-HTTP-请求-响应模式" class="headerlink" title="1. HTTP 请求-响应模式"></a>1. <strong>HTTP 请求-响应模式</strong></h3><ul>
<li><strong>同步请求</strong>（传统表单提交）：浏览器提交表单，等待响应页面刷新。</li>
<li><strong>异步请求</strong>（AJAX&#x2F;Fetch&#x2F;axios）：页面不刷新，通过 JavaScript 异步获取数据。</li>
</ul>
<h3 id="2-WebSocket-实时通信"><a href="#2-WebSocket-实时通信" class="headerlink" title="2. WebSocket 实时通信"></a>2. <strong>WebSocket 实时通信</strong></h3><ul>
<li>前端与后端建立长连接。</li>
<li>可以实时双向通信，不需要每次都发 HTTP 请求。</li>
<li>适用场景：聊天应用、在线游戏、实时监控。</li>
</ul>
<h3 id="3-Server-Sent-Events（SSE）"><a href="#3-Server-Sent-Events（SSE）" class="headerlink" title="3. Server-Sent Events（SSE）"></a>3. <strong>Server-Sent Events（SSE）</strong></h3><ul>
<li>后端主动向前端推送事件流。</li>
<li>单向通信（后端 → 前端）。</li>
<li>适用于消息通知、实时数据更新。</li>
</ul>
<h3 id="4-GraphQL"><a href="#4-GraphQL" class="headerlink" title="4. GraphQL"></a>4. <strong>GraphQL</strong></h3><ul>
<li>前端发送一个查询请求，后端根据查询返回精确的数据。</li>
<li>相比 REST，可以减少冗余数据传输。</li>
</ul>
<hr>
<h2 id="三、前后端响应示例"><a href="#三、前后端响应示例" class="headerlink" title="三、前后端响应示例"></a><strong>三、前后端响应示例</strong></h2><p><strong>前端（JavaScript fetch）</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/users&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;网络错误&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;用户数据:&quot;</span>, data);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;请求失败:&quot;</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>后端（Node.js&#x2F;Express）</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/users&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> users = [</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(users);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>前端发起 GET 请求 → 后端返回 JSON → 前端解析 JSON 更新页面。</li>
</ul>
<hr>
<h2 id="四、状态码与响应流程"><a href="#四、状态码与响应流程" class="headerlink" title="四、状态码与响应流程"></a><strong>四、状态码与响应流程</strong></h2><table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
<th>前端处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>200 OK</td>
<td>请求成功</td>
<td>解析数据更新 UI</td>
</tr>
<tr>
<td>201 Created</td>
<td>资源创建成功</td>
<td>可以跳转或提示成功</td>
</tr>
<tr>
<td>400 Bad Request</td>
<td>请求参数错误</td>
<td>提示用户检查输入</td>
</tr>
<tr>
<td>401 Unauthorized</td>
<td>未授权</td>
<td>跳转登录页或请求授权</td>
</tr>
<tr>
<td>404 Not Found</td>
<td>资源不存在</td>
<td>显示 404 页面</td>
</tr>
<tr>
<td>500 Internal Server Error</td>
<td>后端错误</td>
<td>显示错误提示或重试</td>
</tr>
</tbody></table>
<hr>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>好的，我来给你整理一份 <strong>Linux 常见知识点清单</strong>，涵盖基础命令、系统管理、权限、网络、进程、文件系统等方面，适合面试或日常运维参考。我会按模块整理，并给出重点说明。</p>
<hr>
<h2 id="一、基础命令"><a href="#一、基础命令" class="headerlink" title="一、基础命令"></a><strong>一、基础命令</strong></h2><h3 id="1-文件和目录操作"><a href="#1-文件和目录操作" class="headerlink" title="1. 文件和目录操作"></a>1. 文件和目录操作</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code></td>
<td>列出目录内容</td>
</tr>
<tr>
<td><code>cd</code></td>
<td>切换目录</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>查看当前路径</td>
</tr>
<tr>
<td><code>mkdir</code></td>
<td>创建目录</td>
</tr>
<tr>
<td><code>rm</code></td>
<td>删除文件&#x2F;目录（<code>-r</code>递归）</td>
</tr>
<tr>
<td><code>cp</code></td>
<td>复制文件&#x2F;目录</td>
</tr>
<tr>
<td><code>mv</code></td>
<td>移动或重命名</td>
</tr>
<tr>
<td><code>find</code></td>
<td>查找文件</td>
</tr>
<tr>
<td><code>locate</code></td>
<td>快速查找文件（需更新索引）</td>
</tr>
</tbody></table>
<h3 id="2-文件查看与编辑"><a href="#2-文件查看与编辑" class="headerlink" title="2. 文件查看与编辑"></a>2. 文件查看与编辑</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>cat</code></td>
<td>查看文件内容</td>
</tr>
<tr>
<td><code>less</code> &#x2F; <code>more</code></td>
<td>分页浏览</td>
</tr>
<tr>
<td><code>head</code> &#x2F; <code>tail</code></td>
<td>查看开头&#x2F;结尾行</td>
</tr>
<tr>
<td><code>grep</code></td>
<td>文件内容搜索</td>
</tr>
<tr>
<td><code>wc</code></td>
<td>统计行数、字数、字符数</td>
</tr>
<tr>
<td><code>vim</code> &#x2F; <code>nano</code></td>
<td>文本编辑</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、用户与权限管理"><a href="#二、用户与权限管理" class="headerlink" title="二、用户与权限管理"></a><strong>二、用户与权限管理</strong></h2><h3 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1. 用户管理"></a>1. 用户管理</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>useradd</code></td>
<td>添加用户</td>
</tr>
<tr>
<td><code>usermod</code></td>
<td>修改用户</td>
</tr>
<tr>
<td><code>passwd</code></td>
<td>修改用户密码</td>
</tr>
<tr>
<td><code>userdel</code></td>
<td>删除用户</td>
</tr>
<tr>
<td><code>id</code></td>
<td>查看用户信息</td>
</tr>
</tbody></table>
<h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2. 权限管理"></a>2. 权限管理</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>chmod</code></td>
<td>修改文件权限（数字&#x2F;符号模式）</td>
</tr>
<tr>
<td><code>chown</code></td>
<td>修改文件所有者</td>
</tr>
<tr>
<td><code>chgrp</code></td>
<td>修改文件所属组</td>
</tr>
<tr>
<td><code>umask</code></td>
<td>设置默认权限掩码</td>
</tr>
<tr>
<td><code>sudo</code></td>
<td>提权执行命令</td>
</tr>
</tbody></table>
<hr>
<h2 id="三、进程管理"><a href="#三、进程管理" class="headerlink" title="三、进程管理"></a><strong>三、进程管理</strong></h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>ps</code></td>
<td>查看进程</td>
</tr>
<tr>
<td><code>top</code> &#x2F; <code>htop</code></td>
<td>动态查看进程和资源</td>
</tr>
<tr>
<td><code>kill</code> &#x2F; <code>killall</code></td>
<td>结束进程</td>
</tr>
<tr>
<td><code>nice</code> &#x2F; <code>renice</code></td>
<td>设置进程优先级</td>
</tr>
<tr>
<td><code>jobs</code> &#x2F; <code>fg</code> &#x2F; <code>bg</code></td>
<td>作业控制（后台&#x2F;前台）</td>
</tr>
</tbody></table>
<hr>
<h2 id="四、网络管理"><a href="#四、网络管理" class="headerlink" title="四、网络管理"></a><strong>四、网络管理</strong></h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>ifconfig</code> &#x2F; <code>ip addr</code></td>
<td>查看网卡IP信息</td>
</tr>
<tr>
<td><code>ping</code></td>
<td>测试网络连通性</td>
</tr>
<tr>
<td><code>traceroute</code> &#x2F; <code>tracepath</code></td>
<td>路由跟踪</td>
</tr>
<tr>
<td><code>netstat</code> &#x2F; <code>ss</code></td>
<td>查看端口&#x2F;连接信息</td>
</tr>
<tr>
<td><code>curl</code> &#x2F; <code>wget</code></td>
<td>下载文件或访问URL</td>
</tr>
<tr>
<td><code>scp</code> &#x2F; <code>rsync</code></td>
<td>远程复制文件</td>
</tr>
<tr>
<td><code>iptables</code> &#x2F; <code>firewalld</code></td>
<td>防火墙管理</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、包管理"><a href="#五、包管理" class="headerlink" title="五、包管理"></a><strong>五、包管理</strong></h2><ul>
<li><strong>Debian&#x2F;Ubuntu 系列</strong>：<ul>
<li><code>apt update</code> &#x2F; <code>apt upgrade</code></li>
<li><code>apt install &lt;package&gt;</code> &#x2F; <code>apt remove &lt;package&gt;</code></li>
</ul>
</li>
<li><strong>RedHat&#x2F;CentOS 系列</strong>：<ul>
<li><code>yum install &lt;package&gt;</code> &#x2F; <code>yum remove &lt;package&gt;</code></li>
<li><code>dnf</code>（新版本替代 yum）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="六、磁盘与文件系统管理"><a href="#六、磁盘与文件系统管理" class="headerlink" title="六、磁盘与文件系统管理"></a><strong>六、磁盘与文件系统管理</strong></h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>df -h</code></td>
<td>查看磁盘空间</td>
</tr>
<tr>
<td><code>du -h</code></td>
<td>查看目录&#x2F;文件大小</td>
</tr>
<tr>
<td><code>mount</code> &#x2F; <code>umount</code></td>
<td>挂载&#x2F;卸载分区</td>
</tr>
<tr>
<td><code>lsblk</code></td>
<td>查看磁盘分区</td>
</tr>
<tr>
<td><code>fdisk</code> &#x2F; <code>parted</code></td>
<td>分区管理</td>
</tr>
<tr>
<td><code>mkfs</code></td>
<td>格式化文件系统</td>
</tr>
<tr>
<td><code>fsck</code></td>
<td>检查文件系统</td>
</tr>
</tbody></table>
<hr>
<h2 id="七、日志管理"><a href="#七、日志管理" class="headerlink" title="七、日志管理"></a><strong>七、日志管理</strong></h2><table>
<thead>
<tr>
<th>文件&#x2F;命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>/var/log/messages</code></td>
<td>系统日志</td>
</tr>
<tr>
<td><code>/var/log/syslog</code></td>
<td>系统事件</td>
</tr>
<tr>
<td><code>/var/log/auth.log</code></td>
<td>用户登录与认证</td>
</tr>
<tr>
<td><code>journalctl</code></td>
<td>查看 systemd 日志</td>
</tr>
<tr>
<td><code>dmesg</code></td>
<td>查看内核启动和硬件日志</td>
</tr>
</tbody></table>
<hr>
<h2 id="八、系统管理"><a href="#八、系统管理" class="headerlink" title="八、系统管理"></a><strong>八、系统管理</strong></h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>uptime</code></td>
<td>系统运行时间</td>
</tr>
<tr>
<td><code>uname -a</code></td>
<td>系统信息</td>
</tr>
<tr>
<td><code>free -h</code></td>
<td>内存使用</td>
</tr>
<tr>
<td><code>vmstat</code></td>
<td>系统资源统计</td>
</tr>
<tr>
<td><code>df -h</code></td>
<td>磁盘使用情况</td>
</tr>
<tr>
<td><code>systemctl</code></td>
<td>管理服务（启动&#x2F;停止&#x2F;重启）</td>
</tr>
<tr>
<td><code>crontab</code></td>
<td>定时任务管理</td>
</tr>
</tbody></table>
<hr>
<h2 id="九、压缩与解压"><a href="#九、压缩与解压" class="headerlink" title="九、压缩与解压"></a><strong>九、压缩与解压</strong></h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>tar -cvf</code> &#x2F; <code>tar -xvf</code></td>
<td>打包&#x2F;解包</td>
</tr>
<tr>
<td><code>gzip</code> &#x2F; <code>gunzip</code></td>
<td>压缩&#x2F;解压</td>
</tr>
<tr>
<td><code>zip</code> &#x2F; <code>unzip</code></td>
<td>压缩&#x2F;解压</td>
</tr>
</tbody></table>
<hr>
<h2 id="十、Shell-脚本基础（详细版）"><a href="#十、Shell-脚本基础（详细版）" class="headerlink" title="十、Shell 脚本基础（详细版）"></a><strong>十、Shell 脚本基础（详细版）</strong></h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><ul>
<li><strong>定义变量</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME=<span class="string">&quot;Charlotte&quot;</span></span><br><span class="line">AGE=25</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>访问变量</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$NAME</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>只读变量</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">readonly</span> NAME</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>环境变量</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/new/path</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-条件判断"><a href="#2-条件判断" class="headerlink" title="2. 条件判断"></a>2. 条件判断</h3><ul>
<li><strong>if 语句</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$AGE</span> -ge 18 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;成年人&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;未成年人&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>常用条件表达式</strong>：<table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-eq</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>-ne</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>-gt</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>-lt</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>-ge</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>-le</code></td>
<td>小于等于</td>
</tr>
<tr>
<td><code>-f filename</code></td>
<td>文件存在且为普通文件</td>
</tr>
<tr>
<td><code>-d dirname</code></td>
<td>目录存在</td>
</tr>
<tr>
<td><code>-x filename</code></td>
<td>可执行文件</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3. 循环语句"></a>3. 循环语句</h3><ul>
<li><strong>for 循环</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 1 2 3 4 5; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第 <span class="variable">$i</span> 次循环&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>while 循环</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;计数 <span class="variable">$count</span>&quot;</span></span><br><span class="line">    count=$((count+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>until 循环</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count=1</span><br><span class="line"><span class="keyword">until</span> [ <span class="variable">$count</span> -gt 5 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;计数 <span class="variable">$count</span>&quot;</span></span><br><span class="line">    count=$((count+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">greet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet <span class="string">&quot;Charlotte&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>$1</code> 表示函数传入的第一个参数</li>
<li><code>$@</code> 表示所有参数</li>
<li><code>return</code> 返回状态码（0表示成功，非0表示失败）</li>
</ul>
<hr>
<h3 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5. 输入输出"></a>5. 输入输出</h3><ul>
<li><strong>标准输入&#x2F;输出&#x2F;错误</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span>         <span class="comment"># stdout</span></span><br><span class="line"><span class="built_in">read</span> name            <span class="comment"># stdin</span></span><br><span class="line"><span class="built_in">ls</span> nonexist 2&gt; error.log  <span class="comment"># stderr重定向</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>管道与重定向</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file.txt | grep <span class="string">&quot;hello&quot;</span> &gt; result.txt</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-脚本执行权限"><a href="#6-脚本执行权限" class="headerlink" title="6. 脚本执行权限"></a>6. 脚本执行权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x script.sh</span><br><span class="line">./script.sh</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-实用示例"><a href="#7-实用示例" class="headerlink" title="7. 实用示例"></a>7. 实用示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 统计当前目录下所有文件数</span></span><br><span class="line">count=$(<span class="built_in">ls</span> -l | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前目录文件数量: <span class="variable">$count</span>&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="十一、Linux-面试常问知识点（全面版）"><a href="#十一、Linux-面试常问知识点（全面版）" class="headerlink" title="十一、Linux 面试常问知识点（全面版）"></a><strong>十一、Linux 面试常问知识点（全面版）</strong></h1><hr>
<h2 id="1-文件权限与权限管理"><a href="#1-文件权限与权限管理" class="headerlink" title="1. 文件权限与权限管理"></a><strong>1. 文件权限与权限管理</strong></h2><h3 id="核心知识点："><a href="#核心知识点：" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul>
<li><strong>权限类型</strong>：读（r）、写（w）、执行（x）</li>
<li><strong>三类用户</strong>：<ul>
<li>拥有者（u）</li>
<li>用户组（g）</li>
<li>其他用户（o）</li>
</ul>
</li>
<li><strong>权限表示</strong>：<ul>
<li>符号表示法：<code>rwxr-xr-x</code></li>
<li>数字表示法：<code>chmod 755 file</code> → 7&#x3D;rw, x; 5&#x3D;r-x; 5&#x3D;r-x</li>
</ul>
</li>
</ul>
<h3 id="面试常问问题："><a href="#面试常问问题：" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol>
<li><p><strong>命令 chmod、chown、chgrp 有什么作用？</strong></p>
<ul>
<li><code>chmod</code>：修改权限</li>
<li><code>chown</code>：修改文件所有者</li>
<li><code>chgrp</code>：修改文件所属组</li>
</ul>
</li>
<li><p><strong>硬链接和软链接区别？</strong></p>
<table>
<thead>
<tr>
<th>项目</th>
<th>硬链接</th>
<th>软链接</th>
</tr>
</thead>
<tbody><tr>
<td>inode</td>
<td>相同</td>
<td>不同</td>
</tr>
<tr>
<td>跨分区</td>
<td>不行</td>
<td>可以</td>
</tr>
<tr>
<td>删除原文件</td>
<td>内容仍存在</td>
<td>链接失效</td>
</tr>
<tr>
<td>命令</td>
<td><code>ln source target</code></td>
<td><code>ln -s source target</code></td>
</tr>
</tbody></table>
</li>
<li><p><strong>文件描述符和重定向</strong></p>
<ul>
<li><code>0</code> stdin, <code>1</code> stdout, <code>2</code> stderr</li>
<li>示例：<code>command &gt; out.log 2&gt;&amp;1</code> → stdout 和 stderr 都写入 out.log</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-进程与作业管理"><a href="#2-进程与作业管理" class="headerlink" title="2. 进程与作业管理"></a><strong>2. 进程与作业管理</strong></h2><h3 id="核心知识点：-1"><a href="#核心知识点：-1" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul>
<li><strong>查看进程</strong>：<ul>
<li><code>ps aux</code>、<code>top</code>、<code>htop</code></li>
</ul>
</li>
<li><strong>结束进程</strong>：<ul>
<li><code>kill PID</code>、<code>kill -9 PID</code>、<code>killall process_name</code></li>
</ul>
</li>
<li><strong>后台&#x2F;前台任务</strong>：<ul>
<li><code>&amp;</code>：后台执行</li>
<li><code>jobs</code>：查看后台任务</li>
<li><code>fg %1</code>：切换到前台</li>
</ul>
</li>
<li><strong>优先级</strong>：<ul>
<li><code>nice</code>、<code>renice</code> 设置 CPU 优先级</li>
</ul>
</li>
</ul>
<h3 id="面试常问问题：-1"><a href="#面试常问问题：-1" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol>
<li><p><strong>如何查看端口被哪个进程占用？</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :8080</span><br><span class="line">netstat -tulpn | grep 8080</span><br><span class="line">ss -tulpn | grep 8080</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如何终止占用端口的进程？</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="3-文件系统与磁盘管理"><a href="#3-文件系统与磁盘管理" class="headerlink" title="3. 文件系统与磁盘管理"></a><strong>3. 文件系统与磁盘管理</strong></h2><h3 id="核心知识点：-2"><a href="#核心知识点：-2" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul>
<li><code>df -h</code> 查看磁盘空间</li>
<li><code>du -h</code> 查看目录大小</li>
<li><code>lsblk</code> 查看分区信息</li>
<li><code>mount / umount</code> 挂载卸载</li>
<li><code>fdisk / parted</code> 分区</li>
<li><code>mkfs</code> 格式化文件系统</li>
<li><code>fsck</code> 检查文件系统</li>
</ul>
<h3 id="面试常问问题：-2"><a href="#面试常问问题：-2" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol>
<li><p><strong>硬链接和软链接在文件系统中有什么区别？</strong></p>
</li>
<li><p><strong>如何查看磁盘空间和使用情况？</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="built_in">du</span> -sh /path/to/dir</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="4-网络管理"><a href="#4-网络管理" class="headerlink" title="4. 网络管理"></a><strong>4. 网络管理</strong></h2><h3 id="核心知识点：-3"><a href="#核心知识点：-3" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul>
<li>查看 IP 地址：<code>ifconfig</code> &#x2F; <code>ip addr</code></li>
<li>测试连通性：<code>ping</code></li>
<li>路由追踪：<code>traceroute</code> &#x2F; <code>tracepath</code></li>
<li>查看端口和连接：<code>netstat</code> &#x2F; <code>ss</code></li>
<li>下载文件或请求 URL：<code>wget</code> &#x2F; <code>curl</code></li>
<li>远程文件传输：<code>scp</code> &#x2F; <code>rsync</code></li>
</ul>
<h3 id="面试常问问题：-3"><a href="#面试常问问题：-3" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol>
<li><p><strong>如何查看网卡信息？</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如何调试网络连通性？</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 8.8.8.8</span><br><span class="line">traceroute www.baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如何查看 8080 端口占用？</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tulpn | grep 8080</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="5-用户与组管理"><a href="#5-用户与组管理" class="headerlink" title="5. 用户与组管理"></a><strong>5. 用户与组管理</strong></h2><h3 id="核心知识点：-4"><a href="#核心知识点：-4" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul>
<li>添加用户：<code>useradd</code></li>
<li>删除用户：<code>userdel</code></li>
<li>修改用户：<code>usermod -aG group user</code></li>
<li>修改密码：<code>passwd user</code></li>
<li>查看组信息：<code>groups user</code></li>
<li>提权命令：<code>sudo command</code></li>
</ul>
<h3 id="面试常问问题：-4"><a href="#面试常问问题：-4" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol>
<li><p><strong>如何给用户加入某个组？</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG dev user</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如何限制用户权限？</strong></p>
<ul>
<li>使用 <code>chmod</code> 设置文件权限</li>
<li>使用 <code>sudoers</code> 配置命令权限</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-Shell-脚本基础"><a href="#6-Shell-脚本基础" class="headerlink" title="6. Shell 脚本基础"></a><strong>6. Shell 脚本基础</strong></h2><h3 id="核心知识点：-5"><a href="#核心知识点：-5" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul>
<li>变量、条件判断、循环、函数</li>
<li>管道、重定向、标准输入输出</li>
<li>常用脚本示例：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *.<span class="built_in">log</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;处理文件: <span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="面试常问问题：-5"><a href="#面试常问问题：-5" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol>
<li><strong>如何判断文件是否存在？</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;/path/to/file&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件存在&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>如何统计目录下文件数量？</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count=$(<span class="built_in">ls</span> -l | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$count</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-定时任务（Crontab）"><a href="#7-定时任务（Crontab）" class="headerlink" title="7. 定时任务（Crontab）"></a><strong>7. 定时任务（Crontab）</strong></h2><h3 id="核心知识点：-6"><a href="#核心知识点：-6" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul>
<li>查看：<code>crontab -l</code></li>
<li>编辑：<code>crontab -e</code></li>
<li>时间格式：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">command</span></span><br><span class="line">分 时 日 月 星期</span><br></pre></td></tr></table></figure>

<ul>
<li>示例：每天凌晨 2 点备份</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 * * * /home/user/backup.sh</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-系统日志"><a href="#8-系统日志" class="headerlink" title="8. 系统日志"></a><strong>8. 系统日志</strong></h2><h3 id="核心知识点：-7"><a href="#核心知识点：-7" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul>
<li>常用日志路径：<table>
<thead>
<tr>
<th>文件</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td><code>/var/log/messages</code></td>
<td>系统事件</td>
</tr>
<tr>
<td><code>/var/log/syslog</code></td>
<td>系统服务日志</td>
</tr>
<tr>
<td><code>/var/log/auth.log</code></td>
<td>登录&#x2F;认证日志</td>
</tr>
<tr>
<td><code>/var/log/kern.log</code></td>
<td>内核日志</td>
</tr>
<tr>
<td><code>journalctl</code></td>
<td>systemd 日志</td>
</tr>
</tbody></table>
</li>
<li>查看日志：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/syslog</span><br><span class="line">journalctl -xe</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-系统管理"><a href="#9-系统管理" class="headerlink" title="9. 系统管理"></a><strong>9. 系统管理</strong></h2><h3 id="核心知识点：-8"><a href="#核心知识点：-8" class="headerlink" title="核心知识点："></a>核心知识点：</h3><ul>
<li>系统信息：<code>uname -a</code></li>
<li>内存查看：<code>free -h</code></li>
<li>CPU&#x2F;资源统计：<code>top</code> &#x2F; <code>vmstat</code></li>
<li>服务管理：<code>systemctl start/stop/restart/status service</code></li>
<li>系统启动流程：BIOS → Bootloader → Kernel → init&#x2F;systemd → 多用户模式</li>
</ul>
<h3 id="面试常问问题：-6"><a href="#面试常问问题：-6" class="headerlink" title="面试常问问题："></a>面试常问问题：</h3><ol>
<li><strong>如何查看系统运行时间？</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shelluptime</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>如何管理系统服务？</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br><span class="line">systemctl enable nginx</span><br><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-综合示例（面试题）"><a href="#10-综合示例（面试题）" class="headerlink" title="10. 综合示例（面试题）"></a><strong>10. 综合示例（面试题）</strong></h2><ol>
<li><strong>如何查找占用 CPU 前 5 的进程？</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux --sort=-%cpu | head -n 6</span><br></pre></td></tr></table></figure>

<p>   2.<strong>如何查找 1 小时内修改过的文件？</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/dir -type f -mmin -60</span><br></pre></td></tr></table></figure>

<p>   3.<strong>如何将错误日志和输出日志写入同一个文件？</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt; all.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>   4.<strong>如何给用户添加 sudo 权限？</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG sudo username</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h1><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><h2 id="1-DML-Data-Manipulation-Language-—-数据操作"><a href="#1-DML-Data-Manipulation-Language-—-数据操作" class="headerlink" title="1. DML (Data Manipulation Language) — 数据操作"></a>1. DML (Data Manipulation Language) — 数据操作</h2><p>用于操作数据库中的数据。</p>
<h3 id="1-1-SELECT-查询"><a href="#1-1-SELECT-查询" class="headerlink" title="1.1 SELECT 查询"></a>1.1 SELECT 查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查询指定列，并对结果排序、分页</span><br><span class="line">SELECT column1, column2</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE condition         -- 过滤条件</span><br><span class="line">ORDER BY column DESC    -- 按列排序，可 ASC 或 DESC</span><br><span class="line">LIMIT offset, count;    -- 分页查询，offset: 偏移量, count: 返回行数</span><br></pre></td></tr></table></figure>

<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*), SUM(column), AVG(column), MAX(column), MIN(column)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure>

<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column, COUNT(*)</span><br><span class="line">FROM table_name</span><br><span class="line">GROUP BY column       -- 按 column 分组</span><br><span class="line">HAVING COUNT(*) &gt; 1; -- 分组过滤</span><br></pre></td></tr></table></figure>

<h4 id="联接查询-JOIN"><a href="#联接查询-JOIN" class="headerlink" title="联接查询 (JOIN)"></a>联接查询 (JOIN)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-- 内连接，只返回两个表中匹配的行</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">INNER JOIN table_b b ON a.id = b.a_id;</span><br><span class="line"></span><br><span class="line">-- 左连接，返回左表所有行及匹配右表的行</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">LEFT JOIN table_b b ON a.id = b.a_id;</span><br><span class="line"></span><br><span class="line">-- 右连接，返回右表所有行及匹配左表的行</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">RIGHT JOIN table_b b ON a.id = b.a_id;</span><br><span class="line"></span><br><span class="line">-- 全连接 (MySQL 不直接支持，用 UNION ALL 模拟)</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">LEFT JOIN table_b b ON a.id = b.a_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT a.*, b.*</span><br><span class="line">FROM table_a a</span><br><span class="line">RIGHT JOIN table_b b ON a.id = b.a_id</span><br><span class="line">WHERE a.id IS NULL;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-INSERT-插入"><a href="#1-2-INSERT-插入" class="headerlink" title="1.2 INSERT 插入"></a>1.2 INSERT 插入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 指定列插入</span><br><span class="line">INSERT INTO table_name (column1, column2)</span><br><span class="line">VALUES (value1, value2);</span><br><span class="line"></span><br><span class="line">-- 插入所有列</span><br><span class="line">INSERT INTO table_name</span><br><span class="line">VALUES (value1, value2, ...);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-UPDATE-更新"><a href="#1-3-UPDATE-更新" class="headerlink" title="1.3 UPDATE 更新"></a>1.3 UPDATE 更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET column1 = value1,</span><br><span class="line">    column2 = value2</span><br><span class="line">WHERE condition;  -- 必须加 WHERE，否则会更新所有行</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-4-DELETE-删除"><a href="#1-4-DELETE-删除" class="headerlink" title="1.4 DELETE 删除"></a>1.4 DELETE 删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE condition; -- 不加 WHERE 会删除所有行，比 TRUNCATE TABLE 慢</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-DDL-Data-Definition-Language-—-数据定义"><a href="#2-DDL-Data-Definition-Language-—-数据定义" class="headerlink" title="2. DDL (Data Definition Language) — 数据定义"></a>2. DDL (Data Definition Language) — 数据定义</h2><p>用于创建、修改和删除数据库对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE DATABASE database_name;</span><br><span class="line"></span><br><span class="line">-- 创建表</span><br><span class="line">CREATE TABLE table_name (</span><br><span class="line">    column1 datatype constraints,</span><br><span class="line">    column2 datatype constraints,</span><br><span class="line">    PRIMARY KEY (column_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 修改表结构</span><br><span class="line">ALTER TABLE table_name ADD column_name datatype;</span><br><span class="line">ALTER TABLE table_name DROP COLUMN column_name;</span><br><span class="line">ALTER TABLE table_name MODIFY COLUMN column_name datatype;</span><br><span class="line"></span><br><span class="line">-- 删除表</span><br><span class="line">DROP TABLE table_name;</span><br><span class="line"></span><br><span class="line">-- 索引操作</span><br><span class="line">CREATE INDEX index_name ON table_name (column_name);</span><br><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-DCL-Data-Control-Language-—-数据权限控制"><a href="#3-DCL-Data-Control-Language-—-数据权限控制" class="headerlink" title="3. DCL (Data Control Language) — 数据权限控制"></a>3. DCL (Data Control Language) — 数据权限控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 授权</span><br><span class="line">GRANT privileges ON database.table TO &#x27;user&#x27;@&#x27;host&#x27;;</span><br><span class="line"></span><br><span class="line">-- 撤销权限</span><br><span class="line">REVOKE privileges ON database.table FROM &#x27;user&#x27;@&#x27;host&#x27;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-TCL-Transaction-Control-Language-—-事务控制"><a href="#4-TCL-Transaction-Control-Language-—-事务控制" class="headerlink" title="4. TCL (Transaction Control Language) — 事务控制"></a>4. TCL (Transaction Control Language) — 事务控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION; -- 或 BEGIN;</span><br><span class="line"></span><br><span class="line">-- 提交事务</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 回滚事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 设置保存点</span><br><span class="line">SAVEPOINT savepoint_name;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-EXPLAIN-查询分析-—-SQL-优化核心工具"><a href="#5-EXPLAIN-查询分析-—-SQL-优化核心工具" class="headerlink" title="5. EXPLAIN 查询分析 — SQL 优化核心工具"></a>5. EXPLAIN 查询分析 — SQL 优化核心工具</h2><p>用于分析 SELECT（或 DML）语句的执行计划，判断是否使用索引，以及优化查询性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM table_name WHERE condition;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-EXPLAIN-核心字段解析"><a href="#5-1-EXPLAIN-核心字段解析" class="headerlink" title="5.1 EXPLAIN 核心字段解析"></a>5.1 EXPLAIN 核心字段解析</h3><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>查询序列号，越大优先级越高；相同 id 按顺序执行。</td>
</tr>
<tr>
<td>select_type</td>
<td>查询类型：SIMPLE, PRIMARY, SUBQUERY, DEPENDENT SUBQUERY, UNION, DERIVED 等。</td>
</tr>
<tr>
<td>table</td>
<td>正在访问的表名。</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区信息（如果有分区表）。</td>
</tr>
<tr>
<td>type</td>
<td>连接类型&#x2F;访问方式，性能从好到差：system → const → eq_ref → ref → range → index → ALL。</td>
</tr>
<tr>
<td>possible_keys</td>
<td>查询可能使用的索引。</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引，NULL 表示未使用索引。</td>
</tr>
<tr>
<td>key_len</td>
<td>使用的索引长度（字节），越短越好。</td>
</tr>
<tr>
<td>ref</td>
<td>表示索引列与哪个列或常量进行比较。</td>
</tr>
<tr>
<td>rows</td>
<td>MySQL 估计要扫描的行数，越少越好。</td>
</tr>
<tr>
<td>filtered</td>
<td>WHERE 条件过滤行的百分比，越高越好。</td>
</tr>
<tr>
<td>Extra</td>
<td>额外信息，重要优化指标：- <code>Using filesort</code>：需要额外排序。- <code>Using temporary</code>：需要临时表处理。- <code>Using index</code>：使用覆盖索引，查询效率高。- <code>Using where</code>：使用 WHERE 条件过滤。- <code>Using index condition</code>：索引条件下推（ICP）。- <code>Using join buffer</code>：连接查询未用索引，使用缓存优化。</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-2-type-类型说明（访问方式）"><a href="#5-2-type-类型说明（访问方式）" class="headerlink" title="5.2 type 类型说明（访问方式）"></a>5.2 type 类型说明（访问方式）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">system  : 表中只有一行记录，性能极高</span><br><span class="line">const   : 通过主键或唯一索引查找，最多一行</span><br><span class="line">eq_ref   : 对前表每行组合读取一行，用于主键或唯一索引连接</span><br><span class="line">ref      : 非唯一索引等值查找，可能多行</span><br><span class="line">range    : 范围查找，使用索引</span><br><span class="line">index    : 全索引扫描，优于全表扫描</span><br><span class="line">ALL      : 全表扫描，性能最差</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-3-优化建议"><a href="#5-3-优化建议" class="headerlink" title="5.3 优化建议"></a>5.3 优化建议</h3><ol>
<li>尽量使用索引，避免 <code>ALL</code> 类型。</li>
<li>ORDER BY &#x2F; GROUP BY 尽量使用索引列，避免 <code>Using filesort</code> 或 <code>Using temporary</code>。</li>
<li>覆盖索引（<code>Using index</code>）能显著提高性能。</li>
<li>对复杂查询，使用 EXPLAIN 分析并调整索引或 SQL 结构。</li>
<li>对 JOIN 查询，保证连接字段有索引。</li>
</ol>
<hr>
<h2 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务 (Transaction)"></a>事务 (Transaction)</h2><p>事务是一组操作的集合，这些操作要么全部成功，要么全部失败。它具有四大特性 (ACID)。</p>
<ul>
<li><strong>ACID 特性：</strong><ol>
<li><strong>原子性 (Atomicity)</strong>: 事务是最小的执行单位，不可再分割。事务中的所有操作要么全部成功提交，要么全部失败回滚到事务开始前的状态。</li>
<li><strong>一致性 (Consistency)</strong>: 事务执行前后，数据库的完整性约束 (如主键唯一性、外键约束、检查约束、自定义业务规则 ) 没有被破坏，数据从一个一致性状态转换到另一个一致性状态。</li>
<li><strong>隔离性 (Isolation)</strong>: 并发执行的事务之间是隔离的，一个事务的执行不应影响其他事务的执行，反之亦然。事务的中间状态对其他事务是不可见的。</li>
<li><strong>持久性 (Durability)</strong>: 一旦事务提交，它对数据库中数据的改变就是永久性的，即使系统崩溃也不会丢失。</li>
</ol>
</li>
<li><strong>并发事务带来的问题：</strong><ol>
<li><strong>脏读 (Dirty Read)</strong>: 一个事务读取了另一个未提交事务的数据。如果这个未提交事务最终回滚，那么之前读取的数据就是“脏数据”。</li>
<li><strong>不可重复读 (Non-Repeatable Read)</strong>：一个事务在两次相同的查询中，读取到了不同的数据。通常是因为另一个已提交事务对这些数据进行了 UPDATE 或 DELETE 操作。</li>
<li><strong>幻读 (Phantom Read)</strong>：一个事务在两次相同的查询中，读取到了不同数量的行。通常是因为另一个已提交事务对数据进行了 INSERT 操作，导致第二次查询出现了之前没有的行。</li>
<li><strong>丢失更新 (Lost Update)</strong>：当两个事务都读取同一数据并进行修改时，其中一个事务的修改覆盖了另一个事务的修改，导致数据丢失。</li>
</ol>
</li>
<li><strong>事务隔离级别 (从低到高)：</strong><ol>
<li><strong>READ UNCOMMITTED (读未提交)：</strong><ul>
<li>最低的隔离级别。</li>
<li>允许脏读、不可重复读和幻读。</li>
<li>性能最高，但数据一致性最差。</li>
</ul>
</li>
<li><strong>READ COMMITTED (读已提交)：</strong><ul>
<li>解决了脏读问题。一个事务只能看到其他事务已经提交的数据。</li>
<li>仍然存在不可重复读和幻读问题。</li>
<li>多数数据库 (如 Oracle, SQL Server) 的默认隔离级别。</li>
</ul>
</li>
<li><strong>REPEATABLE READ (可重复读)：</strong><ul>
<li>MySQL (InnoDB 存储引擎) 的默认隔离级别。</li>
<li>解决了脏读和不可重复读问题。在同一个事务中，多次读取同一数据会得到相同的结果 (通过 MVCC - 多版本并发控制)。</li>
<li>仍然可能存在幻读问题 (但在 InnoDB 默认隔离级别下，通过间隙锁解决了大部分幻读问题)。</li>
</ul>
</li>
<li><strong>SERIALIZABLE (串行化):</strong><ul>
<li>最高的隔离级别。</li>
<li>完全解决了脏读、不可重复读和幻读问题。</li>
<li>强制事务串行执行，避免所有并发问题。</li>
<li>性能最低，因为它牺牲了并发性。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h1 id="索引-Index"><a href="#索引-Index" class="headerlink" title="索引 (Index)"></a>索引 (Index)</h1><p>索引是帮助 MySQL 高效获取数据的数据结构。它类似于书籍的目录，可以快速定位所需数据，而无需扫描整个表。</p>
<hr>
<h2 id="1-索引的优缺点"><a href="#1-索引的优缺点" class="headerlink" title="1. 索引的优缺点"></a>1. 索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>加快数据检索速度</strong>：通过索引可以直接定位到数据，避免全表扫描。</li>
<li><strong>减少 I&#x2F;O 次数</strong>：索引结构比数据表小，减少磁盘访问。</li>
<li><strong>优化分组和排序</strong>：在 <code>GROUP BY</code> 和 <code>ORDER BY</code> 中，可减少 CPU 消耗。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong>维护成本</strong>：数据增加、更新或删除时，索引也需要更新。</li>
<li><strong>占用存储空间</strong>：索引本身也需要占用磁盘。</li>
<li><strong>写入性能影响</strong>：虽然查询快，但对 <code>INSERT/UPDATE/DELETE</code> 有一定性能开销。</li>
</ul>
<hr>
<h2 id="2-索引底层实现-—-B-树"><a href="#2-索引底层实现-—-B-树" class="headerlink" title="2. 索引底层实现 — B+ 树"></a>2. 索引底层实现 — B+ 树</h2><h3 id="B-树特点"><a href="#B-树特点" class="headerlink" title="B+ 树特点"></a>B+ 树特点</h3><ul>
<li><strong>数据存储</strong>：所有数据都存储在叶子节点，非叶子节点仅存储键值用于导航。</li>
<li><strong>叶子节点链表</strong>：方便范围查询和顺序遍历。</li>
<li><strong>树层高低</strong>：非叶子节点不存储数据，一个节点可存储更多索引键，降低树高度，减少磁盘 I&#x2F;O。</li>
<li><strong>适合磁盘存储</strong>：节点大小匹配磁盘块大小，最大限度减少磁盘寻道次数。</li>
</ul>
<hr>
<h2 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3. 索引分类"></a>3. 索引分类</h2><h3 id="3-1-主键索引-Primary-Key-Index"><a href="#3-1-主键索引-Primary-Key-Index" class="headerlink" title="3.1 主键索引 (Primary Key Index)"></a>3.1 主键索引 (Primary Key Index)</h3><ul>
<li>特殊的唯一索引，一个表只能有一个主键。</li>
<li>不允许 <code>NULL</code> 值。</li>
<li>通常是 <strong>聚集索引</strong> (InnoDB 存储引擎)。</li>
</ul>
<h3 id="3-2-唯一索引-Unique-Index"><a href="#3-2-唯一索引-Unique-Index" class="headerlink" title="3.2 唯一索引 (Unique Index)"></a>3.2 唯一索引 (Unique Index)</h3><ul>
<li>列值必须唯一，但允许多个 <code>NULL</code> 值。</li>
<li>SQL 示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX idx_name ON table_name (column_name);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-普通索引-Normal-Index-Non-Unique-Index"><a href="#3-3-普通索引-Normal-Index-Non-Unique-Index" class="headerlink" title="3.3 普通索引 (Normal Index &#x2F; Non-Unique Index)"></a>3.3 普通索引 (Normal Index &#x2F; Non-Unique Index)</h3><ul>
<li>最基本索引，没有唯一性限制。</li>
<li>SQL 示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON table_name (column_name);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-全文索引-Fulltext-Index"><a href="#3-4-全文索引-Fulltext-Index" class="headerlink" title="3.4 全文索引 (Fulltext Index)"></a>3.4 全文索引 (Fulltext Index)</h3><ul>
<li>用于大文本字段的模糊搜索。</li>
<li>仅支持 MyISAM 和 InnoDB。</li>
<li>SQL 示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX idx_name ON table_name (column_name);</span><br></pre></td></tr></table></figure>

<h3 id="3-5-复合索引-Composite-Multi-Column-Index"><a href="#3-5-复合索引-Composite-Multi-Column-Index" class="headerlink" title="3.5 复合索引 (Composite &#x2F; Multi-Column Index)"></a>3.5 复合索引 (Composite &#x2F; Multi-Column Index)</h3><ul>
<li>在多列上创建的索引。</li>
<li><strong>最左前缀原则</strong>：<ul>
<li>查询条件使用复合索引的第一列，则整个索引可用。</li>
<li>仅使用非首列，则索引可能无法完全使用。</li>
</ul>
</li>
<li>SQL 示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON table_name (column1, column2, column3);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-聚集索引与非聚集索引"><a href="#4-聚集索引与非聚集索引" class="headerlink" title="4. 聚集索引与非聚集索引"></a>4. 聚集索引与非聚集索引</h2><h3 id="4-1-聚集索引-Clustered-Index"><a href="#4-1-聚集索引-Clustered-Index" class="headerlink" title="4.1 聚集索引 (Clustered Index)"></a>4.1 聚集索引 (Clustered Index)</h3><ul>
<li><strong>叶子节点存储完整数据行</strong>。</li>
<li>一个表只能有一个聚集索引（通常是主键）。</li>
<li>数据物理顺序与索引逻辑顺序一致。</li>
<li>查询效率高，无需回表。</li>
<li>写入影响：插入、更新、删除需要维护物理顺序。</li>
<li><strong>InnoDB 实现</strong>：<ul>
<li>主键索引即聚集索引。</li>
<li>若未定义主键，选择唯一非空索引作为聚集索引；若无，则创建隐藏 6 字节 <code>row_id</code> 作为聚集索引。</li>
</ul>
</li>
</ul>
<h3 id="4-2-非聚集索引-Non-Clustered-Index"><a href="#4-2-非聚集索引-Non-Clustered-Index" class="headerlink" title="4.2 非聚集索引 (Non-Clustered Index)"></a>4.2 非聚集索引 (Non-Clustered Index)</h3><ul>
<li><strong>叶子节点存储主键或指向数据行的指针</strong>。</li>
<li>表可有多个非聚集索引。</li>
<li>数据物理顺序与索引逻辑顺序无关。</li>
<li>查询需回表：若查询列不在索引中，需要通过索引找到主键，再通过聚集索引获取完整数据。</li>
<li><strong>InnoDB 实现</strong>：所有非主键索引都是非聚集索引。</li>
</ul>
<hr>
<h2 id="5-索引优化策略"><a href="#5-索引优化策略" class="headerlink" title="5. 索引优化策略"></a>5. 索引优化策略</h2><h3 id="5-1-创建索引的列选择"><a href="#5-1-创建索引的列选择" class="headerlink" title="5.1 创建索引的列选择"></a>5.1 创建索引的列选择</h3><ul>
<li><strong>常用列</strong>：<code>WHERE</code>、<code>JOIN</code>、<code>ORDER BY</code> 中频繁使用的列。</li>
<li><strong>高区分度列</strong>：唯一值多的列更适合建立索引。</li>
<li><strong>避免</strong>：<ul>
<li>小表或频繁更新表上的索引。</li>
<li>重复值多的列上建索引。</li>
</ul>
</li>
</ul>
<h3 id="5-2-遵循最左前缀原则"><a href="#5-2-遵循最左前缀原则" class="headerlink" title="5.2 遵循最左前缀原则"></a>5.2 遵循最左前缀原则</h3><ul>
<li>对复合索引 <code>(a, b, c)</code>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHERE a = 1                -&gt; 索引可用</span><br><span class="line">WHERE a = 1 AND b = 2      -&gt; 索引可用</span><br><span class="line">WHERE b = 2                 -&gt; 索引无法完全利用</span><br><span class="line">WHERE c = 3                 -&gt; 索引无法完全利用</span><br></pre></td></tr></table></figure>

<h3 id="5-3-避免索引失效"><a href="#5-3-避免索引失效" class="headerlink" title="5.3 避免索引失效"></a>5.3 避免索引失效</h3><ul>
<li><strong>函数或表达式</strong>：如 <code>WHERE YEAR(date_column) = 2023</code></li>
<li><strong>隐式类型转换</strong>：索引列类型不同于查询值类型</li>
<li><strong>OR 条件</strong>：除非两边都有索引，且优化器决定合并索引</li>
<li><strong>左模糊匹配</strong>：<code>LIKE &#39;%keyword&#39;</code></li>
<li><strong>不等&#x2F;非 IN</strong>：<code>!=</code> 或 <code>NOT IN</code></li>
</ul>
<h3 id="5-4-覆盖索引-Covering-Index"><a href="#5-4-覆盖索引-Covering-Index" class="headerlink" title="5.4 覆盖索引 (Covering Index)"></a>5.4 覆盖索引 (Covering Index)</h3><ul>
<li>查询所需列都在索引中，无需回表：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_in_index</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE indexed_column = value;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-防止回表"><a href="#5-5-防止回表" class="headerlink" title="5.5 防止回表"></a>5.5 防止回表</h3><ul>
<li>尽量让 SELECT 列被索引覆盖，或只查询主键。</li>
</ul>
<h3 id="5-6-定期维护索引"><a href="#5-6-定期维护索引" class="headerlink" title="5.6 定期维护索引"></a>5.6 定期维护索引</h3><ul>
<li>重建索引或优化碎片化索引，保持性能稳定。</li>
</ul>
<hr>
<hr>
<h2 id="一、B-树的结构特点"><a href="#一、B-树的结构特点" class="headerlink" title="一、B+树的结构特点"></a>一、B+树的结构特点</h2><ol>
<li><strong>多路平衡查找树</strong>：MySQL（InnoDB）使用的是 <strong>B+树索引</strong>，不同于二叉树，一个节点能存储大量 key。</li>
<li><strong>非叶子节点</strong>：只存储 <strong>索引键值 + 子节点指针</strong>，不存放真实数据。</li>
<li><strong>叶子节点</strong>：存放 <strong>完整的数据行（聚簇索引）</strong> 或 <strong>主键值（辅助索引）</strong>，并且通过 <strong>双向链表</strong> 相连，便于范围查询。</li>
<li><strong>有序性</strong>：索引键在节点内是有序存储的，适合二分查找。</li>
</ol>
<hr>
<h2 id="二、定位过程（精确查找某条记录）"><a href="#二、定位过程（精确查找某条记录）" class="headerlink" title="二、定位过程（精确查找某条记录）"></a>二、定位过程（精确查找某条记录）</h2><p>假设有一张表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT PRIMARY KEY,   -- 聚簇索引</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>索引类型：</p>
<ul>
<li><strong>聚簇索引（Clustered Index）</strong>：叶子节点存储整行记录。</li>
<li><strong>辅助索引（Secondary Index）</strong>：叶子节点存储主键值，再回表查询整行。</li>
</ul>
<hr>
<h3 id="1-精确查找（主键查找）"><a href="#1-精确查找（主键查找）" class="headerlink" title="1. 精确查找（主键查找）"></a>1. 精确查找（主键查找）</h3><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE id = 25;</span><br></pre></td></tr></table></figure>

<p>定位步骤：</p>
<ol>
<li>从 <strong>根节点</strong> 开始，根据 <code>id</code> 值进行二分查找，找到对应的子节点指针。</li>
<li>进入 <strong>中间节点</strong>，重复二分查找，继续向下。</li>
<li>进入 <strong>叶子节点</strong>，找到键值 &#x3D; 25 的位置。</li>
<li>因为是 <strong>聚簇索引</strong>，叶子节点存放了完整行记录，直接返回。</li>
</ol>
<hr>
<h3 id="2-辅助索引查找（非主键查找）"><a href="#2-辅助索引查找（非主键查找）" class="headerlink" title="2. 辅助索引查找（非主键查找）"></a>2. 辅助索引查找（非主键查找）</h3><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE name = &#x27;Tom&#x27;;</span><br></pre></td></tr></table></figure>

<p>定位步骤：</p>
<ol>
<li>进入 <strong>辅助索引 B+树</strong>，从根 → 中间节点 → 叶子节点，找到 <code>name = &#39;Tom&#39;</code> 对应的记录。</li>
<li>叶子节点存放的不是整行数据，而是 <strong>主键值（id）</strong>。</li>
<li>根据主键值，再回到 <strong>聚簇索引 B+树</strong> 中，走一次查找过程，定位到整行数据。</li>
</ol>
<p>这就是所谓的 <strong>回表</strong>。</p>
<hr>
<h2 id="三、为什么能“精确定位”"><a href="#三、为什么能“精确定位”" class="headerlink" title="三、为什么能“精确定位”"></a>三、为什么能“精确定位”</h2><ol>
<li><strong>有序存储</strong> → 节点内可以二分查找，快速缩小范围。</li>
<li><strong>树高较低</strong> → InnoDB 一般 3<del>4 层就能存下百万级数据，每次查找只需磁盘 I&#x2F;O 3</del>4 次。</li>
<li><strong>聚簇索引</strong> → 直接在叶子节点找到完整行，避免额外跳转。</li>
<li><strong>辅助索引 + 主键索引</strong> → 通过两次 B+树查找，依然能精确定位。</li>
</ol>
<hr>
<h2 id="四、类比理解"><a href="#四、类比理解" class="headerlink" title="四、类比理解"></a>四、类比理解</h2><p>B+树就像一个“图书馆目录”：</p>
<ul>
<li><strong>根节点</strong> &#x3D; 图书馆的“目录索引页”</li>
<li><strong>中间节点</strong> &#x3D; 分区目录</li>
<li><strong>叶子节点</strong> &#x3D; 书架（放书或者书的编号）</li>
<li><strong>聚簇索引</strong> &#x3D; 直接找到书本</li>
<li><strong>辅助索引</strong> &#x3D; 先找到书的编号，再去另一个书架找书</li>
</ul>
<hr>
<p>👉 总结一句：<br> <strong>MySQL 通过 B+树的有序性和分层查找机制，从根节点到叶子节点逐级定位，最终在叶子节点找到目标记录（主键索引直接拿数据，辅助索引还需回表）。</strong></p>
<p>要不要我帮你画一张 <strong>B+树精确查找的图解流程</strong>，形象化展示“查找某条记录”的路径？</p>
<ul>
<li><h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><img src="https://i-blog.csdnimg.cn/blog_migrate/bfe55c106fb1ceb9316542c424cecf9f.png" alt="图片"></li>
</ul>
<hr>
<h1 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h1><p>MySQL 支持多种存储引擎，每种存储引擎在事务支持、锁机制、索引类型、适用场景等方面有所不同。</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>特性</th>
<th>锁机制</th>
<th>事务支持</th>
<th>索引类型</th>
<th>崩溃恢复</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>InnoDB (默认)</strong></td>
<td>- 支持事务（ACID）- 支持行级锁- 支持外键约束- 支持崩溃恢复- 默认聚集索引- MVCC（多版本并发控制）</td>
<td>行级锁</td>
<td>支持</td>
<td>聚集索引（叶子节点存储数据行）</td>
<td>支持 redo log &#x2F; undo log</td>
<td>事务性应用、高并发读写、数据完整性要求高的场景（如电商、金融）</td>
</tr>
<tr>
<td><strong>MyISAM</strong></td>
<td>- 不支持事务- 不支持外键- 非聚集索引- SELECT COUNT(*) 快</td>
<td>表级锁</td>
<td>不支持</td>
<td>非聚集索引（叶子节点存储数据地址）</td>
<td>不支持</td>
<td>只读或读多写少、对事务性要求不高，需要频繁 COUNT(*) 的应用（如日志、数据仓库）</td>
</tr>
<tr>
<td><strong>Memory (HEAP)</strong></td>
<td>- 数据存储在内存中，速度快- 重启数据丢失</td>
<td>表级锁</td>
<td>不支持</td>
<td>哈希索引（默认，可用 BTREE）</td>
<td>不支持</td>
<td>临时表、缓存、快速计算</td>
</tr>
<tr>
<td><strong>Archive</strong></td>
<td>- 高度压缩，节省空间- 支持高速插入和查询- 不支持更新和删除</td>
<td>表级锁</td>
<td>不支持</td>
<td>非聚集索引</td>
<td>不支持</td>
<td>存储历史数据、不常访问的数据仓库</td>
</tr>
<tr>
<td><strong>CSV</strong></td>
<td>- 数据以 CSV 文件格式存储- 易于与其他应用交换</td>
<td>表级锁</td>
<td>不支持</td>
<td>无索引或简单索引</td>
<td>不支持</td>
<td>数据导入导出、交换数据文件</td>
</tr>
</tbody></table>
<hr>
<h2 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h2><ol>
<li><strong>InnoDB 逐渐成为默认引擎</strong>：MySQL 5.5 之后，InnoDB 取代 MyISAM，成为事务型应用首选。</li>
<li><strong>索引和锁机制区别</strong>：<ul>
<li>行级锁：并发性能高，锁粒度小。</li>
<li>表级锁：并发性能低，适合读多写少场景。</li>
</ul>
</li>
<li><strong>崩溃恢复</strong>：<ul>
<li>InnoDB 通过 <strong>redo log</strong> 和 <strong>undo log</strong> 保证数据持久性和事务回滚。</li>
<li>MyISAM 和 Memory 不支持事务或崩溃恢复。</li>
</ul>
</li>
<li><strong>存储优化选择</strong>：<ul>
<li>高并发、事务性应用 → <strong>InnoDB</strong></li>
<li>只读或日志分析 → <strong>MyISAM</strong></li>
<li>临时计算&#x2F;缓存 → <strong>Memory</strong></li>
<li>历史归档数据 → <strong>Archive</strong></li>
<li>数据交换 → <strong>CSV</strong></li>
</ul>
</li>
</ol>
<hr>
<h2 id="MVCC（多版本并发控制）："><a href="#MVCC（多版本并发控制）：" class="headerlink" title="MVCC（多版本并发控制）："></a>MVCC（多版本并发控制）：</h2><p>好的，我们来深入探讨一下 <strong>MVCC (Multi-Version Concurrency Control)</strong>，并分析一些常见的面试题。</p>
<hr>
<h3 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a><strong>什么是 MVCC？</strong></h3><p><strong>MVCC</strong>，即<strong>多版本并发控制</strong>，是一种在数据库中用于解决并发访问问题的方法。它不是通过加锁的方式来控制并发，而是通过<strong>为每个事务生成一个数据快照</strong>，让读操作在快照上进行。</p>
<p>你可以把它想象成一个“时光机”。当一个事务开始时，数据库会为它“拍一张照片”，也就是生成一个数据快照。这个事务的所有读操作都只会看到这个快照里的数据，而不会受到其他并发事务修改的影响。这样，读操作就不需要等待写锁释放，从而实现了<strong>读写分离</strong>，大大提高了并发性能。</p>
<p>简而言之，MVCC 的核心思想是：</p>
<ul>
<li><strong>读不加锁</strong>：读取数据时，直接从数据的历史版本中读取，不需要等待其他事务的写锁。</li>
<li><strong>写不阻塞读</strong>：写操作修改数据时，会创建一个新的版本，而旧版本依然保留，供其他读事务使用。</li>
</ul>
<hr>
<h3 id="MVCC-的实现原理"><a href="#MVCC-的实现原理" class="headerlink" title="MVCC 的实现原理"></a><strong>MVCC 的实现原理</strong></h3><p>MVCC 的实现通常依赖于以下几个核心要素：</p>
<ol>
<li><p>隐藏列（Hidden Columns）：</p>
<p>每个表都会有几个隐藏的列，用于记录版本信息：</p>
<ul>
<li><strong>DB_TRX_ID</strong>：事务 ID，记录最近一次修改数据的事务 ID。</li>
<li><strong>DB_ROLL_PTR</strong>：回滚指针，指向这条记录的上一个版本。</li>
<li><strong>DB_ROW_ID</strong>：行 ID，是插入新行时分配的隐藏 ID，当主键是字符串时，可能用于辅助索引。</li>
</ul>
</li>
<li><p>Undo Log (回滚日志)：</p>
<p>Undo Log 记录了数据在被修改之前的值。每次修改数据时，都会将修改前的数据版本记录在 Undo Log 中，并通过回滚指针 DB_ROLL_PTR 将新版本与旧版本连接起来，形成一个版本链。这样，通过版本链，我们就可以追溯到这条数据的历史版本。</p>
</li>
<li><p>Read View (读视图)：</p>
<p>Read View 是 MVCC 的核心，它是一个在事务启动时生成的、用来判断某个数据版本对当前事务是否可见的数据快照。它主要包含以下几个关键信息：</p>
<ul>
<li><code>m_ids</code>：在生成 <code>Read View</code> 时，当前系统中<strong>所有活跃事务</strong>的 ID 列表。</li>
<li><code>min_trx_id</code>：在生成 <code>Read View</code> 时，<code>m_ids</code> 中最小的事务 ID。</li>
<li><code>max_trx_id</code>：在生成 <code>Read View</code> 时，系统将要分配给下一个事务的 ID。</li>
<li><code>creator_trx_id</code>：创建 <code>Read View</code> 的事务 ID。</li>
</ul>
<p>当一个事务想要读取一条数据时，会根据 <code>Read View</code> 的规则来判断这条数据的**<code>DB_TRX_ID</code>**是否可见。</p>
<ul>
<li>如果 <code>DB_TRX_ID</code> 小于 <code>min_trx_id</code>，说明这个修改操作在当前事务启动前就已经提交了，数据<strong>可见</strong>。</li>
<li>如果 <code>DB_TRX_ID</code> 大于等于 <code>max_trx_id</code>，说明这个修改操作是在当前事务启动后才发生的，数据<strong>不可见</strong>。</li>
<li>如果 <code>DB_TRX_ID</code> 在 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，那么需要判断 <code>DB_TRX_ID</code> 是否在 <code>m_ids</code> 列表中。如果在，说明这个修改操作是和当前事务同时启动的，数据<strong>不可见</strong>；如果不在，说明这个修改操作在当前事务启动前就已经提交了，数据<strong>可见</strong>。</li>
</ul>
<p>如果当前版本不可见，事务就会通过回滚指针 <code>DB_ROLL_PTR</code> 沿着版本链找到上一版本，直到找到一个<strong>可见</strong>的版本。</p>
</li>
</ol>
<hr>
<h3 id="面试题分析"><a href="#面试题分析" class="headerlink" title="面试题分析"></a><strong>面试题分析</strong></h3><h4 id="1-什么是-MVCC？它解决了什么问题？"><a href="#1-什么是-MVCC？它解决了什么问题？" class="headerlink" title="1. 什么是 MVCC？它解决了什么问题？"></a><strong>1. 什么是 MVCC？它解决了什么问题？</strong></h4><p><strong>回答要点：</strong></p>
<ul>
<li><strong>概念</strong>：多版本并发控制，通过维护数据历史版本实现并发。</li>
<li><strong>解决问题</strong>：在数据库隔离级别为**读已提交（RC）<strong>和</strong>可重复读（RR）**时，实现了读写不冲突。它解决了 <strong>读写锁冲突</strong> 和 <strong>脏读</strong> 问题，但无法完全解决幻读。</li>
<li><strong>核心思想</strong>：读操作读取数据快照，写操作创建新版本。</li>
</ul>
<h4 id="2-MVCC-是如何实现可重复读（Repeatable-Read）的？"><a href="#2-MVCC-是如何实现可重复读（Repeatable-Read）的？" class="headerlink" title="2. MVCC 是如何实现可重复读（Repeatable Read）的？"></a><strong>2. MVCC 是如何实现可重复读（Repeatable Read）的？</strong></h4><p><strong>回答要点：</strong></p>
<ul>
<li><strong>核心</strong>：<code>Read View</code> 的创建时机。</li>
<li><strong>可重复读</strong>：事务在第一次读操作时创建 <code>Read View</code>，并且在<strong>整个事务的生命周期内都使用这个 Read View</strong>。这意味着无论事务中执行多少次读，看到的都是同一个数据快照，所以能保证多次读取结果一致。</li>
<li><strong>读已提交</strong>：相比之下，读已提交的隔离级别是<strong>每次执行读操作时都重新生成一个 Read View</strong>。因此，如果其他事务在两次读操作之间提交了修改，第二次读就能看到新数据，导致不可重复读。</li>
</ul>
<h4 id="3-MVCC-能解决幻读吗？"><a href="#3-MVCC-能解决幻读吗？" class="headerlink" title="3. MVCC 能解决幻读吗？"></a><strong>3. MVCC 能解决幻读吗？</strong></h4><p><strong>回答要点：</strong></p>
<ul>
<li><strong>部分解决，但不能完全解决。</strong></li>
<li><strong>幻读（Phantom Read）</strong>：当一个事务在两次查询之间，另一个事务插入了新的数据，导致第一次查询不存在的数据，第二次查询却出现了。</li>
<li><strong>MVCC 的作用</strong>：MVCC 可以防止<strong>更新幻读</strong>（即一个事务在两次查询之间，另一个事务更新了数据），因为它总是读取事务启动时的快照。</li>
<li><strong>无法解决</strong>：MVCC 无法完全解决<strong>插入幻读</strong>。例如，事务 A 两次查询 <code>WHERE id &gt; 10</code>，但在两次查询之间，事务 B 插入了一条 <code>id=11</code> 的记录并提交。虽然事务 A 的 <code>Read View</code> 看不到这条新记录，但如果事务 A 执行 <code>UPDATE ... WHERE id &gt; 10</code> 时，它会发现这条新记录并对其加锁，从而更新成功。这会打破可重复读的承诺。</li>
<li><strong>InnoDB 的解决方案</strong>：InnoDB 数据库在 <code>可重复读</code> 隔离级别下，除了 MVCC，还会结合**间隙锁（Gap Lock）**来彻底解决幻读问题。</li>
</ul>
<h4 id="4-Undo-Log-和-Redo-Log-有什么区别？"><a href="#4-Undo-Log-和-Redo-Log-有什么区别？" class="headerlink" title="4. Undo Log 和 Redo Log 有什么区别？"></a><strong>4. Undo Log 和 Redo Log 有什么区别？</strong></h4><p><strong>回答要点：</strong></p>
<ul>
<li><strong>Undo Log (回滚日志)</strong>：<ul>
<li><strong>作用</strong>：用于<strong>回滚事务</strong>和实现 <strong>MVCC</strong>。</li>
<li><strong>记录内容</strong>：记录的是<strong>数据修改前</strong>的版本。</li>
<li><strong>生命周期</strong>：在事务提交后，如果数据有其他事务在使用（用于 MVCC），<code>Undo Log</code> 依然保留；如果没有，<code>Undo Log</code> 会被清除。</li>
</ul>
</li>
<li><strong>Redo Log (重做日志)</strong>：<ul>
<li><strong>作用</strong>：用于保证事务的<strong>持久性</strong>。</li>
<li><strong>记录内容</strong>：记录的是<strong>数据修改后</strong>的日志，比如“某某页的某某偏移量改成了某某值”。</li>
<li><strong>生命周期</strong>：在数据同步到磁盘后，<code>Redo Log</code> 就会被清除。</li>
<li><strong>作用点</strong>：<code>Redo Log</code> 作用于<strong>崩溃恢复</strong>。当数据库发生宕机时，可以根据 <code>Redo Log</code> 将已提交但尚未写入磁盘的数据重新写入，以保证数据不丢失。</li>
</ul>
</li>
</ul>
<h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><p>MySQL的日志系统是其数据库管理系统(DBMS)中至关重要的组成部分，扮演着监控、审计、故障恢复和数据复制等多种关键角色。用户提到的错误日志、查询日志、慢查询日志、事务日志和二进制日志构成了MySQL日志体系的核心。下面将对这些主要日志进行详细的梳理和解析。</p>
<h2 id="1-错误日志-Error-Log"><a href="#1-错误日志-Error-Log" class="headerlink" title="1. 错误日志(Error Log)"></a>1. 错误日志(Error Log)</h2><p>错误日志是MySQL中最基础的日志之一，它记录了mysqld服务器启动、运行和关闭过程中遇到的所有严重错误和警告。</p>
<ul>
<li>主要内容：<ul>
<li>服务器启动和关闭的详细信息。</li>
<li>运行过程中发生的错误，例如表损坏、无法访问特定文件等。</li>
<li>事件调度器运行出错时的信息。</li>
<li>在主从复制架构中，从服务器上启动和关闭复制线程，连接主服务器时发生的错误等。</li>
</ul>
</li>
<li>作用：错误日志是诊断和解决MySQL服务器问题的首要工具。当数据库无法启动或运行异常时，应首先检查此日志。</li>
<li>配置：默认情况下，错误日志是开启的。其文件名通常为<hostname>.err，位于数据目录(datadir)下。可以通过在my.cnf或my.ini配置文件中设置log_error变量来指定其路径。</li>
</ul>
<h2 id="2-查询日志-Query-Log-通用查询日志-General-Query-Log"><a href="#2-查询日志-Query-Log-通用查询日志-General-Query-Log" class="headerlink" title="2. 查询日志(Query Log)&#x2F;通用查询日志(General Query Log)"></a>2. 查询日志(Query Log)&#x2F;通用查询日志(General Query Log)</h2><p>通用查询日志记录了MySQL服务器接收到的每一个客户端连接和执行的每一条SQL语句。</p>
<ul>
<li>主要内容：<ul>
<li>客户端的连接信息，包括连接时间、用户名和主机。</li>
<li>客户端发送给服务器的所有SQL语句，无论其是否正确执行。</li>
</ul>
</li>
<li>作用：该日志对于数据库的审计和问题排查非常有用，可以精确复现用户的操作序列。然而，由于它会记录所有操作，对系统性能会产生显著影响，并会迅速占用大量磁盘空间。因此，不建议在生产环境中长期开启。</li>
<li>配置：默认关闭。可以通过设置general_log为ON来启用，并使用general_log_file指定日志文件路径。</li>
</ul>
<h2 id="3-慢查询日志-Slow-Query-Log"><a href="#3-慢查询日志-Slow-Query-Log" class="headerlink" title="3. 慢查询日志(Slow Query Log)"></a>3. 慢查询日志(Slow Query Log)</h2><p>慢查询日志用于记录执行时间超过指定阈值的SQL查询语句，是数据库性能优化的关键工具。</p>
<ul>
<li>主要内容：<ul>
<li>执行时间超过long_query_time阈值的SQL语句。</li>
<li>查询执行时的相关信息，如执行时间、锁定时间、扫描的行数、返回的行数以及执行该查询的用户和主机。</li>
</ul>
</li>
<li>作用：通过分析慢查询日志，开发者和数据库管理员(DBA)可以定位到效率低下的SQL语句，并针对性地进行优化，例如添加索引、改写查询等。</li>
<li>配置：默认关闭。需在配置文件中设置slow_query_log为ON开启。long_query_time参数用于设定慢查询的时间阈值(单位：秒)，slow_query_log_file用于指定日志文件位置。log_queries_not_using_indexes参数还可以记录未使用索引的查询。</li>
</ul>
<h2 id="4-事务日志-Transaction-Log"><a href="#4-事务日志-Transaction-Log" class="headerlink" title="4. 事务日志(Transaction Log)"></a>4. 事务日志(Transaction Log)</h2><p>用户提到的”事务日志”在InnoDB存储引擎中，主要由两种日志构成：重做日志(Redo Log)和回滚日志(Undo Log)。它们共同保证了事务的ACID特性(原子性、一致性、隔离性、持久性)。</p>
<ul>
<li>重做日志(Redo Log):<ul>
<li>作用：保证事务的持久性。它记录了数据被修改后的物理变化。当事务提交后，即使数据尚未完全写入数据文件，只要Redo Log已经持久化，在数据库发生崩溃时，也可以通过重放Redo Log来恢复已提交的事务，确保数据不丢失。这种技术被称为预写日志(Write-Ahead Logging, WAL)。</li>
<li>特点：Redo Log是以循环写的方式记录在连续的物理文件中，大小固定。</li>
</ul>
</li>
<li>回滚日志(Undo Log):<ul>
<li>作用：保证事务的原子性和实现多版本并发控制(MVCC)。Undo Log记录的是数据被修改前的状态。当事务需要回滚时，可以通过Undo Log将数据恢复到修改之前的版本。同时，在读已提交(Read Committed)和可重复读(Repeatable Read)隔离级别下，当一个事务需要读取被另一个未提交事务修改的行时，会通过Undo Log读取该行之前的版本，从而实现非锁定读。</li>
<li>特点：Undo Log逻辑上记录了每个修改操作的逆操作。</li>
</ul>
</li>
</ul>
<h2 id="5-二进制日志-Binary-Log-Binlog"><a href="#5-二进制日志-Binary-Log-Binlog" class="headerlink" title="5. 二进制日志(Binary Log&#x2F;Binlog)"></a>5. 二进制日志(Binary Log&#x2F;Binlog)</h2><p>二进制日志是MySQL中功能最强大、用途最广泛的日志之一。它以二进制格式记录了所有修改数据库数据的操作(DML)以及数据定义语言(DDL)的操作，但不包括SELECT和SHOW等不修改数据的查询。</p>
<ul>
<li>主要内容：记录了导致数据发生更改的所有事件。根据格式不同，可以记录为SQL语句(STATEMENT格式)、行的变更(ROW格式)或两者的混合(MIXED格式)。</li>
<li>主要作用：<ul>
<li>数据恢复(Point-in-Time Recovery)：通过备份的数据文件和之后的二进制日志，可以将数据库恢复到过去的任意一个时间点。</li>
<li>主从复制(Replication)：在主从架构中，主服务器将二进制日志传送给从服务器，从服务器重放这些日志中的事件，从而实现与主服务器的数据同步。</li>
</ul>
</li>
<li>配置：默认情况下可能关闭，需要通过配置文件中的log_bin选项来启用。启用后，会生成一个索引文件(默认为<hostname>-bin.index)和一系列的二进制日志文件。</li>
</ul>
<h2 id="扩展：中继日志-Relay-Log"><a href="#扩展：中继日志-Relay-Log" class="headerlink" title="扩展：中继日志(Relay Log)"></a>扩展：中继日志(Relay Log)</h2><p>在主从复制环境中，还有一个重要的日志类型——中继日志。</p>
<ul>
<li>作用：从服务器的I&#x2F;O线程从主服务器获取二进制日志，并将其写入本地的中继日志中。然后，从服务器的SQL线程读取中继日志中的事件，并在从服务器上执行，以实现数据同步。</li>
<li>特点：中继日志的格式与二进制日志完全相同。它的存在使得从服务器的I&#x2F;O和SQL执行可以解耦，即使在网络不稳定的情况下，只要I&#x2F;O线程将日志拉到本地，SQL线程就可以持续执行。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>日志类型</th>
<th>主要作用</th>
<th>生产环境建议</th>
</tr>
</thead>
<tbody><tr>
<td>错误日志</td>
<td>记录服务器启停和运行错误</td>
<td>始终开启</td>
</tr>
<tr>
<td>查询日志</td>
<td>记录所有连接和SQL语句，用于审计</td>
<td>默认关闭，仅在调试时短期开启</td>
</tr>
<tr>
<td>慢查询日志</td>
<td>记录执行缓慢的SQL，用于性能优化</td>
<td>建议开启</td>
</tr>
<tr>
<td>事务日志</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- Redo Log</td>
<td>保证事务持久性，用于崩溃恢复</td>
<td>InnoDB引擎核心组件，始终开启</td>
</tr>
<tr>
<td>- Undo Log</td>
<td>保证事务原子性，支持MVCC</td>
<td>InnoDB引擎核心组件，始终开启</td>
</tr>
<tr>
<td>二进制日志</td>
<td>数据恢复、主从复制</td>
<td>强烈建议开启，尤其是需要数据恢复和复制的场景</td>
</tr>
<tr>
<td>中继日志</td>
<td>主从复制中，从库用于暂存主库的二进制日志</td>
<td>在从服务器上自动创建和管理</td>
</tr>
</tbody></table>
<h2 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h2><h2 id="第一部分：数据库锁系统"><a href="#第一部分：数据库锁系统" class="headerlink" title="第一部分：数据库锁系统"></a>第一部分：数据库锁系统</h2><h3 id="1-锁的分类体系"><a href="#1-锁的分类体系" class="headerlink" title="1. 锁的分类体系"></a>1. 锁的分类体系</h3><h4 id="1-1-按锁粒度的层次分类"><a href="#1-1-按锁粒度的层次分类" class="headerlink" title="1.1 按锁粒度的层次分类"></a>1.1 按锁粒度的层次分类</h4><p><strong>表级锁（Table-Level Lock）</strong> 表级锁是最粗粒度的锁机制，一次锁定整个表的所有数据。MyISAM存储引擎主要使用表级锁，其内部维护一个全局的表锁列表。当线程需要访问表时，首先检查表锁状态，如果表已被其他线程以不兼容模式锁定，则当前线程进入等待队列。表级锁的优势在于锁管理开销极小，只需要维护少量的锁对象；缺点是并发度极低，即使访问不同行的操作也会相互阻塞。</p>
<p><strong>页级锁（Page-Level Lock）</strong> 页级锁锁定数据页，是表级锁和行级锁的折中方案。BDB存储引擎使用页级锁，每个数据页通常包含多条记录。页级锁的实现需要在页头维护锁信息，包括锁模式、持有者信息等。这种锁粒度在空间局部性较好的应用中表现优秀，因为相关的数据通常存储在相邻的页面中。</p>
<p><strong>行级锁（Row-Level Lock）</strong> 行级锁是最细粒度的锁机制，InnoDB存储引擎的核心特性。行锁的实现依赖于索引结构，实际上锁定的是索引记录而不是数据行本身。当查询没有使用索引时，InnoDB会扫描整个表并对所有记录加锁，退化为类似表锁的行为。行级锁提供最高的并发度，但也带来最大的管理开销。</p>
<h4 id="1-2-按锁模式的功能分类"><a href="#1-2-按锁模式的功能分类" class="headerlink" title="1.2 按锁模式的功能分类"></a>1.2 按锁模式的功能分类</h4><p><strong>共享锁（Shared Lock, S锁）</strong> 共享锁允许多个事务同时读取同一资源，但阻止任何事务修改该资源。在InnoDB中，共享锁通过在锁对象的type_mode字段中设置LOCK_S标志位来标识。多个共享锁可以并存，这是通过锁兼容性矩阵来判断的。共享锁的获取相对简单，只需要检查是否存在冲突的排他锁。</p>
<p><strong>排他锁（Exclusive Lock, X锁）</strong> 排他锁提供独占访问，同一时间只能有一个事务持有资源的排他锁。排他锁与任何其他锁都不兼容，包括共享锁和其他排他锁。在InnoDB实现中，排他锁的获取需要等待所有现有的锁释放，这通过等待队列机制来实现。</p>
<p><strong>意向锁（Intention Lock）</strong> 意向锁是一种表级锁，用于表明事务在表的某些行上持有或即将请求某种类型的锁。意向共享锁（IS）表示事务意图在某些行上获取共享锁，意向排他锁（IX）表示事务意图在某些行上获取排他锁。意向锁的引入大大简化了表级操作的锁冲突检测，避免了遍历所有行锁的开销。</p>
<h4 id="1-3-按锁算法的实现分类"><a href="#1-3-按锁算法的实现分类" class="headerlink" title="1.3 按锁算法的实现分类"></a>1.3 按锁算法的实现分类</h4><p><strong>记录锁（Record Lock）</strong> 记录锁锁定索引中的一条具体记录，是最基本的行级锁形式。在InnoDB的实现中，记录锁通过在B+树的叶子节点记录上设置锁标记来实现。锁对象中的heap_no字段精确标识被锁定的记录在页面中的位置。记录锁只能防止其他事务修改或删除该记录，但不能防止在该记录前后插入新记录。</p>
<p><strong>间隙锁（Gap Lock）</strong> 间隙锁锁定索引记录之间的间隙，防止其他事务在该间隙中插入新记录。间隙锁的范围是开区间，不包含边界记录本身。InnoDB通过比较索引键值来确定间隙的边界，对于复合索引，间隙的比较需要考虑所有键值列的组合。间隙锁之间不冲突，多个事务可以同时持有相同间隙的间隙锁。</p>
<p><strong>临键锁（Next-Key Lock）</strong> 临键锁是记录锁和间隙锁的组合，锁定一个记录以及该记录前面的间隙。这是InnoDB在可重复读隔离级别下的默认锁算法。临键锁有效解决了幻读问题，因为它不仅锁定已存在的记录，还锁定了可能插入新记录的位置。临键锁的范围是左开右闭区间。</p>
<h3 id="2-InnoDB锁系统的深层实现"><a href="#2-InnoDB锁系统的深层实现" class="headerlink" title="2. InnoDB锁系统的深层实现"></a>2. InnoDB锁系统的深层实现</h3><h4 id="2-1-锁对象的数据结构设计"><a href="#2-1-锁对象的数据结构设计" class="headerlink" title="2.1 锁对象的数据结构设计"></a>2.1 锁对象的数据结构设计</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="type">trx_t</span>* trx;           <span class="comment">// 拥有该锁的事务</span></span><br><span class="line">    UT_LIST_NODE_T(<span class="type">lock_t</span>) trx_locks; <span class="comment">// 事务锁链表节点</span></span><br><span class="line">    <span class="type">dict_table_t</span>* tab_lock; <span class="comment">// 表锁信息</span></span><br><span class="line">    <span class="type">dict_index_t</span>* index;    <span class="comment">// 索引信息</span></span><br><span class="line">    <span class="type">hash_node_t</span> hash;       <span class="comment">// 哈希表节点</span></span><br><span class="line">    ulint type_mode;        <span class="comment">// 锁类型和模式</span></span><br><span class="line">    ulint n_bits;          <span class="comment">// 位图大小</span></span><br><span class="line">    ulint n_granted_locks; <span class="comment">// 已授予的锁数量</span></span><br><span class="line">    ulint n_waiting_locks; <span class="comment">// 等待的锁数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>锁哈希表的设计：</strong> InnoDB使用一个全局的锁哈希表来管理所有的锁对象，哈希函数基于space_id和page_no计算。每个哈希桶包含一个锁对象链表，相同页面的所有锁对象都链接在同一个桶中。这种设计支持快速的锁查找和冲突检测，时间复杂度接近O(1)。</p>
<p><strong>锁位图的精巧设计：</strong> 对于页面级别的锁管理，InnoDB使用位图来标识页面中哪些记录被锁定。每个记录对应位图中的一位，设置为1表示该记录被锁定。这种压缩表示法大大节省了内存空间，特别是在锁定大量记录时。位图操作使用高效的位运算指令，支持快速的锁状态查询和更新。</p>
<h4 id="2-2-死锁检测的高级算法"><a href="#2-2-死锁检测的高级算法" class="headerlink" title="2.2 死锁检测的高级算法"></a>2.2 死锁检测的高级算法</h4><p><strong>增量式死锁检测：</strong> InnoDB不是每次都重新构建整个等待图，而是采用增量式检测。当新的等待关系建立时，算法只检查从新等待者开始的路径是否形成环。这种优化大大减少了检测的计算开销，特别是在高并发场景下效果显著。</p>
<p><strong>死锁检测的优先级调度：</strong> 死锁检测器运行在独立的后台线程中，具有较高的调度优先级。检测频率根据系统负载动态调整：在高并发时增加检测频率，在低负载时降低频率以节省CPU资源。检测器还会维护统计信息，包括死锁发生频率、平均解决时间等，用于系统调优。</p>
<p><strong>复杂死锁场景的处理：</strong> 实际生产环境中可能出现涉及多个资源类型的复杂死锁，比如同时涉及行锁、表锁、和外键约束锁的死锁。InnoDB的死锁检测器需要构建一个多层次的等待图，包含不同类型的资源节点和等待边。解决这类死锁时，需要考虑不同锁类型的回滚代价。</p>
<h4 id="2-3-MVCC与锁的深度集成"><a href="#2-3-MVCC与锁的深度集成" class="headerlink" title="2.3 MVCC与锁的深度集成"></a>2.3 MVCC与锁的深度集成</h4><p><strong>ReadView的内部结构：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReadView</span> &#123;</span></span><br><span class="line">    <span class="type">trx_id_t</span> low_limit_id;    <span class="comment">// 生成ReadView时的下一个事务ID</span></span><br><span class="line">    <span class="type">trx_id_t</span> up_limit_id;     <span class="comment">// 生成ReadView时最小的活跃事务ID</span></span><br><span class="line">    <span class="type">trx_id_t</span> creator_trx_id;  <span class="comment">// 创建ReadView的事务ID</span></span><br><span class="line">    <span class="type">trx_ids_t</span> m_ids;          <span class="comment">// 生成ReadView时的活跃事务ID列表</span></span><br><span class="line">    m_low_limit_no;           <span class="comment">// 最大的事务编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>版本可见性的判断算法：</strong> 当事务读取记录时，需要判断记录的某个版本是否对当前事务可见。判断逻辑基于记录的DB_TRX_ID字段和ReadView的信息：如果DB_TRX_ID小于up_limit_id，则该版本对所有事务可见；如果DB_TRX_ID大于等于low_limit_id，则该版本对当前事务不可见；如果DB_TRX_ID在两者之间，则需要检查是否在活跃事务列表中。</p>
<p><strong>undo log的链式结构：</strong> 每个事务的undo log形成一个链式结构，记录了该事务的所有修改操作。undo log不仅用于事务回滚，还用于MVCC的版本构建。当需要构建某个历史版本时，InnoDB会从当前版本开始，沿着undo log链向前回溯，逐步应用逆向操作直到达到目标版本。</p>
<h3 id="3-数据库锁的性能优化策略"><a href="#3-数据库锁的性能优化策略" class="headerlink" title="3. 数据库锁的性能优化策略"></a>3. 数据库锁的性能优化策略</h3><h4 id="3-1-锁等待的自适应策略"><a href="#3-1-锁等待的自适应策略" class="headerlink" title="3.1 锁等待的自适应策略"></a>3.1 锁等待的自适应策略</h4><p><strong>等待时间的动态调整：</strong> InnoDB实现了自适应的锁等待策略，根据系统负载和锁竞争情况动态调整等待超时时间。在低负载时延长等待时间以减少不必要的回滚，在高负载时缩短等待时间以快速释放资源。这种策略通过维护系统级的统计信息来实现，包括平均锁持有时间、锁竞争频率等。</p>
<p><strong>等待队列的优先级管理：</strong> 对于同一资源的多个等待者，InnoDB可以根据事务的重要性、等待时间、资源消耗等因素进行优先级排序。高优先级的事务可以优先获得锁，这对于关键业务操作特别重要。优先级的计算考虑多个维度，包括事务的年龄、修改的数据量、是否为只读事务等。</p>
<h4 id="3-2-索引设计对锁性能的影响"><a href="#3-2-索引设计对锁性能的影响" class="headerlink" title="3.2 索引设计对锁性能的影响"></a>3.2 索引设计对锁性能的影响</h4><p><strong>覆盖索引与锁范围优化：</strong> 当查询能够通过覆盖索引获取所有需要的数据时，InnoDB只需要在二级索引上加锁，而不需要回表访问聚簇索引。这大大减少了锁的数量和范围，提高了并发性能。覆盖索引的设计需要仔细分析查询模式，将经常一起访问的列组合成复合索引。</p>
<p><strong>索引前缀长度对锁粒度的影响：</strong> 对于字符串类型的索引，前缀长度的选择直接影响锁的粒度。较短的前缀可能导致多个不同的值映射到相同的索引前缀，从而扩大锁的范围；较长的前缀提供更精确的锁定，但增加了索引的存储开销。最优前缀长度需要在锁粒度和存储效率之间平衡。</p>
<h4 id="3-3-事务设计对锁性能的优化"><a href="#3-3-事务设计对锁性能的优化" class="headerlink" title="3.3 事务设计对锁性能的优化"></a>3.3 事务设计对锁性能的优化</h4><p><strong>事务边界的精细控制：</strong> 事务边界的设计直接影响锁的持有时间。长事务会长时间持有锁，阻塞其他事务的执行。优化策略包括：将大事务拆分为多个小事务，减少每个事务的锁持有时间；将只读操作和写操作分离，只读操作使用快照读避免加锁；在事务中优先执行可能失败的操作，减少无效锁持有。</p>
<p><strong>批量操作的锁优化：</strong> 对于批量插入、更新、删除操作，可以采用特殊的锁策略。比如批量插入时可以使用INSERT … ON DUPLICATE KEY UPDATE语法，减少锁冲突；批量更新时可以按照索引顺序进行，避免死锁；批量删除时可以分批进行，避免长时间持有大量锁。</p>
<h2 id="行锁（Row-Lock）"><a href="#行锁（Row-Lock）" class="headerlink" title="行锁（Row Lock）"></a>行锁（Row Lock）</h2><h2 id="InnoDB的行锁实现"><a href="#InnoDB的行锁实现" class="headerlink" title="InnoDB的行锁实现"></a>InnoDB的行锁实现</h2><p>InnoDB是MySQL中支持行锁的主要存储引擎：<br>实现原理：</p>
<ol>
<li>当事务需要锁定某行时，InnoDB会在该行对应的索引记录上加锁</li>
<li>如果没有索引，会锁定整个表（实际是锁定所有行）</li>
<li>锁信息存储在内存中的哈希表结构中</li>
</ol>
<h2 id="表锁（Table-Lock）"><a href="#表锁（Table-Lock）" class="headerlink" title="表锁（Table Lock）"></a>表锁（Table Lock）</h2><h2 id="MyISAM的表锁实现"><a href="#MyISAM的表锁实现" class="headerlink" title="MyISAM的表锁实现"></a>MyISAM的表锁实现</h2><p>MyISAM只支持表级锁</p>
<ol>
<li>维护一个全局的表锁队列</li>
<li>写锁具有更高优先级</li>
<li>锁信息存储在服务器层面</li>
</ol>
<h1 id="Java-核心技术"><a href="#Java-核心技术" class="headerlink" title="Java 核心技术"></a>Java 核心技术</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><hr>
<h3 id="八个基本数据类型（Primitive-Data-Types）"><a href="#八个基本数据类型（Primitive-Data-Types）" class="headerlink" title="八个基本数据类型（Primitive Data Types）"></a><strong>八个基本数据类型（Primitive Data Types）</strong></h3><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a><strong>1. 整型</strong></h4><p>整型用于存储不带小数的整数。Java 提供了四种整型，它们的区别在于所占内存空间的大小，从而影响可存储的数值范围。</p>
<ul>
<li><strong>byte</strong><ul>
<li>大小：1 字节（8 位）</li>
<li>范围：−128 到 127</li>
<li>用途：主要用于节省内存，尤其是在处理大量数据时，例如在文件或网络传输中。</li>
</ul>
</li>
<li><strong>short</strong><ul>
<li>大小：2 字节（16 位）</li>
<li>范围：−32768 到 32767</li>
<li>用途：同样用于节省内存，比 <code>byte</code> 的范围更大。</li>
</ul>
</li>
<li><strong>int</strong><ul>
<li>大小：4 字节（32 位）</li>
<li>范围：约 −2.1×109 到 2.1×109</li>
<li>用途：这是<strong>最常用</strong>的整型，通常用来表示普通的整数。</li>
</ul>
</li>
<li><strong>long</strong><ul>
<li>大小：8 字节（64 位）</li>
<li>范围：约 −9.2×1018 到 9.2×1018</li>
<li>用途：当 <code>int</code> 类型的范围不足以存储一个大数时使用，例如处理时间戳、文件大小等。在数值后面需要加上 <code>L</code> 或 <code>l</code> 来表示，例如 <code>long myLong = 100L;</code>。</li>
</ul>
</li>
</ul>
<h4 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2. 浮点型"></a><strong>2. 浮点型</strong></h4><p>浮点型用于存储带有小数点的数值。</p>
<ul>
<li><strong>float</strong><ul>
<li>大小：4 字节（32 位）</li>
<li>用途：单精度浮点数，有效位数为 6-7 位。在数值后面需要加上 <code>F</code> 或 <code>f</code> 来表示，例如 <code>float myFloat = 3.14f;</code>。</li>
</ul>
</li>
<li><strong>double</strong><ul>
<li>大小：8 字节（64 位）</li>
<li>用途：双精度浮点数，有效位数为 15-16 位。这是<strong>最常用</strong>的浮点型，Java 默认的浮点数类型就是 <code>double</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：浮点数存在精度问题，不适合用于精确的金融计算。如果需要精确计算，应使用 <code>java.math.BigDecimal</code> 类。</p>
</blockquote>
<h4 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3. 字符型"></a><strong>3. 字符型</strong></h4><ul>
<li><strong>char</strong><ul>
<li>大小：2 字节（16 位）</li>
<li>用途：存储单个字符。在 Java 中，<code>char</code> 采用 Unicode 编码，可以表示包括中文在内的所有字符。它可以用单引号 <code>&#39;</code> 括起来，例如 <code>char myChar = &#39;A&#39;;</code>。</li>
</ul>
</li>
</ul>
<h4 id="4-布尔型"><a href="#4-布尔型" class="headerlink" title="4. 布尔型"></a><strong>4. 布尔型</strong></h4><ul>
<li><strong>boolean</strong><ul>
<li>大小：在内存中通常被视为 1 位，但在数组中会占用 1 字节。</li>
<li>用途：用于存储 <code>true</code> 或 <code>false</code>，表示逻辑值。</li>
</ul>
</li>
</ul>
<p><strong><img src="C:\Users\19501\AppData\Local\Temp\1755509694028.png" alt="1755509694028"></strong></p>
<p><img src="C:\Users\19501\AppData\Local\Temp\1755509855359.png" alt="1755509855359"></p>
<h3 id="自动拆装箱的本质"><a href="#自动拆装箱的本质" class="headerlink" title="自动拆装箱的本质"></a>自动拆装箱的本质</h3><hr>
<p><strong>自动拆装箱</strong>是 Java 编译器在编译时期，根据代码的语法，<strong>自动</strong>将基本数据类型和其对应的包装类型之间进行转换的一种机制。这在 Java 5 之后被引入，大大简化了代码，让开发者可以像操作基本类型一样操作包装类型。</p>
<ul>
<li><strong>装箱（Boxing）</strong>：将基本数据类型（如 <code>int</code>）转换为对应的包装类型（<code>Integer</code>）。</li>
<li><strong>拆箱（Unboxing）</strong>：将包装类型（<code>Integer</code>）转换为对应的基本数据类型（<code>int</code>）。</li>
</ul>
<h3 id="自动拆装箱的底层原理"><a href="#自动拆装箱的底层原理" class="headerlink" title="自动拆装箱的底层原理"></a>自动拆装箱的底层原理</h3><hr>
<p>这并非 JVM 的特性，而是<strong>编译器</strong>的“障眼法”。当你在 Java 代码中使用自动拆装箱时，编译器会在你看不见的地方，自动插入对应的 <code>valueOf()</code> 和 <code>xxxValue()</code> 方法。</p>
<h4 id="1-自动装箱的原理"><a href="#1-自动装箱的原理" class="headerlink" title="1. 自动装箱的原理"></a>1. 自动装箱的原理</h4><p>当你写下 <code>Integer a = 100;</code> 这样的代码时，编译器会将其自动转换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这就是自动装箱的本质。它调用了包装类的静态方法 <strong>valueOf()</strong>。</p>
<p><strong>Integer.valueOf() 的特殊之处</strong>：</p>
<p>为了节省内存并提高性能，<code>Integer</code> 类内部维护了一个 <strong>缓存</strong>。这个缓存的范围通常是 <strong>-128 到 127</strong>。</p>
<p>当 <code>valueOf()</code> 方法传入的值在这个范围内时，它会直接从缓存中返回对应的 <code>Integer</code> 对象，而不是创建一个新的对象。</p>
<p>所以，当你执行以下代码时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);</span><br></pre></td></tr></table></figure>

<p>结果是 <code>true</code>，因为 <code>a</code> 和 <code>b</code> 都指向了缓存中的同一个对象。</p>
<p>但如果值超出这个范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(c == d);</span><br></pre></td></tr></table></figure>

<p>结果就是 <code>false</code>，因为每次都会创建新的 <code>Integer</code> 对象。这个缓存优化机制也存在于 <code>Byte</code>, <code>Short</code>, <code>Long</code> 和 <code>Character</code> 类型中。</p>
<h4 id="2-自动拆箱的原理"><a href="#2-自动拆箱的原理" class="headerlink" title="2. 自动拆箱的原理"></a>2. 自动拆箱的原理</h4><p>当你写下 <code>int i = a;</code> 这样的代码（其中 <code>a</code> 是一个 <code>Integer</code> 对象）时，编译器会将其自动转换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.intValue();</span><br></pre></td></tr></table></figure>

<p>这就是自动拆箱的本质。它调用了包装类的实例方法 <strong>xxxValue()</strong>（如 <code>intValue()</code>, <code>doubleValue()</code> 等）。</p>
<hr>
<h3 id="注意事项与潜在问题"><a href="#注意事项与潜在问题" class="headerlink" title="注意事项与潜在问题"></a>注意事项与潜在问题</h3><p>虽然自动拆装箱让代码更简洁，但如果不了解其原理，可能会引发一些问题：</p>
<ul>
<li><p><strong>NullPointerException</strong>：如果一个包装类型为 <code>null</code>，在进行自动拆箱时，会调用 <code>null</code> 对象的 <code>intValue()</code> 方法，从而抛出 <code>NullPointerException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; <span class="comment">// 这里会抛出 NullPointerException</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能问题</strong>：在循环中频繁地进行自动装箱和拆箱，会不断地创建和销毁对象，这会增加垃圾回收（GC）的负担，影响程序性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 糟糕的写法</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++) &#123;</span><br><span class="line">    sum += k; <span class="comment">// 每次循环都会进行一次拆箱和一次装箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该使用基本数据类型来避免这种开销：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更好的写法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++) &#123;</span><br><span class="line">    sum += k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>好的，我们来详细解析一下静态变量。</p>
<h3 id="什么是静态变量？"><a href="#什么是静态变量？" class="headerlink" title="什么是静态变量？"></a>什么是静态变量？</h3><p>在 Java 中，静态变量（Static Variable），也称为类变量（Class Variable），是使用 <strong>static 关键字</strong> 修饰的变量。它属于 <strong>类</strong>，而不是类的任何一个 <strong>实例对象</strong>。</p>
<p>这意味着，不管你创建了多少个类的对象，静态变量在内存中都只有<strong>一份</strong>，并且这唯一的一份数据被该类的所有对象共享。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">company</span> <span class="operator">=</span> <span class="string">&quot;Google&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>name</code> 是一个<strong>实例变量</strong>。每个 <code>User</code> 对象都有自己独立的 <code>name</code> 属性，<code>user1</code> 的 <code>name</code> 和 <code>user2</code> 的 <code>name</code> 互不影响。</li>
<li><code>company</code> 是一个<strong>静态变量</strong>。无论你创建多少个 <code>User</code> 对象，它们共享同一个 <code>company</code> 变量。如果你修改了 <code>company</code> 的值，所有 <code>User</code> 对象的 <code>company</code> 属性都会跟着改变。</li>
</ul>
<hr>
<h3 id="静态变量的内存分配与生命周期"><a href="#静态变量的内存分配与生命周期" class="headerlink" title="静态变量的内存分配与生命周期"></a>静态变量的内存分配与生命周期</h3><ul>
<li><strong>内存分配</strong>：静态变量在类加载时，被分配到 <strong>方法区（Method Area）</strong> 的 <strong>静态区</strong> 中。这与实例变量不同，实例变量是在创建对象时，随着对象一起分配在 <strong>堆（Heap）</strong> 中。</li>
<li><strong>生命周期</strong>：静态变量的生命周期与类的生命周期相同。当类被加载时，静态变量被创建；当类被卸载时，静态变量才会被销毁。</li>
</ul>
<p>因为它的生命周期贯穿整个程序运行过程，所以也常常被称为“全局变量”。</p>
<hr>
<h3 id="如何访问静态变量？"><a href="#如何访问静态变量？" class="headerlink" title="如何访问静态变量？"></a>如何访问静态变量？</h3><p>访问静态变量有两种方式，但推荐使用第一种，因为它更符合静态变量“属于类”的特性。</p>
<ol>
<li><p>通过类名访问（推荐）</p>
<p>这是最常见、最规范的访问方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(User.company); <span class="comment">// 输出: Google</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过对象实例访问（不推荐）</p>
<p>虽然可以通过对象实例来访问静态变量，但编译器会发出警告，因为它可能会造成混淆，让人误以为静态变量是实例特有的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">System.out.println(user1.company); <span class="comment">// 输出: Google</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="静态变量的应用场景"><a href="#静态变量的应用场景" class="headerlink" title="静态变量的应用场景"></a>静态变量的应用场景</h3><p>静态变量因其“全局唯一”的特性，非常适合以下场景：</p>
<ol>
<li><p><strong>计数器</strong>：需要统计某个类被创建了多少次，可以使用一个静态变量作为计数器。每次创建对象时，就在构造函数中对该静态变量进行自增操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>共享配置</strong>：当某些数据是所有对象共有的，比如公司名称、项目名称、数据库连接池等，可以将它们定义为静态变量，方便所有对象共享和访问。</p>
</li>
<li><p><strong>常量</strong>：定义程序中不会改变的常量，通常结合 <code>final</code> 关键字一起使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVER_URL</span> <span class="operator">=</span> <span class="string">&quot;http://api.example.com&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样定义的常量可以在整个程序中被安全地访问。</p>
</li>
</ol>
<hr>
<h3 id="静态变量的缺点与注意事项"><a href="#静态变量的缺点与注意事项" class="headerlink" title="静态变量的缺点与注意事项"></a>静态变量的缺点与注意事项</h3><ul>
<li><strong>线程安全问题</strong>：由于静态变量是所有线程共享的，当多个线程同时修改它时，可能会发生数据不一致的问题。因此，在使用静态变量时，需要特别注意<strong>线程安全</strong>，可以考虑使用同步锁或原子类（如 <code>AtomicInteger</code>）来保证并发安全。</li>
<li><strong>过度使用问题</strong>：滥用静态变量可能会导致程序耦合度过高，不利于单元测试和代码维护。因为静态变量无法通过依赖注入进行替换，测试时难以模拟或隔离其状态。</li>
</ul>
<p><code>new</code> 关键字在 Java 中是用来<strong>创建对象实例</strong>的。当你在代码中使用 <code>new</code> 关键字时，它会执行以下三个关键步骤：</p>
<h3 id="1-分配内存"><a href="#1-分配内存" class="headerlink" title="1. 分配内存"></a>1. 分配内存</h3><p><code>new</code> 关键字会计算新创建对象所需的内存大小，并在 <strong>堆（Heap）</strong> 上为这个对象分配一块内存空间。这块内存包含了所有实例变量，以及指向该类信息的指针（例如，该类的<strong>方法区</strong>中的类元信息）。</p>
<h3 id="2-初始化实例变量"><a href="#2-初始化实例变量" class="headerlink" title="2. 初始化实例变量"></a>2. 初始化实例变量</h3><p>内存分配完成后，Java 会对实例变量进行初始化。</p>
<ul>
<li>如果在定义时给变量赋了初始值，那么它们会按照代码中的值进行初始化。</li>
<li>如果没有明确赋值，那么它们会被赋予默认值：<code>int</code> 为 0，<code>boolean</code> 为 <code>false</code>，引用类型为 <code>null</code> 等。</li>
</ul>
<h3 id="3-调用构造方法"><a href="#3-调用构造方法" class="headerlink" title="3. 调用构造方法"></a>3. 调用构造方法</h3><p>初始化实例变量之后，<code>new</code> 关键字会调用类的<strong>构造方法</strong>。构造方法的主要作用是完成对象的最终初始化工作，例如为实例变量赋上更具体的值。</p>
<hr>
<h3 id="new-关键字与构造方法的关系"><a href="#new-关键字与构造方法的关系" class="headerlink" title="new 关键字与构造方法的关系"></a><code>new</code> 关键字与构造方法的关系</h3><p>很多人会把 <code>new</code> 关键字和构造方法混为一谈，但它们是两个不同的概念。</p>
<ul>
<li><strong>new 关键字</strong> 是一个<strong>操作符</strong>，负责<strong>创建对象</strong>并<strong>分配内存</strong>。</li>
<li><strong>构造方法</strong> 是一个<strong>特殊方法</strong>，负责<strong>初始化对象</strong>。</li>
</ul>
<p>你可以把它们想象成这样：</p>
<ul>
<li><code>new</code> 就像是工厂的流水线，负责制造一个空壳产品（对象）。</li>
<li>构造方法就像是流水线上的工人，负责给这个产品填充内容（初始化）。</li>
</ul>
<p><code>new</code> 关键字的作用是<strong>实例化</strong>，而构造方法的作用是<strong>初始化</strong>。只有通过 <code>new</code> 关键字，你才能调用构造方法来创建一个新的对象。</p>
<h3 id="new-关键字的局限性"><a href="#new-关键字的局限性" class="headerlink" title="new 关键字的局限性"></a><code>new</code> 关键字的局限性</h3><p>虽然 <code>new</code> 是最常见的对象创建方式，但它也有一些局限性：</p>
<ul>
<li><strong>强耦合</strong>：直接使用 <code>new</code> 会在代码中创建对具体类的依赖，不利于代码解耦和单元测试。</li>
<li><strong>无法灵活创建</strong>：你无法通过 <code>new</code> 关键字来动态地决定创建哪个类的实例，也无法在创建对象时进行一些额外的逻辑处理。</li>
</ul>
<p>因此，在很多设计模式和框架中，会使用其他方式来代替 <code>new</code>，比如：</p>
<ul>
<li><strong>反射</strong>：通过 <code>Class.forName().newInstance()</code> 来创建对象。</li>
<li><strong>工厂模式</strong>：通过工厂方法或抽象工厂来创建对象。</li>
<li><strong>依赖注入（DI）框架</strong>：如 Spring 框架，通过配置文件或注解自动创建和管理对象。</li>
</ul>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ul>
<li><pre><code class="language-java"> /**
  * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
  */
 public final native Class&lt;?&gt; getClass()
 /**
  * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
  */
 public native int hashCode()
 /**
  * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
  */
 public boolean equals(Object obj)
 /**
  * native 方法，用于创建并返回当前对象的一份拷贝。
  */
 protected native Object clone() throws CloneNotSupportedException
 /**
  * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
  */
 public String toString()
 /**
  * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
  */
 public final native void notify()
 /**
  * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
  */
 public final native void notifyAll()
 /**
  * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
  */
 public final native void wait(long timeout) throws InterruptedException
 /**
  * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。
  */
 public final void wait(long timeout, int nanos) throws InterruptedException
 /**
  * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
  */
 public final void wait() throws InterruptedException
 /**
  * 实例被垃圾回收器回收的时候触发的操作
  */
 protected void finalize() throws Throwable &#123; &#125;
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    ------</span><br><span class="line"></span><br><span class="line">    ## `Object` 类的所有方法</span><br><span class="line"></span><br><span class="line">    #### 1. `public final native Class&lt;?&gt; getClass()`</span><br><span class="line"></span><br><span class="line">    返回当前正在运行的对象的 **Class** 对象。这个方法是 **final** 的，这意味着你不能重写它。它通常用于反射（Reflection），让你在运行时获取对象的类型信息。</span><br><span class="line"></span><br><span class="line">    #### 2. `public native int hashCode()`</span><br><span class="line"></span><br><span class="line">    返回对象的 **哈希码** 值。这个哈希值通常用于基于哈希的集合，如 `HashMap`、`HashSet` 和 `HashTable`。**hashCode() 和 equals() 必须保持一致**：如果两个对象 `equals()` 返回 `true`，那么它们的 `hashCode()` 也必须相等。</span><br><span class="line"></span><br><span class="line">    #### 3. `public boolean equals(Object obj)`</span><br><span class="line"></span><br><span class="line">    比较两个对象是否相等。**Object** 类的默认实现是比较两个对象的**内存地址**。通常情况下，为了比较对象的内容，你需要根据业务逻辑**重写**这个方法。</span><br><span class="line"></span><br><span class="line">    #### 4. `protected native Object clone() throws CloneNotSupportedException`</span><br><span class="line"></span><br><span class="line">    创建并返回当前对象的**浅拷贝**。要使用 `clone()` 方法，你的类必须实现**`Cloneable`**接口，否则会抛出 `CloneNotSupportedException` 异常。</span><br><span class="line"></span><br><span class="line">    #### 5. `public String toString()`</span><br><span class="line"></span><br><span class="line">    返回对象的字符串表示。默认返回 `“类名@对象的哈希码的无符号十六进制表示”`。为了提供有意义的字符串描述，通常需要**重写**这个方法。</span><br><span class="line"></span><br><span class="line">    #### 6. `public final native void notify()`</span><br><span class="line"></span><br><span class="line">    唤醒在此对象监视器（monitor）上等待的**一个**线程。这个方法必须在 `synchronized` 代码块中调用，否则会抛出 `IllegalMonitorStateException`。</span><br><span class="line"></span><br><span class="line">    #### 7. `public final native void notifyAll()`</span><br><span class="line"></span><br><span class="line">    唤醒在此对象监视器上等待的**所有**线程。与 `notify()` 一样，它也必须在 `synchronized` 代码块中调用。</span><br><span class="line"></span><br><span class="line">    #### 8. `public final native void wait(long timeout) throws InterruptedException`</span><br><span class="line"></span><br><span class="line">    让当前线程进入等待状态，并释放它所持有的锁，直到其他线程调用 `notify()` 或 `notifyAll()`，或者等待时间超时。</span><br><span class="line"></span><br><span class="line">    #### 9. `public final void wait() throws InterruptedException`</span><br><span class="line"></span><br><span class="line">    与 `wait(long timeout)` 类似，但它会**无限期**地等待，直到被唤醒。</span><br><span class="line"></span><br><span class="line">    #### 10. `public final void wait(long timeout, int nanos) throws InterruptedException`</span><br><span class="line"></span><br><span class="line">    更精确的 `wait()` 方法，允许以毫秒和纳秒为单位指定等待时间。</span><br><span class="line"></span><br><span class="line">    #### 11. `protected void finalize() throws Throwable`</span><br><span class="line"></span><br><span class="line">    当垃圾回收器确定没有对该对象的引用时，垃圾回收器会在该对象上调用此方法。这个方法用于在对象被销毁前执行一些清理工作。**不推荐**使用 `finalize()`，因为它不保证何时执行，甚至可能不执行，并且会影响垃圾回收性能。现代 Java 中应使用 `try-with-resources` 或其他资源管理方式。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">## **String 类型**</span><br><span class="line"></span><br><span class="line">### 1. 字节和字符的区别？</span><br><span class="line"></span><br><span class="line">字节是存储容量的基本单位；字符是数字、字母、汉字以及其他语言的各种符号；1 字节 = 8 个二进制单位，一个字符由一个字节或多个字节的二进制单位组成。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 2. String 为什么要设计为不可变类？</span><br><span class="line"></span><br><span class="line">在 Java 中将 String 设计成不可变的是综合考虑到各种因素的结果。主要的原因主要有以下三点：</span><br><span class="line"></span><br><span class="line">- **字符串常量池的需要**：字符串常量池是 Java 堆内存中一个特殊的存储区域, 当创建一个 String 对象时，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象；</span><br><span class="line">- **允许 String 对象缓存 HashCode**：Java 中 String 对象的哈希码被频繁地使用, 比如在 HashMap 等容器中。字符串不变性保证了 hash 码的唯一性，因此可以放心地进行缓存。这也是一种性能优化手段，意味着不必每次都去计算新的哈希码；</span><br><span class="line">- **String 被许多的 Java 类(库)用来当做参数**，例如：网络连接地址 URL、文件路径 path、还有反射机制所需要的 String 参数等, 假若 String 不是固定不变的，将会引起各种安全隐患。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 3. String、StringBuilder、StringBuffer 的区别？</span><br><span class="line"></span><br><span class="line">string类不能被继承，因为被final修饰</span><br><span class="line"></span><br><span class="line">- **String**：用于字符串操作，属于不可变类；【补充：String 不是基本数据类型，是引用类型，底层用 char 数组实现的】</span><br><span class="line">- **StringBuilder**：与 StringBuffer 类似，都是字符串缓冲区，但线程不安全；</span><br><span class="line">- **StringBuffer**：也用于字符串操作，不同之处是 StringBuffer 属于可变类，对方法加了同步锁，线程安全</span><br><span class="line"></span><br><span class="line">StringBuffer的补充说明：StringBuffer 中并不是所有方法都使用了 Synchronized 修饰来实现同步：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Override public StringBuffer insert(int dstOffset, CharSequence s) &#123; // Note, synchronization achieved via invocations of other StringBuffer methods // after narrowing of s to specific type // Ditto for toStringCache clearing super.insert(dstOffset, s); return this; &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>执行效率：StringBuilder &gt; StringBuffer &gt; String</p>
<hr>
<h3 id="4-String-字符串修改实现的原理？"><a href="#4-String-字符串修改实现的原理？" class="headerlink" title="4. String 字符串修改实现的原理？"></a>4. String 字符串修改实现的原理？</h3><p>当用 String 类型来对字符串进行修改时，其实现方法是首先创建一个 StringBuffer，其次调用 StringBuffer 的 <code>append()</code> 方法，最后调用 StringBuffer 的 <code>toString()</code> 方法把结果返回。</p>
<hr>
<h3 id="5-String-str-“i”-与-String-str-new-String-“i”-一样吗？"><a href="#5-String-str-“i”-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="5. String str &#x3D; “i” 与 String str &#x3D; new String(“i”) 一样吗？"></a>5. String str &#x3D; “i” 与 String str &#x3D; new String(“i”) 一样吗？</h3><p>不一样，因为内存的分配方式不一样。<code>String str = &quot;i&quot;</code> 的方式，Java 虚拟机会将其分配到常量池中；而 <code>String str = new String(&quot;i&quot;)</code> 则会被分到堆内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(str1 == str2);</span><br><span class="line">        System.out.println(str1 == str3);</span><br><span class="line">        System.out.println(str3 == str4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(str3.equals(str4)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在执行 <code>String str1 = &quot;abc&quot;</code> 的时候，JVM 会首先检查字符串常量池中是否已经存在该字符串对象，如果已经存在，那么就不会再创建了，直接返回该字符串在字符串常量池中的内存地址；如果该字符串还不存在字符串常量池中，那么就会在字符串常量池中创建该字符串对象，然后再返回。所以在执行 <code>String str2 = &quot;abc&quot;</code> 的时候，因为字符串常量池中已经存在“abc”字符串对象了，就不会在字符串常量池中再次创建了，所以栈内存中 str1 和 str2 的内存地址都是指向 “abc” 在字符串常量池中的位置，所以 <code>str1 = str2</code> 的运行结果为 true。</p>
<p>而在执行 <code>String str3 = new String(&quot;abc&quot;)</code> 的时候，JVM 会首先检查字符串常量池中是否已经存在“abc”字符串，如果已经存在，则不会在字符串常量池中再创建了；如果不存在，则就会在字符串常量池中创建 “abc” 字符串对象，然后再到堆内存中再创建一份字符串对象，把字符串常量池中的 “abc” 字符串内容拷贝到内存中的字符串对象中，然后返回堆内存中该字符串的内存地址，即栈内存中存储的地址是堆内存中对象的内存地址。<code>String str4 = new String(&quot;abc&quot;)</code> 是在堆内存中又创建了一个对象，所以 <code>str3 == str4</code> 运行的结果是 false。str1、str2、str3、str4 在内存中的存储状况如下图所示：</p>
<hr>
<h3 id="6-String-类的常用方法都有那些？"><a href="#6-String-类的常用方法都有那些？" class="headerlink" title="6. String 类的常用方法都有那些？"></a>6. String 类的常用方法都有那些？</h3><ul>
<li><code>indexOf()</code>：返回指定字符的索引。</li>
<li><code>charAt()</code>：返回指定索引处的字符。</li>
<li><code>replace()</code>：字符串替换。</li>
<li><code>trim()</code>：去除字符串两端空白。</li>
<li><code>split()</code>：分割字符串，返回一个分割后的字符串数组。</li>
<li><code>getBytes()</code>：返回字符串的 byte 类型数组。</li>
<li><code>length()</code>：返回字符串长度。</li>
<li><code>toLowerCase()</code>：将字符串转成小写字母。</li>
<li><code>toUpperCase()</code>：将字符串转成大写字符。</li>
<li><code>substring()</code>：截取字符串。</li>
<li><code>equals()</code>：字符串比较。</li>
</ul>
<hr>
<h3 id="7-final-修饰-StringBuffer-后还可以-append-吗？"><a href="#7-final-修饰-StringBuffer-后还可以-append-吗？" class="headerlink" title="7. final 修饰 StringBuffer 后还可以 append 吗？"></a>7. final 修饰 StringBuffer 后还可以 append 吗？</h3><p>可以。<code>final</code> 修饰的是一个引用变量，那么这个引用始终只能指向这个对象，但是这个对象内部的属性是可以变化的。</p>
<p>官方文档解释：<code>once a final variable has been assigned, it always contains the same value. If a final variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object.</code></p>
<p><code>String</code> 是一个非常特殊的类型，它<strong>不是基本数据类型</strong>，而是一个<strong>引用数据类型（Reference Data Type）</strong>。</p>
<h4 id="String-的核心特性"><a href="#String-的核心特性" class="headerlink" title="String 的核心特性"></a><strong>String 的核心特性</strong></h4><ol>
<li><strong>不可变性（Immutability）</strong><ul>
<li><code>String</code> 对象一旦被创建，它的值就不能被改变。</li>
<li>当你对 <code>String</code> 进行修改操作时，比如拼接字符串，实际上是<strong>创建了一个新的 String 对象</strong>，而原始对象没有改变。</li>
<li>这种不可变性使得 <code>String</code> 对象是线程安全的，可以在多线程环境中被安全地共享。</li>
</ul>
</li>
<li><strong>String 的创建</strong><ul>
<li><strong>字面量方式</strong>：<code>String s = &quot;hello&quot;;</code><ul>
<li>这种方式创建的字符串会被存储在**字符串常量池（String Pool）**中。</li>
<li>当创建第二个值为 <code>&quot;hello&quot;</code> 的字符串时，JVM 会直接从常量池中返回已存在的对象引用，而不会创建新的对象。这是一种重要的内存优化。</li>
</ul>
</li>
<li><strong>new 关键字方式</strong>：<code>String s = new String(&quot;hello&quot;);</code><ul>
<li>这种方式会创建一个新的 <code>String</code> 对象在堆（Heap）中。即使常量池中已经存在 <code>&quot;hello&quot;</code>，也会在堆中再创建一个新的对象。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="String-的常用方法"><a href="#String-的常用方法" class="headerlink" title="String 的常用方法"></a><strong>String 的常用方法</strong></h4><ul>
<li><strong>拼接</strong>：<ul>
<li>使用 <code>+</code> 运算符：<code>String s3 = s1 + s2;</code></li>
<li>使用 <code>concat()</code> 方法：<code>s1.concat(s2);</code></li>
<li>推荐使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 进行大量字符串拼接，因为它们是可变的，效率更高。</li>
</ul>
</li>
<li><strong>比较</strong>：<ul>
<li><code>equals()</code>：比较字符串的内容，返回 <code>boolean</code> 类型。</li>
<li><code>equalsIgnoreCase()</code>：忽略大小写比较字符串内容。</li>
<li><code>==</code>：比较的是<strong>对象的引用地址</strong>，只有当两个引用指向同一个对象时才为 <code>true</code>。</li>
</ul>
</li>
<li><strong>查找</strong>：<ul>
<li><code>indexOf(char)</code>：查找字符第一次出现的索引。</li>
<li><code>contains(String)</code>：判断是否包含某个子字符串。</li>
</ul>
</li>
<li><strong>修改</strong>：<ul>
<li><code>replace(oldChar, newChar)</code>：替换字符串中的字符。</li>
<li><code>substring(beginIndex, endIndex)</code>：截取子字符串。</li>
</ul>
</li>
</ul>
<h4 id="为什么不用-char-数组代替-String？"><a href="#为什么不用-char-数组代替-String？" class="headerlink" title="为什么不用 char 数组代替 String？"></a><strong>为什么不用 char 数组代替 String？</strong></h4><p>虽然 <code>String</code> 内部也是用 <code>char</code> 数组实现的，但 <code>String</code> 的不可变性提供了很多优势：</p>
<ul>
<li><strong>安全性</strong>：作为方法参数时，可以防止方法内部修改原始字符串。</li>
<li><strong>线程安全</strong>：可以在多线程环境下共享。</li>
<li><strong>哈希码缓存</strong>：<code>String</code> 的哈希码会被缓存，在作为 <code>HashMap</code> 的键时，性能更好。</li>
</ul>
<hr>
<h3 id="基本类型与-String-的转换"><a href="#基本类型与-String-的转换" class="headerlink" title="基本类型与 String 的转换"></a><strong>基本类型与 String 的转换</strong></h3><ul>
<li><strong>基本类型转 String</strong>：<ul>
<li><code>String.valueOf(int i)</code></li>
<li><code>Integer.toString(int i)</code></li>
<li><code>&quot;&quot; + i</code></li>
</ul>
</li>
<li><strong>String 转基本类型</strong>：<ul>
<li><code>Integer.parseInt(&quot;123&quot;)</code></li>
<li><code>Double.parseDouble(&quot;3.14&quot;)</code></li>
<li><code>Float.parseFloat(&quot;1.23&quot;)</code></li>
<li>等等。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：<code>String</code> 转基本类型时，如果字符串格式不正确，会抛出 <code>NumberFormatException</code>。</p>
</blockquote>
<p><code>&amp;</code> 和 <code>&amp;&amp;</code> 在 Java 中都是逻辑与运算符，但它们之间有一个至关重要的区别：<strong>短路特性</strong>。</p>
<hr>
<h3 id="（逻辑与-按位与）"><a href="#（逻辑与-按位与）" class="headerlink" title="&amp;（逻辑与 &#x2F; 按位与）"></a><code>&amp;</code>（逻辑与 &#x2F; 按位与）</h3><p><code>&amp;</code> 运算符有两种不同的用途，取决于它的操作数类型。</p>
<p><strong>1. 逻辑与（当操作数为 boolean 类型时）</strong></p>
<p>当 <code>&amp;</code> 的两边是布尔表达式时，它执行<strong>非短路逻辑与</strong>。这意味着无论第一个表达式的结果是 <code>true</code> 还是 <code>false</code>，它都会<strong>继续计算</strong>第二个表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> &amp; (++a &gt; <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="comment">// 即使第一个表达式是 true，第二个表达式 (++a &gt; 10) 也会被执行。</span></span><br><span class="line">    <span class="comment">// a 的值会变为 11。</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a); <span class="comment">// 输出 11</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>++a</code> 总是会被执行，<code>a</code> 的值最终会增加。</p>
<p><strong>2. 按位与（当操作数为整数类型时）</strong></p>
<p>当 <code>&amp;</code> 的两边是整数类型（如 <code>int</code>, <code>long</code> 等）时，它执行<strong>按位与运算</strong>。它将两个数的二进制位进行比较，如果对应的位都是 <code>1</code>，则结果位是 <code>1</code>，否则是 <code>0</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 二进制 0101</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">// 二进制 0011</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x &amp; y; <span class="comment">// 二进制 0001</span></span><br><span class="line">System.out.println(result); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>

<h3 id="（短路逻辑与）"><a href="#（短路逻辑与）" class="headerlink" title="&amp;&amp;（短路逻辑与）"></a><code>&amp;&amp;</code>（短路逻辑与）</h3><p><code>&amp;&amp;</code> 运算符只用于布尔类型的操作，它执行<strong>短路逻辑与</strong>。</p>
<p>**短路（Short-circuiting）**是 <code>&amp;&amp;</code> 最重要的特性。如果第一个表达式的结果是 <code>false</code>，那么整个表达式的结果必定是 <code>false</code>，因此 <code>&amp;&amp;</code> 会立即停止计算，<strong>不再执行</strong>第二个表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span> &amp;&amp; (++a &gt; <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="comment">// 第一个表达式是 false，整个条件已确定为 false。</span></span><br><span class="line">    <span class="comment">// 第二个表达式 (++a &gt; 10) 不会被执行。</span></span><br><span class="line">    <span class="comment">// a 的值保持不变。</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a); <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>++a</code> 永远不会被执行，因为它位于短路操作的右侧。</p>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>&amp;</code></th>
<th><code>&amp;&amp;</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>功能</strong></td>
<td>逻辑与、按位与</td>
<td>仅为逻辑与</td>
</tr>
<tr>
<td><strong>短路</strong></td>
<td>不短路</td>
<td>短路</td>
</tr>
<tr>
<td><strong>计算</strong></td>
<td>始终计算第二个表达式</td>
<td>当第一个表达式为 <code>false</code> 时，不计算第二个表达式</td>
</tr>
<tr>
<td><strong>适用类型</strong></td>
<td><code>boolean</code> 和整数类型</td>
<td>仅 <code>boolean</code></td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>可能比 <code>&amp;&amp;</code> 慢（如果第一个表达式为 <code>false</code>）</td>
<td>通常比 <code>&amp;</code> 快（当第一个表达式为 <code>false</code> 时）</td>
</tr>
</tbody></table>
<p>在日常开发中，<strong>优先使用 &amp;&amp;</strong>。因为它能提高代码效率，并在避免 <code>NullPointerException</code> 等问题时非常有用，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 &amp;&amp; 避免空指针异常</span></span><br><span class="line"><span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 list 为 null，第二个表达式不会被执行，程序不会报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>&amp;</code> 通常只在需要<strong>两个表达式都必须执行</strong>的特定场景下使用，或者用于按位运算。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="C:\Users\19501\Desktop\types-of-exceptions-in-java.png" alt="types-of-exceptions-in-java"></p>
<h3 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a><a href="#exception-%E5%92%8C-error-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Exception 和 Error 有什么区别？</a></h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><strong>Exception</strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong>Error</strong>：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<h3 id="⭐️Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#⭐️Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="⭐️Checked Exception 和 Unchecked Exception 有什么区别？"></a><a href="#%E2%AD%90%EF%B8%8Fchecked-exception-%E5%92%8C-unchecked-exception-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">⭐️Checked Exception 和 Unchecked Exception 有什么区别？</a></h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。 </p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p>
<p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>
<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>
<li>……</li>
</ul>
<hr>
<h3 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a><a href="#throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">Throwable 类常用方法有哪些？</a></h3><ul>
<li><code>String getMessage()</code>: 返回异常发生时的详细信息</li>
<li><code>String toString()</code>: 返回异常发生时的简要描述</li>
<li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a><a href="#try-catch-finally-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">try-catch-finally 如何使用？</a></h3><hr>
<p><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</p>
<p><code>catch</code>块：用于处理 try 捕获到的异常。</p>
<p><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p>
<h3 id="5-Error-和-Exception-的区别？"><a href="#5-Error-和-Exception-的区别？" class="headerlink" title="5. Error 和 Exception 的区别？"></a>5. Error 和 Exception 的区别？</h3><p>Error 类和 Exception 类的父类都是 Throwable 类。主要区别如下：</p>
<ul>
<li><strong>Error 类</strong>：一般是指与虚拟机相关的问题，如：系统崩溃、虚拟机错误、内存空间不足、方法调用栈溢出等。这类错误将会导致应用程序中断，仅靠程序本身无法恢复和预防；</li>
<li><strong>Exception 类</strong>：分为运行时异常和受检查的异常。</li>
</ul>
<hr>
<h3 id="6-运行时异常与受检异常有何异同？"><a href="#6-运行时异常与受检异常有何异同？" class="headerlink" title="6. 运行时异常与受检异常有何异同？"></a>6. 运行时异常与受检异常有何异同？</h3><ul>
<li><strong>运行时异常</strong>：如：空指针异常、指定的类找不到、数组越界、方法传递参数错误、数据类型转换错误。可以编译通过，但是一运行就停止了，程序不会自己处理；</li>
<li><strong>受检查异常</strong>：要么用 <code>try ... catch...</code> 捕获，要么用 <code>throws</code> 声明抛出，交给父类处理。</li>
</ul>
<hr>
<h3 id="7-throw-和-throws-的区别？"><a href="#7-throw-和-throws-的区别？" class="headerlink" title="7. throw 和 throws 的区别？"></a>7. throw 和 throws 的区别？</h3><ul>
<li><strong>throw</strong>：在方法体内部，表示抛出异常，由方法体内部的语句处理；<code>throw</code> 是具体向外抛出异常的动作，所以它抛出一个异常实例；</li>
<li><strong>throws</strong>：在方法声明后面，表示如果抛出异常，由该方法的调用者来处理；表示出现异常的可能性，并不一定会发生这种异常。</li>
</ul>
<hr>
<h3 id="8-常见的异常类有哪些？"><a href="#8-常见的异常类有哪些？" class="headerlink" title="8. 常见的异常类有哪些？"></a>8. 常见的异常类有哪些？</h3><ul>
<li><strong>NullPointerException</strong>：当应用程序试图访问空对象时，则抛出该异常。</li>
<li><strong>SQLException</strong>：提供关于数据库访问错误或其他错误信息的异常。</li>
<li><strong>IndexOutOfBoundsException</strong>：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li>
<li><strong>FileNotFoundException</strong>：当试图打开指定路径名表示的文件失败时，抛出此异常。</li>
<li><strong>IOException</strong>：当发生某种 I&#x2F;O 异常时，抛出此异常。此类是失败或中断的 I&#x2F;O 操作生成的异常的通用类。</li>
<li><strong>ClassCastException</strong>：当试图将对象强制转换为不是实例的子类时，抛出该异常。</li>
<li><strong>IllegalArgumentException</strong>：抛出的异常表明向方法传递了一个不合法或不正确的参数。</li>
</ul>
<hr>
<h3 id="9-主线程可以捕获到子线程的异常吗？"><a href="#9-主线程可以捕获到子线程的异常吗？" class="headerlink" title="9. 主线程可以捕获到子线程的异常吗？"></a>9. 主线程可以捕获到子线程的异常吗？</h3><p>线程设计的理念：“线程的问题应该线程它自己本身来解决，而不要委托到外部”。</p>
<p>正常情况下，如果不做特殊的处理，在主线程中是不能够捕获到子线程中的异常的。如果想要在主线程中捕获子线程的异常，我们可以用如下的方式进行处理，使用 <code>Thread</code> 的静态方法 <code>Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandle());</code>通常情况下，主线程<strong>不能直接</strong>捕获到子线程中抛出的异常。这是因为线程是独立的执行流，每个线程都有自己的调用栈。当子线程中发生异常时，如果该异常没有被子线程内部的 <code>try-catch</code> 块捕获，它会沿着子线程的调用栈向上冒泡，最终导致子线程终止。这个异常不会传递到主线程的调用栈中，因此主线程无法感知或捕获它。</p>
<p>这个设计理念被称为“线程的问题应该由线程自己本身来解决，而不是委托到外部”。</p>
<hr>
<h3 id="捕获子线程异常的方法"><a href="#捕获子线程异常的方法" class="headerlink" title="捕获子线程异常的方法"></a>捕获子线程异常的方法</h3><p>虽然主线程无法直接捕获子线程异常，但 Java 提供了两种机制来处理这种情况，允许你在主线程或其他线程中对子线程的异常进行处理：</p>
<h4 id="1-使用-try-catch-在子线程内部处理"><a href="#1-使用-try-catch-在子线程内部处理" class="headerlink" title="1. 使用 try-catch 在子线程内部处理"></a>1. 使用 <code>try-catch</code> 在子线程内部处理</h4><p>这是最直接也最推荐的方式。在子线程的 <code>run()</code> 方法中，用 <code>try-catch</code> 块将可能抛出异常的代码包围起来。这样，异常就会在子线程内部被捕获并处理，你可以选择记录日志、发送通知，或者执行其他恢复操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能会抛出异常的代码</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception from child thread&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 在子线程中捕获并处理异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;子线程捕获到异常: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-设置未捕获异常处理器-UncaughtExceptionHandler"><a href="#2-设置未捕获异常处理器-UncaughtExceptionHandler" class="headerlink" title="2. 设置未捕获异常处理器 (UncaughtExceptionHandler)"></a>2. 设置未捕获异常处理器 (<code>UncaughtExceptionHandler</code>)</h4><p>当你无法在子线程内部处理所有异常时，可以使用 <code>UncaughtExceptionHandler</code>。这是一个在线程因未捕获异常而突然终止时被调用的回调接口。你可以为每个线程或所有线程设置一个默认的处理器。</p>
<p><strong>A. 为单个线程设置处理器</strong></p>
<p>你可以为特定的 <code>Thread</code> 实例设置一个 <code>UncaughtExceptionHandler</code>。当该线程发生未捕获异常时，JVM 会调用你提供的处理器的 <code>uncaughtException()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception from child thread!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;在主线程中捕获到子线程 [&quot;</span> + t.getName() + <span class="string">&quot;] 的异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p><strong>B. 为所有线程设置默认处理器</strong></p>
<p>如果你想为所有线程（包括线程池中的线程）设置一个通用的异常处理逻辑，可以使用 <code>Thread.setDefaultUncaughtExceptionHandler()</code>。这个处理器会在没有任何特定处理器的线程上被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主线程中设置全局默认处理器</span></span><br><span class="line">Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;全局处理器捕获到线程 [&quot;</span> + t.getName() + <span class="string">&quot;] 的异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程中抛出未处理的异常</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Global uncaught exception&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>主线程</strong>不能直接捕获<strong>子线程</strong>的异常，因为它们是独立的执行流。</li>
<li>要处理子线程的异常，最简单的方法是<strong>在子线程内部使用 try-catch 块</strong>。</li>
<li>如果需要在主线程中感知和处理子线程的异常，可以使用 <code>Thread</code> 提供的**<code>UncaughtExceptionHandler</code>**机制。你可以为特定线程或所有线程设置一个处理器，当线程因未捕获异常而终止时，这个处理器会被调用。</li>
</ul>
<hr>
<h2 id="创建对象："><a href="#创建对象：" class="headerlink" title="创建对象："></a>创建对象：</h2><p>好的，Java 中创建对象的方式有多种，除了最常见的 <code>new</code> 关键字，还有其他几种重要的技术。下面我们来详细解析这四种创建对象的方法。</p>
<hr>
<h3 id="1-使用-new-关键字"><a href="#1-使用-new-关键字" class="headerlink" title="1. 使用 new 关键字"></a>1. 使用 <code>new</code> 关键字</h3><p>这是最常见、最直接的创建对象方式。当你使用 <code>new</code> 关键字时，它会调用类的<strong>构造器</strong>来初始化对象。</p>
<p><strong>原理：</strong></p>
<ol>
<li><strong>分配内存：</strong> JVM 在堆（Heap）上为新对象分配所需的内存空间。</li>
<li><strong>默认初始化：</strong> 成员变量会被赋予默认值（例如，<code>int</code> 为 <code>0</code>，<code>boolean</code> 为 <code>false</code>，引用类型为 <code>null</code>）。</li>
<li><strong>调用构造器：</strong> JVM 调用指定的构造器来执行初始化代码。构造器中的代码会覆盖之前的默认值。</li>
<li><strong>返回引用：</strong> 对象创建完成后，<code>new</code> 表达式会返回该对象在内存中的引用。</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li>简单直观，代码可读性好。</li>
<li>可以调用任何可访问的构造器（包括有参和无参）。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>每次调用 <code>new</code> 都会创建一个新对象，开销较大。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 new 关键字创建对象</span></span><br><span class="line"><span class="type">MyObject</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line"><span class="type">MyObject</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-使用-Class-类的-newInstance-方法（反射）"><a href="#2-使用-Class-类的-newInstance-方法（反射）" class="headerlink" title="2. 使用 Class 类的 newInstance() 方法（反射）"></a>2. 使用 <code>Class</code> 类的 <code>newInstance()</code> 方法（反射）</h3><p><code>Class.forName().newInstance()</code> 是通过<strong>反射</strong>来创建对象的方式。</p>
<p><strong>原理：</strong></p>
<ol>
<li><strong>加载类：</strong> <code>Class.forName()</code> 方法根据类的全限定名（如 <code>&quot;com.example.MyObject&quot;</code>）加载类，并返回对应的 <code>Class</code> 对象。</li>
<li><strong>创建实例：</strong> <code>newInstance()</code> 方法会调用该类的<strong>无参构造器</strong>来创建对象。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li><code>newInstance()</code> 要求类必须有一个无参的构造器，且该构造器必须是可见的（<code>public</code>）。</li>
<li>Java 9 之后，<code>Class.newInstance()</code> 被标记为<strong>过时（deprecated）</strong>。</li>
<li>在现代 Java 中，更推荐使用 <code>Constructor</code> 类的 <code>newInstance()</code> 方法，因为它能够调用<strong>有参</strong>构造器，并且可以处理构造器抛出的异常。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以在运行时动态地创建对象，非常灵活。</li>
<li>适用于工厂模式、依赖注入（如 Spring）等场景。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>性能比 <code>new</code> 关键字差，因为涉及反射机制。</li>
<li>如果类没有无参构造器或构造器不可访问，会抛出异常。</li>
<li>没有编译时检查，错误只能在运行时发现。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Class.forName().newInstance() 创建对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyObject&quot;</span>);</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">obj</span> <span class="operator">=</span> (MyObject) clazz.newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-使用-clone-方法"><a href="#3-使用-clone-方法" class="headerlink" title="3. 使用 clone() 方法"></a>3. 使用 <code>clone()</code> 方法</h3><p><code>clone()</code> 方法通过<strong>复制</strong>现有对象来创建新对象，而不是重新构造。它属于 <code>Object</code> 类的一个 <code>protected</code> 方法。</p>
<p><strong>原理：</strong></p>
<ol>
<li><strong>实现接口：</strong> 要使用 <code>clone()</code> 方法，你的类必须实现 <code>Cloneable</code> 接口。这个接口是一个<strong>标记接口</strong>，本身没有任何方法，但它告诉 JVM 这个类可以被克隆。</li>
<li><strong>重写方法：</strong> 你需要重写 <code>Object</code> 类的 <code>clone()</code> 方法，并将其访问修饰符改为 <code>public</code>。</li>
<li><strong>执行克隆：</strong> <code>clone()</code> 方法会创建一个新对象，并将现有对象的字段值<strong>逐一复制</strong>到新对象中。这是一种<strong>浅拷贝（shallow copy）</strong>。如果你的对象包含引用类型的成员，那么新对象和旧对象将共享同一个引用。</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li>克隆一个对象比使用 <code>new</code> 关键字创建对象更快，因为它跳过了构造器的初始化过程。</li>
<li>在需要大量创建相同或相似对象时，是一种有效的性能优化手段。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><code>clone()</code> 方法默认是浅拷贝，如果需要深拷贝（deep copy），需要手动实现。</li>
<li><code>Cloneable</code> 接口和 <code>clone()</code> 方法的设计有些“反直觉”，容易出现问题。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类需要实现 Cloneable 接口并重写 clone() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 clone() 方法创建对象</span></span><br><span class="line"><span class="type">MyObject</span> <span class="variable">original</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyObject) original.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-反序列化（Deserialization）"><a href="#4-反序列化（Deserialization）" class="headerlink" title="4. 反序列化（Deserialization）"></a>4. 反序列化（Deserialization）</h3><p>反序列化是指将字节流<strong>恢复成</strong> Java 对象的过程。</p>
<p><strong>原理：</strong></p>
<ol>
<li><strong>序列化：</strong> 首先，一个对象必须是**可序列化（<code>Serializable</code>）**的，即它实现了 <code>Serializable</code> 接口。</li>
<li><strong>写入流：</strong> 序列化就是将对象的状态（成员变量的值）写入一个字节流中（例如，写入文件或网络）。</li>
<li><strong>反序列化：</strong> 反序列化则是从字节流中读取数据，并重建（re-create）原始对象。这个过程<strong>不会调用构造器</strong>。</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li>可以将对象持久化到磁盘或在网络中传输，这对于分布式系统和缓存非常重要。</li>
<li>可以跨进程甚至跨机器传输对象。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>只有实现了 <code>Serializable</code> 接口的类才能进行序列化和反序列化。</li>
<li>如果对象的版本不兼容，反序列化可能会失败。</li>
<li>存在安全风险，因为它能够绕过构造器，如果设计不当可能导致不一致的状态。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象必须实现 Serializable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>))) &#123;</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> <span class="title class_">MyObject</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">obj</span> <span class="operator">=</span> (MyObject) ois.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>这四种创建对象的方式各有优劣和适用场景：</p>
<ul>
<li><strong>new</strong>：最常用，用于<strong>常规</strong>的对象创建。</li>
<li><strong>反射</strong>：用于<strong>运行时动态</strong>创建对象，常用于框架开发。</li>
<li><strong>clone()</strong>：用于<strong>快速复制</strong>现有对象，以提高性能。</li>
<li><strong>反序列化</strong>：用于将对象<strong>持久化</strong>或在<strong>网络传输</strong>中重建。</li>
</ul>
<p>理解这些创建对象的方式，可以让你在不同的编程场景中做出更明智的选择。</p>
<p>深拷贝和浅拷贝是 Java 对象复制时需要理解的两个重要概念。它们主要通过 <code>clone()</code> 方法或序列化来实现。</p>
<h3 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h3><p><strong>浅拷贝</strong>只复制对象本身，以及其基本数据类型的字段。对于引用类型的字段，它<strong>只复制引用地址</strong>，新旧对象会共享同一块内存中的引用数据。</p>
<h4 id="实现方式：clone-方法"><a href="#实现方式：clone-方法" class="headerlink" title="实现方式：clone() 方法"></a>实现方式：<code>clone()</code> 方法</h4><p>Java 中的浅拷贝通常通过实现 <code>Cloneable</code> 接口并重写 <code>Object</code> 类的 <code>clone()</code> 方法来实现。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>让你的类实现 <code>java.lang.Cloneable</code> 接口。这是一个标记接口，告诉 JVM 这个类的实例可以被克隆。</li>
<li>重写 <code>Object</code> 类的 <code>clone()</code> 方法，并将其可见性改为 <code>public</code>。</li>
<li>在重写的方法中调用 <code>super.clone()</code>。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address; <span class="comment">// 引用类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 这是浅拷贝的实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShallowCopyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">originalStudent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Zhangsan&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用浅拷贝</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStudent</span> <span class="operator">=</span> (Student) originalStudent.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 浅拷贝前 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改克隆对象的引用类型字段</span></span><br><span class="line">        clonedStudent.address.city = <span class="string">&quot;Shanghai&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 浅拷贝后 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city); <span class="comment">// 原始对象的地址也变了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- 浅拷贝前 ---</span><br><span class="line">原始学生地址: Beijing</span><br><span class="line">克隆学生地址: Beijing</span><br><span class="line"></span><br><span class="line">--- 浅拷贝后 ---</span><br><span class="line">原始学生地址: Shanghai</span><br><span class="line">克隆学生地址: Shanghai</span><br></pre></td></tr></table></figure>

<p>可以看到，修改克隆对象的地址，原始对象的地址也随之改变，这正是浅拷贝的特点。</p>
<hr>
<h3 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h3><p><strong>深拷贝</strong>会创建一个完全独立的新对象，不仅复制基本数据类型，还会<strong>递归地复制</strong>所有引用类型字段指向的对象。新旧对象之间互不影响。</p>
<h4 id="实现方式一：手动实现递归复制"><a href="#实现方式一：手动实现递归复制" class="headerlink" title="实现方式一：手动实现递归复制"></a>实现方式一：手动实现递归复制</h4><p>在重写的 <code>clone()</code> 方法中，对引用类型的字段进行<strong>单独的克隆</strong>。</p>
<p>示例：</p>
<p>修改上面的 Student 类，实现深拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Address 类也必须重写 clone()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 先进行浅拷贝</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStudent</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">// 然后对引用类型的字段进行深层拷贝</span></span><br><span class="line">        clonedStudent.address = (Address) <span class="built_in">this</span>.address.clone();</span><br><span class="line">        <span class="keyword">return</span> clonedStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCopyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">originalStudent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Zhangsan&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用深拷贝</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStudent</span> <span class="operator">=</span> (Student) originalStudent.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 深拷贝前 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改克隆对象的引用类型字段</span></span><br><span class="line">        clonedStudent.address.city = <span class="string">&quot;Shanghai&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 深拷贝后 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city); <span class="comment">// 原始对象没有改变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- 深拷贝前 ---</span><br><span class="line">原始学生地址: Beijing</span><br><span class="line">克隆学生地址: Beijing</span><br><span class="line"></span><br><span class="line">--- 深拷贝后 ---</span><br><span class="line">原始学生地址: Beijing</span><br><span class="line">克隆学生地址: Shanghai</span><br></pre></td></tr></table></figure>

<p>这次，修改克隆对象的地址，原始对象没有受到影响。</p>
<h4 id="实现方式二：序列化与反序列化"><a href="#实现方式二：序列化与反序列化" class="headerlink" title="实现方式二：序列化与反序列化"></a>实现方式二：序列化与反序列化</h4><p>这是一种更简单、通用的深拷贝方法，特别适用于对象结构复杂的情况。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>让所有相关类（包括引用类型）都实现 <code>java.io.Serializable</code> 接口。</li>
<li>将对象写入一个字节流中（序列化）。</li>
<li>再从字节流中读出新的对象（反序列化）。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializationDeepCopyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">originalStudent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Zhangsan&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化和反序列化实现深拷贝</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(originalStudent);</span><br><span class="line">        oos.close();</span><br><span class="line">        </span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStudent</span> <span class="operator">=</span> (Student) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 深拷贝前 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改克隆对象的引用类型字段</span></span><br><span class="line">        clonedStudent.address.city = <span class="string">&quot;Shanghai&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 深拷贝后 ---&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始学生地址: &quot;</span> + originalStudent.address.city);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆学生地址: &quot;</span> + clonedStudent.address.city);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法代码虽然多，但对于复杂的对象图来说，它比手动递归实现要简单得多，因为它会自动处理所有嵌套对象的拷贝。</p>
<h2 id="接口和抽象类："><a href="#接口和抽象类：" class="headerlink" title="接口和抽象类："></a>接口和抽象类：</h2><p>在软件开发中，<strong>抽象类（abstract class）和接口（interface）都是用于实现多态</strong>的重要概念，它们允许你定义一个通用的契约，然后让具体的类去实现这个契约。虽然它们的目的相似，但在用途、设计和实现上存在一些关键区别。</p>
<hr>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一个不能被实例化的类，它通常包含<strong>抽象方法</strong>（没有具体实现的方法）和<strong>具体方法</strong>（有具体实现的方法）。</p>
<p><strong>主要特点：</strong></p>
<ul>
<li><strong>语法：</strong> 使用 <code>abstract</code> 关键字来声明类和抽象方法。</li>
<li><strong>方法：</strong> 可以同时包含抽象方法和具体方法。抽象方法必须在子类中被实现，具体方法则可以选择性地被重写。</li>
<li><strong>成员变量：</strong> 可以包含成员变量，包括 <code>private</code>、<code>protected</code> 和 <code>public</code> 等修饰符。</li>
<li><strong>继承：</strong> 一个子类<strong>只能继承一个</strong>抽象类。如果子类不是抽象类，它必须实现所有父抽象类中的抽象方法。</li>
<li><strong>构造器：</strong> 抽象类可以有构造器，但不能直接用 <code>new</code> 关键字来创建实例。它的构造器主要用于在子类中通过 <code>super</code> 关键字调用，以初始化父类的成员。</li>
<li><strong>目的：</strong> 通常用于定义一类事物共同的<strong>属性和行为</strong>。它代表一种“is-a”（是一种）的关系，比如“猫是一种动物”，<code>Cat</code> 类继承 <code>Animal</code> 抽象类。</li>
</ul>
<p>使用场景：</p>
<p>当你需要定义一个模板，其中一些方法是通用的（已实现），而另一些方法是需要子类根据自身特点去实现的，抽象类是理想选择。例如，一个 Shape 抽象类可以定义一个通用的 draw() 抽象方法，但每个具体的形状（Circle，Rectangle）都有自己独特的绘制方式。同时，它还可以有一个具体的 getColor() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 示例</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法，所有子类都可以直接使用或重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zzz...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof woof&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一个完全抽象的“类”，它定义了一组<strong>契约或规范</strong>，其中只包含抽象方法和常量。自 Java 8 之后，接口也可以包含默认方法（default method）和静态方法。</p>
<p><strong>主要特点：</strong></p>
<ul>
<li><strong>语法：</strong> 使用 <code>interface</code> 关键字声明。</li>
<li><strong>方法：</strong> 在 Java 8 之前，接口中的方法默认都是 <code>public abstract</code> 的，可以省略这两个关键字。自 Java 8 之后，可以有 <code>default</code> 和 <code>static</code> 方法。自 Java 9 之后，还可以有 <code>private</code> 方法。</li>
<li><strong>成员变量：</strong> 接口中的成员变量默认是 <code>public static final</code> 的，也即常量。</li>
<li><strong>实现：</strong> 一个类可以<strong>实现（implements）多个</strong>接口，从而克服了单继承的限制。</li>
<li><strong>目的：</strong> 主要用于定义一个<strong>能力或行为</strong>。它代表一种“can-do”（能做）的关系，比如一个 <code>Car</code> 类可以实现 <code>Driveable</code> 接口，一个 <code>Bird</code> 类可以实现 <code>Flyable</code> 接口。它是一种对行为的抽象。</li>
</ul>
<p>使用场景：</p>
<p>当你需要定义一种能力，而这种能力可以被不同类别的对象共享时，接口非常有用。例如，Flyable 接口可以被 Airplane、Bird 或 Superman 等完全不相关的类实现，因为它们都具有“飞行”的能力。</p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，默认 public abstract</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java 8 之后允许的默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">glide</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Gliding through the air...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Flapping wings to fly.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="核心区别总结"><a href="#核心区别总结" class="headerlink" title="核心区别总结"></a>核心区别总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>抽象类（Abstract Class）</th>
<th>接口（Interface）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>继承&#x2F;实现</strong></td>
<td><code>extends</code>，单继承</td>
<td><code>implements</code>，多实现</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td>可包含抽象方法和具体方法</td>
<td>仅包含抽象方法（Java 8+ 可有 <code>default</code>、<code>static</code> 方法）</td>
</tr>
<tr>
<td><strong>成员变量</strong></td>
<td>各种类型变量，包括常量和非常量</td>
<td>只能是 <code>public static final</code> 常量</td>
</tr>
<tr>
<td><strong>构造器</strong></td>
<td>可以有</td>
<td>不能有</td>
</tr>
<tr>
<td><strong>可访问性</strong></td>
<td>成员可以是 <code>private</code>, <code>protected</code> 或 <code>public</code></td>
<td>方法默认是 <code>public</code>，变量默认是 <code>public static final</code></td>
</tr>
<tr>
<td><strong>目的</strong></td>
<td>定义一类事物的<strong>共同特征和行为</strong>，代表“is-a”关系</td>
<td>定义一种<strong>能力或行为</strong>，代表“can-do”关系</td>
</tr>
</tbody></table>
<p>10、抽象类和接口有什么区别？</p>
<p>（1）抽象类中可以定义构造函数，接口不能定义构造函数； </p>
<p>（2）抽象类中可以有抽象方法和具体⽅方法，而接口中只能有抽象方法（public abstract）； </p>
<p>（3）抽象类中的成员权限可以是 public、默认、protected（抽象类中抽象方法就是为了重写，所以不能被 private 修饰），而接口中的成员只可以是 public（方法默认：public abstrat、成员变量默认：public static final）；</p>
<p> （4）抽象类中可以包含静态方法，而接口中不不可以包含静态方法；</p>
<p> JDK 8 中的改变：</p>
<p>1、在 JDK1.8中，允许在接⼝口中包含带有具体实现的⽅方法，使用 default 修饰，这类⽅方法就是默认方法。 2、抽象类中可以包含静态方法，在 JDK1.8 之前接口中不不能包含静态方法，JDK1.8 以后可以包含。之前不能包含是因为，接口不可以实现方法，只可以定义方法，所以不能使用静态方法（因为静态方法必须实现）。现在可以包 含了，只能直接用接口调用静态⽅方法。JDK1.8 仍然不可以包含静态代码块。 </p>
<h3 id="面试官可能会问的深入问题"><a href="#面试官可能会问的深入问题" class="headerlink" title="面试官可能会问的深入问题"></a>面试官可能会问的深入问题</h3><ul>
<li><strong>为什么 Java 要同时保留抽象类和接口？</strong><ul>
<li>抽象类侧重于<strong>代码复用</strong>，通过具体方法减少子类的重复代码，并强制子类实现某些特定行为。</li>
<li>接口侧重于<strong>功能扩展和解耦</strong>，允许不相关的类拥有相同的行为，实现更灵活的设计，同时避免多继承带来的复杂性。</li>
</ul>
</li>
<li><strong>什么时候用抽象类，什么时候用接口？</strong><ul>
<li>如果你想在类层次结构中<strong>共享代码</strong>，并且这种关系是一种**“is-a”关系**，使用抽象类。</li>
<li>如果你想为不相关的类<strong>定义通用的行为</strong>，并且希望一个类能拥有多种能力，使用接口。</li>
</ul>
</li>
<li><strong>Java 8 的默认方法对接口和抽象类的区别有什么影响？</strong><ul>
<li>默认方法的引入模糊了两者的一些界限，接口现在也可以提供方法的默认实现，使得接口的能力更强。</li>
<li>但是，本质区别仍然存在：<strong>抽象类可以有状态（非 final 成员变量），而接口不能。</strong> 抽象类可以共享状态和具体实现，接口则更关注行为的契约。</li>
</ul>
</li>
</ul>
<p>简单来说，抽象类是<strong>模板</strong>，提供了骨架和部分实现；接口是<strong>契约</strong>，只规定了行为。理解了这一点，就能很好地应对这类面试题。</p>
<hr>
<p>好的，我帮你系统整理 <strong>代理模式（Proxy Pattern）</strong> 的概念、分类和特点，并附带易懂示例。</p>
<hr>
<h1 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h1><p>代理模式是一种 <strong>结构型设计模式</strong>，其核心思想是：<strong>为其他对象提供一种代理以控制对这个对象的访问</strong>。<br> 代理对象（Proxy）充当真实对象（Real Subject）的替身，客户端通过代理访问真实对象，而代理可以在访问前后进行增强操作（如权限校验、延迟加载、日志记录等）。</p>
<hr>
<h2 id="1-代理模式的组成"><a href="#1-代理模式的组成" class="headerlink" title="1. 代理模式的组成"></a>1. 代理模式的组成</h2><ol>
<li><strong>Subject（抽象主题）</strong><ul>
<li>定义真实对象和代理对象的公共接口，客户端通过这个接口访问对象。</li>
</ul>
</li>
<li><strong>RealSubject（真实主题）</strong><ul>
<li>真正的业务逻辑对象，实现 Subject 接口。</li>
</ul>
</li>
<li><strong>Proxy（代理类）</strong><ul>
<li>通过实现 Subject 接口，内部持有 RealSubject 的引用。</li>
<li>可在调用真实对象方法前后添加额外功能。</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">interface Subject &#123;</span><br><span class="line">    void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 真实对象</span><br><span class="line">class RealSubject implements Subject &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        System.out.println(&quot;真实对象处理请求&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代理对象</span><br><span class="line">class ProxySubject implements Subject &#123;</span><br><span class="line">    private RealSubject real;</span><br><span class="line"></span><br><span class="line">    public ProxySubject(RealSubject real) &#123;</span><br><span class="line">        this.real = real;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        System.out.println(&quot;代理前处理&quot;);</span><br><span class="line">        real.request(); // 调用真实对象</span><br><span class="line">        System.out.println(&quot;代理后处理&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RealSubject real = new RealSubject();</span><br><span class="line">        ProxySubject proxy = new ProxySubject(real);</span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-代理模式的几种类型及特点"><a href="#2-代理模式的几种类型及特点" class="headerlink" title="2. 代理模式的几种类型及特点"></a>2. 代理模式的几种类型及特点</h2><table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>静态代理（Static Proxy）</strong></td>
<td>- 代理类在编译时就确定- 代理类与真实对象实现相同接口- 优点：简单易懂，编译时检查安全- 缺点：每一个真实对象都需要对应代理类，代理类数量多，扩展性差</td>
<td>权限控制、日志记录等固定功能的增强</td>
</tr>
<tr>
<td><strong>动态代理（Dynamic Proxy）</strong></td>
<td>- 运行时创建代理类- Java 提供 <strong>JDK 动态代理</strong>（接口）和 <strong>CGLIB 动态代理</strong>（继承子类）- 优点：减少代理类数量，增强可扩展性- 缺点：运行时生成字节码，性能稍低</td>
<td>AOP、事务管理、日志记录、RPC 调用</td>
</tr>
<tr>
<td><strong>强制代理（Force Proxy）</strong></td>
<td>- 真实对象只能通过代理访问- 客户端无法直接访问真实对象</td>
<td>需要严格控制访问权限的场景</td>
</tr>
<tr>
<td><strong>远程代理（Remote Proxy）</strong></td>
<td>- 为远程对象提供本地代理，隐藏网络通信细节</td>
<td>RPC 调用、分布式系统</td>
</tr>
<tr>
<td><strong>虚拟代理（Virtual Proxy）</strong></td>
<td>- 延迟创建或加载真实对象- 代理对象在需要时才创建真实对象</td>
<td>大对象延迟加载、懒加载场景</td>
</tr>
<tr>
<td><strong>保护代理（Protection Proxy）</strong></td>
<td>- 控制真实对象的访问权限- 根据不同用户权限返回不同结果</td>
<td>权限控制、安全管理</td>
</tr>
<tr>
<td><strong>缓存代理（Cache Proxy）</strong></td>
<td>- 对结果进行缓存，减少真实对象重复计算</td>
<td>频繁查询、计算量大的场景</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-代理模式的优缺点"><a href="#3-代理模式的优缺点" class="headerlink" title="3. 代理模式的优缺点"></a>3. 代理模式的优缺点</h3><p><strong>优点</strong>：</p>
<ol>
<li>客户端与真实对象解耦，通过代理可以灵活增强功能。</li>
<li>可以控制访问、延迟加载、记录日志等。</li>
<li>增强对象功能而不修改原始类。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>增加系统复杂性，代理类可能增加额外层次。</li>
<li>对性能有一定影响（尤其是动态代理或远程代理）。</li>
</ol>
<hr>
<h3 id="如何实现动态代理？"><a href="#如何实现动态代理？" class="headerlink" title="如何实现动态代理？"></a>如何实现动态代理？</h3><p>动态代理的核心思想是在<strong>运行时</strong>创建一个代理对象，用于在不修改原始类代码的情况下，为对象添加额外的功能（如日志记录、性能监控、事务管理等）。Java 提供了两种主要的动态代理实现方式：<strong>JDK 动态代理</strong>和 <strong>CGLIB 动态代理</strong>。</p>
<p>这里我们重点解析 JDK 动态代理的实现，它依赖于接口。</p>
<hr>
<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>JDK 动态代理的实现主要依赖于以下三个核心组件：</p>
<ol>
<li><strong>接口 (Interface)</strong>：代理对象和被代理对象必须实现同一个或一组接口。这是 JDK 动态代理的基础，它强制代理对象和被代理对象具有相同的公共行为。</li>
<li><strong>InvocationHandler</strong>：这是动态代理的<strong>核心处理逻辑</strong>。你需要在其中实现 <code>invoke</code> 方法，这个方法包含了代理对象被调用时要执行的所有逻辑。</li>
<li><strong>Proxy</strong>：这是一个工具类，用于动态生成代理对象。你不能直接创建代理对象，而是通过 <code>Proxy</code> 类的静态方法来完成。</li>
</ol>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>动态代理的整个过程可以分为以下几步：</p>
<ol>
<li><strong>定义接口</strong>：首先，你需要定义一个接口，声明被代理对象和代理对象共同拥有的方法。</li>
<li><strong>创建被代理对象（目标对象）</strong>：创建一个类，实现上一步定义的接口，这就是我们真正要代理的对象。</li>
<li><strong>编写 InvocationHandler</strong>：创建一个处理类，它实现 <code>InvocationHandler</code> 接口，并重写 <code>invoke</code> 方法。在这个方法中，你将：<ul>
<li>接收被代理对象的实例。</li>
<li>在调用原始方法<strong>之前</strong>执行一些预处理逻辑。</li>
<li>通过 <code>method.invoke(目标对象, args)</code> 调用被代理对象的原始方法。</li>
<li>在调用原始方法<strong>之后</strong>执行一些后处理逻辑。</li>
</ul>
</li>
<li><strong>使用 Proxy 类生成代理对象</strong>：调用 <code>Proxy</code> 类的静态方法 <code>newProxyInstance()</code> 来创建代理对象。这个方法需要三个参数：<ul>
<li><strong>ClassLoader loader</strong>：用于加载代理类的类加载器。通常使用被代理对象的类加载器。</li>
<li><strong>Class&lt;?&gt;[] interfaces</strong>：一个接口数组，代理对象需要实现的接口。</li>
<li><strong>InvocationHandler handler</strong>：实现了 <code>InvocationHandler</code> 的对象，它包含了代理的逻辑。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="invoke-方法的参数解析"><a href="#invoke-方法的参数解析" class="headerlink" title="invoke() 方法的参数解析"></a><code>invoke()</code> 方法的参数解析</h4><p><code>InvocationHandler</code> 接口的 <code>invoke()</code> 方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>proxy</strong>：这个参数是<strong>代理对象本身</strong>的引用。在 <code>invoke</code> 方法内部，你应该避免直接调用 <code>proxy</code> 的方法，否则可能导致无限递归调用。</li>
<li><strong>method</strong>：代表正在被调用的方法，它是 <code>java.lang.reflect.Method</code> 类型的对象。你可以通过它获取方法名、参数类型、返回值类型等信息。</li>
<li><strong>args</strong>：一个 <code>Object</code> 数组，包含了调用原始方法时传递的所有参数。</li>
</ul>
<p>通过以上步骤，JVM 会在运行时动态生成一个实现了指定接口、并继承自 <code>Proxy</code> 类的字节码，将其加载到内存中，并最终返回一个代理对象实例。所有对代理对象方法的调用都会被自动转发到 <code>InvocationHandler</code> 的 <code>invoke</code> 方法中，从而实现了对原始方法的增强和控制。</p>
<p>Proxy 类的作用是动态创建一个代理对象的类。它提供了许多的方法，但是我们用得最多的就是 <code>newProxyInstance</code> 这个方法：</p>
<p><code>public static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler handler) throws IllegalArgumentException</code></p>
<ul>
<li><code>loader</code>：一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载；</li>
<li><code>interfaces</code>：一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了。</li>
<li><code>handler</code>：一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上。</li>
</ul>
<p>通过 <code>Proxy.newProxyInstance</code> 创建的代理对象是在 Jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行时动态生成的一个对象。</p>
<h2 id="成员类："><a href="#成员类：" class="headerlink" title="成员类："></a>成员类：</h2><p>我已经为您将之前关于<strong>成员类分类</strong>的详细解析和表格总结进行了合并，以提供一个更全面、更易于理解的回答。</p>
<hr>
<p>在 Java 中，一个类可以定义在另一个类的内部，这种类被称为<strong>成员类（Member Class）</strong>，也被称为<strong>嵌套类（Nested Class）</strong>。根据其定义方式和特性，成员类主要分为以下四种类型：</p>
<h3 id="1-静态成员类（Static-Member-Class）"><a href="#1-静态成员类（Static-Member-Class）" class="headerlink" title="1. 静态成员类（Static Member Class）"></a>1. 静态成员类（Static Member Class）</h3><p><strong>静态成员类</strong>是使用 <code>static</code> 关键字修饰的内部类。它与外部类的实例没有关联，可以像访问静态变量一样，直接通过外部类名来创建它的实例。</p>
<ul>
<li><strong>特点</strong>:<ul>
<li>无法直接访问外部类的非静态成员，但可以访问外部类的静态成员。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>当一个类与外部类逻辑上紧密相关，但又不需要访问外部类的实例成员时，使用静态成员类。它常用于作为外部类的辅助工具类，比如在一个 <code>LinkedList</code> 类中定义一个 <code>Node</code> 静态成员类来表示链表节点。</li>
</ul>
</li>
</ul>
<h3 id="2-内部类（Inner-Class）"><a href="#2-内部类（Inner-Class）" class="headerlink" title="2. 内部类（Inner Class）"></a>2. 内部类（Inner Class）</h3><p><strong>内部类</strong>是没有被 <code>static</code> 关键字修饰的嵌套类。它与外部类的实例紧密相连，必须依附于一个外部类的实例才能被创建。</p>
<ul>
<li><strong>特点</strong>:<ul>
<li>可以直接访问外部类的<strong>所有成员</strong>，包括私有成员。这是内部类最强大的特性。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>当一个类的实例需要直接访问外部类的私有状态时，使用内部类。它常用于实现某些特定功能的回调接口。</li>
</ul>
</li>
</ul>
<h3 id="3-局部内部类（Local-Inner-Class）"><a href="#3-局部内部类（Local-Inner-Class）" class="headerlink" title="3. 局部内部类（Local Inner Class）"></a>3. 局部内部类（Local Inner Class）</h3><p><strong>局部内部类</strong>是定义在方法或代码块内部的类。它只能在定义它的方法或代码块内部被访问和实例化。</p>
<ul>
<li><strong>特点</strong>:<ul>
<li>无法使用访问修饰符（如 <code>public</code>）。</li>
<li>可以访问外部类的所有成员，但只能访问其所在方法中的 <strong>final 或事实上的 final</strong> 局部变量。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>当某个方法中需要一个只用一次的复杂对象或工具类时，可以使用局部内部类，以避免在类级别创建不必要的成员。</li>
</ul>
</li>
</ul>
<h3 id="4-匿名内部类（Anonymous-Inner-Class）"><a href="#4-匿名内部类（Anonymous-Inner-Class）" class="headerlink" title="4. 匿名内部类（Anonymous Inner Class）"></a>4. 匿名内部类（Anonymous Inner Class）</h3><p><strong>匿名内部类</strong>是一种没有名字的局部内部类，通常用于创建一个只使用一次的类的实例。</p>
<ul>
<li><strong>特点</strong>:<ul>
<li>没有名字，因此无法被复用。</li>
<li>必须在<strong>创建实例</strong>的同时定义类的实现。</li>
<li>无法定义构造器。</li>
<li>可以实现一个接口或继承一个类。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>最常用于实现事件监听器或创建线程，尤其是在需要简洁地实现某个接口的单个方法时。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="匿名内部类中的局部变量为什么只能用-final？"><a href="#匿名内部类中的局部变量为什么只能用-final？" class="headerlink" title="匿名内部类中的局部变量为什么只能用 final？"></a>匿名内部类中的局部变量为什么只能用 <code>final</code>？</h3><p>这个限制的根本原因在于<strong>生命周期（Lifecycle）</strong>。</p>
<ol>
<li><strong>局部变量的生命周期</strong>：局部变量（如方法中的参数或变量）是在方法被调用时创建的，存储在**栈（Stack）**上。当方法执行完毕，这些变量就会被销毁。</li>
<li><strong>匿名内部类的生命周期</strong>：匿名内部类的实例通常会作为一个对象被传递或保存，它的生命周期可能<strong>比创建它的方法更长</strong>。例如，你可能会将一个实现了事件监听器的匿名内部类实例作为参数传递给一个 UI 组件，当方法返回后，这个监听器对象可能仍然存在并等待事件触发。</li>
</ol>
<p><strong>问题出现：</strong></p>
<p>如果匿名内部类可以访问和修改一个非 <code>final</code> 的局部变量，那么当创建它的方法执行完毕、局部变量被销毁后，匿名内部类的实例仍然存在。当它试图访问这个已经不存在的变量时，就会引发一个**悬空引用（Dangling Reference）**的错误。</p>
<p>为了解决这个问题，Java 编译器采取了以下策略：</p>
<ul>
<li><strong>将局部变量复制一份</strong>：当匿名内部类访问一个局部变量时，编译器会为它在<strong>堆（Heap）上创建一个副本</strong>。这个副本会和匿名内部类实例一起存储，从而确保匿名内部类在任何时候都能访问到这个值。</li>
<li><strong>强制 final 保证一致性</strong>：如果允许修改原始的局部变量，而匿名内部类使用的是它的副本，那么就会导致原始变量和副本之间的数据不一致。为了避免这种混乱，Java 强制要求被匿名内部类访问的局部变量必须是 <code>final</code> 的，以确保其值不可变。<code>final</code> 关键字保证了原始变量和副本的值始终相同。</li>
</ul>
<h3 id="Java-8-之后的改变：“事实上的-final”（Effectively-Final）"><a href="#Java-8-之后的改变：“事实上的-final”（Effectively-Final）" class="headerlink" title="Java 8 之后的改变：“事实上的 final”（Effectively Final）"></a>Java 8 之后的改变：“事实上的 <code>final</code>”（Effectively Final）</h3><p>在 Java 8 之后，为了简化代码，这个规则有了一些放松。你不再需要显式地使用 <code>final</code> 关键字。只要一个局部变量在定义后<strong>没有被重新赋值</strong>，它就会被编译器自动视为“<strong>事实上的 final</strong>”。</p>
<p>这使得代码看起来更简洁，但<strong>本质上的限制并没有改变</strong>：匿名内部类仍然只能访问那些值在方法执行期间不会改变的局部变量。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>; <span class="comment">// 事实上的 final</span></span><br><span class="line">    <span class="comment">// name = &quot;Bob&quot;; // 如果在这里重新赋值，则会编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 匿名内部类访问局部变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>name</code> 变量没有被 <code>final</code> 修饰，但在它被匿名内部类访问后没有被修改，所以编译器会将其视为事实上的 <code>final</code>，代码可以正常编译和运行。但如果你尝试在 <code>doSomething</code> 方法的 <code>new Thread</code> 之后修改 <code>name</code>，编译器就会报错。</p>
<hr>
<h3 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h3><table>
<thead>
<tr>
<th>类型</th>
<th>关键字</th>
<th>定义位置</th>
<th>访问外部类成员</th>
<th>创建方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>静态成员类</strong></td>
<td><code>static</code></td>
<td>在外部类内部</td>
<td>只能访问外部类的 <strong>静态成员</strong></td>
<td><code>new Outer.StaticInner();</code></td>
</tr>
<tr>
<td><strong>内部类</strong></td>
<td>无</td>
<td>在外部类内部</td>
<td>可访问外部类的<strong>所有成员</strong></td>
<td><code>new Outer().new Inner();</code></td>
</tr>
<tr>
<td><strong>局部内部类</strong></td>
<td>无</td>
<td>在方法或代码块内部</td>
<td>可访问外部成员和 <strong>final 局部变量</strong></td>
<td>只能在定义它的方法内部创建</td>
</tr>
<tr>
<td><strong>匿名内部类</strong></td>
<td>无</td>
<td>在方法或代码块内部</td>
<td>同局部内部类</td>
<td><code>new Interface/Class() &#123; ... &#125;;</code></td>
</tr>
</tbody></table>
<p>匿名内部类、函数式接口和 Lambda 表达式是 Java 语言在不断演进过程中，为了简化代码和支持函数式编程而引入的重要特性。它们经常在面试中被一起考察，因为它们之间存在演变和替代的关系。</p>
<hr>
<h3 id="1-匿名内部类-Anonymous-Inner-Class"><a href="#1-匿名内部类-Anonymous-Inner-Class" class="headerlink" title="1. 匿名内部类 (Anonymous Inner Class)"></a>1. 匿名内部类 (Anonymous Inner Class)</h3><p><strong>匿名内部类</strong>是一种没有名字的局部内部类，通常用于创建一个只使用一次的类的实例。</p>
<ul>
<li><strong>核心特点</strong>:<ul>
<li><strong>没有名字</strong>: 无法被复用。</li>
<li><strong>创建时定义</strong>: 必须在创建实例的同时定义类的实现。</li>
<li><strong>只能实现一个</strong>: 它可以实现一个接口或继承一个类，但不能两者都做。</li>
</ul>
</li>
<li><strong>用途</strong>:<ul>
<li>主要用于简化代码，特别是当一个类只被使用一次，且其实现非常简单时。</li>
<li>常见的应用场景是事件监听器（<code>ActionListener</code>）、线程（<code>Runnable</code>）等。</li>
</ul>
</li>
</ul>
<p>示例:</p>
<p>创建一个线程，实现 Runnable 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from an anonymous inner class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-函数式接口-Functional-Interface"><a href="#2-函数式接口-Functional-Interface" class="headerlink" title="2. 函数式接口 (Functional Interface)"></a>2. 函数式接口 (Functional Interface)</h3><p><strong>函数式接口</strong>是指<strong>只包含一个抽象方法</strong>的接口。它可以包含其他默认方法（<code>default</code>）、静态方法（<code>static</code>）和来自 <code>Object</code> 类的方法（如 <code>equals</code>）。</p>
<ul>
<li><strong>核心特点</strong>:<ul>
<li><strong>一个抽象方法</strong>: 这是函数式接口的唯一强制要求。</li>
<li><strong>@FunctionalInterface 注解</strong>: 这是一个可选的注解，但强烈推荐使用。它会帮助编译器检查该接口是否满足函数式接口的定义，如果违反了规则，就会报错。</li>
</ul>
</li>
</ul>
<p><strong>用途</strong>:</p>
<ul>
<li>它为 Lambda 表达式提供了一个<strong>目标类型</strong>。Lambda 表达式的本质就是函数式接口的一个匿名实现。</li>
<li><code>java.util.function</code> 包中定义了大量的函数式接口，如 <code>Predicate</code>、<code>Consumer</code>、<code>Function</code> 和 <code>Supplier</code>，它们是 Java 8 Stream API 的基础。</li>
</ul>
<p>示例:</p>
<p>一个自定义的函数式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-Lambda-表达式-Lambda-Expression"><a href="#3-Lambda-表达式-Lambda-Expression" class="headerlink" title="3. Lambda 表达式 (Lambda Expression)"></a>3. Lambda 表达式 (Lambda Expression)</h3><p><strong>Lambda 表达式</strong>是 Java 8 引入的一个新特性，它提供了一种简洁的方式来表示<strong>函数式接口的实现</strong>。Lambda 表达式可以被看作是匿名内部类的<strong>简化版本</strong>，用于实现只有一个抽象方法的接口。</p>
<ul>
<li><strong>语法</strong>: <code>(参数列表) -&gt; &#123; 方法体 &#125;</code></li>
<li><strong>核心特点</strong>:<ul>
<li><strong>简洁</strong>: 极大地减少了代码量，省去了匿名内部类的许多样板代码。</li>
<li><strong>函数式编程</strong>: 使得 Java 能够更方便地支持函数式编程范式，如将函数作为参数传递。</li>
<li><strong>类型推断</strong>: 编译器可以根据上下文自动推断参数类型。</li>
</ul>
</li>
</ul>
<p>示例:</p>
<p>使用 Lambda 表达式实现上面的 Runnable 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello from a Lambda expression!&quot;</span>));</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见的面试问题"><a href="#常见的面试问题" class="headerlink" title="常见的面试问题"></a>常见的面试问题</h3><h4 id="1-匿名内部类、Lambda-表达式和函数式接口之间的关系是什么？"><a href="#1-匿名内部类、Lambda-表达式和函数式接口之间的关系是什么？" class="headerlink" title="1. 匿名内部类、Lambda 表达式和函数式接口之间的关系是什么？"></a>1. 匿名内部类、Lambda 表达式和函数式接口之间的关系是什么？</h4><ul>
<li><strong>演变关系</strong>: 匿名内部类是 Java 早期用于实现接口或抽象类的单一方法的笨重方式。函数式接口的出现，为 Lambda 表达式提供了一个<strong>目标类型</strong>。Lambda 表达式就是对只有一个抽象方法的匿名内部类的一种<strong>语法糖</strong>，它极大地简化了代码。</li>
<li><strong>本质</strong>: Lambda 表达式是函数式接口的一个<strong>匿名实现</strong>。</li>
</ul>
<h4 id="2-为什么-Lambda-表达式只能实现函数式接口？"><a href="#2-为什么-Lambda-表达式只能实现函数式接口？" class="headerlink" title="2. 为什么 Lambda 表达式只能实现函数式接口？"></a>2. 为什么 Lambda 表达式只能实现函数式接口？</h4><p>Lambda 表达式的语法（<code>(参数) -&gt; &#123;方法体&#125;</code>）本身就只适用于实现<strong>一个方法</strong>。如果一个接口有两个抽象方法，编译器无法确定 Lambda 表达式的 <code>()</code> 和 <code>&#123;&#125;</code> 对应的是哪个方法，因此会报错。</p>
<h4 id="3-Lambda-表达式和匿名内部类在使用-this-关键字时有什么区别？"><a href="#3-Lambda-表达式和匿名内部类在使用-this-关键字时有什么区别？" class="headerlink" title="3. Lambda 表达式和匿名内部类在使用 this 关键字时有什么区别？"></a>3. Lambda 表达式和匿名内部类在使用 <code>this</code> 关键字时有什么区别？</h4><ul>
<li><strong>匿名内部类</strong>: 匿名内部类有自己的作用域。它内部的 <code>this</code> 关键字指向的是<strong>匿名内部类自身的实例</strong>。</li>
<li><strong>Lambda 表达式</strong>: Lambda 表达式没有自己的作用域。它内部的 <code>this</code> 关键字指向的是<strong>其定义所在类的实例</strong>。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private String name = &quot;Outer&quot;;</span><br><span class="line"></span><br><span class="line">    public void testLambda() &#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(this.name); // 这里的 this 指向 OuterClass 实例</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void testAnonymous() &#123;</span><br><span class="line">        Runnable r = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // System.out.println(this.name); // 编译错误，匿名内部类没有 name 字段</span><br><span class="line">                System.out.println(OuterClass.this.name); // 必须用 OuterClass.this</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Lambda-表达式捕获的局部变量为什么必须是-final-的？"><a href="#4-Lambda-表达式捕获的局部变量为什么必须是-final-的？" class="headerlink" title="4. Lambda 表达式捕获的局部变量为什么必须是 final 的？"></a>4. Lambda 表达式捕获的局部变量为什么必须是 <code>final</code> 的？</h4><p>和匿名内部类一样，Lambda 表达式会<strong>捕获</strong>其外部作用域的局部变量。这些变量在 Lambda 表达式的生命周期中是不可变的，因为它们被复制到了堆中。在 Java 8 之前，你需要显式地用 <code>final</code> 修饰；自 Java 8 之后，只要变量没有被重新赋值，它就是**“事实上的 <code>final</code>”**，可以省略 <code>final</code> 关键字。</p>
<h2 id="Lambda表达式："><a href="#Lambda表达式：" class="headerlink" title="Lambda表达式："></a>Lambda表达式：</h2><p>Lambda 表达式是 Java 8 引入的语法糖，它让你可以用更简洁的方式实现<strong>函数式接口</strong>。它的底层实现机制比你想象的要复杂，但核心思想是利用了新的字节码指令和方法。</p>
<hr>
<h3 id="Lambda-表达式的底层实现"><a href="#Lambda-表达式的底层实现" class="headerlink" title="Lambda 表达式的底层实现"></a>Lambda 表达式的底层实现</h3><p>Lambda 表达式的底层实现依赖于两个关键技术：</p>
<ol>
<li><strong>invokedynamic 指令</strong></li>
<li><strong>方法句柄（Method Handle）</strong></li>
</ol>
<p>在 Java 7 之前，JVM 中只有四种调用方法的指令：<code>invokevirtual</code>、<code>invokeinterface</code>、<code>invokespecial</code> 和 <code>invokestatic</code>。这些指令都是<strong>静态</strong>绑定的，意味着在编译时就确定了调用的目标方法。</p>
<p>然而，Lambda 表达式的调用是<strong>动态</strong>的。编译器在处理 Lambda 表达式时，并不知道它会具体调用哪个方法。因此，Java 7 引入了 <strong>invokedynamic</strong> 指令，它允许在运行时动态地解析和绑定方法调用。</p>
<hr>
<h4 id="编译时：生成-invokedynamic-指令"><a href="#编译时：生成-invokedynamic-指令" class="headerlink" title="编译时：生成 invokedynamic 指令"></a>编译时：生成 <code>invokedynamic</code> 指令</h4><p>当你编写一个 Lambda 表达式时，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Java 编译器在编译时并不会直接生成一个匿名内部类。相反，它会做以下事情：</p>
<ol>
<li><strong>将 Lambda 表达式体转换为一个私有方法</strong>：编译器会把 <code>System.out.println(&quot;Hello&quot;)</code> 这段代码提取出来，生成一个<strong>新的私有方法</strong>，通常是 <code>private static</code> 或 <code>private</code> 类型，并带有特殊的命名规则（比如 <code>lambda$main$0</code>）。这个新方法包含了 Lambda 表达式的实际逻辑。</li>
<li><strong>生成 invokedynamic 指令</strong>：在 Lambda 表达式出现的地方，编译器会生成一条 <code>invokedynamic</code> 指令。这条指令不会直接调用上一步生成的私有方法。相反，它指向一个<strong>引导方法（Bootstrap Method）</strong>。</li>
</ol>
<p><code>invokedynamic</code> 指令的结构大致如下：</p>
<p><code>invokedynamic #0:run:()Ljava/lang/Runnable;</code></p>
<ul>
<li><code>#0</code> 是一个常量池索引，指向引导方法（通常是 <code>java.lang.invoke.LambdaMetafactory.metafactory</code>）。</li>
<li><code>run</code> 是函数式接口中抽象方法的名称。</li>
<li><code>()Ljava/lang/Runnable;</code> 是函数式接口的签名。</li>
</ul>
<h4 id="运行时：动态绑定"><a href="#运行时：动态绑定" class="headerlink" title="运行时：动态绑定"></a>运行时：动态绑定</h4><p>当 JVM 执行到 <code>invokedynamic</code> 指令时，它会执行以下步骤：</p>
<ol>
<li><strong>调用引导方法</strong>：JVM 会调用 <code>LambdaMetafactory.metafactory</code> 引导方法。这个方法是 Lambda 表达式的**“工厂”<strong>，它负责生成一个</strong>方法句柄（Method Handle）**。</li>
<li><strong>生成方法句柄</strong>：方法句柄是一个轻量级的、类似于 <code>java.lang.reflect.Method</code> 的引用，但它更高效，可以直接调用。它指向编译时生成的那个私有方法（即 Lambda 表达式的实际逻辑）。</li>
<li><strong>生成调用点对象</strong>：<code>LambdaMetafactory.metafactory</code> 返回一个**<code>CallSite</code>**对象，这个对象持有一个指向方法句柄的引用。这个 <code>CallSite</code> 会被缓存起来。</li>
<li><strong>执行方法调用</strong>：<code>invokedynamic</code> 指令会直接跳转到 <code>CallSite</code> 对象中的方法句柄，然后执行实际的 Lambda 表达式代码。</li>
</ol>
<h3 id="Lambda-表达式与匿名内部类的区别"><a href="#Lambda-表达式与匿名内部类的区别" class="headerlink" title="Lambda 表达式与匿名内部类的区别"></a>Lambda 表达式与匿名内部类的区别</h3><p>理解底层实现后，两者在性能和设计上有一些关键区别：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Lambda 表达式</th>
<th>匿名内部类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>生成方式</strong></td>
<td>动态生成私有方法和 <code>invokedynamic</code> 指令</td>
<td>编译时生成独立的 <code>.class</code> 文件</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>通常更快。<strong>invokedynamic 优化了性能</strong>，避免了每次都创建新对象和执行 <code>invokespecial</code> 指令。</td>
<td>每次使用都会创建一个新的对象实例，并生成一个额外的类文件。</td>
</tr>
<tr>
<td><strong>作用域</strong></td>
<td>没有自己的作用域，<code>this</code> 关键字指向外部类的实例。</td>
<td>有自己的作用域，<code>this</code> 关键字指向匿名内部类实例本身。</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td><strong>更小</strong>。由于采用了方法句柄，避免了为每个 Lambda 表达式创建独立的匿名类对象。</td>
<td>会产生额外的 <code>.class</code> 文件和对象实例，内存开销更大。</td>
</tr>
</tbody></table>
<p>总结来说，Lambda 表达式的底层实现是一种<strong>延迟创建</strong>和<strong>动态绑定</strong>的机制。编译器在编译时只留下一个调用指令，将真正的实现工作推迟到运行时。这种设计使得 Lambda 表达式在保持代码简洁的同时，也带来了更高的性能。</p>
<h2 id="switch语句支持的数据类型："><a href="#switch语句支持的数据类型：" class="headerlink" title="switch语句支持的数据类型："></a>switch语句支持的数据类型：</h2><p><code>switch</code> 语句是 Java 中一个非常实用的控制流语句，它能够根据变量的值来选择不同的执行路径。从 Java 7 开始，<code>switch</code> 语句支持的数据类型有了显著的扩展。</p>
<p><code>switch</code> 语句作用的数据类型包括：</p>
<hr>
<h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a><strong>1. 基本数据类型</strong></h3><ul>
<li><strong>byte</strong></li>
<li><strong>short</strong></li>
<li><strong>char</strong></li>
<li><strong>int</strong></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><code>switch</code> 语句不支持 <code>long</code>、<code>float</code>、<code>double</code> 或 <code>boolean</code> 类型。</li>
<li>如果你的变量是 <code>long</code> 类型，你需要将其强制转换为 <code>int</code> 类型才能在 <code>switch</code> 中使用，但这可能导致数据丢失，通常不推荐。</li>
</ul>
<hr>
<h3 id="2-包装类"><a href="#2-包装类" class="headerlink" title="2. 包装类"></a><strong>2. 包装类</strong></h3><ul>
<li><strong>Byte</strong></li>
<li><strong>Short</strong></li>
<li><strong>Character</strong></li>
<li><strong>Integer</strong></li>
</ul>
<p>这是因为 Java 编译器在编译时会进行<strong>自动拆箱（autounboxing）</strong>，将包装类对象自动转换为对应的基本数据类型。</p>
<hr>
<h3 id="3-枚举类型-enum"><a href="#3-枚举类型-enum" class="headerlink" title="3. 枚举类型 (enum)"></a><strong>3. 枚举类型 (enum)</strong></h3><ul>
<li><strong>从 Java 5 开始</strong>，<code>switch</code> 语句开始支持枚举类型。</li>
<li>使用枚举可以使代码更具可读性和安全性，因为编译器会检查所有 <code>case</code> 标签是否对应了枚举中的有效常量。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Day</span> <span class="variable">day</span> <span class="operator">=</span> Day.MONDAY;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s Monday.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s Sunday.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s a weekday.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-String-类型"><a href="#4-String-类型" class="headerlink" title="4. String 类型"></a><strong>4. String 类型</strong></h3><ul>
<li><strong>从 Java 7 开始</strong>，<code>switch</code> 语句开始支持 <code>String</code> 类型。</li>
<li>这个特性极大地简化了基于字符串的条件判断代码，避免了大量的 <code>if-else if-else</code> 链。</li>
<li>在底层，编译器通过 <code>String</code> 对象的 <code>hashCode()</code> 和 <code>equals()</code> 方法来执行 <code>switch</code> 逻辑。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;You chose an apple.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;orange&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;You chose an orange.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown fruit.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th>支持类型</th>
<th>版本</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code></td>
<td>所有版本</td>
<td><code>switch</code> 的基础类型。</td>
</tr>
<tr>
<td><code>Byte</code>, <code>Short</code>, <code>Character</code>, <code>Integer</code></td>
<td>所有版本</td>
<td>自动拆箱机制使其可用。</td>
</tr>
<tr>
<td><code>enum</code></td>
<td>Java 5+</td>
<td>增强代码的可读性和安全性。</td>
</tr>
<tr>
<td><code>String</code></td>
<td>Java 7+</td>
<td>极大地简化了字符串判断逻辑。</td>
</tr>
</tbody></table>
<p>记住，无论使用哪种类型，<code>case</code> 标签后面的值都必须是<strong>编译时常量</strong>。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="1-内置锁：synchronized-关键字"><a href="#1-内置锁：synchronized-关键字" class="headerlink" title="1. 内置锁：synchronized 关键字"></a>1. 内置锁：<code>synchronized</code> 关键字</h3><p><code>synchronized</code>是Java语言层面的同步机制，使用起来相对简单。它可以修饰方法或代码块，由JVM负责加锁和释放锁，开发者不需要手动管理。</p>
<ul>
<li><strong>同步方法：</strong> 当你用<code>synchronized</code>修饰一个非静态方法时，锁对象是这个方法的实例对象（<code>this</code>）。当一个线程进入这个同步方法时，它会获得该实例的锁，其他线程就无法进入这个实例的任何同步方法，直到它释放锁。</li>
<li><strong>同步静态方法：</strong> 当<code>synchronized</code>修饰一个静态方法时，锁对象是该类的<code>Class</code>对象。这意味着所有线程在访问这个类的任何同步静态方法时都会争抢同一把锁，无论有多少个实例。</li>
<li><strong>同步代码块：</strong> <code>synchronized (object)</code>。这是最灵活的使用方式，你可以指定任何对象作为锁。通过缩小同步范围，可以减少锁的持有时间，从而提高程序的并发性能。</li>
</ul>
<p><strong>synchronized的特点：</strong></p>
<ul>
<li><strong>可重入性（Reentrant）：</strong> 一个线程可以重复获取它已经持有的锁，避免死锁。</li>
<li><strong>非公平性（Unfair）：</strong> 默认情况下，线程获取锁的顺序是不确定的，先来的不一定先得到。</li>
<li><strong>锁的升级：</strong> 为了优化性能，<code>synchronized</code>锁的实现经历了从<strong>偏向锁</strong>、<strong>轻量级锁</strong>到<strong>重量级锁</strong>的升级过程。这使得在竞争不激烈的情况下，加锁的开销非常小。</li>
<li><strong>内存可见性（Visibility）：</strong> <code>synchronized</code>可以保证当一个线程释放锁时，它对共享变量所做的修改会立即刷新到主内存，而当另一个线程获取锁时，它会从主内存中读取最新的变量值。这是由Java内存模型（JMM）的<code>happens-before</code>规则保证的。</li>
</ul>
<h3 id="底层实现机制"><a href="#底层实现机制" class="headerlink" title="底层实现机制"></a>底层实现机制</h3><p>synchronized本质上是基于JVM的**内置锁（Intrinsic Lock）**实现的。每个Java对象都天生具备一个监视器锁（Monitor），这是JVM级别的原生支持。</p>
<p><strong>监视器的工作原理：</strong></p>
<ul>
<li>当线程进入synchronized代码块时，会执行monitorenter指令获取对象的监视器</li>
<li>当线程退出时，执行monitorexit指令释放监视器</li>
<li>如果获取失败，线程会被阻塞在操作系统级别</li>
</ul>
<h3 id="锁升级的演进过程"><a href="#锁升级的演进过程" class="headerlink" title="锁升级的演进过程"></a>锁升级的演进过程</h3><p>synchronized的性能优化经历了一个复杂的演进过程，从最初的重量级锁逐步优化：</p>
<p><strong>偏向锁阶段：</strong><br>当只有一个线程反复进入同步块时，JVM会将锁偏向于这个线程。此时的开销极低，几乎等同于无锁操作。对象头中会记录偏向的线程ID，后续该线程进入时直接通过简单的比较就能获取锁。</p>
<p><strong>轻量级锁阶段：</strong><br>当有其他线程开始竞争时，偏向锁会升级为轻量级锁。JVM在当前线程的栈帧中创建锁记录（Lock Record），通过CAS操作尝试将对象头的Mark Word替换为指向锁记录的指针。这个过程避免了操作系统层面的阻塞。</p>
<p><strong>重量级锁阶段：</strong><br>当CAS操作失败次数过多或者有多个线程同时竞争时，锁会膨胀为重量级锁。此时会创建Monitor对象，利用操作系统的互斥量（Mutex）来实现同步，涉及用户态和内核态的切换。</p>
<p>好的，我帮你把 <strong>JVM 锁升级过程</strong> 优化排版，整理成条理清晰、易于理解的版本，并加上一些注释说明，让整个流程更直观。</p>
<hr>
<h1 id="JVM-锁的升级过程"><a href="#JVM-锁的升级过程" class="headerlink" title="JVM 锁的升级过程"></a>JVM 锁的升级过程</h1><p>JVM 的对象锁在多线程访问时会经历 <strong>偏向锁 → 轻量级锁 → 重量级锁</strong> 的升级过程。下面详细说明每一步。</p>
<hr>
<h2 id="1-普通对象（无锁状态）"><a href="#1-普通对象（无锁状态）" class="headerlink" title="1. 普通对象（无锁状态）"></a>1. 普通对象（无锁状态）</h2><ul>
<li>对象未被任何线程持有锁时：<ul>
<li>Mark Word 中记录 <strong>对象的 HashCode</strong>。</li>
<li>锁标志位：<code>01</code>（表示无锁）。</li>
<li>是否偏向锁位：<code>0</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>此时对象只是普通对象，没有同步锁。</p>
</blockquote>
<hr>
<h2 id="2-偏向锁初始化（第一次加锁）"><a href="#2-偏向锁初始化（第一次加锁）" class="headerlink" title="2. 偏向锁初始化（第一次加锁）"></a>2. 偏向锁初始化（第一次加锁）</h2><ul>
<li>线程 <strong>A</strong> 获取锁：<ul>
<li>锁标志位仍为 <code>01</code>（无锁标志）。</li>
<li>偏向锁标志位改为 <code>1</code>，表示对象进入 <strong>偏向锁状态</strong>。</li>
<li>Mark Word 的前 23 bit 保存 <strong>线程 A 的线程 ID</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>偏向锁用于优化单线程访问锁的性能，减少同步开销。</p>
</blockquote>
<hr>
<h2 id="3-偏向锁重入（线程-A-再次获取锁）"><a href="#3-偏向锁重入（线程-A-再次获取锁）" class="headerlink" title="3. 偏向锁重入（线程 A 再次获取锁）"></a>3. 偏向锁重入（线程 A 再次获取锁）</h2><ul>
<li>线程 <strong>A</strong> 再次尝试获取锁：<ul>
<li>JVM 检查对象标志位：<ul>
<li>锁标志位 <code>01</code></li>
<li>偏向锁位 <code>1</code></li>
<li>Mark Word 中线程 ID &#x3D; A 的 ID</li>
</ul>
</li>
<li>由于线程 A 已持有偏向锁，直接进入同步代码，无需 CAS 操作。</li>
</ul>
</li>
</ul>
<blockquote>
<p>偏向锁允许线程重复获取锁，性能开销极低。</p>
</blockquote>
<hr>
<h2 id="4-偏向锁竞争（线程-B-尝试获取锁）"><a href="#4-偏向锁竞争（线程-B-尝试获取锁）" class="headerlink" title="4. 偏向锁竞争（线程 B 尝试获取锁）"></a>4. 偏向锁竞争（线程 B 尝试获取锁）</h2><ul>
<li>线程 <strong>B</strong> 尝试获取锁：<ul>
<li>JVM 检查对象偏向锁：<ul>
<li>锁标志位 <code>01</code></li>
<li>偏向锁位 <code>1</code></li>
<li>Mark Word 中线程 ID ≠ B</li>
</ul>
</li>
<li>线程 B <strong>尝试通过 CAS 抢锁</strong>：<ul>
<li>成功：偏向锁切换到线程 B，Mark Word 更新为 B 的线程 ID</li>
<li>失败：表示竞争存在，进入下一步升级轻量级锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>偏向锁竞争失败时，说明锁开始有多线程访问，需要升级锁状态。</p>
</blockquote>
<hr>
<h2 id="5-轻量级锁（Lightweight-Lock）"><a href="#5-轻量级锁（Lightweight-Lock）" class="headerlink" title="5. 轻量级锁（Lightweight Lock）"></a>5. 轻量级锁（Lightweight Lock）</h2><ul>
<li>JVM 为当前线程在 <strong>栈帧</strong>中分配一块空间，称为 <strong>锁记录区（Lock Record）</strong>：<ul>
<li>保存指向对象 Mark Word 的指针</li>
</ul>
</li>
<li>对象 Mark Word 保存指向锁记录区的指针</li>
<li>CAS 操作同时更新两处指针：<ul>
<li>成功：线程获得轻量级锁，执行同步代码，锁标志位改为 <code>00</code>（轻量级锁状态）</li>
<li>失败：竞争激烈，进入自旋阶段</li>
</ul>
</li>
</ul>
<blockquote>
<p>轻量级锁适合 <strong>多线程少量竞争</strong> 场景，性能较好。</p>
</blockquote>
<hr>
<h2 id="6-自旋锁（Spin-Lock）"><a href="#6-自旋锁（Spin-Lock）" class="headerlink" title="6. 自旋锁（Spin Lock）"></a>6. 自旋锁（Spin Lock）</h2><ul>
<li>线程尝试获取轻量级锁失败：<ul>
<li>JVM <strong>自旋重试</strong>（循环尝试抢锁）</li>
<li>自旋次数由 JVM 决定（JDK 1.7 默认启用）</li>
<li>成功：执行同步代码</li>
<li>失败：锁升级为重量级锁</li>
</ul>
</li>
</ul>
<blockquote>
<p>自旋锁适合锁竞争短暂的情况，避免线程阻塞带来的开销。</p>
</blockquote>
<hr>
<h2 id="7-重量级锁（Heavyweight-Lock）"><a href="#7-重量级锁（Heavyweight-Lock）" class="headerlink" title="7. 重量级锁（Heavyweight Lock）"></a>7. 重量级锁（Heavyweight Lock）</h2><ul>
<li>自旋失败后，锁升级为 <strong>重量级锁</strong>：<ul>
<li>锁标志位改为 <code>10</code></li>
<li>线程未抢到锁的会被阻塞（挂起）</li>
<li>系统线程调度负责唤醒等待线程</li>
</ul>
</li>
</ul>
<blockquote>
<p>重量级锁性能开销较大，使用操作系统互斥机制。<br> 只有当轻量级锁和自旋锁都无法满足需求时才会升级。</p>
</blockquote>
<hr>
<h2 id="🔑-总结锁升级过程"><a href="#🔑-总结锁升级过程" class="headerlink" title="🔑 总结锁升级过程"></a>🔑 总结锁升级过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">无锁状态（01 + 偏向位0）</span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">偏向锁（01 + 偏向位1 + 线程ID）</span><br><span class="line">       │</span><br><span class="line">       ▼   线程竞争</span><br><span class="line">轻量级锁（00 + 指向栈帧锁记录区）</span><br><span class="line">       │</span><br><span class="line">       ▼   CAS 失败 / 高竞争</span><br><span class="line">自旋锁（不断自旋尝试抢锁）</span><br><span class="line">       │</span><br><span class="line">       ▼   自旋失败</span><br><span class="line">重量级锁（10 + 阻塞等待）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JVM 通过 <strong>锁膨胀机制</strong>（Lock Inflation）逐步升级锁，尽量在多线程争用情况下保证性能。</p>
</blockquote>
<h3 id="自动化的特点"><a href="#自动化的特点" class="headerlink" title="自动化的特点"></a>自动化的特点</h3><p>synchronized的最大特点是<strong>完全自动化</strong>。程序员无需关心锁的获取和释放时机，JVM会自动处理所有细节。即使在异常情况下，JVM也能保证锁的正确释放，这大大降低了死锁和资源泄露的风险。</p>
<h3 id="2-显式锁：java-util-concurrent-locks-Lock"><a href="#2-显式锁：java-util-concurrent-locks-Lock" class="headerlink" title="2. 显式锁：java.util.concurrent.locks.Lock"></a>2. 显式锁：<code>java.util.concurrent.locks.Lock</code></h3><p>从JDK 1.5开始，<code>java.util.concurrent.locks</code>包提供了更灵活、更强大的锁机制，其核心是<code>Lock</code>接口。最常用的实现类是**<code>ReentrantLock</code>**。</p>
<p>使用<code>Lock</code>需要手动进行加锁和解锁操作，通常是在<code>try...finally</code>块中进行，以确保锁在任何情况下都能被释放，防止死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 访问共享资源的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lock相比synchronized的优势：</strong></p>
<ul>
<li><strong>中断锁（Interruptibly）：</strong> <code>Lock</code>提供了<code>lockInterruptibly()</code>方法，允许在等待锁的过程中响应中断。而<code>synchronized</code>的线程如果陷入等待锁的状态，是无法被中断的。</li>
<li><strong>尝试获取锁（tryLock）：</strong> <code>Lock</code>提供了<code>tryLock()</code>和<code>tryLock(long timeout, TimeUnit unit)</code>方法，可以尝试获取锁，如果失败则立即返回或在指定时间内放弃，避免无限等待。</li>
<li><strong>公平锁与非公平锁：</strong> <code>ReentrantLock</code>可以创建公平锁（Fair Lock）。公平锁会按照线程请求锁的顺序来分配锁，虽然这可能会带来一些性能开销。而<code>synchronized</code>只能是非公平锁。</li>
<li><strong>绑定多个条件（Condition）：</strong> <code>Lock</code>配合<code>Condition</code>接口，可以实现更灵活的线程等待和唤醒机制，类似<code>Object</code>的<code>wait()</code>和<code>notify()</code>，但功能更强大，一个锁可以有多个等待队列。</li>
<li><strong>读写锁（ReadWriteLock）：</strong> <code>ReadWriteLock</code>是<code>Lock</code>的另一个重要实现，它维护了一对锁：一个用于读操作，一个用于写操作。在读多写少的场景下，多个线程可以同时获取读锁，大大提高了并发性能，只有写操作才需要获取独占的写锁。<code>ReentrantReadWriteLock</code>是其具体实现。</li>
</ul>
<h3 id="Lock接口的设计理念"><a href="#Lock接口的设计理念" class="headerlink" title="Lock接口的设计理念"></a>Lock接口的设计理念</h3><h3 id="显式锁机制"><a href="#显式锁机制" class="headerlink" title="显式锁机制"></a>显式锁机制</h3><p>Lock接口代表了Java并发包中<strong>显式锁</strong>的设计思想。与synchronized的隐式锁不同，Lock要求程序员明确控制锁的生命周期，这带来了更大的灵活性，同时也增加了使用的复杂性。</p>
<h3 id="AQS框架的核心思想"><a href="#AQS框架的核心思想" class="headerlink" title="AQS框架的核心思想"></a>AQS框架的核心思想</h3><p>Lock接口的实现基于AbstractQueuedSynchronizer（AQS）框架，这是Doug Lea设计的一个并发框架的杰作。</p>
<p><strong>同步状态的抽象：</strong><br>AQS使用一个int值来表示同步状态，不同的锁实现可以赋予这个状态不同的含义。比如ReentrantLock用它表示重入次数，Semaphore用它表示许可证数量。</p>
<p><strong>队列化的等待机制：</strong><br>当线程无法获取锁时，AQS会将其包装成节点加入到一个FIFO队列中。这个队列使用双向链表实现，每个节点都包含了线程引用和等待状态信息。</p>
<p><strong>自旋与阻塞的平衡：</strong><br>AQS巧妙地结合了自旋和阻塞两种等待策略。线程在入队后会先进行有限次数的自旋尝试，只有在确定无法获取锁时才会调用LockSupport.park()进入阻塞状态。</p>
<h3 id="3-volatile-关键字"><a href="#3-volatile-关键字" class="headerlink" title="3. volatile 关键字"></a>3. <code>volatile</code> 关键字</h3><p><code>volatile</code>关键字并不是一个锁，它是一种轻量级的同步机制，主要用于保证共享变量的<strong>可见性</strong>和<strong>有序性</strong>。</p>
<ul>
<li><strong>可见性（Visibility）：</strong> 当一个变量被<code>volatile</code>修饰后，一个线程对它的修改会立即被其他线程可见。这是通过在写操作后添加内存屏障，强制将修改后的值刷新到主内存，并在读操作前添加内存屏障，强制从主内存中读取最新值来实现的。</li>
<li><strong>有序性（Ordering）：</strong> <code>volatile</code>可以禁止指令重排序，确保代码的执行顺序不会被打乱。</li>
<li><strong>无法保证原子性（Atomicity）：</strong> <code>volatile</code>无法保证复合操作（如<code>i++</code>）的原子性，因为<code>i++</code>实际上是读、加、写三个操作的组合，这三个操作并非一次完成。如果要保证原子性，需要使用<code>synchronized</code>、<code>Lock</code>或<code>java.util.concurrent.atomic</code>包下的原子类。</li>
</ul>
<p><strong>总结一下：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>synchronized</code></th>
<th><code>Lock</code> (如<code>ReentrantLock</code>)</th>
<th><code>volatile</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>功能</strong></td>
<td>独占锁，保证原子性、可见性、有序性</td>
<td>独占锁，功能更强大，保证原子性、可见性、有序性</td>
<td>轻量级同步，只保证可见性和有序性</td>
</tr>
<tr>
<td><strong>使用方式</strong></td>
<td>关键字，自动加锁和解锁</td>
<td>接口，需要手动加锁和解锁，必须在<code>finally</code>块中释放</td>
<td>关键字，修饰变量</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>较差，功能固定</td>
<td>强，提供了更多高级功能，如可中断、超时、公平锁等</td>
<td>较差，只针对变量</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>JVM优化后性能较高，开销相对较小</td>
<td>高性能，在竞争激烈时通常优于<code>synchronized</code></td>
<td>非常高，几乎没有开销</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单的同步需求，大部分情况都适用</td>
<td>高级同步需求，需要灵活控制锁的获取和释放</td>
<td>变量的写操作不依赖于当前值，需要保证变量的可见性。</td>
</tr>
</tbody></table>
<h3 id="4-乐观锁-Optimistic-Locking"><a href="#4-乐观锁-Optimistic-Locking" class="headerlink" title="4. 乐观锁 (Optimistic Locking)"></a>4. 乐观锁 (Optimistic Locking)</h3><p>与之前讨论的<strong>悲观锁</strong>（<code>synchronized</code>和<code>Lock</code>）不同，乐观锁并非一个具体的Java关键字或类，而是一种<strong>并发控制的思想和策略</strong>。悲观锁认为“总会有其他线程来修改数据”，所以在访问共享资源前，先对资源加锁，确保独占访问。而乐观锁则认为“数据冲突发生的概率很小”，所以它<strong>不加锁</strong>，而是假设所有线程都能正常执行，只有在数据更新提交时，才去检查在此期间数据是否被其他线程修改过。</p>
<p>如果检查到数据没有被修改，则更新成功。如果发现数据已经被修改，则更新失败。处理失败的方式通常有两种：</p>
<ol>
<li><strong>重试：</strong> 循环尝试，直到更新成功为止。</li>
<li><strong>放弃：</strong> 抛出异常或直接返回失败，由调用方处理。</li>
</ol>
<p><strong>乐观锁的实现方式：</strong></p>
<p>乐观锁的核心在于如何“检查数据是否被修改”。在Java中，常见的实现方式有两种：</p>
<ul>
<li><p>版本号（Version Number）：</p>
<p>在数据表中增加一个version字段。每次读取数据时，也把version字段读出来。当要进行数据更新时，带上之前读取的version值，在更新语句中加入WHERE version &#x3D; &lt;当前版本号&gt;的条件。如果更新成功，同时把version值加1。</p>
<ul>
<li><p><strong>SQL示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE products <span class="type">SET</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">100</span>, version = version + <span class="number">1</span></span><br><span class="line"><span class="type">WHERE</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">123</span> <span class="type">AND</span> <span class="variable">version</span> <span class="operator">=</span> &lt;之前读取的版本号&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原理：</strong> 如果在更新时，其他线程已经修改了这条数据，那么<code>version</code>值已经改变，上述<code>UPDATE</code>语句的<code>WHERE</code>条件将不成立，导致更新失败，影响行数为0。此时，你可以选择重试或放弃。</p>
</li>
</ul>
</li>
<li><p>CAS (Compare-And-Swap) 算法：</p>
<p>这是乐观锁在硬件层面的支持，也是Java中实现乐观锁的核心机制。CAS是一种原子操作，它包含三个操作数：</p>
<ul>
<li><strong>V (Value)：</strong> 内存地址中存放的旧值。</li>
<li><strong>A (Expected)：</strong> 预期的旧值。</li>
<li><strong>B (New)：</strong> 想要写入的新值。</li>
</ul>
<p>CAS的操作逻辑是：</p>
<p>如果内存地址V中的值等于预期值A，那么就将V的值更新为新值B。否则，什么都不做。整个操作是原子性的，由CPU指令直接完成。</p>
<p>Java中<code>java.util.concurrent.atomic</code>包下的所有原子类，如<code>AtomicInteger</code>、<code>AtomicLong</code>等，都是基于CAS实现的。</p>
<p><strong>AtomicInteger示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="comment">// 假设多个线程同时执行以下操作</span></span><br><span class="line">count.incrementAndGet(); <span class="comment">// 内部就是CAS操作</span></span><br></pre></td></tr></table></figure>

<p><code>incrementAndGet()</code>方法的内部实现类似于一个自旋重试的循环：</p>
<ol>
<li>获取当前值<code>current</code>。</li>
<li>计算新值<code>next = current + 1</code>。</li>
<li>使用CAS尝试将<code>current</code>更新为<code>next</code>。</li>
<li>如果更新失败（说明<code>current</code>已经被其他线程修改），则重新回到第一步，再次获取最新值并尝试更新。</li>
</ol>
</li>
</ul>
<p><strong>悲观锁与乐观锁的比较：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>悲观锁 (<code>synchronized</code>, <code>Lock</code>)</th>
<th>乐观锁 (CAS, 版本号)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>加锁方式</strong></td>
<td>独占资源时先加锁，阻止其他线程访问</td>
<td>不加锁，只在提交时进行冲突检测</td>
</tr>
<tr>
<td><strong>冲突处理</strong></td>
<td>线程排队等待锁，串行执行</td>
<td>线程失败后重试或放弃，并发执行</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td><strong>写操作多、竞争激烈</strong>的场景。数据冲突概率高。</td>
<td><strong>读操作多、写操作少</strong>的场景。数据冲突概率低。</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>在高竞争环境下，线程切换和上下文开销大，性能下降。</td>
<td>在低竞争环境下，无锁开销，性能极高。在高竞争环境下，大量重试可能导致CPU开销增加。</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<p>在Java中，<strong>悲观锁</strong>和<strong>乐观锁</strong>是两种截然不同的并发控制策略。悲观锁（<code>synchronized</code>, <code>Lock</code>）适合<strong>写多读少</strong>的场景，能够保证数据的一致性，但会牺牲一定的性能。而乐观锁（<strong>CAS</strong>、<strong>版本号</strong>）则适合<strong>读多写少</strong>的场景，通过无锁的并发操作提高了性能，但在高竞争下可能导致频繁重试，反而降低效率。理解这两种锁的思想，可以帮助你根据具体的业务场景选择最合适的并发控制方案。</p>
<p>好的，我们来继续完善Java中关于锁的介绍，增加<strong>死锁</strong>及其解决方案的内容。</p>
<hr>
<h3 id="5-死锁-Deadlock"><a href="#5-死锁-Deadlock" class="headerlink" title="5. 死锁 (Deadlock)"></a>5. 死锁 (Deadlock)</h3><p><strong>死锁</strong>是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法继续执行。</p>
<p><strong>死锁的产生</strong>是一个非常经典的多线程问题，通常发生在线程需要同时持有多个锁的场景中。一个简单的死锁场景是：线程A持有锁1，想获取锁2；而线程B持有锁2，想获取锁1。此时两个线程都无法继续执行，从而进入死锁状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h4><p>死锁的发生需要同时满足以下四个条件，缺一不可：</p>
<ol>
<li><strong>互斥条件（Mutual Exclusion）：</strong> 至少有一个资源是独占的，即一次只能被一个线程使用。这是锁本身的基本特性。</li>
<li><strong>请求与保持条件（Hold and Wait）：</strong> 一个线程因请求资源而阻塞时，它对自己已获得的资源保持不放。</li>
<li><strong>不剥夺条件（No Preemption）：</strong> 线程已获得的资源在未使用完之前，不能被强行剥夺，只能由该线程自己释放。</li>
<li><strong>循环等待条件（Circular Wait）：</strong> 存在一个线程等待链，其中每个线程都持有下一个线程所需的资源。例如：线程A等待线程B，线程B等待线程C，线程C又等待线程A。</li>
</ol>
<h4 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h4><p>解决死锁的根本思想是<strong>破坏上述四个必要条件之一或多个</strong>。通常，我们无法破坏互斥条件（因为资源就是独占的），因此主要从其他三个条件入手。</p>
<ol>
<li><strong>破坏“请求与保持”条件：</strong><ul>
<li><strong>一次性获取所有锁：</strong> 线程在开始执行时，就一次性获取所有需要的锁。如果获取不成功，则释放所有已获得的锁，然后等待一段时间后再次尝试。</li>
<li><strong>优点：</strong> 简单有效。</li>
<li><strong>缺点：</strong> 可能会降低并发性，因为线程在很早就持有了锁，即使这些锁在后面才被使用。</li>
</ul>
</li>
<li><strong>破坏“不剥夺”条件：</strong><ul>
<li><strong>使用可中断的锁：</strong> 使用<code>Lock</code>接口提供的<code>tryLock()</code>方法。当一个线程尝试获取锁失败时，它可以选择放弃并释放已持有的锁，而不是一直等待。<code>Lock.tryLock(long time, TimeUnit unit)</code>方法可以在指定时间内尝试获取锁，超时后会放弃。</li>
<li><strong>优点：</strong> 提高了灵活性，线程可以响应中断或超时，避免无限等待。</li>
<li><strong>缺点：</strong> 实现起来相对复杂，需要开发者手动处理获取锁失败的情况。</li>
</ul>
</li>
<li><strong>破坏“循环等待”条件：</strong><ul>
<li><strong>按顺序获取锁：</strong> 对所有的锁进行排序，并强制所有线程都按照相同的顺序获取锁。</li>
<li><strong>示例：</strong> 如果线程A和线程B都需要<code>lock1</code>和<code>lock2</code>，那么它们都必须先获取<code>lock1</code>，再获取<code>lock2</code>。这样就杜绝了线程A持有<code>lock1</code>等待<code>lock2</code>，同时线程B持有<code>lock2</code>等待<code>lock1</code>的循环。</li>
<li><strong>优点：</strong> 这是最常用、最有效的死锁解决方案，实现起来也相对简单。</li>
<li><strong>缺点：</strong> 有时很难对所有锁进行全局排序，特别是在代码模块化程度较高、依赖关系复杂的情况下。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>在实际开发中，预防死锁的最佳实践通常是<strong>破坏循环等待条件</strong>，即<strong>统一锁的获取顺序</strong>。这是最简单且最有效的方案。如果业务场景需要更灵活的控制，可以考虑使用<code>Lock</code>接口，利用<code>tryLock()</code>方法来破坏“不剥夺”条件，实现更复杂的死锁处理逻辑。</p>
<p>好的，我们来详细介绍<strong>银行家算法 (Banker’s Algorithm)</strong>。</p>
<hr>
<h3 id="银行家算法概述"><a href="#银行家算法概述" class="headerlink" title="银行家算法概述"></a>银行家算法概述</h3><p>银行家算法是一种著名的<strong>死锁避免算法</strong>，由荷兰计算机科学家Dijkstra在1965年提出。它的核心思想是：在每次分配资源之前，先进行一次<strong>安全性检查</strong>。如果分配后系统仍然处于<strong>安全状态</strong>，则分配资源；否则，不予分配，线程需要等待。</p>
<ul>
<li>优点：比死锁预防更灵活，能提高资源利用率。</li>
<li>缺点：算法复杂，需要预知进程的最大资源需求，并且系统开销大。</li>
</ul>
<p>之所以叫“银行家算法”，是因为它的工作原理类似于银行管理贷款。银行家在发放贷款时，会先确保这笔贷款发放后，自己还有足够的资金来满足所有客户可能提出的最大取款需求，从而避免因无法支付而破产的风险。</p>
<p>简单来说，银行家算法通过以下两个步骤来避免死锁：</p>
<ol>
<li><strong>安全状态的定义：</strong> 系统能够找到一个<strong>安全序列</strong>，使得所有线程都能按照这个序列执行完毕。</li>
<li><strong>资源分配策略：</strong> 当一个线程请求资源时，算法会先假设分配成功，然后检查系统是否仍处于安全状态。如果安全，就真的分配；如果不安全，就拒绝分配。</li>
</ol>
<hr>
<h3 id="银行家算法中的几个重要数据结构"><a href="#银行家算法中的几个重要数据结构" class="headerlink" title="银行家算法中的几个重要数据结构"></a>银行家算法中的几个重要数据结构</h3><p>为了实现算法，需要维护以下几个关键数据结构，假设系统中有<code>n</code>个线程和<code>m</code>种资源：</p>
<ul>
<li><strong>Available (可用资源矩阵)：</strong> 一个长度为<code>m</code>的向量。<code>Available[j]</code>表示第<code>j</code>种资源目前可用的数量。</li>
<li><strong>Max (最大需求矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Max[i, j]</code>表示线程<code>i</code>最多需要第<code>j</code>种资源多少个。</li>
<li><strong>Allocation (已分配资源矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Allocation[i, j]</code>表示线程<code>i</code>目前已拥有第<code>j</code>种资源多少个。</li>
<li><strong>Need (需求矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Need[i, j]</code>表示线程<code>i</code>还需要第<code>j</code>种资源多少个才能完成任务。<ul>
<li><code>Need[i, j] = Max[i, j] - Allocation[i, j]</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="银行家算法的核心：安全状态的判断"><a href="#银行家算法的核心：安全状态的判断" class="headerlink" title="银行家算法的核心：安全状态的判断"></a>银行家算法的核心：安全状态的判断</h3><p>判断系统是否处于安全状态是银行家算法的核心。一个系统处于<strong>安全状态</strong>，当且仅当存在一个<strong>安全序列</strong><code>&lt;P1, P2, ..., Pn&gt;</code>。这个序列满足：对于序列中每一个线程<code>Pi</code>，它所需要的资源都能由系统中当前可用的资源，以及前面所有已完成的线程释放的资源来满足。</p>
<p><strong>安全性检查算法的步骤：</strong></p>
<ol>
<li><strong>初始化：</strong><ul>
<li>创建一个<code>Work</code>向量，初始化为<code>Available</code>（即当前可用资源）。</li>
<li>创建一个<code>Finish</code>向量，初始化为<code>false</code>，表示所有线程都未完成。</li>
</ul>
</li>
<li><strong>寻找安全线程：</strong><ul>
<li>从所有线程中找到一个线程<code>i</code>，满足以下两个条件：<ul>
<li><code>Finish[i]</code>为<code>false</code>。</li>
<li><code>Need[i]</code>向量中的每一个值都小于或等于<code>Work</code>向量中对应的值。</li>
<li>换句话说，线程<code>i</code>所需要的资源小于或等于当前可用的资源。</li>
</ul>
</li>
</ul>
</li>
<li><strong>释放资源：</strong><ul>
<li>如果找到了这样的线程<code>i</code>，则认为它可以顺利执行完毕。</li>
<li>模拟该线程执行完毕并释放资源，更新<code>Work</code>向量：<code>Work = Work + Allocation[i]</code>。</li>
<li>将<code>Finish[i]</code>设置为<code>true</code>。</li>
</ul>
</li>
<li><strong>循环检查：</strong><ul>
<li>重复步骤2和步骤3，直到找不到满足条件的线程。</li>
</ul>
</li>
<li><strong>判断结果：</strong><ul>
<li>如果最终所有线程的<code>Finish</code>都为<code>true</code>，则说明找到了一个安全序列，系统处于<strong>安全状态</strong>。</li>
<li>如果还有线程的<code>Finish</code>为<code>false</code>，则说明系统处于<strong>不安全状态</strong>，可能存在死锁。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="银行家算法的流程：资源分配"><a href="#银行家算法的流程：资源分配" class="headerlink" title="银行家算法的流程：资源分配"></a>银行家算法的流程：资源分配</h3><p>当一个线程<code>P</code>请求资源时，银行家算法会执行以下步骤：</p>
<ol>
<li><strong>请求检查：</strong> 检查线程<code>P</code>请求的资源数量是否小于或等于其<code>Need</code>向量中的需求量。如果不是，说明线程<code>P</code>的请求不合理，拒绝分配。</li>
<li><strong>可用性检查：</strong> 检查线程<code>P</code>请求的资源数量是否小于或等于当前<code>Available</code>中的资源数量。如果不是，说明资源不足，线程<code>P</code>需要等待。</li>
<li><strong>预分配并进行安全性检查：</strong><ul>
<li>假设资源可以分配，<strong>临时</strong>进行以下操作：<ul>
<li><code>Available = Available - Request</code></li>
<li><code>Allocation[P] = Allocation[P] + Request</code></li>
<li><code>Need[P] = Need[P] - Request</code></li>
</ul>
</li>
<li>调用上面的<strong>安全性检查算法</strong>，判断系统是否处于安全状态。</li>
</ul>
</li>
<li><strong>正式分配或拒绝：</strong><ul>
<li>如果安全性检查的结果是<strong>安全</strong>，则正式分配资源，并保留步骤3中的修改。</li>
<li>如果安全性检查的结果是<strong>不安全</strong>，则回滚步骤3中的所有临时修改，拒绝分配资源，线程<code>P</code>需要等待。</li>
</ul>
</li>
</ol>
<h3 id="银行家算法的优缺点"><a href="#银行家算法的优缺点" class="headerlink" title="银行家算法的优缺点"></a>银行家算法的优缺点</h3><ul>
<li><strong>优点：</strong><ul>
<li>可以有效地避免死锁的发生，保证系统的安全性。</li>
<li>通过提前检查，可以最大化地利用资源，提高系统的并发性。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>计算开销大：</strong> 每次分配资源都需要运行安全性检查算法，增加了系统的开销。</li>
<li><strong>过于保守：</strong> 安全状态不等于无死锁，不安全状态也不等于一定发生死锁。算法为了确保安全，可能会拒绝一些本可以成功分配的请求，从而降低了系统的吞吐量。</li>
<li><strong>条件苛刻：</strong> 算法要求线程在开始前就声明其所需的最大资源量，这在实际应用中很难做到。</li>
<li><strong>资源数量固定：</strong> 算法假设系统中资源的数量是固定的，不能动态增减。</li>
</ul>
</li>
</ul>
<p>因此，银行家算法虽然在理论上非常完美，但在实际操作系统中很少被直接完整地实现。然而，它的核心思想——<strong>通过安全性检查来避免死锁</strong>——仍然是许多并发控制策略的重要理论基础。                                     </p>
<h3 id="实际应用中的死锁处理"><a href="#实际应用中的死锁处理" class="headerlink" title="实际应用中的死锁处理"></a>实际应用中的死锁处理</h3><p>在实际的并发编程和数据库系统中，最常见的死锁处理方式是：</p>
<ul>
<li><p>死锁预防(通过编程规范)：</p>
<ul>
<li>加锁顺序一致：规定所有线程在获取多个锁时，必须按照相同的顺序。这是最有效的预防死锁的编程实践。</li>
<li>使用超时锁：尝试获取锁时设置一个超时时间，如果超时未获取到锁，则放弃本次操作并释放已持有的锁，然后重试。这破坏了”请求与保持”条件。例如Java的ReentrantLocktryLock(timeout)。</li>
<li>避免嵌套锁：尽量减少持有多个锁的情况。</li>
</ul>
</li>
<li><p>死锁检测与恢复(数据库系统)：</p>
<ul>
<li>大多数关系型数据库(如MySQL InnoDB)都实现了死锁检测机制。当检测到死锁时，数据库会自动选择一个成本较低的事务(“牺牲品”)进行回滚，从而解除死锁。客户端应用会收到相应的错误码(例如MySQL中的Deadlock found when trying to get lock; try restarting transaction)。应用程序通常需要捕获这个错误并重试事务。理解死锁的四个必要条件是关键，因为解决死锁的根本方法就是破坏其中一个或多个条件。</li>
</ul>
</li>
</ul>
<h2 id="锁扩展："><a href="#锁扩展：" class="headerlink" title="锁扩展："></a>锁扩展：</h2><h3 id="18-谈谈-synchronized-和-ReentrantLock-的区别？"><a href="#18-谈谈-synchronized-和-ReentrantLock-的区别？" class="headerlink" title="18. 谈谈 synchronized 和 ReentrantLock 的区别？"></a>18. 谈谈 synchronized 和 ReentrantLock 的区别？</h3><ol>
<li><code>synchronized</code> 是和 <code>for</code>、<code>while</code> 一样的关键字，<code>ReentrantLock</code> 是类，这是二者的本质区别。既然 <code>ReentrantLock</code> 是类，那么它就提供了比 <code>synchronized</code> 更多更灵活的特性：等待可中断、可实现公平锁、可实现选择性通知（锁可以绑定多个条件）、性能已不是选择标准。</li>
<li><code>synchronized</code> 依赖于 JVM 而 <code>ReenTrantLock</code> 依赖于 API。<code>synchronized</code> 是依赖于 JVM 实现的，JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReenTrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock</code> 方法配合 <code>try/finally</code> 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li>
</ol>
<hr>
<h3 id="19-synchronized-和-volatile-的区别是什么？"><a href="#19-synchronized-和-volatile-的区别是什么？" class="headerlink" title="19. synchronized 和 volatile 的区别是什么？"></a>19. synchronized 和 volatile 的区别是什么？</h3><ol>
<li><code>volatile</code> 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；<code>synchronized</code> 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li><code>volatile</code> 仅能使用在变量级别；<code>synchronized</code> 则可以使用在变量、方法、和类级别的。</li>
<li><code>volatile</code> 仅能实现变量的修改可见性，不能保证原子性；而 <code>synchronized</code> 则可以保证变量的修改可见性和原子性。</li>
<li><code>volatile</code> 不会造成线程的阻塞；<code>synchronized</code> 可能会造成线程的阻塞。</li>
<li><code>volatile</code> 标记的变量不会被编译器优化；<code>synchronized</code> 标记的变量可以被编译器优化。</li>
</ol>
<hr>
<h3 id="20-谈一下你对-volatile-关键字的理解？"><a href="#20-谈一下你对-volatile-关键字的理解？" class="headerlink" title="20. 谈一下你对 volatile 关键字的理解？"></a>20. 谈一下你对 volatile 关键字的理解？</h3><p><code>volatile</code> 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，这样做是为了减少流水线阻塞，提高 CPU 的执行效率。这就需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知道对不对了，所以有 <code>happens-before</code> 规则，其中有条就是 <code>volatile</code> 变量规则：对一个变量的写操作先行发生于后面面对这个变量的读操作、有序性实现的是通过插入内存屏障来保证的。</p>
<p>被 <code>volatile</code> 修饰的共享变量，就具有了以下两点特性：</p>
<ol>
<li>保证了不同线程对该变量操作的内存可见性;</li>
<li>禁止指令重排序。</li>
</ol>
<p>备注：这个题如果扩展了答，可以从 Java 的内存模型入手，下一篇 Java 虚拟机高频面试题中会讲到，这里不做过多赘述。</p>
<hr>
<h3 id="21-说下对-ReentrantReadWriteLock-的理解？"><a href="#21-说下对-ReentrantReadWriteLock-的理解？" class="headerlink" title="21. 说下对 ReentrantReadWriteLock 的理解？"></a>21. 说下对 ReentrantReadWriteLock 的理解？</h3><p><code>ReentrantReadWriteLock</code> 允许多个读线程同时访问，但是不允许写线程和读线程、写线程和写线程同时访问。读写锁内部维护了两个锁：一个是用于读操作的 <code>ReadLock</code>，一个是用于写操作的 <code>WriteLock</code>。读写锁 <code>ReentrantReadWriteLock</code> 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p>
<p><code>ReentrantReadWriteLock</code> 基于 <code>AQS</code> 实现，它的自定义同步器（继承 <code>AQS</code>）需要在同步状态 <code>state</code> 上维护多个读线程和一个写线程，该状态的设计成为实现读写锁的关键。<code>ReentrantReadWriteLock</code> 很好的利用了高低位。来实现一个整型控制两种状态的功能，读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写。</p>
<p><strong>ReentrantReadWriteLock 的特点</strong>：</p>
<ol>
<li>写锁可以降级为读锁，但是读锁不能升级为写锁；</li>
<li>不管是 <code>ReadLock</code> 还是 <code>WriteLock</code> 都支持 <code>Interrupt</code>，语义与 <code>ReentrantLock</code> 一致；</li>
<li><code>WriteLock</code> 支持 <code>Condition</code> 并且与 <code>ReentrantLock</code> 语义一致，而 <code>ReadLock</code> 则不能使用 <code>Condition</code>，否则抛出 <code>UnsupportedOperationException</code> 异常；</li>
<li>默认构造方法为非公平模式 ，开发者也可以通过指定 <code>fair</code> 为 <code>true</code> 设置为公平模式 。</li>
</ol>
<p><strong>升级&#x2F;降级</strong></p>
<ol>
<li>读锁里面加写锁，会导致死锁；</li>
<li>写锁里面是可以加读锁的，这就是锁的降级。</li>
</ol>
<h2 id="多线程与线程池"><a href="#多线程与线程池" class="headerlink" title="多线程与线程池"></a>多线程与线程池</h2><p>在 Java 中，多线程是实现并发编程的关键技术，它允许程序同时执行多个任务。线程池则是管理和复用线程的重要机制，能有效提升系统性能和资源利用率。</p>
<h3 id="⭐️什么是线程和进程"><a href="#⭐️什么是线程和进程" class="headerlink" title="⭐️什么是线程和进程?"></a><a href="#%E2%AD%90%EF%B8%8F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B">⭐️什么是线程和进程?</a></h3><h4 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a><a href="#%E4%BD%95%E4%B8%BA%E8%BF%9B%E7%A8%8B">何为进程?</a></h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
<h4 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a><a href="#%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B">何为线程?</a></h4><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<hr>
<p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<hr>
<h4 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84">程序计数器为什么是私有的?</a></h4><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h4 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84">虚拟机栈和本地方法栈为什么是私有的?</a></h4><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h4 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a><a href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA">一句话简单了解堆和方法区</a></h4><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<hr>
<h3 id="Java-THREAD-类详解"><a href="#Java-THREAD-类详解" class="headerlink" title="Java THREAD 类详解"></a>Java THREAD 类详解</h3><p>在 Java 中，<strong>Thread</strong> 类是多线程编程的核心。它代表了一个线程，并提供了丰富的 API 来创建、控制和管理线程的生命周期。理解 <code>Thread</code> 类及其方法对于编写高效、并发的 Java 应用程序至关重要。</p>
<hr>
<h3 id="1-THREAD-类的基本概念"><a href="#1-THREAD-类的基本概念" class="headerlink" title="1. THREAD 类的基本概念"></a>1. THREAD 类的基本概念</h3><p><code>Thread</code> 类位于 <code>java.lang</code> 包中。每个 <code>Thread</code> 类的实例都代表一个独立的线程，这个线程能够并行执行代码。有两种主要方式可以创建一个线程：</p>
<ol>
<li><strong>继承 Thread 类</strong>：创建一个新的类并继承 <code>Thread</code>，然后重写其 <strong>run()</strong> 方法来定义线程的执行逻辑。</li>
<li><strong>实现 Runnable 接口</strong>：创建一个实现了 <code>Runnable</code> 接口的类，并将其实例作为参数传递给 <code>Thread</code> 构造器。这种方式更灵活，因为它允许你的类继承其他类。</li>
</ol>
<hr>
<h3 id="2-THREAD-类的主要方法详解"><a href="#2-THREAD-类的主要方法详解" class="headerlink" title="2. THREAD 类的主要方法详解"></a>2. THREAD 类的主要方法详解</h3><p>下面详细介绍 <code>Thread</code> 类中的常用和重要方法，并按其功能进行分类。</p>
<h4 id="线程生命周期控制"><a href="#线程生命周期控制" class="headerlink" title="线程生命周期控制"></a><strong>线程生命周期控制</strong></h4><p>这些方法用于启动、中断和协调线程的执行。</p>
<ul>
<li><strong>start()</strong>: <strong>启动</strong>线程。此方法会创建一个新的线程，并使它进入<strong>可运行 (Runnable)</strong> 状态。一旦操作系统调度这个线程，它的 <strong>run()</strong> 方法就会被调用。</li>
<li><strong>run()</strong>: 线程的<strong>执行体</strong>。当你调用 <code>start()</code> 方法时，JVM 会自动调用这个方法。如果你直接调用 <code>run()</code>，它只会被当作一个普通方法在当前线程中执行，而不会创建新线程。</li>
<li><strong>interrupt()</strong>: 向线程发送一个<strong>中断信号</strong>。此方法并不会立即停止线程。它只是设置一个<strong>中断标志</strong>。线程需要自己检查这个标志并决定如何响应。对于在 <code>sleep()</code>, <code>join()</code>, 或 <code>wait()</code> 等方法中阻塞的线程，这个方法会抛出 <code>InterruptedException</code>。</li>
<li><strong>join()</strong>: <strong>等待</strong>线程终止。调用此方法的线程（通常是主线程）会<strong>阻塞</strong>，直到被调用 <code>join()</code> 的线程执行结束。<ul>
<li><strong>join()</strong>: 永远等待，直到线程终止。</li>
<li><strong>join(long millis)</strong>: 最多等待指定的毫秒数。</li>
</ul>
</li>
</ul>
<h4 id="线程属性和状态查询"><a href="#线程属性和状态查询" class="headerlink" title="线程属性和状态查询"></a><strong>线程属性和状态查询</strong></h4><p>这些方法用于获取线程的当前状态或设置其属性。</p>
<ul>
<li><strong>getName()</strong>: 返回线程的名称。线程可以有一个自定义的名称，如果没有指定，则会有一个默认的名称，如 “Thread-0”。</li>
<li><strong>setName(String name)</strong>: 设置线程的名称。</li>
<li><strong>getState()</strong>: 返回线程的当前<strong>状态</strong>。返回值是一个枚举类型 <code>Thread.State</code>，包括 <code>NEW</code>, <code>RUNNABLE</code>, <code>BLOCKED</code>, <code>WAITING</code>, <code>TIMED_WAITING</code>, <code>TERMINATED</code>。</li>
<li><strong>isAlive()</strong>: 判断线程是否<strong>存活</strong>。如果线程已经启动但尚未终止，则返回 <code>true</code>。</li>
<li><strong>isDaemon()</strong>: 判断线程是否为<strong>守护线程</strong>。守护线程在所有非守护线程终止时会自动终止。例如，JVM 的垃圾回收线程就是一个守护线程。</li>
<li><strong>setDaemon(boolean on)</strong>: 将线程设置为守护线程或非守护线程。这个方法必须在线程启动前调用。</li>
<li><strong>getPriority()</strong>: 返回线程的<strong>优先级</strong>。优先级是一个整数，范围从 <code>MIN_PRIORITY</code> (1) 到 <code>MAX_PRIORITY</code> (10)。</li>
<li><strong>setPriority(int newPriority)</strong>: 设置线程的优先级。</li>
</ul>
<h4 id="静态方法-影响当前线程"><a href="#静态方法-影响当前线程" class="headerlink" title="静态方法 (影响当前线程)"></a><strong>静态方法 (影响当前线程)</strong></h4><p>这些方法直接作用于正在执行的线程。</p>
<ul>
<li><strong>Thread.currentThread()</strong>: 返回对<strong>当前正在执行</strong>的线程对象的引用。这是获取当前线程信息最常用的方法。</li>
<li><strong>Thread.sleep(long millis)</strong>: 使<strong>当前线程</strong>暂停执行指定的毫秒数。它会释放 CPU 资源，但不会释放锁。</li>
<li><strong>Thread.yield()</strong>: 提示调度器，<strong>当前线程</strong>愿意放弃当前的 CPU 使用权，让其他线程有机会运行。这是一个<strong>提示</strong>，不能保证一定生效。</li>
<li><strong>Thread.interrupted()</strong>: 测试<strong>当前线程</strong>是否被中断。此方法会<strong>清除</strong>中断标志。如果线程在调用时中断标志为 <code>true</code>，则返回 <code>true</code>，然后将中断标志重置为 <code>false</code>。</li>
</ul>
<hr>
<h3 id="3-THREAD-类方法使用示例"><a href="#3-THREAD-类方法使用示例" class="headerlink" title="3. THREAD 类方法使用示例"></a>3. THREAD 类方法使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethodsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建并启动线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行。状态：&quot;</span> + Thread.currentThread().getState());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 模拟耗时操作，并演示 sleep()</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 休眠 2 秒...&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 检查中断标志</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被中断了！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 捕获到 InterruptedException，线程被中断。&quot;</span>);</span><br><span class="line">                <span class="comment">// 捕获异常后重新设置中断标志</span></span><br><span class="line">                Thread.currentThread().interrupt(); </span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行结束。&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;WorkerThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程优先级和守护状态（必须在启动前）</span></span><br><span class="line">        worker.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        worker.setDaemon(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并打印线程信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程创建后，名称：&quot;</span> + worker.getName() + <span class="string">&quot;，优先级：&quot;</span> + worker.getPriority());</span><br><span class="line">        System.out.println(<span class="string">&quot;线程创建后，状态：&quot;</span> + worker.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        worker.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 使用 join() 等待 worker 线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待 WorkerThread 结束...&quot;</span>);</span><br><span class="line">        <span class="comment">// worker.join(1000); // 只等待 1 秒</span></span><br><span class="line">        worker.join(); <span class="comment">// 无限等待</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行。WorkerThread 的最终状态：&quot;</span> + worker.getState());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 再次检查是否存活</span></span><br><span class="line">        System.out.println(<span class="string">&quot;WorkerThread 是否存活：&quot;</span> + worker.isAlive());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 演示 interrupt()</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">interruptibleThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程在这里阻塞</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;interruptibleThread 被中断，捕获到异常。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        interruptibleThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="comment">// 确保线程进入休眠</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程中断 interruptibleThread...&quot;</span>);</span><br><span class="line">        interruptibleThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，这是一个关于 Java 线程控制的非常重要的知识点。我将详细解释<strong>守护线程（Daemon Thread）</strong>，以及 <code>join()</code> 和 <code>yield()</code> 这两个线程控制方法。</p>
<hr>
<h3 id="一、守护线程-Daemon-Thread"><a href="#一、守护线程-Daemon-Thread" class="headerlink" title="一、守护线程 (Daemon Thread)"></a>一、守护线程 (Daemon Thread)</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul>
<li><strong>守护线程</strong>：是一种特殊的线程，它为其他线程（非守护线程）提供服务。</li>
<li><strong>特点</strong>：如果 JVM 中<strong>只剩下守护线程</strong>，那么 JVM 会自动退出。换句话说，守护线程的生命周期不依赖于自己，而是依赖于其他非守护线程。</li>
</ul>
<h4 id="2-与普通线程的区别"><a href="#2-与普通线程的区别" class="headerlink" title="2. 与普通线程的区别"></a>2. 与普通线程的区别</h4><ul>
<li><strong>普通线程（User Thread）</strong>：又称用户线程。如果 JVM 中还有一个用户线程在运行，JVM 就不会退出。</li>
<li><strong>守护线程</strong>：当所有用户线程都执行完毕后，JVM 会忽略仍在运行的守护线程，并直接终止。</li>
</ul>
<h4 id="3-常见用途"><a href="#3-常见用途" class="headerlink" title="3. 常见用途"></a>3. 常见用途</h4><ul>
<li>守护线程常用于执行一些后台任务，例如：<ul>
<li><strong>垃圾回收器 (Garbage Collector)</strong>：JVM 的垃圾回收线程就是典型的守护线程。它负责回收内存，但不会阻止 JVM 的退出。</li>
<li><strong>JIT (Just-In-Time) 编译器</strong>：同样是后台服务线程。</li>
<li><strong>日志记录</strong>：一些日志框架的异步日志线程可以设置为守护线程。</li>
</ul>
</li>
</ul>
<h4 id="4-如何创建和判断"><a href="#4-如何创建和判断" class="headerlink" title="4. 如何创建和判断"></a>4. 如何创建和判断</h4><ul>
<li><strong>创建</strong>：在线程启动前，调用 <code>setDaemon(true)</code> 方法。<ul>
<li><strong>注意</strong>：必须在 <code>start()</code> 方法调用之前设置，否则会抛出 <code>IllegalThreadStateException</code>。</li>
</ul>
</li>
<li><strong>判断</strong>：<code>isDaemon()</code> 方法可以判断一个线程是否为守护线程。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonThreadExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个用户线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">userThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;用户线程正在运行...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户线程执行完毕。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个守护线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;守护线程正在运行...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置为守护线程，必须在 start() 之前</span></span><br><span class="line">        daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        userThread.start();</span><br><span class="line">        daemonThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 观察结果：当用户线程执行完毕后，守护线程也会立即终止。</span></span><br><span class="line">        <span class="comment">// 如果把 setDaemon(true) 移除，守护线程会一直运行，导致程序不退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、join-方法"><a href="#二、join-方法" class="headerlink" title="二、join() 方法"></a>二、<code>join()</code> 方法</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul>
<li><code>join()</code> 方法的作用是<strong>等待调用该方法的线程执行完毕</strong>。</li>
<li><strong>比喻</strong>：主线程 A 调用了线程 B 的 <code>B.join()</code> 方法，那么主线程 A 会<strong>进入等待状态</strong>，直到线程 B 执行结束，主线程 A 才会继续执行。</li>
</ul>
<h4 id="2-主要用途"><a href="#2-主要用途" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h4><ul>
<li>确保线程间的执行顺序。当一个线程的执行依赖于另一个线程的执行结果时，<code>join()</code> 方法非常有用。</li>
</ul>
<h4 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1执行完毕。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2执行完毕。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待 thread1 和 thread2 执行完毕</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待线程1执行完毕...&quot;</span>);</span><br><span class="line">        thread1.join(); <span class="comment">// 主线程阻塞在这里，直到 thread1 结束</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待线程2执行完毕...&quot;</span>);</span><br><span class="line">        thread2.join(); <span class="comment">// 主线程阻塞在这里，直到 thread2 结束</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程都执行完毕，主线程继续执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="三、yield-方法"><a href="#三、yield-方法" class="headerlink" title="三、yield() 方法"></a>三、<code>yield()</code> 方法</h3><h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul>
<li><code>yield()</code> 方法的作用是<strong>让出当前 CPU 的执行权</strong>。</li>
<li><strong>比喻</strong>：一个线程调用了 <code>yield()</code>，它告诉调度器：“我愿意暂时放弃 CPU，你可以让其他同等优先级的线程先执行。”</li>
</ul>
<h4 id="2-主要用途-1"><a href="#2-主要用途-1" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h4><ul>
<li><strong>提示</strong>：<code>yield()</code> 只是一个<strong>提示</strong>，调度器<strong>不一定会采纳</strong>。它可能让出 CPU 给其他线程，也可能立即重新获得 CPU 的执行权。</li>
<li><strong>与其他方法的区别</strong>：<ul>
<li><code>sleep()</code>：让线程进入<strong>休眠状态</strong>，<strong>强制</strong>让出 CPU。</li>
<li><code>wait()</code>：让线程进入<strong>等待状态</strong>，<strong>必须</strong>通过 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒。</li>
</ul>
</li>
<li><strong>yield() 不会释放锁</strong>。</li>
</ul>
<h4 id="3-代码示例-1"><a href="#3-代码示例-1" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YieldExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在运行：&quot;</span> + i);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 放弃CPU执行权。&quot;</span>);</span><br><span class="line">                    Thread.<span class="keyword">yield</span>(); <span class="comment">// 让出 CPU</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>观察结果</strong>：在输出到 “放弃CPU执行权” 后，你可能会看到另一个线程的输出先出现。但这并不绝对，因为 <code>yield()</code> 只是一个建议。</p>
<p>在Java多线程编程中，<code>yield()</code>、<code>join()</code>、<code>setDaemon()</code> 这些方法都有严格的<strong>设置时机</strong>，如果使用不当，可能会导致异常或行为不符合预期。</p>
<p>让我们来详细解释一下每个方法的设置时机。</p>
<hr>
<h3 id="1-setDaemon-boolean-on-方法"><a href="#1-setDaemon-boolean-on-方法" class="headerlink" title="1. setDaemon(boolean on) 方法"></a>1. <code>setDaemon(boolean on)</code> 方法</h3><ul>
<li><p><strong>作用</strong>：将一个线程设置为守护线程或用户线程。</p>
</li>
<li><p><strong>设置时机</strong>：<strong>必须在线程启动前调用</strong>，即在 <code>thread.start()</code> 方法之前。</p>
</li>
<li><p><strong>为什么？</strong>：</p>
<ul>
<li>线程一旦启动，其类型（用户线程或守护线程）就已经确定，并且不能在运行时改变。</li>
<li>如果在 <code>start()</code> 方法之后调用 <code>setDaemon(true)</code>，会抛出 <code>IllegalThreadStateException</code> 运行时异常。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 守护线程的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例：先启动再设置</span></span><br><span class="line"><span class="comment">// daemonThread.start();</span></span><br><span class="line"><span class="comment">// daemonThread.setDaemon(true); // 这里会抛出 IllegalThreadStateException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例：先设置再启动</span></span><br><span class="line">daemonThread.setDaemon(<span class="literal">true</span>); </span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-join-方法"><a href="#2-join-方法" class="headerlink" title="2. join() 方法"></a>2. <code>join()</code> 方法</h3><ul>
<li><p><strong>作用</strong>：让当前线程等待另一个线程执行完毕。</p>
</li>
<li><p><strong>设置时机</strong>：<strong>必须在被等待的线程启动后调用</strong>。</p>
</li>
<li><p><strong>为什么？</strong>：</p>
<ul>
<li><code>join()</code> 的目的是让一个线程等待另一个线程。如果被等待的线程还没有启动，那么等待它结束是没有意义的。</li>
<li>尽管在启动前调用不会抛出异常，但它也不会有任何效果，因为目标线程根本没有开始运行。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 工作线程的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例：在工作线程启动前调用 join()</span></span><br><span class="line"><span class="comment">// workerThread.join(); // 无效，因为 workerThread 还没有运行</span></span><br><span class="line"><span class="comment">// workerThread.start(); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例：在工作线程启动后调用 join()</span></span><br><span class="line">workerThread.start();</span><br><span class="line">workerThread.join(); <span class="comment">// 主线程将等待 workerThread 运行完毕</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-yield-方法"><a href="#3-yield-方法" class="headerlink" title="3. yield() 方法"></a>3. <code>yield()</code> 方法</h3><ul>
<li><p><strong>作用</strong>：向线程调度器发出提示，当前线程愿意放弃 CPU 执行权。</p>
</li>
<li><p><strong>设置时机</strong>：<strong>可以在线程生命周期的任何阶段调用</strong>，但通常在线程的 <code>run()</code> 方法中调用。</p>
</li>
<li><p><strong>为什么？</strong>：</p>
<ul>
<li><code>yield()</code> 是一个<strong>动态的行为</strong>，它发生在线程正在执行其任务的过程中。</li>
<li>它的目的是在任务执行过程中，在某个点上主动让出 CPU，让其他线程有机会运行。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我正在运行...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">// 在任务执行到一半时，让出 CPU</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>设置时机</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>setDaemon()</strong></td>
<td>设定线程类型（守护&#x2F;用户）</td>
<td><strong>thread.start() 之前</strong></td>
<td>启动后设置会抛出异常</td>
</tr>
<tr>
<td><strong>join()</strong></td>
<td>等待线程执行结束</td>
<td><strong>thread.start() 之后</strong></td>
<td>在启动前调用是无效的</td>
</tr>
<tr>
<td><strong>yield()</strong></td>
<td>提示线程调度器让出 CPU</td>
<td><strong>线程运行期间的任何时刻</strong></td>
<td>只是一个建议，不保证生效</td>
</tr>
</tbody></table>
<h3 id="1-深度解析"><a href="#1-深度解析" class="headerlink" title="1. 深度解析"></a>1. 深度解析</h3><h4 id="1-Thread-sleep-long-millis"><a href="#1-Thread-sleep-long-millis" class="headerlink" title="1. Thread.sleep(long millis)"></a>1. <code>Thread.sleep(long millis)</code></h4><p><strong>功能:</strong> <code>sleep()</code> 方法是 <code>Thread</code> 类的静态方法，作用是让<strong>当前正在执行的线程</strong>暂停指定的时间。</p>
<p><strong>核心机制:</strong></p>
<ul>
<li><code>sleep()</code> 方法会使线程进入<strong>阻塞状态（Timed Waiting）</strong>。</li>
<li>它<strong>不会释放</strong>任何持有的<strong>锁（monitor）</strong>。</li>
<li>当指定的时间过后，线程会回到<strong>可运行状态（Runnable）</strong>，等待 CPU 调度。</li>
<li>如果线程在休眠期间被其他线程调用 <code>interrupt()</code> 方法，<code>sleep()</code> 会立即抛出 <code>InterruptedException</code>。</li>
<li><code>sleep()</code> 的实现依赖于操作系统的调度器，实际暂停的时间可能比指定的时间长。</li>
</ul>
<p><strong>源码解析 (伪代码):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查中断标志</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用本地方法，通知操作系统挂起当前线程</span></span><br><span class="line">    VM.nativeSleep(millis);</span><br><span class="line">    <span class="comment">// 唤醒后再次检查中断标志</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VM.nativeSleep</strong> 是一个本地方法，它将线程挂起的任务交给操作系统内核来完成。</p>
<h4 id="2-Thread-yield"><a href="#2-Thread-yield" class="headerlink" title="2. Thread.yield()"></a>2. <code>Thread.yield()</code></h4><p><strong>功能:</strong> <code>yield()</code> 方法是 <code>Thread</code> 类的静态方法，作用是让<strong>当前正在执行的线程</strong>放弃其 CPU 时间片，回到<strong>可运行状态（Runnable）</strong>。</p>
<p><strong>核心机制:</strong></p>
<ul>
<li><code>yield()</code> 的目的是给其他线程一个执行的机会，但它<strong>不保证</strong>其他线程会立即运行。</li>
<li>它<strong>不会</strong>使线程进入阻塞或等待状态，线程只是从“正在运行”的状态切换到“可运行”队列的末尾。</li>
<li>调度器可能会选择立即重新调度刚才调用 <code>yield()</code> 的线程。</li>
<li>它<strong>不会</strong>释放任何锁。</li>
<li><code>yield()</code> 主要用于<strong>调试</strong>或<strong>优化</strong>，通常不应用于核心业务逻辑。因为它依赖于调度器的实现，其行为不可预测。</li>
</ul>
<p><strong>源码解析 (伪代码):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用本地方法，向操作系统调度器发出“让步”信号</span></span><br><span class="line">    nativeYield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>nativeYield</strong> 同样是一个本地方法，它向操作系统调度器发出一个提示，表示当前线程愿意让出 CPU。</p>
<h4 id="3-obj-wait"><a href="#3-obj-wait" class="headerlink" title="3. obj.wait()"></a>3. <code>obj.wait()</code></h4><p><strong>功能:</strong> <code>wait()</code> 方法是 <code>Object</code> 类的方法，作用是让<strong>当前线程</strong>进入<strong>等待状态（Waiting）</strong>，并<strong>释放</strong>它所持有的对象的锁。</p>
<p><strong>核心机制:</strong></p>
<ul>
<li><code>wait()</code> 必须在**同步块（synchronized block）**内部调用，否则会抛出 <code>IllegalMonitorStateException</code>。</li>
<li>当线程调用 <code>wait()</code> 后，它会<strong>释放</strong>该同步块所关联的对象的锁，进入等待队列。</li>
<li>线程需要等待其他线程调用<strong>同一对象的</strong> <code>notify()</code> 或 <code>notifyAll()</code> 方法才能被唤醒。</li>
<li>被唤醒后，线程需要<strong>重新竞争</strong>对象的锁，才能继续执行。</li>
</ul>
<p><strong>源码解析 (伪代码):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    wait(<span class="number">0</span>); <span class="comment">// 内部调用带超时参数的 wait 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 必须持有对象的锁</span></span><br><span class="line">    <span class="keyword">if</span> (!Thread.holdsLock(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知虚拟机，当前线程进入等待状态，并释放锁</span></span><br><span class="line">    VM.nativeWait(<span class="built_in">this</span>, timeout);</span><br><span class="line">    <span class="comment">// 线程被唤醒后，重新竞争锁</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>wait()</code> 是线程间<strong>通信和协作</strong>的关键，通常与 <code>notify()</code> 或 <code>notifyAll()</code> 配合使用，实现生产者-消费者等设计模式。</p>
<h4 id="4-Thread-join"><a href="#4-Thread-join" class="headerlink" title="4. Thread.join()"></a>4. <code>Thread.join()</code></h4><p><strong>功能:</strong> <code>join()</code> 方法是 <code>Thread</code> 类的方法，作用是让<strong>当前线程</strong>（例如主线程）<strong>等待</strong>调用 <code>join()</code> 的线程（例如子线程）执行完毕。</p>
<p><strong>核心机制:</strong></p>
<ul>
<li><code>join()</code> 的本质是调用 <code>wait()</code> 方法。它在内部使用一个<strong>隐式的锁</strong>来同步。</li>
<li>当一个线程调用 <code>t.join()</code> 时，当前线程（调用者）会<strong>阻塞</strong>，直到线程 <code>t</code> 终止。</li>
<li>如果线程 <code>t</code> 终止（无论是正常结束还是异常终止），JVM 会调用 <code>t.notifyAll()</code> 来唤醒所有在 <code>t.join()</code> 上等待的线程。</li>
</ul>
<p><strong>源码解析 (简化版):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 必须在同步方法中，使用this作为锁</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果线程已经结束，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="comment">// 进入等待</span></span><br><span class="line">        wait(millis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>join()</code> 的实现巧妙地利用了 <code>wait()</code> 和 <code>notifyAll()</code> 的机制。当一个线程的 <code>run()</code> 方法执行完毕时，JVM 会自动调用其 <code>notifyAll()</code> 方法，从而唤醒所有等待它的线程。</p>
<hr>
<h3 id="2-区别与使用场景总结"><a href="#2-区别与使用场景总结" class="headerlink" title="2. 区别与使用场景总结"></a>2. 区别与使用场景总结</h3><table>
<thead>
<tr>
<th>特性&#x2F;方法</th>
<th><code>Thread.sleep()</code></th>
<th><code>Thread.yield()</code></th>
<th><code>obj.wait()</code></th>
<th><code>Thread.join()</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类&#x2F;接口</strong></td>
<td><code>java.lang.Thread</code> (静态)</td>
<td><code>java.lang.Thread</code> (静态)</td>
<td><code>java.lang.Object</code></td>
<td><code>java.lang.Thread</code></td>
</tr>
<tr>
<td><strong>是否释放锁</strong></td>
<td><strong>不释放</strong></td>
<td><strong>不释放</strong></td>
<td><strong>释放</strong></td>
<td><strong>不释放</strong> (但其内部实现会释放)</td>
</tr>
<tr>
<td><strong>状态转换</strong></td>
<td><code>RUNNING</code> -&gt; <code>TIMED_WAITING</code></td>
<td><code>RUNNING</code> -&gt; <code>RUNNABLE</code></td>
<td><code>RUNNING</code> -&gt; <code>WAITING</code></td>
<td><code>RUNNING</code> -&gt; <code>WAITING</code>&#x2F;<code>TIMED_WAITING</code></td>
</tr>
<tr>
<td><strong>唤醒方式</strong></td>
<td>时间到了自动唤醒 或 <code>interrupt()</code></td>
<td>依赖于操作系统调度器，立即或稍后被重新调度</td>
<td>必须由其他线程调用 <code>notify()</code>&#x2F;<code>notifyAll()</code></td>
<td>目标线程执行结束时自动唤醒 或 <code>interrupt()</code></td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>模拟耗时操作，或让出 CPU 资源（但不释放锁）</td>
<td>提示调度器给其他线程机会，通常用于调试或低优先级的任务</td>
<td>线程间的<strong>协作和通信</strong>，实现生产者-消费者模式</td>
<td><strong>等待</strong>一个线程执行结束，实现线程间的<strong>顺序执行</strong></td>
</tr>
<tr>
<td><strong>是否需要同步块</strong></td>
<td>否</td>
<td>否</td>
<td><strong>是</strong> (必须在 <code>synchronized</code> 块内)</td>
<td>否 (但其内部实现依赖于同步机制)</td>
</tr>
</tbody></table>
<h3 id="3-使用场景示例"><a href="#3-使用场景示例" class="headerlink" title="3. 使用场景示例"></a>3. 使用场景示例</h3><ul>
<li><p><strong>sleep()</strong>: 你需要一个定时任务，比如每隔一秒钟打印一次日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 暂停一秒</span></span><br><span class="line">    System.out.println(<span class="string">&quot;等待了 &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; 秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>yield()</strong>: 你有一个 CPU 密集型任务，希望在每次循环中给其他线程一个运行的机会，以避免饥饿。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 执行一些计算</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        Thread.<span class="keyword">yield</span>(); <span class="comment">// 让出 CPU</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>wait()</strong>: 你有一个共享队列，当队列为空时，消费者线程需要等待，当生产者放入新元素时，消费者被唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (sharedQueue) &#123;</span><br><span class="line">    <span class="keyword">while</span> (sharedQueue.isEmpty()) &#123;</span><br><span class="line">        sharedQueue.wait(); <span class="comment">// 队列为空，等待并释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费元素...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>join()</strong>: 你需要确保子线程的数据处理完成后，主线程才能继续使用这个数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">dataProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="comment">/* 处理数据 */</span> &#125;);</span><br><span class="line">dataProcessor.start();</span><br><span class="line">dataProcessor.join(); <span class="comment">// 主线程等待数据处理完成</span></span><br><span class="line">System.out.println(<span class="string">&quot;数据处理完成，主线程可以继续了。&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>理解这些方法的细微差别是编写健壮、高效并发代码的基础。特别是 <code>wait()</code> 和 <code>sleep()</code>，它们最大的区别在于是否释放锁，这直接影响着线程间的同步和协作方式。</p>
<h3 id="线程（Thread）的概念与生命周期"><a href="#线程（Thread）的概念与生命周期" class="headerlink" title="线程（Thread）的概念与生命周期"></a>线程（Thread）的概念与生命周期</h3><p>线程是操作系统调度的最小单位，是进程中的一个执行路径。一个进程可以包含多个线程，这些线程共享进程的内存空间。</p>
<p>线程的生命周期通常包含以下六种状态（定义在 java.lang.Thread.State 枚举中）：</p>
<ul>
<li><p>NEW（新建）：线程被创建但尚未启动。当使用 new Thread() 创建一个线程实例后，它就处于此状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello from a new thread!&quot;</span>));</span><br><span class="line"><span class="comment">// 此时 myThread 处于 NEW 状态，尚未执行 start()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>RUNNABLE（可运行）：线程已调用 start() 方法，正在 JVM 中运行（可能正在执行，也可能在等待 CPU 调度）。一个 RUNNABLE 状态的线程可能正在运行，也可能并没有运行，它仅仅是具备了运行的资格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myThread.start();</span><br><span class="line"><span class="comment">// 此时 myThread 进入 RUNNABLE 状态，等待 CPU 调度执行 run() 方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BLOCKED (阻塞)：线程正在等待获取一个监视器锁(例如，进入 synchronized 块或方法)。当一个线程试图访问被其他线程锁定的资源时，它会进入此状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 线程已经持有 lock 对象的锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// ... 线程 A 正在执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程 B 尝试获取 lock 对象的锁，但被线程 A 占用，会进入 BLOCKED 状态</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WAITING (等待)：线程无限制地等待另一个线程执行特定操作。例如，调用 Object.wait(), Thread.join() (无参数) 或 LockSupport.park().这些方法会使线程放弃 CPU 使用权，并进入无限制等待，直到被其他线程 notify(), notifyAll() 或 unpark() 唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">sharedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 线程 A:</span></span><br><span class="line"><span class="keyword">synchronized</span> (sharedObject) &#123;</span><br><span class="line">    sharedObject.wait(); <span class="comment">// 线程 A 进入 WAITING 状态，并释放 sharedObject 的锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程 B:</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line">threadA.start();</span><br><span class="line">threadA.join(); <span class="comment">// 线程 B 等待 threadA 执行完毕，进入 WAITING 状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TIMED_WAITING (有时限等待)：线程在指定的时间内等待另一个线程执行特定操作，或者休眠。例如，调用 Thread.sleep(long millis)、Object.wait(long timeout)、Thread.join(long millis)、LockSupport.parkNanos() 或 LockSupport.parkUntil()。一旦超时间到达，线程会自动从等待状态唤醒，并尝试重新进入 RUNNABLE 状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 线程进入 TIMED_WAITING 状态 1 秒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TERMINATED (终止): 线程已执行完毕其 run() 方法, 或者因未捕获的异常退出。线程一旦进入此状态, 就不能再被重新启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程的 run() 方法执行完毕</span></span><br><span class="line"><span class="comment">// 线程在执行过程中抛出未捕获的异常</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="什么是线程上下文切换"><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换?"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">什么是线程上下文切换?</a></h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h3 id="Thread-sleep-方法和-Object-wait-方法对比"><a href="#Thread-sleep-方法和-Object-wait-方法对比" class="headerlink" title="Thread#sleep() 方法和 Object#wait() 方法对比"></a><a href="#thread-sleep-%E6%96%B9%E6%B3%95%E5%92%8C-object-wait-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94">Thread#sleep() 方法和 Object#wait() 方法对比</a></h3><hr>
<p><strong>共同点</strong>：两者都可以暂停线程的执行。</p>
<p><strong>区别</strong>：</p>
<ul>
<li><strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong> 。</li>
<li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？下一个问题就会聊到。</li>
</ul>
<hr>
<h3 id="为什么-wait-方法不定义在-Thread-中？"><a href="#为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%9C%A8-thread-%E4%B8%AD">为什么 wait() 方法不定义在 Thread 中？</a></h3><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p>
<p>类似的问题：<strong>为什么 sleep() 方法定义在 Thread 中？</strong></p>
<p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
<hr>
<h3 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a><a href="#%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-thread-%E7%B1%BB%E7%9A%84-run-%E6%96%B9%E6%B3%95%E5%90%97">可以直接调用 Thread 类的 run 方法吗？</a></h3><p>这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结：调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p>
<h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类:"></a>继承 Thread 类:</h4><ul>
<li>通过创建 Thread 类的子类, 并重写其 run() 方法, 在该方法中定义线程执行的任务。</li>
<li>创建 Thread 子类的实例, 并调用其 start() 方法来启动线程。调用 start() 方法会使线程进入 RUNNABLE 状态, 并由 JVM 调度执行 run() 方法; 直接调用 run() 方法则只是在当前线程中执行普通方法, 不会启动新线程。</li>
<li>优点: 实现简单直观, 代码结构清晰。</li>
<li>缺点: Java 是单继承的, 如果你的类已经继承了其他类, 就不能再继承 Thread 类。这限制了类的灵活性。此外, 任务 (run() 方法中的逻辑 ) 与线程本身 (Thread 对象) 紧密耦合, 不利于任务的复用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyThread.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + threadName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running via extending Thread.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread: &quot;</span> + threadName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">                <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + threadName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> + threadName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadCreationDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCreationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread started.&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;MyThread-1&quot;</span>);</span><br><span class="line">        thread1.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;MyThread-2&quot;</span>);</span><br><span class="line">        thread2.start(); <span class="comment">// 启动另一个新线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished starting other threads.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现-Runnable-接口："><a href="#实现-Runnable-接口：" class="headerlink" title="实现 Runnable 接口："></a>实现 <strong>Runnable</strong> 接口：</h4><ul>
<li>定义一个类实现 <strong>Runnable</strong> 接口，并实现其抽象方法 public void run()。run() 方法中包含线程执行的具体任务。</li>
<li>创建 <strong>Runnable</strong> 实现类的实例，然后将其作为参数传入 Thread 类的构造器 (new Thread(Runnable target))，再调用 Thread 实例的 start() 方法。</li>
<li>优点：<ul>
<li>推荐方式：避免了 Java 单继承的限制，你的类可以同时继承其他类来实现 <strong>Runnable</strong> 接口。</li>
<li>任务与线程解耦：Runnable 对象只负责定义任务，而 Thread 对象负责执行任务。这意味着同一个 <strong>Runnable</strong> 对象可以被多个 Thread 实例共享执行，从而更好地实现资源的共享和任务的复用。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyRunnable.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + taskName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running via implementing Runnable.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task: &quot;</span> + taskName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task &quot;</span> + taskName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task &quot;</span> + taskName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadCreationDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCreationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread started.&quot;</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;Runnable-Task-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable1);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;Runnable-Task-2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable2, <span class="string">&quot;Custom-Thread-Name&quot;</span>); <span class="comment">// 可以给线程命名</span></span><br><span class="line">        thread4.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished starting runnable threads.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><p><code>Callable</code> 是 Java 并发编程中一个非常重要的接口，它与 <code>Runnable</code> 类似，都用于定义一个可在线程中执行的任务。但 <code>Callable</code> 提供了更强大的功能，主要体现在两个方面：</p>
<ol>
<li><strong>可以返回结果：</strong> <code>Callable</code> 的 <code>call()</code> 方法可以返回一个泛型类型的结果。</li>
<li><strong>可以抛出异常：</strong> <code>Callable</code> 的 <code>call()</code> 方法可以声明抛出任何 <code>Exception</code>。</li>
</ol>
<p>这与 <code>Runnable</code> 接口形成了鲜明对比，<code>Runnable</code> 的 <code>run()</code> 方法没有返回值，也不能抛出受检异常（checked exception）。</p>
<ul>
<li><h3 id="Callable-的基本结构"><a href="#Callable-的基本结构" class="headerlink" title="Callable 的基本结构"></a><code>Callable</code> 的基本结构</h3></li>
</ul>
<p><code>Callable</code> 接口是一个泛型接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算并返回结果，或在无法做到时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 如果无法计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;V&gt;</code>：泛型参数，代表 <code>call()</code> 方法将要返回的结果类型。</p>
</li>
<li><p><code>V call()</code>：<code>call()</code> 方法的签名，它返回一个 <code>V</code> 类型的结果，并且可以抛出异常。</p>
</li>
<li><h3 id="如何使用-Callable"><a href="#如何使用-Callable" class="headerlink" title="如何使用 Callable"></a>如何使用 <code>Callable</code></h3></li>
</ul>
<p><code>Callable</code> 接口本身并不能直接作为 <code>Thread</code> 的构造参数。它需要配合 <code>ExecutorService</code> 线程池和 <code>Future</code> 接口一起使用。</p>
<p><strong>典型使用流程：</strong></p>
<ol>
<li><p><strong>创建 Callable 任务：</strong> 实现 <code>Callable</code> 接口，并在 <code>call()</code> 方法中编写具体的业务逻辑，返回一个结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务执行完毕，返回结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 ExecutorService 线程池：</strong> 使用 <code>Executors</code> 工厂类创建线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提交 Callable 任务：</strong> 使用 <code>ExecutorService</code> 的 <code>submit()</code> 方法提交任务。<code>submit()</code> 方法会返回一个 <code>Future</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">MyCallableTask</span>();</span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取任务结果：</strong> 通过 <code>Future</code> 对象的 <code>get()</code> 方法来获取 <code>Callable</code> 任务的执行结果。</p>
<ul>
<li><code>future.get()</code> 是一个<strong>阻塞</strong>方法，它会一直等待，直到任务执行完毕并返回结果。</li>
<li>如果任务执行过程中抛出了异常，<code>get()</code> 方法也会将这个异常包装在 <code>ExecutionException</code> 中重新抛出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 阻塞等待结果</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 线程被中断</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 任务执行过程中抛出的异常</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><h3 id="Callable-与-Runnable-的区别"><a href="#Callable-与-Runnable-的区别" class="headerlink" title="Callable 与 Runnable 的区别"></a><code>Callable</code> 与 <code>Runnable</code> 的区别</h3></li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>Callable</code></th>
<th><code>Runnable</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>返回值</strong></td>
<td><code>call()</code> 方法有返回值（泛型 <code>V</code>）</td>
<td><code>run()</code> 方法没有返回值（<code>void</code>）</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td><code>call()</code> 方法可以抛出受检异常</td>
<td><code>run()</code> 方法不能直接抛出受检异常</td>
</tr>
<tr>
<td><strong>执行方式</strong></td>
<td>必须配合 <code>ExecutorService.submit()</code> 执行</td>
<td>可以直接作为 <code>Thread</code> 构造函数的参数，也可以通过 <code>ExecutorService.execute()</code> 或 <code>submit()</code> 执行</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>适用于需要返回计算结果或可能抛出异常的异步任务</td>
<td>适用于简单的异步任务，不需要返回结果</td>
</tr>
</tbody></table>
<hr>
<ul>
<li><h3 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a><code>Future</code> 接口</h3></li>
</ul>
<p><code>Future</code> 接口是 <code>Callable</code> 的重要伴侣，它代表一个<strong>异步计算的结果</strong>。它提供了检查任务是否完成、等待任务完成以及获取任务结果的方法。</p>
<p><code>Future</code> 接口的主要方法：</p>
<ul>
<li><p><code>V get()</code>: 阻塞式地等待任务完成，并返回结果。</p>
</li>
<li><p><code>V get(long timeout, TimeUnit unit)</code>: 在指定时间内等待任务完成，超时则抛出 <code>TimeoutException</code>。</p>
</li>
<li><p><code>boolean isDone()</code>: 检查任务是否已经完成。</p>
</li>
<li><p><code>boolean cancel(boolean mayInterruptIfRunning)</code>: 尝试取消任务。</p>
</li>
<li><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3></li>
</ul>
<p><code>Callable</code> 是 Java 并发编程中一个更高级的任务抽象，它解决了 <code>Runnable</code> 接口无法返回结果和处理受检异常的痛点。通过与 <code>ExecutorService</code> 和 <code>Future</code> 接口的组合使用，<code>Callable</code> 使得异步编程变得更加简单和灵活，非常适合那些需要耗时计算并返回结果的场景，比如网络请求、数据处理等。</p>
<h4 id="线程池-Thread-Pool"><a href="#线程池-Thread-Pool" class="headerlink" title="线程池 (Thread Pool)"></a>线程池 (Thread Pool)</h4><p>线程池是一种基于池化思想的线程管理机制，用于管理和复用线程，而不是在每次需要执行任务时都创建新线程。</p>
<ul>
<li><p><strong>为什么使用线程池？</strong></p>
<ul>
<li>降低资源消耗:通过重复利用已创建的线程，降低线程创建和销毁的开销。</li>
<li>提高响应速度:当任务到达时，任务可以直接执行，无需等待线程创建。</li>
<li>提高线程的可管理性:线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配、调优和监控。</li>
<li>提供更多功能:如定时执行、周期执行、单线程化等。</li>
</ul>
</li>
<li><p><strong>线程池的核心参数 (ThreadPoolExecutor 构造方法)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">    TimeUnit unit,</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>corePoolSize: 核心线程数。线程池中始终保持的线程数量，即使它们处于空闲状态，除非设置了 allowCoreThreadTimeOut(true)。</p>
</li>
<li><p>maximumPoolSize: 最大线程数。线程池中允许存在的最大线程数量。当工作队列已满且核心线程都在忙碌时，线程池会创建新的非核心线程，直到达到这个数量。</p>
</li>
<li><p>keepAliveTime: 当线程池中的线程数量超过 corePoolSize 时，这些空闲的非核心线程在终止之前等待新任务的最长时间。</p>
</li>
<li><p>unit: keepAliveTime 参数的时间单位。</p>
</li>
<li><p>workQueue: 任务队列 (阻塞队列)。用于存放等待执行的任务。</p>
<ul>
<li>ArrayBlockingQueue: 基于数组的有界阻塞队列，需要指定容量。</li>
<li>LinkedBlockingQueue: 基于链表的阻塞队列，容量可以指定，也可以是无界的（默认）。如果使用无界队列，maximumPoolSize 参数将失效。</li>
<li>SynchronousQueue: 一个不存储元素的阻塞队列。每个插入操作必须等待一个对应的移除操作，反之亦然。</li>
<li>PriorityBlockingQueue: 支持优先级的无界阻塞队列，按照自然顺序或自定义比较器排序。</li>
</ul>
</li>
<li><p>threadFactory: 线程工厂。用于创建新线程，可以自定义线程的命名、优先级等。</p>
</li>
<li><p>handler: 拒绝策略 (当线程池和工作队列都已满时，新的任务到来时的处理方式)。</p>
<ul>
<li><p>ThreadPoolExecutor.AbortPolicy (默认): 直接抛出 RejectedExecutionException 异常。</p>
</li>
<li><p>ThreadPoolExecutor.CallerRunsPolicy: 由调用线程 (提交任务的线程) 执行任务。</p>
</li>
<li><p>ThreadPoolExecutor.DiscardOldestPolicy: 丢弃队列中最老的任务，然后尝试提交当前任务。</p>
</li>
<li><p>ThreadPoolExecutor.DiscardPolicy: 直接丢弃当前新提交的任务。</p>
</li>
<li><p>因为<code>CallerRunsPolicy</code>这个拒绝策略，导致耗时的任务用了主线程执行，导致线程池阻塞，进而导致后续任务无法及时执行，严重的情况下很可能导致 OOM。</p>
<p>我们从问题的本质入手，调用者采用<code>CallerRunsPolicy</code>是希望所有的任务都能够被执行，暂时无法处理的任务又被保存在阻塞队列<code>BlockingQueue</code>中。这样的话，在内存允许的情况下，我们可以增加阻塞队列<code>BlockingQueue</code>的大小并调整堆内存以容纳更多的任务，确保任务能够被准确执行。</p>
<p>为了充分利用 CPU，我们还可以调整线程池的<code>maximumPoolSize</code> （最大线程数）参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线程池的执行流程</strong></p>
<ol>
<li>当一个任务提交到线程池时，如果当前运行的线程数小于 corePoolSize，即使有空闲线程，也会创建并启动一个新线程来执行任务。</li>
<li>如果当前运行的线程数大于或等于 corePoolSize，但任务队列 workQueue 未满，任务会被添加到 workQueue 中等待执行。</li>
<li>如果 workQueue 已满，但当前运行的线程数小于 maximumPoolSize，线程池会创建新的非核心线程来执行任务。</li>
<li>如果当前运行的线程数等于 maximumPoolSize 且 workQueue 已满，线程池会根据拒绝策略来处理新提交的任务。</li>
</ol>
</li>
<li><p><strong>Java 内置的四种常用线程池 (通过 Executors 工厂类创建)</strong></p>
<ul>
<li>FixedThreadPool (固定大小线程池)<ul>
<li>Executors.newFixedThreadPool(int nThreads)</li>
<li>corePoolSize &#x3D; maximumPoolSize &#x3D; nThreads</li>
<li>使用无界 LinkedBlockingQueue。</li>
<li>特点：可控制并发的线程数，超出的任务会在队列中等待。</li>
<li>问题：当任务提交速度远大于处理速度时，队列会不断增长，可能导致 OOM。</li>
</ul>
</li>
<li>SingleThreadExecutor (单线程线程池)<ul>
<li>Executors.newSingleThreadExecutor()</li>
<li>corePoolSize &#x3D; maximumPoolSize &#x3D; 1</li>
<li>使用无界 LinkedBlockingQueue。</li>
<li>特点：保证所有任务都在一个线程中按顺序执行。</li>
<li>问题：同 FixedThreadPool，队列无限增长可能导致 OOM。</li>
</ul>
</li>
<li>CachedThreadPool（可缓存线程池）<ul>
<li>Executors.newCachedThreadPool()</li>
<li>corePoolSize &#x3D; 0, maximumPoolSize &#x3D; Integer.MAX_VALUE</li>
<li>使用 SynchronousQueue。</li>
<li>keepAliveTime &#x3D; 60s</li>
<li>特点：当任务到来时，有空闲线程则复用，无空闲线程则创建新线程。适用于大量短时任务。</li>
<li>问题：maximumPoolSize 过大，当任务并发量极高时，可能创建大量线程，导致系统资源耗尽 (OOM)。</li>
</ul>
</li>
<li>ScheduledThreadPool（定时任务线程池）<ul>
<li>Executors.newScheduledThreadPool(int corePoolSize)</li>
<li>特点：支持定时及周期性任务执行。</li>
<li>内部使用 DelayedWorkQueue，一个无界队列，可以按时间进行排序。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>阿里巴巴开发手册建议：不推荐使用 Executors 创建线程池，而是手动通过 ThreadPoolExecutor 的构造方法创建，以明确线程池的运行规则，避免资源耗尽的风险。</strong></p>
</li>
</ul>
<p>好的，这是一个非常核心且重要的 Java 并发编程话题。我将从线程池的<strong>创建、生命周期和启动流程</strong>三个方面进行详细且深入的解析。</p>
<hr>
<h3 id="一、线程池的创建-ThreadPoolExecutor"><a href="#一、线程池的创建-ThreadPoolExecutor" class="headerlink" title="一、线程池的创建 (ThreadPoolExecutor)"></a>一、线程池的创建 (ThreadPoolExecutor)</h3><p>Java 中，线程池的核心是 <code>java.util.concurrent.ThreadPoolExecutor</code> 类。创建线程池最推荐的方式是直接使用它的构造函数，而不是使用 <code>Executors</code> 工厂类，因为这能让你更清楚地了解线程池的运行参数。</p>
<p><code>ThreadPoolExecutor</code> 的构造函数有多个参数，理解它们是掌握线程池的关键：</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(</span><br><span class="line">    int corePoolSize,      // 核心线程数</span><br><span class="line">    int maximumPoolSize,   // 最大线程数</span><br><span class="line">    long keepAliveTime,    // 线程空闲存活时间</span><br><span class="line">    TimeUnit unit,         // 时间单位</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列</span><br><span class="line">    ThreadFactory threadFactory,   // 线程工厂</span><br><span class="line">    RejectedExecutionHandler handler // 拒绝策略</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="各参数详解："><a href="#各参数详解：" class="headerlink" title="各参数详解："></a>各参数详解：</h4><ol>
<li><strong>corePoolSize (核心线程数)</strong>：<ul>
<li><strong>作用</strong>：线程池中<strong>常驻</strong>的线程数量。即使这些线程处于空闲状态，它们也不会被销毁。</li>
<li><strong>用途</strong>：当有新任务提交时，如果核心线程数未达到 <code>corePoolSize</code>，线程池会创建新线程来处理任务，直到核心线程数达到上限。</li>
</ul>
</li>
<li><strong>maximumPoolSize (最大线程数)</strong>：<ul>
<li><strong>作用</strong>：线程池中允许存在的<strong>最大</strong>线程数量。</li>
<li><strong>用途</strong>：当任务队列已满，且核心线程数已满时，线程池会创建新的线程（非核心线程）来处理任务，直到总线程数达到 <code>maximumPoolSize</code>。</li>
</ul>
</li>
<li><strong>keepAliveTime (线程空闲存活时间)</strong>：<ul>
<li><strong>作用</strong>：非核心线程的空闲存活时间。</li>
<li><strong>用途</strong>：当线程池中的线程数量超过 <code>corePoolSize</code> 时，如果一个非核心线程空闲时间超过 <code>keepAliveTime</code>，它就会被回收。</li>
</ul>
</li>
<li><strong>unit (时间单位)</strong>：<ul>
<li><strong>作用</strong>：<code>keepAliveTime</code> 的时间单位，如秒、分钟、毫秒。</li>
</ul>
</li>
<li><strong>workQueue (任务队列)</strong>：<ul>
<li><strong>作用</strong>：用于<strong>存放等待执行的任务</strong>。当核心线程都在忙碌时，新提交的任务会进入这个队列。</li>
<li><strong>常见类型</strong>：<ul>
<li><code>ArrayBlockingQueue</code>：基于数组，有界的阻塞队列。</li>
<li><code>LinkedBlockingQueue</code>：基于链表，通常是无界的，也可以指定容量。</li>
<li><code>SynchronousQueue</code>：不存储任务，每个任务提交都会立即被一个线程执行。</li>
</ul>
</li>
</ul>
</li>
<li><strong>ThreadFactory (线程工厂)</strong>：<ul>
<li><strong>作用</strong>：用于创建线程。可以自定义工厂来为线程命名、设置守护状态等。</li>
</ul>
</li>
<li><strong>RejectedExecutionHandler (拒绝策略)</strong>：<ul>
<li><strong>作用</strong>：当任务队列已满，且线程数达到 <code>maximumPoolSize</code> 时，线程池会根据拒绝策略来处理新提交的任务。</li>
<li><strong>常见策略</strong>：<ul>
<li><code>AbortPolicy</code> (默认)：直接抛出 <code>RejectedExecutionException</code> 异常。</li>
<li><code>CallerRunsPolicy</code>：由提交任务的线程（caller）自己来执行任务。</li>
<li><code>DiscardOldestPolicy</code>：丢弃任务队列中最老的任务，然后尝试将当前任务加入队列。</li>
<li><code>DiscardPolicy</code>：直接丢弃当前任务，不抛出异常。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="二、线程池的生命周期"><a href="#二、线程池的生命周期" class="headerlink" title="二、线程池的生命周期"></a>二、线程池的生命周期</h3><p>线程池有五种状态，这些状态通过内部的 <code>ctl</code> 变量控制，它包含线程池的运行状态和线程数。</p>
<ol>
<li><strong>RUNNING (运行中)</strong>：<ul>
<li><strong>状态</strong>：接受新任务，并处理阻塞队列中的任务。</li>
<li><strong>转换</strong>：创建线程池时处于此状态。</li>
</ul>
</li>
<li><strong>SHUTDOWN (关闭)</strong>：<ul>
<li><strong>状态</strong>：不接受新任务，但会处理阻塞队列中的已有任务。</li>
<li><strong>转换</strong>：调用 <code>shutdown()</code> 方法后进入此状态。</li>
</ul>
</li>
<li><strong>STOP (停止)</strong>：<ul>
<li><strong>状态</strong>：不接受新任务，也不处理阻塞队列中的已有任务，会中断所有正在执行的任务。</li>
<li><strong>转换</strong>：调用 <code>shutdownNow()</code> 方法后进入此状态。</li>
</ul>
</li>
<li><strong>TIDYING (整理)</strong>：<ul>
<li><strong>状态</strong>：所有任务都已终止，线程数为 0。</li>
<li><strong>转换</strong>：当线程池处于 <code>SHUTDOWN</code> 或 <code>STOP</code> 状态，且所有任务都已完成、线程都已销毁时，进入此状态。</li>
</ul>
</li>
<li><strong>TERMINATED (终止)</strong>：<ul>
<li><strong>状态</strong>：彻底终止，可以安全地进行回收。</li>
<li><strong>转换</strong>：<code>TIDYING</code> 状态下，<code>terminated()</code> 方法执行完毕后进入此状态。</li>
</ul>
</li>
</ol>
<h3 id="三、线程池的启动流程-任务提交过程"><a href="#三、线程池的启动流程-任务提交过程" class="headerlink" title="三、线程池的启动流程 (任务提交过程)"></a>三、线程池的启动流程 (任务提交过程)</h3><p>当调用 <code>executor.execute(Runnable task)</code> 方法提交一个新任务时，线程池会按照以下严格的流程来决定如何处理任务：</p>
<ol>
<li><strong>核心线程检查</strong>：<ul>
<li>如果当前线程池中的线程数量<strong>小于</strong> <code>corePoolSize</code>，则创建并启动一个新线程来执行任务。即使有空闲的线程，也会创建新线程直到达到核心线程数。</li>
</ul>
</li>
<li><strong>任务队列检查</strong>：<ul>
<li>如果当前线程池中的线程数量<strong>等于或大于</strong> <code>corePoolSize</code>，则将任务放入任务队列 <code>workQueue</code> 中等待。</li>
</ul>
</li>
<li><strong>最大线程数检查</strong>：<ul>
<li>如果任务队列已满，线程池会再次检查当前线程数。</li>
<li>如果当前线程数量<strong>小于</strong> <code>maximumPoolSize</code>，则创建并启动一个新线程（非核心线程）来执行任务。</li>
</ul>
</li>
<li><strong>拒绝策略</strong>：<ul>
<li>如果任务队列已满，且当前线程数已达到 <code>maximumPoolSize</code>，则根据线程池的<strong>拒绝策略</strong>来处理这个新任务。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：线程池的运行是一个复杂的、多阶段的过程。它优先使用核心线程，然后将任务放入队列，最后才考虑创建非核心线程。这个流程设计旨在最大限度地利用现有线程，减少线程创建和销毁的开销，从而提高性能和资源利用率。</p>
<h2 id="ThreadLocal："><a href="#ThreadLocal：" class="headerlink" title="ThreadLocal："></a>ThreadLocal：</h2><p>好的，我们来详细聊聊 <code>ThreadLocal</code>。</p>
<h3 id="ThreadLocal-是什么？"><a href="#ThreadLocal-是什么？" class="headerlink" title="ThreadLocal 是什么？"></a><code>ThreadLocal</code> 是什么？</h3><p><code>ThreadLocal</code>（线程本地变量）并不是用来解决线程间共享数据问题的，它的核心作用是<strong>为每个使用该变量的线程都提供一个独立的、隔离的副本</strong>。</p>
<p>你可以把 <code>ThreadLocal</code> 想象成一个“线程专属的储物柜”。每个线程都可以往这个储物柜里存东西（通过 <code>set()</code> 方法），取东西（通过 <code>get()</code> 方法），但它只能看到自己储物柜里的东西，无法访问其他线程的。</p>
<p><code>ThreadLocal</code> 内部其实是通过一个 <code>ThreadLocalMap</code> 来实现的。这个 Map 的键是 <code>ThreadLocal</code> 对象本身，值就是你存入的那个变量。每个线程都有一个属于自己的 <code>ThreadLocalMap</code>。</p>
<hr>
<h3 id="为什么需要-ThreadLocal？"><a href="#为什么需要-ThreadLocal？" class="headerlink" title="为什么需要 ThreadLocal？"></a>为什么需要 <code>ThreadLocal</code>？</h3><p>我们通常在开发中会遇到两种数据共享问题：</p>
<ol>
<li><strong>多个线程共享一个变量</strong>：这种情况下，需要通过 <code>synchronized</code>、<code>volatile</code> 或 <code>Lock</code> 来保证线程安全。</li>
<li><strong>每个线程需要一个独立的变量</strong>：这是 <code>ThreadLocal</code> 的主要应用场景。</li>
</ol>
<p>如果不用 <code>ThreadLocal</code>，我们可能需要自己手动维护一个 <code>Map&lt;Thread, Object&gt;</code>，每次存取数据时都以当前线程作为键。这样不仅麻烦，还容易出错。<code>ThreadLocal</code> 帮我们封装了这些细节，让使用变得非常简单。</p>
<hr>
<h3 id="ThreadLocal-的常见应用场景"><a href="#ThreadLocal-的常见应用场景" class="headerlink" title="ThreadLocal 的常见应用场景"></a><code>ThreadLocal</code> 的常见应用场景</h3><p><code>ThreadLocal</code> 最常见的应用场景是在 Web 开发中，用于<strong>存储与当前请求相关的上下文信息</strong>。</p>
<p>例如，一个 HTTP 请求从进入服务器到返回响应，可能由多个方法或组件来处理，但它们都属于同一个线程。如果需要传递一些请求相关的状态（比如用户身份、事务 ID、数据库连接），我们有很多种做法：</p>
<ul>
<li><strong>参数传递</strong>：将这些信息作为参数层层传递。这会导致方法签名变得臃肿，并且增加了代码的耦合性。</li>
<li><strong>静态变量</strong>：如果用静态变量，多个请求同时到达时会互相覆盖，导致线程不安全。</li>
<li><strong>ThreadLocal</strong>：这是最优雅的解决方案。你可以把这些信息存入 <code>ThreadLocal</code>，然后在任何需要的地方直接通过 <code>get()</code> 方法获取，无需在方法间显式传递。</li>
</ul>
<p><strong>典型的例子：</strong></p>
<ul>
<li><strong>Spring 的事务管理</strong>：Spring 框架在处理事务时，会使用 <code>ThreadLocal</code> 来保存每个线程的数据库连接，确保在同一个事务中的所有操作都使用同一个连接。</li>
<li><strong>上下文信息</strong>：例如，在请求处理链中，将用户登录信息、语言偏好等数据存入 <code>ThreadLocal</code>，下游的业务逻辑可以随时获取。</li>
</ul>
<hr>
<h3 id="ThreadLocal-可能带来的问题"><a href="#ThreadLocal-可能带来的问题" class="headerlink" title="ThreadLocal 可能带来的问题"></a><code>ThreadLocal</code> 可能带来的问题</h3><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><strong>内存泄漏</strong></h4><p><code>ThreadLocal</code> 可能会导致<strong>内存泄漏</strong>。这是一个非常重要的问题。</p>
<p><code>ThreadLocalMap</code> 使用的是<strong>弱引用（Weak Reference）</strong> 作为键。这意味着，当 <code>ThreadLocal</code> 对象没有其他强引用时，即使它还在 <code>ThreadLocalMap</code> 中，垃圾回收器也会回收它。</p>
<p>但是，<code>ThreadLocalMap</code> 的值（也就是你存入的对象）是<strong>强引用</strong>。如果线程一直存活，但你不再使用 <code>ThreadLocal</code> 对象，<code>ThreadLocalMap</code> 中的键就会变成 <code>null</code>，但值还在。这样，值对象就无法被回收，导致内存泄漏。</p>
<p>如何避免？</p>
<p>解决这个问题的关键在于：在 ThreadLocal 使用完毕后，务必调用 remove() 方法。</p>
<p>在 Web 应用中，请求处理结束后，线程会被放回线程池。如果 <code>ThreadLocal</code> 没有被清除，那么下一次其他请求再拿到这个线程时，它会读取到上一个请求残留的数据，导致业务逻辑出错。因此，<strong>正确使用模式</strong>通常是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;My Data&quot;</span>);</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 确保在任何情况下都执行清理操作</span></span><br><span class="line">    threadLocal.remove(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocalMap</code> 使用弱引用作为键，但使用强引用作为值，这样做主要是为了优化内存管理并处理由 <code>ThreadLocal</code> 引起的潜在内存泄漏问题。这种设计虽然能解决一些问题，但也引入了新的挑战。</p>
<h3 id="为什么键是弱引用？"><a href="#为什么键是弱引用？" class="headerlink" title="为什么键是弱引用？"></a>为什么键是弱引用？</h3><p><code>ThreadLocalMap</code> 的键是 <code>ThreadLocal</code> 对象的弱引用。当一个 <code>ThreadLocal</code> 对象没有其他地方（比如一个变量）引用它时，它就会被垃圾回收器回收。</p>
<ul>
<li><strong>避免键的内存泄漏：</strong> 如果键是强引用，即使 <code>ThreadLocal</code> 对象在程序中不再被使用，只要线程还活着，这个 <code>ThreadLocalMap</code> 实例就会一直持有对它的强引用，导致 <code>ThreadLocal</code> 对象本身无法被回收，从而引起内存泄漏。通过使用弱引用，当 <code>ThreadLocal</code> 变量超出作用域后，即使线程依然存活，<code>ThreadLocalMap</code> 中的键也会被自动回收。</li>
</ul>
<h3 id="为什么值是强引用？"><a href="#为什么值是强引用？" class="headerlink" title="为什么值是强引用？"></a>为什么值是强引用？</h3><p>与键不同，<code>ThreadLocalMap</code> 的值（也就是你通过 <code>set</code> 方法存入的对象）是强引用。</p>
<ul>
<li><strong>确保值的可用性：</strong> 如果值也是弱引用，那么当 <code>ThreadLocal</code> 变量超出作用域后，值也可能随时被垃圾回收器回收。这样一来，当你再次通过 <code>get</code> 方法访问时，就会得到 <code>null</code>，这与 <code>ThreadLocal</code> 的使用初衷相悖。<code>ThreadLocal</code> 的目的是为每个线程提供独立的、可以持续访问的变量副本。</li>
</ul>
<h3 id="这种设计带来的内存泄漏问题"><a href="#这种设计带来的内存泄漏问题" class="headerlink" title="这种设计带来的内存泄漏问题"></a>这种设计带来的内存泄漏问题</h3><p>虽然键的弱引用设计解决了 <code>ThreadLocal</code> 对象的内存泄漏，但如果开发者没有正确地处理，仍然会导致值的内存泄漏。</p>
<p>考虑以下场景：</p>
<ol>
<li>你在一个线程中创建了一个 <code>ThreadLocal</code> 对象，并设置了一个值。</li>
<li><code>ThreadLocalMap</code> 中会有一个键值对，键是 <code>ThreadLocal</code> 对象的弱引用，值是你设置的对象。</li>
<li><code>ThreadLocal</code> 对象在外部不再被强引用，被垃圾回收器回收。</li>
<li>此时 <code>ThreadLocalMap</code> 中的键变为 <code>null</code>，但值依然存在，因为它是一个强引用。</li>
</ol>
<p>如果线程一直存活（比如在线程池中），而你没有手动调用 <code>ThreadLocal.remove()</code>，那么这个值为 <code>null</code> 的键值对就会一直占用内存，导致内存泄漏。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了解决这个问题，Java 社区推荐的<strong>最佳实践</strong>是：<strong>无论何时使用完 ThreadLocal 变量，都应该显式地调用 ThreadLocal.remove() 方法。</strong></p>
<p><code>ThreadLocal.remove()</code> 会从 <code>ThreadLocalMap</code> 中移除对应的键值对，从而释放内存，避免内存泄漏。这个操作通常应该放在 <code>finally</code> 块中，以确保即使发生异常，也能执行清理工作。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;MyObject&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(<span class="keyword">new</span> <span class="title class_">MyObject</span>());</span><br><span class="line">    <span class="comment">// 业务逻辑...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>总而言之，<code>ThreadLocalMap</code> 的设计是一种<strong>平衡</strong>。它利用弱引用来自动处理 <code>ThreadLocal</code> 对象的回收，从而减轻了开发者的负担。但与此同时，它把值的清理责任留给了开发者，要求我们通过 <code>remove()</code> 方法来显式地释放内存，从而避免因长期存活的线程而导致的值的内存泄漏。</p>
<h4 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a><strong>继承问题</strong></h4><p><code>ThreadLocal</code> 的值不会自动传递给子线程。如果你需要父线程创建子线程时，让子线程也能访问父线程的 <code>ThreadLocal</code> 值，你需要使用 <code>InheritableThreadLocal</code>。不过，<code>InheritableThreadLocal</code> 同样需要注意内存泄漏问题，并且在线程池环境下使用时可能会有意外行为，需要格外小心。</p>
<h2 id="Collection-集合框架"><a href="#Collection-集合框架" class="headerlink" title="Collection (集合框架):"></a>Collection (集合框架):</h2><ul>
<li>核心接口: Collection (父接口), List, Set, Map。</li>
<li>Iterable 接口: Collection 接口继承了 Iterable 接口,使得所有集合都可以通过增强for 循环(foreach)进行遍历。</li>
</ul>
<h4 id="A-List-接口及其实现类"><a href="#A-List-接口及其实现类" class="headerlink" title="A. List 接口及其实现类"></a>A. List 接口及其实现类</h4><p>List 是一种有序集合,可以包含重复元素。</p>
<h5 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h5><ul>
<li><p>底层实现:基于动态数组(Object[] elementData)实现。</p>
</li>
<li><p>特点:</p>
<ul>
<li>有序:元素有插入顺序,可以通过索引访问(get(index))。</li>
<li>可重复:允许存储重复元素。</li>
<li>随机访问效率高:通过索引访问元素(get(index))速度非常快,时间复杂度为O(1)。这是因为数组在内存中是连续存储的,可以通过基地址和偏移量直接计算出元素的内存地址。</li>
<li>插入和删除效率低:<ul>
<li>在数组末尾添加或删除元素效率较高(平均O(1))。</li>
<li>在数组中间插入或删除元素时,需要使用System.arraycopy()移动被影响位置之后的所有元素,时间复杂度为 O(n)。</li>
</ul>
</li>
<li>线程不安全:在多线程环境下,如果一个线程正在修改 ArrayList,而另一个线程正在读取或修改它,可能会导致数据不一致或 ConcurrentModificationException(在使用迭代器时)。</li>
</ul>
</li>
<li><p>扩容机制:</p>
<ul>
<li>初始容量:默认情况下,当你创建一个无参的ArrayList时,它的底层数组是空的(DEFAULTCAPACITY_EMPTY_ELEMENTDATA, 即 new Object[0])。首次添加元素时,内部数组会被初始化为默认容量 DEFAULT_CAPACITY (JDK8为10)。如果你在创建时指定了容量(new ArrayList&lt;&gt;(capacity)),则初始容量就是你指定的。</li>
<li>扩容时机:当ArrayList 的当前元素个数(size)等于底层数组的容量(elementData.length)时,就会触发扩容。</li>
<li>扩容方式:扩容逻辑位于grow()方法中。<ul>
<li>计算新的容量:newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),即新容量是旧容量的1.5倍。</li>
<li>如果计算出的新容量仍然小于需要的最小容量(minCapacity,即当前元素个数 size + 1),则直接将 minCapacity 作为新容量。</li>
<li>如果新容量超出了MAX_ARRAY_SIZE(通常是 Integer.MAX_VALUE-8),则会尝试使用 Integer.MAX_VALUE,如果仍不足则抛出 OutOfMemoryError。</li>
<li>创建一个新数组,并将旧数组中的元素复制到新数组中(Arrays.copyOf()内部调用 System.arraycopy())。</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么这么扩容(1.5倍):</p>
<ul>
<li>平衡空间与时间:<ul>
<li>相比于每次只增加1个元素,1.5倍的扩容策略减少了扩容的次数,从而减少了频繁进行数组复制带来的性能开销(数组复制是O(n)操作)。</li>
<li>相比于2倍扩容,1.5倍的策略在空间利用率上更优,避免了过度分配和浪费过多内存。</li>
</ul>
</li>
<li>这是一个在时间和空间之间权衡的选择,旨在提供一个相对高效且内存友好的动态数组实现。</li>
</ul>
</li>
<li><p>可能出现的问题:</p>
<ul>
<li>ConcurrentModificationException: 在多线程环境中,如果一个线程正在遍历 ArrayList(通过迭代器或增强 for循环),而另一个线程同时对其进行结构性修改(添加、删除元素等),就会抛出此异常。这是因为ArrayList 的迭代器是快速失败(fail-fast)的,它会检查 modCount(修改次数)是否与迭代器创建时一致。不一致则抛出异常。</li>
<li>内存开销:如果预估容量不准确,频繁扩容会导致多次数组复制,增加 CPU和内存开销。</li>
<li>内存浪费:如果初始容量设置过大,而实际使用的元素很少,会导致内存浪费。</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>add(E e): 在列表末尾添加元素。</li>
<li>add(int index, E e): 在指定位置插入元素。</li>
<li>remove(int index) &#x2F; remove(Object o): 删除指定位置或指定元素的第一个匹配项。</li>
<li>get(int index):获取指定位置的元素。</li>
<li>set(int index, E e): 替换指定位置的元素。</li>
<li>size(): 返回列表中元素的个数。</li>
<li>indexOf(Object o) &#x2F; lastIndexOf(Object o):返回元素第一次&#x2F;最后一次出现的索引。</li>
<li>contains(Object o): 判断是否包含某个元素。</li>
<li>clear(): 清空列表。</li>
</ul>
</li>
<li><p>遍历方式:</p>
<ol>
<li><p>传统 for 循环:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增强 for 循环(foreach):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (E element: list) &#123; <span class="comment">//内部使用迭代器</span></span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器(Iterator):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">    <span class="comment">// 如果需要删除元素,必须使用 it.remove(),否则会抛出</span></span><br><span class="line">    <span class="comment">// ConcurrentModificationException</span></span><br><span class="line">    <span class="comment">// it.remove();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8 Stream API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">list.stream().forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p><code>RandomAccess</code> 是 Java 集合框架中的一个<strong>标记接口</strong>，它本身不包含任何方法。它的主要作用是告诉 Java 虚拟机（JVM）和开发者，实现了这个接口的 <code>List</code> 集合<strong>支持快速随机访问</strong>，即通过索引访问元素时，性能是恒定的，通常为 O(1)。</p>
<hr>
<h3 id="ArrayList-实现-RandomAccess-的作用"><a href="#ArrayList-实现-RandomAccess-的作用" class="headerlink" title="ArrayList 实现 RandomAccess 的作用"></a><code>ArrayList</code> 实现 <code>RandomAccess</code> 的作用</h3><p><code>ArrayList</code> 的底层是<strong>数组</strong>。通过索引访问数组元素（如 <code>list.get(i)</code>）是一个非常高效的操作，因为它直接通过内存地址偏移量来查找，耗时是固定的。</p>
<p><code>RandomAccess</code> 接口的作用就是为这种特性提供一个<strong>标记</strong>。在某些算法或方法中（比如 <code>Collections.binarySearch()</code>），程序会先检查一个 <code>List</code> 是否实现了 <code>RandomAccess</code>。</p>
<ul>
<li>如果实现了，就说明它是 <code>ArrayList</code> 这类基于数组的列表，此时会选择<strong>基于索引的 for 循环</strong>进行遍历，因为这种方式最快。</li>
<li>如果没实现，就说明它是 <code>LinkedList</code> 这类基于链表的列表，此时会选择<strong>迭代器</strong>进行遍历，以避免低效的随机访问。</li>
</ul>
<p>因此，<code>RandomAccess</code> 就像一个性能提示标签，帮助 JVM 和算法选择最合适的遍历或查找策略，从而优化性能。</p>
<hr>
<h3 id="为什么-LinkedList-没有实现-RandomAccess？"><a href="#为什么-LinkedList-没有实现-RandomAccess？" class="headerlink" title="为什么 LinkedList 没有实现 RandomAccess？"></a>为什么 <code>LinkedList</code> 没有实现 <code>RandomAccess</code>？</h3><p><code>LinkedList</code> 的底层是<strong>双向链表</strong>。要通过索引访问链表中的一个元素（如 <code>list.get(i)</code>），需要从头节点或尾节点开始，逐个遍历到目标位置。这个操作的耗时与索引值 <code>i</code> 成正比，时间复杂度为 O(n)。</p>
<p>因为 <code>LinkedList</code> 不支持快速随机访问，所以它没有实现 <code>RandomAccess</code> 接口。如果用 for 循环来遍历 <code>LinkedList</code>，每次 <code>get(i)</code> 调用都会导致一次从头到尾的遍历，效率极低。相反，使用迭代器则能确保每次只移动到下一个元素，效率更高。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>底层数据结构</th>
<th>随机访问性能 (<code>get(i)</code>)</th>
<th>遍历方式</th>
<th>是否实现 <code>RandomAccess</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ArrayList</strong></td>
<td>数组</td>
<td>O(1)</td>
<td><strong>for 循环</strong></td>
<td>是</td>
</tr>
<tr>
<td><strong>LinkedList</strong></td>
<td>双向链表</td>
<td>O(n)</td>
<td><strong>迭代器</strong></td>
<td>否</td>
</tr>
</tbody></table>
<p>总而言之，<code>RandomAccess</code> 接口是一个重要的设计模式，它利用多态性来指导程序为不同的 <code>List</code> 实现选择最优的算法，从而在不修改代码逻辑的前提下提升了性能。</p>
<h5 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h5><ul>
<li><p>底层实现:基于双向链表(Doubly Linked List)实现。每个节点都包含数据,以及指向前一个节点和后一个节点的引用。</p>
</li>
<li><p>特点:</p>
<ul>
<li>有序:元素有插入顺序。</li>
<li>可重复:允许存储重复元素。</li>
<li>插入和删除效率高:在链表的任何位置插入或删除元素,只需修改前后节点的引用,时间复杂度为O(1)。</li>
<li>随机访问效率低:get(index)操作需要从头节点或尾节点开始遍历链表直到目标索引,时间复杂度为O(n)。</li>
<li>内存开销大:每个节点除了存储数据本身,还需要额外的内存空间存储两个指针(prev 和 next),因此相比 ArrayList,在存储相同数量元素时, LinkedList 占用更多内存。</li>
<li>线程不安全:与ArrayList 类似,在多线程环境下不安全,可能抛出 ConcurrentModificationException。</li>
</ul>
</li>
<li><p>扩容机制:</p>
<ul>
<li>LinkedList 基于链表实现,没有固定容量的概念,也无需进行扩容。每次添加元素就是创建一个新节点并连接到链表中。因此不存在 ArrayList 那样的数组复制开销。</li>
</ul>
</li>
<li><p>可能出现的问题:</p>
<ul>
<li>ConcurrentModification Exception:同样在多线程环境下使用迭代器进行修改时可能发生。</li>
<li>内存碎片&#x2F;开销:频繁的节点创建和销毁,以及每个节点额外的指针开销,可能导致一定的内存碎片和更高的内存占用。</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>add(E e) &#x2F; addFirst(E e) &#x2F; addLast(E e): 添加元素。</li>
<li>remove() &#x2F; removeFirst() &#x2F; removeLast():删除元素。</li>
<li>get(int index) &#x2F; getFirst() &#x2F; getLast(): 获取元素(get(int index)效率低)。</li>
<li>peek() &#x2F; peekFirst() &#x2F; peekLast(): 获取但不移除头部&#x2F;尾部元素。</li>
<li>offer(E e) &#x2F; offerFirst(E e) &#x2F; offerLast (E e): 添加元素到队列&#x2F;双端队列(通常不抛异常)。</li>
<li>poll() &#x2F; pollFirst() &#x2F; pollLast(): 获取并移除头部&#x2F;尾部元素(为空返回null)。</li>
<li>push(E e) &#x2F; pop():实现栈的入栈和出栈操作。</li>
<li>size(), isEmpty(), contains(Object o), clear().</li>
</ul>
</li>
<li><p>遍历方式:</p>
<ol>
<li><p>传统 for 循环: <code>for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125;</code>(不推荐,效率低)</p>
</li>
<li><p>增强 for 循环(foreach): <code>for (E element: list) &#123; System.out.println(element); &#125;</code>(推荐)</p>
</li>
<li><p>迭代器(Iterator):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8 Stream API: <code>list.forEach(System.out::println);</code></p>
</li>
</ol>
</li>
</ul>
<h5 id="3-Vector"><a href="#3-Vector" class="headerlink" title="3. Vector"></a>3. Vector</h5><ul>
<li>底层实现:基于动态数组实现,与ArrayList 类似。</li>
<li>特点:<ul>
<li>线程安全:所有公共方法都使用了synchronized 关键字进行同步,因此是线程安全的。</li>
<li>效率低:因为所有操作都被同步,在单线程或并发读多写少的场景下,性能比 ArrayList 差。</li>
<li>扩容机制: Vector 的扩容策略与 ArrayList 类似,但默认是翻倍扩容(即新容量是旧容量的2倍)。可以通过构造函数指定扩容增量。</li>
</ul>
</li>
<li>可能出现的问题:<ul>
<li>性能瓶颈:全局锁导致并发性能差。</li>
</ul>
</li>
<li>使用场景:已经被 java.util.concurrent 包中的并发集合(如 CopyOnWriteArrayList)取代,基本不再推荐使用。</li>
</ul>
<h5 id="4-Stack"><a href="#4-Stack" class="headerlink" title="4. Stack"></a>4. Stack</h5><ul>
<li>底层实现:继承自Vector,因此也是基于数组实现,并具有Vector 的线程安全性。</li>
<li>特点:实现了后进先出(LIFO)的栈结构。</li>
<li>常用方法:<ul>
<li>push(E item):元素入栈。</li>
<li>pop():元素出栈。</li>
<li>peek(): 查看栈顶元素但不移除。</li>
<li>empty(): 判断栈是否为空。</li>
<li>search(Object o): 查找元素并返回离栈顶的距离。</li>
</ul>
</li>
<li>使用场景:不推荐使用,因为Stack 继承了Vector,而 Vector 本身有很多不适合栈操作的方法。通常使用 Deque 接口的实现类(如ArrayDeque 或 LinkedList)来代替栈,它们更灵活高效。</li>
</ul>
<h4 id="小结-List"><a href="#小结-List" class="headerlink" title="小结 List:"></a>小结 List:</h4><ul>
<li>ArrayList: 随机访问多,插入删除少(尤其末尾操作)的场景。</li>
<li>LinkedList: 插入删除多,随机访问少的场景;或需要作为队列&#x2F;栈使用的场景。</li>
<li>Vector &#x2F; Stack:不推荐在现代Java开发中使用,除非有特殊历史兼容需求。</li>
</ul>
<h4 id="B-Set-接口及其实现类"><a href="#B-Set-接口及其实现类" class="headerlink" title="B. Set 接口及其实现类"></a>B. Set 接口及其实现类</h4><p>Set 是一种无序集合,不允许重复元素。</p>
<h5 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h5><ul>
<li><p>底层实现:基于HashMap 实现。HashSet 内部使用一个 HashMap 实例来存储元素,HashSet 的元素作为HashMap的键(Key),而HashMap 的值(Value)则是一个固定的、无关紧要的 PRESENT 静态 Object 对象。</p>
</li>
<li><p>特点:</p>
<ul>
<li>无序:不保证元素的存储顺序和迭代顺序。</li>
<li>不可重复:元素唯一。通过元素的hashCode() 和 equals() 方法来判断元素的唯一性。当添加元素时,首先计算元素的hashCode(),然后根据哈希值找到对应的“桶”,再在该桶中遍历,如果存在 equals()为true 的元素,则不添加。</li>
<li>允许 null元素:允许且只能存储一个 null 元素。</li>
<li>查询、添加、删除的平均时间复杂度为(1) (在不发生哈希冲突或冲突较少的情况下)。最坏情况下(所有元素哈希冲突到同一个桶),会退化为 O(n)。</li>
<li>线程不安全:与HashMap 类似,非同步。</li>
</ul>
</li>
<li><p>扩容机制:</p>
<ul>
<li>由于底层是HashMap,其扩容机制与 HashMap 完全相同。</li>
<li>初始容量:默认初始容量为16。</li>
<li>负载因子:默认负载因子为0.75。</li>
<li>扩容时机:当HashSet 中存储的元素数量达到容量*负载因子时,就会进行扩容,新容量是旧容量的2倍。</li>
<li>扩容过程:创建一个新的两倍大小的底层数组,然后遍历旧数组中的所有元素,重新计算它们的哈希值,并将它们放入新数组的正确位置。</li>
</ul>
</li>
<li><p>可能出现的问题:</p>
<ul>
<li>性能下降: 如果自定义类作为元素存储在 HashSet 中，但没有正确重写 hashCode() 和 equals() 方法，可能会导致元素重复，或者哈希冲突严重，从而导致性能急剧下降。</li>
<li>ConcurrentModicationException: 同步性问题，在多线程环境下使用迭代器修改集合时会抛出。</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>add(E e): 添加元素。</li>
<li>remove(Object o): 删除元素。</li>
<li>contains(Object o): 判断是否包含元素。</li>
<li>size(): 返回集合中元素的个数。</li>
<li>isEmpty(), clear().</li>
</ul>
</li>
<li><p>遍历方式:</p>
<ol>
<li><p>增强 for 循环 (foreach): <code>for (E element : set) &#123; System.out.println(element); &#125;</code></p>
</li>
<li><p>迭代器 (Iterator):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = set.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8 Stream API: <code>set.forEach(System.out::println);</code></p>
</li>
</ol>
</li>
</ul>
<h5 id="2-LinkedHashSet"><a href="#2-LinkedHashSet" class="headerlink" title="2. LinkedHashSet"></a>2. LinkedHashSet</h5><ul>
<li>底层实现: 继承自 HashSet，内部使用 LinkedHashMap 实现。</li>
<li>特点:<ul>
<li>除了具备 HashSet 的所有特性外，最大的特点是保持元素的插入顺序（或者访问顺序，如果配置为 LRU 缓存）。这意味着遍历 LinkedHashSet时，元素的顺序与它们被添加到集合中的顺序一致。</li>
<li>维护了一个双向链表，用于维护元素的插入顺序。</li>
</ul>
</li>
<li>扩容机制: 与 HashSet 和 HashMap 相同。</li>
<li>使用场景: 需要去重，同时又需要保持元素插入顺序的场景。</li>
</ul>
<h5 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3. TreeSet"></a>3. TreeSet</h5><ul>
<li>底层实现: 基于 TreeMap 实现。TreeSet 内部使用一个 TreeMap 实例来存储元素，TreeSet 的元素作为 TreeMap 的键，而值则是一个固定的 Object。</li>
<li>特点:<ul>
<li>有序: 元素会根据其自然排序（元素必须实现 Comparable 接口）或者在创建 TreeSet 时提供的 Comparator 进行排序。</li>
<li>不可重复: 元素唯一，唯一性通过比较结果判断（compareTo() 或 compare() 方法返回 0）。</li>
<li>不允许 null 元素: 不允许存储 null 元素（因为 null 无法进行比较）。</li>
<li>查询、添加、删除的时间复杂度为 O(log n)，因为底层是红黑树。</li>
<li>线程不安全: 非同步。</li>
</ul>
</li>
<li>扩容机制:<ul>
<li>由于底层是红黑树，没有传统意义上的扩容机制。每次添加元素就是增加一个节点，并根据红黑树的平衡规则进行调整（旋转和变色）来保持树的平衡。</li>
</ul>
</li>
<li>可能出现的问题:<ul>
<li>性能: 相比 HashSet，性能略低，因为涉及比较和树的平衡操作。</li>
<li>元素必须可比较: 如果存储的元素没有实现 Comparable 接口，或者创建 TreeSet 时没有提供 Comparator，则会抛出 ClassCastException。</li>
<li>ConcurrentModicationException: 同步性问题。</li>
</ul>
</li>
<li>常用方法:<ul>
<li>与 HashSet 类似，但额外提供了与排序相关的方法，如 rst(), last(), headSet(), tailSet(), subSet() 等。</li>
</ul>
</li>
</ul>
<h4 id="小结-Set"><a href="#小结-Set" class="headerlink" title="小结 Set:"></a>小结 Set:</h4><ul>
<li>HashSet: 最常用，需要快速查找、去重，不关心元素顺序的场景。</li>
<li>LinkedHashSet: 需要去重，同时又需要保持元素插入顺序的场景。</li>
<li>TreeSet: 需要去重，并且希望元素自动按照自然顺序或自定义顺序排序的场景。</li>
</ul>
<h4 id="C-Map-接口及其实现类"><a href="#C-Map-接口及其实现类" class="headerlink" title="C. Map 接口及其实现类"></a>C. Map 接口及其实现类</h4><p>Map 存储键值对，键是唯一的，值可以重复。</p>
<h5 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h5><ul>
<li><p>底层实现: 基于哈希表实现，JDK 8 及以后是数组 + 链表 + 红黑树。</p>
<ul>
<li>数组: Node</li>
<li>链表: 用于解决哈希冲突，将哈希到同一个索引位置的键值对以链表形式连接。</li>
<li>红黑树: 当链表长度达到一定阈值（JDK 8 默认为 8）时，为了提高查找效率，该链表会转换为红黑树。当红黑树节点数少于一定阈值（JDK 8 默认为 6）时，会退化为链表。</li>
</ul>
</li>
<li><p>特点:</p>
<ul>
<li>无序: 不保证键值对的存储和迭代顺序。</li>
<li>键唯一，值可重复: 键通过 hashCode() 和 equals() 方法确定唯一性。</li>
<li>允许 null 键和 null 值: 只能有一个 null 键（存储在索引 0 的位置），可以有多个 null 值。</li>
<li>查询、添加、删除的平均时间复杂度为 O(1)，最坏情况下为 O(n)（链表）或 O(logn)（红黑树，JDK 8 及以后）。</li>
</ul>
</li>
<li><p>扩容机制:</p>
<ul>
<li><p>初始容量 (initialCapacity): 默认值为 16。最好在创建 HashMap 时预估并指定一个合适的初始容量，以减少扩容次数。</p>
</li>
<li><p>负载因子 (loadFactor): 默认值为 0.75。表示哈希表在进行扩容前的填充比例。</p>
</li>
<li><p>扩容时机: 当 HashMap 中存储的元素数量 (size) 达到 容量 * 负载因子 (即 threshold) 时，就会触发扩容。</p>
</li>
<li><p>扩容方式: resize() 方法。</p>
<ol>
<li>创建一个新的两倍大小的底层数组。</li>
<li>遍历旧数组中的所有键值对。</li>
<li>重新计算每个键的哈希值，并根据新的容量大小，将其放入新数组的正确位置。这个过程被称为再哈希 (rehash)。</li>
</ol>
<ul>
<li>JDK 8 优化: 在链表转换时，避免了每个节点单独重新计算哈希值，而是根据原索引和新容量的关系，直接判断节点在新数组中的位置，提高了效率。</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么这么扩容 (2 倍):</p>
<ul>
<li>位运算优化: 容量始终保持 2 的幂次方，可以利用位运算 (h &amp; (length - 1)) 来替代取模运算 h % length，提高哈希值到索引的映射效率。</li>
<li>减少哈希冲突: 扩容为 2 倍可以有效分散哈希冲突，使得更多的键能够映射到不同的桶，从而降低链表&#x2F;红黑树的长度，保持 O(1) 的平均性能。</li>
</ul>
</li>
<li><p>为什么负载因子是 0.75:</p>
<ul>
<li>这是一个在“空间利用率”和“查询效率”之间的权衡。</li>
<li>如果负载因子过小，会频繁扩容，浪费空间。</li>
<li>如果负载因子过大，哈希冲突会增加，链表&#x2F;红黑树变长，导致查询效率下降。</li>
<li>0.75 这个值是经过实践验证，在大多数情况下能够提供较好性能的平衡点。</li>
</ul>
</li>
<li><p>可能出现的问题:</p>
<ul>
<li>性能下降: 如果自定义类作为键存储在 HashMap 中，但没有正确重写 hashCode() 和 equals() 方法，会导致元素重复，或者哈希冲突严重，从而导致性能急剧下降。</li>
<li>多线程问题: 在多线程环境下，对 HashMap 进行修改操作可能导致数据丢失、死循环（JDK 7 及以前），或 ConcurrentModicationException。这是其最大的问题。</li>
<li>内存开销: 频繁扩容会带来数组复制的开销。</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>put(K key, V value): 关联键值对。</li>
<li>get(Object key):</li>
</ul>
</li>
<li><p>遍历方式:</p>
<ol>
<li><p>遍历键集 (keySet()):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (K key : map.keySet()) &#123;</span><br><span class="line">    V value = map.get(key);</span><br><span class="line">    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历键值对集 (entrySet()) - 推荐，效率最高:</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Value: &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历值集 (values()):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (V value : map.values()) &#123;</span><br><span class="line">    System.out.println(&quot;Value: &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器 (Iterator):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = it.next();</span><br><span class="line">    System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Value: &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8 Stream API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h5 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2. LinkedHashMap"></a>2. LinkedHashMap</h5><ul>
<li>底层实现: 继承自 HashMap，额外维护了一个双向链表，用于维护插入顺序或访问顺序。</li>
<li>特点:<ul>
<li>除了具备 HashMap 的所有特性外，最大的特点是保持键值对的插入顺序（或访问顺序）。这意味着遍历 LinkedHashMap 时，元素的顺序与它们被添加到 Map 中的顺序一致。</li>
<li>可以用于实现 LRU (Least Recently Used) 缓存策略，通过覆盖 removeEldestEntry 方法并设置访问顺序为 true。</li>
</ul>
</li>
<li>扩容机制: 与 HashMap 相同。</li>
<li>使用场景: 需要快速查找，同时又需要保持插入顺序的场景。</li>
</ul>
<h5 id="3-TreeMap"><a href="#3-TreeMap" class="headerlink" title="3. TreeMap"></a>3. TreeMap</h5><ul>
<li>底层实现: 基于红黑树（Red-Black Tree）实现。</li>
<li>特点:<ul>
<li>有序: 键会根据其自然排序（键的类型必须实现 Comparable 接口）或者在创建 TreeMap 时提供的 Comparator 进行排序。</li>
<li>键唯一，值可重复: 唯一性判断依赖于键的比较结果（compareTo() 或 compare() 方法返回 0）。</li>
<li>不允许 null 键: 不允许存储 null 键（因为 null 无法进行比较），但允许 null 值。</li>
<li>查询、添加、删除的时间复杂度为 O(log n)，因为底层是红黑树。</li>
<li>线程不安全: 非同步。</li>
</ul>
</li>
<li>扩容机制:<ul>
<li>由于底层是红黑树，没有传统意义上的扩容机制。每次添加键值对就是增加一个节点，并根据红黑树的平衡规则进行调整（旋转和变色）来保持树的平衡。</li>
</ul>
</li>
<li>可能出现的问题:<ul>
<li>性能: 相比 HashMap，性能略低，因为涉及比较和树的平衡操作。</li>
<li>键必须可比较: 如果键没有实现 Comparable 接口，或者创建 TreeMap 时没有提供 Comparator，则会抛出 ClassCastException。</li>
<li>ConcurrentModicationException: 同步性问题。</li>
</ul>
</li>
<li>常用方法:<ul>
<li>与 HashMap 类似，但额外提供了与排序相关的方法，如 rstKey(), lastKey(), ceilingEntry(), oorEntry() 等。</li>
</ul>
</li>
</ul>
<h5 id="4-Hashtable"><a href="#4-Hashtable" class="headerlink" title="4. Hashtable"></a>4. Hashtable</h5><ul>
<li>底层实现: 基于哈希表实现，与 HashMap 类似，但所有方法都使用了 synchronized 关键字。</li>
<li>特点:<ul>
<li>线程安全: 所有公共方法都进行了同步处理。</li>
<li>效率低: 全局锁导致并发性能差。</li>
<li>不允许 null 键和 null 值。</li>
<li>初始容量和扩容机制: 默认初始容量 11，负载因子 0.75。扩容时新容量是旧容量的 2 倍 + 1。</li>
</ul>
</li>
<li>使用场景: 已被 ConcurrentHashMap 取代，基本不再推荐使用。</li>
</ul>
<h5 id="5-ConcurrentHashMap-JUC-包中的并发集合"><a href="#5-ConcurrentHashMap-JUC-包中的并发集合" class="headerlink" title="5. ConcurrentHashMap (JUC 包中的并发集合)"></a>5. ConcurrentHashMap (JUC 包中的并发集合)</h5><ul>
<li><p>底层实现:</p>
<ul>
<li>JDK 7 及以前: 采用分段锁 (Segment) 的方式，将 HashMap 内部数据分成多个段（Segment），每个段是一个独立的 ReentrantLock。锁住某个段时，不影响其他段的操作。</li>
<li>JDK 8 及以后: 放弃了分段锁，改为使用 CAS (Compare-And-Swap) 操作和 synchronized 关键字（只在链表&#x2F;红黑树头节点发生竞争时才使用，锁住的范围更小）来保证线程安全。</li>
</ul>
</li>
<li><p>特点:</p>
<ul>
<li>线程安全: 高并发环境下性能优异。</li>
<li>不允许 null 键和 null 值。</li>
<li>读操作基本无锁。</li>
</ul>
</li>
<li><p>扩容机制: 与 HashMap 类似，JDK 8 中，每个 Node 数组的扩容是独立的，通过 transfer 方法实现。</p>
</li>
<li><p>使用场景: 高并发场景下替代 HashMap 和 Hashtable 的首选。</p>
</li>
<li><p><code>java.util.concurrent</code> (JUC) 包是 Java 并发编程的高级工具包，它提供了比传统 <code>synchronized</code> 关键字和 <code>wait/notify</code> 机制更强大、更灵活的并发控制手段。</p>
</li>
</ul>
<p>好的 ✅ 我来帮你把前面两个回答 <strong>整合成一个完整、系统、逐层递进的 ConcurrentHashMap 解析文档</strong>，内容覆盖 <strong>实现原理 + 扩容机制 + 高频面试题 + 答题模板</strong>，你可以直接拿去当复习资料或面试答题脚本。</p>
<hr>
<h1 id="🧩-ConcurrentHashMap-超详细解析（JDK8为主，含对比）"><a href="#🧩-ConcurrentHashMap-超详细解析（JDK8为主，含对比）" class="headerlink" title="🧩 ConcurrentHashMap 超详细解析（JDK8为主，含对比）"></a>🧩 ConcurrentHashMap 超详细解析（JDK8为主，含对比）</h1><hr>
<h2 id="一、背景与设计动机"><a href="#一、背景与设计动机" class="headerlink" title="一、背景与设计动机"></a>一、背景与设计动机</h2><p>在并发场景下：</p>
<ul>
<li><code>HashMap</code> 线程不安全，可能出现死循环、数据丢失。</li>
<li><code>Hashtable</code> 与 <code>Collections.synchronizedMap</code> 使用 <strong>全表锁</strong>，吞吐量极差。</li>
</ul>
<p><strong>ConcurrentHashMap（CHM）</strong>：</p>
<ul>
<li><strong>线程安全</strong>：保证多线程同时访问时数据一致性。</li>
<li><strong>高性能</strong>：通过 <strong>分桶锁 + CAS + volatile</strong> 提升并发度。</li>
<li><strong>弱一致性迭代器</strong>：遍历过程中允许修改，不会抛 <code>ConcurrentModificationException</code>。</li>
</ul>
<hr>
<h2 id="二、实现演变（JDK7-vs-JDK8）"><a href="#二、实现演变（JDK7-vs-JDK8）" class="headerlink" title="二、实现演变（JDK7 vs JDK8）"></a>二、实现演变（JDK7 vs JDK8）</h2><h3 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h3><ul>
<li>数据结构：<code>Segment[]</code> + <code>HashEntry[]</code>。</li>
<li>Segment：类似小型 HashMap，每个 Segment 有独立的 ReentrantLock。</li>
<li>并发度：由 Segment 数量决定（默认 16）。</li>
</ul>
<p>缺点：</p>
<ul>
<li>锁粒度仍然较大；</li>
<li>扩容需要锁定整个 Segment。</li>
</ul>
<hr>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><ul>
<li>数据结构：<code>Node[]</code> + 链表&#x2F;红黑树。</li>
<li>锁机制：<strong>CAS + synchronized（桶锁）</strong>，比 Segment 更细。</li>
<li>改进点：<ol>
<li>无 Segment，更细粒度控制。</li>
<li>链表冲突过长时转化为 <strong>红黑树</strong>（树化）。</li>
<li>扩容为 <strong>渐进式 + 多线程协助</strong>。</li>
<li>使用 <strong>ForwardingNode</strong> 路由迁移。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="三、核心数据结构"><a href="#三、核心数据结构" class="headerlink" title="三、核心数据结构"></a>三、核心数据结构</h2><h3 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    volatile V val;</span><br><span class="line">    volatile Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>val</code> 和 <code>next</code> 是 <code>volatile</code>，保证可见性。</li>
</ul>
<h3 id="TreeNode（红黑树节点）"><a href="#TreeNode（红黑树节点）" class="headerlink" title="TreeNode（红黑树节点）"></a>TreeNode（红黑树节点）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent, left, right, prev;</span><br><span class="line">    boolean red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当链表长度 &gt; 8 且容量 ≥ 64 时转化为红黑树。</li>
</ul>
<h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><ul>
<li>扩容时的占位符，用于标记桶已迁移，引导线程访问新表。</li>
</ul>
<hr>
<h2 id="四、核心操作流程"><a href="#四、核心操作流程" class="headerlink" title="四、核心操作流程"></a>四、核心操作流程</h2><h3 id="1-get-——-无锁读"><a href="#1-get-——-无锁读" class="headerlink" title="1. get() —— 无锁读"></a>1. get() —— 无锁读</h3><ul>
<li>直接计算 hash 定位桶。</li>
<li>如果是链表 → 遍历；</li>
<li>如果是红黑树 → 按树查找；</li>
<li>如果是 ForwardingNode → 去新表查。</li>
</ul>
<p><strong>特点</strong>：无锁，只依赖 volatile 保证可见性。</p>
<hr>
<h3 id="2-put-——-写时加锁"><a href="#2-put-——-写时加锁" class="headerlink" title="2. put() —— 写时加锁"></a>2. put() —— 写时加锁</h3><ol>
<li>计算索引位置；</li>
<li>桶为空 → CAS 插入；</li>
<li>桶非空：<ul>
<li>ForwardingNode → 协助扩容；</li>
<li>链表&#x2F;树 → synchronized 锁住桶头，再插入；</li>
</ul>
</li>
<li>插入后：<ul>
<li>如果链表长度 &gt; 8 且容量 ≥ 64 → 树化；</li>
<li>如果总数超过阈值 → 触发扩容。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-扩容机制（Transfer）"><a href="#3-扩容机制（Transfer）" class="headerlink" title="3. 扩容机制（Transfer）"></a>3. 扩容机制（Transfer）</h3><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><ul>
<li>size 超过 <code>threshold = capacity * loadFactor</code>（默认 0.75）。</li>
</ul>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol>
<li><strong>新建数组</strong>：容量翻倍。</li>
<li><strong>迁移桶</strong>：<ul>
<li>遍历旧桶，将节点分为 <strong>低位链（loHead）</strong> 和 <strong>高位链（hiHead）</strong>。</li>
<li><code>hash &amp; oldCap == 0</code> → 留在原位置；</li>
<li>否则 → 放到 <code>i+oldCap</code>。</li>
</ul>
</li>
<li><strong>标记迁移完成</strong>：<ul>
<li>旧桶置为 ForwardingNode。</li>
<li>之后读&#x2F;写遇到它时，会路由到新表。</li>
</ul>
</li>
<li><strong>多线程协助</strong>：<ul>
<li>其他线程写入时若发现正在扩容 → 调用 <code>helpTransfer()</code> → 一起分桶迁移。</li>
</ul>
</li>
<li><strong>渐进式扩容</strong>：<ul>
<li>一次只迁移一个桶，避免阻塞。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="五、并发控制机制"><a href="#五、并发控制机制" class="headerlink" title="五、并发控制机制"></a>五、并发控制机制</h2><ol>
<li><strong>CAS</strong>：初始化 table、插入第一个节点时。</li>
<li><strong>volatile</strong>：保证 val 和 next 的可见性。</li>
<li><strong>synchronized</strong>：写操作时锁定单个桶。</li>
<li><strong>ForwardingNode</strong>：保证扩容过程数据一致性。</li>
</ol>
<hr>
<h2 id="六、性能特性"><a href="#六、性能特性" class="headerlink" title="六、性能特性"></a>六、性能特性</h2><ul>
<li>读操作几乎无锁 → 高性能。</li>
<li>写操作局部锁定 → 粒度小，冲突概率低。</li>
<li>扩容支持并行迁移 → 避免长时间卡顿。</li>
<li>树化避免链表退化 O(n)。</li>
</ul>
<hr>
<h2 id="七、常见高频面试题"><a href="#七、常见高频面试题" class="headerlink" title="七、常见高频面试题"></a>七、常见高频面试题</h2><h3 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h3><ol>
<li><strong>ConcurrentHashMap 和 HashMap 的区别？</strong><ul>
<li>HashMap：线程不安全；</li>
<li>ConcurrentHashMap：线程安全，CAS+桶锁；</li>
<li>数据结构都支持链表+红黑树。</li>
</ul>
</li>
<li><strong>JDK7 和 JDK8 的区别？</strong><ul>
<li>JDK7：Segment 分段锁；</li>
<li>JDK8：CAS + synchronized，锁粒度更细。</li>
</ul>
</li>
<li><strong>为什么 synchronized 而不是 ReentrantLock？</strong><ul>
<li>JDK8 之后对 synchronized 优化（偏向锁、轻量级锁）；</li>
<li>实现简洁，不需手动释放锁。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="进阶题"><a href="#进阶题" class="headerlink" title="进阶题"></a>进阶题</h3><ol>
<li><strong>为什么 get 无需加锁？</strong><ul>
<li>Node 的 val、next 是 volatile，可见性足够；</li>
<li>get 只读，不会修改结构。</li>
</ul>
</li>
<li><strong>为什么需要红黑树？</strong><ul>
<li>避免哈希冲突严重时链表退化为 O(n)。</li>
<li>树化后查询 O(log n)。</li>
</ul>
</li>
<li><strong>红黑树什么时候转化&#x2F;退化？</strong><ul>
<li>链表长度 &gt; 8 且容量 ≥ 64 → 树化；</li>
<li>树节点数 &lt; 6 → 退化为链表。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="扩容相关题"><a href="#扩容相关题" class="headerlink" title="扩容相关题"></a>扩容相关题</h3><ol>
<li><strong>ConcurrentHashMap 扩容过程？为什么说是渐进式？</strong><ul>
<li>桶级迁移，每次只迁移一个桶；</li>
<li>旧桶置为 ForwardingNode；</li>
<li>多线程可协助迁移；</li>
<li>不会一次性迁移整个表 → 避免卡顿。</li>
</ul>
</li>
<li><strong>扩容时，get 如何保证正确性？</strong><ul>
<li>遇到 ForwardingNode → 跳转新表继续查；</li>
<li>保证读到的是最新数据。</li>
</ul>
</li>
<li><strong>为什么不允许 key 或 value 为 null？</strong><ul>
<li>无法区分「null 表示没有值」还是「值本身就是 null」，容易歧义。</li>
</ul>
</li>
<li><strong>为什么迭代器是弱一致性的？</strong></li>
</ol>
<ul>
<li>遍历时允许并发修改；</li>
<li>不抛异常，但可能漏数据或读到旧值。</li>
</ul>
<ol>
<li><strong>size() 如何实现？为什么不精确？</strong></li>
</ol>
<ul>
<li>分段计数，多次尝试累加；</li>
<li>并发下不保证强一致性，只保证大致准确。</li>
</ul>
<hr>
<h3 id="高阶题"><a href="#高阶题" class="headerlink" title="高阶题"></a>高阶题</h3><ol>
<li><strong>为什么扩容时使用 ForwardingNode？</strong></li>
</ol>
<ul>
<li>防止重复迁移；</li>
<li>读写遇到它能路由到新表。</li>
</ul>
<ol>
<li><strong>ConcurrentHashMap 会死锁吗？</strong></li>
</ol>
<ul>
<li>不会。每次只锁单个桶，不存在跨桶死锁。</li>
</ul>
<ol>
<li><strong>ConcurrentHashMap 与 CopyOnWriteMap 区别？</strong></li>
</ol>
<ul>
<li>CHM：适合读多写多，分桶锁+CAS；</li>
<li>COW：适合读多写少，写时复制，读完全无锁。</li>
</ul>
<hr>
<h2 id="八、答题模板（面试框架）"><a href="#八、答题模板（面试框架）" class="headerlink" title="八、答题模板（面试框架）"></a>八、答题模板（面试框架）</h2><p>当被问到「ConcurrentHashMap」时，可以这样答：</p>
<ol>
<li><strong>整体实现</strong>：<ul>
<li>JDK7：Segment 分段锁；</li>
<li>JDK8：Node 数组 + CAS + synchronized（桶锁）。</li>
</ul>
</li>
<li><strong>核心思想</strong>：<ul>
<li>读操作无锁；</li>
<li>写操作锁单个桶；</li>
<li>扩容渐进式+多线程协助；</li>
<li>冲突过长时树化。</li>
</ul>
</li>
<li><strong>扩容机制</strong>：<ul>
<li>懒扩容，阈值触发；</li>
<li>ForwardingNode 标记已迁移桶；</li>
<li>多线程 helpTransfer；</li>
<li>渐进式迁移，避免阻塞。</li>
</ul>
</li>
<li><strong>常见问题</strong>：<ul>
<li>不允许 null key&#x2F;value；</li>
<li>弱一致性迭代器；</li>
<li>size() 不精确。</li>
</ul>
</li>
</ol>
<hr>
<p>📌 <strong>一句话总结口诀</strong>：<br> 👉 <strong>JDK7 Segment 分段锁，JDK8 CAS+桶锁；读无锁，写锁桶，扩容多线程协助；链表转树，弱一致迭代。</strong></p>
<hr>
<h1 id="🧩-一、并发工具类（协作类）"><a href="#🧩-一、并发工具类（协作类）" class="headerlink" title="🧩 一、并发工具类（协作类）"></a>🧩 一、并发工具类（协作类）</h1><p>这些工具类都在 <code>java.util.concurrent</code> 包里，用来解决线程间的 <strong>协调&#x2F;同步&#x2F;通信问题</strong>。</p>
<hr>
<h2 id="1-CountDownLatch（倒计时器）"><a href="#1-CountDownLatch（倒计时器）" class="headerlink" title="1. CountDownLatch（倒计时器）"></a>1. CountDownLatch（倒计时器）</h2><h3 id="📝-定义"><a href="#📝-定义" class="headerlink" title="📝 定义"></a>📝 定义</h3><ul>
<li>一个或多个线程等待 <strong>其他线程完成操作</strong> 后再继续。</li>
<li>内部维护一个 <code>state</code>（计数），初始值设定好，每调用一次 <code>countDown()</code>，<code>state--</code>。</li>
<li>当 <code>state=0</code> 时，<code>await()</code> 的线程全部唤醒。</li>
</ul>
<h3 id="⚙️-底层实现"><a href="#⚙️-底层实现" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul>
<li>基于 <strong>AQS（AbstractQueuedSynchronizer）</strong> 的共享锁实现。</li>
<li><code>await()</code> 会阻塞线程，直到 <code>state==0</code>；</li>
<li><code>countDown()</code> 是非阻塞的，只是原子性地减 1。</li>
</ul>
<h3 id="📌-使用场景"><a href="#📌-使用场景" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul>
<li>主线程等待多个子线程完成（<strong>一等多</strong>）。</li>
<li>例如：并行加载多个配置文件，等都加载完再合并处理。</li>
</ul>
<h3 id="🎯-面试考点"><a href="#🎯-面试考点" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul>
<li><strong>能否重用？</strong> → <strong>不能</strong>，计数归零后不能重置。</li>
<li>和 <code>CyclicBarrier</code> 的区别？→ <code>CountDownLatch</code> 是「一等多」，<code>CyclicBarrier</code> 是「多等多」。</li>
</ul>
<hr>
<h2 id="2-CyclicBarrier（循环屏障）"><a href="#2-CyclicBarrier（循环屏障）" class="headerlink" title="2. CyclicBarrier（循环屏障）"></a>2. CyclicBarrier（循环屏障）</h2><h3 id="📝-定义-1"><a href="#📝-定义-1" class="headerlink" title="📝 定义"></a>📝 定义</h3><ul>
<li>一组线程互相等待，直到所有线程都到达屏障点，再统一出发。</li>
<li>支持 <strong>循环使用</strong>（计数归零后可重置）。</li>
</ul>
<h3 id="⚙️-底层实现-1"><a href="#⚙️-底层实现-1" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul>
<li>基于 <strong>ReentrantLock + Condition</strong>。</li>
<li>每个线程调用 <code>await()</code> → 计数 -1 → 当计数 &#x3D; 0 → 唤醒所有线程。</li>
<li>还可以指定一个 <strong>barrierAction</strong>（所有线程到达后执行的回调）。</li>
</ul>
<h3 id="📌-使用场景-1"><a href="#📌-使用场景-1" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul>
<li>多线程分阶段计算，再统一合并结果。</li>
<li>例如：并行计算矩阵的每一行，所有线程到齐后汇总。</li>
</ul>
<h3 id="🎯-面试考点-1"><a href="#🎯-面试考点-1" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul>
<li>与 <code>CountDownLatch</code> 的区别？→ 可循环，且是「多等多」。</li>
<li><code>BrokenBarrierException</code> 什么时候抛？→ 线程中断或超时导致 barrier 破坏。</li>
</ul>
<hr>
<h2 id="3-Semaphore（信号量）"><a href="#3-Semaphore（信号量）" class="headerlink" title="3. Semaphore（信号量）"></a>3. Semaphore（信号量）</h2><h3 id="📝-定义-2"><a href="#📝-定义-2" class="headerlink" title="📝 定义"></a>📝 定义</h3><ul>
<li>控制同时访问某资源的线程数，像 <strong>限流器&#x2F;许可证</strong>。</li>
</ul>
<h3 id="⚙️-底层实现-2"><a href="#⚙️-底层实现-2" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul>
<li>基于 <strong>AQS</strong> 的共享锁实现。</li>
<li>内部维护一个 <code>permits</code>（许可证数）。</li>
<li><code>acquire()</code> 获取许可证（permits–，不足则阻塞）；</li>
<li><code>release()</code> 归还许可证（permits++）。</li>
</ul>
<h3 id="📌-使用场景-2"><a href="#📌-使用场景-2" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul>
<li>控制并发数：数据库连接池、接口限流。</li>
<li>例子：停车场有 3 个车位 → 最多只能停 3 辆车。</li>
</ul>
<h3 id="🎯-面试考点-2"><a href="#🎯-面试考点-2" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul>
<li>公平模式 vs 非公平模式？<ul>
<li>公平：FIFO 获取许可证。</li>
<li>非公平：可能插队，吞吐量更高。</li>
</ul>
</li>
<li>和 <code>Lock</code> 的区别？→ <code>Semaphore</code> 控制的是 <strong>并发数量</strong>，而 <code>Lock</code> 是 <strong>互斥（只能 1 个线程）</strong>。</li>
</ul>
<hr>
<h2 id="4-Exchanger（交换器）"><a href="#4-Exchanger（交换器）" class="headerlink" title="4. Exchanger（交换器）"></a>4. Exchanger（交换器）</h2><h3 id="📝-定义-3"><a href="#📝-定义-3" class="headerlink" title="📝 定义"></a>📝 定义</h3><ul>
<li>让 <strong>两个线程</strong> 在同步点交换数据。</li>
</ul>
<h3 id="⚙️-底层实现-3"><a href="#⚙️-底层实现-3" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul>
<li>基于 <strong>自旋 + CAS</strong>。</li>
<li>一个线程调用 <code>exchange()</code> 会等待，直到另一个线程也调用 <code>exchange()</code>，然后两者交换数据。</li>
</ul>
<h3 id="📌-使用场景-3"><a href="#📌-使用场景-3" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul>
<li>双线程协作：生产者和消费者之间成对交换数据块。</li>
<li>比如：一个线程生成数据，另一个线程写入磁盘。</li>
</ul>
<h3 id="🎯-面试考点-3"><a href="#🎯-面试考点-3" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul>
<li>如果只有一个线程调用 <code>exchange()</code> 会怎样？→ 会阻塞，直到另一方到来。</li>
<li>与队列（BlockingQueue）的区别？→ <code>Exchanger</code> 是 <strong>一对一交换</strong>，而队列可以一对多。</li>
</ul>
<hr>
<h1 id="🧩-二、原子类（Atomic-系列）"><a href="#🧩-二、原子类（Atomic-系列）" class="headerlink" title="🧩 二、原子类（Atomic 系列）"></a>🧩 二、原子类（Atomic 系列）</h1><p>这些类在 <code>java.util.concurrent.atomic</code> 包下，提供了 <strong>无锁化的线程安全操作</strong>。</p>
<hr>
<h2 id="1-基础原子类"><a href="#1-基础原子类" class="headerlink" title="1. 基础原子类"></a>1. 基础原子类</h2><h3 id="AtomicInteger-AtomicLong-AtomicBoolean"><a href="#AtomicInteger-AtomicLong-AtomicBoolean" class="headerlink" title="AtomicInteger &#x2F; AtomicLong &#x2F; AtomicBoolean"></a>AtomicInteger &#x2F; AtomicLong &#x2F; AtomicBoolean</h3><ul>
<li>作用：对单个 <code>int</code>&#x2F;<code>long</code>&#x2F;<code>boolean</code> 变量的原子操作。</li>
<li>典型方法：<ul>
<li><code>getAndIncrement()</code> → 自增（原子性 i++）。</li>
<li><code>compareAndSet(expect, update)</code> → CAS 更新。</li>
</ul>
</li>
</ul>
<h3 id="⚙️-底层实现-4"><a href="#⚙️-底层实现-4" class="headerlink" title="⚙️ 底层实现"></a>⚙️ 底层实现</h3><ul>
<li>基于 <strong>CAS（Compare-And-Swap） + volatile</strong>。</li>
<li>内部调用 <strong>Unsafe 类</strong> 的 <code>compareAndSwapInt</code> 等方法。</li>
</ul>
<h3 id="📌-使用场景-4"><a href="#📌-使用场景-4" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul>
<li>高并发计数器：网站访问量统计、ID 生成器。</li>
</ul>
<h3 id="🎯-面试考点-4"><a href="#🎯-面试考点-4" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul>
<li>CAS 的缺点？<ol>
<li>ABA 问题（可用 <code>AtomicStampedReference</code> 解决）。</li>
<li>自旋开销大。</li>
<li>只能保证单变量原子性，不能保证复合操作。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-数组原子类"><a href="#2-数组原子类" class="headerlink" title="2. 数组原子类"></a>2. 数组原子类</h2><h3 id="AtomicIntegerArray-AtomicLongArray-AtomicReferenceArray"><a href="#AtomicIntegerArray-AtomicLongArray-AtomicReferenceArray" class="headerlink" title="AtomicIntegerArray &#x2F; AtomicLongArray &#x2F; AtomicReferenceArray"></a>AtomicIntegerArray &#x2F; AtomicLongArray &#x2F; AtomicReferenceArray</h3><ul>
<li>保证数组中的每个元素的原子操作。</li>
<li>例如：统计分片数据时，避免锁整个数组。</li>
</ul>
<hr>
<h2 id="3-引用原子类"><a href="#3-引用原子类" class="headerlink" title="3. 引用原子类"></a>3. 引用原子类</h2><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><ul>
<li>保证对象引用的原子更新。</li>
</ul>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><ul>
<li>解决 <strong>ABA 问题</strong>，给引用加一个版本号（stamp）。</li>
</ul>
<h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><ul>
<li>给引用加一个 <strong>boolean 标记</strong>。</li>
</ul>
<hr>
<h2 id="4-累加器类"><a href="#4-累加器类" class="headerlink" title="4. 累加器类"></a>4. 累加器类</h2><h3 id="LongAdder-DoubleAdder"><a href="#LongAdder-DoubleAdder" class="headerlink" title="LongAdder &#x2F; DoubleAdder"></a>LongAdder &#x2F; DoubleAdder</h3><ul>
<li>对 <code>AtomicLong</code> 的优化：高并发下热点分离。</li>
<li>内部维护一个 <strong>base 值 + 分片 cell 数组</strong>。</li>
<li>多线程写时分散到不同的 cell，最后求和。</li>
</ul>
<h3 id="📌-使用场景-5"><a href="#📌-使用场景-5" class="headerlink" title="📌 使用场景"></a>📌 使用场景</h3><ul>
<li>高并发计数，如 QPS 统计、热点计数。</li>
</ul>
<h3 id="🎯-面试考点-5"><a href="#🎯-面试考点-5" class="headerlink" title="🎯 面试考点"></a>🎯 面试考点</h3><ul>
<li>为什么 <code>LongAdder</code> 比 <code>AtomicLong</code> 性能好？<ul>
<li>AtomicLong 所有线程 CAS 同一个值，形成热点；</li>
<li>LongAdder 分散冲突到多个 cell，降低竞争。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="🧠-三、工具类-原子类对比总结"><a href="#🧠-三、工具类-原子类对比总结" class="headerlink" title="🧠 三、工具类 &amp; 原子类对比总结"></a>🧠 三、工具类 &amp; 原子类对比总结</h1><table>
<thead>
<tr>
<th>工具类 &#x2F; 原子类</th>
<th>功能</th>
<th>实现原理</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td>CountDownLatch</td>
<td>一等多</td>
<td>AQS 共享锁</td>
<td>主线程等子线程完成</td>
</tr>
<tr>
<td>CyclicBarrier</td>
<td>多等多，可循环</td>
<td>ReentrantLock + Condition</td>
<td>分阶段同步，多线程汇总计算</td>
</tr>
<tr>
<td>Semaphore</td>
<td>控制并发数（许可证）</td>
<td>AQS 共享锁</td>
<td>限流、连接池、资源池</td>
</tr>
<tr>
<td>Exchanger</td>
<td>两线程数据交换</td>
<td>CAS + 自旋</td>
<td>双线程协作，数据块交换</td>
</tr>
<tr>
<td>AtomicInteger&#x2F;Long</td>
<td>单变量原子操作</td>
<td>CAS + volatile</td>
<td>高并发计数器，ID 生成</td>
</tr>
<tr>
<td>AtomicReference</td>
<td>原子更新引用</td>
<td>CAS</td>
<td>无锁更新对象引用</td>
</tr>
<tr>
<td>AtomicStampedReference</td>
<td>带版本号引用，防止 ABA</td>
<td>CAS</td>
<td>解决 ABA 问题</td>
</tr>
<tr>
<td>LongAdder&#x2F;DoubleAdder</td>
<td>高并发累加优化</td>
<td>分片 + CAS</td>
<td>高并发计数，性能优于 AtomicLong</td>
</tr>
</tbody></table>
<hr>
<h1 id="🎯-四、面试答题模板（可套用）"><a href="#🎯-四、面试答题模板（可套用）" class="headerlink" title="🎯 四、面试答题模板（可套用）"></a>🎯 四、面试答题模板（可套用）</h1><p>如果面试官问 <strong>“你了解 JUC 的并发工具类吗？”</strong> 可以这样答：</p>
<ol>
<li><strong>总体分类</strong><ul>
<li>JUC 里提供了 <strong>协作类工具（CountDownLatch、CyclicBarrier、Semaphore、Exchanger）</strong> 和 <strong>原子类（AtomicInteger、LongAdder 等）</strong>。</li>
</ul>
</li>
<li><strong>逐个解释</strong><ul>
<li><code>CountDownLatch</code>：一等多，主线程等子线程。</li>
<li><code>CyclicBarrier</code>：多等多，可循环。</li>
<li><code>Semaphore</code>：控制并发数，限流。</li>
<li><code>Exchanger</code>：两线程交换数据。</li>
<li><code>AtomicInteger/Long</code>：单变量原子操作，基于 CAS。</li>
<li><code>LongAdder</code>：高并发下比 AtomicLong 更高效。</li>
</ul>
</li>
<li><strong>原理补充</strong><ul>
<li>工具类大多基于 <strong>AQS</strong> 实现；</li>
<li>原子类基于 <strong>CAS + volatile</strong>；</li>
<li>LongAdder 用 <strong>分段累加</strong> 优化热点。</li>
</ul>
</li>
<li><strong>总结</strong><br> 👉 <strong>工具类解决线程协作，原子类解决无锁更新，都是 JUC 的核心。</strong></li>
</ol>
<hr>
<h4 id="小结-Map"><a href="#小结-Map" class="headerlink" title="小结 Map:"></a>小结 Map:</h4><ul>
<li>HashMap: 最常用，需要快速查找，不关心键值对顺序，且在单线程或由外部同步机制保证线程安全的场景。</li>
<li>LinkedHashMap: 需要快速查找，同时需要保持插入顺序或访问顺序的场景（如实现 LRU 缓存）。</li>
<li>TreeMap: 需要根据键的自然顺序或自定义顺序排序的场景。</li>
<li>ConcurrentHashMap: 高并发场景下对 Map 进行读写操作的首选。</li>
<li>Hashtable: 已被淘汰，不推荐使用。</li>
</ul>
<h4 id="集合部分总结："><a href="#集合部分总结：" class="headerlink" title="集合部分总结："></a>集合部分总结：</h4><p>遍历 Java 集合有多种方式，每种方式都有其优缺点。选择哪种方式取决于你正在使用的集合类型和具体需求。以下是对几种常见遍历方式的优劣分析和推荐。</p>
<hr>
<h3 id="1-迭代器-Iterator"><a href="#1-迭代器-Iterator" class="headerlink" title="1. 迭代器 (Iterator)"></a>1. 迭代器 (Iterator)</h3><p>这是最通用的遍历方式，适用于所有实现了 <code>Iterable</code> 接口的集合。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>通用性强</strong>：它适用于所有集合，包括 <code>List</code>、<code>Set</code> 和 <code>Queue</code>。</li>
<li><strong>安全</strong>：在使用 <code>Iterator</code> 遍历时，可以安全地调用 <code>iterator.remove()</code> 方法移除元素，不会引发 <code>ConcurrentModificationException</code>。</li>
<li><strong>性能优越</strong>：对于 <code>LinkedList</code> 这类链式存储的集合，迭代器的遍历效率最高。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>语法相对繁琐，需要手动调用 <code>hasNext()</code> 和 <code>next()</code>。</li>
</ul>
</li>
<li><strong>推荐</strong>：<ul>
<li>当需要<strong>在遍历过程中删除元素</strong>时，必须使用迭代器。</li>
<li>作为<strong>通用</strong>且安全的遍历首选。</li>
</ul>
</li>
</ul>
<h3 id="2-增强-for-循环-For-Each-Loop"><a href="#2-增强-for-循环-For-Each-Loop" class="headerlink" title="2. 增强 for 循环 (For-Each Loop)"></a>2. 增强 for 循环 (For-Each Loop)</h3><p>增强 for 循环是基于迭代器的一种语法糖，它使遍历代码更简洁易读。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>代码简洁</strong>：语法简单直观，可读性强。</li>
<li><strong>不易出错</strong>：无需手动管理索引或迭代器。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>不支持删除</strong>：在遍历过程中直接调用集合的 <code>remove()</code> 方法会抛出 <code>ConcurrentModificationException</code>。</li>
<li><strong>性能</strong>：对于 <code>LinkedList</code> 来说，它的底层仍然是迭代器，性能很好。但对于 <code>ArrayList</code>，它的性能不如传统的 <code>for</code> 循环，因为每次迭代都需要调用 <code>next()</code> 方法。</li>
</ul>
</li>
<li><strong>推荐</strong>：<ul>
<li>当你只需要<strong>读取集合中的元素</strong>，且代码简洁性比性能更重要时。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-传统-for-循环-Indexed-For-Loop"><a href="#3-传统-for-循环-Indexed-For-Loop" class="headerlink" title="3. 传统 for 循环 (Indexed For Loop)"></a>3. 传统 for 循环 (Indexed For Loop)</h3><p>这种方式只适用于支持通过索引访问的集合，如 <code>ArrayList</code> 和 <code>Vector</code>。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>性能最高</strong>：对于 <code>ArrayList</code>，它通过索引直接访问元素，效率极高，性能优于迭代器。</li>
<li><strong>灵活</strong>：可以按需向前或向后遍历，也可以跳过元素。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>不通用</strong>：不适用于 <code>Set</code> 或 <code>Map</code> 等不按索引存储的集合。</li>
<li><strong>效率低下</strong>：对于 <code>LinkedList</code>，每次 <code>get(i)</code> 调用都会从头开始遍历，导致性能极差，时间复杂度为 O(n²)。</li>
</ul>
</li>
<li><strong>推荐</strong>：<ul>
<li>当遍历 <strong>ArrayList</strong> 并需要<strong>高性能</strong>时。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-Lambda-表达式与-Stream-API"><a href="#4-Lambda-表达式与-Stream-API" class="headerlink" title="4. Lambda 表达式与 Stream API"></a>4. Lambda 表达式与 Stream API</h3><p>Java 8 引入的 Stream API 提供了非常强大的函数式编程能力，可以用于遍历和处理集合。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>简洁优雅</strong>：代码非常简洁，表达力强。</li>
<li><strong>功能强大</strong>：支持过滤、映射、排序等各种操作，能以声明式的方式处理数据。</li>
<li><strong>支持并行</strong>：可以通过 <code>parallelStream()</code> 开启并行处理，利用多核优势。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>性能开销：通常比传统的 <code>for</code> 循环略高，特别是在处理小规模数据时。</li>
</ul>
</li>
<li><strong>推荐</strong>：<ul>
<li>当你需要对集合进行<strong>复杂的操作</strong>（如过滤、转换、聚合）时。</li>
<li>需要利用<strong>并行处理</strong>来提高性能时。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结与最佳实践"><a href="#总结与最佳实践" class="headerlink" title="总结与最佳实践"></a>总结与最佳实践</h3><table>
<thead>
<tr>
<th>方式</th>
<th>适用集合</th>
<th>优劣</th>
<th>推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>迭代器</strong></td>
<td>所有集合</td>
<td>通用、安全（可删除），对 <code>LinkedList</code> 性能好。</td>
<td>需要在遍历中删除元素，或作为通用选择。</td>
</tr>
<tr>
<td><strong>增强 for</strong></td>
<td>所有集合</td>
<td>语法简洁，可读性高。不能在遍历中删除。</td>
<td>仅需读取元素，且追求代码简洁。</td>
</tr>
<tr>
<td><strong>传统 for</strong></td>
<td><code>ArrayList</code> 等</td>
<td><code>ArrayList</code> 性能最高，灵活。对 <code>LinkedList</code> 性能极差。</td>
<td><code>ArrayList</code> 的高性能遍历，或需要控制索引。</td>
</tr>
<tr>
<td><strong>Stream API</strong></td>
<td>所有集合</td>
<td>功能强大，代码优雅，支持并行。</td>
<td>复杂数据处理、并行计算。</td>
</tr>
</tbody></table>
<p><strong>简单概括</strong>：</p>
<ul>
<li><strong>读取</strong> <code>ArrayList</code>：首选<strong>传统 for 循环</strong>。</li>
<li><strong>读取</strong> <code>LinkedList</code>、<code>Set</code>：首选<strong>增强 for 循环</strong>。</li>
<li><strong>删除</strong>元素：必须使用<strong>迭代器</strong>。</li>
<li><strong>复杂操作</strong>：使用 <strong>Stream API</strong>。</li>
</ul>
<p>通常来说，在 Java 中反向遍历并删除元素时，使用传统的 <strong>for 循环</strong>并从列表的末尾开始向前遍历是最安全和高效的方法。</p>
<h3 id="为什么推荐反向遍历？"><a href="#为什么推荐反向遍历？" class="headerlink" title="为什么推荐反向遍历？"></a>为什么推荐反向遍历？</h3><p>当你使用正向遍历（从索引 0 开始）并删除元素时，会遇到一个常见问题：</p>
<ul>
<li>当你删除一个元素后，它后面的所有元素的索引都会向前移动一位。</li>
<li>这会导致在下一次循环迭代时，你可能会跳过紧跟在被删除元素后面的那个元素，因为它现在占据了被删除元素原来的位置，而你的循环索引已经增到了下一个位置。</li>
</ul>
<p><strong>反向遍历</strong>完美地解决了这个问题。当你从列表末尾开始向前遍历时，删除一个元素<strong>不会影响</strong>你尚未遍历到的任何元素的索引，因为你正在处理的元素及其索引都位于列表的“后半部分”。</p>
<hr>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="1-传统的-for-循环（推荐）"><a href="#1-传统的-for-循环（推荐）" class="headerlink" title="1. 传统的 for 循环（推荐）"></a>1. 传统的 <code>for</code> 循环（推荐）</h4><p>这是反向遍历并删除最直接、最安全、最高效的方式，尤其适用于 <code>ArrayList</code>。</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class ReverseRemoveExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;a&quot;);</span><br><span class="line">        list.add(&quot;b&quot;);</span><br><span class="line">        list.add(&quot;c&quot;);</span><br><span class="line">        list.add(&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">        // 从后往前遍历，并删除元素</span><br><span class="line">        for (int i = list.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            // 假设我们要删除所有元素</span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;删除后的列表: &quot; + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-迭代器（Iterator）"><a href="#2-迭代器（Iterator）" class="headerlink" title="2. 迭代器（Iterator）"></a>2. 迭代器（Iterator）</h4><p>虽然迭代器通常用于正向遍历，但你也可以使用它来从后向前遍历并删除。不过，这种方式的实现相对复杂，并且对于 <code>LinkedList</code> 之外的集合性能并不好。对于 <code>ArrayList</code>，它仍然需要从末尾开始遍历，性能不如传统 <code>for</code> 循环。</p>
<p><strong>注意</strong>：<code>ListIterator</code> 提供了双向遍历功能，但其 <code>previous()</code> 方法在 <code>Iterator</code> 接口中并不存在。因此，在通用性上，传统 <code>for</code> 循环依然是首选。</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 这是一个使用 ListIterator 的例子，只适用于 List</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.ListIterator;</span><br><span class="line"></span><br><span class="line">public class ListIteratorExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        list.add(&quot;a&quot;);</span><br><span class="line">        list.add(&quot;b&quot;);</span><br><span class="line">        list.add(&quot;c&quot;);</span><br><span class="line">        list.add(&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">        // 从列表末尾获取 ListIterator</span><br><span class="line">        ListIterator&lt;String&gt; it = list.listIterator(list.size());</span><br><span class="line">        </span><br><span class="line">        while (it.hasPrevious()) &#123;</span><br><span class="line">            String element = it.previous();</span><br><span class="line">            // 假设我们删除元素 &quot;b&quot; 和 &quot;c&quot;</span><br><span class="line">            if (element.equals(&quot;b&quot;) || element.equals(&quot;c&quot;)) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;删除后的列表: &quot; + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>推荐</strong>：对于 <code>ArrayList</code> 或任何基于数组的列表，使用<strong>传统的 for 循环反向遍历</strong>是最简单、最安全、最高效的删除方式。</li>
<li><strong>避免</strong>：避免在正向遍历时直接使用 <code>remove()</code> 方法，因为它可能导致跳过元素或引发 <code>ConcurrentModificationException</code>。</li>
<li><strong>通用性</strong>：如果你需要编写一个通用的删除方法，考虑到所有 <code>List</code> 实现，那么 <code>ListIterator</code> 是一个选择，但它的双向遍历特性仅限于 <code>List</code> 接口。</li>
</ul>
<h2 id="多线程下的hashmap死循环问题："><a href="#多线程下的hashmap死循环问题：" class="headerlink" title="多线程下的hashmap死循环问题："></a>多线程下的hashmap死循环问题：</h2><p>当多个线程同时对一个 <strong>HashMap</strong> 进行操作时，尤其是在涉及扩容（resizing）的情况下，可能会导致死循环。这个问题主要出现在 Java 7 及以前的版本，由于其底层数据结构和扩容机制的设计缺陷。</p>
<hr>
<h3 id="HashMap-的死循环问题"><a href="#HashMap-的死循环问题" class="headerlink" title="HashMap 的死循环问题"></a>HashMap 的死循环问题</h3><p>在 Java 7 中，<code>HashMap</code> 采用<strong>数组 + 链表</strong>的方式存储数据。当链表上的元素数量过多时，为了提高性能，<code>HashMap</code> 会进行扩容。扩容的步骤大致如下：</p>
<ol>
<li>创建一个新的、更大的数组。</li>
<li>遍历旧数组中的所有元素。</li>
<li>将每个元素重新计算哈希值，并放入新数组的正确位置。</li>
</ol>
<p>问题就出在第三步：<strong>将链表上的元素从旧数组转移到新数组时，如果多个线程同时进行此操作，就可能导致链表中的节点顺序颠倒，形成闭环。</strong></p>
<h4 id="扩容时的死循环过程"><a href="#扩容时的死循环过程" class="headerlink" title="扩容时的死循环过程"></a>扩容时的死循环过程</h4><p>假设有两个线程 <strong>Thread1</strong> 和 <strong>Thread2</strong> 同时对一个 <code>HashMap</code> 进行扩容。</p>
<ol>
<li><strong>初始状态</strong>：<code>HashMap</code> 扩容前，一个桶位上有一个链表，比如 <code>NodeA</code> -&gt; <code>NodeB</code>。</li>
<li><strong>Thread1 执行到一半</strong>：<code>Thread1</code> 遍历到 <code>NodeA</code>，准备将其移动到新数组。此时 <code>Thread1</code> 被挂起。<code>NodeA</code> 的 <code>next</code> 引用仍然指向 <code>NodeB</code>。</li>
<li><strong>Thread2 开始执行</strong>：<code>Thread2</code> 完整地完成了扩容过程。它将链表 <code>NodeA</code> -&gt; <code>NodeB</code> 转移到了新数组。但由于是单线程操作，转移后链表顺序保持不变，仍是 <code>NodeA</code> -&gt; <code>NodeB</code>。</li>
<li><strong>Thread1 恢复执行</strong>：<code>Thread1</code> 恢复执行，但它不知道 <code>Thread2</code> 已经完成了扩容。它仍然使用旧的 <code>next</code> 引用信息。<ul>
<li><code>Thread1</code> 取出 <code>NodeA</code>，将其放入新数组。</li>
<li><code>Thread1</code> 接着处理 <code>NodeB</code>（因为在 <code>Thread1</code> 的视角，<code>NodeA</code> 的 <code>next</code> 还是 <code>NodeB</code>）。它将 <code>NodeB</code> 放入新数组。此时，<strong>由于哈希冲突，NodeB 被放在了 NodeA 的前面，导致链表变成了 NodeB -&gt; NodeA。</strong></li>
<li><code>NodeA</code> 的 <code>next</code> 引用（在 <code>Thread1</code> 的视角）仍然指向 <code>NodeB</code>。现在，<code>NodeB</code> 的 <code>next</code> 指向 <code>NodeA</code>，而 <code>NodeA</code> 的 <code>next</code> 指向 <code>NodeB</code>，<strong>形成了一个闭环</strong>。</li>
</ul>
</li>
</ol>
<p>当后续线程在这个闭环链表上进行查找时，就会陷入无限循环，导致 CPU 100% 占用。</p>
<hr>
<h3 id="如何解决这个问题？"><a href="#如何解决这个问题？" class="headerlink" title="如何解决这个问题？"></a>如何解决这个问题？</h3><p>Java 提供了多种线程安全的替代方案来解决 <code>HashMap</code> 的多线程问题：</p>
<ol>
<li><strong>Collections.synchronizedMap()</strong>：<ul>
<li>这个方法可以创建一个线程安全的 <code>Map</code> 包装器。</li>
<li>它通过在每个方法调用上加锁来实现线程安全。</li>
<li><strong>优点</strong>：简单易用。</li>
<li><strong>缺点</strong>：每次访问都需要加锁，并发性能较差。</li>
</ul>
</li>
<li><strong>Hashtable</strong>：<ul>
<li>一个早期的线程安全 <code>Map</code> 实现，所有公共方法都用 <code>synchronized</code> 修饰。</li>
<li><strong>优点</strong>：线程安全。</li>
<li><strong>缺点</strong>：性能差，几乎所有操作都锁住整个表，已被 <code>ConcurrentHashMap</code> 取代。</li>
</ul>
</li>
<li><strong>ConcurrentHashMap</strong>：<ul>
<li>这是 <strong>Java 推荐的线程安全 Map 实现</strong>。</li>
<li>在 Java 7 中，它使用了<strong>分段锁（Segment Lock）</strong>，将数据分成多个段，每个段独立加锁。</li>
<li>在 Java 8 中，它进一步优化，采用**CAS（Compare-And-Swap）**和 <strong>synchronized</strong> 关键字，锁的粒度更细，只锁住当前操作的桶，从而大大提高了并发性能。</li>
</ul>
</li>
</ol>
<p>因此，在多线程环境下，<strong>永远不要使用 HashMap</strong>。你应该根据需求，选择 <code>ConcurrentHashMap</code> 或 <code>Collections.synchronizedMap()</code> 来保证线程安全。</p>
<h2 id="集合扩展："><a href="#集合扩展：" class="headerlink" title="集合扩展："></a>集合扩展：</h2><h3 id="12-HashMap-的-get-方法能否判断某个元素是否在-map-中？"><a href="#12-HashMap-的-get-方法能否判断某个元素是否在-map-中？" class="headerlink" title="12. HashMap 的 get 方法能否判断某个元素是否在 map 中？"></a>12. HashMap 的 get 方法能否判断某个元素是否在 map 中？</h3><p><code>HashMap</code> 的 <code>get</code> 函数的返回值不能判断一个 <code>key</code> 是否包含在 <code>map</code> 中，因为 <code>get</code> 返回 <code>null</code> 有可能是不包含该 <code>key</code>，也有可能该 <code>key</code> 对应的 <code>value</code> 为 <code>null</code>。因为 <code>HashMap</code> 中允许 <code>key</code> 为 <code>null</code>，也允许 <code>value</code> 为 <code>null</code>。</p>
<hr>
<h3 id="13-HashMap-与-HashTable-的区别是什么？"><a href="#13-HashMap-与-HashTable-的区别是什么？" class="headerlink" title="13. HashMap 与 HashTable 的区别是什么？"></a>13. HashMap 与 HashTable 的区别是什么？</h3><ol>
<li><code>HashTable</code> 基于 <code>Dictionary</code> 类，而 <code>HashMap</code> 是基于 <code>AbstractMap</code>。<code>Dictionary</code> 是任何可将键映射到相应值的类的抽象父类，而 <code>AbstractMap</code> 是基于 <code>Map</code> 接口的实现，它以最大限度地减少实现此接口所需的工作。</li>
<li><code>HashMap</code> 的 <code>key</code> 和 <code>value</code> 都允许为 <code>null</code>，而 <code>Hashtable</code> 的 <code>key</code> 和 <code>value</code> 都不允许为 <code>null</code>。<code>HashMap</code> 遇到 <code>key</code> 为 <code>null</code> 的时候，调用 <code>putForNullKey</code> 方法进行处理，而对 <code>value</code> 没有处理；<code>Hashtable</code> 遇到 <code>null</code>，直接返回 <code>NullPointerException</code>。</li>
<li><code>Hashtable</code> 是线程安全的，而 <code>HashMap</code> 不是线程安全的，但是我们也可以通过 <code>Collections.synchronizedMap(hashMap)</code>，使其实现同步。</li>
</ol>
<p>HashTable 的补充：</p>
<p>HashTable 和 HashMap 的实现原理几乎一样，差别无非是：</p>
<ol>
<li><code>HashTable</code> 不允许 <code>key</code> 和 <code>value</code> 为 <code>null</code>；</li>
<li><code>HashTable</code> 是线程安全的。但是 <code>HashTable</code> 线程安全的策略实现代价却太大了，简单粗暴，<code>get/put</code> 所有相关操作都是 <code>synchronized</code> 的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。</li>
</ol>
<hr>
<h3 id="14-HashMap-与-ConcurrentHashMap-的区别是什么"><a href="#14-HashMap-与-ConcurrentHashMap-的区别是什么" class="headerlink" title="14. HashMap 与 ConcurrentHashMap 的区别是什么?"></a>14. HashMap 与 ConcurrentHashMap 的区别是什么?</h3><p><code>HashMap</code> 不是线程安全的，而 <code>ConcurrentHashMap</code> 是线程安全的。</p>
<p><code>ConcurrentHashMap</code> 采用锁分段技术，将整个Hash桶进行了分段segment，也就是将这个大的数组分成了几个小的片段 <code>segment</code>，而且每个小的片段 <code>segment</code> 上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段 <code>segment</code>，然后再在这个片段上面进行插入，而且这里还需要获取 <code>segment</code> 锁，这样做明显减小了锁的粒度。</p>
<hr>
<h3 id="15-HashTable-和-ConcurrentHashMap-的区别？"><a href="#15-HashTable-和-ConcurrentHashMap-的区别？" class="headerlink" title="15. HashTable 和 ConcurrentHashMap 的区别？"></a>15. HashTable 和 ConcurrentHashMap 的区别？</h3><p><code>HashTable</code> 和 <code>ConcurrentHashMap</code> 相比，效率低。 <code>Hashtable</code> 之所以效率低主要是使用了 <code>synchronized</code> 关键字对 <code>put</code> 等操作进行加锁，而 <code>synchronized</code> 关键字加锁是对整张 Hash 表的，即每次锁住整张表让线程独占，致使效率低下，而 <code>ConcurrentHashMap</code> 在对象中保存了一个 <code>Segment</code> 数组，即将整个 Hash 表划分为多个分段；而每个<code>Segment</code>元素，即每个分段则类似于一个<code>Hashtable</code>；这样，在执行 <code>put</code> 操作时首先根据 hash 算法定位到元素属于哪个 <code>Segment</code>，然后对该 <code>Segment</code> 加锁即可，因此，<code>ConcurrentHashMap</code> 在多线程并发编程中可是实现多线程 <code>put</code>操作。</p>
<hr>
<h3 id="16-ConcurrentHashMap-的实现原理是什么？"><a href="#16-ConcurrentHashMap-的实现原理是什么？" class="headerlink" title="16. ConcurrentHashMap 的实现原理是什么？"></a>16. ConcurrentHashMap 的实现原理是什么？</h3><p><strong>数据结构</strong></p>
<ul>
<li><strong>JDK 7</strong>：中 <code>ConcurrentHashMap</code> 采用了<strong>数组 + Segment + 分段锁</strong>的方式实现。</li>
<li><strong>JDK 8</strong>：中 <code>ConcurrentHashMap</code> 参考了 JDK 8 <code>HashMap</code> 的实现，采用了<strong>数组 + 链表 + 红黑树</strong>的实现方式来设计，内部大量采用 <code>CAS</code> 操作。</li>
</ul>
<p>ConcurrentHashMap 采用了非常精妙的”分段锁”策略，ConcurrentHashMap 的主干是个 Segment 数组。</p>
<p>final Segment[] segments;</p>
<p>Segment 继承了 ReentrantLock，所以它就是一种可重入锁（ReentrantLock）。在 ConcurrentHashMap，一个 Segment 就是一个子哈希表，Segment 里维护了一个 HashEntry 数组，并发环境下，对于不同 Segment 的数据进行操作是不用考虑锁竞争的。就按默认的 ConcurrentLevel 为 16 来讲，理论上就允许 16 个线程并发执行。所以，对于同一个 Segment 的操作才需考虑线程同步，不同的 Segment 则无需考虑。Segment 类似于 HashMap，一个 Segment 维护着一个HashEntry 数组：</p>
<p>transient volatile HashEntry[] table;</p>
<p>HashEntry 是目前我们提到的最小的逻辑处理单元了。一个 ConcurrentHashMap 维护一个 Segment 数组，一个 Segment 维护一个 HashEntry 数组。因此，ConcurrentHashMap 定位一个元素的过程需要进行两次 Hash 操作。第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。</p>
<hr>
<h3 id="17-HashSet-的实现原理？"><a href="#17-HashSet-的实现原理？" class="headerlink" title="17. HashSet 的实现原理？"></a>17. HashSet 的实现原理？</h3><p><code>HashSet</code> 的实现是依赖于 <code>HashMap</code> 的，<code>HashSet</code> 的值都是存储在 <code>HashMap</code> 中的。在 <code>HashSet</code> 的构造法中会初始化一个 <code>HashMap</code> 对象，<code>HashSet</code> 不允许值重复。因此，<code>HashSet</code> 的值是作为 <code>HashMap</code> 的 <code>key</code> 存储在 <code>HashMap</code> 中的，当存储的值已经存在时返回 <code>false</code>。</p>
<hr>
<h3 id="18-HashSet-怎么保证元素不重复的？"><a href="#18-HashSet-怎么保证元素不重复的？" class="headerlink" title="18. HashSet 怎么保证元素不重复的？"></a>18. HashSet 怎么保证元素不重复的？</h3><p><code>public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125;</code></p>
<p>元素值作为的是 <code>map</code> 的 <code>key</code>，<code>map</code> 的 <code>value</code> 则是 <code>PRESENT</code> 变量，这个变量只作为放入 <code>map</code> 时的<code>一个占位符而存在，所以没什么实际用处。其实，这时候答案已经出来了：</code>HashMap<code>的</code>key<code>是不能重复的，而这里</code>HashSet<code>的元素又是作为了</code>map<code>的</code>key&#96;，当然也不能重复了。</p>
<hr>
<h3 id="19-LinkedHashMap-的实现原理"><a href="#19-LinkedHashMap-的实现原理" class="headerlink" title="19. LinkedHashMap 的实现原理?"></a>19. LinkedHashMap 的实现原理?</h3><p><code>LinkedHashMap</code> 也是基于 <code>HashMap</code> 实现的，不同的是它定义了一个 <code>Entry</code> <code>header</code>，这个 <code>header</code> 不是放在 <code>Table</code> 里，它是额外独立出来的。<code>LinkedHashMap</code> 通过继承 <code>hashMap</code> 中的 <code>Entry</code>，并添加两个属性 <code>Entry before, after</code> 和 <code>header</code> 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。</p>
<p><code>LinkedHashMap</code> 定义了排序模式 <code>accessOrder</code>，该属性为 <code>boolean</code> 型变量，对于访问顺序，为 <code>true</code>；对于插入顺序，则为 <code>false</code>。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p>
<hr>
<h3 id="20-Iterator-怎么使用？有什么特点？"><a href="#20-Iterator-怎么使用？有什么特点？" class="headerlink" title="20. Iterator 怎么使用？有什么特点？"></a>20. Iterator 怎么使用？有什么特点？</h3><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。Java 中的 <code>Iterator</code> 功能比较简单，并且只能单向移动：</p>
<ol>
<li>使用方法 <code>iterator()</code> 要求容器返回一个 <code>Iterator</code>。第一次调用 <code>Iterator</code> 的 <code>next()</code> 方法时，它返回序列的第一个元素。注意：<code>iterator()</code> 方法是 <code>java.lang.Iterable</code> 接口，被 <code>Collection</code> 继承。</li>
<li>使用 <code>next()</code> 获得序列中的下一个元素。</li>
<li>使用 <code>hasNext()</code> 检查序列中是否还有元素。</li>
<li>使用 <code>remove()</code> 将迭代器新返回的元素删除。</li>
</ol>
<hr>
<h3 id="21-Iterator-和-ListIterator-有什么区别？"><a href="#21-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="21. Iterator 和 ListIterator 有什么区别？"></a>21. Iterator 和 ListIterator 有什么区别？</h3><p><code>Iterator</code> 可用来遍历 <code>Set</code> 和 <code>List</code> 集合，但是 <code>ListIterator</code> 只能用来遍历 <code>List</code>。<code>Iterator</code> 对集合只能是前向遍历，<code>ListIterator</code> 既可以前向也可以后向。<code>ListIterator</code> 实现了 <code>Iterator</code> 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</p>
<hr>
<h3 id="22-Iterator-和-Enumeration-接口的区别？"><a href="#22-Iterator-和-Enumeration-接口的区别？" class="headerlink" title="22. Iterator 和 Enumeration 接口的区别？"></a>22. Iterator 和 Enumeration 接口的区别？</h3><p>与 <code>Enumeration</code> 相比，<code>Iterator</code> 更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。否则会抛出 <code>ConcurrentModificationException</code> 异常。这其实就是 <code>fail-fast</code> 机制。具体区别有三点：</p>
<ol>
<li><code>Iterator</code> 的方法名比 <code>Enumeration</code> 更科学；</li>
<li><code>Iterator</code> 有 <code>fail-fast</code> 机制，比 <code>Enumeration</code> 更安全；</li>
<li><code>Iterator</code> 能够删除元素，<code>Enumeration</code> 并不能删除元素。</li>
</ol>
<hr>
<h3 id="23-fail-fast-与-fail-safe-有什么区别？"><a href="#23-fail-fast-与-fail-safe-有什么区别？" class="headerlink" title="23. fail-fast 与 fail-safe 有什么区别？"></a>23. fail-fast 与 fail-safe 有什么区别？</h3><p><code>Iterator</code> 的 <code>fail-fast</code> 属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。<code>java.util</code> 包中的所有集合类都被设计为 <code>fail-fast</code> 的，而 <code>java.util.concurrent</code> 中的集合类都为 <code>fail-safe</code> 的。当检测到正在遍历的集合的结构被改变时，<code>fail-fast</code> 迭代器抛出 <code>ConcurrentModificationException</code>，而 <code>fail-safe</code> 迭代器从不抛出 <code>ConcurrentModificationException</code>。</p>
<hr>
<h3 id="24-Collection-和-Collections-有什么区别？"><a href="#24-Collection-和-Collections-有什么区别？" class="headerlink" title="24. Collection 和 Collections 有什么区别？"></a>24. Collection 和 Collections 有什么区别？</h3><ul>
<li><code>Collection</code>：是最基本的集合接口，一个 <code>Collection</code> 代表一组 <code>Object</code>，即 <code>Collection</code> 的元素。它的直接继承接口有 <code>List</code>，<code>Set</code> 和 <code>Queue</code>。</li>
<li><code>Collections</code>：不属于 Java 的集合框架的，它是集合类的一个工具类&#x2F;帮助类。此类不能被实例化， 服务于 Java 的 <code>Collection</code> 框架。它包含有关集合操作的静态多态方法，实现对各种集合的搜索、排序、线程安全等操作。</li>
</ul>
<h2 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO 流"></a>Java IO 流</h2><p>Java IO (Input&#x2F;Output) 流是用于处理计算机与外部设备之间数据传输的抽象概念。它将数据抽象为流 (Stream)，通过流可以实现数据的输入和输出。</p>
<h3 id="IO-流的分类"><a href="#IO-流的分类" class="headerlink" title="IO 流的分类"></a>IO 流的分类</h3><p>Java IO 流根据不同的标准有多种分类方式：</p>
<ul>
<li>按数据类型分：<ul>
<li>字节流：处理字节数据，所有文件类型（文本、图片、音视频等）都可以用字节流处理。<ul>
<li>抽象基类：InputStream（输入流）、OutputStream（输出流）。</li>
<li>常用实现：FileInputStream&#x2F;FileOutputStream（文件操作），BufferedInputStream&#x2F;BufferedOutputStream（带缓冲），ObjectInputStream&#x2F;ObjectOutputStream（对象序列化），ByteArrayInputStream&#x2F;ByteArrayOutputStream（内存操作），DataInputStream&#x2F;DataOutputStream（基本数据类型操作）。</li>
</ul>
</li>
<li>字符流：处理字符数据，专门用于处理文本文件。<ul>
<li>抽象基类：Reader（输入流）、Writer（输出流）。</li>
<li>常用实现：FileReader&#x2F;FileWriter（文件操作），BufferedReader&#x2F;BufferedWriter（带缓冲），InputStreamReader&#x2F;OutputStreamWriter（字节流与字符流的转换）。</li>
</ul>
</li>
</ul>
</li>
<li>按流向分：<ul>
<li>输入流：从数据源读取数据到程序中。</li>
<li>输出流：从程序中写入数据到目的地。</li>
</ul>
</li>
<li>按功能分：<ul>
<li>节点流（或源头流）：直接与数据源（如文件、内存、网络连接）连接的流。例如FileInputStream、FileReader。</li>
<li>处理流（或包装流）：对已存在的节点流进行包装，增加新的功能或提升性能。例如BufferedInputStream、BufferedReader。</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\19501\AppData\Local\Temp\1755834271160.png" alt="1755834271160"></p>
<p><img src="C:\Users\19501\AppData\Local\Temp\1755834290356.png" alt="1755834290356"></p>
<h3 id="常用-IO-操作"><a href="#常用-IO-操作" class="headerlink" title="常用 IO 操作"></a>常用 IO 操作</h3><ul>
<li><p>文件读写（字节流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    fos.write(<span class="string">&quot;Hello, World!&quot;</span>.getBytes());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">while</span> ((data = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件读写（字符流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output_char.txt&quot;</span>)) &#123;</span><br><span class="line">    fw.write(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;output_char.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">while</span> ((data = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓冲流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用缓冲字节流复制文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.txt&quot;</span>));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;destination.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个可序列化的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 序列化版本UID</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">transient</span> String password; <span class="comment">// transient 关键字修饰的字段不参与序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User(name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, password=&quot;</span> + password + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    oos.writeObject(user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;user.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">deserializedUser</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">    System.out.println(deserializedUser); <span class="comment">// password 字段将为 null</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="NIO-New-Input-Output"><a href="#NIO-New-Input-Output" class="headerlink" title="NIO (New Input&#x2F;Output)"></a>NIO (New Input&#x2F;Output)</h3><p>Java NIO (New I&#x2F;O) 是在 JDK 1.4 中引入的一套新的 I&#x2F;O API，它提供了非阻塞 I&#x2F;O 的能力，并引入了“通道 (Channel)”和“缓冲区 (Buffer)”的概念，与传统的基于流 (Stream) 的 I&#x2F;O 相比，NIO 更加高效。</p>
<p><strong>核心组件：</strong></p>
<ul>
<li>Channel (通道): 类似于传统 IO 中的流，但可以双向读写。数据总是通过通道读入缓冲区或从缓冲区写入通道。<ul>
<li>常用实现: FileChannel (文件), SocketChannel (TCP 客户端), ServerSocketChannel (TCP 服务器), DatagramChannel (UDP)。</li>
</ul>
</li>
<li>Buffer (缓冲区): 用于存储数据 (字节数组)，与通道进行交互。所有数据读写都是通过缓冲区完成的。缓冲区有多种类型，如 ByteBuffer、CharBuffer、IntBuffer 等。<ul>
<li>核心属性：<ul>
<li>capacity: 缓冲区可容纳的最大数据量。一旦创建，容量不可变。</li>
<li>limit: 缓冲区中可读或可写的上限。</li>
<li>position: 下一个读或写的位置。</li>
<li>mark: 标记当前 position，可以通过 reset() 恢复到 mark 的位置。</li>
</ul>
</li>
<li>主要方法：<ul>
<li>put(): 向缓冲区写入数据。</li>
<li>get(): 从缓冲区读取数据。</li>
<li>flip(): 将缓冲区从写模式切换到读模式。limit 会设置为当前的 position, position 会重置为 0。</li>
<li>clear(): 清空缓冲区，为新的写入做准备。position 设为 0, limit 设为 capacity。</li>
<li>compact(): 压缩缓冲区，将未读的数据移到缓冲区开头，position 设为未读数据数量，limit 设为 capacity。</li>
<li>rewind(): 将 position 设为 0，可以重复读取缓冲区中的数据。</li>
</ul>
</li>
</ul>
</li>
<li>Selector (选择器): 用于监听多个通道上的事件 (如连接就绪、读就绪、写就绪等)。一个单线程可以管理多个通道，从而实现非阻塞 I&#x2F;O。</li>
</ul>
<p><strong>NIO 与传统 IO 的区别：</strong></p>
<ul>
<li>I&#x2F;O 模式:传统 IO 是阻塞式 I&#x2F;O, NIO 是非阻塞式 I&#x2F;O。</li>
<li>流与缓冲区:传统 IO 基于流(单向), NIO 基于通道和缓冲区(双向)。</li>
<li>同步与异步:传统 IO 是同步阻塞的, NIO 是同步非阻塞的(在多路复用模型下)。</li>
</ul>
<p><strong>NIO 文件复制示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">     <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;destination_nio.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> fos.getChannel()) &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (inChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buffer.flip(); <span class="comment">// 切换到读模式</span></span><br><span class="line">        outChannel.write(buffer); <span class="comment">// 从缓冲区写入通道</span></span><br><span class="line">        buffer.clear(); <span class="comment">// 清空缓冲区, 为下次写入做准备</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AIO-Asynchronous-Input-Output"><a href="#AIO-Asynchronous-Input-Output" class="headerlink" title="AIO (Asynchronous Input&#x2F;Output)"></a>AIO (Asynchronous Input&#x2F;Output)</h3><p>Java AIO (Asynchronous I&#x2F;O) 是在 JDK 7 中引入的，也称为 NIO 2.0。它提供了真正的异步非阻塞 I&#x2F;O，通过回调机制来处理 I&#x2F;O 操作的结果。与 NIO 的同步非阻塞不同，AIO 在 I&#x2F;O 操作完成后会主动通知应用程序。</p>
<ul>
<li><p><strong>核心概念:</strong></p>
<ul>
<li>AsynchronousFileChannel:异步文件通道。</li>
<li>AsynchronousSocketChannel:异步 Socket 通道。</li>
<li>AsynchronousServerSocketChannel:异步 Server Socket 通道。</li>
<li>CompletionHandler:回调处理器接口，定义了 completed() (操作成功) 和 failed() (操作失败) 方法。</li>
<li>Future:也可以通过返回 Future 对象来获取异步操作的结果。</li>
</ul>
</li>
<li><p>**工作原理:**当发起一个 I&#x2F;O 操作时，不再需要等待操作完成，而是立即返回。I&#x2F;O 操作由操作系统在后台完成，完成后通过回调函数通知应用程序。</p>
</li>
<li><p><strong>AIO 优势:</strong></p>
<ul>
<li>真正的异步非阻塞:应用程序不需要等待 I&#x2F;O 操作，可以将 CPU 资源用于其他任务。</li>
<li>提高并发性:特别适合高并发、长连接的网络应用。</li>
</ul>
</li>
<li><p><strong>AIO 劣势:</strong></p>
<ul>
<li>复杂性:编程模型相对于 NIO 更复杂，需要处理回调逻辑。</li>
<li>适用场景:对于连接数较多且连接时间长的应用，如聊天服务器，AIO 表现优异。对于短连接、高并发的场景，NIO（基于 Selector）可能表现更好。</li>
</ul>
</li>
<li><p><strong>AIO 读文件示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">file</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;async_read.txt&quot;</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(file, StandardOpenOption.READ)) &#123;</span><br><span class="line">    fileChannel.read(buffer, <span class="number">0</span>, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Read &quot;</span> + result + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">            attachment.flip();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[attachment.remaining()];</span><br><span class="line">            attachment.get(data);</span><br><span class="line">            System.out.println(<span class="string">&quot;Content: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Read failed: &quot;</span> + exc.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 为了让主线程不立即退出，等待异步操作完成</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-Java-IO-流的分类？请说出几个你熟悉的实现类。"><a href="#1-Java-IO-流的分类？请说出几个你熟悉的实现类。" class="headerlink" title="1. Java IO 流的分类？请说出几个你熟悉的实现类。"></a>1. Java IO 流的分类？请说出几个你熟悉的实现类。</h3><p>Java IO 流根据不同的标准可以进行分类：</p>
<ul>
<li><strong>按数据流向</strong>：<ul>
<li><strong>输入流（InputStream &#x2F; Reader）</strong>：从外部源（如文件、网络）读取数据到程序中。</li>
<li><strong>输出流（OutputStream &#x2F; Writer）</strong>：将数据从程序写入到外部目标。</li>
</ul>
</li>
<li><strong>按数据类型</strong>：<ul>
<li><strong>字节流（InputStream &#x2F; OutputStream）</strong>：以 8 位字节为单位处理数据，适用于所有类型的文件，包括图片、视频、音频等二进制文件。<ul>
<li><strong>实现类</strong>：<code>FileInputStream</code>, <code>FileOutputStream</code>, <code>BufferedInputStream</code>, <code>BufferedOutputStream</code>。</li>
</ul>
</li>
<li><strong>字符流（Reader &#x2F; Writer）</strong>：以 16 位字符为单位处理数据，适用于文本文件，能处理各种字符编码。<ul>
<li><strong>实现类</strong>：<code>FileReader</code>, <code>FileWriter</code>, <code>BufferedReader</code>, <code>BufferedWriter</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-字节流和字符流有什么区别？"><a href="#2-字节流和字符流有什么区别？" class="headerlink" title="2. 字节流和字符流有什么区别？"></a>2. 字节流和字符流有什么区别？</h3><p>字节流和字符流的主要区别在于处理数据的单位和适用场景：</p>
<ul>
<li><strong>数据单位</strong>：字节流以 8 位字节为单位进行读写，而字符流以 16 位字符为单位。</li>
<li><strong>编码转换</strong>：字符流是字节流的封装，它在内部处理了字节和字符之间的编码转换。当处理文本文件时，字符流可以根据指定的字符集（如 UTF-8）自动进行编码和解码，避免了乱码问题。字节流不进行编码转换，直接处理原始字节。</li>
<li><strong>最小存储单元</strong>：尽管字符流以字符为单位，但文件或网络传输的最小存储单元依然是字节。字符流在底层仍依赖于字节流来完成数据的传输。</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>字节流</strong>：适用于所有文件类型，尤其是处理<strong>非文本文件</strong>（如图片、视频、音频等），因为这些文件不需要进行字符编码转换。</li>
<li><strong>字符流</strong>：专门用于处理<strong>文本文件</strong>，可以避免手动处理字符编码的复杂性。</li>
</ul>
</li>
</ul>
<h3 id="3-BIO、NIO-和-AIO-有什么区别？"><a href="#3-BIO、NIO-和-AIO-有什么区别？" class="headerlink" title="3. BIO、NIO 和 AIO 有什么区别？"></a>3. BIO、NIO 和 AIO 有什么区别？</h3><p>这是 Java IO 发展历程中的三种不同模型，主要区别在于处理 IO 操作的方式（阻塞&#x2F;非阻塞、同步&#x2F;异步）和并发能力。</p>
<ul>
<li><strong>BIO (Blocking I&#x2F;O)</strong><ul>
<li><strong>特点</strong>：<strong>同步阻塞</strong>。当一个线程发起 IO 操作（如 <code>read</code> 或 <code>accept</code>），它会一直阻塞，直到数据读写完成或连接建立。</li>
<li><strong>模型</strong>：采用“一对一”的连接模型，即一个客户端连接对应一个处理线程。</li>
<li><strong>优点</strong>：编程模型简单直观，适用于连接数较少、并发量不高的场景。</li>
<li><strong>缺点</strong>：在高并发场景下，每个连接都需要一个线程，会消耗大量系统资源，导致性能瓶颈。</li>
</ul>
</li>
<li><strong>NIO (Non-blocking I&#x2F;O)</strong><ul>
<li><strong>特点</strong>：<strong>同步非阻塞</strong>。一个线程可以同时处理多个连接。当线程发起 IO 操作时，如果数据没有准备好，它不会阻塞，而是立即返回，去做其他事情，稍后再次检查。</li>
<li><strong>模型</strong>：采用<strong>多路复用</strong>模型。通过一个 <code>Selector</code>（选择器），一个或少数几个线程可以监听多个 <code>Channel</code>（通道）上的 IO 事件（如连接就绪、数据可读），从而高效地处理大量并发连接。</li>
<li><strong>优点</strong>：解决了 BIO 的高并发问题，大大提高了系统的吞吐量，适用于高并发的网络应用。</li>
<li><strong>缺点</strong>：编程模型相对复杂。尽管 IO 操作是非阻塞的，但数据读写本身仍然是同步的，即线程在进行读写时仍需等待。</li>
</ul>
</li>
<li><strong>AIO (Asynchronous I&#x2F;O)</strong><ul>
<li><strong>特点</strong>：<strong>异步非阻塞</strong>。应用程序发起 IO 操作后，会立即返回，而不会等待数据读写。操作系统会在后台完成 IO 操作，并在完成后通过<strong>回调</strong>或事件通知应用程序。</li>
<li><strong>模型</strong>：基于<strong>事件和回调</strong>机制。</li>
<li><strong>优点</strong>：进一步提高了并发性能，彻底释放了线程资源，适用于连接数巨大且连接时间长的应用。</li>
<li><strong>缺点</strong>：目前在实际应用中，特别是在网络编程方面，使用不如 NIO 广泛，因为其复杂性和对操作系统的依赖性较高。</li>
</ul>
</li>
</ul>
<h2 id="Java-反射-Reflection"><a href="#Java-反射-Reflection" class="headerlink" title="Java 反射 (Reflection)"></a>Java 反射 (Reflection)</h2><p>Java 反射机制是指在程序运行时，能够动态地获取类的信息（包括类的属性、方法、构造器等），并能够动态地操作类或对象（如创建对象、调用方法、修改属性）。</p>
<ul>
<li><p><strong>核心类与接口：</strong></p>
<ul>
<li>Class 类：代表类的字节码文件，是反射的入口。</li>
<li>Constructor 类：代表类的构造器。</li>
<li>Method 类：代表类的方法。</li>
<li>Field 类：代表类的成员变量（属性）。</li>
<li>AccessibleObject：Field, Method, Constructor 的共同父类，提供了 setAccessible(true) 方法，用于抑制 Java 语言访问检查，从而访问私有成员。</li>
</ul>
</li>
<li><p><strong>获取 Class 对象的三种方式：</strong></p>
<ol>
<li><p>Class.forName(“全限定类名”)：最常用，动态加载类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>类名.class：已知具体类名时使用，编译时加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = String.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象.getClass()：通过对象实例获取，运行时获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Class&lt;?&gt; clazz = s.getClass();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>反射的应用：</strong></p>
<ul>
<li><p>动态创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance(); <span class="comment">// 调用无参构造器</span></span><br><span class="line"><span class="comment">// 或者调用指定构造器</span></span><br><span class="line">Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person2</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">setNameMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">setNameMethod.invoke(person, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// 调用 setName 方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getNameMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) getNameMethod.invoke(person); <span class="comment">// 调用 getName 方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>动态操作属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance();</span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">// 获取私有属性</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>); <span class="comment">// 允许访问私有属性</span></span><br><span class="line">nameField.set(person, <span class="string">&quot;Charlie&quot;</span>); <span class="comment">// 设置属性值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) nameField.get(person); <span class="comment">// 获取属性值</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>反射的优缺点：</strong></p>
<ul>
<li>优点：<ul>
<li>灵活性和动态性:在运行时动态获取类信息和操作对象,大大增强了程序的灵活性,是许多框架(如Spring、ORM框架)和工具(如JSON解析库)的基础。</li>
<li>解耦:允许代码在编译时不知道具体的类,只在运行时加载和使用,实现高度解耦。</li>
</ul>
</li>
<li>缺点:<ul>
<li>性能开销:反射操作比直接调用有更高的性能开销,因为涉及到动态解析和查找。</li>
<li>安全性问题:setAccessible(true)可以绕过Java的访问控制,可能破坏封装性。</li>
<li>可维护性差:反射代码通常比直接调用更复杂,更难调试和维护。</li>
<li>编译时检查缺失:反射操作在编译时无法检查类型错误,只能在运行时发现。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="JVM内存结构与垃圾收集器"><a href="#JVM内存结构与垃圾收集器" class="headerlink" title="JVM内存结构与垃圾收集器"></a>JVM内存结构与垃圾收集器</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><h3 id="JVM-简单介绍"><a href="#JVM-简单介绍" class="headerlink" title="JVM 简单介绍"></a>JVM 简单介绍</h3><p>Java 虚拟机（JVM）是 Java 语言跨平台能力的核心。它是一个抽象的计算机，负责将 Java 字节码 (<code>.class</code> 文件) 转换成特定平台的机器指令。下面通过表格的形式，简单介绍 JVM 的主要组成部分、功能和工作流程。</p>
<hr>
<table>
<thead>
<tr>
<th>模块名称</th>
<th>核心功能</th>
<th>主要组成部分</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>类加载子系统</strong></td>
<td>加载、链接、初始化 <code>.class</code> 文件</td>
<td>类加载器 (ClassLoader)</td>
<td>负责从文件系统、网络等来源加载 <code>.class</code> 文件到内存，并进行验证、准备和解析。</td>
</tr>
<tr>
<td><strong>运行时数据区</strong></td>
<td>存放程序运行时的各种数据</td>
<td><strong>方法区</strong><br><strong>堆</strong><br><strong>虚拟机栈</strong><br><strong>本地方法栈</strong><br><strong>程序计数器</strong></td>
<td>线程共享：<br>- <strong>方法区</strong>: 存储已加载的类信息、常量、静态变量等。<br>- <strong>堆</strong>: 存储所有对象实例和数组。<br><br>线程私有：<br>- <strong>虚拟机栈</strong>: 存储方法调用的局部变量、操作数栈等。<br>- <strong>本地方法栈</strong>: 存储 Native 方法的调用信息。<br>- <strong>程序计数器</strong>: 记录当前线程正在执行的字节码指令地址。</td>
</tr>
<tr>
<td><strong>执行引擎</strong></td>
<td>执行字节码指令</td>
<td><strong>解释器</strong><br><strong>即时编译器 (JIT)</strong><br><strong>垃圾收集器 (GC)</strong></td>
<td>负责将字节码翻译成机器指令并执行。<br>- <strong>解释器</strong>: 逐行解释执行字节码。<br>- <strong>JIT</strong>: 将热点代码编译成高效的本地机器码。<br>- <strong>GC</strong>: 自动回收堆中不再使用的对象内存。</td>
</tr>
<tr>
<td><strong>本地方法接口</strong></td>
<td>调用 Native 方法</td>
<td>JNI (Java Native Interface)</td>
<td>允许 Java 代码与其他语言（如 C&#x2F;C++）编写的代码进行交互。</td>
</tr>
<tr>
<td><strong>本地方法库</strong></td>
<td>支持 Native 方法</td>
<td>一系列本地方法库</td>
<td>提供了执行引擎调用本地方法所需的库文件。</td>
</tr>
</tbody></table>
<p>JVM(Java Virtual Machine)在执行Java程序时,会将内存划分为几个不同的区域,这些区域有各自的用途和生命周期。</p>
<ul>
<li><p><strong>程序计数器 (Program Counter Register)</strong></p>
<ul>
<li>功能:一块较小的内存空间,用于存储当前线程所执行的字节码的行号指示器。</li>
<li>特点:<ul>
<li>每个线程私有,生命周期与线程一致。</li>
<li>JVM规范中唯一没有规定任何OutOfMemoryError情况的区域。</li>
<li>在多线程切换时,程序计数器记录了当前线程的执行位置,使得线程切换回来后能够知道从哪里继续执行。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Java虚拟机栈 (Java Virtual Machine Stacks)</strong></p>
<ul>
<li>功能:每个线程私有的内存区域,用于存储栈帧(Stack Frame)。每个方法被执行时都会创建一个栈帧,用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>
<li>特点:<ul>
<li>生命周期与线程一致。</li>
<li>局部变量表:存储方法参数和方法内部定义的局部变量。</li>
<li>操作数栈:用于存放方法执行时的操作数和中间结果。</li>
<li>动态链接:指向运行时常量池中该栈帧所属方法的引用。</li>
<li>方法出口:记录方法执行完后回到哪里。</li>
<li>可能抛出StackOverflowError(栈深度超过虚拟机允许的深度)或OutOfMemoryError(栈扩展时无法申请到足够的内存)。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>本地方法栈 (Native Method Stacks)</strong></p>
<ul>
<li>功能:与虚拟机栈类似,但是为JVM执行Native方法(即用C&#x2F;C++等语言实现的方法)服务。</li>
<li>特点：<ul>
<li>每个线程私有。</li>
<li>可能抛出 StackOverflowError 或 OutOfMemoryError。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Java 堆 (Java Heap)</strong></p>
<ul>
<li><p>功能:JVM 管理的最大一块内存区域，被所有线程共享，用于存放对象实例和数组。</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>是垃圾收集器管理的主要区域 (GC 堆)。</p>
</li>
<li><p>是 Java 应用程序对象存放的“老家”。</p>
</li>
<li><p>根据垃圾回收的特性，可以分为新生代 (Young Generation) 和老年代 (Old Generation)。</p>
</li>
<li><p>新生代:通常分为 Eden 空间和两个 Survivor 空间 (From 和 To)。新创建的对象优先在 Eden 区分配，经过 Minor GC 后存活的对象进入 Survivor 区，多次 GC 后仍存活的对象进入老年代。</p>
</li>
<li><p>老年代:存放生命周期较长的对象。</p>
</li>
<li><p>在 JVM 内存模型中，新生代被划分为三个区域，默认的比例通常是 <strong>8:1:1</strong>。</p>
<ul>
<li><strong>Eden 区</strong>：占比 <strong>80%</strong>。这是新创建对象的主要分配区域。</li>
<li><strong>Survivor S0 区</strong>：占比 <strong>10%</strong>。</li>
<li><strong>Survivor S1 区</strong>：占比 <strong>10%</strong>。</li>
</ul>
<hr>
<h3 id="为什么要这样划分？"><a href="#为什么要这样划分？" class="headerlink" title="为什么要这样划分？"></a><strong>为什么要这样划分？</strong></h3><p>这种划分是为了配合 Minor GC 的垃圾回收流程，从而提高垃圾回收的效率。</p>
<h4 id="新生代的垃圾回收流程"><a href="#新生代的垃圾回收流程" class="headerlink" title="新生代的垃圾回收流程"></a><strong>新生代的垃圾回收流程</strong></h4><ol>
<li><strong>对象创建</strong>：新创建的对象首先在 <strong>Eden 区</strong> 分配。</li>
<li><strong>Minor GC</strong>：当 <strong>Eden 区</strong> 满了之后，会触发一次 Minor GC（也叫 Young GC）。</li>
<li><strong>存活对象转移</strong>：<ul>
<li>在 Eden 区和其中一个 Survivor 区（比如 S0）中，所有存活的对象会被复制到另一个空的 Survivor 区（比如 S1）。</li>
<li>同时，对象的年龄（age）会加一。</li>
</ul>
</li>
<li><strong>清空 Eden 和 S0</strong>：垃圾回收后，Eden 区和 S0 区都会被清空。</li>
<li><strong>角色互换</strong>：下一次 Minor GC 时，Eden 区和 S1 区中存活的对象会被复制到 S0 区。S0 和 S1 两个 Survivor 区会不断地进行角色互换。</li>
<li><strong>晋升老年代</strong>：<ul>
<li>当对象的年龄达到一个设定的阈值（默认为 15），或者 Survivor 区中同一年龄段的对象大小超过了一定比例，这些对象就会被移动到<strong>老年代</strong>。</li>
<li>这种设计也被称为<strong>复制算法（Copying Algorithm）</strong>，它在新生代存活对象较少的情况下，效率非常高。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="为什么是-8-1-1？"><a href="#为什么是-8-1-1？" class="headerlink" title="为什么是 8:1:1？"></a><strong>为什么是 8:1:1？</strong></h3><p>这个比例是一个经验值，基于大多数 Java 应用的特点：</p>
<ul>
<li><strong>大多数对象都是朝生夕灭的</strong>。因此，将 Eden 区设置得更大，可以容纳更多的新对象，减少 Minor GC 的频率。</li>
<li>两个 Survivor 区只需要用来暂存存活的对象，因此不需要太大。10% 的空间通常足以容纳一次 Minor GC 后存活的对象。</li>
</ul>
<p>当然，这个比例不是固定的。在某些特殊情况下，如果新生代存活对象较多，导致 Survivor 区无法容纳所有存活对象，JVM 会发生<strong>空间分配担保</strong>，将这些对象直接晋升到老年代。</p>
<p>你可以通过 JVM 参数来调整这个比例，例如： <code>java -Xmn100m -XX:SurvivorRatio=8</code></p>
<p>这个命令设置新生代总大小为 100MB，Eden 区和 Survivor 区的比例为 8:1:1。</p>
</li>
<li><p>可能抛出 OutOfMemoryError。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>方法区 (Method Area)</strong></p>
<ul>
<li>功能:被所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
<li>特点：<ul>
<li>在 JDK 1.7 及之前，方法区被称为“永久代 (Permanent Generation)”，它属于堆内存的一部分。</li>
<li>在 JDK 1.8 及之后，永久代被移除，方法区的实现改为“元空间 (Metaspace)”，并且元空间不使用 JVM 内存，而是直接使用本地内存 (Native Memory)。</li>
<li>可能抛出 OutOfMemoryError。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>运行时常量池 (Runtime Constant Pool)</strong></p>
<ul>
<li>功能:方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</li>
<li>特点：<ul>
<li>动态性:Java 语言并不要求常量池在编译期就全部确定，运行时也可以将新的常量放入池中 (如 String.intern())。</li>
<li>可能抛出 OutOfMemoryError。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>程序计数器（Program Counter Register）：是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。程序的分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的命令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储，我们程这块内存区域为“线程私有”的内存。</p>
<p>此区域是唯一一个虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p>
<hr>
<h3 id="2-Java-虚拟机栈"><a href="#2-Java-虚拟机栈" class="headerlink" title="2. Java 虚拟机栈"></a>2. Java 虚拟机栈</h3><p>Java 虚拟机栈（Java Virtual Machine Stacks）：描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个帧栈（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。它的线程也是私有的，生命周期与线程相同。</p>
<p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和 returnAddress 类型（指向了一条字节码指令的地址）。</p>
<p>Java 虚拟机栈的局部变量表的空间单位是槽（Slot），其中 64 位长度的 double 和 long 类型会占用两个 Slot。局部变量表所需内存空间在编译期完成分配，当进入一个方法时，该方法需要在帧中分配多大的局部变量是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>Java虚拟机栈有两种异常状况：如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出 <code>StackOverflowError</code> 异常；如果扩展时无法申请到足够的内存，就会抛出 <code>OutOfMemoryError</code> 异常。</p>
<hr>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>本地方法栈（Native Method Stack）：与虚拟机栈所发的作用是非常相似的，它们之间的区别只不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p>
<p>Java 虚拟机规范没有对本地方法栈中方法使用的语言、使用的方式和数据结构做出强制规定，因此具体的虚拟机可以自由地实现它。比如：Sun HotSpot 虚拟机直接把Java虚拟机栈和本地方法栈合二为一。</p>
<p>与Java虚拟机栈一样，本地方法栈也会抛出<code>StackOverflowError</code>和 <code>OutOfMemoryError</code> 异常。</p>
<hr>
<h3 id="4-Java-堆"><a href="#4-Java-堆" class="headerlink" title="4. Java 堆"></a>4. Java 堆</h3><p>Java堆（Java Heap）：是被所有线程所共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是：存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC”堆（Garbage Collected Heap）。从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代。从内存分配角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）。不过无论如何划分，都与存放的内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p>
<p>Java 虚拟机规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，可以是固定大小的，也可以是可扩展的。如果在堆中没有完成实例分配。并且堆也无法扩展时，将会抛出 <code>OutOfMemoryError</code> 异常。</p>
<hr>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>方法区（Method Area）：与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），其目的应该就是与 Java 堆区分开来。</p>
<p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</p>
<p>根据Java虚拟机规范规定，当方法区无法满足内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p>
<p><strong>运行时常量池</strong>：运行时常量池（Runtime Constant Pool）：是方法区的一部分。<code>Class</code> 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一些信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>Java 虚拟机对 Class 文件每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行。</p>
<p><strong>直接内存</strong>：直接内存（Direct Memory）：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也频繁地使用，而且也可能导致 <code>OutOfMemoryError</code> 异常。</p>
<p>本地直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存大小以及处理器寻址空间的限制。如果各个内存区域总和大于物理内存限制，从而导致动态扩展时出现 <code>OutOfMemoryError</code> 异常。</p>
<hr>
<h3 id="3-堆和栈的区别是什么？"><a href="#3-堆和栈的区别是什么？" class="headerlink" title="3. 堆和栈的区别是什么？"></a>3. 堆和栈的区别是什么？</h3><p>堆和栈（虚拟机栈）是完全不同的两块内存区域，一个是线程独享的，一个是线程共享的。二者之间最大的区别就是存储的内容不同：堆中主要存放对象实例。栈（局部变量表）中主要存放各种基本数据类型、对象的引用。</p>
<p>从作用来说，栈是运行时的单位，而堆是存储的单位。栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。在 Java 中一个线程就会相应有一个线程栈与之对应，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。</p>
<hr>
<h3 id="4-堆中存什么？栈中存什么？"><a href="#4-堆中存什么？栈中存什么？" class="headerlink" title="4. 堆中存什么？栈中存什么？"></a>4. 堆中存什么？栈中存什么？</h3><p>堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个 4btye 的引用（堆栈分离的好处）。</p>
<p>为什么不把基本类型放堆中呢？</p>
<p>因为基本数据类型占用的空间一般是1~8个字节，需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况，长度固定，因此栈中存储就够了。如果把它存在堆中是没有什么意义的。基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，它们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java 中参数传递时的问题。</p>
<hr>
<h3 id="5-为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"><a href="#5-为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？" class="headerlink" title="5. 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"></a>5. 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</h3><ol>
<li>从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</li>
<li>堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li>
<li>栈因为运行时的需要，比如：保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</li>
</ol>
<hr>
<h3 id="6-Java-中的参数传递时传值呢？还是传引用？"><a href="#6-Java-中的参数传递时传值呢？还是传引用？" class="headerlink" title="6. Java 中的参数传递时传值呢？还是传引用？"></a>6. Java 中的参数传递时传值呢？还是传引用？</h3><p>要说明这个问题，先要明确两点：</p>
<ol>
<li>不要试图与 C 进行类比，Java 中没有指针的概念。</li>
<li>程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。</li>
</ol>
<p>Java 在方法调用传递参数时，因为没有指针，所以它都是进行传值调用。但是传引用的错觉是如何造成的呢？在运行栈中，基本类型和引用的处理是一样的，都是传值。所以，如果是传引用的方法调用，也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。但是当进入被调用方法时，被传递的这个引用的值，被程序解释到堆中的对象，这个时候才对应到真正的对象。如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是堆中的数据。所以这个修改是可以保持的了。</p>
<p>对象，从某种意义上说，是由基本类型组成的。可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树（即非叶子节点），基本类型则为树的叶子节点。程序参数传递时，被传递的值本身都是不能进行修改的，但是，如果这个值是一个非叶子节点（即一个对象引用），则可以修改这个节点下面的所有内容。</p>
<hr>
<h3 id="7-Java-对象的大小是怎么计算的？"><a href="#7-Java-对象的大小是怎么计算的？" class="headerlink" title="7. Java 对象的大小是怎么计算的？"></a>7. Java 对象的大小是怎么计算的？</h3><p>基本数据类型的大小是固定的。对于非基本类型的 Java 对象，其大小就值得商榷。在 Java 中，一个空 <code>Object</code> 对象的大小是 8 byte，这个大小只是保存堆中一个没有任何属性的对象的<code>大小。看下面语句： </code>Object ob &#x3D; new Object();<code> 这样在程序中完成了一个 Java 对象的生命，但是它所占的空间为：</code>4 byte + 8 byte<code>。</code>4 byte<code>是上面部分所说的 Java 栈中保存引用的所需要的空间。而那</code>8 byte<code>则是 Java 堆中对象的信息。因为所有的 Java 非基本类型的对象都需要默认继承</code>Object<code>对象，因此不论什么样的 Java 对象，其大小都必须是大于</code>8 byte<code>。有了 </code>Object&#96; 对象的大小，我们就可以计算其他对象的大小了。</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class MaNong &#123;</span><br><span class="line">    int count;</span><br><span class="line">    boolean flag;</span><br><span class="line">    Object obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MaNong</code> 的大小为：空对象大小(8 byte) + <code>int</code> 大小(4 byte) + <code>Boolean</code> 大小(1 byte) + 空 <code>Object</code> 引用的<code>大小（4 byte）</code> &#x3D; 17byte。但是因为 Java 在对对象内存分配时都是以 8 的整数倍来分，因此大于 17 byte 的最接近 8 的整数倍的是 24，因此此对象的大小为 24 byte。</p>
<p>这里需要注意一下基本类型的包装类型的大小。因为这种包装类型已经成为对象了，因此需要把它们作为对象来看待。包装类型的大小至少是12 byte（声明一个空 <code>Object</code> 至少需要的空间），而且 12 byte 没有包含任何有效信息，同时，因为 Java 对象大小是 8 的整数倍，因此一个基本类型包装类的大小至少是 16 byte。这个内存占用是很恐怖的，它是使用基本类型的 N 倍（N &gt; 2），有些类型的内存占用更是夸张（随便想下就知道了）。因此，可能的话应尽量少使用包装类。在 JDK5 以后，因为加入了自动类型装换，因此，Java 虚拟机会在存储方面进行相应的优化。</p>
<hr>
<h3 id="8-对象的访问定位的两种方式？"><a href="#8-对象的访问定位的两种方式？" class="headerlink" title="8. 对象的访问定位的两种方式？"></a>8. 对象的访问定位的两种方式？</h3><p>Java 程序通过栈上的引用数据来操作堆上的具体对象。目前主流的对象访问方式有：句柄 和 直接指针。</p>
<ol>
<li><p>使用句柄</p>
<p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
</li>
<li><p>直接指针</p>
<p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何防止访问类型数据的相关信息，reference 中存储的直接就是对象的地址。</p>
</li>
<li><p><strong>各自的优点</strong></p>
</li>
<li><p>使用句柄来访问的最大好处是引用中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而引用本身不需要修改；</p>
</li>
<li><p>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>
</li>
</ol>
<h3 id="JVM-调优参数"><a href="#JVM-调优参数" class="headerlink" title="JVM 调优参数"></a>JVM 调优参数</h3><ul>
<li><strong>堆内存大小设置:</strong><ul>
<li>-Xms<size>:设置 JVM 堆的初始内存大小。</li>
<li>-Xmx<size>:设置 JVM 堆的最大内存大小。</li>
<li>最佳实践:通常建议 -Xms 和 -Xmx 设置为相同值，以避免 JVM 在运行时动态调整堆大小带来的额外开销和 GC 停顿。例如 -Xms4g -Xmx4g。</li>
</ul>
</li>
<li><strong>新生代大小设置:</strong><ul>
<li>-Xmn<size>:设置新生代内存大小。</li>
<li>-XX:NewRatio&#x3D;<ratio>:设置老年代与新生代的比例，例如 -XX:NewRatio&#x3D;2 表示老年代:新生代 &#x3D; 2:1。</li>
<li>考量:<ul>
<li>新生代过小:频繁 Minor GC, 导致对象过早进入老年代。</li>
<li>新生代过大:Minor GC 间隔长, 但每次 GC 耗时可能长。</li>
</ul>
</li>
</ul>
</li>
<li><strong>元空间大小设置 (JDK 1.8+):</strong><ul>
<li>-XX:MetaspaceSize&#x3D;<size>:设置元空间的初始大小。</li>
<li>-XX:MaxMetaspaceSize&#x3D;<size>:设置元空间的最大大小。</li>
<li>考量:如果应用加载大量类或使用动态代码生成, 可能需要调大。</li>
</ul>
</li>
<li><strong>选择垃圾收集器:</strong><ul>
<li>-XX:+UseG1GC:启用 G1 垃圾收集器。这是 JDK 9+ 的默认收集器。</li>
<li>-XX:MaxGCPauseMillis&#x3D;<ms>:设置 G1 收集器可接受的最大停顿时间(G1 会尽量接近这个目标, 但不保证完全达到)。例如 -XX:MaxGCPauseMillis&#x3D;200。</li>
</ul>
</li>
</ul>
<h3 id="10-垃圾回收是从哪里开始的呢？"><a href="#10-垃圾回收是从哪里开始的呢？" class="headerlink" title="10. 垃圾回收是从哪里开始的呢？"></a>10. 垃圾回收是从哪里开始的呢？</h3><p>垃圾回收从查找哪些对象是正在被当前系统使用的开始。上面分析的堆和栈的区别，其中栈是真正进行程序执行的地方，所以要获取哪些对象正在被使用，则需要从 Java 栈开始。同时，一个栈是与一个线程对应的，因此，如果有多个线程的话，则必须对这些线程对应的所有的栈进行检查。</p>
<p>同时，除了栈外，还有系统运行时的寄存器等，也是存储程序运行数据的。这样，以栈或寄存器中的引用为起点，我们可以找到堆中的对象，又从这些对象找到对堆中其他对象的引用，这种引用逐步扩展，最终以 <code>null</code> 引用或者基本类型结束，这样就形成了一棵以 Java 栈中引用所对应的对象为根节点的一棵对象树。如果栈中有多个引用，则最终会形成多棵对象树。在这些对象树上的对象，都是当前系统运行所需要的对象，不能被垃圾回收。而其他剩余对象，则可以视为无法被引用到的对象，可以被当做垃圾进行回收。</p>
<hr>
<h3 id="11-被标记为垃圾的对象一定会被回收吗？"><a href="#11-被标记为垃圾的对象一定会被回收吗？" class="headerlink" title="11. 被标记为垃圾的对象一定会被回收吗？"></a>11. 被标记为垃圾的对象一定会被回收吗？</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。</p>
<ul>
<li><strong>第一次标记</strong>：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记；</li>
<li><strong>第二次标记</strong>：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize()</code> 方法。在 <code>finalize()</code> 方法中没有重新与引用链建立关联关系的，将被进行第二次标记。第二次标记成功的对象将真的会被回收，如果对象在 <code>finalize()</code> 方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。</li>
</ul>
<hr>
<h3 id="12-谈谈对-Java-中引用的了解？"><a href="#12-谈谈对-Java-中引用的了解？" class="headerlink" title="12. 谈谈对 Java 中引用的了解？"></a>12. 谈谈对 Java 中引用的了解？</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在Java语言中，将引用又分为强引用、软引用、弱引用、虚引用 4 种，这四种引用强度依次逐渐减弱。</p>
<ol>
<li><p>强引用</p>
<p>在程序代码中普遍存在的，类似 Object obj &#x3D; new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
</li>
<li><p>软引用</p>
<p>用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内</p>
</li>
<li><p>弱引用</p>
<p>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
</li>
<li><p>虚引用</p>
<p>也叫幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。</p>
</li>
</ol>
<hr>
<h3 id="13-谈谈对内存泄漏的理解？"><a href="#13-谈谈对内存泄漏的理解？" class="headerlink" title="13. 谈谈对内存泄漏的理解？"></a>13. 谈谈对内存泄漏的理解？</h3><p>内存泄露的基本概念</p>
<p>在 Java 中，内存泄漏就是存在一些不会再被使用却没有被回收的对象，这些对象有下面两个特点：</p>
<ol>
<li><p>这些对象是可达的，即在有向图中，存在通路可以与其相连；</p>
</li>
<li><p>这些对象是无用的，即程序以后不会再使用这些对象。</p>
<p>如果对象满足这两个条件，这些对象就可以判定为 Java 中的内存泄漏，这些对象不会被 GC 所回收，然而它却占用内存。</p>
</li>
</ol>
<hr>
<h3 id="14-内存泄露的根本原因是什么？"><a href="#14-内存泄露的根本原因是什么？" class="headerlink" title="14. 内存泄露的根本原因是什么？"></a>14. 内存泄露的根本原因是什么？</h3><p>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是 Java 中内存泄漏的发生场景。</p>
<hr>
<h3 id="15-举几个可能发生内存泄漏的情况？"><a href="#15-举几个可能发生内存泄漏的情况？" class="headerlink" title="15. 举几个可能发生内存泄漏的情况？"></a>15. 举几个可能发生内存泄漏的情况？</h3><ol>
<li>静态集合类引起的内存泄漏；</li>
<li>当集合里面的对象属性被修改后，再调用 <code>remove()</code> 方法时不起作用；</li>
<li>监听器：释放对象的时候没有删除监听器；</li>
<li>各种连接：比如数据库连接（<code>dataSourse.getConnection()</code>），网络连接(<code>socket</code>) 和 IO 连接，除非其显式的调用了其 <code>close()</code> 方法将其连接关闭，否则是不会自动被 GC 回收的；</li>
<li>内部类：内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放；</li>
<li>单例模式：单例对象在初始化后将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏。</li>
</ol>
<hr>
<h3 id="16-尽量避免内存泄漏的方法？"><a href="#16-尽量避免内存泄漏的方法？" class="headerlink" title="16. 尽量避免内存泄漏的方法？"></a>16. 尽量避免内存泄漏的方法？</h3><ol>
<li>尽量不要使用 <code>static</code> 成员变量，减少生命周期；</li>
<li>及时关闭资源；</li>
<li>不用的对象，可以手动设置为 <code>null</code>。</li>
</ol>
<h3 id="垃圾收集器-Garbage-Collector"><a href="#垃圾收集器-Garbage-Collector" class="headerlink" title="垃圾收集器 (Garbage Collector)"></a>垃圾收集器 (Garbage Collector)</h3><p>垃圾收集器是 JVM 的一个重要组成部分, 负责自动管理 Java 堆内存中的对象的生命周期, 回收不再使用的对象所占用的内存。</p>
<h4 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法:"></a><strong>垃圾判断算法:</strong></h4><ul>
<li>引用计数算法:当一个对象被引用一次, 计数器加1;引用失效, 计数器减1。当计数器为0时, 对象被判定为可回收。<ul>
<li>缺点:难以解决对象之间的循环引用问题。Java 虚拟机不采用此算法。</li>
</ul>
</li>
<li>可达性分析算法 (Root Tracing):通过一系列称为 “GC Roots” 的对象作为起始点, 从这些节点向下搜索, 搜索所走过的路径称为引用链 (Reference Chain)。当一个对象到 GC Roots 没有任何引用链相连时, 则证明此对象是不可用的。<ul>
<li>可作为 GC Roots 的对象:<ul>
<li>虚拟机栈 (栈帧中的局部变量表) 中引用的对象。</li>
<li>本地方法栈 (Native 方法) 中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>被同步锁持有的对象。</li>
<li>JVM 内部的引用 (如基本数据类型对应的 Class 对象)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器:"></a><strong>常见垃圾收集器:</strong></h4><ul>
<li><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器:"></a>Serial 收集器:</h5><ul>
<li>特点:单线程, 工作时需要停止所有用户线程 (“Stop The World”, STW)。简单高效, 适用于单核 CPU 或内存较小的客户端应用。</li>
<li>新生代使用:复制算法。</li>
<li>老年代使用:标记-整理算法。</li>
</ul>
</li>
<li><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器:"></a>ParNew 收集器:</h5><ul>
<li>特点:Serial 收集器的多线程版本, 用于新生代。并行收集时也需要 STW。</li>
<li>新生代使用:复制算法。</li>
<li>常与 CMS 收集器配合使用。</li>
</ul>
</li>
<li><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器:"></a>Parallel Scavenge 收集器:</h5><ul>
<li>特点：关注吞吐量（Throughput &#x3D; 用户代码执行时间 &#x2F; (用户代码执行时间 + GC 时间)），可以设置最大吞吐量或最大 GC 停顿时间。</li>
<li>新生代使用：复制算法。</li>
<li>老年代使用：与 Parallel Old 配合使用，使用标记-整理算法。</li>
</ul>
</li>
<li><h5 id="CMS-Concurrent-Mark-Sweep-收集器："><a href="#CMS-Concurrent-Mark-Sweep-收集器：" class="headerlink" title="CMS (Concurrent Mark Sweep) 收集器："></a>CMS (Concurrent Mark Sweep) 收集器：</h5><ul>
<li>特点：以获取最短回收停顿时间为目标，并发收集（与用户线程一起执行）。适用于对响应时间要求高的应用（如 Web 服务器）。</li>
<li>工作步骤：<ol>
<li>初始标记 (Initial Mark)：STW，标记 GC Roots 能直接关联到的对象，速度快。</li>
<li>并发标记 (Concurrent Mark)：与用户线程并发执行，进行 GC Roots Tracing 过程，耗时最长。</li>
<li>重新标记 (Remark)：STW，修正并发标记期间因用户程序继续运行而导致标记产生变动的对象，比初始标记耗时长，但远比并发标记短。</li>
<li>并发清除 (Concurrent Sweep)：与用户线程并发执行，清除已标记为垃圾的对象。</li>
</ol>
</li>
<li>缺点：<ul>
<li>对 CPU 资源敏感：并发阶段会占用一部分 CPU。</li>
<li>无法处理浮动垃圾：并发清除阶段产生的垃圾（新生成的对象）只能下次 GC 再处理。</li>
<li>可能产生大量空间碎片：采用“标记-清除”算法，不进行整理，可能导致大对象无法分配空间而提前触发 Full GC。</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="G1-Garbage-First-收集器："><a href="#G1-Garbage-First-收集器：" class="headerlink" title="G1 (Garbage-First) 收集器："></a>G1 (Garbage-First) 收集器：</h5><ul>
<li>特点：JDK 9+ 的默认垃圾收集器。面向服务端应用，分区（将 Java 堆划分为多个独立区域 Region)，可预测的停顿时间模型。</li>
<li>工作原理：<ul>
<li>将堆内存划分为多个大小相等的 Region。</li>
<li>G1 跟踪每个 Region 的垃圾回收价值 (Garbage-First)，优先回收垃圾最多的 Region。</li>
<li>年轻化和老年代不再是物理隔离，而是逻辑上的概念，Region 可以动态地成为 Eden、Survivor 或 Old 区域。</li>
<li>并发与并行兼容：并发标记，但回收阶段并行。</li>
<li>基本无碎片：采用复制和标记-整理算法结合。</li>
</ul>
</li>
<li>工作步骤：<ol>
<li>初始标记 (Initial Mark)：STW，标记 GC Roots 能直接关联的对象。</li>
<li>并发标记 (Concurrent Mark)：与用户线程并发，遍历对象图。</li>
<li>最终标记 (Final Mark)：STW，处理并发标记阶段结束后仍然存活的对象。</li>
<li>筛选回收 (Evacuation)：STW，对各个 Region 的回收价值进行排序，根据预期停顿时间来回收 Region，采用复制算法将存活对象复制到新的 Region。</li>
</ol>
</li>
<li>优势：在保持高吞吐量的同时，降低了 GC 停顿时间，适合大内存、多核处理器场景。</li>
</ul>
</li>
<li><h5 id="zGC-Z-Garbage-Collector-和-Shenandoah-收集器："><a href="#zGC-Z-Garbage-Collector-和-Shenandoah-收集器：" class="headerlink" title="zGC (Z Garbage Collector) 和 Shenandoah 收集器："></a>zGC (Z Garbage Collector) 和 Shenandoah 收集器：</h5><ul>
<li>特点：低延迟、并发 GC 收集器，旨在实现毫秒级的 GC 停顿。</li>
<li>ZGC: JDK 11 引入，支持 TB 级别的堆内存，停顿时间与堆大小无关。</li>
<li>Shenandoah: JDK 12 引入，与 G1 类似，但能进一步降低停顿时间。</li>
<li>应用场景：对延迟要求极高的应用</li>
</ul>
</li>
</ul>
<h2 id="类加载机制-Class-Loading-Mechanism"><a href="#类加载机制-Class-Loading-Mechanism" class="headerlink" title="类加载机制 (Class Loading Mechanism)"></a>类加载机制 (Class Loading Mechanism)</h2><ul>
<li><p><strong>作用</strong>: 将 .class 文件中的字节码加载到 JVM 内存中，并转换为运行时数据结构。  </p>
</li>
<li><p><strong>生命周期</strong>: 加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载。  </p>
</li>
<li><p><strong>主要阶段</strong>:  </p>
<ul>
<li><strong>加载 (Loading)</strong>:  <ul>
<li>通过类的全限定名获取该类的二进制字节流。  </li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  </li>
<li>在内存中生成一个代表该类的 java.lang.Class 对象。</li>
</ul>
</li>
<li><strong>验证 (Verification)</strong>: 确保 Class 文件的字节流符合 JVM 规范，没有安全问题。  </li>
<li><strong>准备 (Preparation)</strong>: 为类的静态变量（static fields）分配内存并初始化为默认值（如 int 变量为 0，引用类型为 null）。  </li>
<li><strong>解析 (Resolution)</strong>: 将常量池中的符号引用替换为直接引用。  </li>
<li><strong>初始化 (Initialization)</strong>: 执行类的构造器 <code>&lt;clinit&gt;()</code> 方法，真正开始执行类中定义的 Java 程序代码（为静态变量赋予初始值，执行静态代码块）。</li>
</ul>
</li>
<li><p>类加载是 Java 虚拟机（JVM）将 <code>Class</code> 文件中的二进制数据读取到内存中，并将其转换为可用的 <code>java.lang.Class</code> 对象的过程。这个过程是所有 Java 程序运行的基础。</p>
<p>类加载的整个生命周期包括以下 7 个阶段：</p>
<ol>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ol>
<p>其中，前五个阶段是类加载的核心过程，后面两个阶段是类生命周期的延伸。下面我们详细解析前五个核心阶段。</p>
<hr>
<h3 id="1-加载（Loading）"><a href="#1-加载（Loading）" class="headerlink" title="1. 加载（Loading）"></a>1. 加载（Loading）</h3><p>这是类加载过程的第一个阶段，主要任务是查找并导入 <code>Class</code> 文件中的二进制数据。这个阶段主要完成三件事：</p>
<ul>
<li><strong>通过类的全限定名获取定义此类的二进制字节流</strong>：JVM 可以从文件系统、网络、压缩包（JAR&#x2F;WAR&#x2F;EAR）甚至数据库中获取字节流。</li>
<li><strong>将字节流中的静态存储结构转换为方法区的运行时数据结构</strong>：JVM 会将二进制数据按照虚拟机规范的要求，转化为方法区中可用的数据结构。</li>
<li><strong>在内存中生成一个代表该类的 java.lang.Class 对象</strong>：这个对象是访问方法区中该类各种数据（如方法、字段）的入口，也是反射机制的基石。</li>
</ul>
<hr>
<h3 id="2-验证（Verification）"><a href="#2-验证（Verification）" class="headerlink" title="2. 验证（Verification）"></a>2. 验证（Verification）</h3><p>验证阶段的目的是确保 <code>Class</code> 文件的字节流符合 JVM 规范，并且不会危害到虚拟机的安全。这个阶段非常重要，因为 <code>Class</code> 文件不一定是由 Java 源码编译而来，它可以是任何来源。验证通常包括以下几个检查：</p>
<ul>
<li><strong>文件格式验证</strong>：检查字节流是否符合 <code>Class</code> 文件格式的规范，例如魔数（<code>0xCAFEBABE</code>）、版本号等。</li>
<li><strong>元数据验证</strong>：对类的元数据进行语义分析，确保其符合 Java 语言规范，例如是否继承了不允许继承的 <code>final</code> 类、字段和方法签名是否合理等。</li>
<li><strong>字节码验证</strong>：这是验证阶段最复杂的一步，通过数据流和控制流分析，确保程序语义是合法的、符合逻辑的。例如，保证类型转换是有效的、方法调用的参数是正确的。</li>
<li><strong>符号引用验证</strong>：在解析阶段发生，确保解析出来的类、字段、方法是真实存在的，并且具有足够的访问权限。</li>
</ul>
<hr>
<h3 id="3-准备（Preparation）"><a href="#3-准备（Preparation）" class="headerlink" title="3. 准备（Preparation）"></a>3. 准备（Preparation）</h3><p>准备阶段是为类的<strong>静态变量</strong>分配内存并设置<strong>初始值</strong>的阶段。</p>
<ul>
<li><strong>只为静态变量分配内存</strong>：在这个阶段，JVM 只为 <code>static</code> 变量（类变量）分配内存，而不包括实例变量。实例变量会在对象实例化时随着对象一起分配在堆中。</li>
<li><strong>设置初始值</strong>：这里的初始值通常是该数据类型的<strong>零值</strong>（例如 <code>int</code> 的初始值为 <code>0</code>，<code>boolean</code> 为 <code>false</code>，<code>String</code> 为 <code>null</code>）。</li>
</ul>
<p><strong>注意</strong>：如果静态变量被 <code>final</code> 修饰，并且是基本数据类型或字符串字面量，那么在准备阶段就会直接赋值为它在代码中定义的值。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备阶段：value 的初始值为 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备阶段：finalValue 的初始值直接为 123</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalValue</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-解析（Resolution）"><a href="#4-解析（Resolution）" class="headerlink" title="4. 解析（Resolution）"></a>4. 解析（Resolution）</h3><p>解析阶段是将常量池中的<strong>符号引用</strong>转换为<strong>直接引用</strong>的过程。</p>
<ul>
<li><strong>符号引用</strong>：一组符号来描述所引用的目标，可以是任何形式的字面量，只要能定位到目标即可。它不依赖于内存布局。</li>
<li><strong>直接引用</strong>：直接指向目标的指针、相对偏移量或是一个可以间接定位到目标的句柄。它与内存布局相关。</li>
</ul>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符七类符号引用进行。这个阶段是动态的，通常会在程序运行时，当符号引用被首次使用时才进行。</p>
<hr>
<h3 id="5-初始化（Initialization）"><a href="#5-初始化（Initialization）" class="headerlink" title="5. 初始化（Initialization）"></a>5. 初始化（Initialization）</h3><p>初始化是类加载过程的最后一步，在这个阶段，<strong>真正执行</strong>类中定义的 Java 代码。</p>
<ul>
<li><strong>执行 <clinit>() 方法</strong>：初始化阶段会执行类构造器 <code>&lt;clinit&gt;()</code> 方法，这个方法由编译器自动生成，它用于收集类中所有静态变量的赋值动作和静态代码块（<code>static &#123;&#125;</code>）中的语句。</li>
<li><strong>线程安全</strong>：JVM 会确保 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确地加锁和同步，保证一个类的 <code>&lt;clinit&gt;()</code> 方法只会被执行一次。</li>
<li><strong>触发时机</strong>：只有在以下几种情况中，一个类才会被“主动”初始化：<ul>
<li>创建类的实例（<code>new</code>）。</li>
<li>访问类的静态变量（除了在编译时被 <code>final</code> 化的常量）。</li>
<li>调用类的静态方法。</li>
<li>使用 <code>java.lang.reflect</code> 包的方法进行反射调用。</li>
<li>初始化一个子类时，其父类尚未初始化。</li>
<li>虚拟机启动时，被指定为启动类的类（如包含 <code>main()</code> 方法的类）。</li>
</ul>
</li>
</ul>
<p>理解这五个阶段对于深入掌握 JVM 的工作原理至关重要。</p>
</li>
<li><p><strong>类加载器 (Class Loaders)</strong>:  </p>
<ul>
<li><p>类加载器的分类：</p>
<p>（1）Bootstrap class loader （使用C++编写的）</p>
<p>​    简称：启动类加载器</p>
<p>​    <strong>加载路径</strong>：JAVA_HOME&#x2F;jre&#x2F;lib</p>
<p>​    显示形式：null</p>
<p>（2）Platform class loader（由Java编写的）</p>
<p>​    简称：扩展类加载器</p>
<p>​    <strong>加载路径</strong>：JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</p>
<p>​    显示形式：ExtClassLoader</p>
<p>（3）System class loader（由Java编写的）</p>
<p>​    简称：应用程序类加载器</p>
<p>​    <strong>加载路径</strong>：类路径（src目录）</p>
<p>​    显示形式：AppClassLoader   &#x2F;&#x2F;sun.misc.Launcher$AppClassLoader@18b4aac2</p>
<p>（4）自定义类加载器（由Java编写的）</p>
<p>​    简称：自定义类加载器</p>
<p>​    加载路径：自定义</p>
<h4 id="1-启动类加载器-Bootstrap-ClassLoader"><a href="#1-启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="1. 启动类加载器 (Bootstrap ClassLoader)"></a><strong>1. 启动类加载器 (Bootstrap ClassLoader)</strong></h4><ul>
<li><strong>作用</strong>：它负责加载 Java 核心库，比如 <code>rt.jar</code>（包含 <code>java.lang.*</code>, <code>java.util.*</code> 等核心类）。</li>
<li><strong>实现</strong>：它不是用 Java 写的，而是由 C++ 实现的，是 JVM 自身的一部分。因此，你无法在 Java 代码中直接获取到它的对象，调用 <code>getClassLoader()</code> 得到的会是 <code>null</code>。</li>
<li><strong>父加载器</strong>：它没有父加载器。它是类加载器层次结构的顶端。</li>
</ul>
<h4 id="2-扩展类加载器-Extension-ClassLoader"><a href="#2-扩展类加载器-Extension-ClassLoader" class="headerlink" title="2. 扩展类加载器 (Extension ClassLoader)"></a><strong>2. 扩展类加载器 (Extension ClassLoader)</strong></h4><ul>
<li><strong>作用</strong>：它负责加载 JVM 扩展目录中的所有 jar 包，通常是 <code>JRE/lib/ext</code> 目录下的库。</li>
<li><strong>实现</strong>：它是由 Java 语言实现的。</li>
<li><strong>父加载器</strong>：它的父加载器是<strong>启动类加载器</strong>。</li>
</ul>
<h4 id="3-应用程序类加载器-Application-ClassLoader"><a href="#3-应用程序类加载器-Application-ClassLoader" class="headerlink" title="3. 应用程序类加载器 (Application ClassLoader)"></a><strong>3. 应用程序类加载器 (Application ClassLoader)</strong></h4><ul>
<li><strong>作用</strong>：它负责加载我们自己编写的 Java 程序中的类，也就是你项目中 <code>classpath</code> 路径下的所有类。</li>
<li><strong>实现</strong>：它也是由 Java 语言实现的。</li>
<li><strong>父加载器</strong>：它的父加载器是<strong>扩展类加载器</strong>。</li>
</ul>
<hr>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h3><p>除了上面三个，你也可以根据自己的需求创建<strong>自定义类加载器</strong>。</p>
<ul>
<li><strong>作用</strong>：当你需要加载一些特定来源的类时（比如从网络下载的类、对字节码进行加密或解密），自定义类加载器就很有用。例如，Web 服务器（如 Tomcat）就是通过自定义类加载器来隔离不同 Web 应用的类。</li>
<li><strong>如何实现</strong>：通常，你需要继承 <code>java.lang.ClassLoader</code> 类，并重写 <code>findClass()</code> 方法。在 <code>findClass()</code> 方法中，你需要自己定义如何获取类的字节码（比如从文件系统、网络或数据库），然后调用 <code>defineClass()</code> 方法将字节码转换为 <code>Class</code> 对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="33-有哪些类加载器？分别有什么作用？"><a href="#33-有哪些类加载器？分别有什么作用？" class="headerlink" title="33. 有哪些类加载器？分别有什么作用？"></a>33. 有哪些类加载器？分别有什么作用？</h3><ol>
<li><strong>启动类加载器 (Bootstrap ClassLoader)</strong>：这个类加载器是由 C++ 语言实现的，是虚拟机自身的一部分。负责将存在 <code>\lib</code> 目录中的，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中的类库加载到虚拟机内存中。启动内加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 <code>null</code> 即可；</li>
<li><strong>其他类加载器</strong>：由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。如扩展类加载器和应用程序类加载器：<ul>
<li><strong>扩展类加载器 (Extension ClassLoader)</strong>：这个类加载器由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现，它负责加载<code>\lib\ext</code>目录中的，或者被 <code>java.ext.dirs</code> 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器 (Application ClassLoader)</strong>：这个类加载器由 <code>sun.misc.Launcher$AppClassLoder</code> 实现。由于个类加载器是 <code>ClassLoader</code> 中的 <code>getSystemClassLoader()</code> 方法的返回值，所以一般也称之为系统类加载器。它负责加载用户路径（ClassPath）所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>双亲委派模型 (Parents Delegation Model)</strong>:  </p>
<ul>
<li><strong>原理</strong>: 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。  </li>
<li><strong>优点</strong>: 避免类的重复加载，保证 Java 核心库的类型安全。</li>
</ul>
</li>
</ul>
<h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><p>为什么需要四个类加载器，而不是一个？</p>
<p>这是一个很好的问题。为什么 Java 要设计多个类加载器，而不是用一个大一统的加载器呢？这背后主要有三个核心原因：<strong>隔离性</strong>、<strong>安全性</strong>和<strong>可扩展性</strong>。</p>
<hr>
<h3 id="1-隔离性（Isolation）"><a href="#1-隔离性（Isolation）" class="headerlink" title="1. 隔离性（Isolation）"></a>1. 隔离性（Isolation）</h3><p>多类加载器的最大优势就是实现了<strong>类隔离</strong>。</p>
<p>想象一下，你有一个 Web 服务器，上面部署了两个不同的 Web 应用（比如一个博客系统和一个论坛）。这两个应用可能依赖同一个第三方库的不同版本（例如，博客用的是 Spring 框架的 5.x 版本，而论坛用的是 4.x 版本）。</p>
<p>如果只有一个类加载器，它会把所有 <code>classpath</code> 上的类都加载到同一个内存空间。这样一来，两个不同版本的 Spring 框架就会产生冲突，JVM 根本无法区分它们，程序就会报错。</p>
<p>而有了自定义类加载器，服务器就可以为每个 Web 应用创建一个独立的类加载器。每个加载器负责加载自己应用目录下的类，这样两个应用即使使用了同一个库的不同版本，也能在内存中和谐共存，互不干扰。</p>
<hr>
<h3 id="2-安全性（Security）"><a href="#2-安全性（Security）" class="headerlink" title="2. 安全性（Security）"></a>2. 安全性（Security）</h3><p>Java 的核心库（如 <code>java.lang</code>, <code>java.util</code> 等）对 JVM 的稳定和安全至关重要。</p>
<p><strong>双亲委派模型</strong>正是为了保护这些核心库不被恶意代码或普通用户代码所篡改。</p>
<p>例如，如果你尝试自己写一个 <code>java.lang.String</code> 类并把它放在应用的 <code>classpath</code> 下，双亲委派机制会确保这个类不会被加载。因为当加载请求到达应用程序类加载器时，它会先委派给它的父加载器——扩展类加载器，然后再委派给最顶层的<strong>启动类加载器</strong>。启动类加载器会优先加载 JDK 自带的 <code>java.lang.String</code>，从而你的恶意代码就永远没有机会被执行。</p>
<hr>
<h3 id="3-可扩展性（Extensibility）"><a href="#3-可扩展性（Extensibility）" class="headerlink" title="3. 可扩展性（Extensibility）"></a>3. 可扩展性（Extensibility）</h3><p>Java 是一种非常灵活的语言，需要适应各种复杂的运行时环境。</p>
<p>如果只有一个类加载器，所有的类都必须来自文件系统。但在现实世界中，类可能来自各种地方：</p>
<ul>
<li>从网络上下载的字节码。</li>
<li>通过数据库存储和加载。</li>
<li>对字节码进行加密和解密。</li>
</ul>
<p>自定义类加载器让 Java 能够<strong>动态地加载</strong>和<strong>处理非标准来源的类</strong>。例如，热部署技术（在不重启应用的情况下更新代码）就是通过自定义类加载器实现的。它会创建一个新的加载器来加载新版本的类，而旧的加载器和它的类则可以被垃圾回收。</p>
<hr>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>所以，一个大一统的类加载器虽然简单，但它无法解决复杂的<strong>类版本冲突</strong>、<strong>核心库安全</strong>和<strong>动态加载</strong>等问题。通过分层设计和双亲委派模型，Java 的类加载器体系变得既安全又灵活，能够满足从简单的桌面应用到复杂的企业级服务器等各种场景的需求。</p>
<h2 id="常见的-OOM-OutOfMemoryError-和-StackOverflowError"><a href="#常见的-OOM-OutOfMemoryError-和-StackOverflowError" class="headerlink" title="常见的 OOM (OutOfMemoryError) 和 StackOverflowError"></a>常见的 OOM (OutOfMemoryError) 和 StackOverflowError</h2><ul>
<li><strong>Java heap space</strong>: 堆内存不足，最常见。通常通过调整 JVM 启动参数 <code>-Xms</code> (初始堆大小) 和 <code>-Xmx</code> (最大堆大小) 来解决。  </li>
<li><strong>StackOverflowError</strong>: 虚拟机栈溢出。通常是递归调用过深导致栈帧不断入栈。  </li>
<li><strong>PermGen space &#x2F; Metaspace</strong>: 方法区溢出。通常是加载的类过多，或者存在大量字符串常量。通过 <code>-XX:MaxPermSize</code> (JDK 1.7) 或 <code>-XX:MaxMetaspaceSize</code> (JDK 1.8) 调整。  </li>
<li><strong>Direct buffer memory</strong>: 直接内存溢出。通常是使用了 NIO 或 Netty 等直接操作堆外内存的库。  </li>
<li><strong>unable to create new native thread</strong>: 无法创建新线程。通常是系统线程数达到上限或内存不足以分配新线程的栈空间。</li>
</ul>
<h2 id="OOM常见场景："><a href="#OOM常见场景：" class="headerlink" title="OOM常见场景："></a>OOM常见场景：</h2><hr>
<h3 id="1-java-lang-OutOfMemoryError-Java-heap-space"><a href="#1-java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="1. java.lang.OutOfMemoryError: Java heap space"></a><strong>1. java.lang.OutOfMemoryError: Java heap space</strong></h3><p>这是最常见、也最广为人知的内存溢出错误。它表示 <strong>Java 堆（Heap）</strong> 中没有足够的空间来分配新的对象。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong>内存泄漏（Memory Leak）</strong>：这是最主要的原因。你的程序中创建了对象，但本应被垃圾回收器（GC）回收的对象却因为某些原因（比如被一个长生命周期的对象引用着）而无法被回收。例如：<ul>
<li>一个静态的 <code>Map</code> 或 <code>List</code> 集合，不断地往里面添加对象，但从不删除。</li>
<li>监听器或回调函数没有正确移除，导致被监听的对象无法被回收。</li>
<li>数据库连接或文件流没有正确关闭，长时间占用资源。</li>
</ul>
</li>
<li><strong>内存使用不当</strong>：一次性加载大量数据到内存中。例如，从数据库查询数百万条记录，并把它们全部加载到一个 <code>List</code> 中；或者处理一个超大的图片或文件，导致瞬间占用大量内存。</li>
<li><strong>配置问题</strong>：JVM 的堆内存设置得太小，无法满足程序的正常运行需求。这在部署应用时很常见，可以通过调整 <code>-Xmx</code> 参数来解决。</li>
</ul>
<hr>
<h3 id="2-java-lang-StackOverflowError"><a href="#2-java-lang-StackOverflowError" class="headerlink" title="2. java.lang.StackOverflowError"></a><strong>2. java.lang.StackOverflowError</strong></h3><p>这个错误表示 <strong>虚拟机栈（Stack）</strong> 溢出。每个线程都有一个独立的栈，用于存储方法调用的栈帧。当栈的深度超过了 JVM 允许的最大深度时，就会抛出此错误。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><p><strong>无限递归（Infinite Recursion）</strong>：这是最典型的场景。一个方法不断地调用自身，且没有正确的退出条件。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursiveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 没有退出条件</span></span><br><span class="line">    recursiveMethod(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子是两个方法互相调用，形成循环：A 调用 B，B 又调用 A。</p>
</li>
<li><p><strong>递归调用层级过深</strong>：即使递归有正确的退出条件，如果数据量过大，导致递归调用层级非常深，也可能导致栈溢出。例如，处理一个深度非常大的树形结构。</p>
</li>
</ul>
<hr>
<h3 id="3-java-lang-OutOfMemoryError-PermGen-space-或-Metaspace"><a href="#3-java-lang-OutOfMemoryError-PermGen-space-或-Metaspace" class="headerlink" title="3. java.lang.OutOfMemoryError: PermGen space 或 Metaspace"></a><strong>3. java.lang.OutOfMemoryError: PermGen space 或 Metaspace</strong></h3><p>这个错误发生在 <strong>方法区</strong> 溢出。方法区用于存储类的元数据信息，如类的结构、字段、方法、常量池等。</p>
<ul>
<li><strong>JDK 1.7 及之前</strong>：方法区在堆中，被称为<strong>永久代（PermGen）</strong>。溢出错误为 <code>PermGen space</code>。</li>
<li><strong>JDK 1.8 及之后</strong>：永久代被移除，方法区改为使用<strong>元空间（Metaspace）</strong>，并且默认使用本地内存。溢出错误为 <code>Metaspace</code>。</li>
</ul>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong>动态生成大量类</strong>：在运行时生成大量新的类。这在一些使用字节码增强技术的框架（如 CGLib）或动态代理的场景中很常见。</li>
<li><strong>热部署</strong>：在像 Tomcat 这样的 Web 服务器中进行频繁的热部署操作，如果没有正确清理旧的类加载器，会导致旧的类元数据无法被回收，从而逐渐耗尽方法区内存。</li>
<li><strong>常量池溢出</strong>：在 JDK 1.7 之前，字符串常量池也在永久代中。如果程序创建了大量不同的字符串（例如在循环中不断生成新的字符串），也可能导致永久代溢出。</li>
</ul>
<hr>
<h3 id="4-java-lang-OutOfMemoryError-Direct-buffer-memory"><a href="#4-java-lang-OutOfMemoryError-Direct-buffer-memory" class="headerlink" title="4. java.lang.OutOfMemoryError: Direct buffer memory"></a><strong>4. java.lang.OutOfMemoryError: Direct buffer memory</strong></h3><p>这个错误与 <strong>直接内存（Direct Memory）</strong> 相关，它不是 Java 堆的一部分，而是通过 <code>ByteBuffer.allocateDirect()</code> 在堆外分配的内存。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong>NIO 和网络编程</strong>：在使用 Java NIO、Netty、或者其他依赖堆外内存的库时，如果频繁地分配直接内存但没有及时释放，就可能导致此错误。</li>
<li><strong>内存泄漏</strong>：直接内存的回收不像堆内存那样由 GC 自动管理。如果程序中没有调用 <code>ByteBuffer</code> 的 <code>cleaner()</code> 方法，或者在没有关闭资源的情况下直接内存泄漏，就会耗尽系统的直接内存。</li>
</ul>
<hr>
<h3 id="5-java-lang-OutOfMemoryError-unable-to-create-new-native-thread"><a href="#5-java-lang-OutOfMemoryError-unable-to-create-new-native-thread" class="headerlink" title="5. java.lang.OutOfMemoryError: unable to create new native thread"></a><strong>5. java.lang.OutOfMemoryError: unable to create new native thread</strong></h3><p>这个错误通常不是因为 Java 堆内存不足，而是因为<strong>系统资源耗尽</strong>。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong>线程创建过多</strong>：程序中创建了大量的线程，导致系统无法为新的线程分配内存空间。每个线程除了 Java 堆中的栈空间外，还需要分配一些本地内存。</li>
<li><strong>系统限制</strong>：操作系统对单个进程创建的线程数有限制。如果达到了这个上限，JVM 就会抛出此错误。在 Linux 系统中，你可以通过 <code>ulimit -u</code> 命令查看这个限制。</li>
<li><strong>内存不足</strong>：系统内存（包括堆外内存）已经所剩无几，JVM 无法为新的线程栈分配足够的内存。</li>
</ul>
<h3 id="面试题：-1"><a href="#面试题：-1" class="headerlink" title="面试题："></a>面试题：</h3><h3 id="1-简述-Java-堆内存溢出（Java-heap-space）的原因及解决方案。"><a href="#1-简述-Java-堆内存溢出（Java-heap-space）的原因及解决方案。" class="headerlink" title="1. 简述 Java 堆内存溢出（Java heap space）的原因及解决方案。"></a>1. 简述 Java 堆内存溢出（Java heap space）的原因及解决方案。</h3><p><strong>原因：</strong> 最主要的原因是<strong>内存泄漏</strong>，即 GC 无法回收本应被回收的对象。其他常见原因包括：</p>
<ul>
<li><strong>内存使用不当</strong>：一次性加载大量数据到内存中，如从数据库查询海量数据。</li>
<li><strong>配置不当</strong>：JVM 启动参数 <code>-Xmx</code> 设置过小，无法满足应用需求。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li><strong>分析和定位问题</strong>：使用 <code>jmap</code>、<code>jstat</code>、<code>jstack</code> 等 JDK 自带工具或者 <code>Eclipse MAT</code> 等可视化工具分析内存快照（<code>heap dump</code>），找到占用内存最多的对象，并分析是否存在内存泄漏。</li>
<li><strong>代码层面优化</strong>：<ul>
<li>检查并解决内存泄漏问题，比如移除不再需要的静态集合引用。</li>
<li>优化大批量数据处理逻辑，采用分批、分页处理或流式处理，避免一次性加载所有数据。</li>
<li>及时释放不再使用的资源，如关闭数据库连接、文件流等。</li>
</ul>
</li>
<li><strong>JVM 参数调整</strong>：如果确认没有内存泄漏，只是应用确实需要更多内存，可以适当增大 <code>-Xmx</code> 和 <code>-Xms</code> 参数。</li>
</ul>
<hr>
<h3 id="2-什么是-StackOverflowError？它和-OOM-有什么区别？"><a href="#2-什么是-StackOverflowError？它和-OOM-有什么区别？" class="headerlink" title="2. 什么是 StackOverflowError？它和 OOM 有什么区别？"></a>2. 什么是 StackOverflowError？它和 OOM 有什么区别？</h3><p><strong>StackOverflowError</strong> 表示<strong>虚拟机栈</strong>溢出，通常是由于<strong>无限递归</strong>或<strong>递归调用层级过深</strong>导致栈帧不断入栈而耗尽了栈空间。</p>
<p><strong>与 OOM 的区别：</strong></p>
<ul>
<li><strong>发生位置不同</strong>：<code>StackOverflowError</code> 发生在<strong>虚拟机栈</strong>，而 <code>OutOfMemoryError</code> 发生在<strong>堆</strong>或<strong>方法区</strong>等其他内存区域。</li>
<li><strong>原因不同</strong>：<code>StackOverflowError</code> 通常是由于<strong>代码逻辑问题</strong>（如无限递归）导致，与程序处理的数据量大小关系不大（除非递归深度过深）。而 <code>OOM</code> 往往与<strong>程序处理的数据量</strong>、<strong>JVM 内存配置</strong>或<strong>内存泄漏</strong>有关。</li>
<li><strong>解决方式不同</strong>：解决 <code>StackOverflowError</code> 主要需要<strong>修改代码</strong>，比如增加递归的退出条件或采用非递归（迭代）方式重构。而解决 <code>OOM</code> 则需要<strong>定位内存泄漏</strong>、<strong>优化代码</strong>或<strong>调整 JVM 内存参数</strong>。</li>
</ul>
<hr>
<h3 id="3-JDK-8-中-PermGen-space-溢出错误为什么变成了-Metaspace？"><a href="#3-JDK-8-中-PermGen-space-溢出错误为什么变成了-Metaspace？" class="headerlink" title="3. JDK 8 中 PermGen space 溢出错误为什么变成了 Metaspace？"></a>3. JDK 8 中 PermGen space 溢出错误为什么变成了 Metaspace？</h3><ul>
<li><strong>JDK 1.7 及之前</strong>：方法区被实现为<strong>永久代（PermGen）</strong>，它属于<strong>堆内存的一部分</strong>。因此，它的空间大小受限于 JVM 堆内存的设置，容易发生 <code>PermGen space</code> 溢出。</li>
<li><strong>JDK 1.8 及之后</strong>：<strong>永久代被移除</strong>，方法区改为<strong>元空间（Metaspace）</strong>。元空间<strong>不在 JVM 堆中</strong>，而是直接使用<strong>本地内存</strong>（Native Memory）。</li>
</ul>
<p><strong>变化的好处：</strong></p>
<ul>
<li><strong>减少 OOM 可能性</strong>：元空间使用本地内存，其大小只受限于系统可用内存，默认情况下比永久代大得多，从而降低了因方法区过小而引发 OOM 的风险。</li>
<li><strong>避免 GC 负担</strong>：永久代需要由 GC 进行垃圾回收，而元空间则通过 <code>class loader</code> 引用来管理，当对应的 <code>class loader</code> 被回收时，其加载的类元数据也会被回收。</li>
<li><strong>更灵活</strong>：元空间的大小可以通过参数 <code>-XX:MaxMetaspaceSize</code> 来设置上限，如果该参数不设置，元空间会根据需要自动扩容。</li>
</ul>
<hr>
<h3 id="4-除了-Java-堆，还有哪些内存区域可能发生-OOM？如何解决？"><a href="#4-除了-Java-堆，还有哪些内存区域可能发生-OOM？如何解决？" class="headerlink" title="4. 除了 Java 堆，还有哪些内存区域可能发生 OOM？如何解决？"></a>4. 除了 Java 堆，还有哪些内存区域可能发生 OOM？如何解决？</h3><ul>
<li><strong>直接内存（Direct buffer memory）</strong>：<ul>
<li><strong>原因</strong>：通常是使用 NIO 或 Netty 等框架时，频繁分配堆外内存但没有及时释放。</li>
<li><strong>解决</strong>：检查代码中堆外内存的使用，确保在不再需要时通过 <code>Buffer.cleaner()</code> 或资源关闭操作来显式释放内存。</li>
</ul>
</li>
<li><strong>无法创建新线程（unable to create new native thread）</strong>：<ul>
<li><strong>原因</strong>：<ol>
<li>程序创建了<strong>过多线程</strong>，耗尽了操作系统对单个进程的线程数限制。</li>
<li>系统<strong>内存不足</strong>，无法为新线程分配栈空间。</li>
</ol>
</li>
<li><strong>解决</strong>：<ol>
<li><strong>代码优化</strong>：检查业务逻辑，看是否可以减少线程创建数量，或者使用线程池来复用线程。</li>
<li><strong>系统配置</strong>：<ul>
<li>在 Linux 系统中，使用 <code>ulimit -u</code> 增加线程数限制。</li>
<li>检查系统内存，确保有足够的内存空间。</li>
</ul>
</li>
<li><strong>JVM 参数调整</strong>：如果线程确实需要，可以适当减小线程栈的大小（<code>-Xss</code>）来允许创建更多线程，但需要注意防止 StackOverflowError。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="Java框架核心知识详解"><a href="#Java框架核心知识详解" class="headerlink" title="Java框架核心知识详解"></a>Java框架核心知识详解</h1><h2 id="一、Spring框架深入解析"><a href="#一、Spring框架深入解析" class="headerlink" title="一、Spring框架深入解析"></a>一、Spring框架深入解析</h2><h3 id="1-1-Spring核心概念与原理"><a href="#1-1-Spring核心概念与原理" class="headerlink" title="1.1 Spring核心概念与原理"></a>1.1 Spring核心概念与原理</h3><p>Spring框架是一个分层的企业级应用开发框架，其核心是控制反转（IoC）和面向切面编程（AOP）。</p>
<h4 id="IoC容器原理深入分析"><a href="#IoC容器原理深入分析" class="headerlink" title="IoC容器原理深入分析"></a>IoC容器原理深入分析</h4><p><strong>IoC（控制反转）的本质：</strong> 传统开发中，对象的创建和依赖关系由程序代码直接控制，而IoC将这个控制权交给了外部容器。Spring通过依赖注入（DI）来实现IoC。</p>
<p><strong>IoC容器的实现机制：</strong></p>
<ol>
<li><strong>BeanFactory</strong>: 基础容器，提供基本的IoC功能</li>
<li><strong>ApplicationContext</strong>: 高级容器，继承BeanFactory，提供更多企业级功能</li>
</ol>
<p>好的，我们把 <strong>Spring IoC容器的实现机制</strong> 展开讲清楚，从 <strong>BeanFactory</strong> 到 <strong>ApplicationContext</strong> 的层次演进，以及它们在底层是如何运作的。</p>
<hr>
<h1 id="IoC-容器实现机制"><a href="#IoC-容器实现机制" class="headerlink" title="IoC 容器实现机制"></a>IoC 容器实现机制</h1><h2 id="1-BeanFactory-——-基础-IoC-容器"><a href="#1-BeanFactory-——-基础-IoC-容器" class="headerlink" title="1. BeanFactory —— 基础 IoC 容器"></a>1. BeanFactory —— 基础 IoC 容器</h2><p><code>BeanFactory</code> 是 Spring IoC 的最底层容器接口，定义了 <strong>获取 Bean 的基本规则</strong>。</p>
<h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><ul>
<li><strong>懒加载（Lazy loading）</strong><ul>
<li>只有在调用 <code>getBean()</code> 时，才会去实例化 Bean。</li>
<li>避免启动时消耗过多资源。</li>
</ul>
</li>
<li><strong>最小依赖</strong><ul>
<li>只提供 IoC 的基础功能：<ul>
<li>Bean 的定义（BeanDefinition）管理</li>
<li>Bean 的生命周期（创建、依赖注入、销毁）</li>
<li>Bean 的作用域（singleton &#x2F; prototype）</li>
</ul>
</li>
</ul>
</li>
<li><strong>轻量级</strong><ul>
<li>更适合资源受限环境，比如 IoT、移动设备，或 Spring 的底层框架内部。</li>
</ul>
</li>
</ul>
<h3 id="核心实现机制"><a href="#核心实现机制" class="headerlink" title="核心实现机制"></a>核心实现机制</h3><ol>
<li><strong>读取 BeanDefinition</strong><ul>
<li>配置文件(XML)、注解(@Component)、Java Config( @Bean ) → 转换成 <strong>BeanDefinition</strong> 对象。</li>
<li>BeanDefinition 是 Bean 的抽象描述，包括：<ul>
<li>Bean 的 class 类型</li>
<li>是否单例 &#x2F; 原型</li>
<li>是否懒加载</li>
<li>构造参数 &#x2F; 依赖属性</li>
</ul>
</li>
</ul>
</li>
<li><strong>存储 BeanDefinition</strong><ul>
<li>存入 <strong>BeanDefinitionRegistry</strong>（通常是 Map 结构）。</li>
</ul>
</li>
<li><strong>按需实例化 Bean</strong><ul>
<li>调用 <code>getBean(name)</code> → 根据 BeanDefinition 反射创建实例。</li>
<li>进行依赖注入（构造器注入 &#x2F; setter 注入）。</li>
</ul>
</li>
<li><strong>Bean 生命周期管理</strong><ul>
<li>初始化前回调（BeanPostProcessor → <code>postProcessBeforeInitialization</code>）</li>
<li>调用初始化方法（<code>InitializingBean</code> 或 <code>@PostConstruct</code>）</li>
<li>初始化后回调（BeanPostProcessor → <code>postProcessAfterInitialization</code>）</li>
<li>销毁前回调（<code>DisposableBean</code> 或 <code>@PreDestroy</code>）</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-ApplicationContext-——-高级-IoC-容器"><a href="#2-ApplicationContext-——-高级-IoC-容器" class="headerlink" title="2. ApplicationContext —— 高级 IoC 容器"></a>2. ApplicationContext —— 高级 IoC 容器</h2><p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口，扩展了很多 <strong>企业级特性</strong>，是我们在项目中最常用的容器。</p>
<h3 id="核心特性（对比-BeanFactory）"><a href="#核心特性（对比-BeanFactory）" class="headerlink" title="核心特性（对比 BeanFactory）"></a>核心特性（对比 BeanFactory）</h3><ol>
<li><strong>预实例化（Eager loading）</strong><ul>
<li>默认在容器启动时，就会实例化所有单例 Bean。</li>
<li>启动时性能开销更大，但运行时性能更好。</li>
</ul>
</li>
<li><strong>国际化（I18N）支持</strong><ul>
<li>通过 <code>MessageSource</code> 接口，支持不同语言的消息解析。</li>
</ul>
</li>
<li><strong>事件机制（ApplicationEvent）</strong><ul>
<li>内置事件发布 &#x2F; 监听机制（观察者模式）。</li>
<li>开发者可以自定义事件，实现应用内解耦。</li>
</ul>
</li>
<li><strong>资源加载</strong><ul>
<li>统一的 <code>Resource</code> 抽象，可以加载文件、URL、classpath 下的资源。</li>
</ul>
</li>
<li><strong>与 AOP、事务管理集成</strong><ul>
<li>自动识别 BeanPostProcessor、BeanFactoryPostProcessor，用于扩展 Bean 生命周期逻辑（例如事务代理、AOP 动态代理）。</li>
</ul>
</li>
<li><strong>Profile 环境支持</strong><ul>
<li>支持多环境配置（开发、测试、生产），通过 <code>@Profile</code> 注解切换。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-BeanFactory-vs-ApplicationContext-总结"><a href="#3-BeanFactory-vs-ApplicationContext-总结" class="headerlink" title="3. BeanFactory vs ApplicationContext 总结"></a>3. BeanFactory vs ApplicationContext 总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th><strong>BeanFactory</strong></th>
<th><strong>ApplicationContext</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bean 加载时机</strong></td>
<td>懒加载（按需创建）</td>
<td>预实例化（启动时创建单例 Bean）</td>
</tr>
<tr>
<td><strong>国际化支持</strong></td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><strong>事件机制</strong></td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><strong>AOP &#x2F; 事务</strong></td>
<td>手动注册 BeanPostProcessor</td>
<td>自动识别并应用</td>
</tr>
<tr>
<td><strong>资源加载</strong></td>
<td>基础 API</td>
<td>更强大的 Resource 抽象</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>轻量应用、底层容器</td>
<td>企业级应用，大部分 Spring 项目</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-常见-ApplicationContext-实现类"><a href="#4-常见-ApplicationContext-实现类" class="headerlink" title="4. 常见 ApplicationContext 实现类"></a>4. 常见 ApplicationContext 实现类</h2><ul>
<li><strong>ClassPathXmlApplicationContext</strong><ul>
<li>从 classpath 下的 XML 加载配置。</li>
</ul>
</li>
<li><strong>FileSystemXmlApplicationContext</strong><ul>
<li>从文件系统路径下加载 XML 配置。</li>
</ul>
</li>
<li><strong>AnnotationConfigApplicationContext</strong><ul>
<li>基于注解和 Java Config 的容器。</li>
</ul>
</li>
<li><strong>WebApplicationContext</strong><ul>
<li>专门为 Web 应用准备的 IoC 容器，整合 ServletContext。</li>
</ul>
</li>
</ul>
<hr>
<p>👉 可以这样理解：</p>
<ul>
<li><code>BeanFactory</code> 就是 IoC 的“发动机”，提供最基本的动力。</li>
<li><code>ApplicationContext</code> 就是加了“变速箱、车载娱乐系统、空调、智能导航”的完整汽车，更适合实际企业应用。</li>
</ul>
<p><strong>Bean的生命周期详解：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例化 → 属性赋值 → 初始化前处理 → 初始化 → 初始化后处理 → 使用 → 销毁前处理 → 销毁</span><br></pre></td></tr></table></figure>

<p><strong>详细生命周期步骤：</strong></p>
<ol>
<li>Bean元数据解析（XML、注解、Java配置）</li>
<li>调用Bean构造函数实例化</li>
<li>依赖注入（setter方法、构造函数、字段注入）</li>
<li>如果实现了BeanNameAware，调用setBeanName()</li>
<li>如果实现了BeanFactoryAware，调用setBeanFactory()</li>
<li>如果实现了ApplicationContextAware，调用setApplicationContext()</li>
<li>如果有BeanPostProcessor，调用postProcessBeforeInitialization()</li>
<li>如果实现了InitializingBean，调用afterPropertiesSet()</li>
<li>如果配置了init-method，调用自定义初始化方法</li>
<li>如果有BeanPostProcessor，调用postProcessAfterInitialization()</li>
<li>Bean可以被使用</li>
<li>容器关闭时，如果实现了DisposableBean，调用destroy()</li>
<li>如果配置了destroy-method，调用自定义销毁方法</li>
</ol>
<h4 id="DI的三种注入方式对比"><a href="#DI的三种注入方式对比" class="headerlink" title="DI的三种注入方式对比"></a>DI的三种注入方式对比</h4><ul>
<li><strong>构造器注入（Constructor Injection）</strong><ul>
<li><strong>优点</strong>：强制依赖、依赖清晰、不可变性</li>
<li><strong>缺点</strong>：当依赖项过多时构造函数臃肿</li>
<li><strong>最佳实践</strong>：官方推荐，特别是当依赖是必需的、不可选的时候</li>
</ul>
</li>
<li><strong>Setter注入（Setter Injection）</strong><ul>
<li><strong>优点</strong>：可选依赖，灵活性高</li>
<li><strong>缺点</strong>：对象可能处于不完整状态，无法使用final修饰</li>
<li><strong>最佳实践</strong>：用于注入可选的依赖项</li>
</ul>
</li>
<li><strong>字段注入（Field Injection）</strong><ul>
<li><strong>优点</strong>：代码简洁</li>
<li><strong>缺点</strong>：不推荐使用，隐藏依赖、测试困难、无法使用final修饰</li>
</ul>
</li>
</ul>
<h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><p>在传统的 Java 应用中，Bean 的生命周期很简单：使用 <code>new</code> 关键字进行实例化，然后 Bean 就能被使用，不再使用时，由 Java 自动进行垃圾回收。</p>
<p>相比之下，Spring 管理 Bean 的生命周期就复杂多了，正确理解 Bean 的生命周期非常重要，因为 Spring 对 Bean 的管理可扩展性非常强。以下是一个 Bean 的构造过程：</p>
<ol>
<li><strong>Spring 启动</strong>：查找并加载需要被 Spring 管理的 Bean，进行 Bean 的实例化。</li>
<li><strong>属性注入</strong>：对 Bean 的引用和值注入到 Bean 的属性中。</li>
<li><strong>BeanNameAware 接口</strong>：如果 Bean 实现了 <code>BeanNameAware</code> 接口，Spring 将 Bean 的 Id 传递给 <code>setBeanName()</code> 方法。</li>
<li><strong>BeanFactoryAware 接口</strong>：如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，Spring 将调用 <code>setBeanFactory()</code> 方法，将 <code>BeanFactory</code> 容器实例传入。</li>
<li><strong>ApplicationContextAware 接口</strong>：如果 Bean 实现了 <code>ApplicationContextAware</code> 接口，Spring 将调用 Bean 的 <code>setApplicationContext()</code> 方法，将 Bean 所在的应用上下文引用传入。</li>
<li><strong>BeanPostProcessor (前)</strong>：如果 Bean 实现了 <code>BeanPostProcessor</code> 接口，Spring 将调用它们的 <code>postProcessBeforeInitialization()</code> 方法。</li>
<li><strong>InitializingBean 接口与 init-method</strong>：<ul>
<li>如果 Bean 实现了 <code>InitializingBean</code> 接口，Spring 将调用它们的 <code>afterPropertiesSet()</code> 方法。</li>
<li>如果 Bean 使用 <code>init-method</code> 声明了初始化方法，该方法也会被调用。</li>
</ul>
</li>
<li><strong>BeanPostProcessor (后)</strong>：如果 Bean 实现了 <code>BeanPostProcessor</code> 接口，Spring 将调用它们的 <code>postProcessAfterInitialization()</code> 方法。</li>
<li><strong>Bean 准备就绪</strong>：此时，Bean 已经准备就绪，可以被应用程序使用。它们将一直驻留在应用上下文中，直到应用上下文被销毁。</li>
<li><strong>销毁</strong>：<ul>
<li>如果 Bean 实现了 <code>DisposableBean</code> 接口，Spring 将调用它的 <code>destory()</code> 接口方法。</li>
<li>如果 Bean 使用 <code>destory-method</code> 声明了销毁方法，该方法也会被调用。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h3><ol>
<li><strong>singleton</strong>：唯一的 Bean 实例，Spring 中的 Bean 默认都是单例的。</li>
<li><strong>prototype</strong>：每次请求都会创建一个新的 Bean 实例。</li>
<li><strong>request</strong>：每一次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong>：每一次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP session 内有效。</li>
<li><strong>global-session</strong>：全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring 5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>
</ol>
<hr>
<h3 id="Spring-中的单例-Bean-的线程安全问题"><a href="#Spring-中的单例-Bean-的线程安全问题" class="headerlink" title="Spring 中的单例 Bean 的线程安全问题"></a>Spring 中的单例 Bean 的线程安全问题</h3><p>大多数时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为：当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。常见的有两种解决办法：</p>
<ol>
<li>在 Bean 对象中尽量避免定义可变的成员变量（不太现实）。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
</ol>
<hr>
<h3 id="对-Spring-中的事务的理解"><a href="#对-Spring-中的事务的理解" class="headerlink" title="对 Spring 中的事务的理解"></a>对 Spring 中的事务的理解</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p><strong>事务特性</strong></p>
<ul>
<li><strong>原子性</strong>：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。</li>
<li><strong>一致性</strong>：执行事务前后，数据保持一致。</li>
<li><strong>隔离性</strong>：并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的。</li>
<li><strong>持久性</strong>：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<p><strong>Spring 事务管理接口</strong></p>
<ol>
<li><code>PlatformTransactionManager</code>：（平台）事务管理器。</li>
<li><code>TransactionDefinition</code>：事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）。</li>
<li><code>TransactionStatus</code>：事务运行状态。</li>
</ol>
<p>所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。</p>
<hr>
<h3 id="Spring-中的事务隔离级别"><a href="#Spring-中的事务隔离级别" class="headerlink" title="Spring 中的事务隔离级别"></a>Spring 中的事务隔离级别</h3><p><code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT</strong>：使用后端数据库默认的隔离级别。MySQL 默认采用 <code>REPEATABLE_READ</code> 隔离级别，Oracle 默认采用 <code>READ_COMMITTED</code> 隔离级别。</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</strong>：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED</strong>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ</strong>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE</strong>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<hr>
<h3 id="Spring-中的事物传播行为"><a href="#Spring-中的事物传播行为" class="headerlink" title="Spring 中的事物传播行为"></a>Spring 中的事物传播行为</h3><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在 <code>TransactionDefinition</code> 定义中包括了如下几个表示传播行为的常量：</p>
<p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW</strong>：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</strong>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER</strong>：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED</strong>：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 <code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</li>
</ul>
<hr>
<h3 id="Spring-常用注入方式"><a href="#Spring-常用注入方式" class="headerlink" title="Spring 常用注入方式"></a>Spring 常用注入方式</h3><ol>
<li><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</li>
<li><strong>Setter 方法注入</strong>：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂方法实例化 bean 之后，调用该 bean 的 Setter 方法，即实现了基于 Setter 的依赖注入。</li>
<li><strong>基于注解的注入</strong>：最好的解决方案是使用构造器参数实现强制依赖，Setter 方法实现可选依赖。</li>
</ol>
<hr>
<h3 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h3><ol>
<li><strong>工厂设计模式</strong>：Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong>：Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong>：Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong>：Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 <code>Template</code> 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong>：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式</strong>：Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong>：Spring AOP 的增强或通知（Advice）使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。</li>
</ol>
<hr>
<h3 id="ApplicationContext-通常的实现有哪些？"><a href="#ApplicationContext-通常的实现有哪些？" class="headerlink" title="ApplicationContext 通常的实现有哪些？"></a>ApplicationContext 通常的实现有哪些？</h3><ol>
<li><strong>FileSystemXmlApplicationContext</strong>：此容器从一个 XML 文件中加载 beans 的定义，XML Bean 配置文件&#96;的全路径名必须提供给它的构造函数。</li>
<li><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个 XML 文件中加载 beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。</li>
<li><strong>WebXmlApplicationContext</strong>：此容器加载一个 XML 文件，此文件定义了一个 Web 应用的所有 bean。</li>
</ol>
<h4 id="AOP原理深入分析"><a href="#AOP原理深入分析" class="headerlink" title="AOP原理深入分析"></a>AOP原理深入分析</h4><p><strong>AOP实现机制：</strong> Spring AOP基于代理模式实现，支持两种代理方式：</p>
<ol>
<li><strong>JDK动态代理</strong>: 针对实现了接口的类</li>
<li><strong>CGLIB代理</strong>: 针对没有实现接口的类</li>
</ol>
<p>我们来系统性地讲解一下 <strong>Spring AOP 的实现机制</strong>，包括：</p>
<ol>
<li>JDK 动态代理</li>
<li>CGLIB 动态代理</li>
<li>静态代理（对比说明）</li>
</ol>
<hr>
<h2 id="🌟-一、Spring-AOP-实现机制概述"><a href="#🌟-一、Spring-AOP-实现机制概述" class="headerlink" title="🌟 一、Spring AOP 实现机制概述"></a>🌟 一、Spring AOP 实现机制概述</h2><p>Spring AOP（面向切面编程）是基于 <strong>代理模式</strong> 实现的，它通过在目标方法执行前后织入逻辑（增强），实现横切关注点（如日志、安全、事务等）的分离。</p>
<blockquote>
<p>Spring AOP 仅支持方法级别的代理（即对方法进行增强），不支持字段、构造器等底层字节码增强（这要用 AspectJ）。</p>
</blockquote>
<hr>
<h2 id="🧩-二、Spring-AOP-的两种动态代理方式"><a href="#🧩-二、Spring-AOP-的两种动态代理方式" class="headerlink" title="🧩 二、Spring AOP 的两种动态代理方式"></a>🧩 二、Spring AOP 的两种动态代理方式</h2><h3 id="1️⃣-JDK-动态代理（基于接口）"><a href="#1️⃣-JDK-动态代理（基于接口）" class="headerlink" title="1️⃣ JDK 动态代理（基于接口）"></a>1️⃣ JDK 动态代理（基于接口）</h3><h4 id="✅-原理："><a href="#✅-原理：" class="headerlink" title="✅ 原理："></a>✅ 原理：</h4><ul>
<li>基于 Java 的 <code>java.lang.reflect.Proxy</code> 类实现。</li>
<li>必须要有接口，Spring 会为接口生成代理类。</li>
<li>代理类在运行时实现接口，并将调用委托给 InvocationHandler。</li>
</ul>
<h4 id="📦-示例："><a href="#📦-示例：" class="headerlink" title="📦 示例："></a>📦 示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring AOP 为 <code>UserService</code> 创建代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">    userService.getClass().getClassLoader(),</span><br><span class="line">    userService.getClass().getInterfaces(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="🎯-特点："><a href="#🎯-特点：" class="headerlink" title="🎯 特点："></a>🎯 特点：</h4><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>是否依赖接口</td>
<td>✅ 是</td>
</tr>
<tr>
<td>性能</td>
<td>较高（比 CGLIB 略快）</td>
</tr>
<tr>
<td>生成的代理类</td>
<td>实现接口</td>
</tr>
</tbody></table>
<hr>
<h3 id="2️⃣-CGLIB-动态代理（基于子类）"><a href="#2️⃣-CGLIB-动态代理（基于子类）" class="headerlink" title="2️⃣ CGLIB 动态代理（基于子类）"></a>2️⃣ CGLIB 动态代理（基于子类）</h3><h4 id="✅-原理：-1"><a href="#✅-原理：-1" class="headerlink" title="✅ 原理："></a>✅ 原理：</h4><ul>
<li>使用 CGLIB 库在运行时 <strong>生成目标类的子类</strong>，并重写其方法来实现增强。</li>
<li>适用于 <strong>没有接口</strong> 的类，或者想对类本身增强而非接口。</li>
</ul>
<h4 id="🧪-示例："><a href="#🧪-示例：" class="headerlink" title="🧪 示例："></a>🧪 示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 通过 CGLIB 生成子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">enhancer.setSuperclass(UserService.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) enhancer.create();</span><br></pre></td></tr></table></figure>

<h4 id="🎯-特点：-1"><a href="#🎯-特点：-1" class="headerlink" title="🎯 特点："></a>🎯 特点：</h4><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>是否依赖接口</td>
<td>❌ 否</td>
</tr>
<tr>
<td>是否可代理 final 类&#x2F;方法</td>
<td>❌ 否（final 无法被继承&#x2F;重写）</td>
</tr>
<tr>
<td>生成的代理类</td>
<td>子类</td>
</tr>
</tbody></table>
<hr>
<h2 id="🏗-三、静态代理（对比动态代理）"><a href="#🏗-三、静态代理（对比动态代理）" class="headerlink" title="🏗 三、静态代理（对比动态代理）"></a>🏗 三、静态代理（对比动态代理）</h2><h3 id="✅-原理：-2"><a href="#✅-原理：-2" class="headerlink" title="✅ 原理："></a>✅ 原理：</h3><ul>
<li>自己写一个代理类，<strong>实现相同接口</strong>，将方法调用委托给目标对象，并在调用前后手动添加增强逻辑。</li>
</ul>
<h4 id="🧪-示例：-1"><a href="#🧪-示例：-1" class="headerlink" title="🧪 示例："></a>🧪 示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">        target.addUser();</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="🎯-特点：-2"><a href="#🎯-特点：-2" class="headerlink" title="🎯 特点："></a>🎯 特点：</h4><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>是否自动生成</td>
<td>❌ 需手动编码</td>
</tr>
<tr>
<td>灵活性</td>
<td>差（每个类都要写一个代理类）</td>
</tr>
<tr>
<td>是否支持 AOP</td>
<td>❌ 无法动态织入多个切面</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔚-四、三者对比总结"><a href="#🔚-四、三者对比总结" class="headerlink" title="🔚 四、三者对比总结"></a>🔚 四、三者对比总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>静态代理</th>
<th>JDK 动态代理</th>
<th>CGLIB 动态代理</th>
</tr>
</thead>
<tbody><tr>
<td>是否依赖接口</td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>❌ 否</td>
</tr>
<tr>
<td>是否自动生成代理类</td>
<td>❌ 手动编写</td>
<td>✅ 运行时生成</td>
<td>✅ 运行时生成</td>
</tr>
<tr>
<td>是否可代理类</td>
<td>❌ 否（接口为主）</td>
<td>❌ 否（接口为主）</td>
<td>✅ 是（类的子类）</td>
</tr>
<tr>
<td>性能</td>
<td>一般</td>
<td>较高</td>
<td>略慢（但可接受）</td>
</tr>
<tr>
<td>是否支持 final 方法</td>
<td>✅</td>
<td>✅</td>
<td>❌ 否</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-Spring-如何选择代理方式？"><a href="#✅-Spring-如何选择代理方式？" class="headerlink" title="✅ Spring 如何选择代理方式？"></a>✅ Spring 如何选择代理方式？</h2><ul>
<li>默认使用 JDK 动态代理（如果目标类实现了接口）。</li>
<li>如果目标类没有接口，Spring 自动切换为 CGLIB。</li>
<li>可以强制使用 CGLIB：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br></pre></td></tr></table></figure>

<h5 id="AOP核心概念："><a href="#AOP核心概念：" class="headerlink" title="AOP核心概念："></a><strong>AOP核心概念：</strong></h5><ul>
<li><strong>切面（Aspect）</strong>: 横切关注点的模块化</li>
<li><strong>连接点（Joinpoint）</strong>: 程序执行中的特定点</li>
<li><strong>切点（Pointcut）</strong>: 连接点的集合</li>
<li><strong>通知（Advice）</strong>: 切面在特定连接点执行的代码</li>
<li><strong>目标对象（Target）</strong>: 被代理的对象</li>
<li><strong>代理对象（Proxy）</strong>: AOP框架创建的对象</li>
</ul>
<h5 id="AOP通知类型："><a href="#AOP通知类型：" class="headerlink" title="AOP通知类型："></a>AOP通知类型：</h5><p><strong>1. 前置通知（Before advice）</strong>：在某个连接点（JoinPoint）之前执行的通知，但它不能阻止连接点之前的执行。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:before&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p>
<p><strong>2. 后置通知（After advice）</strong>：当某个连接点退出时执行的通知，无论是正常返回还是异常退出。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:after&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p>
<p><strong>3. 返回后通知（After return advice）</strong>：在某个连接点正常完成后执行的通知，不包括抛出异常的情况。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:after-returning&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p>
<p><strong>4. 环绕通知（Around advice）</strong>：包围一个连接点的通知，类似于 Web 中 Servlet 规范中的 <code>Filter</code> 的 <code>doFilter</code> 方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:around&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p>
<p><strong>5. 抛出异常后通知（After throwing advice）</strong>：在方法抛出异常退出时执行的通知。在 <code>ApplicationContext</code> 中，可以使用 <code>&lt;aop:after-throwing&gt;</code> 元素在 <code>&lt;aop:aspect&gt;</code> 内部进行声明。</p>
<p><strong>JDK动态代理 vs. CGLIB动态代理</strong></p>
<ul>
<li><strong>JDK动态代理</strong>：<ul>
<li>基于接口实现</li>
<li>使用Proxy.newProxyInstance()创建代理</li>
<li>只能代理实现了接口的类</li>
</ul>
</li>
<li><strong>CGLIB动态代理</strong>：<ul>
<li>基于继承实现</li>
<li>使用Enhancer类创建代理</li>
<li>可以代理普通类</li>
<li>不能代理final类和方法</li>
</ul>
</li>
</ul>
<h3 id="1-2-Spring核心注解详解"><a href="#1-2-Spring核心注解详解" class="headerlink" title="1.2 Spring核心注解详解"></a>1.2 Spring核心注解详解</h3><h4 id="基础配置注解"><a href="#基础配置注解" class="headerlink" title="基础配置注解"></a>基础配置注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">// 表示这是一个配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span>  <span class="comment">// 组件扫描</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>  <span class="comment">// 启用自动配置</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span>  <span class="comment">// SpringBoot主类注解，包含上述三个</span></span><br><span class="line"><span class="meta">@Import(OtherConfig.class)</span>  <span class="comment">// 导入其他配置类</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span>  <span class="comment">// 加载属性文件</span></span><br></pre></td></tr></table></figure>

<h4 id="Bean定义注解"><a href="#Bean定义注解" class="headerlink" title="Bean定义注解"></a>Bean定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">// 通用组件</span></span><br><span class="line"><span class="meta">@Service</span>    <span class="comment">// 业务层组件</span></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 数据访问层组件</span></span><br><span class="line"><span class="meta">@Controller</span> <span class="comment">// 控制层组件</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// RESTful控制器，相当于@Controller + @ResponseBody</span></span><br><span class="line"><span class="meta">@Bean</span>       <span class="comment">// 方法级别，定义Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton/prototype/request/session&quot;)</span>  <span class="comment">// Bean作用域</span></span><br><span class="line"><span class="meta">@Lazy</span>       <span class="comment">// 延迟初始化</span></span><br><span class="line"><span class="meta">@Primary</span>    <span class="comment">// 优先注入</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;beanName&quot;)</span>  <span class="comment">// 指定注入的Bean名称</span></span><br></pre></td></tr></table></figure>

<h4 id="依赖注入注解"><a href="#依赖注入注解" class="headerlink" title="依赖注入注解"></a>依赖注入注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>  <span class="comment">// 自动装配，可用于构造函数、方法、字段</span></span><br><span class="line"><span class="meta">@Resource</span>   <span class="comment">// JSR-250标准，按名称注入</span></span><br><span class="line"><span class="meta">@Inject</span>     <span class="comment">// JSR-330标准</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;property.name&#125;&quot;)</span>  <span class="comment">// 注入配置值</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span>  <span class="comment">// 绑定配置属性</span></span><br></pre></td></tr></table></figure>

<h4 id="生命周期注解"><a href="#生命周期注解" class="headerlink" title="生命周期注解"></a>生命周期注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span>  <span class="comment">// 初始化方法</span></span><br><span class="line"><span class="meta">@PreDestroy</span>     <span class="comment">// 销毁方法</span></span><br></pre></td></tr></table></figure>

<h4 id="AOP相关注解"><a href="#AOP相关注解" class="headerlink" title="AOP相关注解"></a>AOP相关注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>         <span class="comment">// 声明切面</span></span><br><span class="line"><span class="meta">@Pointcut</span>       <span class="comment">// 定义切点</span></span><br><span class="line"><span class="meta">@Before</span>         <span class="comment">// 前置通知</span></span><br><span class="line"><span class="meta">@After</span>          <span class="comment">// 后置通知</span></span><br><span class="line"><span class="meta">@AfterReturning</span> <span class="comment">// 返回后通知</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>  <span class="comment">// 异常通知</span></span><br><span class="line"><span class="meta">@Around</span>         <span class="comment">// 环绕通知</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-Spring常见使用场景"><a href="#1-3-Spring常见使用场景" class="headerlink" title="1.3 Spring常见使用场景"></a>1.3 Spring常见使用场景</h3><h4 id="场景1：服务层事务管理"><a href="#场景1：服务层事务管理" class="headerlink" title="场景1：服务层事务管理"></a>场景1：服务层事务管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景2：缓存管理"><a href="#场景2：缓存管理" class="headerlink" title="场景2：缓存管理"></a>场景2：缓存管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;products&quot;, key = &quot;#product.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productRepository.save(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-Spring常见面试问题"><a href="#1-4-Spring常见面试问题" class="headerlink" title="1.4 Spring常见面试问题"></a>1.4 Spring常见面试问题</h3><p><strong>Q1: Spring IoC容器的初始化过程是怎样的？</strong></p>
<p>A: Spring IoC容器初始化分为三个阶段：</p>
<ol>
<li><strong>Resource定位</strong>: 定位配置文件</li>
<li><strong>BeanDefinition载入</strong>: 将配置信息转换为Spring内部数据结构</li>
<li><strong>BeanDefinition注册</strong>: 将BeanDefinition注册到IoC容器的HashMap中</li>
</ol>
<p>具体流程：</p>
<ul>
<li>创建ApplicationContext</li>
<li>加载配置元数据（XML、注解、Java配置）</li>
<li>解析配置，创建BeanDefinition</li>
<li>注册BeanDefinition到BeanDefinitionRegistry</li>
<li>实例化非懒加载的单例Bean</li>
</ul>
<p><strong>Q2: Spring中的循环依赖是如何解决的？</strong></p>
<p>A: Spring通过三级缓存解决循环依赖：</p>
<ol>
<li><strong>singletonObjects</strong>: 一级缓存，存放完整的Bean实例</li>
<li><strong>earlySingletonObjects</strong>: 二级缓存，存放早期的Bean实例</li>
<li><strong>singletonFactories</strong>: 三级缓存，存放Bean工厂</li>
</ol>
<p>解决过程：</p>
<ul>
<li>A依赖B，B依赖A</li>
<li>创建A时，将A的工厂放入三级缓存</li>
<li>A需要注入B，开始创建B</li>
<li>B需要注入A，从缓存中获取A的早期实例</li>
<li>B创建完成，A继续创建完成</li>
</ul>
<p><strong>Q3: Spring AOP的实现原理？</strong></p>
<p>A: Spring AOP基于代理模式实现：</p>
<ol>
<li><strong>JDK动态代理</strong>: 目标类实现接口时使用，基于反射机制</li>
<li><strong>CGLIB代理</strong>: 目标类没有接口时使用，基于字节码技术</li>
</ol>
<p>代理创建过程：</p>
<ul>
<li>Spring在Bean初始化后，检查是否需要AOP</li>
<li>如果需要，创建代理对象替换原始Bean</li>
<li>代理对象拦截方法调用，执行切面逻辑</li>
</ul>
<h2 id="二、Spring-Boot深入解析"><a href="#二、Spring-Boot深入解析" class="headerlink" title="二、Spring Boot深入解析"></a>二、Spring Boot深入解析</h2><h3 id="2-1-Spring-Boot核心原理"><a href="#2-1-Spring-Boot核心原理" class="headerlink" title="2.1 Spring Boot核心原理"></a>2.1 Spring Boot核心原理</h3><p><strong>自动配置原理：</strong> Spring Boot通过@EnableAutoConfiguration注解启用自动配置机制。</p>
<p>核心类分析：</p>
<ol>
<li><strong>SpringBootApplication</strong>: 组合注解，包含@Configuration、@EnableAutoConfiguration、@ComponentScan</li>
<li><strong>AutoConfigurationImportSelector</strong>: 负责导入自动配置类</li>
<li><strong>spring.factories</strong>: META-INF&#x2F;spring.factories文件定义自动配置类</li>
</ol>
<p><strong>自动配置流程：</strong></p>
<ol>
<li>SpringBoot启动时扫描所有jar包下的META-INF&#x2F;spring.factories文件</li>
<li>加载文件中定义的自动配置类</li>
<li>根据条件注解(@ConditionalOnClass等)判断是否生效</li>
<li>生效的配置类会创建相应的Bean</li>
</ol>
<h3 id="2-2-Spring-Boot启动流程详解"><a href="#2-2-Spring-Boot启动流程详解" class="headerlink" title="2.2 Spring Boot启动流程详解"></a>2.2 Spring Boot启动流程详解</h3><p><strong>SpringApplication.run()方法执行流程：</strong></p>
<ol>
<li><strong>准备阶段</strong>：<ul>
<li>创建SpringApplication实例</li>
<li>确定应用类型（SERVLET、REACTIVE、NONE）</li>
<li>加载ApplicationContextInitializer</li>
<li>加载ApplicationListener</li>
</ul>
</li>
<li><strong>启动阶段</strong>：<ul>
<li>启动计时器</li>
<li>配置Headless模式</li>
<li>获取并启动监听器</li>
<li>准备环境（Environment）</li>
<li>打印Banner</li>
</ul>
</li>
<li><strong>容器创建阶段</strong>：<ul>
<li>创建ApplicationContext</li>
<li>准备ApplicationContext</li>
<li>刷新ApplicationContext</li>
<li>刷新后处理</li>
</ul>
</li>
<li><strong>完成阶段</strong>：<ul>
<li>停止计时器</li>
<li>发布启动完成事件</li>
<li>调用Runners</li>
</ul>
</li>
</ol>
<h3 id="2-3-Spring-Boot核心注解"><a href="#2-3-Spring-Boot核心注解" class="headerlink" title="2.3 Spring Boot核心注解"></a>2.3 Spring Boot核心注解</h3><h4 id="启动类注解"><a href="#启动类注解" class="headerlink" title="启动类注解"></a>启动类注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 等价于以下三个注解的组合</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span>  <span class="comment">// Spring Boot配置类</span></span><br><span class="line"><span class="meta">@EnableScheduling</span>        <span class="comment">// 启用定时任务</span></span><br><span class="line"><span class="meta">@EnableAsync</span>            <span class="comment">// 启用异步处理</span></span><br><span class="line"><span class="meta">@EnableCaching</span>          <span class="comment">// 启用缓存</span></span><br></pre></td></tr></table></figure>

<h4 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(DataSource.class)</span>      <span class="comment">// 类路径下存在指定类</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span> <span class="comment">// 容器中不存在指定Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;app.enabled&quot;, havingValue = &quot;true&quot;)</span> <span class="comment">// 属性匹配</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>               <span class="comment">// Web应用环境</span></span><br><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span>            <span class="comment">// 非Web应用环境</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span>                           <span class="comment">// 激活的profile</span></span><br></pre></td></tr></table></figure>

<h4 id="配置属性注解"><a href="#配置属性注解" class="headerlink" title="配置属性注解"></a>配置属性注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Spring-Boot实际应用场景"><a href="#2-4-Spring-Boot实际应用场景" class="headerlink" title="2.4 Spring Boot实际应用场景"></a>2.4 Spring Boot实际应用场景</h3><h4 id="场景1：微服务架构"><a href="#场景1：微服务架构" class="headerlink" title="场景1：微服务架构"></a>场景1：微服务架构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;order-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/orders/&#123;userId&#125;&quot;)</span></span><br><span class="line">    List&lt;Order&gt; <span class="title function_">getOrdersByUserId</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景2：数据访问层整合"><a href="#场景2：数据访问层整合" class="headerlink" title="场景2：数据访问层整合"></a>场景2：数据访问层整合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource.primary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProperties <span class="title function_">primaryDataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource.secondary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProperties <span class="title function_">secondaryDataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Spring-Boot面试问题"><a href="#2-5-Spring-Boot面试问题" class="headerlink" title="2.5 Spring Boot面试问题"></a>2.5 Spring Boot面试问题</h3><p><strong>Q1: Spring Boot的启动原理是什么？</strong></p>
<p>A: Spring Boot启动原理核心在于自动配置：</p>
<ol>
<li><strong>@SpringBootApplication</strong>组合了三个注解，其中@EnableAutoConfiguration是关键</li>
<li><strong>AutoConfigurationImportSelector</strong>会扫描所有引入的jar包，查找其META-INF&#x2F;spring.factories文件中org.springframework.boot.autoconfigure.EnableAutoConfiguration键所对应的配置类全限定名列表</li>
<li>根据条件注解判断哪些自动配置类生效</li>
<li>生效的配置类会向容器中注册相应的Bean</li>
</ol>
<p><strong>Q2: Spring Boot如何实现自动配置？</strong></p>
<p>A: 自动配置通过以下机制实现：</p>
<ol>
<li><strong>条件注解</strong>: @ConditionalOnClass、@ConditionalOnBean等判断配置是否生效</li>
<li><strong>配置文件</strong>: spring.factories定义自动配置类列表</li>
<li><strong>配置属性</strong>: @ConfigurationProperties绑定配置文件中的属性</li>
<li><strong>默认配置</strong>: 提供合理的默认值，用户可覆盖</li>
</ol>
<p><strong>Q3: Spring Boot Starter的工作原理？</strong></p>
<p>A: Starter是Spring Boot自动配置的载体：</p>
<ol>
<li><strong>依赖管理</strong>: 通过Maven&#x2F;Gradle引入相关依赖</li>
<li><strong>自动配置</strong>: 包含AutoConfiguration类</li>
<li><strong>属性绑定</strong>: 提供ConfigurationProperties类</li>
<li><strong>条件装配</strong>: 使用条件注解控制Bean的创建</li>
</ol>
<h2 id="三、Spring-MVC深入解析"><a href="#三、Spring-MVC深入解析" class="headerlink" title="三、Spring MVC深入解析"></a>三、Spring MVC深入解析</h2><h3 id="3-1-Spring-MVC核心组件"><a href="#3-1-Spring-MVC核心组件" class="headerlink" title="3.1 Spring MVC核心组件"></a>3.1 Spring MVC核心组件</h3><p><strong>DispatcherServlet处理流程：</strong></p>
<ol>
<li><strong>接收请求</strong>: DispatcherServlet接收HTTP请求</li>
<li><strong>查找Handler</strong>: HandlerMapping查找处理请求的Handler</li>
<li><strong>获取HandlerAdapter</strong>: 获取能够执行Handler的HandlerAdapter</li>
<li><strong>执行Handler</strong>: HandlerAdapter执行Handler（Controller方法）</li>
<li><strong>处理结果</strong>: 返回ModelAndView</li>
<li><strong>视图解析</strong>: ViewResolver解析视图名称</li>
<li><strong>渲染视图</strong>: View渲染模型数据</li>
<li><strong>返回响应</strong>: 响应结果返回给客户端</li>
</ol>
<p><strong>核心组件详解：</strong></p>
<ul>
<li><strong>DispatcherServlet</strong>: 前端控制器，统一处理请求</li>
<li><strong>HandlerMapping</strong>: 处理器映射器，URL与Handler的映射</li>
<li><strong>HandlerAdapter</strong>: 处理器适配器，执行Handler</li>
<li><strong>Handler</strong>: 处理器，即Controller</li>
<li><strong>ViewResolver</strong>: 视图解析器</li>
<li><strong>View</strong>: 视图</li>
</ul>
<h3 id="3-2-Spring-MVC核心注解"><a href="#3-2-Spring-MVC核心注解" class="headerlink" title="3.2 Spring MVC核心注解"></a>3.2 Spring MVC核心注解</h3><h4 id="控制器注解"><a href="#控制器注解" class="headerlink" title="控制器注解"></a>控制器注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>             <span class="comment">// 标记控制器类</span></span><br><span class="line"><span class="meta">@RestController</span>        <span class="comment">// RESTful控制器</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span> <span class="comment">// 请求映射</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span>   <span class="comment">// GET请求映射</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span>  <span class="comment">// POST请求映射</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/users/&#123;id&#125;&quot;)</span>    <span class="comment">// PUT请求映射</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;id&#125;&quot;)</span> <span class="comment">// DELETE请求映射</span></span><br><span class="line"><span class="meta">@PatchMapping(&quot;/users/&#123;id&#125;&quot;)</span>  <span class="comment">// PATCH请求映射</span></span><br></pre></td></tr></table></figure>

<h4 id="参数绑定注解"><a href="#参数绑定注解" class="headerlink" title="参数绑定注解"></a>参数绑定注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam(&quot;name&quot;)</span>           <span class="comment">// 请求参数</span></span><br><span class="line"><span class="meta">@PathVariable(&quot;id&quot;)</span>            <span class="comment">// 路径变量</span></span><br><span class="line"><span class="meta">@RequestBody</span>                   <span class="comment">// 请求体</span></span><br><span class="line"><span class="meta">@RequestHeader(&quot;Content-Type&quot;)</span> <span class="comment">// 请求头</span></span><br><span class="line"><span class="meta">@CookieValue(&quot;sessionId&quot;)</span>      <span class="comment">// Cookie值</span></span><br><span class="line"><span class="meta">@ModelAttribute</span>               <span class="comment">// 模型属性</span></span><br><span class="line"><span class="meta">@SessionAttribute</span>            <span class="comment">// Session属性</span></span><br><span class="line"><span class="meta">@RequestPart</span>                 <span class="comment">// 文件上传</span></span><br></pre></td></tr></table></figure>

<h4 id="响应处理注解"><a href="#响应处理注解" class="headerlink" title="响应处理注解"></a>响应处理注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>              <span class="comment">// 响应体</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.CREATED)</span> <span class="comment">// 响应状态码</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>         <span class="comment">// 异常处理</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>        <span class="comment">// 全局控制器增强</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span>    <span class="comment">// RESTful全局异常处理</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-Spring-MVC实际应用场景"><a href="#3-3-Spring-MVC实际应用场景" class="headerlink" title="3.3 Spring MVC实际应用场景"></a>3.3 Spring MVC实际应用场景</h3><h4 id="场景1：RESTful-API开发"><a href="#场景1：RESTful-API开发" class="headerlink" title="场景1：RESTful API开发"></a>场景1：RESTful API开发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;PageResult&lt;User&gt;&gt; <span class="title function_">getUsers</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class="type">int</span> page,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(required = false)</span> String keyword)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        PageResult&lt;User&gt; result = userService.findUsers(page, size, keyword);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserCreateRequest request)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.createUser(request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).body(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">updateUser</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@PathVariable</span> Long id,</span></span><br><span class="line"><span class="params">            <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserUpdateRequest request)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.updateUser(id, request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        userService.deleteUser(id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景2：全局异常处理"><a href="#场景2：全局异常处理" class="headerlink" title="场景2：全局异常处理"></a>场景2：全局异常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(ValidationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleValidationException</span><span class="params">(ValidationException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorResponse.builder()</span><br><span class="line">                .code(<span class="string">&quot;VALIDATION_ERROR&quot;</span>)</span><br><span class="line">                .message(e.getMessage())</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(EntityNotFoundException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleEntityNotFoundException</span><span class="params">(EntityNotFoundException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorResponse.builder()</span><br><span class="line">                .code(<span class="string">&quot;ENTITY_NOT_FOUND&quot;</span>)</span><br><span class="line">                .message(e.getMessage())</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleGenericException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error occurred&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ErrorResponse.builder()</span><br><span class="line">                .code(<span class="string">&quot;INTERNAL_ERROR&quot;</span>)</span><br><span class="line">                .message(<span class="string">&quot;An unexpected error occurred&quot;</span>)</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景3：文件上传处理"><a href="#场景3：文件上传处理" class="headerlink" title="场景3：文件上传处理"></a>场景3：文件上传处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/files&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;FileUploadResponse&gt; <span class="title function_">uploadFile</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile file,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(required = false)</span> String description)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件类型验证</span></span><br><span class="line">        <span class="keyword">if</span> (!isValidFileType(file.getContentType())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidFileTypeException</span>(<span class="string">&quot;Invalid file type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件大小验证</span></span><br><span class="line">        <span class="keyword">if</span> (file.getSize() &gt; MAX_FILE_SIZE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileSizeExceededException</span>(<span class="string">&quot;File size exceeds limit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> fileService.saveFile(file, description);</span><br><span class="line">        </span><br><span class="line">        <span class="type">FileUploadResponse</span> <span class="variable">response</span> <span class="operator">=</span> FileUploadResponse.builder()</span><br><span class="line">                .fileName(fileName)</span><br><span class="line">                .originalName(file.getOriginalFilename())</span><br><span class="line">                .size(file.getSize())</span><br><span class="line">                .contentType(file.getContentType())</span><br><span class="line">                .uploadTime(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-Spring-MVC面试问题"><a href="#3-4-Spring-MVC面试问题" class="headerlink" title="3.4 Spring MVC面试问题"></a>3.4 Spring MVC面试问题</h3><p><strong>Q1: Spring MVC的执行流程是怎样的？</strong></p>
<p>A: Spring MVC的执行流程如下：</p>
<ol>
<li>用户发送请求到DispatcherServlet</li>
<li>DispatcherServlet调用HandlerMapping查找Handler</li>
<li>HandlerMapping返回HandlerExecutionChain（包含Handler和拦截器）</li>
<li>DispatcherServlet调用HandlerAdapter执行Handler</li>
<li>Handler执行完成后返回ModelAndView</li>
<li>DispatcherServlet调用ViewResolver解析视图名称</li>
<li>ViewResolver返回View对象</li>
<li>DispatcherServlet调用View的render方法渲染视图</li>
<li>响应结果返回给用户</li>
</ol>
<p><strong>Q2: Spring MVC中的拦截器是如何工作的？</strong></p>
<p>A: 拦截器基于AOP思想，在Handler执行前后进行处理：</p>
<ol>
<li><strong>HandlerInterceptor接口</strong>提供三个方法：<ul>
<li>preHandle(): 前置处理，返回false则中断请求</li>
<li>postHandle(): 后置处理，Handler执行后调用</li>
<li>afterCompletion(): 完成处理，视图渲染后调用</li>
</ul>
</li>
<li><strong>执行顺序</strong>：<ul>
<li>多个拦截器按配置顺序执行preHandle()</li>
<li>按相反顺序执行postHandle()和afterCompletion()</li>
</ul>
</li>
</ol>
<p><strong>Q3: @RequestBody和@ResponseBody的工作原理？</strong></p>
<p>A: 这两个注解基于HttpMessageConverter工作：</p>
<ol>
<li><strong>@RequestBody</strong>:<ul>
<li>使用HttpMessageConverter将HTTP请求体转换为Java对象</li>
<li>常用的转换器：MappingJackson2HttpMessageConverter处理JSON</li>
</ul>
</li>
<li><strong>@ResponseBody</strong>:<ul>
<li>使用HttpMessageConverter将Java对象转换为HTTP响应体</li>
<li>根据Accept头选择合适的转换器</li>
</ul>
</li>
</ol>
<h2 id="四、MyBatis深入解析"><a href="#四、MyBatis深入解析" class="headerlink" title="四、MyBatis深入解析"></a>四、MyBatis深入解析</h2><h3 id="4-1-MyBatis核心原理"><a href="#4-1-MyBatis核心原理" class="headerlink" title="4.1 MyBatis核心原理"></a>4.1 MyBatis核心原理</h3><p><strong>MyBatis架构分析：</strong> MyBatis采用分层架构设计：</p>
<ol>
<li><strong>API接口层</strong>: 提供给外部使用的接口API</li>
<li><strong>数据处理层</strong>: 参数映射、SQL解析、结果映射</li>
<li><strong>基础支撑层</strong>: 连接管理、事务管理、配置加载、缓存处理</li>
</ol>
<p><strong>MyBatis核心组件：</strong></p>
<ul>
<li><strong>SqlSessionFactory</strong>: 会话工厂，负责创建SqlSession</li>
<li><strong>SqlSession</strong>: 会话，执行SQL的核心接口</li>
<li><strong>Executor</strong>: 执行器，实际执行SQL</li>
<li><strong>StatementHandler</strong>: 语句处理器，处理SQL语句</li>
<li><strong>ParameterHandler</strong>: 参数处理器，处理SQL参数</li>
<li><strong>ResultSetHandler</strong>: 结果集处理器，处理查询结果</li>
<li><strong>MappedStatement</strong>: 映射语句，封装SQL配置信息</li>
</ul>
<h3 id="4-2-MyBatis执行流程详解"><a href="#4-2-MyBatis执行流程详解" class="headerlink" title="4.2 MyBatis执行流程详解"></a>4.2 MyBatis执行流程详解</h3><p><strong>SQL执行流程：</strong></p>
<ol>
<li><strong>解析配置</strong>: 解析mybatis-config.xml和Mapper XML文件</li>
<li><strong>创建会话</strong>: 通过SqlSessionFactory创建SqlSession</li>
<li><strong>获取Mapper</strong>: 通过动态代理创建Mapper接口实例</li>
<li><strong>执行SQL</strong>: 调用Mapper方法，转换为MappedStatement执行</li>
<li><strong>参数处理</strong>: ParameterHandler处理输入参数</li>
<li><strong>执行查询</strong>: StatementHandler执行SQL语句</li>
<li><strong>结果映射</strong>: ResultSetHandler处理结果集</li>
<li><strong>返回结果</strong>: 将结果返回给调用方</li>
</ol>
<p><strong>动态代理原理：</strong> MyBatis使用JDK动态代理为Mapper接口创建代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperProxy实现InvocationHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据方法签名找到对应的MappedStatement</span></span><br><span class="line">        <span class="comment">// 执行SQL并返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-MyBatis核心注解"><a href="#4-3-MyBatis核心注解" class="headerlink" title="4.3 MyBatis核心注解"></a>4.3 MyBatis核心注解</h3><h4 id="基础映射注解"><a href="#基础映射注解" class="headerlink" title="基础映射注解"></a>基础映射注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">findById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert(&quot;INSERT INTO users(name, email) VALUES(#&#123;name&#125;, #&#123;email&#125;)&quot;)</span></span><br><span class="line"><span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update(&quot;UPDATE users SET name = #&#123;name&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete(&quot;DELETE FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="高级映射注解"><a href="#高级映射注解" class="headerlink" title="高级映射注解"></a>高级映射注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果映射</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;user_id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;user_name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT user_id, user_name, create_time FROM users&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对一映射</span></span><br><span class="line"><span class="meta">@One(select = &quot;findUserById&quot;)</span></span><br><span class="line"><span class="meta">@Result(column = &quot;user_id&quot;, property = &quot;user&quot;)</span></span><br><span class="line">Order <span class="title function_">findOrderById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对多映射</span></span><br><span class="line"><span class="meta">@Many(select = &quot;findOrdersByUserId&quot;)</span></span><br><span class="line"><span class="meta">@Result(column = &quot;id&quot;, property = &quot;orders&quot;)</span></span><br><span class="line">User <span class="title function_">findUserWithOrders</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="动态SQL注解"><a href="#动态SQL注解" class="headerlink" title="动态SQL注解"></a>动态SQL注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;findUsers&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsers</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUsers</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (params.get(<span class="string">&quot;name&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;name LIKE CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (params.get(<span class="string">&quot;email&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;email = #&#123;email&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-MyBatis缓存机制"><a href="#4-4-MyBatis缓存机制" class="headerlink" title="4.4 MyBatis缓存机制"></a>4.4 MyBatis缓存机制</h3><p><strong>一级缓存（默认开启）：</strong></p>
<ul>
<li>作用域：SqlSession级别</li>
<li>生命周期：与SqlSession相同</li>
<li>存储：HashMap结构，key为CacheKey</li>
</ul>
<p><strong>二级缓存（需要配置）：</strong></p>
<ul>
<li>作用域：Mapper级别</li>
<li>生命周期：与应用程序相同</li>
<li>配置：@CacheNamespace注解或<cache>标签</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace(</span></span><br><span class="line"><span class="meta">    eviction = LRU.class,</span></span><br><span class="line"><span class="meta">    flushInterval = 60000,</span></span><br><span class="line"><span class="meta">    size = 1024,</span></span><br><span class="line"><span class="meta">    readWrite = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">// mapper methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-MyBatis实际应用场景"><a href="#4-5-MyBatis实际应用场景" class="headerlink" title="4.5 MyBatis实际应用场景"></a>4.5 MyBatis实际应用场景</h3><h4 id="场景1：复杂查询场景"><a href="#场景1：复杂查询场景" class="headerlink" title="场景1：复杂查询场景"></a>场景1：复杂查询场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分页查询订单</span></span><br><span class="line">    <span class="meta">@Select(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        SELECT o.*, u.name as user_name, u.email as user_email</span></span><br><span class="line"><span class="meta">        FROM orders o</span></span><br><span class="line"><span class="meta">        LEFT JOIN users u ON o.user_id = u.id</span></span><br><span class="line"><span class="meta">        WHERE o.status = #&#123;status&#125;</span></span><br><span class="line"><span class="meta">        AND o.create_time BETWEEN #&#123;startTime&#125; AND #&#123;endTime&#125;</span></span><br><span class="line"><span class="meta">        ORDER BY o.create_time DESC</span></span><br><span class="line"><span class="meta">        LIMIT #&#123;offset&#125;, #&#123;limit&#125;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;user_id&quot;, property = &quot;userId&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;user_name&quot;, property = &quot;user.name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;user_email&quot;, property = &quot;user.email&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    List&lt;OrderVO&gt; <span class="title function_">findOrdersWithUser</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;status&quot;)</span> String status,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;startTime&quot;)</span> LocalDateTime startTime,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;endTime&quot;)</span> LocalDateTime endTime,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计查询</span></span><br><span class="line">    <span class="meta">@Select(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        SELECT </span></span><br><span class="line"><span class="meta">            COUNT(*) as total_count,</span></span><br><span class="line"><span class="meta">            SUM(amount) as total_amount,</span></span><br><span class="line"><span class="meta">            AVG(amount) as avg_amount</span></span><br><span class="line"><span class="meta">        FROM orders </span></span><br><span class="line"><span class="meta">        WHERE status = #&#123;status&#125;</span></span><br><span class="line"><span class="meta">        AND create_time &gt;= #&#123;startTime&#125;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    OrderStatistics <span class="title function_">getOrderStatistics</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;status&quot;)</span> String status,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;startTime&quot;)</span> LocalDateTime startTime</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景2：批量操作场景"><a href="#场景2：批量操作场景" class="headerlink" title="场景2：批量操作场景"></a>场景2：批量操作场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BatchMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 批量插入</span></span><br><span class="line">    <span class="meta">@Insert(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        &lt;script&gt;</span></span><br><span class="line"><span class="meta">        INSERT INTO users (name, email, create_time) VALUES</span></span><br><span class="line"><span class="meta">        &lt;foreach collection=&quot;users&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="meta">            (#&#123;user.name&#125;, #&#123;user.email&#125;, #&#123;user.createTime&#125;)</span></span><br><span class="line"><span class="meta">        &lt;/foreach&gt;</span></span><br><span class="line"><span class="meta">        &lt;/script&gt;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">batchInsertUsers</span><span class="params">(<span class="meta">@Param(&quot;users&quot;)</span> List&lt;User&gt; users)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 批量更新</span></span><br><span class="line">    <span class="meta">@Update(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        &lt;script&gt;</span></span><br><span class="line"><span class="meta">        &lt;foreach collection=&quot;users&quot; item=&quot;user&quot; separator=&quot;;&quot;&gt;</span></span><br><span class="line"><span class="meta">            UPDATE users SET </span></span><br><span class="line"><span class="meta">                name = #&#123;user.name&#125;,</span></span><br><span class="line"><span class="meta">                email = #&#123;user.email&#125;,</span></span><br><span class="line"><span class="meta">                update_time = NOW()</span></span><br><span class="line"><span class="meta">            WHERE id = #&#123;user.id&#125;</span></span><br><span class="line"><span class="meta">        &lt;/foreach&gt;</span></span><br><span class="line"><span class="meta">        &lt;/script&gt;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">batchUpdateUsers</span><span class="params">(<span class="meta">@Param(&quot;users&quot;)</span> List&lt;User&gt; users)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景3：动态SQL场景"><a href="#场景3：动态SQL场景" class="headerlink" title="场景3：动态SQL场景"></a>场景3：动态SQL场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;searchUsers&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">searchUsers</span><span class="params">(UserSearchCriteria criteria)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">searchUsers</span><span class="params">(UserSearchCriteria criteria)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;u.*, p.name as profile_name&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;users u&quot;</span>);</span><br><span class="line">            LEFT_OUTER_JOIN(<span class="string">&quot;user_profiles p ON u.id = p.user_id&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(criteria.getName())) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.name LIKE CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(criteria.getEmail())) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.email = #&#123;email&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getMinAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.age &gt;= #&#123;minAge&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getMaxAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.age &lt;= #&#123;maxAge&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getCreateTimeStart() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.create_time &gt;= #&#123;createTimeStart&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getCreateTimeEnd() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.create_time &lt;= #&#123;createTimeEnd&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(criteria.getStatuses())) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.status IN (&quot;</span> + </span><br><span class="line">                    criteria.getStatuses().stream()</span><br><span class="line">                        .map(s -&gt; <span class="string">&quot;&#x27;&quot;</span> + s + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">                        .collect(Collectors.joining(<span class="string">&quot;,&quot;</span>)) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 排序</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(criteria.getSortField())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;desc&quot;</span>.equalsIgnoreCase(criteria.getSortDirection())) &#123;</span><br><span class="line">                    ORDER_BY(<span class="string">&quot;u.&quot;</span> + criteria.getSortField() + <span class="string">&quot; DESC&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ORDER_BY(<span class="string">&quot;u.&quot;</span> + criteria.getSortField() + <span class="string">&quot; ASC&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ORDER_BY(<span class="string">&quot;u.create_time DESC&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-MyBatis性能优化"><a href="#4-6-MyBatis性能优化" class="headerlink" title="4.6 MyBatis性能优化"></a>4.6 MyBatis性能优化</h3><h4 id="优化策略1：合理使用缓存"><a href="#优化策略1：合理使用缓存" class="headerlink" title="优化策略1：合理使用缓存"></a>优化策略1：合理使用缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启二级缓存，设置合理的缓存策略</span></span><br><span class="line"><span class="meta">@CacheNamespace(</span></span><br><span class="line"><span class="meta">    eviction = LRU.class,        // 缓存回收策略</span></span><br><span class="line"><span class="meta">    flushInterval = 300000,      // 缓存刷新间隔（5分钟）</span></span><br><span class="line"><span class="meta">    size = 1024,                 // 缓存大小</span></span><br><span class="line"><span class="meta">    readWrite = true,            // 读写缓存</span></span><br><span class="line"><span class="meta">    blocking = false             // 非阻塞缓存</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于频繁查询且变化不大的数据使用缓存</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM products WHERE category_id = #&#123;categoryId&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useCache = true)</span></span><br><span class="line">    List&lt;Product&gt; <span class="title function_">findByCategory</span><span class="params">(<span class="meta">@Param(&quot;categoryId&quot;)</span> Long categoryId)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于实时性要求高的数据禁用缓存</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM products WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useCache = false)</span></span><br><span class="line">    Product <span class="title function_">findRealTimeById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化策略2：批量操作"><a href="#优化策略2：批量操作" class="headerlink" title="优化策略2：批量操作"></a>优化策略2：批量操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用批量插入替代循环插入</span></span><br><span class="line"><span class="meta">@Insert(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    &lt;script&gt;</span></span><br><span class="line"><span class="meta">    INSERT INTO order_items (order_id, product_id, quantity, price) VALUES</span></span><br><span class="line"><span class="meta">    &lt;foreach collection=&quot;items&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="meta">        (#&#123;item.orderId&#125;, #&#123;item.productId&#125;, #&#123;item.quantity&#125;, #&#123;item.price&#125;)</span></span><br><span class="line"><span class="meta">    &lt;/foreach&gt;</span></span><br><span class="line"><span class="meta">    &lt;/script&gt;</span></span><br><span class="line"><span class="meta">&quot;&quot;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">batchInsertOrderItems</span><span class="params">(<span class="meta">@Param(&quot;items&quot;)</span> List&lt;OrderItem&gt; items)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量更新优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdateProducts</span><span class="params">(List&lt;Product&gt; products)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH)) &#123;</span><br><span class="line">        <span class="type">ProductMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ProductMapper.class);</span><br><span class="line">        <span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">            mapper.updateProduct(product);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化策略3：延迟加载"><a href="#优化策略3：延迟加载" class="headerlink" title="优化策略3：延迟加载"></a>优化策略3：延迟加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResultMap(&quot;userResultMap&quot;)</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">findUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在ResultMap中配置延迟加载</span></span><br><span class="line">&lt;resultMap id=<span class="string">&quot;userResultMap&quot;</span> type=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span>/&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;name&quot;</span> property=<span class="string">&quot;name&quot;</span>/&gt;</span><br><span class="line">    &lt;collection property=<span class="string">&quot;orders&quot;</span> </span><br><span class="line">                select=<span class="string">&quot;findOrdersByUserId&quot;</span> </span><br><span class="line">                column=<span class="string">&quot;id&quot;</span> </span><br><span class="line">                fetchType=<span class="string">&quot;lazy&quot;</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-MyBatis常见问题与解决方案"><a href="#4-7-MyBatis常见问题与解决方案" class="headerlink" title="4.7 MyBatis常见问题与解决方案"></a>4.7 MyBatis常见问题与解决方案</h3><h4 id="问题1：N-1查询问题"><a href="#问题1：N-1查询问题" class="headerlink" title="问题1：N+1查询问题"></a>问题1：N+1查询问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题：会产生N+1次查询</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findAllUsers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM orders WHERE user_id = #&#123;userId&#125;&quot;)</span></span><br><span class="line">List&lt;Order&gt; <span class="title function_">findOrdersByUserId</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案1：使用联表查询</span></span><br><span class="line"><span class="meta">@Select(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    SELECT u.*, o.id as order_id, o.amount, o.status as order_status</span></span><br><span class="line"><span class="meta">    FROM users u</span></span><br><span class="line"><span class="meta">    LEFT JOIN orders o ON u.id = o.user_id</span></span><br><span class="line"><span class="meta">&quot;&quot;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;order_id&quot;, property = &quot;orders.id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;amount&quot;, property = &quot;orders.amount&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;order_status&quot;, property = &quot;orders.status&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersWithOrders</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案2：使用批量查询</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUsersWithOrdersOptimized</span><span class="params">(List&lt;Long&gt; userIds)</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.findUsersByIds(userIds);</span><br><span class="line">    <span class="keyword">if</span> (!users.isEmpty()) &#123;</span><br><span class="line">        List&lt;Long&gt; ids = users.stream().map(User::getId).collect(Collectors.toList());</span><br><span class="line">        List&lt;Order&gt; orders = orderMapper.findOrdersByUserIds(ids);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手动组装数据</span></span><br><span class="line">        Map&lt;Long, List&lt;Order&gt;&gt; orderMap = orders.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Order::getUserId));</span><br><span class="line">        </span><br><span class="line">        users.forEach(user -&gt; user.setOrders(orderMap.get(user.getId())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题2：大数据量查询内存溢出"><a href="#问题2：大数据量查询内存溢出" class="headerlink" title="问题2：大数据量查询内存溢出"></a>问题2：大数据量查询内存溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题：一次性加载大量数据导致内存溢出</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM large_table&quot;)</span></span><br><span class="line">List&lt;LargeData&gt; <span class="title function_">findAllData</span><span class="params">()</span>; <span class="comment">// 可能导致OOM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案1：分页查询</span></span><br><span class="line"><span class="keyword">public</span> List&lt;LargeData&gt; <span class="title function_">findAllDataWithPaging</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;LargeData&gt; allData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;LargeData&gt; pageData;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        pageData = mapper.findDataWithLimit(offset, pageSize);</span><br><span class="line">        allData.addAll(pageData);</span><br><span class="line">        offset += pageSize;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pageData.size() == pageSize);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> allData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案2：使用游标查询</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM large_table WHERE process_status = &#x27;PENDING&#x27;&quot;)</span></span><br><span class="line"><span class="meta">@Options(resultSetType = ResultSetType.FORWARD_ONLY, fetchSize = 1000)</span></span><br><span class="line">Cursor&lt;LargeData&gt; <span class="title function_">findPendingDataCursor</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processLargeData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (Cursor&lt;LargeData&gt; cursor = mapper.findPendingDataCursor()) &#123;</span><br><span class="line">        cursor.forEach(<span class="built_in">this</span>::processData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题3：SQL注入防护"><a href="#问题3：SQL注入防护" class="headerlink" title="问题3：SQL注入防护"></a>问题3：SQL注入防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险：直接拼接SQL，容易SQL注入</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = &#x27;$&#123;name&#125;&#x27;&quot;)</span> <span class="comment">// 错误示例</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByNameUnsafe</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全：使用参数绑定</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = #&#123;name&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByNameSafe</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态排序的安全处理</span></span><br><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;findUsersWithSort&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersWithSort</span><span class="params">(<span class="meta">@Param(&quot;sortField&quot;)</span> String sortField, </span></span><br><span class="line"><span class="params">                            <span class="meta">@Param(&quot;sortDirection&quot;)</span> String sortDirection)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; ALLOWED_SORT_FIELDS = </span><br><span class="line">        Set.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;create_time&quot;</span>, <span class="string">&quot;update_time&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUsersWithSort</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sortField</span> <span class="operator">=</span> (String) params.get(<span class="string">&quot;sortField&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sortDirection</span> <span class="operator">=</span> (String) params.get(<span class="string">&quot;sortDirection&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 白名单验证</span></span><br><span class="line">        <span class="keyword">if</span> (!ALLOWED_SORT_FIELDS.contains(sortField)) &#123;</span><br><span class="line">            sortField = <span class="string">&quot;id&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;DESC&quot;</span>.equalsIgnoreCase(sortDirection)) &#123;</span><br><span class="line">            sortDirection = <span class="string">&quot;ASC&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SELECT * FROM users ORDER BY &quot;</span> + sortField + <span class="string">&quot; &quot;</span> + sortDirection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-MyBatis面试高频问题"><a href="#4-8-MyBatis面试高频问题" class="headerlink" title="4.8 MyBatis面试高频问题"></a>4.8 MyBatis面试高频问题</h3><p><strong>Q1: MyBatis的执行流程是怎样的？</strong></p>
<p>A: MyBatis的执行流程包括以下步骤：</p>
<ol>
<li><strong>配置解析</strong>: 解析mybatis-config.xml配置文件和Mapper XML文件，创建Configuration对象</li>
<li><strong>SqlSessionFactory创建</strong>: 根据Configuration创建SqlSessionFactory</li>
<li><strong>SqlSession创建</strong>: 通过SqlSessionFactory.openSession()创建SqlSession</li>
<li><strong>Mapper获取</strong>: 通过SqlSession.getMapper()获取Mapper接口的代理对象</li>
<li><strong>方法调用</strong>: 调用Mapper接口方法，通过动态代理转换为SQL执行</li>
<li><strong>SQL执行</strong>: 通过Executor执行SQL，包括参数处理、语句执行、结果映射</li>
<li><strong>结果返回</strong>: 将执行结果返回给调用方</li>
</ol>
<p><strong>Q2: MyBatis的一级缓存和二级缓存有什么区别？</strong></p>
<p>A: 两级缓存的主要区别：</p>
<p><strong>一级缓存（默认开启）：</strong></p>
<ul>
<li>作用域：SqlSession级别</li>
<li>生命周期：与SqlSession相同，SqlSession关闭时缓存清空</li>
<li>存储结构：HashMap，key为CacheKey（由SQL、参数、分页等组成）</li>
<li>失效条件：执行update、insert、delete操作或手动清空</li>
</ul>
<p><strong>二级缓存（需要配置）：</strong></p>
<ul>
<li>作用域：Mapper级别，多个SqlSession可以共享</li>
<li>生命周期：与应用程序相同</li>
<li>存储结构：可配置（HashMap、LRU、FIFO等）</li>
<li>配置方式：@CacheNamespace注解或<cache>标签</li>
<li>注意事项：需要序列化，可能存在脏读问题</li>
</ul>
<p><strong>Q3: MyBatis如何防止SQL注入？</strong></p>
<p>A: MyBatis通过以下方式防止SQL注入：</p>
<ol>
<li><strong>参数绑定</strong>: 使用#{}而不是${}<ul>
<li>#{}：预编译处理，参数作为占位符传递</li>
<li>${}：字符串替换，直接拼接到SQL中（危险）</li>
</ul>
</li>
<li><strong>类型检查</strong>: MyBatis会对参数类型进行检查</li>
<li><strong>白名单验证</strong>: 对于动态排序等场景，使用白名单验证</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全的写法</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = #&#123;name&#125; AND age &gt; #&#123;age&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsers</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险的写法（避免使用）</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = &#x27;$&#123;name&#125;&#x27;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersUnsafe</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Q4: MyBatis中#{}和${}的区别？</strong></p>
<p>A: 两者的主要区别：</p>
<p><strong>#{}（推荐使用）：</strong></p>
<ul>
<li>预编译处理，生成PreparedStatement</li>
<li>参数会被处理为占位符?</li>
<li>可以防止SQL注入</li>
<li>会进行类型转换</li>
<li>适用于参数值传递</li>
</ul>
<p><strong>${}（谨慎使用）：</strong></p>
<ul>
<li>字符串替换，直接拼接到SQL中</li>
<li>不会进行预编译</li>
<li>存在SQL注入风险</li>
<li>不会进行类型转换</li>
<li>适用于动态表名、列名等场景</li>
</ul>
<p><strong>Q5: MyBatis的动态SQL是如何实现的？</strong></p>
<p>A: MyBatis的动态SQL通过以下标签实现：</p>
<ol>
<li><strong>if标签</strong>: 条件判断</li>
<li><strong>choose&#x2F;when&#x2F;otherwise</strong>: 类似switch-case</li>
<li><strong>where标签</strong>: 智能处理WHERE条件</li>
<li><strong>set标签</strong>: 智能处理SET语句</li>
<li><strong>foreach标签</strong>: 循环处理</li>
<li><strong>trim标签</strong>: 去除多余的字符</li>
</ol>
<p>实现原理：</p>
<ul>
<li>使用OGNL表达式进行条件判断</li>
<li>在SQL解析阶段根据参数值动态生成SQL</li>
<li>通过SqlNode树结构表示动态SQL</li>
<li>在执行时遍历SqlNode树生成最终SQL</li>
</ul>
<h2 id="五、框架整合与最佳实践"><a href="#五、框架整合与最佳实践" class="headerlink" title="五、框架整合与最佳实践"></a>五、框架整合与最佳实践</h2><h3 id="5-1-Spring-Boot-MyBatis整合"><a href="#5-1-Spring-Boot-MyBatis整合" class="headerlink" title="5.1 Spring Boot + MyBatis整合"></a>5.1 Spring Boot + MyBatis整合</h3><h4 id="完整配置示例"><a href="#完整配置示例" class="headerlink" title="完整配置示例"></a>完整配置示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主启动类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据源配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource.primary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProperties <span class="title function_">primaryDataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">primaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> primaryDataSourceProperties()</span><br><span class="line">                .initializeDataSourceBuilder()</span><br><span class="line">                .type(HikariDataSource.class)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        factory.setDataSource(dataSource);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// MyBatis配置</span></span><br><span class="line">        org.apache.ibatis.session.<span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">org</span>.apache.ibatis.session.Configuration();</span><br><span class="line">        config.setMapUnderscoreToCamelCase(<span class="literal">true</span>);</span><br><span class="line">        config.setLogImpl(Slf4jImpl.class);</span><br><span class="line">        config.setCacheEnabled(<span class="literal">true</span>);</span><br><span class="line">        config.setLazyLoadingEnabled(<span class="literal">true</span>);</span><br><span class="line">        config.setAggressiveLazyLoading(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        factory.setConfiguration(config);</span><br><span class="line">        <span class="keyword">return</span> factory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事务管理配置"><a href="#事务管理配置" class="headerlink" title="事务管理配置"></a>事务管理配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderItemMapper orderItemMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductMapper productMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">createOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setUserId(request.getUserId());</span><br><span class="line">        order.setStatus(<span class="string">&quot;PENDING&quot;</span>);</span><br><span class="line">        order.setCreateTime(LocalDateTime.now());</span><br><span class="line">        orderMapper.insert(order);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建订单项</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">totalAmount</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">        List&lt;OrderItem&gt; orderItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (CreateOrderItemRequest itemRequest : request.getItems()) &#123;</span><br><span class="line">            <span class="comment">// 检查库存</span></span><br><span class="line">            <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productMapper.findById(itemRequest.getProductId());</span><br><span class="line">            <span class="keyword">if</span> (product == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ProductNotFoundException</span>(<span class="string">&quot;Product not found: &quot;</span> + itemRequest.getProductId());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (product.getStock() &lt; itemRequest.getQuantity()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientStockException</span>(<span class="string">&quot;Insufficient stock for product: &quot;</span> + product.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 减库存</span></span><br><span class="line">            productMapper.decreaseStock(itemRequest.getProductId(), itemRequest.getQuantity());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建订单项</span></span><br><span class="line">            <span class="type">OrderItem</span> <span class="variable">orderItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderItem</span>();</span><br><span class="line">            orderItem.setOrderId(order.getId());</span><br><span class="line">            orderItem.setProductId(itemRequest.getProductId());</span><br><span class="line">            orderItem.setQuantity(itemRequest.getQuantity());</span><br><span class="line">            orderItem.setPrice(product.getPrice());</span><br><span class="line">            orderItems.add(orderItem);</span><br><span class="line">            </span><br><span class="line">            totalAmount = totalAmount.add(</span><br><span class="line">                product.getPrice().multiply(BigDecimal.valueOf(itemRequest.getQuantity()))</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 批量插入订单项</span></span><br><span class="line">        <span class="keyword">if</span> (!orderItems.isEmpty()) &#123;</span><br><span class="line">            orderItemMapper.batchInsert(orderItems);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 更新订单总金额</span></span><br><span class="line">        order.setTotalAmount(totalAmount);</span><br><span class="line">        orderMapper.updateAmount(order.getId(), totalAmount);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> OrderDetailVO <span class="title function_">getOrderDetail</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">        <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderNotFoundException</span>(<span class="string">&quot;Order not found: &quot;</span> + orderId);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;OrderItem&gt; orderItems = orderItemMapper.findByOrderId(orderId);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> OrderDetailVO.builder()</span><br><span class="line">                .order(order)</span><br><span class="line">                .items(orderItems)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-统一异常处理"><a href="#5-2-统一异常处理" class="headerlink" title="5.2 统一异常处理"></a>5.2 统一异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(ValidationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleValidationException</span><span class="params">(ValidationException e)</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Validation error: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;VALIDATION_ERROR&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleMethodArgumentNotValid</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        List&lt;String&gt; errors = e.getBindingResult()</span><br><span class="line">                .getFieldErrors()</span><br><span class="line">                .stream()</span><br><span class="line">                .map(error -&gt; error.getField() + <span class="string">&quot;: &quot;</span> + error.getDefaultMessage())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;VALIDATION_ERROR&quot;</span>, String.join(<span class="string">&quot;, &quot;</span>, errors));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(DataIntegrityViolationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CONFLICT)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleDataIntegrityViolation</span><span class="params">(DataIntegrityViolationException e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Data integrity violation&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;DATA_CONFLICT&quot;</span>, <span class="string">&quot;Data conflict occurred&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(OptimisticLockingFailureException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CONFLICT)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleOptimisticLockingFailure</span><span class="params">(OptimisticLockingFailureException e)</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Optimistic locking failure: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;OPTIMISTIC_LOCK_ERROR&quot;</span>, <span class="string">&quot;Resource has been modified by another user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleGenericException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error occurred&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;INTERNAL_ERROR&quot;</span>, <span class="string">&quot;An unexpected error occurred&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-接口文档与验证"><a href="#5-3-接口文档与验证" class="headerlink" title="5.3 接口文档与验证"></a>5.3 接口文档与验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统一响应格式</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiResponse</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> success;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Long timestamp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResponse&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.&lt;T&gt;builder()</span><br><span class="line">                .success(<span class="literal">true</span>)</span><br><span class="line">                .code(<span class="string">&quot;SUCCESS&quot;</span>)</span><br><span class="line">                .data(data)</span><br><span class="line">                .timestamp(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResponse&lt;T&gt; <span class="title function_">error</span><span class="params">(String code, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.&lt;T&gt;builder()</span><br><span class="line">                .success(<span class="literal">false</span>)</span><br><span class="line">                .code(code)</span><br><span class="line">                .message(message)</span><br><span class="line">                .timestamp(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求参数验证</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Valid</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateUserRequest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 2, max = 20, message = &quot;用户名长度必须在2-20个字符之间&quot;)</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^[a-zA-Z0-9_\\u4e00-\\u9fa5]+$&quot;, message = &quot;用户名只能包含字母、数字、下划线和中文&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;邮箱不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 8, max = 20, message = &quot;密码长度必须在8-20个字符之间&quot;)</span></span><br><span class="line">    <span class="meta">@Pattern(</span></span><br><span class="line"><span class="meta">        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]+$&quot;,</span></span><br><span class="line"><span class="meta">        message = &quot;密码必须包含大小写字母、数字和特殊字符&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull(message = &quot;年龄不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 1, message = &quot;年龄必须大于0&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 150, message = &quot;年龄不能超过150&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;角色不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="meta">@NotBlank(message = &quot;角色名称不能为空&quot;)</span> String&gt; roles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-性能监控与优化"><a href="#5-4-性能监控与优化" class="headerlink" title="5.4 性能监控与优化"></a>5.4 性能监控与优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能监控切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerformanceMonitorAspect</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(org.springframework.web.bind.annotation.RequestMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.GetMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.PostMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.PutMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.DeleteMapping)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">monitorPerformance</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().toShortString();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">long</span> <span class="variable">executionTime</span> <span class="operator">=</span> endTime - startTime;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (executionTime &gt; <span class="number">1000</span>) &#123; <span class="comment">// 超过1秒记录警告</span></span><br><span class="line">                log.warn(<span class="string">&quot;Slow API detected: &#123;&#125; took &#123;&#125;ms&quot;</span>, methodName, executionTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;API performance: &#123;&#125; took &#123;&#125;ms&quot;</span>, methodName, executionTime);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            log.error(<span class="string">&quot;API error: &#123;&#125; took &#123;&#125;ms, error: &#123;&#125;&quot;</span>, </span><br><span class="line">                     methodName, endTime - startTime, e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库连接池监控</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceHealthIndicator</span> <span class="keyword">implements</span> <span class="title class_">HealthIndicator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Health <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> HikariDataSource) &#123;</span><br><span class="line">                <span class="type">HikariDataSource</span> <span class="variable">hikariDataSource</span> <span class="operator">=</span> (HikariDataSource) dataSource;</span><br><span class="line">                <span class="type">HikariPoolMXBean</span> <span class="variable">poolBean</span> <span class="operator">=</span> hikariDataSource.getHikariPoolMXBean();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> Health.up()</span><br><span class="line">                        .withDetail(<span class="string">&quot;database&quot;</span>, <span class="string">&quot;MySQL&quot;</span>)</span><br><span class="line">                        .withDetail(<span class="string">&quot;activeConnections&quot;</span>, poolBean.getActiveConnections())</span><br><span class="line">                        .withDetail(<span class="string">&quot;idleConnections&quot;</span>, poolBean.getIdleConnections())</span><br><span class="line">                        .withDetail(<span class="string">&quot;totalConnections&quot;</span>, poolBean.getTotalConnections())</span><br><span class="line">                        .withDetail(<span class="string">&quot;threadsAwaitingConnection&quot;</span>, poolBean.getThreadsAwaitingConnection())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection()) &#123;</span><br><span class="line">                <span class="keyword">return</span> Health.up()</span><br><span class="line">                        .withDetail(<span class="string">&quot;database&quot;</span>, connection.getMetaData().getDatabaseProductName())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down()</span><br><span class="line">                    .withDetail(<span class="string">&quot;error&quot;</span>, e.getMessage())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-高频面试综合题"><a href="#5-5-高频面试综合题" class="headerlink" title="5.5 高频面试综合题"></a>5.5 高频面试综合题</h3><p><strong>Q1: 在微服务架构中，如何设计一个高并发的订单系统？</strong></p>
<p>A: 设计高并发订单系统需要考虑以下几个方面：</p>
<p><strong>1. 架构设计：</strong></p>
<ul>
<li>使用分布式架构，订单服务、库存服务、支付服务分离</li>
<li>引入消息队列处理异步任务</li>
<li>使用Redis做缓存和分布式锁</li>
<li>数据库读写分离，分库分表</li>
</ul>
<p><strong>2. 并发控制：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">createOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;order:lock:&quot;</span> + request.getUserId();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分布式锁防止重复下单</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">locked</span> <span class="operator">=</span> redisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(lockKey, <span class="string">&quot;1&quot;</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderCreationException</span>(<span class="string">&quot;Order creation in progress&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 订单创建逻辑</span></span><br><span class="line">            <span class="keyword">return</span> processOrder(request);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redisTemplate.delete(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 性能优化：</strong></p>
<ul>
<li>使用批量操作减少数据库交互</li>
<li>合理使用缓存策略</li>
<li>异步处理非核心业务逻辑</li>
<li>数据库连接池优化</li>
</ul>
<p><strong>Q2: 如何处理分布式事务？</strong></p>
<p>A: 分布式事务处理方案：</p>
<p><strong>1. 2PC&#x2F;3PC协议：</strong></p>
<ul>
<li>强一致性，但性能较差</li>
<li>适用于对一致性要求极高的场景</li>
</ul>
<p><strong>2. TCC模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TccTransaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTccService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryCreateOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// Try阶段：预留资源</span></span><br><span class="line">        orderService.reserveOrder(request);</span><br><span class="line">        stockService.reserveStock(request.getItems());</span><br><span class="line">        paymentService.reservePayment(request.getPaymentInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirmCreateOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// Confirm阶段：确认操作</span></span><br><span class="line">        orderService.confirmOrder(request);</span><br><span class="line">        stockService.confirmStock(request.getItems());</span><br><span class="line">        paymentService.confirmPayment(request.getPaymentInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancelCreateOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// Cancel阶段：回滚操作</span></span><br><span class="line">        orderService.cancelOrder(request);</span><br><span class="line">        stockService.cancelStock(request.getItems());</span><br><span class="line">        paymentService.cancelPayment(request.getPaymentInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 消息队列最终一致性：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEventService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleOrderCreated</span><span class="params">(OrderCreatedEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 异步处理订单相关业务</span></span><br><span class="line">        notificationService.sendOrderNotification(event.getOrder());</span><br><span class="line">        inventoryService.updateInventory(event.getOrderItems());</span><br><span class="line">        pointsService.addPoints(event.getUserId(), event.getAmount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Q3: Spring Boot应用如何优化启动速度？</strong></p>
<p>A: Spring Boot启动优化策略：</p>
<p><strong>1. 依赖优化：</strong></p>
<ul>
<li>移除不必要的依赖</li>
<li>使用spring-boot-starter-web替代完整的spring-web</li>
<li>避免引入大量自动配置类</li>
</ul>
<p><strong>2. 配置优化：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">lazy-initialization:</span> <span class="literal">true</span>  <span class="comment"># 启用懒加载</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">none</span>           <span class="comment"># 禁用DDL自动生成</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">false</span>            <span class="comment"># 禁用SQL日志</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span>           <span class="comment"># 生产环境禁用热重启</span></span><br></pre></td></tr></table></figure>

<p><strong>3. JVM优化：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockExperimentalVMOptions </span><br><span class="line">     -XX:+UseZGC </span><br><span class="line">     -XX:+UseTransparentHugePages</span><br><span class="line">     -XX:MaxMetaspaceSize=256m</span><br><span class="line">     -Xms512m -Xmx1024m</span><br><span class="line">     -jar application.jar</span><br></pre></td></tr></table></figure>

<p><strong>4. 代码优化：</strong></p>
<ul>
<li>使用@Lazy注解延迟Bean初始化</li>
<li>避免在@PostConstruct中执行耗时操作</li>
<li>合理使用@ConditionalOn*注解</li>
</ul>
<p>好的，这是一份详细的解释，我们来逐个分析这些 Java 虚拟机（JVM）参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -XX:+UseTransparentHugePages -XX:MaxMetaspaceSize=256m -Xms512m -Xmx1024m -jar application.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>java</code>: 这是启动 Java 程序的命令。</li>
</ul>
<hr>
<h3 id="内存管理和垃圾回收"><a href="#内存管理和垃圾回收" class="headerlink" title="内存管理和垃圾回收"></a>内存管理和垃圾回收</h3><p>这部分参数主要用于优化 JVM 的内存使用和垃圾回收机制，以获得更好的性能。</p>
<ul>
<li><code>-XX:+UnlockExperimentalVMOptions</code>: 这个参数是用来<strong>解锁实验性（experimental）的 JVM 选项</strong>。ZGC 曾经是实验性功能，所以需要这个参数才能使用。</li>
<li><code>-XX:+UseZGC</code>: 这条命令是启用 <strong>Z 垃圾回收器（Z Garbage Collector）</strong>。ZGC 是一种为<strong>超大堆内存</strong>（从几GB到几十TB）设计的、<strong>低延迟</strong>的垃圾回收器。它的主要目标是在垃圾回收时，尽量减少应用程序的停顿时间，这对于需要极低延迟的应用程序非常重要。</li>
<li><code>-XX:+UseTransparentHugePages</code>: 这个参数开启了<strong>透明大页（Transparent Huge Pages）的支持。在操作系统层面，通常内存是以 4KB 的小页来管理的。而大页（通常是 2MB 或 1GB）可以减少 CPU 在内存管理上的开销，从而提升性能，尤其对于内存占用较大</strong>的应用效果更明显。</li>
<li><code>-XX:MaxMetaspaceSize=256m</code>: 这个参数设置了<strong>元空间（Metaspace）的最大大小为 256MB</strong>。元空间是 JVM 存储类的元数据（如类的名称、方法、字段等信息）的地方。在 Java 8 之后，它取代了之前的“永久代”（PermGen）。</li>
<li><code>-Xms512m</code>: 这条命令设定了 <strong>JVM 堆的初始内存为 512MB</strong>。堆是用来存放 Java 对象的地方。<code>-Xms</code> 决定了 JVM 启动时会申请的最小内存。</li>
<li><code>-Xmx1024m</code>: 这条命令设定了 <strong>JVM 堆的最大内存为 1024MB（即 1GB）</strong>。这是 JVM 运行时可以使用的最大内存。当堆内存用尽时，JVM 会触发垃圾回收，如果依然不足，就会抛出 <code>OutOfMemoryError</code>。</li>
</ul>
<hr>
<p>好的，我们来更详细地聊聊 JVM 堆内存的结构，特别是分代设计和具体的划分比例。</p>
<hr>
<h3 id="堆内存的传统分代结构"><a href="#堆内存的传统分代结构" class="headerlink" title="堆内存的传统分代结构"></a>堆内存的传统分代结构</h3><p>在绝大多数的垃圾回收器中（例如 CMS、G1 之前的串行和并行 GC），堆内存被分为以下几个代（Generation）：</p>
<h4 id="1-年轻代（Young-Generation）"><a href="#1-年轻代（Young-Generation）" class="headerlink" title="1. 年轻代（Young Generation）"></a>1. 年轻代（Young Generation）</h4><p><strong>年轻代是新对象的诞生地。</strong> 绝大多数对象，比如局部变量创建的临时对象，都会在年轻代被创建。年轻代被设计成较小且垃圾回收频率高的区域。</p>
<ul>
<li><strong>Eden 区</strong>：这是年轻代的主要部分，新创建的对象首先被分配到这里。</li>
<li><strong>Survivor 区（幸存者区）</strong>：有两个大小相等的 Survivor 区，通常命名为 <strong>S0</strong> 和 <strong>S1</strong>。它们的作用是保存每次垃圾回收后，还存活的对象。</li>
</ul>
<p><strong>划分比例</strong></p>
<p>在默认情况下，年轻代内部的划分比例通常是：</p>
<ul>
<li><strong>Eden 区 : S0 区 : S1 区 &#x3D; 8 : 1 : 1</strong></li>
</ul>
<p>这个比例可以通过 JVM 参数进行调整，比如使用 <code>-XX:SurvivorRatio=8</code>。这意味着 Eden 区的大小是单个 Survivor 区的 8 倍。</p>
<h4 id="2-老年代（Old-Generation）"><a href="#2-老年代（Old-Generation）" class="headerlink" title="2. 老年代（Old Generation）"></a>2. 老年代（Old Generation）</h4><p><strong>老年代用于存放生命周期较长的对象。</strong> 当一个对象在年轻代经过多次垃圾回收（通常是 15 次，这个次数也可以通过 <code>-XX:MaxTenuringThreshold</code> 参数调整）后仍然存活，或者年轻代放不下的大对象，就会被“晋升”到老年代。</p>
<p>老年代的垃圾回收频率远低于年轻代，但每次回收的开销更大。</p>
<p><strong>划分比例</strong></p>
<p>堆内存中，年轻代和老年代的默认划分比例通常是：</p>
<ul>
<li><strong>年轻代 : 老年代 &#x3D; 1 : 2</strong></li>
</ul>
<p>例如，如果你设置 <code>-Xms1200m -Xmx1200m</code>，那么年轻代大约是 400MB，老年代大约是 800MB。这个比例可以通过 <code>-XX:NewRatio</code> 参数来调整。例如，<code>-XX:NewRatio=2</code> 表示老年代与年轻代的大小比值为 2:1。</p>
<hr>
<h3 id="垃圾回收过程（以-Minor-GC-为例）"><a href="#垃圾回收过程（以-Minor-GC-为例）" class="headerlink" title="垃圾回收过程（以 Minor GC 为例）"></a>垃圾回收过程（以 Minor GC 为例）</h3><p>理解了这些区域，我们再来看看垃圾回收是怎么进行的：</p>
<ol>
<li>当 <strong>Eden 区</strong>满了，会触发一次 <strong>Minor GC</strong>。</li>
<li>Minor GC 会检查 Eden 区和其中一个 Survivor 区（比如 S0）。</li>
<li>它会将所有还<strong>存活的对象</strong>复制到另一个空的 Survivor 区（比如 S1）。</li>
<li>同时，那些<strong>不再被引用的对象</strong>则会被清理。</li>
<li>所有被复制到 S1 区的对象，它们的年龄（<code>age</code>）会加一。</li>
<li>下一次 Minor GC 发生时，同样会扫描 Eden 区和 S1 区，将存活对象复制到 S0 区，清空 Eden 和 S1 区，并增加对象的年龄。</li>
<li>当对象的年龄达到某个阈值时，它就会被<strong>晋升</strong>到老年代。</li>
</ol>
<h3 id="现代垃圾回收器（如-G1-和-ZGC）"><a href="#现代垃圾回收器（如-G1-和-ZGC）" class="headerlink" title="现代垃圾回收器（如 G1 和 ZGC）"></a>现代垃圾回收器（如 G1 和 ZGC）</h3><p>值得注意的是，像 <strong>G1 垃圾回收器</strong>已经打破了这种严格的分代比例。它将堆划分为一个个大小相等的<strong>区域（Region）</strong>，每个区域都可以是 Eden、Survivor 或者老年代。G1 能够更智能地选择要回收的区域，从而在保证低停顿的同时，提高吞吐量。</p>
<p>而 <strong>ZGC</strong> 则更进一步，如我之前所说，它<strong>完全没有年轻代、老年代的概念</strong>，而是通过着色指针和读屏障技术，在不中断应用程序的情况下并发地进行垃圾回收，实现了更低的停顿。</p>
<p>因此，当你使用 ZGC 时，传统的分代比例就不适用了。不过，了解传统的分代结构对于理解 Java 内存管理的基础依然非常重要。</p>
<p>以下是针对Spring Cloud Alibaba及其他分布式技术的深度补充，包含实现原理和核心组件的详细说明：</p>
<hr>
<h2 id="六、Spring-Cloud与分布式技术详解"><a href="#六、Spring-Cloud与分布式技术详解" class="headerlink" title="六、Spring Cloud与分布式技术详解"></a>六、Spring Cloud与分布式技术详解</h2><h3 id="6-1-Spring-Cloud-Alibaba核心组件"><a href="#6-1-Spring-Cloud-Alibaba核心组件" class="headerlink" title="6.1 Spring Cloud Alibaba核心组件"></a>6.1 Spring Cloud Alibaba核心组件</h3><h4 id="Nacos深度解析"><a href="#Nacos深度解析" class="headerlink" title="Nacos深度解析"></a>Nacos深度解析</h4><p><strong>服务发现原理</strong>：</p>
<ol>
<li><p><strong>注册流程</strong>：</p>
<ul>
<li>服务启动时向Nacos Server发送注册请求（HTTP&#x2F;GRPC）</li>
<li>注册信息包含元数据、健康检查方式（TCP&#x2F;HTTP&#x2F;MySQL）</li>
<li>客户端本地缓存服务列表（故障转移）</li>
</ul>
</li>
<li><p><strong>健康检查机制</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nacos健康检查配置示例</span></span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        health-check-enabled: <span class="literal">true</span></span><br><span class="line">        health-check-interval: 10s</span><br><span class="line">        health-check-timeout: 5s</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>配置中心实现</strong>：</p>
<ul>
<li><strong>长轮询机制</strong>（Push+Pull混合模式）：<ul>
<li>客户端发起长轮询请求（默认30秒超时）</li>
<li>服务端配置变更时立即响应</li>
<li>客户端收到变更后拉取最新配置</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态配置刷新示例</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.config.item&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Sentinel核心原理"><a href="#Sentinel核心原理" class="headerlink" title="Sentinel核心原理"></a>Sentinel核心原理</h4><p><strong>流量控制规则</strong>：</p>
<ul>
<li><strong>滑动窗口算法</strong>：<ul>
<li>统计周期（1秒）分为多个格子（如20个50ms）</li>
<li>实时淘汰过期格子数据</li>
<li>QPS计算基于当前窗口总请求数</li>
</ul>
</li>
</ul>
<p><strong>熔断降级策略</strong>：</p>
<table>
<thead>
<tr>
<th>策略类型</th>
<th>计算公式</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>慢调用比例</td>
<td>响应时间 &gt; RT阈值 &amp;&amp; 比例 &gt; 阈值</td>
<td>接口性能波动</td>
</tr>
<tr>
<td>异常比例</td>
<td>异常数 &#x2F; 请求数 &gt; 阈值</td>
<td>依赖服务不稳定</td>
</tr>
<tr>
<td>异常数</td>
<td>异常数 &gt; 阈值（时间窗口内）</td>
<td>关键业务熔断</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sentinel规则持久化到Nacos示例</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRules</span><span class="params">()</span> &#123;</span><br><span class="line">    FlowRuleManager.register2Property(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NacosDataSourceWrapper</span>(</span><br><span class="line">            <span class="string">&quot;nacos-server:8848&quot;</span>, <span class="string">&quot;sentinel-flow-rules&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> List&lt;FlowRule&gt; <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> JSON.parseArray(source, FlowRule.class);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RocketMQ集成"><a href="#RocketMQ集成" class="headerlink" title="RocketMQ集成"></a>RocketMQ集成</h4><p><strong>消息轨迹追踪</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RocketMQTemplate <span class="title function_">rocketMQTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RocketMQTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RocketMQTemplate</span>();</span><br><span class="line">    template.setProducer(<span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;producer_group&quot;</span>) &#123;&#123;</span><br><span class="line">        setVipChannelEnabled(<span class="literal">false</span>);</span><br><span class="line">        setTraceDispatcher(<span class="keyword">new</span> <span class="title class_">AsyncTraceDispatcher</span>(<span class="string">&quot;trace_topic&quot;</span>));</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者轨迹追踪</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">    topic = &quot;order_topic&quot;, </span></span><br><span class="line"><span class="meta">    consumerGroup = &quot;order_consumer&quot;,</span></span><br><span class="line"><span class="meta">    enableMsgTrace = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-分布式事务增强（Seata原理）"><a href="#6-2-分布式事务增强（Seata原理）" class="headerlink" title="6.2 分布式事务增强（Seata原理）"></a>6.2 分布式事务增强（Seata原理）</h3><h4 id="AT模式工作流程"><a href="#AT模式工作流程" class="headerlink" title="AT模式工作流程"></a>AT模式工作流程</h4><ol>
<li><strong>一阶段</strong>：<ul>
<li>解析SQL生成前后镜像</li>
<li>注册分支事务到TC（Transaction Coordinator）</li>
<li>本地事务提交前记录undo_log</li>
</ul>
</li>
<li><strong>二阶段</strong>：<ul>
<li>成功：异步删除undo_log</li>
<li>失败：根据undo_log补偿（反向SQL）</li>
</ul>
</li>
</ol>
<p><strong>undo_log表示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="TCC模式最佳实践"><a href="#TCC模式最佳实践" class="headerlink" title="TCC模式最佳实践"></a>TCC模式最佳实践</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 账户服务TCC接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountTccService</span> &#123;</span><br><span class="line">    <span class="meta">@TwoPhaseBusinessAction(</span></span><br><span class="line"><span class="meta">        name = &quot;deduct&quot;,</span></span><br><span class="line"><span class="meta">        commitMethod = &quot;confirmDeduct&quot;,</span></span><br><span class="line"><span class="meta">        rollbackMethod = &quot;cancelDeduct&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">prepareDeduct</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@BusinessActionContextParameter(paramName = &quot;userId&quot;)</span> String userId,</span></span><br><span class="line"><span class="params">        <span class="meta">@BusinessActionContextParameter(paramName = &quot;amount&quot;)</span> BigDecimal amount</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">confirmDeduct</span><span class="params">(BusinessActionContext context)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancelDeduct</span><span class="params">(BusinessActionContext context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务调用方</span></span><br><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 冻结库存</span></span><br><span class="line">    inventoryTccService.prepare(<span class="literal">null</span>, order.getProductId(), order.getCount());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 预扣款</span></span><br><span class="line">    accountTccService.prepareDeduct(order.getUserId(), order.getAmount());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 创建订单</span></span><br><span class="line">    orderMapper.insert(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-分布式缓存深度优化"><a href="#6-3-分布式缓存深度优化" class="headerlink" title="6.3 分布式缓存深度优化"></a>6.3 分布式缓存深度优化</h3><h4 id="Redis多级缓存架构"><a href="#Redis多级缓存架构" class="headerlink" title="Redis多级缓存架构"></a>Redis多级缓存架构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地缓存+Caffeine+Redis实现</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CaffeineRedisCacheManager</span>(</span><br><span class="line">        Caffeine.newBuilder()</span><br><span class="line">            .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">            .maximumSize(<span class="number">1000</span>),</span><br><span class="line">        RedisCacheWriter.nonLockingRedisCacheWriter(factory),</span><br><span class="line">        RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            .entryTtl(Duration.ofHours(<span class="number">1</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 热点Key探测</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getWithHotspotProtection</span><span class="params">(String key, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 本地缓存查询</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> localCache.getIfPresent(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) <span class="keyword">return</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. Redis集群查询（带随机过期时间）</span></span><br><span class="line">    value = redisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        localCache.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 分布式锁防击穿</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span> + key;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (redisLock.tryLock(lockKey, <span class="number">3</span>, <span class="number">30</span>)) &#123;</span><br><span class="line">            <span class="comment">// 4. 数据库查询</span></span><br><span class="line">            value = databaseLoader.load(key);</span><br><span class="line">            redisTemplate.opsForValue().set(</span><br><span class="line">                key, value, </span><br><span class="line">                ThreadLocalRandom.current().nextInt(<span class="number">30</span>) + <span class="number">30</span>, </span><br><span class="line">                TimeUnit.MINUTES</span><br><span class="line">            );</span><br><span class="line">            localCache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-消息队列高级特性"><a href="#6-4-消息队列高级特性" class="headerlink" title="6.4 消息队列高级特性"></a>6.4 消息队列高级特性</h3><h4 id="RocketMQ事务消息"><a href="#RocketMQ事务消息" class="headerlink" title="RocketMQ事务消息"></a>RocketMQ事务消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务消息生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTransactionMessage</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="type">TransactionSendResult</span> <span class="variable">result</span> <span class="operator">=</span> rocketMQTemplate.sendMessageInTransaction(</span><br><span class="line">        <span class="string">&quot;order-tx-group&quot;</span>,</span><br><span class="line">        MessageBuilder.withPayload(order)</span><br><span class="line">            .setHeader(RocketMQHeaders.TRANSACTION_ID, order.getId())</span><br><span class="line">            .build(),</span><br><span class="line">        order</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地事务执行器</span></span><br><span class="line"><span class="meta">@RocketMQTransactionListener(txProducerGroup = &quot;order-tx-group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">RocketMQLocalTransactionListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> (Order) arg;</span><br><span class="line">            orderService.createOrder(order); <span class="comment">// 本地事务</span></span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> msg.getHeaders().get(<span class="string">&quot;TRANSACTION_ID&quot;</span>).toString();</span><br><span class="line">        <span class="keyword">return</span> orderService.exists(orderId) ? </span><br><span class="line">            RocketMQLocalTransactionState.COMMIT : </span><br><span class="line">            RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Kafka精确一次语义"><a href="#Kafka精确一次语义" class="headerlink" title="Kafka精确一次语义"></a>Kafka精确一次语义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ProducerFactory&lt;String, String&gt; <span class="title function_">producerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    configs.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, <span class="literal">true</span>);</span><br><span class="line">    configs.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, <span class="string">&quot;tx-producer-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultKafkaProducerFactory</span>&lt;&gt;(configs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ConsumerFactory&lt;String, String&gt; <span class="title function_">consumerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    configs.put(ConsumerConfig.ISOLATION_LEVEL_CONFIG, <span class="string">&quot;read_committed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultKafkaConsumerFactory</span>&lt;&gt;(configs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务性消费</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &quot;order-topic&quot;)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(ConsumerRecord&lt;String, String&gt; record)</span> &#123;</span><br><span class="line">    <span class="type">OrderEvent</span> <span class="variable">event</span> <span class="operator">=</span> parseEvent(record.value());</span><br><span class="line">    orderService.process(event); <span class="comment">// 数据库操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、云原生支持（新增）"><a href="#七、云原生支持（新增）" class="headerlink" title="七、云原生支持（新增）"></a>七、云原生支持（新增）</h2><h3 id="7-1-Kubernetes集成方案"><a href="#7-1-Kubernetes集成方案" class="headerlink" title="7.1 Kubernetes集成方案"></a>7.1 Kubernetes集成方案</h3><h4 id="服务发现适配"><a href="#服务发现适配" class="headerlink" title="服务发现适配"></a>服务发现适配</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Nacos与K8s Service集成</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">kubernetes:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">all-namespaces:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">$&#123;NACOS_HOST:nacos-headless&#125;:$&#123;NACOS_PORT:8848&#125;</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">$&#123;POD_NAMESPACE:default&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置管理方案"><a href="#配置管理方案" class="headerlink" title="配置管理方案"></a>配置管理方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多配置源加载（K8s ConfigMap + Nacos）</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;configFromNacos&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nacosConfig;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;configFromK8s&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String k8sConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-Service-Mesh整合"><a href="#7-2-Service-Mesh整合" class="headerlink" title="7.2 Service Mesh整合"></a>7.2 Service Mesh整合</h3><h4 id="Istio流量治理"><a href="#Istio流量治理" class="headerlink" title="Istio流量治理"></a>Istio流量治理</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 金丝雀发布策略</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">order-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">order-service</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">            <span class="attr">host:</span> <span class="string">order-service</span></span><br><span class="line">            <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">          <span class="attr">weight:</span> <span class="number">90</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">            <span class="attr">host:</span> <span class="string">order-service</span></span><br><span class="line">            <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">          <span class="attr">weight:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、性能优化深度实践"><a href="#八、性能优化深度实践" class="headerlink" title="八、性能优化深度实践"></a>八、性能优化深度实践</h2><h3 id="8-1-全链路压测方案"><a href="#8-1-全链路压测方案" class="headerlink" title="8.1 全链路压测方案"></a>8.1 全链路压测方案</h3><h4 id="影子库表配置"><a href="#影子库表配置" class="headerlink" title="影子库表配置"></a>影子库表配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ShardingSphere影子库配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">ds-real,ds-shadow</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="attr">shadow:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">data-sources:</span></span><br><span class="line">          <span class="attr">shadow-data-source:</span></span><br><span class="line">            <span class="attr">source-data-source-name:</span> <span class="string">ds-real</span></span><br><span class="line">            <span class="attr">shadow-data-source-name:</span> <span class="string">ds-shadow</span></span><br><span class="line">        <span class="attr">tables:</span></span><br><span class="line">          <span class="attr">t_order:</span></span><br><span class="line">            <span class="attr">shadow-algorithm-names:</span> [<span class="string">simple-hint-algorithm</span>]</span><br></pre></td></tr></table></figure>

<h4 id="流量染色标记"><a href="#流量染色标记" class="headerlink" title="流量染色标记"></a>流量染色标记</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ThreadLocal传递压测标记</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PressureTestContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; FLAG = ThreadLocal.withInitial(() -&gt; <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">markPressureTest</span><span class="params">()</span> &#123;</span><br><span class="line">        FLAG.set(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPressureTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FLAG.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyBatis拦截器自动路由</span></span><br><span class="line"><span class="meta">@Intercepts(@Signature(type=Executor.class, method=&quot;update&quot;, args=&#123;MappedStatement.class,Object.class&#125;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShadowDbInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (PressureTestContext.isPressureTest()) &#123;</span><br><span class="line">            RoutingContext.setShadowDataSource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h4 id="1-Spring-Cloud-体系"><a href="#1-Spring-Cloud-体系" class="headerlink" title="1. Spring Cloud 体系"></a><strong>1. Spring Cloud 体系</strong></h4><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h5><p>Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的<strong>规范和解决方案的集合</strong>。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。</p>
<h5 id="Netflix-OSS-常用组件（部分进入维护模式）"><a href="#Netflix-OSS-常用组件（部分进入维护模式）" class="headerlink" title="Netflix OSS 常用组件（部分进入维护模式）"></a><strong>Netflix OSS 常用组件（部分进入维护模式）</strong></h5><ul>
<li><strong>服务注册与发现 (Service Discovery): Eureka</strong><ul>
<li><strong>作用</strong>: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。</li>
<li><strong>使用</strong>: 服务端添加 <code>spring-cloud-starter-netflix-eureka-server</code> 依赖，并使用 <code>@EnableEurekaServer</code> 注解。客户端添加 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖，并配置 Eureka Server 地址。</li>
</ul>
</li>
<li><strong>服务调用与负载均衡 (RPC &amp; Load Balancing): OpenFeign + Ribbon</strong><ul>
<li><strong>作用</strong>: Feign 让远程服务调用变得像调用本地方法一样简单。开发者只需定义一个接口，并使用 <code>@FeignClient</code> 注解，即可完成对远程服务的调用。Ribbon（现已被 Spring Cloud LoadBalancer 替代）则提供了客户端负载均衡能力，当从 Eureka 获取到多个服务实例地址时，Ribbon 会根据配置的策略（如轮询、随机）选择一个实例进行调用。</li>
<li><strong>使用</strong>: 添加 <code>spring-cloud-starter-openfeign</code> 依赖，在启动类上加 <code>@EnableFeignClients</code>，创建接口并使用 <code>@FeignClient(&quot;service-name&quot;)</code> 注解。</li>
</ul>
</li>
<li><strong>熔断与降级 (Circuit Breaker): Hystrix</strong><ul>
<li><strong>作用</strong>: 当某个下游服务出现故障或响应缓慢时，为了防止故障在系统中蔓延（即“服务雪崩”），熔断器会快速失败，暂时切断对该服务的调用。同时，可以执行一个预定义的降级逻辑（Fallback），例如返回一个缓存的、默认的或友好的提示信息。</li>
<li><strong>状态</strong>: Hystrix 已进入维护模式，官方推荐使用 Resilience4j 或其他替代方案。</li>
</ul>
</li>
<li><strong>API 网关 (API Gateway): Zuul</strong><ul>
<li><strong>作用</strong>: 作为系统的统一入口，API 网关负责请求路由、协议转换、权限校验、流量控制、日志监控等。所有外部请求都先经过网关，再由网关分发到后端的各个微服务。</li>
<li><strong>状态</strong>: Zuul 1.x 已进入维护模式，官方推荐使用 Spring Cloud Gateway。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Spring-Cloud-Alibaba-详解"><a href="#Spring-Cloud-Alibaba-详解" class="headerlink" title="Spring Cloud Alibaba 详解"></a><strong>Spring Cloud Alibaba 详解</strong></h5><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案，是 Spring Cloud 体系的重要实现。它集成了阿里巴巴开源的优秀组件，为开发者提供了更符合国内技术生态的选择。</p>
<ul>
<li><strong>服务注册与发现 &amp; 分布式配置中心: Nacos</strong><ul>
<li><strong>作用</strong>: Nacos (Naming and Configuration Service) 是一个功能丰富的平台，完美整合了<strong>服务注册发现</strong>和<strong>配置管理</strong>两大核心功能。<ul>
<li><strong>服务发现</strong>: 与 Eureka 类似，提供服务注册、发现和健康检查。但 Nacos 支持基于 DNS 和 RPC 的服务发现，并提供更实时的健康检查机制。</li>
<li><strong>配置管理</strong>: 可以作为分布式配置中心，对所有微服务的配置进行集中化管理。支持配置的热更新，即修改配置后无需重启服务即可生效。还支持配置的版本管理、灰度发布等高级功能。</li>
</ul>
</li>
<li><strong>使用</strong>:<ol>
<li>引入 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 和 <code>spring-cloud-starter-alibaba-nacos-config</code> 依赖。</li>
<li>在 <code>bootstrap.properties</code> (或 <code>.yml</code>) 文件中配置 Nacos 服务器地址和应用名。</li>
<li>使用 <code>@Value</code> 或 <code>@ConfigurationProperties</code> 注解即可动态获取和刷新配置。</li>
</ol>
</li>
</ul>
</li>
<li><strong>熔断、降级与流量控制: Sentinel</strong><ul>
<li><strong>作用</strong>: Sentinel 是面向分布式服务架构的“流量的守护者”，以流量为切入点，从<strong>流量控制、熔断降级、系统负载保护</strong>等多个维度保护服务的稳定性。相较于 Hystrix，Sentinel 功能更强大，提供了可视化的监控和配置平台，并且支持热点参数限流等精细化控制。</li>
<li><strong>核心概念</strong>:<ul>
<li><strong>资源 (Resource)</strong>: Sentinel 中一切皆资源，可以是一个方法、一段代码或一个服务 URL。</li>
<li><strong>规则 (Rule)</strong>: 定义如何保护资源，包括流控规则、降级规则、系统保护规则等。</li>
</ul>
</li>
<li><strong>使用</strong>:<ol>
<li>引入 <code>spring-cloud-starter-alibaba-sentinel</code> 依赖。</li>
<li>配置 Sentinel 控制台地址。</li>
<li>通过 <code>@SentinelResource</code> 注解来定义资源，并指定 Fallback (降级逻辑) 和 BlockHandler (流控&#x2F;熔断逻辑)。</li>
</ol>
</li>
</ul>
</li>
<li><strong>分布式事务解决方案: Seata</strong><ul>
<li><strong>作用</strong>: Seata 是一个开源的分布式事务解决方案，提供了高性能且易于使用的分布式事务服务。它支持多种事务模式，包括 AT（自动补偿）、TCC、Saga 和 XA 模式，旨在解决微服务架构下的数据一致性问题。</li>
<li><strong>使用</strong>: 引入 <code>spring-cloud-starter-alibaba-seata</code> 依赖，配置 Seata Server 地址，并使用 <code>@GlobalTransactional</code> 注解开启全局事务。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-分布式ID：雪花算法（Snowflake）"><a href="#2-分布式ID：雪花算法（Snowflake）" class="headerlink" title="2. 分布式ID：雪花算法（Snowflake）"></a><strong>2. 分布式ID：雪花算法（Snowflake）</strong></h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>Snowflake 是 Twitter 开源的一种分布式 ID 生成算法，它能生成一个 64 位的 <code>long</code> 型数字作为全局唯一 ID。这个 64 位的 ID 由四部分构成：</p>
<ul>
<li><strong>1位符号位</strong>: 最高位，固定为0，表示正数，无实际意义。</li>
<li><strong>41位时间戳 (Timestamp)</strong>: 精确到毫秒级，是 <code>(当前时间戳 - 起始时间戳)</code> 的差值。41位可以表示 (241−1) 毫秒，大约可以使用 69 年。</li>
<li><strong>10位工作机器ID (Worker ID)</strong>: 这 10 位可以被灵活划分，例如前 5 位代表数据中心 ID (Datacenter ID)，后 5 位代表机器 ID (Machine ID)。这样总共可以支持 210&#x3D;1024 台机器。</li>
<li><strong>12位序列号 (Sequence)</strong>: 表示在同一毫秒内，同一台机器上生成的 ID 序列号。12位意味着每台机器每毫秒可以生成 212&#x3D;4096 个不同的 ID。</li>
</ul>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h5><ul>
<li><strong>全局唯一</strong>: 通过时间戳、机器 ID 和序列号的组合，可以保证在分布式环境下的 ID 唯一性。</li>
<li><strong>趋势递增</strong>: 由于时间戳在高位，所以生成的 ID 整体上是按时间趋势递增的，这对于数据库索引（特别是 B+树）非常友好，可以减少页分裂，提高插入性能。</li>
<li><strong>高性能</strong>: ID 在本地生成，不依赖任何外部服务（如数据库或 Redis），生成效率极高。</li>
<li><strong>高可用</strong>: 算法本身不依赖网络，部署简单，具有很高的可用性。</li>
</ul>
<h5 id="面试题：“雪花算法有时钟回拨问题，如何解决？”"><a href="#面试题：“雪花算法有时钟回拨问题，如何解决？”" class="headerlink" title="面试题：“雪花算法有时钟回拨问题，如何解决？”"></a><strong>面试题：“雪花算法有时钟回拨问题，如何解决？”</strong></h5><p>回答要点:</p>
<p>时钟回拨是指服务器时间被同步到一个过去的时间点。如果算法不做处理，可能会生成重复的 ID。解决方案通常是：在生成 ID 时，记录上一次生成 ID 时所使用的时间戳。当发现当前时间戳小于上次记录的时间戳时，就意味着发生了时钟回拨。</p>
<ul>
<li><strong>方案一（拒绝服务）</strong>: 直接抛出异常，拒绝生成 ID，等待时钟恢复正常。这种方案简单，但会暂时影响可用性，适合对 ID 连续性要求不高的场景。</li>
<li><strong>方案二（等待追赶）</strong>: 如果回拨幅度很小（比如几毫秒），程序可以 <code>while(currentTime &lt; lastTimestamp)</code> 这样自旋等待，直到当前时间追赶上上次的时间戳。这会造成短暂的线程阻塞。</li>
<li><strong>方案三（使用备用位）</strong>: 一些改进版的雪花算法会预留几位作为扩展位，当发生时钟回拨时，在这几位上做自增，从而在短时间回拨内仍能生成不同的 ID。（这种方案实现较为复杂）</li>
<li><strong>业界实践（美团 Leaf）</strong>: 在发生时钟回拨时，切换到另一种备用 ID 生成策略（如号段模式），或者直接报错。</li>
</ul>
<hr>
<h4 id="3-RBAC（基于角色的访问控制）"><a href="#3-RBAC（基于角色的访问控制）" class="headerlink" title="3. RBAC（基于角色的访问控制）"></a><strong>3. RBAC（基于角色的访问控制）</strong></h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>RBAC (Role-Based Access Control) 是一种主流且灵活的权限管理模型。它的核心思想是在 <strong>用户 (User)</strong> 和 <strong>权限 (Permission)</strong> 之间引入一个中间层——<strong>角色 (Role)</strong>。权限不再直接授予用户，而是授予角色；然后将角色分配给用户。这样，用户与权限实现了解耦，当需要修改大量用户的权限时，只需修改他们共同拥有的角色的权限即可，极大地简化了权限管理和维护。</p>
<h5 id="核心三要素"><a href="#核心三要素" class="headerlink" title="核心三要素"></a><strong>核心三要素</strong></h5><ul>
<li><strong>用户 (User)</strong>: 系统操作的主体。</li>
<li><strong>角色 (Role)</strong>: 权限的集合，代表了一组特定的职责或身份，如“管理员”、“文章编辑”、“普通会员”。</li>
<li><strong>权限 (Permission)</strong>: 对系统中特定资源进行特定操作的许可。通常用一个字符串表示，如 <code>user:create</code>、<code>order:delete</code>、<code>article:publish</code>。</li>
</ul>
<h5 id="面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”"><a href="#面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”" class="headerlink" title="面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”"></a><strong>面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”</strong></h5><p>回答要点:</p>
<p>一个基础的 RBAC 模型至少需要五张表：</p>
<ul>
<li><strong>用户表 (t_user)</strong>: 存储用户信息。<ul>
<li><code>user_id</code> (主键), <code>username</code>, <code>password</code>, …</li>
</ul>
</li>
<li><strong>角色表 (t_role)</strong>: 存储角色信息。<ul>
<li><code>role_id</code> (主键), <code>role_name</code> (角色名, 如”管理员”), <code>role_key</code> (角色标识, 如”admin”), …</li>
</ul>
</li>
<li><strong>权限表 (t_permission)</strong>: 存储具体的权限点信息。<ul>
<li><code>permission_id</code> (主键), <code>permission_name</code> (权限名称, 如“新增用户”), <code>permission_code</code> (权限标识, 如 <code>user:add</code>), <code>parent_id</code> (用于菜单层级), …</li>
</ul>
</li>
<li><strong>用户-角色关联表 (t_user_role)</strong>: 存储用户和角色的多对多关系。<ul>
<li><code>user_id</code> (外键), <code>role_id</code> (外键)。(主键是 <code>user_id</code> 和 <code>role_id</code> 的联合主键)</li>
</ul>
</li>
<li><strong>角色-权限关联表 (t_role_permission)</strong>: 存储角色和权限的多对多关系。<ul>
<li><code>role_id</code> (外键), <code>permission_id</code> (外键)。(主键是 <code>role_id</code> 和 <code>permission_id</code> 的联合主键)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-Redis-进阶详解"><a href="#4-Redis-进阶详解" class="headerlink" title="4. Redis 进阶详解"></a><strong>4. Redis 进阶详解</strong></h4><h5 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h5><ul>
<li><strong>基于内存</strong>: Redis 是一个内存数据结构存储系统，所有数据都存放在内存中，因此读写速度极快。</li>
<li><strong>单线程模型</strong>: Redis 的核心网络模型处理客户端请求是单线程的。这避免了多线程环境下的上下文切换和锁竞争带来的开销。（注意：Redis 6.0 之后引入了多线程来处理 I&#x2F;O，但执行命令的核心仍然是单线程）。</li>
<li><strong>IO多路复用</strong>: 单线程能实现高性能的关键在于它使用了 IO 多路复用技术（如 Linux 下的 epoll）。该技术允许单个线程同时监听多个网络连接上的 IO 事件，当某个连接准备好读或写时，才去处理它，极大地提高了并发处理能力。</li>
<li><strong>丰富的数据类型</strong>: 支持 String, Hash, List, Set, Sorted Set, Bitmap, HyperLogLog, GEO 等多种数据结构。</li>
</ul>
<h5 id="缓存三大问题与解决方案"><a href="#缓存三大问题与解决方案" class="headerlink" title="缓存三大问题与解决方案"></a><strong>缓存三大问题与解决方案</strong></h5><ul>
<li><strong>缓存穿透</strong>:<ul>
<li><strong>问题</strong>: 客户端查询一个数据库和缓存中<strong>都</strong>不存在的数据。这导致每次请求都会绕过缓存，直接打到数据库上，当有大量此类请求时，会给数据库带来巨大压力。</li>
<li><strong>解决</strong>:<ol>
<li><strong>缓存空对象</strong>: 当从数据库查询不到数据时，也在缓存中存入一个特殊的空值（如 <code>null</code> 或特定字符串），并设置一个较短的过期时间。</li>
<li><strong>布隆过滤器 (Bloom Filter)</strong>: 在访问缓存之前，先通过布隆过滤器判断 key 是否<strong>可能</strong>存在。布隆过滤器可以高效地判断一个元素<strong>一定不存在</strong>，从而在第一层就拦截掉大量无效请求。</li>
</ol>
</li>
</ul>
</li>
<li><strong>缓存击穿</strong>:<ul>
<li><strong>问题</strong>: 某个<strong>热点 Key</strong> 在某一时刻突然失效，而此时恰好有大量的并发请求访问这个 Key，这些请求会同时穿透缓存，直接打到数据库上，可能导致数据库瞬间崩溃。</li>
<li><strong>解决</strong>:<ol>
<li><strong>设置热点 Key 永不过期</strong>: 对于一些访问极其频繁且数据相对固定的热点数据，可以考虑不设置过期时间，通过后台任务定时更新。</li>
<li><strong>使用分布式锁</strong>: 在查询数据库之前，先获取一个该 Key 对应的分布式锁。只有第一个获取到锁的线程才能去查询数据库并回写缓存，其他线程则等待或直接返回。</li>
</ol>
</li>
</ul>
</li>
<li><strong>缓存雪崩</strong>:<ul>
<li><strong>问题</strong>: 大量的缓存 Key 在<strong>同一时间集中失效</strong>（例如，在应用启动时缓存了大量数据，并设置了相同的过期时间），导致所有请求都瞬间涌向数据库，造成数据库压力剧增甚至宕机。</li>
<li><strong>解决</strong>:<ol>
<li><strong>过期时间加随机值</strong>: 在设置缓存的过期时间时，在一个基础时间上增加一个随机数，使得 Key 的失效时间点尽可能分散。</li>
<li><strong>多级缓存</strong>: 建立多级缓存体系，如 Nginx 缓存 + Redis 缓存 + JVM 本地缓存（Caffeine&#x2F;Guava Cache）。</li>
<li><strong>熔断降级</strong>: 使用 Hystrix 或 Sentinel 等组件，当检测到数据库压力过大时，进行熔断或降级处理，暂时不访问数据库，返回一个默认值或提示信息。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-消息队列（MQ）"><a href="#5-消息队列（MQ）" class="headerlink" title="5. 消息队列（MQ）"></a><strong>5. 消息队列（MQ）</strong></h4><h5 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a><strong>核心作用</strong></h5><ul>
<li><strong>异步 (Asynchronous)</strong>: 将耗时的操作（如发送邮件、生成报表）作为消息放入 MQ，主流程可以立即返回，无需等待这些操作完成，从而提高系统的响应速度和吞吐量。</li>
<li><strong>解耦 (Decoupling)</strong>: 生产者和消费者之间通过 MQ 进行通信，无需直接相互依赖。任何一方的修改、宕机或升级都不会影响到另一方，增强了系统的灵活性和可维护性。</li>
<li><strong>削峰 (Peak Shaving)</strong>: 在秒杀、大促等高并发场景下，将瞬时涌入的大量请求暂存在 MQ 中，下游的消费者系统可以按照自己的处理能力，平稳地从 MQ 中拉取并处理请求，避免了流量洪峰直接冲垮下游服务。</li>
</ul>
<h5 id="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"><a href="#面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”" class="headerlink" title="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"></a><strong>面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”</strong></h5><p><strong>回答要点</strong>:</p>
<ul>
<li><strong>消息丢失 (Message Loss)</strong>:<ul>
<li><strong>问题</strong>: 消息从生产者发出后，由于网络或 MQ 服务故障，未能成功到达消费者。</li>
<li><strong>解决</strong>:<ol>
<li><strong>生产者端</strong>: 开启生产者的 <code>confirm</code> 或 <code>ack</code> 机制，确保消息被 MQ 成功接收。如果发送失败，可以进行重试。</li>
<li><strong>MQ 服务端</strong>: 对消息进行持久化，防止 MQ 宕机导致消息丢失（如 RabbitMQ 的持久化队列和消息，Kafka 的磁盘存储）。</li>
<li><strong>消费者端</strong>: 消费者在处理完业务逻辑后，再向 MQ 发送确认应答（<code>ack</code>）。如果处理过程中消费者宕机，MQ 没有收到 <code>ack</code>，会将该消息重新投递给其他消费者。</li>
</ol>
</li>
</ul>
</li>
<li><strong>重复消费 (Duplicate Consumption)</strong>:<ul>
<li><strong>问题</strong>: 由于网络抖动、消费者 <code>ack</code> 超时等原因，MQ 可能会重复投递同一条消息。</li>
<li><strong>解决</strong>: 核心是保证消费逻辑的<strong>幂等性 (Idempotence)</strong>。即多次执行同一个操作，结果都是相同的。实现方式有：<ol>
<li>在数据库中为业务操作创建一个<strong>唯一键</strong>，每次操作前先检查该唯一键是否存在。</li>
<li>使用一个全局唯一的<strong>业务 ID</strong>（如订单号），在处理消息前，先查询这个 ID 是否已经被处理过（例如，存入 Redis Set 或数据库）。</li>
</ol>
</li>
</ul>
</li>
<li><strong>消息堆积 (Message Backlog)</strong>:<ul>
<li><strong>问题</strong>: 生产者的生产速度远大于消费者的消费速度，导致大量消息在 MQ 中积压，占用资源并可能导致消息超时丢失。</li>
<li><strong>解决</strong>:<ol>
<li><strong>水平扩展消费者</strong>: 增加消费者实例的数量，并行处理消息。这是最常用的方法。</li>
<li><strong>优化消费逻辑</strong>: 检查消费者代码，看是否有可以优化的慢操作（如 I&#x2F;O 密集型操作）。</li>
<li><strong>消息分片&#x2F;分区</strong>: 对 Topic 进行分区（Partitioning），让不同的消费者组处理不同的分区，提高并发度。</li>
<li><strong>增加预警监控</strong>: 对消息堆积数量设置阈值，达到阈值时及时告警，人工介入。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-分布式锁详解"><a href="#6-分布式锁详解" class="headerlink" title="6. 分布式锁详解"></a><strong>6. 分布式锁详解</strong></h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在分布式系统环境下，多个进程或服务器上的多个线程需要访问同一个共享资源时，为了保证数据的一致性和操作的原子性，需要一种机制来确保在同一时刻，只有一个客户端能够持有锁并访问该资源。</p>
<h5 id="实现方案对比"><a href="#实现方案对比" class="headerlink" title="实现方案对比"></a><strong>实现方案对比</strong></h5><table>
<thead>
<tr>
<th>实现方式</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基于数据库</strong></td>
<td>实现简单，直接利用数据库（如唯一索引、悲观锁 <code>for update</code>）。</td>
<td>性能开销大，有锁库锁表的风险，不可重入，不是阻塞锁，数据库单点故障问题。</td>
<td>并发度不高的简单场景。</td>
</tr>
<tr>
<td><strong>基于 ZooKeeper</strong></td>
<td>可靠性高，天然支持阻塞锁和可重入，解决死锁问题（临时节点），无锁过期问题，支持公平锁。</td>
<td>性能不如 Redis，实现复杂，依赖 ZK 集群。</td>
<td>对可靠性要求极高，且能容忍一定性能损耗的场景，如分布式协调。</td>
</tr>
<tr>
<td><strong>基于 Redis</strong></td>
<td>性能极高，实现相对简单，有成熟的框架 (Redisson) 可用。</td>
<td>可靠性相对 ZK 稍差，需要处理锁过期和业务未执行完的问题，非公平锁。</td>
<td>互联网高并发、对性能要求高的绝大多数场景。</td>
</tr>
</tbody></table>
<h5 id="基于-Redis-的实现进阶"><a href="#基于-Redis-的实现进阶" class="headerlink" title="基于 Redis 的实现进阶"></a><strong>基于 Redis 的实现进阶</strong></h5><ul>
<li><p>加锁的正确姿势:</p>
<p>使用 SET key value NX EX time 命令。</p>
<ul>
<li><p><code>SET key value</code>: 设置键值。<code>value</code> 通常是一个唯一的随机字符串（如 UUID），用于标识锁的持有者。</p>
</li>
<li><p><code>NX</code>: (if Not eXists)，确保只有在 key 不存在时才能设置成功，实现了“加锁”的原子性。</p>
</li>
<li><p>EX time: 设置一个自动过期时间（秒），防止因客户端宕机而导致死锁。</p>
<p>这三个参数必须在一个命令中执行，保证原子性。</p>
</li>
</ul>
</li>
<li><p><strong>解锁的正确姿势：Lua 脚本</strong></p>
<ul>
<li><p><strong>为什么需要 Lua</strong>: 解锁操作包含“判断”和“删除”两步：1. <code>GET</code> 锁的 <code>value</code>，判断是否与自己加锁时设置的随机字符串相等。2. 如果相等，则 <code>DEL</code> 锁。如果不用 Lua 脚本，在执行完第一步后，若该线程阻塞，此时锁恰好过期，另一个线程获取了锁，那么当原线程恢复执行第二步时，就会<strong>误删掉新线程的锁</strong>。</p>
</li>
<li><p><strong>Lua 脚本示例</strong>:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本接收两个参数：KEYS[1] 是锁的 key，ARGV[1] 是加锁时设置的唯一值</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>Lua 脚本可以确保多个命令在 Redis 服务端被原子性地执行，杜绝了上述问题。</p>
</li>
<li><p><strong>Redis 乐观锁：WATCH 命令</strong></p>
<ul>
<li><p><strong>作用</strong>: <code>WATCH</code> 命令可以监视一个或多个 key，如果在事务 <code>EXEC</code> 执行之前，任何一个被监视的 key 被其他命令修改了，那么整个事务将被取消，<code>EXEC</code> 返回 <code>nil</code>。</p>
</li>
<li><p><strong>原理</strong>: 这是一种<strong>检查后设置 (Check-And-Set, CAS)</strong> 的实现。它不是真正的加锁，而是在更新数据时检查数据是否被修改过。</p>
</li>
<li><p><strong>使用场景</strong>: 适用于<strong>读多写少</strong>的并发场景，可以减少锁的开销。例如，更新商品库存。</p>
<ol>
<li><p><code>WATCH stock_key</code> &#x2F;&#x2F; 监视库存</p>
</li>
<li><p><code>current_stock = GET stock_key</code> &#x2F;&#x2F; 获取当前库存</p>
</li>
<li><p>(在客户端代码中判断 <code>current_stock</code> 是否足够)</p>
</li>
<li><p><code>MULTI</code> &#x2F;&#x2F; 开启事务</p>
</li>
<li><p><code>SET stock_key new_stock</code> &#x2F;&#x2F; 准备更新库存</p>
</li>
<li><p>EXEC &#x2F;&#x2F; 执行事务</p>
<p>如果从 WATCH 到 EXEC 之间 stock_key 被其他客户端修改，EXEC 将失败，此时客户端需要重试整个操作。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”"><a href="#面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”" class="headerlink" title="面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”"></a><strong>面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”</strong></h5><p>回答要点:</p>
<p>这是分布式锁的一个经典问题，被称为锁的超时续期问题。</p>
<ul>
<li><strong>问题根源</strong>: 我们给锁设置了一个过期时间，比如 30 秒，但业务执行了 35 秒。在第 30 秒时锁会自动释放，其他线程就能获取到锁，导致并发问题。</li>
<li><strong>解决方案：“看门狗”(Watchdog)机制</strong>。<ul>
<li><strong>原理</strong>: 比如 Java 中的 Redisson 框架就内置了看门狗。当一个线程获取锁成功后，Redisson 会启动一个后台线程（看门狗），定期（例如每 10 秒）检查该线程是否还持有锁。如果持有，并且业务仍在执行，看门狗就会自动为这个锁<strong>延长过期时间</strong>（续期），比如再续 30 秒。这个过程会一直持续，直到业务执行完毕，线程主动释放锁，看门狗才会停止。</li>
<li><strong>总结</strong>: 看门狗机制通过后台线程自动续期，确保了在业务执行完成之前，锁不会因为超时而提前释放，从而保证了锁的可靠性。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-分布式事务详解"><a href="#7-分布式事务详解" class="headerlink" title="7. 分布式事务详解"></a><strong>7. 分布式事务详解</strong></h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在微服务架构中，一个业务操作可能需要调用多个独立的服务来共同完成（例如，电商下单操作需要调用订单服务、库存服务、积分服务）。分布式事务旨在保证这些跨服务的数据库操作能够遵循 ACID 原则，要么全部成功，要么全部回滚，以确保数据的<strong>最终一致性</strong>。</p>
<h5 id="解决方案深入分析"><a href="#解决方案深入分析" class="headerlink" title="解决方案深入分析"></a><strong>解决方案深入分析</strong></h5><ul>
<li><strong>XA (2PC&#x2F;3PC)</strong>: 两阶段&#x2F;三阶段提交协议。<ul>
<li><strong>角色</strong>: 事务管理器 (Transaction Manager, TM) 和 资源管理器 (Resource Manager, RM)。</li>
<li><strong>流程 (2PC)</strong>:<ol>
<li><strong>准备阶段 (Prepare)</strong>: TM 通知所有 RM 准备提交，RM 执行本地事务并锁定资源，但不提交，然后向 TM 报告准备就绪。</li>
<li><strong>提交&#x2F;回滚阶段 (Commit&#x2F;Rollback)</strong>: 如果所有 RM 都准备就绪，TM 通知所有 RM 提交；否则，通知所有 RM 回滚。</li>
</ol>
</li>
<li><strong>评价</strong>: 是一种<strong>强一致性</strong>的方案，但协议复杂，性能差，同步阻塞模型会长时间锁定资源，且协调器存在单点故障风险，在互联网高并发场景下<strong>很少使用</strong>。</li>
</ul>
</li>
<li><strong>TCC (Try-Confirm-Cancel)</strong>: 补偿型事务。<ul>
<li><strong>核心</strong>: 是一种<strong>业务层面</strong>的柔性事务方案，对代码侵入性强。</li>
<li><strong>流程</strong>:<ol>
<li><strong>Try</strong>: 对业务资源进行<strong>检查和预留</strong>。例如，扣减库存操作，Try 阶段是冻结库存。</li>
<li><strong>Confirm</strong>: 如果所有服务的 Try 阶段都成功，则执行所有服务的 <strong>Confirm</strong> 操作，真正完成业务。例如，将冻结的库存真实扣减。</li>
<li><strong>Cancel</strong>: 如果任何一个服务的 Try 阶段失败，则执行所有已成功服务的 <strong>Cancel</strong> 操作，释放预留的资源。例如，解冻之前被冻结的库存。</li>
</ol>
</li>
<li><strong>评价</strong>: 性能较好，数据一致性高于可靠消息方案。但开发成本极高，需要为每个操作都编写 Try, Confirm, Cancel 三个幂等的方法。</li>
</ul>
</li>
<li><strong>Saga 模式</strong>: 长事务解决方案。<ul>
<li><strong>核心</strong>: 将一个大的分布式事务拆分成多个<strong>本地事务</strong>，每个本地事务都有一个对应的<strong>补偿操作</strong>。</li>
<li><strong>流程</strong>:<ul>
<li><strong>正向执行</strong>: Saga 协调器按顺序调用 T1, T2, T3…Tn。</li>
<li><strong>反向补偿</strong>: 如果 Ti 失败，Saga 会按相反顺序调用前面已成功事务的补偿操作 C(i-1)…C2, C1，进行回滚。</li>
</ul>
</li>
<li><strong>与 TCC 对比</strong>:<ul>
<li>TCC 有资源<strong>预留</strong>阶段，锁资源时间长；Saga 没有预留，直接提交本地事务，锁资源时间短。</li>
<li>TCC 的补偿是<strong>逆向操作</strong> (Cancel)；Saga 的补偿是<strong>反向操作</strong>。</li>
</ul>
</li>
<li><strong>评价</strong>: 适合于业务流程长、需要保证最终一致性的场景。同样对代码有侵入性，需要设计好每个子事务的补偿逻辑。</li>
</ul>
</li>
<li><strong>基于可靠消息的最终一致性 (常用)</strong>:<ul>
<li><strong>核心</strong>: 这是微服务架构中<strong>最常用</strong>的柔性事务方案。</li>
<li><strong>原理</strong>: 服务 A 在执行完本地事务后，发送一条消息到 MQ。服务 B 订阅该消息，消费消息并执行自己的本地事务。</li>
<li><strong>关键问题</strong>: 如何保证<strong>本地事务执行</strong>和<strong>消息发送</strong>的原子性？<ul>
<li><strong>事务消息 (RocketMQ 支持)</strong>: 生产者先发送一条“半消息”到 MQ，MQ 收到后不投递。然后生产者执行本地事务。如果事务成功，则向 MQ 发送确认，MQ 投递该消息；如果事务失败，则通知 MQ 删除该半消息。</li>
<li><strong>本地消息表</strong>: 业务操作和“待发送消息”记录在同一本地事务中。一个后台任务定时扫描这张表，将消息发送到 MQ，发送成功后更新表状态。</li>
</ul>
</li>
<li><strong>评价</strong>: 实现了服务间的解耦，性能高，吞吐量大。但它不保证数据的强一致性，只保证<strong>最终一致性</strong>，存在一个短暂的数据不一致状态窗口。需要处理好消息的可靠投递和幂等消费问题。</li>
</ul>
</li>
</ul>
<h3 id="Lua-脚本详解-在-Redis-中的应用"><a href="#Lua-脚本详解-在-Redis-中的应用" class="headerlink" title="Lua 脚本详解 (在 Redis 中的应用)"></a><strong>Lua 脚本详解 (在 Redis 中的应用)</strong></h3><h4 id="1-Lua-是什么？"><a href="#1-Lua-是什么？" class="headerlink" title="1. Lua 是什么？"></a><strong>1. Lua 是什么？</strong></h4><p>Lua 是一种轻量级、可扩展的脚本语言，被设计用于嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。它以其简洁的语法、高效的执行性能和极小的内存占用而闻名。</p>
<p>在 Redis 的上下文中，Lua 脚本提供了一种在 Redis 服务器端执行复杂逻辑的强大能力。</p>
<h4 id="2-为什么-Redis-要支持-Lua-脚本？"><a href="#2-为什么-Redis-要支持-Lua-脚本？" class="headerlink" title="2. 为什么 Redis 要支持 Lua 脚本？"></a><strong>2. 为什么 Redis 要支持 Lua 脚本？</strong></h4><ul>
<li><strong>原子性 (Atomicity)</strong>: 这是在 Redis 中使用 Lua 最核心的原因。Redis 会将整个 Lua 脚本作为一个单独的命令来执行，<strong>在脚本执行期间，不会有其他客户端的命令被插入执行</strong>。这完美地解决了需要组合多个 Redis 命令才能完成一个业务逻辑时，可能出现的竞态条件问题。例如前面提到的“判断锁并删除锁”的操作，如果分两步执行，就不是原子的，而封装在 Lua 脚本中就是原子的。</li>
<li><strong>减少网络开销</strong>: 对于需要多次与 Redis 交互的复杂操作，可以将所有逻辑封装在一个 Lua 脚本中，一次性发送给 Redis 服务器。客户端只需发送一次请求，而不是多次，这显著减少了客户端与服务器之间的网络往返时间（RTT），提升了性能。</li>
<li><strong>代码复用</strong>: 编写好的 Lua 脚本可以被缓存（通过 <code>SCRIPT LOAD</code> 命令生成一个 SHA1 校验和），之后客户端可以通过这个简短的 SHA1 校验和（使用 <code>EVALSHA</code> 命令）来调用脚本，避免了每次都发送完整的脚本内容。</li>
</ul>
<h4 id="3-如何在-Redis-中使用-Lua-脚本？"><a href="#3-如何在-Redis-中使用-Lua-脚本？" class="headerlink" title="3. 如何在 Redis 中使用 Lua 脚本？"></a><strong>3. 如何在 Redis 中使用 Lua 脚本？</strong></h4><p>通过 EVAL 或 EVALSHA 命令来执行。</p>
<p>EVAL script numkeys key [key …] arg [arg …]</p>
<ul>
<li><code>script</code>: 要执行的 Lua 脚本字符串。</li>
<li><code>numkeys</code>: 后面跟的 <code>key</code> 参数的数量。这有助于 Redis 正确地将参数区分为键名（<code>KEYS</code>）和普通参数（<code>ARGV</code>），这对于 Redis Cluster 模式下的路由至关重要。</li>
<li><code>key [key ...]</code>：脚本中要操作的 Redis 键，在 Lua 脚本中可以通过全局变量 <code>KEYS</code> table（例如 <code>KEYS[1]</code>）来访问。</li>
<li><code>arg [arg ...]</code>：传递给脚本的额外参数，在 Lua 脚本中可以通过全局变量 <code>ARGV</code> table（例如 <code>ARGV[1]</code>）来访问。</li>
</ul>
<p><strong>示例：实现一个安全的库存扣减</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本逻辑：检查库存是否充足，如果充足则扣减并返回1，否则返回0</span></span><br><span class="line"><span class="comment">-- KEYS[1]: 库存的 key，例如 &quot;product:1001:stock&quot;</span></span><br><span class="line"><span class="comment">-- ARGV[1]: 本次要扣减的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">local</span> quantity = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> stock &gt;= quantity <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;decrby&#x27;</span>, KEYS[<span class="number">1</span>], quantity)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这个脚本保证了“读取库存”和“扣减库存”两个操作的原子性，避免了在高并发下超卖的问题。</p>
<hr>
<h3 id="Token-认证机制详解"><a href="#Token-认证机制详解" class="headerlink" title="Token 认证机制详解"></a><strong>Token 认证机制详解</strong></h3><h4 id="1-Token-是什么？"><a href="#1-Token-是什么？" class="headerlink" title="1. Token 是什么？"></a><strong>1. Token 是什么？</strong></h4><p>Token（令牌）是在服务端生成的一串加密字符串，作为客户端进行请求的一个“凭证”。当用户第一次登录成功后，服务端会生成一个 Token 并返回给客户端。之后，客户端在每次请求需要身份认证的接口时，都需要在请求头（通常是 <code>Authorization</code> 字段）中携带这个 Token。服务端接收到请求后，会验证 Token 的有效性，如果验证通过，则处理该请求；否则，拒绝该请求。</p>
<p>一个典型的 Token 是 <strong>JWT (JSON Web Token)</strong>，它由三部分组成，用 <code>.</code> 分隔：</p>
<ul>
<li><strong>Header (头部)</strong>: 包含了令牌的类型（<code>typ</code>，即 JWT）和所使用的签名算法（<code>alg</code>，如 HMAC SHA256 或 RSA）。</li>
<li><strong>Payload (负载)</strong>: 包含了“声明 (claims)”，是存放实际需要传递的数据的地方。例如用户ID（<code>sub</code>）、签发时间（<code>iat</code>）、过期时间（<code>exp</code>）以及其他自定义的用户信息。<strong>注意：Payload 部分是 Base64 编码的，并非加密，因此不应存放敏感信息。</strong></li>
<li><strong>Signature (签名)</strong>: 对前两部分（Header 和 Payload）使用指定的算法和存储在服务端的密钥（secret）进行签名。这个签名的作用是<strong>防止数据被篡改</strong>。服务端收到 Token 后，会用同样的算法和密钥重新计算签名，并与 Token 中的签名进行比对，若一致，则说明 Token 未被篡改且是可信的。</li>
</ul>
<h4 id="2-Token-认证原理（工作流程）"><a href="#2-Token-认证原理（工作流程）" class="headerlink" title="2. Token 认证原理（工作流程）"></a><strong>2. Token 认证原理（工作流程）</strong></h4><ol>
<li><strong>登录</strong>: 用户使用用户名和密码发起登录请求。</li>
<li><strong>验证</strong>: 服务端验证用户的凭据是否正确。</li>
<li><strong>签发 Token</strong>: 验证成功后，服务端根据用户ID、角色等信息，结合密钥（secret），生成一个 Token。</li>
<li><strong>返回 Token</strong>: 服务端将生成的 Token 返回给客户端。</li>
<li><strong>存储 Token</strong>: 客户端（浏览器、App）将 Token 存储起来，通常放在 <code>localStorage</code>、<code>sessionStorage</code> 或 <code>HttpOnly</code> 的 Cookie 中。</li>
<li><strong>携带 Token 请求</strong>: 客户端在后续每次请求受保护的 API 时，都会在 HTTP 请求头的 <code>Authorization</code> 字段中附上 Token，格式通常为 <code>Bearer &lt;token&gt;</code>。</li>
<li><strong>验证 Token</strong>: 服务端收到请求后，从请求头中解析出 Token，然后：<ul>
<li>验证签名是否正确，确保 Token 未被篡改。</li>
<li>检查 Token 是否在有效期内（<code>exp</code> 声明）。</li>
<li>如果验证通过，则从 Payload 中获取用户信息，执行业务逻辑并返回结果。</li>
<li>如果验证失败，则返回 <code>401 Unauthorized</code> 错误。</li>
</ul>
</li>
</ol>
<h4 id="3-为什么使用-Token？（与-Session-的区别）"><a href="#3-为什么使用-Token？（与-Session-的区别）" class="headerlink" title="3. 为什么使用 Token？（与 Session 的区别）"></a><strong>3. 为什么使用 Token？（与 Session 的区别）</strong></h4><p>在 Web 开发早期，<code>Session-Cookie</code> 机制是主流。服务端在用户登录后创建一个 Session 对象存储在内存或 Redis 中，并生成一个 Session ID，通过 Cookie 返回给浏览器。浏览器后续请求会自动带上这个 Session ID，服务端根据 ID 找到对应的 Session 信息来识别用户。</p>
<p><strong>Token 机制相比 Session 机制，核心优势在于“无状态性 (Statelessness)”</strong>，这带来了以下好处：</p>
<table>
<thead>
<tr>
<th>特性对比</th>
<th>Session 机制</th>
<th>Token 机制</th>
<th>优势说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>状态存储</strong></td>
<td><strong>有状态 (Stateful)</strong>。Session 信息需存储在服务端。</td>
<td><strong>无状态 (Stateless)</strong>。用户信息包含在 Token 的 Payload 中，服务端无需存储。</td>
<td><strong>减轻服务端压力</strong>。服务端不需要为每个在线用户维护一个 Session 对象。</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td><strong>差</strong>。在分布式或集群环境下，需要解决 Session 共享问题（如 Session Sticky、Session Replication、集中存储）。</td>
<td><strong>好</strong>。由于服务端不存储状态，任何一台服务器只要有相同的密钥，就能验证 Token，天然适合分布式和微服务架构。</td>
<td><strong>轻松实现水平扩展</strong>。增加服务器节点无需额外配置 Session 共享。</td>
</tr>
<tr>
<td><strong>跨域支持</strong></td>
<td><strong>有限</strong>。基于 Cookie 的 Session 机制在跨域（CORS）场景下处理起来比较麻烦。</td>
<td><strong>优秀</strong>。Token 可以通过 HTTP 请求头发送，不受同源策略限制，非常适合前后端分离和跨域 API 调用。</td>
<td><strong>适应现代架构</strong>。完美支持 SPA（单页应用）、移动 App 等多种客户端。</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>依赖 Cookie 机制，可能遭受 CSRF 攻击。</td>
<td>如果 Token 存储在 <code>localStorage</code>，可能遭受 XSS 攻击。需要综合考虑存储方式。</td>
<td>两者各有安全风险点，需配合其他安全策略。Token 机制不依赖 Cookie，更灵活。</td>
</tr>
<tr>
<td><strong>适用性</strong></td>
<td>适合传统的、一体化的 Web 应用。</td>
<td>适合现代的、分布式的、跨终端的（Web, Mobile, IoT）应用架构。</td>
<td>Token 更具通用性和前瞻性。</td>
</tr>
</tbody></table>
<h4 id="4-双令牌策略-Access-Token-Refresh-Token"><a href="#4-双令牌策略-Access-Token-Refresh-Token" class="headerlink" title="4. 双令牌策略 (Access Token + Refresh Token)"></a><strong>4. 双令牌策略 (Access Token + Refresh Token)</strong></h4><ul>
<li><strong>Q: 为什么不用单个 Token？</strong><ul>
<li><strong>如果 Token 有效期很长（如一个月）</strong>: 安全风险高。一旦 Token 在此期间被窃取，攻击者可以长时间冒充用户身份进行操作。</li>
<li><strong>如果 Token 有效期很短（如 15 分钟）</strong>: 用户体验差。用户需要频繁地重新登录，这是无法接受的。</li>
</ul>
</li>
<li><strong>A: 双令牌策略应运而生，完美平衡了安全性和用户体验。</strong><ul>
<li><strong>Access Token (访问令牌)</strong>: 它的有效期<strong>非常短</strong>（如 15 分钟到 1 小时）。它被用于访问受保护的资源，由于其生命周期短，即使被窃取，攻击者能造成的危害也有限。</li>
<li><strong>Refresh Token (刷新令牌)</strong>: 它的有效期<strong>很长</strong>（如 7 天或 30 天）。它的<strong>唯一作用</strong>是用来获取新的 Access Token。Refresh Token 本身不包含任何权限信息，不能用于直接访问 API。</li>
</ul>
</li>
<li><strong>双令牌工作流程（静默刷新）</strong><ol>
<li><strong>首次登录</strong>: 用户登录成功，服务端返回一个短期的 <code>Access Token</code> 和一个长期的 <code>Refresh Token</code>。客户端将两者都存储起来。</li>
<li><strong>正常访问</strong>: 客户端使用 <code>Access Token</code> 访问 API。服务端验证 <code>Access Token</code> 通过，返回数据。</li>
<li><strong>Access Token 过期</strong>: 客户端再次使用过期的 <code>Access Token</code> 访问 API，服务端返回 <code>401 Unauthorized</code> 错误，并可能带上一个特定错误码，告知客户端是“令牌过期”而非“无效令牌”。</li>
<li><strong>静默刷新</strong>: 客户端的请求拦截器捕获到这个 <code>401</code> 错误后，<strong>不会立即跳转到登录页</strong>。而是自动发起一个特殊的请求，携带那个长期的 <code>Refresh Token</code> 去访问一个专门的刷新接口（如 <code>/api/token/refresh</code>）。</li>
<li><strong>签发新令牌</strong>: 服务端验证 <code>Refresh Token</code> 的有效性（通常会将其存储在 Redis 或数据库中进行比对，以实现强制下线功能）。如果验证通过，就生成一个<strong>新的 Access Token</strong>（有时也会生成一个新的 <code>Refresh Token</code>，这被称为刷新令牌滚动策略）并返回给客户端。</li>
<li><strong>重试请求</strong>: 客户端收到新的 <code>Access Token</code> 后，用它替换掉本地旧的 <code>Access Token</code>，然后<strong>自动重新发送刚才因令牌过期而失败的那个请求</strong>。</li>
<li><strong>无感体验</strong>: 整个过程对用户是透明的，用户感觉不到令牌已经过期并被刷新，实现了“静默刷新”，体验非常流畅。</li>
<li><strong>Refresh Token 过期</strong>: 如果 <code>Refresh Token</code> 也过期了，那么刷新接口会返回错误，此时客户端才会真正清除用户凭证并引导用户重新登录。</li>
</ol>
</li>
</ul>
<h4 id="5-Token-相关场景与面试题"><a href="#5-Token-相关场景与面试题" class="headerlink" title="5. Token 相关场景与面试题"></a><strong>5. Token 相关场景与面试题</strong></h4><ul>
<li><strong>面试题 1：“Token 应该存储在哪里？localStorage、sessionStorage 还是 Cookie？”</strong><ul>
<li><p><strong>回答要点</strong>:</p>
<ul>
<li><strong>localStorage&#x2F;sessionStorage</strong>:<ul>
<li><strong>优点</strong>: 方便 JavaScript 直接读写，容量较大（5MB）。</li>
<li><strong>缺点</strong>: 容易受到 <strong>XSS (跨站脚本攻击)</strong>。如果网站存在 XSS 漏洞，攻击者可以执行 JS 代码直接窃取存储在其中的 Token。</li>
</ul>
</li>
<li><strong>Cookie (HttpOnly)</strong>:<ul>
<li><strong>优点</strong>: 设置为 <code>HttpOnly</code> 后，JavaScript 将无法读写该 Cookie，可以有效<strong>防御 XSS 攻击</strong>。浏览器会自动在同域请求中携带它。</li>
<li><strong>缺点</strong>: 容易受到 <strong>CSRF (跨站请求伪造)</strong> 攻击。攻击者可以诱导用户点击恶意链接，浏览器会自动带上用户的 Cookie 去请求你的网站，执行非用户本意的操作。需要配合 Anti-CSRF Token 等机制来防御。容量较小（4KB）。</li>
</ul>
</li>
<li><strong>最佳实践&#x2F;结论</strong>: 没有绝对完美的选择，需要权衡。<ul>
<li><strong>高安全性方案</strong>: 将 <code>Refresh Token</code> 存储在 <code>HttpOnly</code> 的 Cookie 中（防止 XSS），将 <code>Access Token</code> 存储在内存中（变量里，页面刷新丢失）或 <code>sessionStorage</code> 中。同时，后端接口必须实施 CSRF 防御策略。</li>
<li><strong>主流实践方案 (前后端分离)</strong>: 将 Token 存储在 <code>localStorage</code> 中，并在 <code>Authorization</code> 请求头中携带。同时，前端必须严格做好输入过滤和内容转义，尽最大努力防止 XSS 漏洞的出现。</li>
</ul>
</li>
</ul>
<p>好的，我们来详细探讨<strong>双令牌（Dual Token）的存储方案。这种方案是现代 Web 安全认证的常见模式，主要用于解决传统 JWT（JSON Web Token）方案中的一些安全问题，尤其是防止 XSS（跨站脚本攻击）和 CSRF（跨站请求伪造）攻击</strong>。</p>
<p>双令牌方案的核心思想是：将用户认证所需的权限信息分为两个独立的令牌，并采用不同的存储和传输方式，以达到更高的安全性。这两个令牌通常是：</p>
<ol>
<li><strong>访问令牌（Access Token）</strong></li>
<li><strong>刷新令牌（Refresh Token）</strong></li>
</ol>
<h3 id="1-访问令牌-Access-Token"><a href="#1-访问令牌-Access-Token" class="headerlink" title="1. 访问令牌 (Access Token)"></a>1. 访问令牌 (Access Token)</h3><p>访问令牌是用于<strong>访问受保护资源</strong>的凭证。它通常是一个<strong>有效期很短</strong>的 JWT。</p>
<ul>
<li><strong>作用</strong>：携带用户的身份信息和权限，用于后端 API 接口的认证。后端在收到请求时，会验证这个令牌的有效性（签名、有效期）。</li>
<li><strong>有效期</strong>：<strong>非常短</strong>，通常只有几分钟到几小时。这极大地降低了令牌被盗后造成的损失。</li>
<li><strong>存储方案</strong>：为了防止 XSS 攻击，访问令牌通常不应该存储在浏览器本地的 <code>localStorage</code> 或 <code>sessionStorage</code> 中，因为这些存储空间可以被恶意脚本访问。<ul>
<li><strong>推荐方案</strong>：存储在<strong>内存中</strong>。当用户关闭浏览器标签页时，令牌就会被清除。这意味着用户每次打开新标签页都需要重新获取令牌，但这是为了安全牺牲一些便利性。</li>
<li><strong>次优方案</strong>：存储在<strong>HTTP-only Cookie</strong> 中。这种 Cookie 只能由服务器设置，无法通过 JavaScript 脚本读取，有效防止了 XSS 攻击。但是，它仍然可能受到 CSRF 攻击的风险。</li>
</ul>
</li>
</ul>
<h3 id="2-刷新令牌-Refresh-Token"><a href="#2-刷新令牌-Refresh-Token" class="headerlink" title="2. 刷新令牌 (Refresh Token)"></a>2. 刷新令牌 (Refresh Token)</h3><p>刷新令牌是用于<strong>获取新的访问令牌</strong>的凭证。它通常是一个<strong>有效期很长</strong>的令牌，可以用于在访问令牌过期后，无感地重新获取一个新的。</p>
<ul>
<li><strong>作用</strong>：当访问令牌过期时，客户端携带刷新令牌向认证服务器请求一个新的访问令牌。</li>
<li><strong>有效期</strong>：<strong>很长</strong>，通常是几天、几周甚至几个月。</li>
<li><strong>存储方案</strong>：由于刷新令牌是获取访问令牌的关键，它的存储必须<strong>绝对安全</strong>。<ul>
<li><strong>推荐方案</strong>：存储在<strong>HTTP-only Cookie</strong> 中。HTTP-only 属性可以防止恶意脚本（XSS）读取该令牌。同时，由于刷新令牌只发送给认证服务器，并且不用于访问其他 API，可以采取一些额外的安全措施，如 CSRF 令牌或 SameSite Cookie 属性，来防止 CSRF 攻击。</li>
<li><strong>注意</strong>：刷新令牌<strong>绝对不应该</strong>存储在 <code>localStorage</code> 中。</li>
</ul>
</li>
</ul>
<h3 id="双令牌工作流程（结合存储方案）"><a href="#双令牌工作流程（结合存储方案）" class="headerlink" title="双令牌工作流程（结合存储方案）"></a>双令牌工作流程（结合存储方案）</h3><ol>
<li><strong>首次登录</strong>：<ul>
<li>用户通过用户名&#x2F;密码登录。</li>
<li>认证服务器验证通过后，生成一个<strong>访问令牌（Access Token）和一个刷新令牌（Refresh Token）</strong>。</li>
<li>服务器将刷新令牌设置到 <strong>HTTP-only Cookie</strong> 中，发送给浏览器。</li>
<li>服务器将访问令牌返回给前端，前端将其存储在<strong>内存中</strong>。</li>
</ul>
</li>
<li><strong>访问受保护资源</strong>：<ul>
<li>前端发起 API 请求时，从内存中取出访问令牌，并将其放在请求头（如 <code>Authorization: Bearer &lt;AccessToken&gt;</code>）中发送给后端。</li>
<li>后端 API 服务器验证访问令牌的有效性，如果有效则返回数据。</li>
</ul>
</li>
<li><strong>访问令牌过期</strong>：<ul>
<li>一段时间后，访问令牌过期。前端再次发起 API 请求时，后端会返回一个 401 Unauthorized 错误。</li>
<li>前端捕获到这个错误后，会发起一个<strong>刷新请求</strong>（通常是向一个专门的 <code>/refresh</code> 接口），这个请求会自动带上存储在 HTTP-only Cookie 中的刷新令牌。</li>
</ul>
</li>
<li><strong>刷新令牌工作</strong>：<ul>
<li>认证服务器收到刷新请求，验证刷新令牌的有效性。</li>
<li>如果刷新令牌有效，服务器会生成一个新的<strong>访问令牌</strong>和（可选）一个新的<strong>刷新令牌</strong>。</li>
<li>服务器将新的访问令牌返回给前端，前端更新内存中的令牌。</li>
<li>服务器将新的刷新令牌设置到 <strong>HTTP-only Cookie</strong> 中。</li>
<li>前端使用新的访问令牌重新发起之前的 API 请求。</li>
</ul>
</li>
</ol>
<h3 id="为什么这个方案更安全？"><a href="#为什么这个方案更安全？" class="headerlink" title="为什么这个方案更安全？"></a>为什么这个方案更安全？</h3><ol>
<li><strong>防止 XSS 攻击</strong>：最敏感的刷新令牌存储在 HTTP-only Cookie 中，脚本无法读取。而访问令牌虽然存储在内存中，但其有效期短，即使被盗，也很快会失效。</li>
<li><strong>防止 CSRF 攻击</strong>：刷新令牌通常只用于一个特定的 <code>/refresh</code> 接口，并且可以与 CSRF 令牌（或 SameSite Cookie）结合使用，进一步降低风险。同时，由于其他 API 接口不依赖于 Cookie 中的刷新令牌，而是依赖于请求头中的访问令牌，因此无法被 CSRF 攻击者利用。</li>
<li><strong>提升用户体验</strong>：尽管访问令牌有效期很短，但用户无需频繁登录，因为刷新令牌可以在后台无感地获取新令牌。</li>
</ol>
<p>总之，双令牌方案通过将令牌职责分离和采用不同的存储机制，在保证用户体验的同时，显著提升了系统的安全性，是现代 Web 应用中一种非常成熟和推荐的认证模式。</p>
</li>
</ul>
</li>
<li><strong>面试题 2：“用户点击“退出登录”时，Token 如何失效？”</strong><ul>
<li><strong>回答要点</strong>:<ul>
<li><h4 id="核心观点：无状态-JWT-的特性决定了“退出登录”的本质"><a href="#核心观点：无状态-JWT-的特性决定了“退出登录”的本质" class="headerlink" title="核心观点：无状态 JWT 的特性决定了“退出登录”的本质"></a>核心观点：无状态 JWT 的特性决定了“退出登录”的本质</h4><p>首先，要明确指出 JWT 的核心特点是<strong>无状态</strong>。这意味着服务器<strong>无法主动</strong>让一个已经签发出去的令牌失效，这与传统的 Session 机制（服务器可以主动销毁会话）有本质区别。因此，“退出登录”的实现方式也截然不同。</p>
<h4 id="1-客户端实现（常规退出登录）"><a href="#1-客户端实现（常规退出登录）" class="headerlink" title="1. 客户端实现（常规退出登录）"></a>1. 客户端实现（常规退出登录）</h4><ul>
<li><strong>实现方式</strong>：这是最简单、最常见的方案，适用于用户主动退出登录的情况。</li>
<li><strong>具体操作</strong>：<ul>
<li>前端代码在用户点击“退出登录”时，执行一个简单的操作：<strong>从本地存储（如 localStorage、sessionStorage、内存或 Cookie）中删除 Access Token</strong>。</li>
<li>一旦令牌被删除，前端后续的请求将无法携带有效的 <code>Authorization</code> 头，服务器会返回 401 错误，从而实现了“退出登录”的效果。</li>
</ul>
</li>
<li><strong>局限性</strong>：这种方法只是一个<strong>客户端行为</strong>。如果令牌被复制或被攻击者截获，它在过期之前仍然是有效的。</li>
</ul>
<h4 id="2-服务端实现（强制下线或即时失效）"><a href="#2-服务端实现（强制下线或即时失效）" class="headerlink" title="2. 服务端实现（强制下线或即时失效）"></a>2. 服务端实现（强制下线或即时失效）</h4><ul>
<li><strong>引入背景</strong>：当需要实现更严格的安全需求时，如“管理员踢人下线”、“用户修改密码后所有设备下线”或“令牌泄露后立即失效”，单纯的客户端清除是不够的。此时，我们必须打破无状态的特性，引入服务端的状态管理。</li>
<li><strong>方案一：黑名单机制 (Blacklist)</strong><ul>
<li><strong>工作原理</strong>：<ol>
<li>服务端维护一个高效、可快速查找的<strong>黑名单列表</strong>（通常使用 <strong>Redis 的 Set 数据结构</strong>，因为它具有 O(1) 的查找效率）。</li>
<li>在用户退出登录或需要强制下线时，将该 JWT 的唯一标识 <code>jti</code>（或整个令牌本身）添加到这个黑名单中。</li>
<li>为黑名单中的条目设置一个<strong>过期时间</strong>，该过期时间应与令牌本身的剩余有效期一致。</li>
<li>在每次验证 JWT 的过程中，除了校验签名和过期时间外，额外增加一步：<strong>检查该令牌的 jti 是否存在于黑名单中</strong>。如果存在，则认证失败。</li>
</ol>
</li>
</ul>
</li>
<li><strong>方案二：基于 Refresh Token 的管理</strong><ul>
<li><strong>工作原理</strong>：这种方案是基于<strong>双令牌模式</strong>设计的，更优雅地解决了问题。<ol>
<li>服务器在签发 <code>Access Token</code> 和 <code>Refresh Token</code> 时，会将 <code>Refresh Token</code> 存入数据库或 Redis 中。</li>
<li>当用户点击“退出登录”或需要强制下线时，服务器<strong>删除</strong>或<strong>标记失效</strong>存储在服务器端的 <code>Refresh Token</code>。</li>
<li>当用户的 <code>Access Token</code> 过期后，它将无法通过 <code>Refresh Token</code> 换取新的 <code>Access Token</code>，因为服务器端的 <code>Refresh Token</code> 已经失效。这样，用户就无法继续保持登录状态。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="总结与对比"><a href="#总结与对比" class="headerlink" title="总结与对比"></a>总结与对比</h3><table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>客户端清除</strong></td>
<td>实现简单，开销小。</td>
<td>安全性最低，无法强制下线。</td>
<td>用户主动退出登录。</td>
</tr>
<tr>
<td><strong>黑名单机制</strong></td>
<td>能够实现即时下线，安全可控。</td>
<td>增加了服务端开销（额外的 Redis 存储和查询）。</td>
<td>强制下线、修改密码、令牌泄露。</td>
</tr>
<tr>
<td><strong>Refresh Token 方案</strong></td>
<td>既实现了即时下线，又无需频繁查询黑名单，架构更优雅。</td>
<td>必须采用双令牌模式，实现相对复杂。</td>
<td>现代前后端分离应用，对安全性要求较高。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>面试题 3：“请你设计一个支持 Web 端和 App 端统一登录的认证系统。”</strong><ul>
<li><strong>回答要点</strong>:<ul>
<li>这正是 Token 认证机制的典型应用场景。我会采用基于 <strong>OAuth 2.0&#x2F;OIDC</strong> 或自定义的**双令牌（Access&#x2F;Refresh Token）**方案。</li>
<li><strong>统一认证中心 (UAC)</strong>: 建立一个独立的认证服务，负责处理所有客户端（Web, iOS, Android）的登录、注册、Token 签发和刷新。</li>
<li><strong>API 网关</strong>: 所有业务请求都通过 API 网关。网关的核心职责之一就是<strong>统一鉴权</strong>。它会拦截所有请求，解析 <code>Authorization</code> 头中的 <code>Access Token</code>，调用认证中心或自行验证 Token 的有效性。验证通过后，可以将解析出的用户信息（如用户ID）附加到请求头中，再转发给后端的业务微服务。</li>
<li><strong>业务微服务</strong>: 业务微服务本身<strong>不再关心 Token 的验证细节</strong>，它们信任来自网关的请求，直接从请求头中获取用户信息进行业务处理，实现了业务与认证的解耦。</li>
<li><strong>流程</strong>:<ol>
<li>Web&#x2F;App 客户端引导用户到认证中心进行登录。</li>
<li>登录成功后，认证中心返回 <code>Access Token</code> 和 <code>Refresh Token</code>。</li>
<li>客户端保存令牌，后续访问业务 API 时，在请求头携带 <code>Access Token</code>。</li>
<li>API 网关拦截请求，验证 <code>Access Token</code>。</li>
<li><code>Access Token</code> 过期后，客户端使用 <code>Refresh Token</code> 向认证中心申请新令牌。</li>
</ol>
</li>
<li>这个架构具有高内聚、低耦合、可扩展性强、安全性高的优点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Redis-详细技术解析"><a href="#Redis-详细技术解析" class="headerlink" title="Redis 详细技术解析"></a>Redis 详细技术解析</h1><h2 id="Redis-核心架构与原理"><a href="#Redis-核心架构与原理" class="headerlink" title="Redis 核心架构与原理"></a>Redis 核心架构与原理</h2><h3 id="内存模型与数据结构"><a href="#内存模型与数据结构" class="headerlink" title="内存模型与数据结构"></a>内存模型与数据结构</h3><p>Redis采用基于内存的存储架构，所有数据都保存在RAM中，这是其高性能的根本原因。Redis使用了多种底层数据结构来实现上层的抽象数据类型：</p>
<p><strong>SDS（Simple Dynamic String）</strong> Redis没有直接使用C语言的字符串，而是构建了SDS。SDS在字符串头部记录了长度信息，避免了strlen的O(n)复杂度，同时预分配空间减少内存重分配次数。</p>
<p><strong>跳跃表（Skip List）</strong> 有序集合的底层实现之一，是一种随机化的数据结构，通过多层链表实现O(log N)的查找复杂度。相比红黑树，跳跃表实现更简单，且支持范围查询。</p>
<p><strong>压缩列表（Ziplist）</strong> 当哈希、列表、有序集合元素较少时使用的紧凑存储结构，所有元素存储在一块连续内存中，节省内存但插入删除效率较低。</p>
<p><strong>字典（Dict）</strong> Redis的核心数据结构，使用开放寻址法解决哈希冲突，支持渐进式rehash。当负载因子过高时，会创建新的哈希表并逐步迁移数据。</p>
<h3 id="单线程模型与事件循环"><a href="#单线程模型与事件循环" class="headerlink" title="单线程模型与事件循环"></a>单线程模型与事件循环</h3><p>Redis 6.0之前采用单线程模型处理客户端请求，通过I&#x2F;O多路复用（epoll&#x2F;kqueue）实现高并发。单线程避免了线程切换开销和并发控制问题，但也限制了CPU利用率。</p>
<p><strong>事件循环机制</strong> Redis使用Reactor模式的事件循环，分为文件事件和时间事件：</p>
<ul>
<li>文件事件：处理客户端连接、读写请求</li>
<li>时间事件：处理定时任务，如过期键删除、持久化等</li>
</ul>
<p>Redis 6.0引入了多线程I&#x2F;O，但命令执行仍是单线程，多线程只用于网络I&#x2F;O操作的读写，这样既提高了网络处理能力，又保持了数据操作的原子性。</p>
<h2 id="数据类型详解与应用场景"><a href="#数据类型详解与应用场景" class="headerlink" title="数据类型详解与应用场景"></a>数据类型详解与应用场景</h2><h3 id="Redis-的数据结构详解"><a href="#Redis-的数据结构详解" class="headerlink" title="Redis 的数据结构详解"></a>Redis 的数据结构详解</h3><hr>
<p>这是 Redis 最有特色的地方，理解这些数据结构是掌握 Redis 的关键。</p>
<h4 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1. String (字符串)"></a>1. String (字符串)</h4><ul>
<li><strong>最基本的数据结构</strong>，可以存储任何类型的数据，比如字符串、数字或二进制数据。一个键最多可以存储 512MB 的值。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>SET key value</code>: 设置键值对。</li>
<li><code>GET key</code>: 获取键对应的值。</li>
<li><code>INCR key</code>: 将键对应的值加 1，常用于计数器。</li>
<li><code>MSET key1 value1 key2 value2</code>: 同时设置多个键值对。</li>
<li><code>MGET key1 key2</code>: 同时获取多个键的值。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 缓存、计数器、分布式锁等。</li>
</ul>
<h4 id="2-Hash-哈希"><a href="#2-Hash-哈希" class="headerlink" title="2. Hash (哈希)"></a>2. Hash (哈希)</h4><ul>
<li><strong>类似于一个键值对的集合</strong>。一个哈希键可以存储多个字段（field）和对应的值（value），非常适合存储对象。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>HSET key field value</code>: 设置哈希键中一个字段的值。</li>
<li><code>HGET key field</code>: 获取哈希键中一个字段的值。</li>
<li><code>HGETALL key</code>: 获取哈希键中所有的字段和值。</li>
<li><code>HMSET key field1 value1 field2 value2</code>: 同时设置多个字段。</li>
<li><code>HDEL key field1 field2</code>: 删除一个或多个字段。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 存储用户信息（如<code>user:100</code>作为键，<code>name</code>、<code>age</code>、<code>city</code>作为字段），商品信息等。</li>
</ul>
<h4 id="3-List-列表"><a href="#3-List-列表" class="headerlink" title="3. List (列表)"></a>3. List (列表)</h4><ul>
<li><strong>一个有序的、可以重复的字符串集合</strong>。可以从列表的头部或尾部添加或删除元素。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>LPUSH key value1 value2</code>: 从列表的头部插入一个或多个值。</li>
<li><code>RPUSH key value1 value2</code>: 从列表的尾部插入一个或多个值。</li>
<li><code>LPOP key</code>: 从列表的头部移除并返回一个值。</li>
<li><code>RPOP key</code>: 从列表的尾部移除并返回一个值。</li>
<li><code>LRANGE key start stop</code>: 获取列表中指定范围的元素。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 消息队列（队列、栈）、最新文章列表、历史记录等。</li>
</ul>
<h4 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4. Set (集合)"></a>4. Set (集合)</h4><ul>
<li><strong>一个无序的、不重复的字符串集合</strong>。集合提供了交集、并集和差集等操作。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>SADD key member1 member2</code>: 向集合中添加一个或多个成员。</li>
<li><code>SMEMBERS key</code>: 获取集合中的所有成员。</li>
<li><code>SISMEMBER key member</code>: 判断一个成员是否在集合中。</li>
<li><code>SINTER key1 key2</code>: 求两个集合的交集。</li>
<li><code>SUNION key1 key2</code>: 求两个集合的并集。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 社交网络中的共同好友、标签系统、去重等。</li>
</ul>
<h4 id="5-Sorted-Set-有序集合"><a href="#5-Sorted-Set-有序集合" class="headerlink" title="5. Sorted Set (有序集合)"></a>5. Sorted Set (有序集合)</h4><ul>
<li><strong>和集合类似，但每个成员都会关联一个分数（score）</strong>。通过这个分数，可以对集合中的成员进行排序。分数可以重复，但成员必须唯一。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>ZADD key score1 member1 score2 member2</code>: 向有序集合中添加一个或多个带分数的成员。</li>
<li><code>ZRANGE key start stop</code>: 按分数从小到大排序，获取指定范围的成员。</li>
<li><code>ZREVRANGE key start stop</code>: 按分数从大到小排序，获取指定范围的成员。</li>
<li><code>ZSCORE key member</code>: 获取一个成员的分数。</li>
<li><code>ZINCRBY key increment member</code>: 给指定成员的分数增加指定值。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 排行榜（游戏分数、热点新闻）、带权重的任务队列等。</li>
</ul>
<h3 id="Redis-的持久化机制"><a href="#Redis-的持久化机制" class="headerlink" title="Redis 的持久化机制"></a>Redis 的持久化机制</h3><hr>
<p>Redis 提供了两种持久化方式，可以将数据从内存保存到硬盘，确保数据不会因为服务重启而丢失。</p>
<h4 id="1-RDB-Redis-Database"><a href="#1-RDB-Redis-Database" class="headerlink" title="1. RDB (Redis Database)"></a>1. RDB (Redis Database)</h4><ul>
<li><strong>快照方式</strong>。它会在指定的时间间隔内，将内存中的数据快照写入到磁盘上一个二进制文件中（<code>dump.rdb</code>）。</li>
<li><strong>优点</strong>: RDB 文件是一个非常紧凑的二进制文件，非常适合备份和灾难恢复。</li>
<li><strong>缺点</strong>: 每次保存都会丢失从上次快照到现在之间的数据。</li>
</ul>
<h4 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2. AOF (Append Only File)"></a>2. AOF (Append Only File)</h4><ul>
<li><strong>日志方式</strong>。它会记录每一次对 Redis 数据库的写操作命令，并以追加（append）的方式写入到文件中。当 Redis 重启时，会重新执行 AOF 文件中的命令来恢复数据。</li>
<li><strong>优点</strong>: 数据丢失风险低，可以配置为每秒同步一次，或者每执行一个命令就同步一次。</li>
<li><strong>缺点</strong>: AOF 文件通常比 RDB 文件大，且恢复速度可能较慢。</li>
</ul>
<p>在实际应用中，通常会<strong>同时使用 RDB 和 AOF</strong>，以获得更高的可靠性。</p>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String是Redis最基础的数据类型，底层可以是SDS、整数或浮点数。</p>
<p><strong>常用命令</strong>：SET、GET、INCR、DECR、APPEND、GETRANGE <strong>应用场景</strong>：</p>
<ul>
<li>缓存：存储用户会话、配置信息</li>
<li>计数器：网站访问量、点赞数（INCR原子性保证）</li>
<li>分布式锁：SET key value NX EX seconds</li>
<li>限流：结合EXPIRE实现滑动窗口限流</li>
</ul>
<h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash类型适合存储对象，避免了将对象序列化为JSON字符串的开销。</p>
<p><strong>底层实现</strong>：元素较少时使用ziplist，元素较多时使用hashtable <strong>应用场景</strong>：</p>
<ul>
<li>存储用户信息：HSET user:1001 name “张三” age 25</li>
<li>购物车：HSET cart:1001 product:123 2</li>
<li>配置管理：分类存储不同模块的配置</li>
</ul>
<h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>List是双向链表实现，支持在两端进行O(1)的插入和删除操作。</p>
<p><strong>常用命令</strong>：LPUSH、RPUSH、LPOP、RPOP、LRANGE、BLPOP <strong>应用场景</strong>：</p>
<ul>
<li>消息队列：生产者LPUSH，消费者BRPOP实现阻塞队列</li>
<li>最新列表：朋友圈动态、商品评论</li>
<li>栈和队列：LPUSH+LPOP实现栈，LPUSH+RPOP实现队列</li>
</ul>
<h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Set是无序集合，元素唯一，底层使用hashtable或intset实现。</p>
<p><strong>集合运算</strong>：SINTER（交集）、SUNION（并集）、SDIFF（差集） <strong>应用场景</strong>：</p>
<ul>
<li>去重：统计网站独立访客</li>
<li>社交关系：共同好友、推荐用户</li>
<li>标签系统：用户标签、文章分类</li>
<li>抽奖系统：SRANDMEMBER随机抽取</li>
</ul>
<h3 id="Sorted-Set类型"><a href="#Sorted-Set类型" class="headerlink" title="Sorted Set类型"></a>Sorted Set类型</h3><p>有序集合，每个元素关联一个分数，按分数排序。底层使用跳跃表和哈希表。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li>排行榜：游戏积分、热搜榜</li>
<li>延时队列：分数为执行时间戳</li>
<li>范围查询：按时间、按分数范围获取数据</li>
</ul>
<h2 id="持久化机制深度解析"><a href="#持久化机制深度解析" class="headerlink" title="持久化机制深度解析"></a>持久化机制深度解析</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB通过fork子进程，将内存数据快照写入磁盘。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>文件紧凑，适合备份和灾难恢复</li>
<li>恢复速度快</li>
<li>对Redis性能影响小（子进程操作）</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>数据丢失风险：两次快照间的数据可能丢失</li>
<li>fork过程会阻塞主进程</li>
<li>大数据集fork耗时较长</li>
</ul>
<p><strong>触发条件</strong>：</p>
<ul>
<li>手动执行SAVE或BGSAVE命令</li>
<li>配置自动触发：save 900 1（900秒内至少1个键改变）</li>
<li>主从复制时自动生成RDB</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF记录每个写命令，通过重放命令恢复数据。</p>
<p><strong>写入时机</strong>：</p>
<ul>
<li>always：每个写命令立即同步，安全但性能低</li>
<li>everysec：每秒同步一次，平衡安全性和性能</li>
<li>no：由操作系统决定同步时机，性能高但安全性低</li>
</ul>
<p><strong>AOF重写</strong>： AOF文件会越来越大，Redis提供重写机制优化：</p>
<ul>
<li>遍历内存数据，用最少命令重建AOF文件</li>
<li>重写期间的新命令写入AOF重写缓冲区</li>
<li>原子性替换旧AOF文件</li>
</ul>
<p><strong>混合持久化</strong>： Redis 4.0引入RDB+AOF混合模式，重写时以RDB格式写入基础数据，增量命令以AOF格式追加，兼顾了恢复速度和数据安全。</p>
<h2 id="缓存问题与解决方案"><a href="#缓存问题与解决方案" class="headerlink" title="缓存问题与解决方案"></a>缓存问题与解决方案</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在的数据，缓存无法生效，请求直达数据库。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>空值缓存</strong>：查询结果为空时也缓存，设置较短过期时间</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">    redis.setex(key, <span class="number">60</span>, <span class="string">&quot;null&quot;</span>);  <span class="comment">// 缓存空值60秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>布隆过滤器</strong>：预先将所有可能存在的数据哈希到位数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BloomFilter&lt;String&gt; filter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()), <span class="number">1000000</span>, <span class="number">0.01</span>);</span><br><span class="line"><span class="comment">// 查询前先检查布隆过滤器</span></span><br><span class="line"><span class="keyword">if</span> (!filter.mightContain(key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 一定不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>参数校验</strong>：在API层面进行参数合法性校验</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>热点数据过期瞬间，大量并发请求击穿缓存。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>互斥锁</strong>：只允许一个线程查询数据库并重建缓存</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span> + key;</span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(lockKey, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>)) &#123;  <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                data = database.query(key);  <span class="comment">// 查询数据库</span></span><br><span class="line">                redis.setex(key, <span class="number">3600</span>, data);  <span class="comment">// 重建缓存</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                redis.del(lockKey);  <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);  <span class="comment">// 等待其他线程重建缓存</span></span><br><span class="line">            <span class="keyword">return</span> getData(key);  <span class="comment">// 递归重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>热点数据永不过期</strong>：逻辑上设置过期时间，物理上不过期，异步更新</li>
<li><strong>预热机制</strong>：系统启动时预先加载热点数据</li>
<li><strong>二级缓存</strong>：L1缓存过期后，先返回L2缓存数据，异步更新L1</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量缓存同时过期或Redis宕机，请求涌向数据库。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>过期时间随机化</strong>：避免同时过期</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> baseExpire + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);  <span class="comment">// 基础时间+随机时间</span></span><br><span class="line">redis.setex(key, randomExpire, data);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>多级缓存架构</strong>：<ul>
<li>L1：本地缓存（如Caffeine）</li>
<li>L2：Redis分布式缓存</li>
<li>L3：数据库</li>
</ul>
</li>
<li><strong>限流降级</strong>：使用Sentinel、Hystrix等组件</li>
<li><strong>Redis高可用</strong>：主从复制、哨兵模式、集群部署</li>
</ol>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>系统启动时预先加载热点数据到缓存。</p>
<p><strong>实现方式</strong>：</p>
<ol>
<li><strong>定时任务预热</strong>：凌晨低峰期执行</li>
<li><strong>手动预热</strong>：管理后台触发预热任务</li>
<li><strong>实时预热</strong>：监控系统发现热点数据自动预热</li>
</ol>
<h2 id="数据一致性保证"><a href="#数据一致性保证" class="headerlink" title="数据一致性保证"></a>数据一致性保证</h2><h3 id="Cache-Aside模式（旁路缓存）"><a href="#Cache-Aside模式（旁路缓存）" class="headerlink" title="Cache Aside模式（旁路缓存）"></a>Cache Aside模式（旁路缓存）</h3><p>应用程序负责维护缓存和数据库的一致性。</p>
<p><strong>读操作</strong>：</p>
<ol>
<li>先读缓存，命中则返回</li>
<li>缓存不命中，查询数据库</li>
<li>将数据写入缓存并返回</li>
</ol>
<p><strong>写操作</strong>：</p>
<ol>
<li>先更新数据库</li>
<li>删除缓存（让下次读取时重新加载）</li>
</ol>
<p><strong>为什么是删除而不是更新缓存？</strong></p>
<ul>
<li>更新缓存可能存在并发问题</li>
<li>复杂查询的缓存更新成本高</li>
<li>删除缓存更简单可靠</li>
</ul>
<h3 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h3><p>解决读写并发导致的数据不一致问题。</p>
<p><strong>实现步骤</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Object data)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 删除缓存</span></span><br><span class="line">    redis.del(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 更新数据库</span></span><br><span class="line">    database.update(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 延时删除缓存（异步）</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);  <span class="comment">// 延时500ms</span></span><br><span class="line">            redis.del(key);     <span class="comment">// 再次删除缓存</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;延时删除缓存失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>延时时间设置</strong>：通常为主从同步时间 + 读数据库时间 + 几十毫秒</p>
<h3 id="基于消息队列的最终一致性"><a href="#基于消息队列的最终一致性" class="headerlink" title="基于消息队列的最终一致性"></a>基于消息队列的最终一致性</h3><p>使用消息队列异步处理缓存更新，保证最终一致性。</p>
<p><strong>实现流程</strong>：</p>
<ol>
<li>更新数据库，发送消息到队列</li>
<li>消息消费者删除相关缓存</li>
<li>消费失败时重试，保证最终一致性</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送缓存删除消息</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    userDao.update(user);  <span class="comment">// 更新数据库</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送缓存删除消息（事务提交后发送）</span></span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TransactionSynchronizationAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCommit</span><span class="params">()</span> &#123;</span><br><span class="line">                cacheDeleteMQ.send(<span class="string">&quot;user:&quot;</span> + user.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式事务方案"><a href="#分布式事务方案" class="headerlink" title="分布式事务方案"></a>分布式事务方案</h3><p>对于强一致性要求高的场景，可以使用分布式事务。</p>
<p><strong>2PC（两阶段提交）</strong>：</p>
<ul>
<li>准备阶段：协调者询问参与者是否准备好</li>
<li>提交阶段：所有参与者都准备好则提交，否则回滚</li>
</ul>
<p><strong>TCC（Try-Confirm-Cancel）</strong>：</p>
<ul>
<li>Try：尝试执行，预留资源</li>
<li>Confirm：确认提交</li>
<li>Cancel：取消执行，释放资源</li>
</ul>
<h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><h3 id="基于SET命令的分布式锁"><a href="#基于SET命令的分布式锁" class="headerlink" title="基于SET命令的分布式锁"></a>基于SET命令的分布式锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDistributedLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String lockKey, String requestId, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">releaseLock</span><span class="params">(String lockKey, String requestId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, Collections.singletonList(lockKey),</span><br><span class="line">                                 Collections.singletonList(requestId));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>.equals(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:user:1001&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tryLock(lockKey, requestId, <span class="number">30000</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行业务逻辑</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        releaseLock(lockKey, requestId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h3><p>为了解决单点故障问题，Redis官方提出了Redlock算法。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li>获取当前时间戳</li>
<li>依次向N个Redis实例申请锁</li>
<li>如果在大多数实例（N&#x2F;2+1）上获取锁成功，且总耗时小于锁超时时间，则认为获取锁成功</li>
<li>锁的有效时间 &#x3D; 初始有效时间 - 获取锁消耗的时间</li>
<li>释放锁时，向所有Redis实例发送释放命令</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Redlock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Jedis&gt; jedisInstances;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String resource, <span class="type">int</span> ttl)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">quorum</span> <span class="operator">=</span> jedisInstances.size() / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">successCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Jedis jedis : jedisInstances) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lockInstance(jedis, resource, ttl)) &#123;</span><br><span class="line">                successCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        <span class="keyword">if</span> (successCount &gt;= quorum &amp;&amp; elapsedTime &lt; ttl) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unlock(resource);  <span class="comment">// 释放已获取的锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁的问题与优化"><a href="#锁的问题与优化" class="headerlink" title="锁的问题与优化"></a>锁的问题与优化</h3><p><strong>锁超时问题</strong>： 业务执行时间超过锁超时时间，锁自动释放，可能导致并发问题。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>看门狗机制</strong>：定时续期锁的过期时间</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatchDog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ScheduledExecutorService</span> <span class="variable">scheduler</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startWatchDog</span><span class="params">(String lockKey, String requestId)</span> &#123;</span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 续期锁</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) else return 0 end&quot;</span>;</span><br><span class="line">            jedis.eval(script, Arrays.asList(lockKey), </span><br><span class="line">                      Arrays.asList(requestId, <span class="string">&quot;30&quot;</span>));</span><br><span class="line">        &#125;, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>合理评估业务执行时间</strong>：设置足够的锁超时时间</li>
</ol>
<p><strong>锁竞争激烈问题</strong>： 大量线程竞争同一把锁，导致性能下降。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>分段锁</strong>：将资源分段，减少锁竞争</li>
<li><strong>队列锁</strong>：使用List实现公平锁</li>
<li><strong>自旋锁优化</strong>：适当的退避算法</li>
</ol>
<h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>假设会发生并发冲突，在操作数据前先获取锁。</p>
<p><strong>Redis实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Redis分布式锁实现悲观锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWithPessimisticLock</span><span class="params">(String userId, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:account:&quot;</span> + userId;</span><br><span class="line">    <span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (tryLock(lockKey, requestId, <span class="number">30000</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 查询账户余额</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> getBalance(userId);</span><br><span class="line">            <span class="keyword">if</span> (balance &gt;= amount) &#123;</span><br><span class="line">                <span class="comment">// 扣减余额</span></span><br><span class="line">                updateBalance(userId, balance - amount);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientBalanceException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            releaseLock(lockKey, requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LockAcquisitionException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>假设不会发生冲突，在更新时检查数据是否被修改。</p>
<p><strong>基于版本号的乐观锁</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateWithOptimisticLock</span><span class="params">(String userId, <span class="type">int</span> amount, <span class="type">int</span> expectedVersion)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用Lua脚本保证原子性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> </span><br><span class="line">        <span class="string">&quot;local current = redis.call(&#x27;hmget&#x27;, KEYS[1], &#x27;balance&#x27;, &#x27;version&#x27;) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;if current[2] == ARGV[2] then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  if tonumber(current[1]) &gt;= tonumber(ARGV[1]) then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    redis.call(&#x27;hmset&#x27;, KEYS[1], &#x27;balance&#x27;, current[1] - ARGV[1], &#x27;version&#x27;, current[2] + 1) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return 1 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return -1 &quot;</span> +  <span class="comment">// 余额不足</span></span><br><span class="line">        <span class="string">&quot;  end &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  return 0 &quot;</span> +     <span class="comment">// 版本号不匹配</span></span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;account:&quot;</span> + userId;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, Arrays.asList(key), </span><br><span class="line">                              Arrays.asList(String.valueOf(amount), String.valueOf(expectedVersion)));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> ((Long) result).intValue();</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 更新成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockException</span>(<span class="string">&quot;数据已被修改&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientBalanceException</span>(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基于CAS的乐观锁</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWithCAS</span><span class="params">(String key, Function&lt;String, String&gt; updater)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">currentValue</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 计算新值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newValue</span> <span class="operator">=</span> updater.apply(currentValue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. CAS更新</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[2]) else return nil end&quot;</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> redis.eval(script, Arrays.asList(key), </span><br><span class="line">                                  Arrays.asList(currentValue, newValue));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 更新成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新失败，重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="悲观锁-vs-乐观锁选择"><a href="#悲观锁-vs-乐观锁选择" class="headerlink" title="悲观锁 vs 乐观锁选择"></a>悲观锁 vs 乐观锁选择</h3><p><strong>悲观锁适用场景</strong>：</p>
<ul>
<li>写操作频繁，冲突概率高</li>
<li>业务逻辑复杂，重试成本高</li>
<li>对数据一致性要求严格</li>
</ul>
<p><strong>乐观锁适用场景</strong>：</p>
<ul>
<li>读多写少，冲突概率低</li>
<li>业务逻辑简单，重试成本低</li>
<li>对性能要求高</li>
</ul>
<h2 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Master负责写操作，Slave负责读操作，通过复制实现数据同步。</p>
<p><strong>复制原理</strong>：</p>
<ol>
<li>Slave向Master发送PSYNC命令</li>
<li>Master执行BGSAVE生成RDB文件</li>
<li>Master将RDB文件发送给Slave</li>
<li>Slave载入RDB文件</li>
<li>Master将缓冲区的写命令发送给Slave</li>
<li>后续写命令实时同步</li>
</ol>
<p><strong>部分重同步</strong>： 网络断连后，Slave只需要同步断连期间的命令，而不是完整重同步。</p>
<h3 id="哨兵模式（Sentinel）"><a href="#哨兵模式（Sentinel）" class="headerlink" title="哨兵模式（Sentinel）"></a>哨兵模式（Sentinel）</h3><p>哨兵负责监控Master状态，在Master故障时自动进行故障转移。</p>
<p><strong>哨兵职责</strong>：</p>
<ul>
<li>监控：定期ping Master和Slave</li>
<li>通知：故障时通知管理员和客户端</li>
<li>故障转移：自动将Slave提升为新Master</li>
<li>配置管理：为客户端提供服务发现</li>
</ul>
<p><strong>故障转移流程</strong>：</p>
<ol>
<li>哨兵发现Master下线（主观下线）</li>
<li>多个哨兵确认Master下线（客观下线）</li>
<li>选举领导哨兵执行故障转移</li>
<li>选择合适的Slave作为新Master</li>
<li>修改其他Slave的配置指向新Master</li>
<li>通知客户端Master地址变更</li>
</ol>
<h3 id="集群模式（Cluster）"><a href="#集群模式（Cluster）" class="headerlink" title="集群模式（Cluster）"></a>集群模式（Cluster）</h3><p>Redis Cluster通过分片实现横向扩展和高可用。</p>
<p><strong>分片算法</strong>： 使用CRC16算法计算key的哈希值，然后对16384取模得到槽位号。</p>
<p><strong>节点通信</strong>： 使用Gossip协议在节点间交换状态信息，包括节点上线&#x2F;下线、槽位分配等。</p>
<p><strong>故障转移</strong>： 当Master节点故障时，其Slave自动提升为新Master，过程对客户端透明。</p>
<p><strong>数据迁移</strong>： 集群扩容时，需要将部分槽位从现有节点迁移到新节点。</p>
<h4 id="Redis-哈希槽（Hash-Slot）详解"><a href="#Redis-哈希槽（Hash-Slot）详解" class="headerlink" title="Redis 哈希槽（Hash Slot）详解"></a>Redis 哈希槽（Hash Slot）详解</h4><p>在 Redis Cluster 中，数据不是存储在单个节点上，而是被分散存储在多个节点上。为了实现这种分散存储，Redis 引入了 <strong>哈希槽（hash slot）</strong> 的概念。</p>
<h4 id="1-什么是哈希槽？"><a href="#1-什么是哈希槽？" class="headerlink" title="1. 什么是哈希槽？"></a>1. 什么是哈希槽？</h4><p>Redis Cluster 一共有 <strong>16384 个哈希槽（slot）</strong>，编号从 0 到 16383。集群中的每个键（key）都会通过一个固定的算法映射到这 16384 个哈希槽中的一个，然后这些哈希槽会被分配给集群中的不同节点。</p>
<h4 id="2-键如何映射到哈希槽？"><a href="#2-键如何映射到哈希槽？" class="headerlink" title="2. 键如何映射到哈希槽？"></a>2. 键如何映射到哈希槽？</h4><p>Redis 使用一个简单的算法来决定一个键属于哪个哈希槽：<br>$$<br>slot&#x3D;CRC16(key)(mod16384)<br>$$</p>
<ul>
<li><strong>CRC16(key)</strong>：对键名执行 CRC16 校验和计算。</li>
<li><strong>mod 16384</strong>：将 CRC16 校验和的结果对 16384 取模，得到的结果就是这个键所属的哈希槽编号。</li>
</ul>
<p>例如，如果你有一个键 <code>mykey</code>，Redis 会计算 <code>CRC16(&#39;mykey&#39;) % 16384</code>，得到一个 0 到 16383 之间的数字。</p>
<h4 id="3-哈希槽如何分配给节点？"><a href="#3-哈希槽如何分配给节点？" class="headerlink" title="3. 哈希槽如何分配给节点？"></a>3. 哈希槽如何分配给节点？</h4><p>集群中的每个节点负责管理一部分哈希槽。例如，一个三节点的集群可以这样分配哈希槽：</p>
<ul>
<li><strong>节点 A</strong>：负责哈希槽 0 到 5460。</li>
<li><strong>节点 B</strong>：负责哈希槽 5461 到 10922。</li>
<li><strong>节点 C</strong>：负责哈希槽 10923 到 16383。</li>
</ul>
<p>当一个客户端需要操作一个键时，它会首先计算这个键所属的哈希槽，然后根据哈希槽与节点的映射关系，找到负责该哈希槽的节点，并向其发送请求。</p>
<p>如果客户端请求的键不在当前连接的节点上，这个节点会返回一个 <code>MOVED</code> 重定向错误，告诉客户端正确的节点地址，客户端会根据这个地址重新发起请求。</p>
<h4 id="4-哈希槽的优势"><a href="#4-哈希槽的优势" class="headerlink" title="4. 哈希槽的优势"></a>4. 哈希槽的优势</h4><ul>
<li><strong>高可用性</strong>：当一个节点失效时，它所负责的哈希槽可以被其他节点接管，从而保证数据的可用性。</li>
<li><strong>弹性伸缩</strong>：<ul>
<li><strong>添加节点</strong>：当需要扩展集群时，可以添加新节点，并从现有节点上迁移一部分哈希槽到新节点上，这个过程是增量的，不需要停机。</li>
<li><strong>移除节点</strong>：当需要缩减集群时，可以将某个节点上的所有哈希槽迁移到其他节点，然后移除该节点。</li>
</ul>
</li>
</ul>
<h2 id="性能监控与优化"><a href="#性能监控与优化" class="headerlink" title="性能监控与优化"></a>性能监控与优化</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>Redis提供慢查询日志功能，记录执行时间超过阈值的命令。</p>
<p><strong>配置参数</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">slowlog-log-slower-than</span> <span class="number">10000</span>  <span class="comment"># 超过10毫秒记录</span></span><br><span class="line"><span class="string">slowlog-max-len</span> <span class="number">128</span>           <span class="comment"># 最多保存128条记录</span></span><br></pre></td></tr></table></figure>

<p><strong>查看慢查询</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLOWLOG GET 10  <span class="comment"># 获取最近10条慢查询</span></span><br></pre></td></tr></table></figure>

<h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p>使用MEMORY命令分析内存使用情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MEMORY USAGE key         <span class="comment"># 查看key占用内存</span></span><br><span class="line">MEMORY STATS            <span class="comment"># 查看内存统计信息</span></span><br><span class="line">MEMORY DOCTOR           <span class="comment"># 内存使用建议</span></span><br></pre></td></tr></table></figure>

<h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><p><strong>避免大key</strong>：</p>
<ul>
<li>单个key的value不要超过10KB</li>
<li>集合类型元素数量控制在合理范围</li>
<li>使用SCAN代替KEYS命令</li>
</ul>
<p><strong>合理使用数据结构</strong>：</p>
<ul>
<li>小对象使用Hash而不是多个String</li>
<li>合理设置ziplist等压缩结构的阈值</li>
<li>使用位图(bitmap)存储布尔类型大数据集</li>
</ul>
<p><strong>网络优化</strong>：</p>
<ul>
<li>使用Pipeline批量操作</li>
<li>合理设置客户端连接池</li>
<li>启用TCP_NODELAY选项</li>
</ul>
<p><strong>持久化优化</strong>：</p>
<ul>
<li>根据业务需求选择RDB或AOF</li>
<li>合理配置自动保存条件</li>
<li>在从节点上进行持久化操作</li>
</ul>
<p>这些详细的技术点涵盖了Redis的核心概念、常见问题解决方案和实际应用场景，是Redis技术面试的重要考查内容。掌握这些知识点并能结合实际项目经验进行说明，将大大提高面试通过率。</p>
<h2 id="内存管理与淘汰机制"><a href="#内存管理与淘汰机制" class="headerlink" title="内存管理与淘汰机制"></a>内存管理与淘汰机制</h2><h3 id="内存淘汰策略详解"><a href="#内存淘汰策略详解" class="headerlink" title="内存淘汰策略详解"></a>内存淘汰策略详解</h3><p>当Redis内存使用达到maxmemory限制时，会根据配置的策略淘汰数据。</p>
<p><strong>8种淘汰策略</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对所有key</span></span><br><span class="line">noeviction          <span class="comment"># 不淘汰，写入返回错误</span></span><br><span class="line">allkeys-lru         <span class="comment"># 所有key中淘汰最近最少使用</span></span><br><span class="line">allkeys-lfu         <span class="comment"># 所有key中淘汰最少频率使用</span></span><br><span class="line">allkeys-random      <span class="comment"># 所有key中随机淘汰</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对设置了过期时间的key</span></span><br><span class="line">volatile-lru        <span class="comment"># 过期key中淘汰最近最少使用</span></span><br><span class="line">volatile-lfu        <span class="comment"># 过期key中淘汰最少频率使用</span></span><br><span class="line">volatile-random     <span class="comment"># 过期key中随机淘汰</span></span><br><span class="line">volatile-ttl        <span class="comment"># 过期key中淘汰即将过期的</span></span><br></pre></td></tr></table></figure>

<p><strong>LRU vs LFU 实现细节</strong>： Redis的LRU并非严格的LRU，而是近似LRU算法：</p>
<ul>
<li>每个key都有24位的时钟字段记录访问时间</li>
<li>淘汰时随机采样5个key（可配置），选择时钟值最小的</li>
</ul>
<p>LFU算法维护访问频率：</p>
<ul>
<li>高16位存储上次访问时间</li>
<li>低8位存储访问频率计数器</li>
<li>计数器采用概率性递增，避免频率无限增长</li>
</ul>
<h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p><strong>产生原因</strong>：</p>
<ul>
<li>频繁的数据更新导致内存分配&#x2F;释放</li>
<li>Redis使用jemalloc内存分配器，存在内存对齐</li>
<li>删除大key后留下内存空洞</li>
</ul>
<p><strong>检测方法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"><span class="comment"># 关注 mem_fragmentation_ratio 指标</span></span><br><span class="line"><span class="comment"># 比值 &gt; 1.5 表示碎片较多</span></span><br><span class="line"><span class="comment"># 比值 &lt; 1 表示使用了swap，性能严重下降</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>内存整理</strong>（Redis 4.0+）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET activedefrag <span class="built_in">yes</span>        <span class="comment"># 开启自动整理</span></span><br><span class="line">CONFIG SET active-defrag-threshold-lower 10  <span class="comment"># 碎片率超过10%启动</span></span><br><span class="line">MEMORY PURGE                       <span class="comment"># 手动触发整理</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>重启Redis</strong>：最彻底但影响服务可用性</li>
<li><strong>优化数据结构</strong>：减少小对象，使用Hash存储相关数据</li>
</ol>
<h2 id="过期策略与删除机制"><a href="#过期策略与删除机制" class="headerlink" title="过期策略与删除机制"></a>过期策略与删除机制</h2><h3 id="三种过期删除策略"><a href="#三种过期删除策略" class="headerlink" title="三种过期删除策略"></a>三种过期删除策略</h3><p><strong>定时删除</strong>：设置过期时间时创建定时器，到期立即删除</p>
<ul>
<li>优点：及时释放内存</li>
<li>缺点：消耗CPU资源创建和管理定时器</li>
</ul>
<p><strong>惰性删除</strong>：访问key时检查是否过期，过期则删除</p>
<ul>
<li>优点：CPU友好，只在必要时删除</li>
<li>缺点：内存不友好，过期key可能长期占用内存</li>
</ul>
<p><strong>定期删除</strong>：定期随机检查部分key，删除过期的</p>
<ul>
<li>Redis的实际策略，平衡CPU和内存使用</li>
</ul>
<h3 id="Redis过期删除实现"><a href="#Redis过期删除实现" class="headerlink" title="Redis过期删除实现"></a>Redis过期删除实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的过期删除逻辑</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">activeExpireCycle</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">current_db</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">timelimit_exit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">        redisDb *db = server.db + current_db % server.dbnum;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">iteration</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (iteration &lt; <span class="number">20</span>) &#123;  <span class="comment">// 最多检查20个key</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sampled</span> <span class="operator">=</span> <span class="number">0</span>, expired = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 随机选择key检查过期</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                dictEntry *de = dictGetRandomKey(db-&gt;expires);</span><br><span class="line">                <span class="keyword">if</span> (de == NULL) <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                sampled++;</span><br><span class="line">                <span class="keyword">if</span> (keyIsExpired(db, de)) &#123;</span><br><span class="line">                    deleteExpiredKey(db, de);</span><br><span class="line">                    expired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果过期比例超过25%，继续下轮检查</span></span><br><span class="line">            <span class="keyword">if</span> (expired &gt; <span class="number">5</span>) iteration++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current_db++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构底层实现深度解析"><a href="#数据结构底层实现深度解析" class="headerlink" title="数据结构底层实现深度解析"></a>数据结构底层实现深度解析</h2><h3 id="压缩列表（ZipList）演进"><a href="#压缩列表（ZipList）演进" class="headerlink" title="压缩列表（ZipList）演进"></a>压缩列表（ZipList）演进</h3><p>Redis 7.0用ListPack替代了ZipList，解决了级联更新问题。</p>
<p><strong>ZipList问题</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZipList结构导致的级联更新</span></span><br><span class="line"><span class="comment">// 当插入元素导致某个entry的长度改变时</span></span><br><span class="line"><span class="comment">// 可能引起后续所有entry的重新编码</span></span><br></pre></td></tr></table></figure>

<p><strong>ListPack优势</strong>：</p>
<ul>
<li>每个元素独立编码，避免级联更新</li>
<li>支持从尾部遍历，提高某些操作效率</li>
</ul>
<h3 id="字典扩容与rehash"><a href="#字典扩容与rehash" class="headerlink" title="字典扩容与rehash"></a>字典扩容与rehash</h3><p>Redis字典使用增量式rehash避免阻塞：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渐进式rehash实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">empty_visits</span> <span class="operator">=</span> n * <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 跳过空桶</span></span><br><span class="line">        <span class="keyword">while</span> (d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == NULL) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 迁移桶中所有元素</span></span><br><span class="line">        dictEntry *de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            dictEntry *nextde = de-&gt;next;</span><br><span class="line">            unsigned <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = NULL;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络模型与性能优化"><a href="#网络模型与性能优化" class="headerlink" title="网络模型与性能优化"></a>网络模型与性能优化</h2><h3 id="Redis-6-0-多线程I-O"><a href="#Redis-6-0-多线程I-O" class="headerlink" title="Redis 6.0 多线程I&#x2F;O"></a>Redis 6.0 多线程I&#x2F;O</h3><p>多线程只用于网络I&#x2F;O，命令执行仍是单线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程I/O处理流程</span></span><br><span class="line"><span class="keyword">void</span> *IOThreadMain(<span class="keyword">void</span> *myid) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待主线程分配任务</span></span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[id]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (io_threads_list[id] &amp;&amp; io_threads_pending[id] == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;io_threads_cond[id], &amp;io_threads_mutex[id]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理读写任务</span></span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line">        listRewind(io_threads_list[id], &amp;li);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *c = listNodeValue(ln);</span><br><span class="line">            <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                writeToClient(c, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_READ) &#123;</span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        io_threads_pending[id] = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;io_threads_mutex[id]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端连接管理"><a href="#客户端连接管理" class="headerlink" title="客户端连接管理"></a>客户端连接管理</h3><p><strong>连接池配置优化</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Jedis连接池配置</span></span><br><span class="line"><span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">config.setMaxTotal(<span class="number">200</span>);                    <span class="comment">// 最大连接数</span></span><br><span class="line">config.setMaxIdle(<span class="number">50</span>);                      <span class="comment">// 最大空闲连接</span></span><br><span class="line">config.setMinIdle(<span class="number">10</span>);                      <span class="comment">// 最小空闲连接</span></span><br><span class="line">config.setTestOnBorrow(<span class="literal">true</span>);               <span class="comment">// 获取连接时测试</span></span><br><span class="line">config.setTestOnReturn(<span class="literal">true</span>);               <span class="comment">// 归还连接时测试</span></span><br><span class="line">config.setTestWhileIdle(<span class="literal">true</span>);              <span class="comment">// 空闲时测试</span></span><br><span class="line">config.setTimeBetweenEvictionRunsMillis(<span class="number">30000</span>);  <span class="comment">// 检查间隔</span></span><br><span class="line">config.setNumTestsPerEvictionRun(<span class="number">10</span>);       <span class="comment">// 每次检查连接数</span></span><br><span class="line">config.setMinEvictableIdleTimeMillis(<span class="number">60000</span>);     <span class="comment">// 最小空闲时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config, <span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Pipeline优化</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pipeline批量操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchSet</span><span class="params">(Map&lt;String, String&gt; data)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource()) &#123;</span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : data.entrySet()) &#123;</span><br><span class="line">            pipeline.set(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Object&gt; results = pipeline.syncAndReturnAll();</span><br><span class="line">        <span class="comment">// 处理结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高级数据类型与应用"><a href="#高级数据类型与应用" class="headerlink" title="高级数据类型与应用"></a>高级数据类型与应用</h2><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>用于基数统计，占用内存固定（12KB），误差率0.81%。</p>
<p><strong>实现原理</strong>：</p>
<ul>
<li>基于概率算法，通过观察随机数的最大前导零个数估算基数</li>
<li>使用调和平均数减少误差</li>
<li>适用于UV统计等场景</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网站UV统计</span></span><br><span class="line">PFADD uv:20230815 user1 user2 user3</span><br><span class="line">PFCOUNT uv:20230815                    <span class="comment"># 获取UV数量</span></span><br><span class="line">PFMERGE uv:week uv:20230815 uv:20230816  <span class="comment"># 合并多日数据</span></span><br></pre></td></tr></table></figure>

<h3 id="布隆过滤器（Redis-Module）"><a href="#布隆过滤器（Redis-Module）" class="headerlink" title="布隆过滤器（Redis Module）"></a>布隆过滤器（Redis Module）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis布隆过滤器模块</span></span><br><span class="line">BF.RESERVE myfilter 0.01 1000000       <span class="comment"># 创建过滤器，误报率0.01%，预期元素100万</span></span><br><span class="line">BF.ADD myfilter <span class="string">&quot;user123&quot;</span>              <span class="comment"># 添加元素</span></span><br><span class="line">BF.EXISTS myfilter <span class="string">&quot;user123&quot;</span>           <span class="comment"># 检查元素是否存在</span></span><br><span class="line">BF.MADD myfilter item1 item2 item3     <span class="comment"># 批量添加</span></span><br><span class="line">BF.MEXISTS myfilter item1 item2 item3  <span class="comment"># 批量检查</span></span><br></pre></td></tr></table></figure>

<h3 id="Geo地理位置"><a href="#Geo地理位置" class="headerlink" title="Geo地理位置"></a>Geo地理位置</h3><p>基于Sorted Set实现，使用GeoHash算法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加地理位置</span></span><br><span class="line">GEOADD cities 116.397128 39.916527 <span class="string">&quot;北京&quot;</span> 121.473701 31.230416 <span class="string">&quot;上海&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算距离</span></span><br><span class="line">GEODIST cities <span class="string">&quot;北京&quot;</span> <span class="string">&quot;上海&quot;</span> km</span><br><span class="line"></span><br><span class="line"><span class="comment"># 范围查询</span></span><br><span class="line">GEORADIUS cities 116.397128 39.916527 1000 km WITHDIST WITHCOORD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据成员查询</span></span><br><span class="line">GEORADIUSBYMEMBER cities <span class="string">&quot;北京&quot;</span> 1000 km</span><br></pre></td></tr></table></figure>

<h2 id="安全性问题与防护"><a href="#安全性问题与防护" class="headerlink" title="安全性问题与防护"></a>安全性问题与防护</h2><h3 id="常见安全漏洞"><a href="#常见安全漏洞" class="headerlink" title="常见安全漏洞"></a>常见安全漏洞</h3><p><strong>命令注入</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误做法：直接拼接用户输入</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;user:&quot;</span> + userInput;  <span class="comment">// userInput可能包含恶意命令</span></span><br><span class="line">jedis.eval(<span class="string">&quot;return redis.call(&#x27;get&#x27;, &#x27;&quot;</span> + key + <span class="string">&quot;&#x27;)&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法：使用参数化查询</span></span><br><span class="line">jedis.eval(<span class="string">&quot;return redis.call(&#x27;get&#x27;, KEYS[1])&quot;</span>, <span class="number">1</span>, key);</span><br></pre></td></tr></table></figure>

<p><strong>未授权访问</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis.conf安全配置</span></span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1                        <span class="comment"># 绑定指定IP</span></span><br><span class="line">requirepass your_password              <span class="comment"># 设置密码</span></span><br><span class="line">protected-mode <span class="built_in">yes</span>                     <span class="comment"># 开启保护模式</span></span><br><span class="line">port 0                                <span class="comment"># 禁用默认端口</span></span><br><span class="line">port 6380                             <span class="comment"># 使用非标准端口</span></span><br></pre></td></tr></table></figure>

<p><strong>危险命令禁用</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名危险命令</span></span><br><span class="line">rename-command FLUSHDB <span class="string">&quot;&quot;</span>             <span class="comment"># 禁用FLUSHDB</span></span><br><span class="line">rename-command FLUSHALL <span class="string">&quot;&quot;</span>            <span class="comment"># 禁用FLUSHALL</span></span><br><span class="line">rename-command SHUTDOWN <span class="string">&quot;REDIS_SHUTDOWN&quot;</span>  <span class="comment"># 重命名SHUTDOWN</span></span><br><span class="line">rename-command CONFIG <span class="string">&quot;REDIS_CONFIG&quot;</span>   <span class="comment"># 重命名CONFIG</span></span><br></pre></td></tr></table></figure>

<h3 id="ACL访问控制（Redis-6-0-）"><a href="#ACL访问控制（Redis-6-0-）" class="headerlink" title="ACL访问控制（Redis 6.0+）"></a>ACL访问控制（Redis 6.0+）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">ACL SETUSER alice on &gt;password123 ~cached:* +get +<span class="built_in">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看用户权限</span></span><br><span class="line">ACL LIST</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">ACL DELUSER alice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查权限</span></span><br><span class="line">AUTH alice password123</span><br></pre></td></tr></table></figure>

<h2 id="监控与运维"><a href="#监控与运维" class="headerlink" title="监控与运维"></a>监控与运维</h2><h3 id="关键监控指标"><a href="#关键监控指标" class="headerlink" title="关键监控指标"></a>关键监控指标</h3><p><strong>性能指标</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过INFO命令获取</span></span><br><span class="line">INFO stats</span><br><span class="line"><span class="comment"># 关注指标：</span></span><br><span class="line"><span class="comment"># - instantaneous_ops_per_sec: QPS</span></span><br><span class="line"><span class="comment"># - keyspace_hits/keyspace_misses: 命中率</span></span><br><span class="line"><span class="comment"># - used_cpu_sys/used_cpu_user: CPU使用率</span></span><br><span class="line"><span class="comment"># - connected_clients: 连接数</span></span><br><span class="line"><span class="comment"># - blocked_clients: 阻塞连接数</span></span><br></pre></td></tr></table></figure>

<p><strong>内存指标</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"><span class="comment"># 关注指标：</span></span><br><span class="line"><span class="comment"># - used_memory: 已使用内存</span></span><br><span class="line"><span class="comment"># - used_memory_rss: 物理内存占用</span></span><br><span class="line"><span class="comment"># - mem_fragmentation_ratio: 内存碎片率</span></span><br><span class="line"><span class="comment"># - used_memory_peak: 内存使用峰值</span></span><br></pre></td></tr></table></figure>

<p><strong>持久化指标</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO persistence</span><br><span class="line"><span class="comment"># 关注指标：</span></span><br><span class="line"><span class="comment"># - rdb_last_save_time: 最后RDB保存时间</span></span><br><span class="line"><span class="comment"># - aof_last_rewrite_time_sec: AOF重写耗时</span></span><br><span class="line"><span class="comment"># - aof_current_size: AOF文件大小</span></span><br></pre></td></tr></table></figure>

<h3 id="故障排查常用命令"><a href="#故障排查常用命令" class="headerlink" title="故障排查常用命令"></a>故障排查常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端连接信息</span></span><br><span class="line">CLIENT LIST</span><br><span class="line">CLIENT INFO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 慢查询分析</span></span><br><span class="line">SLOWLOG GET 10</span><br><span class="line">CONFIG GET slowlog-log-slower-than</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大key查找</span></span><br><span class="line">MEMORY USAGE keyname</span><br><span class="line">redis-cli --bigkeys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 热点key分析</span></span><br><span class="line">redis-cli --hotkeys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 延迟监控</span></span><br><span class="line">LATENCY HISTORY <span class="built_in">command</span></span><br><span class="line">CONFIG SET latency-monitor-threshold 100</span><br></pre></td></tr></table></figure>

<h2 id="特殊应用场景"><a href="#特殊应用场景" class="headerlink" title="特殊应用场景"></a>特殊应用场景</h2><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p><strong>固定窗口限流</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisRateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAllowed</span><span class="params">(String key, <span class="type">int</span> limit, <span class="type">int</span> window)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span> / window;</span><br><span class="line">        <span class="type">String</span> <span class="variable">windowKey</span> <span class="operator">=</span> key + <span class="string">&quot;:&quot;</span> + current;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> </span><br><span class="line">            <span class="string">&quot;local count = redis.call(&#x27;incr&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;if count == 1 then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;end &quot;</span> +</span><br><span class="line">            <span class="string">&quot;return count&quot;</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> (Long) jedis.eval(script, Arrays.asList(windowKey), </span><br><span class="line">                                      Arrays.asList(String.valueOf(window)));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count &lt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>滑动窗口限流</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">slidingWindowLimit</span><span class="params">(String key, <span class="type">int</span> limit, <span class="type">int</span> window)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">windowStart</span> <span class="operator">=</span> now - window * <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> </span><br><span class="line">        <span class="string">&quot;redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;local count = redis.call(&#x27;zcard&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;if count &lt; tonumber(ARGV[2]) then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  redis.call(&#x27;zadd&#x27;, KEYS[1], ARGV[3], ARGV[3]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[4]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  return 1 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;  return 0 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> (Long) jedis.eval(script, Arrays.asList(key),</span><br><span class="line">        Arrays.asList(String.valueOf(windowStart), String.valueOf(limit),</span><br><span class="line">                     String.valueOf(now), String.valueOf(window)));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSessionManager</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createSession</span><span class="params">(String sessionId, String userId, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;session:&quot;</span> + sessionId;</span><br><span class="line">        Map&lt;String, Object&gt; sessionData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        sessionData.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">        sessionData.put(<span class="string">&quot;createTime&quot;</span>, System.currentTimeMillis());</span><br><span class="line">        </span><br><span class="line">        redisTemplate.opsForHash().putAll(key, sessionData);</span><br><span class="line">        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSession</span><span class="params">(String sessionId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;session:&quot;</span> + sessionId;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">renewSession</span><span class="params">(String sessionId, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;session:&quot;</span> + sessionId;</span><br><span class="line">        <span class="keyword">if</span> (redisTemplate.hasKey(key)) &#123;</span><br><span class="line">            redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息队列实现"><a href="#消息队列实现" class="headerlink" title="消息队列实现"></a>消息队列实现</h3><p><strong>基于List的简单队列</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(String queue, String message)</span> &#123;</span><br><span class="line">        jedis.lpush(queue, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消费者（阻塞式）</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">consume</span><span class="params">(String queue, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = jedis.brpop(timeout, queue);</span><br><span class="line">        <span class="keyword">return</span> result != <span class="literal">null</span> ? result.get(<span class="number">1</span>) : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基于Stream的消息队列</strong>（Redis 5.0+）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产消息</span></span><br><span class="line"><span class="string">XADD</span> <span class="string">mystream</span> <span class="string">*</span> <span class="string">field1</span> <span class="string">value1</span> <span class="string">field2</span> <span class="string">value2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建消费者组</span></span><br><span class="line"><span class="string">XGROUP</span> <span class="string">CREATE</span> <span class="string">mystream</span> <span class="string">mygroup</span> <span class="string">$</span> <span class="string">MKSTREAM</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费消息</span></span><br><span class="line"><span class="string">XREADGROUP</span> <span class="string">GROUP</span> <span class="string">mygroup</span> <span class="string">consumer1</span> <span class="string">COUNT</span> <span class="number">10</span> <span class="string">STREAMS</span> <span class="string">mystream</span> <span class="string">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认消息</span></span><br><span class="line"><span class="string">XACK</span> <span class="string">mystream</span> <span class="string">mygroup</span> <span class="string">message_id</span></span><br></pre></td></tr></table></figure>

<h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDelayQueue</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDelayTask</span><span class="params">(String task, <span class="type">long</span> delayTime)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">executeTime</span> <span class="operator">=</span> System.currentTimeMillis() + delayTime;</span><br><span class="line">        jedis.zadd(<span class="string">&quot;delay_queue&quot;</span>, executeTime, task);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getReadyTasks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Set&lt;String&gt; tasks = jedis.zrangeByScore(<span class="string">&quot;delay_queue&quot;</span>, <span class="number">0</span>, now);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!tasks.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 原子性删除已获取的任务</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> </span><br><span class="line">                <span class="string">&quot;local tasks = redis.call(&#x27;zrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;if #tasks &gt; 0 then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;  redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return tasks&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            List&lt;String&gt; result = (List&lt;String&gt;) jedis.eval(script, </span><br><span class="line">                Arrays.asList(<span class="string">&quot;delay_queue&quot;</span>), Arrays.asList(String.valueOf(now)));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能调优技巧"><a href="#性能调优技巧" class="headerlink" title="性能调优技巧"></a>性能调优技巧</h2><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p><strong>使用Hash存储小对象</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐：为每个用户字段单独设置key</span></span><br><span class="line">jedis.set(<span class="string">&quot;user:1001:name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;user:1001:age&quot;</span>, <span class="string">&quot;25&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;user:1001:email&quot;</span>, <span class="string">&quot;zhang@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：使用Hash存储</span></span><br><span class="line">jedis.hset(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">jedis.hset(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;25&quot;</span>);</span><br><span class="line">jedis.hset(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;zhang@example.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>合理设置过期时间</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免同时过期导致雪崩</span></span><br><span class="line"><span class="type">int</span> <span class="variable">baseExpire</span> <span class="operator">=</span> <span class="number">3600</span>;  <span class="comment">// 1小时</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> baseExpire + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);  <span class="comment">// 增加0-5分钟随机时间</span></span><br><span class="line">jedis.setex(key, randomExpire, value);</span><br></pre></td></tr></table></figure>

<h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p><strong>批量操作优化</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Pipeline</span></span><br><span class="line"><span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    pipeline.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">pipeline.sync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用原生批量命令</span></span><br><span class="line">Map&lt;String, String&gt; batch = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ... 填充数据</span></span><br><span class="line">jedis.mset(flattenMap(batch));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p><strong>Lua脚本减少网络往返</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 原子性增加库存</span><br><span class="line"><span class="type">local</span> <span class="variable">current</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> current == <span class="literal">false</span> then</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  -- key不存在</span><br><span class="line"><span class="type">end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">current</span> <span class="operator">=</span> tonumber(current)</span><br><span class="line"><span class="keyword">if</span> current &gt;= tonumber(ARGV[<span class="number">1</span>]) then</span><br><span class="line">    redis.call(<span class="string">&#x27;decrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> current - tonumber(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">2</span>  -- 库存不足</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Charlotte</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/java%E7%9F%A5%E8%AF%86%E7%82%B9/">http://example.com/2025/09/11/java%E7%9F%A5%E8%AF%86%E7%82%B9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">浮生若梦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Hexo-Markdown/">Hexo, Markdown</a></div><div class="post-share"><div class="social-share" data-image="/img/title.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/8.21%E5%AD%A6%E4%BC%9A/" title="8.21学会"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">8.21学会</div></div><div class="info-2"><div class="info-item-1">1.实现单例模式 (Singleton Pattern)懒汉式：使用双重检查锁定 (DCL) 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。 1234567891011121314151617181920212223242526272829class Singleton &#123;    // 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到    private static volatile Singleton instance;    // 2. 私有化构造器，防止外部直接 new 实例    private Singleton() &#123;&#125;    // 3. 提供一个全局访问点，使用 DCL 确保线程安全    public static Singleton getInstance() &#123;        // 第一次检查：如果实例已经存在，直接返回，避免不必要的同步        if (instance == null) &#12...</div></div></div></a><a class="pagination-related  no-desc" href="/2025/09/11/my-first-post/" title="my-first-post"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">my-first-post</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/8.21%E5%AD%A6%E4%BC%9A/" title="8.21学会"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">8.21学会</div></div><div class="info-2"><div class="info-item-1">1.实现单例模式 (Singleton Pattern)懒汉式：使用双重检查锁定 (DCL) 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。 1234567891011121314151617181920212223242526272829class Singleton &#123;    // 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到    private static volatile Singleton instance;    // 2. 私有化构造器，防止外部直接 new 实例    private Singleton() &#123;&#125;    // 3. 提供一个全局访问点，使用 DCL 确保线程安全    public static Singleton getInstance() &#123;        // 第一次检查：如果实例已经存在，直接返回，避免不必要的同步        if (instance == null) &#12...</div></div></div></a><a class="pagination-related no-desc" href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" title="命令大全"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">命令大全</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">分布式</div></div><div class="info-2"><div class="info-item-1">1. Spring Cloud 体系核心思想Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的规范和解决方案的集合。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。 Netflix OSS 常用组件（部分进入维护模式） 服务注册与发现 (Service Discovery): Eureka 作用: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。 使用: 服务端添加 spring-cloud-starter-netflix-eureka-server 依赖，并使用 @EnableEurekaServer 注解。客...</div></div></div></a><a class="pagination-related no-desc" href="/2025/09/11/%E6%A1%86%E6%9E%B6/" title="框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">框架</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/" title="手写答案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">手写答案</div></div><div class="info-2"><div class="info-item-1">1.实现单例模式 (Singleton Pattern)懒汉式：使用双重检查锁定 (DCL) 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。 1234567891011121314151617181920212223242526272829class Singleton &#123;    // 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到    private static volatile Singleton instance;    // 2. 私有化构造器，防止外部直接 new 实例    private Singleton() &#123;&#125;    // 3. 提供一个全局访问点，使用 DCL 确保线程安全    public static Singleton getInstance() &#123;        // 第一次检查：如果实例已经存在，直接返回，避免不必要的同步        if (instance == null) &#12...</div></div></div></a><a class="pagination-related" href="/2025/09/11/web/" title="web"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">web</div></div><div class="info-2"><div class="info-item-1">好的，让我们深入到 HTTP 协议的底层，全面解剖它的工作原理、请求-响应模型、以及各个组成部分。  一、HTTP 协议概述HTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，它定义了 Web 客户端（如浏览器）和 Web 服务器之间交换数据的规则。它的核心特点是无状态（Stateless），这意味着服务器不会保存客户端的任何信息，每次请求都是独立的。  二、HTTP 请求（Request）一个完整的 HTTP 请求由四部分组成： 1. 请求行（Request Line）这是请求的第一行，它定义了请求的基本信息。  请求方法（Method）：如 GET, POST, PUT, DELETE 等，表示对资源的操作类型。 请求 URL (URI)：资源的地址。 HTTP 协议版本：如 HTTP/1.1, HTTP/2.0。  示例： GET &#x2F;index.html HTTP&#x2F;1.1 2. 请求头（Request Headers）请求头提供了关于客户端、请求体和一些其他元数据的信息。它们以键值对的形式存在。  Host：指...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/title.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Charlotte</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/charlotte030710"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、网络基础概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">二、OSI 七层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%89%A9%E7%90%86%E5%B1%82%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. 物理层深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 数据链路层深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.0.3.</span> <span class="toc-text">3. 网络层深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BC%A0%E8%BE%93%E5%B1%82%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.0.4.</span> <span class="toc-text">4. 传输层深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP"><span class="toc-number">2.0.4.2.</span> <span class="toc-text">UDP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BC%9A%E8%AF%9D%E5%B1%82%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.0.5.</span> <span class="toc-text">5. 会话层深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%A1%A8%E7%A4%BA%E5%B1%82%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.0.6.</span> <span class="toc-text">6. 表示层深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%BA%94%E7%94%A8%E5%B1%82%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.0.7.</span> <span class="toc-text">7. 应用层深度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81TCP-IP-%E5%8D%8F%E8%AE%AE%E6%97%8F%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">三、TCP&#x2F;IP 协议族（详细版）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%80%BB%E7%BB%93"><span class="toc-number">3.0.1.</span> <span class="toc-text">TCP 三次握手总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%80%BB%E7%BB%93"><span class="toc-number">3.0.2.</span> <span class="toc-text">TCP 四次挥手总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81TCP-%E4%B8%8E-UDP-%E5%8C%BA%E5%88%AB%EF%BC%88%E6%B7%B1%E5%85%A5%E7%89%88%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">一、TCP 与 UDP 区别（深入版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%88%E6%B7%B1%E5%85%A5%E7%89%88%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">二、三次握手的意义（深入版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81TIME-WAIT-%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%88%E6%B7%B1%E5%85%A5%E7%89%88%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">三、TIME_WAIT 的意义（深入版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81OSI-%E4%B8%83%E5%B1%82-vs-TCP-IP-%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%B7%B1%E5%85%A5%E7%89%88%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">四、OSI 七层 vs TCP&#x2F;IP 模型（深入版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">3.5.</span> <span class="toc-text">1. 物理层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">3.6.</span> <span class="toc-text">2. 数据链路层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">3.7.</span> <span class="toc-text">3. 网络层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">3.8.</span> <span class="toc-text">4. 传输层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BC%9A%E8%AF%9D%E5%B1%82"><span class="toc-number">3.9.</span> <span class="toc-text">5. 会话层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%A1%A8%E7%A4%BA%E5%B1%82"><span class="toc-number">3.10.</span> <span class="toc-text">6. 表示层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">3.11.</span> <span class="toc-text">7. 应用层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">3.12.</span> <span class="toc-text">一、前后端交互的基本流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F"><span class="toc-number">3.13.</span> <span class="toc-text">二、前后端交互方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HTTP-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.13.1.</span> <span class="toc-text">1. HTTP 请求-响应模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-WebSocket-%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">3.13.2.</span> <span class="toc-text">2. WebSocket 实时通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Server-Sent-Events%EF%BC%88SSE%EF%BC%89"><span class="toc-number">3.13.3.</span> <span class="toc-text">3. Server-Sent Events（SSE）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-GraphQL"><span class="toc-number">3.13.4.</span> <span class="toc-text">4. GraphQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%89%8D%E5%90%8E%E7%AB%AF%E5%93%8D%E5%BA%94%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.14.</span> <span class="toc-text">三、前后端响应示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%8A%B6%E6%80%81%E7%A0%81%E4%B8%8E%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B"><span class="toc-number">3.15.</span> <span class="toc-text">四、状态码与响应流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux"><span class="toc-number">4.</span> <span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">一、基础命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.1.</span> <span class="toc-text">1. 文件和目录操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E4%B8%8E%E7%BC%96%E8%BE%91"><span class="toc-number">4.1.2.</span> <span class="toc-text">2. 文件查看与编辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">二、用户与权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-number">4.2.1.</span> <span class="toc-text">1. 用户管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">4.2.2.</span> <span class="toc-text">2. 权限管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">三、进程管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">四、网络管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">五、包管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">4.6.</span> <span class="toc-text">六、磁盘与文件系统管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86"><span class="toc-number">4.7.</span> <span class="toc-text">七、日志管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">4.8.</span> <span class="toc-text">八、系统管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B"><span class="toc-number">4.9.</span> <span class="toc-text">九、压缩与解压</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81Shell-%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%89"><span class="toc-number">4.10.</span> <span class="toc-text">十、Shell 脚本基础（详细版）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F"><span class="toc-number">4.10.1.</span> <span class="toc-text">1. 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">4.10.2.</span> <span class="toc-text">2. 条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.10.3.</span> <span class="toc-text">3. 循环语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0"><span class="toc-number">4.10.4.</span> <span class="toc-text">4. 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">4.10.5.</span> <span class="toc-text">5. 输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90"><span class="toc-number">4.10.6.</span> <span class="toc-text">6. 脚本执行权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AE%9E%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.10.7.</span> <span class="toc-text">7. 实用示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Linux-%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%85%A8%E9%9D%A2%E7%89%88%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">十一、Linux 面试常问知识点（全面版）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">1. 文件权限与权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A"><span class="toc-number">5.1.1.</span> <span class="toc-text">核心知识点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">5.1.2.</span> <span class="toc-text">面试常问问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">2. 进程与作业管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">核心知识点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98%EF%BC%9A-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">面试常问问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">3. 文件系统与磁盘管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A-2"><span class="toc-number">5.3.1.</span> <span class="toc-text">核心知识点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98%EF%BC%9A-2"><span class="toc-number">5.3.2.</span> <span class="toc-text">面试常问问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86"><span class="toc-number">5.4.</span> <span class="toc-text">4. 网络管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A-3"><span class="toc-number">5.4.1.</span> <span class="toc-text">核心知识点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98%EF%BC%9A-3"><span class="toc-number">5.4.2.</span> <span class="toc-text">面试常问问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84%E7%AE%A1%E7%90%86"><span class="toc-number">5.5.</span> <span class="toc-text">5. 用户与组管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A-4"><span class="toc-number">5.5.1.</span> <span class="toc-text">核心知识点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98%EF%BC%9A-4"><span class="toc-number">5.5.2.</span> <span class="toc-text">面试常问问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Shell-%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80"><span class="toc-number">5.6.</span> <span class="toc-text">6. Shell 脚本基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A-5"><span class="toc-number">5.6.1.</span> <span class="toc-text">核心知识点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98%EF%BC%9A-5"><span class="toc-number">5.6.2.</span> <span class="toc-text">面试常问问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88Crontab%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">7. 定时任务（Crontab）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A-6"><span class="toc-number">5.7.1.</span> <span class="toc-text">核心知识点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="toc-number">5.8.</span> <span class="toc-text">8. 系统日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A-7"><span class="toc-number">5.8.1.</span> <span class="toc-text">核心知识点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">5.9.</span> <span class="toc-text">9. 系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A-8"><span class="toc-number">5.9.1.</span> <span class="toc-text">核心知识点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98%EF%BC%9A-6"><span class="toc-number">5.9.2.</span> <span class="toc-text">面试常问问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89"><span class="toc-number">5.10.</span> <span class="toc-text">10. 综合示例（面试题）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">6.</span> <span class="toc-text">MySQL 数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.1.</span> <span class="toc-text">SQL语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-DML-Data-Manipulation-Language-%E2%80%94-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.</span> <span class="toc-text">1. DML (Data Manipulation Language) — 数据操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-SELECT-%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.1 SELECT 查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">聚合函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">分组查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E6%8E%A5%E6%9F%A5%E8%AF%A2-JOIN"><span class="toc-number">6.2.1.3.</span> <span class="toc-text">联接查询 (JOIN)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-INSERT-%E6%8F%92%E5%85%A5"><span class="toc-number">6.2.2.</span> <span class="toc-text">1.2 INSERT 插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-UPDATE-%E6%9B%B4%E6%96%B0"><span class="toc-number">6.2.3.</span> <span class="toc-text">1.3 UPDATE 更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-DELETE-%E5%88%A0%E9%99%A4"><span class="toc-number">6.2.4.</span> <span class="toc-text">1.4 DELETE 删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-DDL-Data-Definition-Language-%E2%80%94-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">6.3.</span> <span class="toc-text">2. DDL (Data Definition Language) — 数据定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-DCL-Data-Control-Language-%E2%80%94-%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">6.4.</span> <span class="toc-text">3. DCL (Data Control Language) — 数据权限控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-TCL-Transaction-Control-Language-%E2%80%94-%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="toc-number">6.5.</span> <span class="toc-text">4. TCL (Transaction Control Language) — 事务控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-EXPLAIN-%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90-%E2%80%94-SQL-%E4%BC%98%E5%8C%96%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7"><span class="toc-number">6.6.</span> <span class="toc-text">5. EXPLAIN 查询分析 — SQL 优化核心工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-EXPLAIN-%E6%A0%B8%E5%BF%83%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90"><span class="toc-number">6.6.1.</span> <span class="toc-text">5.1 EXPLAIN 核心字段解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-type-%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%EF%BC%88%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">6.6.2.</span> <span class="toc-text">5.2 type 类型说明（访问方式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="toc-number">6.6.3.</span> <span class="toc-text">5.3 优化建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1-Transaction"><span class="toc-number">6.7.</span> <span class="toc-text">事务 (Transaction)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95-Index"><span class="toc-number">7.</span> <span class="toc-text">索引 (Index)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">7.1.</span> <span class="toc-text">1. 索引的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">7.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">7.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-%E2%80%94-B-%E6%A0%91"><span class="toc-number">7.2.</span> <span class="toc-text">2. 索引底层实现 — B+ 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%89%B9%E7%82%B9"><span class="toc-number">7.2.1.</span> <span class="toc-text">B+ 树特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">7.3.</span> <span class="toc-text">3. 索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-Primary-Key-Index"><span class="toc-number">7.3.1.</span> <span class="toc-text">3.1 主键索引 (Primary Key Index)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95-Unique-Index"><span class="toc-number">7.3.2.</span> <span class="toc-text">3.2 唯一索引 (Unique Index)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95-Normal-Index-Non-Unique-Index"><span class="toc-number">7.3.3.</span> <span class="toc-text">3.3 普通索引 (Normal Index &#x2F; Non-Unique Index)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95-Fulltext-Index"><span class="toc-number">7.3.4.</span> <span class="toc-text">3.4 全文索引 (Fulltext Index)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95-Composite-Multi-Column-Index"><span class="toc-number">7.3.5.</span> <span class="toc-text">3.5 复合索引 (Composite &#x2F; Multi-Column Index)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">7.4.</span> <span class="toc-text">4. 聚集索引与非聚集索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-Clustered-Index"><span class="toc-number">7.4.1.</span> <span class="toc-text">4.1 聚集索引 (Clustered Index)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-Non-Clustered-Index"><span class="toc-number">7.4.2.</span> <span class="toc-text">4.2 非聚集索引 (Non-Clustered Index)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">7.5.</span> <span class="toc-text">5. 索引优化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97%E9%80%89%E6%8B%A9"><span class="toc-number">7.5.1.</span> <span class="toc-text">5.1 创建索引的列选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%81%B5%E5%BE%AA%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="toc-number">7.5.2.</span> <span class="toc-text">5.2 遵循最左前缀原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">7.5.3.</span> <span class="toc-text">5.3 避免索引失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95-Covering-Index"><span class="toc-number">7.5.4.</span> <span class="toc-text">5.4 覆盖索引 (Covering Index)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E9%98%B2%E6%AD%A2%E5%9B%9E%E8%A1%A8"><span class="toc-number">7.5.5.</span> <span class="toc-text">5.5 防止回表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E5%AE%9A%E6%9C%9F%E7%BB%B4%E6%8A%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">7.5.6.</span> <span class="toc-text">5.6 定期维护索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81B-%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9"><span class="toc-number">7.6.</span> <span class="toc-text">一、B+树的结构特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B2%BE%E7%A1%AE%E6%9F%A5%E6%89%BE%E6%9F%90%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%89"><span class="toc-number">7.7.</span> <span class="toc-text">二、定位过程（精确查找某条记录）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B2%BE%E7%A1%AE%E6%9F%A5%E6%89%BE%EF%BC%88%E4%B8%BB%E9%94%AE%E6%9F%A5%E6%89%BE%EF%BC%89"><span class="toc-number">7.7.1.</span> <span class="toc-text">1. 精确查找（主键查找）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%EF%BC%88%E9%9D%9E%E4%B8%BB%E9%94%AE%E6%9F%A5%E6%89%BE%EF%BC%89"><span class="toc-number">7.7.2.</span> <span class="toc-text">2. 辅助索引查找（非主键查找）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E2%80%9C%E7%B2%BE%E7%A1%AE%E5%AE%9A%E4%BD%8D%E2%80%9D"><span class="toc-number">7.8.</span> <span class="toc-text">三、为什么能“精确定位”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%B1%BB%E6%AF%94%E7%90%86%E8%A7%A3"><span class="toc-number">7.9.</span> <span class="toc-text">四、类比理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-number">7.9.0.1.</span> <span class="toc-text">SQL优化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">8.</span> <span class="toc-text">MySQL 存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E8%AF%B4%E6%98%8E"><span class="toc-number">8.1.</span> <span class="toc-text">额外说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC%EF%BC%88%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%89%EF%BC%9A"><span class="toc-number">8.2.</span> <span class="toc-text">MVCC（多版本并发控制）：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MVCC%EF%BC%9F"><span class="toc-number">8.2.1.</span> <span class="toc-text">什么是 MVCC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.2.</span> <span class="toc-text">MVCC 的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">8.2.3.</span> <span class="toc-text">面试题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-MVCC%EF%BC%9F%E5%AE%83%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">1. 什么是 MVCC？它解决了什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MVCC-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88Repeatable-Read%EF%BC%89%E7%9A%84%EF%BC%9F"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">2. MVCC 是如何实现可重复读（Repeatable Read）的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-MVCC-%E8%83%BD%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E5%90%97%EF%BC%9F"><span class="toc-number">8.2.3.3.</span> <span class="toc-text">3. MVCC 能解决幻读吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Undo-Log-%E5%92%8C-Redo-Log-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.2.3.4.</span> <span class="toc-text">4. Undo Log 和 Redo Log 有什么区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%97%A5%E5%BF%97"><span class="toc-number">8.3.</span> <span class="toc-text">MySQL日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97-Error-Log"><span class="toc-number">8.4.</span> <span class="toc-text">1. 错误日志(Error Log)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97-Query-Log-%E9%80%9A%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97-General-Query-Log"><span class="toc-number">8.5.</span> <span class="toc-text">2. 查询日志(Query Log)&#x2F;通用查询日志(General Query Log)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97-Slow-Query-Log"><span class="toc-number">8.6.</span> <span class="toc-text">3. 慢查询日志(Slow Query Log)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97-Transaction-Log"><span class="toc-number">8.7.</span> <span class="toc-text">4. 事务日志(Transaction Log)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97-Binary-Log-Binlog"><span class="toc-number">8.8.</span> <span class="toc-text">5. 二进制日志(Binary Log&#x2F;Binlog)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97-Relay-Log"><span class="toc-number">8.9.</span> <span class="toc-text">扩展：中继日志(Relay Log)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.10.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%AD%E7%9A%84%E9%94%81"><span class="toc-number">8.11.</span> <span class="toc-text">MySQL中的锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">8.12.</span> <span class="toc-text">第一部分：数据库锁系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB%E4%BD%93%E7%B3%BB"><span class="toc-number">8.12.1.</span> <span class="toc-text">1. 锁的分类体系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%8C%89%E9%94%81%E7%B2%92%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%88%86%E7%B1%BB"><span class="toc-number">8.12.1.1.</span> <span class="toc-text">1.1 按锁粒度的层次分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%8C%89%E9%94%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB"><span class="toc-number">8.12.1.2.</span> <span class="toc-text">1.2 按锁模式的功能分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%8C%89%E9%94%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E7%B1%BB"><span class="toc-number">8.12.1.3.</span> <span class="toc-text">1.3 按锁算法的实现分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-InnoDB%E9%94%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B7%B1%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.12.2.</span> <span class="toc-text">2. InnoDB锁系统的深层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E9%94%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.12.2.1.</span> <span class="toc-text">2.1 锁对象的数据结构设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%9A%84%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95"><span class="toc-number">8.12.2.2.</span> <span class="toc-text">2.2 死锁检测的高级算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-MVCC%E4%B8%8E%E9%94%81%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%9B%86%E6%88%90"><span class="toc-number">8.12.2.3.</span> <span class="toc-text">2.3 MVCC与锁的深度集成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">8.12.3.</span> <span class="toc-text">3. 数据库锁的性能优化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%94%81%E7%AD%89%E5%BE%85%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E7%AD%96%E7%95%A5"><span class="toc-number">8.12.3.1.</span> <span class="toc-text">3.1 锁等待的自适应策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%AF%B9%E9%94%81%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">8.12.3.2.</span> <span class="toc-text">3.2 索引设计对锁性能的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E4%BA%8B%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%AF%B9%E9%94%81%E6%80%A7%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">8.12.3.3.</span> <span class="toc-text">3.3 事务设计对锁性能的优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%EF%BC%88Row-Lock%EF%BC%89"><span class="toc-number">8.13.</span> <span class="toc-text">行锁（Row Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E7%9A%84%E8%A1%8C%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.14.</span> <span class="toc-text">InnoDB的行锁实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%94%81%EF%BC%88Table-Lock%EF%BC%89"><span class="toc-number">8.15.</span> <span class="toc-text">表锁（Table Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM%E7%9A%84%E8%A1%A8%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.16.</span> <span class="toc-text">MyISAM的表锁实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF"><span class="toc-number">9.</span> <span class="toc-text">Java 核心技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88Primitive-Data-Types%EF%BC%89"><span class="toc-number">9.1.1.</span> <span class="toc-text">八个基本数据类型（Primitive Data Types）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B4%E5%9E%8B"><span class="toc-number">9.1.1.1.</span> <span class="toc-text">1. 整型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">9.1.1.2.</span> <span class="toc-text">2. 浮点型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-number">9.1.1.3.</span> <span class="toc-text">3. 字符型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">9.1.1.4.</span> <span class="toc-text">4. 布尔型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">9.1.2.</span> <span class="toc-text">自动拆装箱的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.3.</span> <span class="toc-text">自动拆装箱的底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.3.1.</span> <span class="toc-text">1. 自动装箱的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.3.2.</span> <span class="toc-text">2. 自动拆箱的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E6%BD%9C%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.4.</span> <span class="toc-text">注意事项与潜在问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-number">9.1.5.</span> <span class="toc-text">什么是静态变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.1.6.</span> <span class="toc-text">静态变量的内存分配与生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-number">9.1.7.</span> <span class="toc-text">如何访问静态变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.1.8.</span> <span class="toc-text">静态变量的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%BC%BA%E7%82%B9%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">9.1.9.</span> <span class="toc-text">静态变量的缺点与注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">9.1.10.</span> <span class="toc-text">1. 分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-number">9.1.11.</span> <span class="toc-text">2. 初始化实例变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.12.</span> <span class="toc-text">3. 调用构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">9.1.13.</span> <span class="toc-text">new 关键字与构造方法的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">9.1.14.</span> <span class="toc-text">new 关键字的局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object"><span class="toc-number">9.2.</span> <span class="toc-text">Object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-String-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%AE%E6%94%B9%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">9.2.1.</span> <span class="toc-text">4. String 字符串修改实现的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-String-str-%E2%80%9Ci%E2%80%9D-%E4%B8%8E-String-str-new-String-%E2%80%9Ci%E2%80%9D-%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F"><span class="toc-number">9.2.2.</span> <span class="toc-text">5. String str &#x3D; “i” 与 String str &#x3D; new String(“i”) 一样吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-String-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.2.3.</span> <span class="toc-text">6. String 类的常用方法都有那些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-final-%E4%BF%AE%E9%A5%B0-StringBuffer-%E5%90%8E%E8%BF%98%E5%8F%AF%E4%BB%A5-append-%E5%90%97%EF%BC%9F"><span class="toc-number">9.2.4.</span> <span class="toc-text">7. final 修饰 StringBuffer 后还可以 append 吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">9.2.4.1.</span> <span class="toc-text">String 的核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.4.2.</span> <span class="toc-text">String 的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8-char-%E6%95%B0%E7%BB%84%E4%BB%A3%E6%9B%BF-String%EF%BC%9F"><span class="toc-number">9.2.4.3.</span> <span class="toc-text">为什么不用 char 数组代替 String？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E-String-%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.2.5.</span> <span class="toc-text">基本类型与 String 的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E9%80%BB%E8%BE%91%E4%B8%8E-%E6%8C%89%E4%BD%8D%E4%B8%8E%EF%BC%89"><span class="toc-number">9.2.6.</span> <span class="toc-text">&amp;（逻辑与 &#x2F; 按位与）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E7%9F%AD%E8%B7%AF%E9%80%BB%E8%BE%91%E4%B8%8E%EF%BC%89"><span class="toc-number">9.2.7.</span> <span class="toc-text">&amp;&amp;（短路逻辑与）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">9.2.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">9.3.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exception-%E5%92%8C-Error-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.3.1.</span> <span class="toc-text">Exception 和 Error 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%90%EF%B8%8FChecked-Exception-%E5%92%8C-Unchecked-Exception-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.3.2.</span> <span class="toc-text">⭐️Checked Exception 和 Unchecked Exception 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.3.3.</span> <span class="toc-text">Throwable 类常用方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch-finally-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">9.3.4.</span> <span class="toc-text">try-catch-finally 如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Error-%E5%92%8C-Exception-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.3.5.</span> <span class="toc-text">5. Error 和 Exception 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">9.3.6.</span> <span class="toc-text">6. 运行时异常与受检异常有何异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-throw-%E5%92%8C-throws-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.3.7.</span> <span class="toc-text">7. throw 和 throws 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.3.8.</span> <span class="toc-text">8. 常见的异常类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%88%B0%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%90%97%EF%BC%9F"><span class="toc-number">9.3.9.</span> <span class="toc-text">9. 主线程可以捕获到子线程的异常吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.10.</span> <span class="toc-text">捕获子线程异常的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-try-catch-%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86"><span class="toc-number">9.3.10.1.</span> <span class="toc-text">1. 使用 try-catch 在子线程内部处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E6%9C%AA%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8-UncaughtExceptionHandler"><span class="toc-number">9.3.10.2.</span> <span class="toc-text">2. 设置未捕获异常处理器 (UncaughtExceptionHandler)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">9.3.11.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">9.4.</span> <span class="toc-text">创建对象：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-new-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.4.1.</span> <span class="toc-text">1. 使用 new 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-Class-%E7%B1%BB%E7%9A%84-newInstance-%E6%96%B9%E6%B3%95%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%89"><span class="toc-number">9.4.2.</span> <span class="toc-text">2. 使用 Class 类的 newInstance() 方法（反射）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-clone-%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.3.</span> <span class="toc-text">3. 使用 clone() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88Deserialization%EF%BC%89"><span class="toc-number">9.4.4.</span> <span class="toc-text">4. 反序列化（Deserialization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">9.4.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%88Shallow-Copy%EF%BC%89"><span class="toc-number">9.4.6.</span> <span class="toc-text">浅拷贝（Shallow Copy）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9Aclone-%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.6.1.</span> <span class="toc-text">实现方式：clone() 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88Deep-Copy%EF%BC%89"><span class="toc-number">9.4.7.</span> <span class="toc-text">深拷贝（Deep Copy）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92%E5%A4%8D%E5%88%B6"><span class="toc-number">9.4.7.1.</span> <span class="toc-text">实现方式一：手动实现递归复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">9.4.7.2.</span> <span class="toc-text">实现方式二：序列化与反序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9A"><span class="toc-number">9.5.</span> <span class="toc-text">接口和抽象类：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">9.5.1.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.5.2.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-number">9.5.3.</span> <span class="toc-text">核心区别总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%97%AE%E7%9A%84%E6%B7%B1%E5%85%A5%E9%97%AE%E9%A2%98"><span class="toc-number">9.5.4.</span> <span class="toc-text">面试官可能会问的深入问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy-Pattern%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">代理模式（Proxy Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">10.1.</span> <span class="toc-text">1. 代理模式的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="toc-number">10.2.</span> <span class="toc-text">2. 代理模式的几种类型及特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">10.2.1.</span> <span class="toc-text">3. 代理模式的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-number">10.2.2.</span> <span class="toc-text">如何实现动态代理？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">10.2.2.1.</span> <span class="toc-text">核心组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.2.2.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#invoke-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-number">10.2.2.3.</span> <span class="toc-text">invoke() 方法的参数解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E7%B1%BB%EF%BC%9A"><span class="toc-number">10.3.</span> <span class="toc-text">成员类：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%B1%BB%EF%BC%88Static-Member-Class%EF%BC%89"><span class="toc-number">10.3.1.</span> <span class="toc-text">1. 静态成员类（Static Member Class）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Inner-Class%EF%BC%89"><span class="toc-number">10.3.2.</span> <span class="toc-text">2. 内部类（Inner Class）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Local-Inner-Class%EF%BC%89"><span class="toc-number">10.3.3.</span> <span class="toc-text">3. 局部内部类（Local Inner Class）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Anonymous-Inner-Class%EF%BC%89"><span class="toc-number">10.3.4.</span> <span class="toc-text">4. 匿名内部类（Anonymous Inner Class）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E8%83%BD%E7%94%A8-final%EF%BC%9F"><span class="toc-number">10.3.5.</span> <span class="toc-text">匿名内部类中的局部变量为什么只能用 final？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-8-%E4%B9%8B%E5%90%8E%E7%9A%84%E6%94%B9%E5%8F%98%EF%BC%9A%E2%80%9C%E4%BA%8B%E5%AE%9E%E4%B8%8A%E7%9A%84-final%E2%80%9D%EF%BC%88Effectively-Final%EF%BC%89"><span class="toc-number">10.3.6.</span> <span class="toc-text">Java 8 之后的改变：“事实上的 final”（Effectively Final）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E8%A1%A8%E6%A0%BC"><span class="toc-number">10.3.7.</span> <span class="toc-text">总结表格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-Anonymous-Inner-Class"><span class="toc-number">10.3.8.</span> <span class="toc-text">1. 匿名内部类 (Anonymous Inner Class)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-Functional-Interface"><span class="toc-number">10.3.9.</span> <span class="toc-text">2. 函数式接口 (Functional Interface)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F-Lambda-Expression"><span class="toc-number">10.3.10.</span> <span class="toc-text">3. Lambda 表达式 (Lambda Expression)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">10.3.11.</span> <span class="toc-text">常见的面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.3.11.1.</span> <span class="toc-text">1. 匿名内部类、Lambda 表达式和函数式接口之间的关系是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%AA%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">10.3.11.2.</span> <span class="toc-text">2. 为什么 Lambda 表达式只能实现函数式接口？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%9C%A8%E4%BD%BF%E7%94%A8-this-%E5%85%B3%E9%94%AE%E5%AD%97%E6%97%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.3.11.3.</span> <span class="toc-text">3. Lambda 表达式和匿名内部类在使用 this 关键字时有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8D%95%E8%8E%B7%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF-final-%E7%9A%84%EF%BC%9F"><span class="toc-number">10.3.11.4.</span> <span class="toc-text">4. Lambda 表达式捕获的局部变量为什么必须是 final 的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A"><span class="toc-number">10.4.</span> <span class="toc-text">Lambda表达式：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.4.1.</span> <span class="toc-text">Lambda 表达式的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%EF%BC%9A%E7%94%9F%E6%88%90-invokedynamic-%E6%8C%87%E4%BB%A4"><span class="toc-number">10.4.1.1.</span> <span class="toc-text">编译时：生成 invokedynamic 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%9A%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">10.4.1.2.</span> <span class="toc-text">运行时：动态绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.4.2.</span> <span class="toc-text">Lambda 表达式与匿名内部类的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">10.5.</span> <span class="toc-text">switch语句支持的数据类型：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.5.1.</span> <span class="toc-text">1. 基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">10.5.2.</span> <span class="toc-text">2. 包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-enum"><span class="toc-number">10.5.3.</span> <span class="toc-text">3. 枚举类型 (enum)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-String-%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.5.4.</span> <span class="toc-text">4. String 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">10.5.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">10.6.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E7%BD%AE%E9%94%81%EF%BC%9Asynchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">10.6.1.</span> <span class="toc-text">1. 内置锁：synchronized 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">10.6.2.</span> <span class="toc-text">底层实现机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B"><span class="toc-number">10.6.3.</span> <span class="toc-text">锁升级的演进过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM-%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">JVM 锁的升级过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%EF%BC%88%E6%97%A0%E9%94%81%E7%8A%B6%E6%80%81%EF%BC%89"><span class="toc-number">11.1.</span> <span class="toc-text">1. 普通对象（无锁状态）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%81%8F%E5%90%91%E9%94%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8A%A0%E9%94%81%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">2. 偏向锁初始化（第一次加锁）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%81%8F%E5%90%91%E9%94%81%E9%87%8D%E5%85%A5%EF%BC%88%E7%BA%BF%E7%A8%8B-A-%E5%86%8D%E6%AC%A1%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">3. 偏向锁重入（线程 A 再次获取锁）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%81%8F%E5%90%91%E9%94%81%E7%AB%9E%E4%BA%89%EF%BC%88%E7%BA%BF%E7%A8%8B-B-%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%89"><span class="toc-number">11.4.</span> <span class="toc-text">4. 偏向锁竞争（线程 B 尝试获取锁）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88Lightweight-Lock%EF%BC%89"><span class="toc-number">11.5.</span> <span class="toc-text">5. 轻量级锁（Lightweight Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%88Spin-Lock%EF%BC%89"><span class="toc-number">11.6.</span> <span class="toc-text">6. 自旋锁（Spin Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88Heavyweight-Lock%EF%BC%89"><span class="toc-number">11.7.</span> <span class="toc-text">7. 重量级锁（Heavyweight Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%91-%E6%80%BB%E7%BB%93%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">11.8.</span> <span class="toc-text">🔑 总结锁升级过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">11.8.1.</span> <span class="toc-text">自动化的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%98%BE%E5%BC%8F%E9%94%81%EF%BC%9Ajava-util-concurrent-locks-Lock"><span class="toc-number">11.8.2.</span> <span class="toc-text">2. 显式锁：java.util.concurrent.locks.Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="toc-number">11.8.3.</span> <span class="toc-text">Lock接口的设计理念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">11.8.4.</span> <span class="toc-text">显式锁机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">11.8.5.</span> <span class="toc-text">AQS框架的核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">11.8.6.</span> <span class="toc-text">3. volatile 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B9%90%E8%A7%82%E9%94%81-Optimistic-Locking"><span class="toc-number">11.8.7.</span> <span class="toc-text">4. 乐观锁 (Optimistic Locking)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%AD%BB%E9%94%81-Deadlock"><span class="toc-number">11.8.8.</span> <span class="toc-text">5. 死锁 (Deadlock)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">11.8.8.1.</span> <span class="toc-text">死锁的四个必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">11.8.8.2.</span> <span class="toc-text">死锁的解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">11.8.9.</span> <span class="toc-text">银行家算法概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.8.10.</span> <span class="toc-text">银行家算法中的几个重要数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%9A%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">11.8.11.</span> <span class="toc-text">银行家算法的核心：安全状态的判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9A%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D"><span class="toc-number">11.8.12.</span> <span class="toc-text">银行家算法的流程：资源分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">11.8.13.</span> <span class="toc-text">银行家算法的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86"><span class="toc-number">11.8.14.</span> <span class="toc-text">实际应用中的死锁处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%89%A9%E5%B1%95%EF%BC%9A"><span class="toc-number">11.9.</span> <span class="toc-text">锁扩展：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%B0%88%E8%B0%88-synchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">11.9.1.</span> <span class="toc-text">18. 谈谈 synchronized 和 ReentrantLock 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.9.2.</span> <span class="toc-text">19. synchronized 和 volatile 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E8%B0%88%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">11.9.3.</span> <span class="toc-text">20. 谈一下你对 volatile 关键字的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E8%AF%B4%E4%B8%8B%E5%AF%B9-ReentrantReadWriteLock-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">11.9.4.</span> <span class="toc-text">21. 说下对 ReentrantReadWriteLock 的理解？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">11.10.</span> <span class="toc-text">多线程与线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%90%EF%B8%8F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">11.10.1.</span> <span class="toc-text">⭐️什么是线程和进程?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">11.10.1.1.</span> <span class="toc-text">何为进程?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.10.1.2.</span> <span class="toc-text">何为线程?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">11.10.1.3.</span> <span class="toc-text">程序计数器为什么是私有的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">11.10.1.4.</span> <span class="toc-text">虚拟机栈和本地方法栈为什么是私有的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">11.10.1.5.</span> <span class="toc-text">一句话简单了解堆和方法区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-THREAD-%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="toc-number">11.10.2.</span> <span class="toc-text">Java THREAD 类详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-THREAD-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">11.10.3.</span> <span class="toc-text">1. THREAD 类的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-THREAD-%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">11.10.4.</span> <span class="toc-text">2. THREAD 类的主要方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%8E%A7%E5%88%B6"><span class="toc-number">11.10.4.1.</span> <span class="toc-text">线程生命周期控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E7%8A%B6%E6%80%81%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.10.4.2.</span> <span class="toc-text">线程属性和状态查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E5%BD%B1%E5%93%8D%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.10.4.3.</span> <span class="toc-text">静态方法 (影响当前线程)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-THREAD-%E7%B1%BB%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.10.5.</span> <span class="toc-text">3. THREAD 类方法使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B-Daemon-Thread"><span class="toc-number">11.10.6.</span> <span class="toc-text">一、守护线程 (Daemon Thread)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-number">11.10.6.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8E%E6%99%AE%E9%80%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.10.6.2.</span> <span class="toc-text">2. 与普通线程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%94%A8%E9%80%94"><span class="toc-number">11.10.6.3.</span> <span class="toc-text">3. 常见用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A4%E6%96%AD"><span class="toc-number">11.10.6.4.</span> <span class="toc-text">4. 如何创建和判断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81join-%E6%96%B9%E6%B3%95"><span class="toc-number">11.10.7.</span> <span class="toc-text">二、join() 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5-1"><span class="toc-number">11.10.7.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BB%E8%A6%81%E7%94%A8%E9%80%94"><span class="toc-number">11.10.7.2.</span> <span class="toc-text">2. 主要用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.10.7.3.</span> <span class="toc-text">3. 代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81yield-%E6%96%B9%E6%B3%95"><span class="toc-number">11.10.8.</span> <span class="toc-text">三、yield() 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5-2"><span class="toc-number">11.10.8.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BB%E8%A6%81%E7%94%A8%E9%80%94-1"><span class="toc-number">11.10.8.2.</span> <span class="toc-text">2. 主要用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">11.10.8.3.</span> <span class="toc-text">3. 代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-setDaemon-boolean-on-%E6%96%B9%E6%B3%95"><span class="toc-number">11.10.9.</span> <span class="toc-text">1. setDaemon(boolean on) 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-join-%E6%96%B9%E6%B3%95"><span class="toc-number">11.10.10.</span> <span class="toc-text">2. join() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-yield-%E6%96%B9%E6%B3%95"><span class="toc-number">11.10.11.</span> <span class="toc-text">3. yield() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">11.10.12.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">11.10.13.</span> <span class="toc-text">1. 深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Thread-sleep-long-millis"><span class="toc-number">11.10.13.1.</span> <span class="toc-text">1. Thread.sleep(long millis)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Thread-yield"><span class="toc-number">11.10.13.2.</span> <span class="toc-text">2. Thread.yield()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-obj-wait"><span class="toc-number">11.10.13.3.</span> <span class="toc-text">3. obj.wait()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Thread-join"><span class="toc-number">11.10.13.4.</span> <span class="toc-text">4. Thread.join()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93"><span class="toc-number">11.10.14.</span> <span class="toc-text">2. 区别与使用场景总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.10.15.</span> <span class="toc-text">3. 使用场景示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.10.16.</span> <span class="toc-text">线程（Thread）的概念与生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">11.10.17.</span> <span class="toc-text">什么是线程上下文切换?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-sleep-%E6%96%B9%E6%B3%95%E5%92%8C-Object-wait-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">11.10.18.</span> <span class="toc-text">Thread#sleep() 方法和 Object#wait() 方法对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%9C%A8-Thread-%E4%B8%AD%EF%BC%9F"><span class="toc-number">11.10.19.</span> <span class="toc-text">为什么 wait() 方法不定义在 Thread 中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-Thread-%E7%B1%BB%E7%9A%84-run-%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">11.10.20.</span> <span class="toc-text">可以直接调用 Thread 类的 run 方法吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">11.10.21.</span> <span class="toc-text">创建线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB"><span class="toc-number">11.10.21.1.</span> <span class="toc-text">继承 Thread 类:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">11.10.21.2.</span> <span class="toc-text">实现 Runnable 接口：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.10.21.3.</span> <span class="toc-text">实现Callable接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">11.10.22.</span> <span class="toc-text">Callable 的基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Callable"><span class="toc-number">11.10.23.</span> <span class="toc-text">如何使用 Callable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable-%E4%B8%8E-Runnable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.10.24.</span> <span class="toc-text">Callable 与 Runnable 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.10.25.</span> <span class="toc-text">Future 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">11.10.26.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-Thread-Pool"><span class="toc-number">11.10.26.1.</span> <span class="toc-text">线程池 (Thread Pool)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA-ThreadPoolExecutor"><span class="toc-number">11.10.27.</span> <span class="toc-text">一、线程池的创建 (ThreadPoolExecutor)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%9A"><span class="toc-number">11.10.27.1.</span> <span class="toc-text">各参数详解：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.10.28.</span> <span class="toc-text">二、线程池的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B"><span class="toc-number">11.10.29.</span> <span class="toc-text">三、线程池的启动流程 (任务提交过程)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%EF%BC%9A"><span class="toc-number">11.11.</span> <span class="toc-text">ThreadLocal：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.11.1.</span> <span class="toc-text">ThreadLocal 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-ThreadLocal%EF%BC%9F"><span class="toc-number">11.11.2.</span> <span class="toc-text">为什么需要 ThreadLocal？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal-%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">11.11.3.</span> <span class="toc-text">ThreadLocal 的常见应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal-%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">11.11.4.</span> <span class="toc-text">ThreadLocal 可能带来的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">11.11.4.1.</span> <span class="toc-text">内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%94%AE%E6%98%AF%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">11.11.5.</span> <span class="toc-text">为什么键是弱引用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%80%BC%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">11.11.6.</span> <span class="toc-text">为什么值是强引用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E7%A7%8D%E8%AE%BE%E8%AE%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">11.11.7.</span> <span class="toc-text">这种设计带来的内存泄漏问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">11.11.8.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">11.11.8.1.</span> <span class="toc-text">继承问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">11.12.</span> <span class="toc-text">Collection (集合框架):</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-List-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">11.12.0.1.</span> <span class="toc-text">A. List 接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ArrayList"><span class="toc-number">11.12.0.1.1.</span> <span class="toc-text">1. ArrayList</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-%E5%AE%9E%E7%8E%B0-RandomAccess-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">11.12.1.</span> <span class="toc-text">ArrayList 实现 RandomAccess 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-LinkedList-%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0-RandomAccess%EF%BC%9F"><span class="toc-number">11.12.2.</span> <span class="toc-text">为什么 LinkedList 没有实现 RandomAccess？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-LinkedList"><span class="toc-number">11.12.2.0.1.</span> <span class="toc-text">2. LinkedList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Vector"><span class="toc-number">11.12.2.0.2.</span> <span class="toc-text">3. Vector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Stack"><span class="toc-number">11.12.2.0.3.</span> <span class="toc-text">4. Stack</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-List"><span class="toc-number">11.12.2.1.</span> <span class="toc-text">小结 List:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Set-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">11.12.2.2.</span> <span class="toc-text">B. Set 接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-HashSet"><span class="toc-number">11.12.2.2.1.</span> <span class="toc-text">1. HashSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-LinkedHashSet"><span class="toc-number">11.12.2.2.2.</span> <span class="toc-text">2. LinkedHashSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-TreeSet"><span class="toc-number">11.12.2.2.3.</span> <span class="toc-text">3. TreeSet</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-Set"><span class="toc-number">11.12.2.3.</span> <span class="toc-text">小结 Set:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Map-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">11.12.2.4.</span> <span class="toc-text">C. Map 接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-HashMap"><span class="toc-number">11.12.2.4.1.</span> <span class="toc-text">1. HashMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-LinkedHashMap"><span class="toc-number">11.12.2.4.2.</span> <span class="toc-text">2. LinkedHashMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-TreeMap"><span class="toc-number">11.12.2.4.3.</span> <span class="toc-text">3. TreeMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Hashtable"><span class="toc-number">11.12.2.4.4.</span> <span class="toc-text">4. Hashtable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-ConcurrentHashMap-JUC-%E5%8C%85%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88"><span class="toc-number">11.12.2.4.5.</span> <span class="toc-text">5. ConcurrentHashMap (JUC 包中的并发集合)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%A9-ConcurrentHashMap-%E8%B6%85%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%EF%BC%88JDK8%E4%B8%BA%E4%B8%BB%EF%BC%8C%E5%90%AB%E5%AF%B9%E6%AF%94%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">🧩 ConcurrentHashMap 超详细解析（JDK8为主，含对比）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA"><span class="toc-number">12.1.</span> <span class="toc-text">一、背景与设计动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%BC%94%E5%8F%98%EF%BC%88JDK7-vs-JDK8%EF%BC%89"><span class="toc-number">12.2.</span> <span class="toc-text">二、实现演变（JDK7 vs JDK8）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK7"><span class="toc-number">12.2.1.</span> <span class="toc-text">JDK7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8"><span class="toc-number">12.2.2.</span> <span class="toc-text">JDK8</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.3.</span> <span class="toc-text">三、核心数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-%E8%8A%82%E7%82%B9"><span class="toc-number">12.3.1.</span> <span class="toc-text">Node 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeNode%EF%BC%88%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-number">12.3.2.</span> <span class="toc-text">TreeNode（红黑树节点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForwardingNode"><span class="toc-number">12.3.3.</span> <span class="toc-text">ForwardingNode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">12.4.</span> <span class="toc-text">四、核心操作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-get-%E2%80%94%E2%80%94-%E6%97%A0%E9%94%81%E8%AF%BB"><span class="toc-number">12.4.1.</span> <span class="toc-text">1. get() —— 无锁读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-put-%E2%80%94%E2%80%94-%E5%86%99%E6%97%B6%E5%8A%A0%E9%94%81"><span class="toc-number">12.4.2.</span> <span class="toc-text">2. put() —— 写时加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%88Transfer%EF%BC%89"><span class="toc-number">12.4.3.</span> <span class="toc-text">3. 扩容机制（Transfer）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">12.4.3.1.</span> <span class="toc-text">触发条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">12.4.3.2.</span> <span class="toc-text">流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">12.5.</span> <span class="toc-text">五、并发控制机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%A7%E8%83%BD%E7%89%B9%E6%80%A7"><span class="toc-number">12.6.</span> <span class="toc-text">六、性能特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%B8%B8%E8%A7%81%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">12.7.</span> <span class="toc-text">七、常见高频面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%A2%98"><span class="toc-number">12.7.1.</span> <span class="toc-text">基础题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E9%A2%98"><span class="toc-number">12.7.2.</span> <span class="toc-text">进阶题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E7%9B%B8%E5%85%B3%E9%A2%98"><span class="toc-number">12.7.3.</span> <span class="toc-text">扩容相关题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E9%A2%98"><span class="toc-number">12.7.4.</span> <span class="toc-text">高阶题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF%EF%BC%88%E9%9D%A2%E8%AF%95%E6%A1%86%E6%9E%B6%EF%BC%89"><span class="toc-number">12.8.</span> <span class="toc-text">八、答题模板（面试框架）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%80%E3%80%81%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E5%8D%8F%E4%BD%9C%E7%B1%BB%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">🧩 一、并发工具类（协作类）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-CountDownLatch%EF%BC%88%E5%80%92%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%89"><span class="toc-number">13.1.</span> <span class="toc-text">1. CountDownLatch（倒计时器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%9D-%E5%AE%9A%E4%B9%89"><span class="toc-number">13.1.1.</span> <span class="toc-text">📝 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.1.2.</span> <span class="toc-text">⚙️ 底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">13.1.3.</span> <span class="toc-text">📌 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9"><span class="toc-number">13.1.4.</span> <span class="toc-text">🎯 面试考点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CyclicBarrier%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%B1%8F%E9%9A%9C%EF%BC%89"><span class="toc-number">13.2.</span> <span class="toc-text">2. CyclicBarrier（循环屏障）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%9D-%E5%AE%9A%E4%B9%89-1"><span class="toc-number">13.2.1.</span> <span class="toc-text">📝 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">13.2.2.</span> <span class="toc-text">⚙️ 底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">13.2.3.</span> <span class="toc-text">📌 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9-1"><span class="toc-number">13.2.4.</span> <span class="toc-text">🎯 面试考点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Semaphore%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%89"><span class="toc-number">13.3.</span> <span class="toc-text">3. Semaphore（信号量）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%9D-%E5%AE%9A%E4%B9%89-2"><span class="toc-number">13.3.1.</span> <span class="toc-text">📝 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">13.3.2.</span> <span class="toc-text">⚙️ 底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">13.3.3.</span> <span class="toc-text">📌 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9-2"><span class="toc-number">13.3.4.</span> <span class="toc-text">🎯 面试考点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Exchanger%EF%BC%88%E4%BA%A4%E6%8D%A2%E5%99%A8%EF%BC%89"><span class="toc-number">13.4.</span> <span class="toc-text">4. Exchanger（交换器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%9D-%E5%AE%9A%E4%B9%89-3"><span class="toc-number">13.4.1.</span> <span class="toc-text">📝 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">13.4.2.</span> <span class="toc-text">⚙️ 底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">13.4.3.</span> <span class="toc-text">📌 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9-3"><span class="toc-number">13.4.4.</span> <span class="toc-text">🎯 面试考点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%BA%8C%E3%80%81%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%88Atomic-%E7%B3%BB%E5%88%97%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">🧩 二、原子类（Atomic 系列）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">14.1.</span> <span class="toc-text">1. 基础原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicInteger-AtomicLong-AtomicBoolean"><span class="toc-number">14.1.1.</span> <span class="toc-text">AtomicInteger &#x2F; AtomicLong &#x2F; AtomicBoolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">14.1.2.</span> <span class="toc-text">⚙️ 底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">14.1.3.</span> <span class="toc-text">📌 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9-4"><span class="toc-number">14.1.4.</span> <span class="toc-text">🎯 面试考点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">14.2.</span> <span class="toc-text">2. 数组原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicIntegerArray-AtomicLongArray-AtomicReferenceArray"><span class="toc-number">14.2.1.</span> <span class="toc-text">AtomicIntegerArray &#x2F; AtomicLongArray &#x2F; AtomicReferenceArray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%95%E7%94%A8%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">14.3.</span> <span class="toc-text">3. 引用原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicReference"><span class="toc-number">14.3.1.</span> <span class="toc-text">AtomicReference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicStampedReference"><span class="toc-number">14.3.2.</span> <span class="toc-text">AtomicStampedReference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicMarkableReference"><span class="toc-number">14.3.3.</span> <span class="toc-text">AtomicMarkableReference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B4%AF%E5%8A%A0%E5%99%A8%E7%B1%BB"><span class="toc-number">14.4.</span> <span class="toc-text">4. 累加器类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LongAdder-DoubleAdder"><span class="toc-number">14.4.1.</span> <span class="toc-text">LongAdder &#x2F; DoubleAdder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="toc-number">14.4.2.</span> <span class="toc-text">📌 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9-5"><span class="toc-number">14.4.3.</span> <span class="toc-text">🎯 面试考点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%89%E3%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">15.</span> <span class="toc-text">🧠 三、工具类 &amp; 原子类对比总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E5%9B%9B%E3%80%81%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF%EF%BC%88%E5%8F%AF%E5%A5%97%E7%94%A8%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">🎯 四、面试答题模板（可套用）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-Map"><span class="toc-number">16.0.0.1.</span> <span class="toc-text">小结 Map:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">16.0.0.2.</span> <span class="toc-text">集合部分总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator"><span class="toc-number">16.0.1.</span> <span class="toc-text">1. 迭代器 (Iterator)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A2%9E%E5%BC%BA-for-%E5%BE%AA%E7%8E%AF-For-Each-Loop"><span class="toc-number">16.0.2.</span> <span class="toc-text">2. 增强 for 循环 (For-Each Loop)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%A0%E7%BB%9F-for-%E5%BE%AA%E7%8E%AF-Indexed-For-Loop"><span class="toc-number">16.0.3.</span> <span class="toc-text">3. 传统 for 循环 (Indexed For Loop)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E-Stream-API"><span class="toc-number">16.0.4.</span> <span class="toc-text">4. Lambda 表达式与 Stream API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">16.0.5.</span> <span class="toc-text">总结与最佳实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E5%8F%8D%E5%90%91%E9%81%8D%E5%8E%86%EF%BC%9F"><span class="toc-number">16.0.6.</span> <span class="toc-text">为什么推荐反向遍历？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">16.0.7.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%A0%E7%BB%9F%E7%9A%84-for-%E5%BE%AA%E7%8E%AF%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">16.0.7.1.</span> <span class="toc-text">1. 传统的 for 循环（推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88Iterator%EF%BC%89"><span class="toc-number">16.0.7.2.</span> <span class="toc-text">2. 迭代器（Iterator）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">16.0.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84hashmap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">16.1.</span> <span class="toc-text">多线程下的hashmap死循环问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">16.1.1.</span> <span class="toc-text">HashMap 的死循环问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%97%B6%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E8%BF%87%E7%A8%8B"><span class="toc-number">16.1.1.1.</span> <span class="toc-text">扩容时的死循环过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">16.1.2.</span> <span class="toc-text">如何解决这个问题？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%89%A9%E5%B1%95%EF%BC%9A"><span class="toc-number">16.2.</span> <span class="toc-text">集合扩展：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-HashMap-%E7%9A%84-get-%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8-map-%E4%B8%AD%EF%BC%9F"><span class="toc-number">16.2.1.</span> <span class="toc-text">12. HashMap 的 get 方法能否判断某个元素是否在 map 中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-HashMap-%E4%B8%8E-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">16.2.2.</span> <span class="toc-text">13. HashMap 与 HashTable 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-HashMap-%E4%B8%8E-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">16.2.3.</span> <span class="toc-text">14. HashMap 与 ConcurrentHashMap 的区别是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-HashTable-%E5%92%8C-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">16.2.4.</span> <span class="toc-text">15. HashTable 和 ConcurrentHashMap 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">16.2.5.</span> <span class="toc-text">16. ConcurrentHashMap 的实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-HashSet-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">16.2.6.</span> <span class="toc-text">17. HashSet 的实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-HashSet-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%9F"><span class="toc-number">16.2.7.</span> <span class="toc-text">18. HashSet 怎么保证元素不重复的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-LinkedHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">16.2.8.</span> <span class="toc-text">19. LinkedHashMap 的实现原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Iterator-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">16.2.9.</span> <span class="toc-text">20. Iterator 怎么使用？有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-Iterator-%E5%92%8C-ListIterator-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">16.2.10.</span> <span class="toc-text">21. Iterator 和 ListIterator 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-Iterator-%E5%92%8C-Enumeration-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">16.2.11.</span> <span class="toc-text">22. Iterator 和 Enumeration 接口的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-fail-fast-%E4%B8%8E-fail-safe-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">16.2.12.</span> <span class="toc-text">23. fail-fast 与 fail-safe 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-Collection-%E5%92%8C-Collections-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">16.2.13.</span> <span class="toc-text">24. Collection 和 Collections 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO-%E6%B5%81"><span class="toc-number">16.3.</span> <span class="toc-text">Java IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">16.3.1.</span> <span class="toc-text">IO 流的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-IO-%E6%93%8D%E4%BD%9C"><span class="toc-number">16.3.2.</span> <span class="toc-text">常用 IO 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-New-Input-Output"><span class="toc-number">16.3.3.</span> <span class="toc-text">NIO (New Input&#x2F;Output)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AIO-Asynchronous-Input-Output"><span class="toc-number">16.3.4.</span> <span class="toc-text">AIO (Asynchronous Input&#x2F;Output)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java-IO-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9F%E8%AF%B7%E8%AF%B4%E5%87%BA%E5%87%A0%E4%B8%AA%E4%BD%A0%E7%86%9F%E6%82%89%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E3%80%82"><span class="toc-number">16.3.5.</span> <span class="toc-text">1. Java IO 流的分类？请说出几个你熟悉的实现类。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">16.3.6.</span> <span class="toc-text">2. 字节流和字符流有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-BIO%E3%80%81NIO-%E5%92%8C-AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">16.3.7.</span> <span class="toc-text">3. BIO、NIO 和 AIO 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%8F%8D%E5%B0%84-Reflection"><span class="toc-number">16.4.</span> <span class="toc-text">Java 反射 (Reflection)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">16.5.</span> <span class="toc-text">JVM内存结构与垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">16.5.1.</span> <span class="toc-text">JVM内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">16.5.2.</span> <span class="toc-text">JVM 简单介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E5%88%92%E5%88%86%EF%BC%9F"><span class="toc-number">16.5.3.</span> <span class="toc-text">为什么要这样划分？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">16.5.3.1.</span> <span class="toc-text">新生代的垃圾回收流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-8-1-1%EF%BC%9F"><span class="toc-number">16.5.4.</span> <span class="toc-text">为什么是 8:1:1？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">16.5.5.</span> <span class="toc-text">1. 程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">16.5.6.</span> <span class="toc-text">2. Java 虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">16.5.7.</span> <span class="toc-text">3. 本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Java-%E5%A0%86"><span class="toc-number">16.5.8.</span> <span class="toc-text">4. Java 堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">16.5.9.</span> <span class="toc-text">5. 方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">16.5.10.</span> <span class="toc-text">3. 堆和栈的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A0%86%E4%B8%AD%E5%AD%98%E4%BB%80%E4%B9%88%EF%BC%9F%E6%A0%88%E4%B8%AD%E5%AD%98%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">16.5.11.</span> <span class="toc-text">4. 堆中存什么？栈中存什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A%E5%A0%86%E5%92%8C%E6%A0%88%E5%8C%BA%E5%88%86%E5%87%BA%E6%9D%A5%E5%91%A2%EF%BC%9F%E6%A0%88%E4%B8%AD%E4%B8%8D%E6%98%AF%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="toc-number">16.5.12.</span> <span class="toc-text">5. 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Java-%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%97%B6%E4%BC%A0%E5%80%BC%E5%91%A2%EF%BC%9F%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">16.5.13.</span> <span class="toc-text">6. Java 中的参数传递时传值呢？还是传引用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Java-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%9F"><span class="toc-number">16.5.14.</span> <span class="toc-text">7. Java 对象的大小是怎么计算的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">16.5.15.</span> <span class="toc-text">8. 对象的访问定位的两种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="toc-number">16.5.16.</span> <span class="toc-text">JVM 调优参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E4%BB%8E%E5%93%AA%E9%87%8C%E5%BC%80%E5%A7%8B%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">16.5.17.</span> <span class="toc-text">10. 垃圾回收是从哪里开始的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%A2%AB%E6%A0%87%E8%AE%B0%E4%B8%BA%E5%9E%83%E5%9C%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%E5%90%97%EF%BC%9F"><span class="toc-number">16.5.18.</span> <span class="toc-text">11. 被标记为垃圾的对象一定会被回收吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%B0%88%E8%B0%88%E5%AF%B9-Java-%E4%B8%AD%E5%BC%95%E7%94%A8%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">16.5.19.</span> <span class="toc-text">12. 谈谈对 Java 中引用的了解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%B0%88%E8%B0%88%E5%AF%B9%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">16.5.20.</span> <span class="toc-text">13. 谈谈对内存泄漏的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">16.5.21.</span> <span class="toc-text">14. 内存泄露的根本原因是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B8%BE%E5%87%A0%E4%B8%AA%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">16.5.22.</span> <span class="toc-text">15. 举几个可能发生内存泄漏的情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">16.5.23.</span> <span class="toc-text">16. 尽量避免内存泄漏的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-Garbage-Collector"><span class="toc-number">16.5.24.</span> <span class="toc-text">垃圾收集器 (Garbage Collector)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95"><span class="toc-number">16.5.24.1.</span> <span class="toc-text">垃圾判断算法:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">16.5.24.2.</span> <span class="toc-text">常见垃圾收集器:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">16.5.24.2.1.</span> <span class="toc-text">Serial 收集器:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">16.5.24.2.2.</span> <span class="toc-text">ParNew 收集器:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">16.5.24.2.3.</span> <span class="toc-text">Parallel Scavenge 收集器:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CMS-Concurrent-Mark-Sweep-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">16.5.24.2.4.</span> <span class="toc-text">CMS (Concurrent Mark Sweep) 收集器：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1-Garbage-First-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">16.5.24.2.5.</span> <span class="toc-text">G1 (Garbage-First) 收集器：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#zGC-Z-Garbage-Collector-%E5%92%8C-Shenandoah-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">16.5.24.2.6.</span> <span class="toc-text">zGC (Z Garbage Collector) 和 Shenandoah 收集器：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-Class-Loading-Mechanism"><span class="toc-number">16.6.</span> <span class="toc-text">类加载机制 (Class Loading Mechanism)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8A%A0%E8%BD%BD%EF%BC%88Loading%EF%BC%89"><span class="toc-number">16.6.1.</span> <span class="toc-text">1. 加载（Loading）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%AA%8C%E8%AF%81%EF%BC%88Verification%EF%BC%89"><span class="toc-number">16.6.2.</span> <span class="toc-text">2. 验证（Verification）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%86%E5%A4%87%EF%BC%88Preparation%EF%BC%89"><span class="toc-number">16.6.3.</span> <span class="toc-text">3. 准备（Preparation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A7%A3%E6%9E%90%EF%BC%88Resolution%EF%BC%89"><span class="toc-number">16.6.4.</span> <span class="toc-text">4. 解析（Resolution）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88Initialization%EF%BC%89"><span class="toc-number">16.6.5.</span> <span class="toc-text">5. 初始化（Initialization）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Bootstrap-ClassLoader"><span class="toc-number">16.6.5.1.</span> <span class="toc-text">1. 启动类加载器 (Bootstrap ClassLoader)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Extension-ClassLoader"><span class="toc-number">16.6.5.2.</span> <span class="toc-text">2. 扩展类加载器 (Extension ClassLoader)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Application-ClassLoader"><span class="toc-number">16.6.5.3.</span> <span class="toc-text">3. 应用程序类加载器 (Application ClassLoader)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">16.6.6.</span> <span class="toc-text">自定义类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">16.6.7.</span> <span class="toc-text">33. 有哪些类加载器？分别有什么作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="toc-number">16.7.</span> <span class="toc-text">面试题：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88Isolation%EF%BC%89"><span class="toc-number">16.7.1.</span> <span class="toc-text">1. 隔离性（Isolation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%88Security%EF%BC%89"><span class="toc-number">16.7.2.</span> <span class="toc-text">2. 安全性（Security）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%EF%BC%88Extensibility%EF%BC%89"><span class="toc-number">16.7.3.</span> <span class="toc-text">3. 可扩展性（Extensibility）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">16.7.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-OOM-OutOfMemoryError-%E5%92%8C-StackOverflowError"><span class="toc-number">16.8.</span> <span class="toc-text">常见的 OOM (OutOfMemoryError) 和 StackOverflowError</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOM%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">16.9.</span> <span class="toc-text">OOM常见场景：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-java-lang-OutOfMemoryError-Java-heap-space"><span class="toc-number">16.9.1.</span> <span class="toc-text">1. java.lang.OutOfMemoryError: Java heap space</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-java-lang-StackOverflowError"><span class="toc-number">16.9.2.</span> <span class="toc-text">2. java.lang.StackOverflowError</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-java-lang-OutOfMemoryError-PermGen-space-%E6%88%96-Metaspace"><span class="toc-number">16.9.3.</span> <span class="toc-text">3. java.lang.OutOfMemoryError: PermGen space 或 Metaspace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-java-lang-OutOfMemoryError-Direct-buffer-memory"><span class="toc-number">16.9.4.</span> <span class="toc-text">4. java.lang.OutOfMemoryError: Direct buffer memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-java-lang-OutOfMemoryError-unable-to-create-new-native-thread"><span class="toc-number">16.9.5.</span> <span class="toc-text">5. java.lang.OutOfMemoryError: unable to create new native thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A-1"><span class="toc-number">16.9.6.</span> <span class="toc-text">面试题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E8%BF%B0-Java-%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88Java-heap-space%EF%BC%89%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82"><span class="toc-number">16.9.7.</span> <span class="toc-text">1. 简述 Java 堆内存溢出（Java heap space）的原因及解决方案。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF-StackOverflowError%EF%BC%9F%E5%AE%83%E5%92%8C-OOM-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">16.9.8.</span> <span class="toc-text">2. 什么是 StackOverflowError？它和 OOM 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JDK-8-%E4%B8%AD-PermGen-space-%E6%BA%A2%E5%87%BA%E9%94%99%E8%AF%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%98%E6%88%90%E4%BA%86-Metaspace%EF%BC%9F"><span class="toc-number">16.9.9.</span> <span class="toc-text">3. JDK 8 中 PermGen space 溢出错误为什么变成了 Metaspace？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%99%A4%E4%BA%86-Java-%E5%A0%86%EF%BC%8C%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F-OOM%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">16.9.10.</span> <span class="toc-text">4. 除了 Java 堆，还有哪些内存区域可能发生 OOM？如何解决？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%A1%86%E6%9E%B6%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3"><span class="toc-number">17.</span> <span class="toc-text">Java框架核心知识详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Spring%E6%A1%86%E6%9E%B6%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">17.1.</span> <span class="toc-text">一、Spring框架深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Spring%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">17.1.1.</span> <span class="toc-text">1.1 Spring核心概念与原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IoC%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="toc-number">17.1.1.1.</span> <span class="toc-text">IoC容器原理深入分析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IoC-%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">18.</span> <span class="toc-text">IoC 容器实现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-BeanFactory-%E2%80%94%E2%80%94-%E5%9F%BA%E7%A1%80-IoC-%E5%AE%B9%E5%99%A8"><span class="toc-number">18.1.</span> <span class="toc-text">1. BeanFactory —— 基础 IoC 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">18.1.1.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">18.1.2.</span> <span class="toc-text">核心实现机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ApplicationContext-%E2%80%94%E2%80%94-%E9%AB%98%E7%BA%A7-IoC-%E5%AE%B9%E5%99%A8"><span class="toc-number">18.2.</span> <span class="toc-text">2. ApplicationContext —— 高级 IoC 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%EF%BC%88%E5%AF%B9%E6%AF%94-BeanFactory%EF%BC%89"><span class="toc-number">18.2.1.</span> <span class="toc-text">核心特性（对比 BeanFactory）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-BeanFactory-vs-ApplicationContext-%E6%80%BB%E7%BB%93"><span class="toc-number">18.3.</span> <span class="toc-text">3. BeanFactory vs ApplicationContext 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81-ApplicationContext-%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">18.4.</span> <span class="toc-text">4. 常见 ApplicationContext 实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DI%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">18.4.0.1.</span> <span class="toc-text">DI的三种注入方式对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">18.4.1.</span> <span class="toc-text">Bean 的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">18.4.2.</span> <span class="toc-text">Bean 的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-Bean-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">18.4.3.</span> <span class="toc-text">Spring 中的单例 Bean 的线程安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9-Spring-%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">18.4.4.</span> <span class="toc-text">对 Spring 中的事务的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">18.4.5.</span> <span class="toc-text">Spring 中的事务隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E4%B8%AD%E7%9A%84%E4%BA%8B%E7%89%A9%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">18.4.6.</span> <span class="toc-text">Spring 中的事物传播行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E5%B8%B8%E7%94%A8%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">18.4.7.</span> <span class="toc-text">Spring 常用注入方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">18.4.8.</span> <span class="toc-text">Spring 框架中用到了哪些设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationContext-%E9%80%9A%E5%B8%B8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">18.4.9.</span> <span class="toc-text">ApplicationContext 通常的实现有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="toc-number">18.4.9.1.</span> <span class="toc-text">AOP原理深入分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8C%9F-%E4%B8%80%E3%80%81Spring-AOP-%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">18.5.</span> <span class="toc-text">🌟 一、Spring AOP 实现机制概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%BA%8C%E3%80%81Spring-AOP-%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">18.6.</span> <span class="toc-text">🧩 二、Spring AOP 的两种动态代理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-number">18.6.1.</span> <span class="toc-text">1️⃣ JDK 动态代理（基于接口）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">18.6.1.1.</span> <span class="toc-text">✅ 原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%A6-%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">18.6.1.2.</span> <span class="toc-text">📦 示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8E%AF-%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">18.6.1.3.</span> <span class="toc-text">🎯 特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-CGLIB-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%AD%90%E7%B1%BB%EF%BC%89"><span class="toc-number">18.6.2.</span> <span class="toc-text">2️⃣ CGLIB 动态代理（基于子类）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E5%8E%9F%E7%90%86%EF%BC%9A-1"><span class="toc-number">18.6.2.1.</span> <span class="toc-text">✅ 原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A7%AA-%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">18.6.2.2.</span> <span class="toc-text">🧪 示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8E%AF-%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-number">18.6.2.3.</span> <span class="toc-text">🎯 特点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8F%97-%E4%B8%89%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88%E5%AF%B9%E6%AF%94%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89"><span class="toc-number">18.7.</span> <span class="toc-text">🏗 三、静态代理（对比动态代理）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%8E%9F%E7%90%86%EF%BC%9A-2"><span class="toc-number">18.7.1.</span> <span class="toc-text">✅ 原理：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A7%AA-%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">18.7.1.1.</span> <span class="toc-text">🧪 示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8E%AF-%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-number">18.7.1.2.</span> <span class="toc-text">🎯 特点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%9A-%E5%9B%9B%E3%80%81%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">18.8.</span> <span class="toc-text">🔚 四、三者对比总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-Spring-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">18.9.</span> <span class="toc-text">✅ Spring 如何选择代理方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AOP%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">18.9.0.0.1.</span> <span class="toc-text">AOP核心概念：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOP%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">18.9.0.0.2.</span> <span class="toc-text">AOP通知类型：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Spring%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3"><span class="toc-number">18.9.1.</span> <span class="toc-text">1.2 Spring核心注解详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.9.1.1.</span> <span class="toc-text">基础配置注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.9.1.2.</span> <span class="toc-text">Bean定义注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.9.1.3.</span> <span class="toc-text">依赖注入注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.9.1.4.</span> <span class="toc-text">生命周期注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.9.1.5.</span> <span class="toc-text">AOP相关注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Spring%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">18.9.2.</span> <span class="toc-text">1.3 Spring常见使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF1%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">18.9.2.1.</span> <span class="toc-text">场景1：服务层事务管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF2%EF%BC%9A%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">18.9.2.2.</span> <span class="toc-text">场景2：缓存管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">18.9.3.</span> <span class="toc-text">1.4 Spring常见面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Spring-Boot%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">18.10.</span> <span class="toc-text">二、Spring Boot深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Spring-Boot%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">18.10.1.</span> <span class="toc-text">2.1 Spring Boot核心原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Spring-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">18.10.2.</span> <span class="toc-text">2.2 Spring Boot启动流程详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Spring-Boot%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.10.3.</span> <span class="toc-text">2.3 Spring Boot核心注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.10.3.1.</span> <span class="toc-text">启动类注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.10.3.2.</span> <span class="toc-text">条件注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.10.3.3.</span> <span class="toc-text">配置属性注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Spring-Boot%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">18.10.4.</span> <span class="toc-text">2.4 Spring Boot实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF1%EF%BC%9A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">18.10.4.1.</span> <span class="toc-text">场景1：微服务架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF2%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82%E6%95%B4%E5%90%88"><span class="toc-number">18.10.4.2.</span> <span class="toc-text">场景2：数据访问层整合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Spring-Boot%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">18.10.5.</span> <span class="toc-text">2.5 Spring Boot面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Spring-MVC%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">18.11.</span> <span class="toc-text">三、Spring MVC深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Spring-MVC%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">18.11.1.</span> <span class="toc-text">3.1 Spring MVC核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Spring-MVC%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.11.2.</span> <span class="toc-text">3.2 Spring MVC核心注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.11.2.1.</span> <span class="toc-text">控制器注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.11.2.2.</span> <span class="toc-text">参数绑定注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.11.2.3.</span> <span class="toc-text">响应处理注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Spring-MVC%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">18.11.3.</span> <span class="toc-text">3.3 Spring MVC实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF1%EF%BC%9ARESTful-API%E5%BC%80%E5%8F%91"><span class="toc-number">18.11.3.1.</span> <span class="toc-text">场景1：RESTful API开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF2%EF%BC%9A%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">18.11.3.2.</span> <span class="toc-text">场景2：全局异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF3%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%84%E7%90%86"><span class="toc-number">18.11.3.3.</span> <span class="toc-text">场景3：文件上传处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Spring-MVC%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">18.11.4.</span> <span class="toc-text">3.4 Spring MVC面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81MyBatis%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">18.12.</span> <span class="toc-text">四、MyBatis深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-MyBatis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">18.12.1.</span> <span class="toc-text">4.1 MyBatis核心原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-MyBatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">18.12.2.</span> <span class="toc-text">4.2 MyBatis执行流程详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-MyBatis%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.12.3.</span> <span class="toc-text">4.3 MyBatis核心注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%98%A0%E5%B0%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.12.3.1.</span> <span class="toc-text">基础映射注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.12.3.2.</span> <span class="toc-text">高级映射注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81SQL%E6%B3%A8%E8%A7%A3"><span class="toc-number">18.12.3.3.</span> <span class="toc-text">动态SQL注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-MyBatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">18.12.4.</span> <span class="toc-text">4.4 MyBatis缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-MyBatis%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">18.12.5.</span> <span class="toc-text">4.5 MyBatis实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF1%EF%BC%9A%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E5%9C%BA%E6%99%AF"><span class="toc-number">18.12.5.1.</span> <span class="toc-text">场景1：复杂查询场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF2%EF%BC%9A%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%9C%BA%E6%99%AF"><span class="toc-number">18.12.5.2.</span> <span class="toc-text">场景2：批量操作场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF3%EF%BC%9A%E5%8A%A8%E6%80%81SQL%E5%9C%BA%E6%99%AF"><span class="toc-number">18.12.5.3.</span> <span class="toc-text">场景3：动态SQL场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-MyBatis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">18.12.6.</span> <span class="toc-text">4.6 MyBatis性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A51%EF%BC%9A%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-number">18.12.6.1.</span> <span class="toc-text">优化策略1：合理使用缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A52%EF%BC%9A%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">18.12.6.2.</span> <span class="toc-text">优化策略2：批量操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A53%EF%BC%9A%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><span class="toc-number">18.12.6.3.</span> <span class="toc-text">优化策略3：延迟加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-MyBatis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">18.12.7.</span> <span class="toc-text">4.7 MyBatis常见问题与解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%981%EF%BC%9AN-1%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98"><span class="toc-number">18.12.7.1.</span> <span class="toc-text">问题1：N+1查询问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%982%EF%BC%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E6%9F%A5%E8%AF%A2%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">18.12.7.2.</span> <span class="toc-text">问题2：大数据量查询内存溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%983%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E9%98%B2%E6%8A%A4"><span class="toc-number">18.12.7.3.</span> <span class="toc-text">问题3：SQL注入防护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-MyBatis%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98"><span class="toc-number">18.12.8.</span> <span class="toc-text">4.8 MyBatis面试高频问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">18.13.</span> <span class="toc-text">五、框架整合与最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Spring-Boot-MyBatis%E6%95%B4%E5%90%88"><span class="toc-number">18.13.1.</span> <span class="toc-text">5.1 Spring Boot + MyBatis整合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B"><span class="toc-number">18.13.1.1.</span> <span class="toc-text">完整配置示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE"><span class="toc-number">18.13.1.2.</span> <span class="toc-text">事务管理配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">18.13.2.</span> <span class="toc-text">5.2 统一异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E4%B8%8E%E9%AA%8C%E8%AF%81"><span class="toc-number">18.13.3.</span> <span class="toc-text">5.3 接口文档与验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">18.13.4.</span> <span class="toc-text">5.4 性能监控与优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%BB%BC%E5%90%88%E9%A2%98"><span class="toc-number">18.13.5.</span> <span class="toc-text">5.5 高频面试综合题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">18.13.6.</span> <span class="toc-text">内存管理和垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E4%BC%A0%E7%BB%9F%E5%88%86%E4%BB%A3%E7%BB%93%E6%9E%84"><span class="toc-number">18.13.7.</span> <span class="toc-text">堆内存的传统分代结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B9%B4%E8%BD%BB%E4%BB%A3%EF%BC%88Young-Generation%EF%BC%89"><span class="toc-number">18.13.7.1.</span> <span class="toc-text">1. 年轻代（Young Generation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%88Old-Generation%EF%BC%89"><span class="toc-number">18.13.7.2.</span> <span class="toc-text">2. 老年代（Old Generation）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BB%A5-Minor-GC-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">18.13.8.</span> <span class="toc-text">垃圾回收过程（以 Minor GC 为例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%A6%82-G1-%E5%92%8C-ZGC%EF%BC%89"><span class="toc-number">18.13.9.</span> <span class="toc-text">现代垃圾回收器（如 G1 和 ZGC）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Spring-Cloud%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3"><span class="toc-number">18.14.</span> <span class="toc-text">六、Spring Cloud与分布式技术详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Spring-Cloud-Alibaba%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">18.14.1.</span> <span class="toc-text">6.1 Spring Cloud Alibaba核心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nacos%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">18.14.1.1.</span> <span class="toc-text">Nacos深度解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sentinel%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">18.14.1.2.</span> <span class="toc-text">Sentinel核心原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RocketMQ%E9%9B%86%E6%88%90"><span class="toc-number">18.14.1.3.</span> <span class="toc-text">RocketMQ集成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A2%9E%E5%BC%BA%EF%BC%88Seata%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-number">18.14.2.</span> <span class="toc-text">6.2 分布式事务增强（Seata原理）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AT%E6%A8%A1%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">18.14.2.1.</span> <span class="toc-text">AT模式工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCC%E6%A8%A1%E5%BC%8F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">18.14.2.2.</span> <span class="toc-text">TCC模式最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%8C%96"><span class="toc-number">18.14.3.</span> <span class="toc-text">6.3 分布式缓存深度优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84"><span class="toc-number">18.14.3.1.</span> <span class="toc-text">Redis多级缓存架构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-number">18.14.4.</span> <span class="toc-text">6.4 消息队列高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">18.14.4.1.</span> <span class="toc-text">RocketMQ事务消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kafka%E7%B2%BE%E7%A1%AE%E4%B8%80%E6%AC%A1%E8%AF%AD%E4%B9%89"><span class="toc-number">18.14.4.2.</span> <span class="toc-text">Kafka精确一次语义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E6%94%AF%E6%8C%81%EF%BC%88%E6%96%B0%E5%A2%9E%EF%BC%89"><span class="toc-number">18.15.</span> <span class="toc-text">七、云原生支持（新增）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Kubernetes%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88"><span class="toc-number">18.15.1.</span> <span class="toc-text">7.1 Kubernetes集成方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E9%80%82%E9%85%8D"><span class="toc-number">18.15.1.1.</span> <span class="toc-text">服务发现适配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88"><span class="toc-number">18.15.1.2.</span> <span class="toc-text">配置管理方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Service-Mesh%E6%95%B4%E5%90%88"><span class="toc-number">18.15.2.</span> <span class="toc-text">7.2 Service Mesh整合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Istio%E6%B5%81%E9%87%8F%E6%B2%BB%E7%90%86"><span class="toc-number">18.15.2.1.</span> <span class="toc-text">Istio流量治理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AE%9E%E8%B7%B5"><span class="toc-number">18.16.</span> <span class="toc-text">八、性能优化深度实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E6%96%B9%E6%A1%88"><span class="toc-number">18.16.1.</span> <span class="toc-text">8.1 全链路压测方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%B1%E5%AD%90%E5%BA%93%E8%A1%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">18.16.1.1.</span> <span class="toc-text">影子库表配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%9F%93%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="toc-number">18.16.1.2.</span> <span class="toc-text">流量染色标记</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-number">19.</span> <span class="toc-text">分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Spring-Cloud-%E4%BD%93%E7%B3%BB"><span class="toc-number">19.0.0.1.</span> <span class="toc-text">1. Spring Cloud 体系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">19.0.0.1.1.</span> <span class="toc-text">核心思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Netflix-OSS-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%88%E9%83%A8%E5%88%86%E8%BF%9B%E5%85%A5%E7%BB%B4%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">19.0.0.1.2.</span> <span class="toc-text">Netflix OSS 常用组件（部分进入维护模式）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Spring-Cloud-Alibaba-%E8%AF%A6%E8%A7%A3"><span class="toc-number">19.0.0.1.3.</span> <span class="toc-text">Spring Cloud Alibaba 详解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%86%E5%B8%83%E5%BC%8FID%EF%BC%9A%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%EF%BC%88Snowflake%EF%BC%89"><span class="toc-number">19.0.0.2.</span> <span class="toc-text">2. 分布式ID：雪花算法（Snowflake）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">19.0.0.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">19.0.0.2.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E2%80%9C%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E6%9C%89%E6%97%B6%E9%92%9F%E5%9B%9E%E6%8B%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E2%80%9D"><span class="toc-number">19.0.0.2.3.</span> <span class="toc-text">面试题：“雪花算法有时钟回拨问题，如何解决？”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-RBAC%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="toc-number">19.0.0.3.</span> <span class="toc-text">3. RBAC（基于角色的访问控制）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">19.0.0.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">19.0.0.3.2.</span> <span class="toc-text">核心三要素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E2%80%9C%E8%AF%B7%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA-RBAC-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84%E3%80%82%E2%80%9D"><span class="toc-number">19.0.0.3.3.</span> <span class="toc-text">面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Redis-%E8%BF%9B%E9%98%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">19.0.0.4.</span> <span class="toc-text">4. Redis 进阶详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="toc-number">19.0.0.4.1.</span> <span class="toc-text">核心特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">19.0.0.4.2.</span> <span class="toc-text">缓存三大问题与解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MQ%EF%BC%89"><span class="toc-number">19.0.0.5.</span> <span class="toc-text">5. 消息队列（MQ）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="toc-number">19.0.0.5.1.</span> <span class="toc-text">核心作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E2%80%9C%E8%AF%B7%E5%88%97%E4%B8%BE%E4%BD%A0%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%97%B6%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%B9%B6%E7%BB%99%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82%E2%80%9D"><span class="toc-number">19.0.0.5.2.</span> <span class="toc-text">面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">19.0.0.6.</span> <span class="toc-text">6. 分布式锁详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">19.0.0.6.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="toc-number">19.0.0.6.2.</span> <span class="toc-text">实现方案对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-Redis-%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%9B%E9%98%B6"><span class="toc-number">19.0.0.6.3.</span> <span class="toc-text">基于 Redis 的实现进阶</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E2%80%9CRedis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%94%81%E8%BF%87%E6%9C%9F%E4%BA%86%E4%BD%86%E4%B8%9A%E5%8A%A1%E6%B2%A1%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E2%80%9D"><span class="toc-number">19.0.0.6.4.</span> <span class="toc-text">面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A3"><span class="toc-number">19.0.0.7.</span> <span class="toc-text">7. 分布式事务详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">19.0.0.7.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="toc-number">19.0.0.7.2.</span> <span class="toc-text">解决方案深入分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua-%E8%84%9A%E6%9C%AC%E8%AF%A6%E8%A7%A3-%E5%9C%A8-Redis-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">19.0.1.</span> <span class="toc-text">Lua 脚本详解 (在 Redis 中的应用)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Lua-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">19.0.1.1.</span> <span class="toc-text">1. Lua 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-%E8%A6%81%E6%94%AF%E6%8C%81-Lua-%E8%84%9A%E6%9C%AC%EF%BC%9F"><span class="toc-number">19.0.1.2.</span> <span class="toc-text">2. 为什么 Redis 要支持 Lua 脚本？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%9C%A8-Redis-%E4%B8%AD%E4%BD%BF%E7%94%A8-Lua-%E8%84%9A%E6%9C%AC%EF%BC%9F"><span class="toc-number">19.0.1.3.</span> <span class="toc-text">3. 如何在 Redis 中使用 Lua 脚本？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Token-%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">19.0.2.</span> <span class="toc-text">Token 认证机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Token-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">19.0.2.1.</span> <span class="toc-text">1. Token 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Token-%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86%EF%BC%88%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">19.0.2.2.</span> <span class="toc-text">2. Token 认证原理（工作流程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-Token%EF%BC%9F%EF%BC%88%E4%B8%8E-Session-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-number">19.0.2.3.</span> <span class="toc-text">3. 为什么使用 Token？（与 Session 的区别）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%8C%E4%BB%A4%E7%89%8C%E7%AD%96%E7%95%A5-Access-Token-Refresh-Token"><span class="toc-number">19.0.2.4.</span> <span class="toc-text">4. 双令牌策略 (Access Token + Refresh Token)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Token-%E7%9B%B8%E5%85%B3%E5%9C%BA%E6%99%AF%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">19.0.2.5.</span> <span class="toc-text">5. Token 相关场景与面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C-Access-Token"><span class="toc-number">19.0.3.</span> <span class="toc-text">1. 访问令牌 (Access Token)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%B7%E6%96%B0%E4%BB%A4%E7%89%8C-Refresh-Token"><span class="toc-number">19.0.4.</span> <span class="toc-text">2. 刷新令牌 (Refresh Token)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BB%A4%E7%89%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88%E7%BB%93%E5%90%88%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88%EF%BC%89"><span class="toc-number">19.0.5.</span> <span class="toc-text">双令牌工作流程（结合存储方案）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B8%AA%E6%96%B9%E6%A1%88%E6%9B%B4%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">19.0.6.</span> <span class="toc-text">为什么这个方案更安全？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A7%82%E7%82%B9%EF%BC%9A%E6%97%A0%E7%8A%B6%E6%80%81-JWT-%E7%9A%84%E7%89%B9%E6%80%A7%E5%86%B3%E5%AE%9A%E4%BA%86%E2%80%9C%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95%E2%80%9D%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">19.0.6.1.</span> <span class="toc-text">核心观点：无状态 JWT 的特性决定了“退出登录”的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%B8%B8%E8%A7%84%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95%EF%BC%89"><span class="toc-number">19.0.6.2.</span> <span class="toc-text">1. 客户端实现（常规退出登录）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%BC%BA%E5%88%B6%E4%B8%8B%E7%BA%BF%E6%88%96%E5%8D%B3%E6%97%B6%E5%A4%B1%E6%95%88%EF%BC%89"><span class="toc-number">19.0.6.3.</span> <span class="toc-text">2. 服务端实现（强制下线或即时失效）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">19.0.7.</span> <span class="toc-text">总结与对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E8%AF%A6%E7%BB%86%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90"><span class="toc-number">20.</span> <span class="toc-text">Redis 详细技术解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">20.1.</span> <span class="toc-text">Redis 核心架构与原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">20.1.1.</span> <span class="toc-text">内存模型与数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">20.1.2.</span> <span class="toc-text">单线程模型与事件循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">20.2.</span> <span class="toc-text">数据类型详解与应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="toc-number">20.2.1.</span> <span class="toc-text">Redis 的数据结构详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">20.2.1.1.</span> <span class="toc-text">1. String (字符串)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Hash-%E5%93%88%E5%B8%8C"><span class="toc-number">20.2.1.2.</span> <span class="toc-text">2. Hash (哈希)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-List-%E5%88%97%E8%A1%A8"><span class="toc-number">20.2.1.3.</span> <span class="toc-text">3. List (列表)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Set-%E9%9B%86%E5%90%88"><span class="toc-number">20.2.1.4.</span> <span class="toc-text">4. Set (集合)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Sorted-Set-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">20.2.1.5.</span> <span class="toc-text">5. Sorted Set (有序集合)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">20.2.2.</span> <span class="toc-text">Redis 的持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-RDB-Redis-Database"><span class="toc-number">20.2.2.1.</span> <span class="toc-text">1. RDB (Redis Database)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-AOF-Append-Only-File"><span class="toc-number">20.2.2.2.</span> <span class="toc-text">2. AOF (Append Only File)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="toc-number">20.2.3.</span> <span class="toc-text">String类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%B1%BB%E5%9E%8B"><span class="toc-number">20.2.4.</span> <span class="toc-text">Hash类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E7%B1%BB%E5%9E%8B"><span class="toc-number">20.2.5.</span> <span class="toc-text">List类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E7%B1%BB%E5%9E%8B"><span class="toc-number">20.2.6.</span> <span class="toc-text">Set类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorted-Set%E7%B1%BB%E5%9E%8B"><span class="toc-number">20.2.7.</span> <span class="toc-text">Sorted Set类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">20.3.</span> <span class="toc-text">持久化机制深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">20.3.1.</span> <span class="toc-text">RDB持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">20.3.2.</span> <span class="toc-text">AOF持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">20.4.</span> <span class="toc-text">缓存问题与解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">20.4.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">20.4.2.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">20.4.3.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">20.4.4.</span> <span class="toc-text">缓存预热</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number">20.5.</span> <span class="toc-text">数据一致性保证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Aside%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-number">20.5.1.</span> <span class="toc-text">Cache Aside模式（旁路缓存）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0%E7%AD%96%E7%95%A5"><span class="toc-number">20.5.2.</span> <span class="toc-text">延时双删策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">20.5.3.</span> <span class="toc-text">基于消息队列的最终一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88"><span class="toc-number">20.5.4.</span> <span class="toc-text">分布式事务方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">20.6.</span> <span class="toc-text">分布式锁实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESET%E5%91%BD%E4%BB%A4%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">20.6.1.</span> <span class="toc-text">基于SET命令的分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redlock%E7%AE%97%E6%B3%95"><span class="toc-number">20.6.2.</span> <span class="toc-text">Redlock算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">20.6.3.</span> <span class="toc-text">锁的问题与优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">20.7.</span> <span class="toc-text">悲观锁与乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">20.7.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">20.7.2.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81-vs-%E4%B9%90%E8%A7%82%E9%94%81%E9%80%89%E6%8B%A9"><span class="toc-number">20.7.3.</span> <span class="toc-text">悲观锁 vs 乐观锁选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84"><span class="toc-number">20.8.</span> <span class="toc-text">高可用架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">20.8.1.</span> <span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88Sentinel%EF%BC%89"><span class="toc-number">20.8.2.</span> <span class="toc-text">哨兵模式（Sentinel）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Cluster%EF%BC%89"><span class="toc-number">20.8.3.</span> <span class="toc-text">集群模式（Cluster）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%93%88%E5%B8%8C%E6%A7%BD%EF%BC%88Hash-Slot%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-number">20.8.3.1.</span> <span class="toc-text">Redis 哈希槽（Hash Slot）详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E6%A7%BD%EF%BC%9F"><span class="toc-number">20.8.3.2.</span> <span class="toc-text">1. 什么是哈希槽？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%94%AE%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84%E5%88%B0%E5%93%88%E5%B8%8C%E6%A7%BD%EF%BC%9F"><span class="toc-number">20.8.3.3.</span> <span class="toc-text">2. 键如何映射到哈希槽？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%93%88%E5%B8%8C%E6%A7%BD%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E7%BB%99%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="toc-number">20.8.3.4.</span> <span class="toc-text">3. 哈希槽如何分配给节点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%93%88%E5%B8%8C%E6%A7%BD%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">20.8.3.5.</span> <span class="toc-text">4. 哈希槽的优势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">20.9.</span> <span class="toc-text">性能监控与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">20.9.1.</span> <span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">20.9.2.</span> <span class="toc-text">内存分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="toc-number">20.9.3.</span> <span class="toc-text">性能优化建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">20.10.</span> <span class="toc-text">内存管理与淘汰机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3"><span class="toc-number">20.10.1.</span> <span class="toc-text">内存淘汰策略详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="toc-number">20.10.2.</span> <span class="toc-text">内存碎片问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">20.11.</span> <span class="toc-text">过期策略与删除机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">20.11.1.</span> <span class="toc-text">三种过期删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%AE%9E%E7%8E%B0"><span class="toc-number">20.11.2.</span> <span class="toc-text">Redis过期删除实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">20.12.</span> <span class="toc-text">数据结构底层实现深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%EF%BC%88ZipList%EF%BC%89%E6%BC%94%E8%BF%9B"><span class="toc-number">20.12.1.</span> <span class="toc-text">压缩列表（ZipList）演进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%89%A9%E5%AE%B9%E4%B8%8Erehash"><span class="toc-number">20.12.2.</span> <span class="toc-text">字典扩容与rehash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">20.13.</span> <span class="toc-text">网络模型与性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-6-0-%E5%A4%9A%E7%BA%BF%E7%A8%8BI-O"><span class="toc-number">20.13.1.</span> <span class="toc-text">Redis 6.0 多线程I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">20.13.2.</span> <span class="toc-text">客户端连接管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">20.14.</span> <span class="toc-text">高级数据类型与应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">20.14.1.</span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88Redis-Module%EF%BC%89"><span class="toc-number">20.14.2.</span> <span class="toc-text">布隆过滤器（Redis Module）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geo%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">20.14.3.</span> <span class="toc-text">Geo地理位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%E4%B8%8E%E9%98%B2%E6%8A%A4"><span class="toc-number">20.15.</span> <span class="toc-text">安全性问题与防护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E"><span class="toc-number">20.15.1.</span> <span class="toc-text">常见安全漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACL%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%88Redis-6-0-%EF%BC%89"><span class="toc-number">20.15.2.</span> <span class="toc-text">ACL访问控制（Redis 6.0+）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%BF%90%E7%BB%B4"><span class="toc-number">20.16.</span> <span class="toc-text">监控与运维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87"><span class="toc-number">20.16.1.</span> <span class="toc-text">关键监控指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">20.16.2.</span> <span class="toc-text">故障排查常用命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">20.17.</span> <span class="toc-text">特殊应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81"><span class="toc-number">20.17.1.</span> <span class="toc-text">分布式限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8FSession"><span class="toc-number">20.17.2.</span> <span class="toc-text">分布式Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">20.17.3.</span> <span class="toc-text">消息队列实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-number">20.17.4.</span> <span class="toc-text">延时队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%8A%80%E5%B7%A7"><span class="toc-number">20.18.</span> <span class="toc-text">性能调优技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">20.18.1.</span> <span class="toc-text">内存优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96"><span class="toc-number">20.18.2.</span> <span class="toc-text">网络优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E4%BC%98%E5%8C%96"><span class="toc-number">20.18.3.</span> <span class="toc-text">CPU优化</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/8.21%E5%AD%A6%E4%BC%9A/" title="8.21学会">8.21学会</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" title="命令大全">命令大全</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式">分布式</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E6%A1%86%E6%9E%B6/" title="框架">框架</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/" title="手写答案">手写答案</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bg.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Charlotte</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
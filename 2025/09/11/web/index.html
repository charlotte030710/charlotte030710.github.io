<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>web | 浮生若梦</title><meta name="author" content="Charlotte"><meta name="copyright" content="Charlotte"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="好的，让我们深入到 HTTP 协议的底层，全面解剖它的工作原理、请求-响应模型、以及各个组成部分。  一、HTTP 协议概述HTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，它定义了 Web 客户端（如浏览器）和 Web 服务器之间交换数据的规则。它的核心特点是无状态（Stateless），这意味着服务器不会保存客户端的任何信息，每次请求都是独立的。">
<meta property="og:type" content="article">
<meta property="og:title" content="web">
<meta property="og:url" content="http://example.com/2025/09/11/web/index.html">
<meta property="og:site_name" content="浮生若梦">
<meta property="og:description" content="好的，让我们深入到 HTTP 协议的底层，全面解剖它的工作原理、请求-响应模型、以及各个组成部分。  一、HTTP 协议概述HTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，它定义了 Web 客户端（如浏览器）和 Web 服务器之间交换数据的规则。它的核心特点是无状态（Stateless），这意味着服务器不会保存客户端的任何信息，每次请求都是独立的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/title.jpg">
<meta property="article:published_time" content="2025-09-11T10:29:28.000Z">
<meta property="article:modified_time" content="2025-09-16T05:16:12.451Z">
<meta property="article:author" content="Charlotte">
<meta property="article:tag" content="web">
<meta property="article:tag" content="servlet">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/title.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "web",
  "url": "http://example.com/2025/09/11/web/",
  "image": "http://example.com/img/title.jpg",
  "datePublished": "2025-09-11T10:29:28.000Z",
  "dateModified": "2025-09-16T05:16:12.451Z",
  "author": [
    {
      "@type": "Person",
      "name": "Charlotte",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="http://example.com/2025/09/11/web/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'web',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="浮生若梦" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/title.jpg" alt="Logo"><span class="site-name">浮生若梦</span></a><a class="nav-page-title" href="/"><span class="site-name">web</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">web</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-16T05:16:12.451Z" title="更新于 2025-09-16 13:16:12">2025-09-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/web/">web</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>好的，让我们深入到 HTTP 协议的底层，全面解剖它的工作原理、请求-响应模型、以及各个组成部分。</p>
<hr>
<h3 id="一、HTTP-协议概述"><a href="#一、HTTP-协议概述" class="headerlink" title="一、HTTP 协议概述"></a>一、HTTP 协议概述</h3><p>HTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，它定义了 Web 客户端（如浏览器）和 Web 服务器之间交换数据的规则。它的核心特点是<strong>无状态（Stateless）</strong>，这意味着服务器不会保存客户端的任何信息，每次请求都是独立的。</p>
<hr>
<h3 id="二、HTTP-请求（Request）"><a href="#二、HTTP-请求（Request）" class="headerlink" title="二、HTTP 请求（Request）"></a>二、HTTP 请求（Request）</h3><p>一个完整的 HTTP 请求由四部分组成：</p>
<h4 id="1-请求行（Request-Line）"><a href="#1-请求行（Request-Line）" class="headerlink" title="1. 请求行（Request Line）"></a>1. 请求行（Request Line）</h4><p>这是请求的第一行，它定义了请求的基本信息。</p>
<ul>
<li><strong>请求方法（Method）</strong>：如 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 等，表示对资源的操作类型。</li>
<li><strong>请求 URL (URI)</strong>：资源的地址。</li>
<li><strong>HTTP 协议版本</strong>：如 <code>HTTP/1.1</code>, <code>HTTP/2.0</code>。</li>
</ul>
<p>示例：</p>
<p>GET &#x2F;index.html HTTP&#x2F;1.1</p>
<h4 id="2-请求头（Request-Headers）"><a href="#2-请求头（Request-Headers）" class="headerlink" title="2. 请求头（Request Headers）"></a>2. 请求头（Request Headers）</h4><p>请求头提供了关于客户端、请求体和一些其他元数据的信息。它们以键值对的形式存在。</p>
<ul>
<li><strong>Host</strong>：指定请求的目标服务器的域名和端口号。</li>
<li><strong>User-Agent</strong>：客户端的软件类型和版本，如浏览器信息。</li>
<li><strong>Accept</strong>：客户端能够处理的媒体类型，告诉服务器希望返回什么格式的数据（如 <code>application/json</code>, <code>text/html</code>）。</li>
<li><strong>Content-Type</strong>：<strong>请求体</strong>中的数据类型，只在有请求体时使用（如 <code>POST</code>）。常见的有：<ul>
<li><code>application/x-www-form-urlencoded</code>：默认编码，用于提交表单数据。</li>
<li><code>multipart/form-data</code>：用于上传文件。</li>
<li><code>application/json</code>：用于前后端分离，提交 JSON 数据。</li>
</ul>
</li>
<li><strong>Content-Length</strong>：请求体的长度（字节）。</li>
<li><strong>Cookie</strong>：客户端存储的 Cookie 信息，用于会话管理。</li>
<li><strong>Authorization</strong>：用于身份认证，如携带 Bearer Token。</li>
<li><strong>Referer</strong>：请求从哪个页面跳转而来。</li>
</ul>
<h4 id="3-空行"><a href="#3-空行" class="headerlink" title="3. 空行"></a>3. 空行</h4><p>一个空行用于分隔请求头和请求体。</p>
<h4 id="4-请求体（Request-Body）"><a href="#4-请求体（Request-Body）" class="headerlink" title="4. 请求体（Request Body）"></a>4. 请求体（Request Body）</h4><p>请求体包含客户端提交给服务器的数据，通常用于 <code>POST</code>、<code>PUT</code> 等请求。GET 请求通常没有请求体。</p>
<hr>
<h3 id="三、HTTP-响应（Response）"><a href="#三、HTTP-响应（Response）" class="headerlink" title="三、HTTP 响应（Response）"></a>三、HTTP 响应（Response）</h3><p>一个完整的 HTTP 响应由三部分组成：</p>
<h4 id="1-状态行（Status-Line）"><a href="#1-状态行（Status-Line）" class="headerlink" title="1. 状态行（Status Line）"></a>1. 状态行（Status Line）</h4><p>这是响应的第一行，定义了响应的基本信息。</p>
<ul>
<li><strong>HTTP 协议版本</strong>：如 <code>HTTP/1.1</code>。</li>
<li><strong>状态码（Status Code）</strong>：三位数字，表示请求结果。</li>
<li><strong>状态信息（Reason Phrase）</strong>：对状态码的简短描述。</li>
</ul>
<p>示例：</p>
<p>HTTP&#x2F;1.1 200 OK</p>
<h4 id="2-响应头（Response-Headers）"><a href="#2-响应头（Response-Headers）" class="headerlink" title="2. 响应头（Response Headers）"></a>2. 响应头（Response Headers）</h4><p>响应头提供了关于服务器、响应体和会话的元数据信息。</p>
<ul>
<li><strong>Content-Type</strong>：<strong>响应体</strong>的数据类型。</li>
<li><strong>Content-Length</strong>：响应体的长度。</li>
<li><strong>Set-Cookie</strong>：服务器向客户端发送 Cookie，用于存储会话 ID 等信息。</li>
<li><strong>Location</strong>：用于重定向，指定新的 URL。</li>
<li><strong>Cache-Control</strong>：控制浏览器缓存行为。</li>
</ul>
<h4 id="3-空行-1"><a href="#3-空行-1" class="headerlink" title="3. 空行"></a>3. 空行</h4><p>一个空行用于分隔响应头和响应体。</p>
<h4 id="4-响应体（Response-Body）"><a href="#4-响应体（Response-Body）" class="headerlink" title="4. 响应体（Response Body）"></a>4. 响应体（Response Body）</h4><p>响应体包含了服务器返回给客户端的实际数据，如 HTML 网页内容、JSON 数据或图片等。</p>
<hr>
<h3 id="四、HTTP-方法的幂等性与安全性"><a href="#四、HTTP-方法的幂等性与安全性" class="headerlink" title="四、HTTP 方法的幂等性与安全性"></a>四、HTTP 方法的幂等性与安全性</h3><ul>
<li><strong>安全性</strong>：指请求方法不会对服务器上的资源状态产生修改。<code>GET</code> 和 <code>HEAD</code> 方法是安全的。</li>
<li><strong>幂等性</strong>：指请求方法重复执行多次，对服务器上的资源状态产生的影响与执行一次的影响相同。<ul>
<li><strong>幂等方法</strong>：<code>GET</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>。</li>
<li><strong>非幂等方法</strong>：<code>POST</code>。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>安全性</th>
<th>幂等性</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>GET</strong></td>
<td>是</td>
<td>是</td>
<td>获取资源</td>
</tr>
<tr>
<td><strong>POST</strong></td>
<td>否</td>
<td>否</td>
<td>创建资源</td>
</tr>
<tr>
<td><strong>PUT</strong></td>
<td>否</td>
<td>是</td>
<td>更新或替换资源</td>
</tr>
<tr>
<td><strong>DELETE</strong></td>
<td>否</td>
<td>是</td>
<td>删除资源</td>
</tr>
</tbody></table>
<hr>
<h3 id="五、HTTP-的会话管理：Cookie"><a href="#五、HTTP-的会话管理：Cookie" class="headerlink" title="五、HTTP 的会话管理：Cookie"></a>五、HTTP 的会话管理：Cookie</h3><p>HTTP 本身是无状态的，但为了跟踪用户，引入了 Cookie。</p>
<ol>
<li><strong>创建</strong>：服务器通过响应头 <code>Set-Cookie</code> 向客户端发送一个 Cookie。</li>
<li><strong>存储</strong>：浏览器接收到 <code>Set-Cookie</code> 后，会将其存储在本地。</li>
<li><strong>携带</strong>：之后，每次对同一域名发起请求时，浏览器都会自动在请求头 <code>Cookie</code> 中带上这个 Cookie。</li>
</ol>
<p>通过在 Cookie 中存储一个 SessionID，服务器就可以在后续请求中找到对应的会话数据，从而实现状态管理。</p>
<hr>
<h3 id="六、HTTP-1-1-与-HTTP-2-的区别"><a href="#六、HTTP-1-1-与-HTTP-2-的区别" class="headerlink" title="六、HTTP&#x2F;1.1 与 HTTP&#x2F;2 的区别"></a>六、HTTP&#x2F;1.1 与 HTTP&#x2F;2 的区别</h3><ul>
<li><strong>多路复用（Multiplexing）</strong>：HTTP&#x2F;2 允许在<strong>一个 TCP 连接</strong>上同时发送多个请求和响应，解决了 HTTP&#x2F;1.1 队头阻塞的问题，显著提高了性能。</li>
<li><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;2 使用 HPACK 算法压缩请求和响应头，减少了数据传输量。</li>
<li><strong>服务器推送（Server Push）</strong>：服务器可以在客户端请求一个资源时，主动推送其他它认为客户端可能需要的资源，减少了客户端的请求次数。</li>
<li><strong>二进制分帧（Binary Framing）</strong>：HTTP&#x2F;2 将所有传输信息分割成更小的消息和帧，并采用二进制编码，使得解析更高效。</li>
</ul>
<p>好的，我们来详细补充 <strong>HTTP&#x2F;1.0</strong> 的核心概念，并对整个 HTTP 协议族进行全面的对比和深入解析。</p>
<hr>
<h3 id="一、HTTP-协议族演变：从-1-0-到-2-0"><a href="#一、HTTP-协议族演变：从-1-0-到-2-0" class="headerlink" title="一、HTTP 协议族演变：从 1.0 到 2.0"></a>一、HTTP 协议族演变：从 1.0 到 2.0</h3><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h4><p>HTTP&#x2F;1.0 是 HTTP 协议的早期版本，它的设计相对简单，主要用于满足基本的网页浏览需求。</p>
<ul>
<li><strong>核心特点：</strong><ul>
<li><strong>非持久连接（Non-persistent Connection）</strong>：这是 HTTP&#x2F;1.0 最显著的特点。每进行一次 HTTP 请求-响应，客户端和服务器之间就会建立一个新的 <strong>TCP 连接</strong>，并在请求完成后立即断开。<ul>
<li><strong>缺点</strong>：每次请求都需要经过 TCP 三次握手和四次挥手的过程，这带来了巨大的性能开销。如果一个网页包含多个图片、CSS 或 JavaScript 文件，浏览器需要为每个文件单独建立和断开连接，导致页面加载速度慢。</li>
</ul>
</li>
<li><strong>无主机头（No Host Header）</strong>：请求头中没有 <code>Host</code> 字段。这意味着一个 IP 地址只能对应一个域名。如果服务器上有多个网站，就无法通过 IP 地址来区分它们，这在虚拟主机时代是个大问题。</li>
<li><strong>不支持管线化（Pipelining）</strong>：客户端发送一个请求后，必须等待服务器的响应，才能发送下一个请求。</li>
</ul>
</li>
</ul>
<h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h4><p>HTTP&#x2F;1.1 协议是对 1.0 的重大改进，解决了其大部分性能瓶颈。</p>
<ul>
<li><strong>核心特点：</strong><ul>
<li><strong>持久连接（Persistent Connection）</strong>：默认情况下，HTTP&#x2F;1.1 会在一次请求-响应之后<strong>保持 TCP 连接不断开</strong>。客户端可以继续在这个连接上发送后续请求。<ul>
<li><strong>优点</strong>：显著减少了 TCP 连接的建立和断开开销，提高了页面加载速度。这个特性也称为“Keep-Alive”。</li>
</ul>
</li>
<li><strong>支持主机头（Host Header）</strong>：请求头中引入了 <code>Host</code> 字段，允许在同一个 IP 地址上部署多个虚拟主机（域名）。</li>
<li><strong>支持管线化（Pipelining）</strong>：客户端可以在收到上一个响应之前，连续发送多个请求。<ul>
<li><strong>缺点</strong>：虽然提高了效率，但存在**队头阻塞（Head-of-Line Blocking）**问题。如果第一个请求处理时间很长，后面的请求即使已经处理完成，也必须等待它的响应，导致整个连接的效率降低。</li>
</ul>
</li>
<li><strong>引入缓存机制</strong>：通过 <code>Cache-Control</code>, <code>ETag</code>, <code>If-None-Match</code> 等请求头，HTTP&#x2F;1.1 提供了更完善的缓存机制，减少了不必要的请求。</li>
</ul>
</li>
</ul>
<h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h4><p>HTTP&#x2F;2.0 是为了解决 HTTP&#x2F;1.1 在移动互联网和高并发场景下的性能问题而设计的。它不是对 HTTP&#x2F;1.1 的简单升级，而是对协议底层进行了重构。</p>
<ul>
<li><strong>核心特点：</strong><ul>
<li><strong>多路复用（Multiplexing）</strong>：这是 HTTP&#x2F;2 的核心。它允许在<strong>一个 TCP 连接</strong>上同时处理多个 HTTP 请求和响应。<ul>
<li><strong>如何实现？</strong>：HTTP&#x2F;2 将所有数据流（Stream）分割成更小的二进制帧（Frame），每个帧都带有唯一的标识符。这样，客户端和服务器可以在同一个连接上交错发送和接收帧，然后根据标识符重新组装，从而彻底解决了 HTTP&#x2F;1.1 的队头阻塞问题。</li>
</ul>
</li>
<li><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;2 使用 HPACK 算法来压缩请求和响应头，尤其是对于重复发送的字段，大大减少了数据传输量。</li>
<li><strong>服务器推送（Server Push）</strong>：服务器可以在客户端请求一个资源（如 HTML 页面）时，主动推送其他它认为客户端可能需要的资源（如 CSS 和 JS 文件），而无需客户端显式请求，进一步提高了加载速度。</li>
<li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议，而不是文本协议，解析更高效、更不容易出错。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、HTTP-协议版本对比总结"><a href="#二、HTTP-协议版本对比总结" class="headerlink" title="二、HTTP 协议版本对比总结"></a>二、HTTP 协议版本对比总结</h3><p>理解 HTTP 协议的演变历程，能让你更深刻地体会到 Web 性能优化的方向，以及现代 Web 框架如何利用这些底层协议特性来提供更高效的服务。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>HTTP&#x2F;1.0</th>
<th>HTTP&#x2F;1.1</th>
<th>HTTP&#x2F;2.0</th>
</tr>
</thead>
<tbody><tr>
<td><strong>TCP 连接</strong></td>
<td>非持久连接</td>
<td>默认持久连接</td>
<td>单个 TCP 连接多路复用</td>
</tr>
<tr>
<td><strong>性能瓶颈</strong></td>
<td>多次握手挥手开销</td>
<td>队头阻塞</td>
<td>无</td>
</tr>
<tr>
<td><strong>主机头</strong></td>
<td>不支持</td>
<td>支持 (<code>Host</code> Header)</td>
<td>支持</td>
</tr>
<tr>
<td><strong>并发请求</strong></td>
<td>串行（一个请求一个连接）</td>
<td>串行（一个连接一个请求）</td>
<td>并行（一个连接多个请求）</td>
</tr>
<tr>
<td><strong>数据格式</strong></td>
<td>文本协议</td>
<td>文本协议</td>
<td>二进制协议</td>
</tr>
<tr>
<td><strong>头部</strong></td>
<td>无压缩</td>
<td>无压缩</td>
<td>HPACK 算法压缩</td>
</tr>
<tr>
<td><strong>服务器推送</strong></td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>好的，让我们把所有关于 Servlet 的知识点整合在一起，进行一次最全面、最深入的剖析。我们将从基础概念开始，逐步深入到它的生命周期、配置、核心方法以及与 Servlet 规范相关的其他重要组件。</p>
<hr>
<h3 id="Servlet-概述：Java-Web-的核心基石"><a href="#Servlet-概述：Java-Web-的核心基石" class="headerlink" title="Servlet 概述：Java Web 的核心基石"></a>Servlet 概述：Java Web 的核心基石</h3><p><strong>Servlet</strong> 是 Java EE 规范中的一个核心组件，它是一个运行在服务器端的 Java 程序，用于处理 HTTP 请求和生成动态响应。你可以把它看作是所有 Java Web 框架（如 Spring MVC）的底层引擎。</p>
<p><strong>它的核心作用</strong>是作为客户端（浏览器）和 Java 应用程序之间的“桥梁”。Servlet 容器（如 Tomcat、Jetty）负责监听网络请求，然后将请求分发给相应的 Servlet 进行处理。</p>
<h3 id="Servlet-的生命周期：由容器严格管理"><a href="#Servlet-的生命周期：由容器严格管理" class="headerlink" title="Servlet 的生命周期：由容器严格管理"></a>Servlet 的生命周期：由容器严格管理</h3><p>一个 Servlet 的生命周期由 Servlet 容器严格管理，通常分为三个阶段：</p>
<ol>
<li><strong>初始化（Initialization）</strong><ul>
<li><strong>时机</strong>：当 Servlet 容器第一次加载 Servlet 类并创建其实例后，立即调用 <code>init()</code> 方法。</li>
<li><strong>特性</strong>：这个方法<strong>只执行一次</strong>，通常用于加载配置文件、建立数据库连接池等一次性、耗时的任务。如果 <code>init()</code> 方法抛出异常，Servlet 将无法提供服务。</li>
</ul>
</li>
<li><strong>服务（Servicing）</strong><ul>
<li><strong>时机</strong>：每当一个客户端请求到达时，容器会为该请求创建一个新的线程，并调用 <code>service()</code> 方法。</li>
<li><strong>特性</strong>：<code>service()</code> 方法是 Servlet 的核心，它会根据请求类型（如 GET、POST）自动调用相应的 <code>doGet()</code>、<code>doPost()</code> 等方法。由于此方法会被多个线程并发调用，因此访问共享资源时必须注意<strong>线程安全</strong>。</li>
</ul>
</li>
<li><strong>销毁（Destruction）</strong><ul>
<li><strong>时机</strong>：当 Servlet 容器关闭或决定卸载某个 Servlet 时，会调用其 <code>destroy()</code> 方法。</li>
<li><strong>特性</strong>：这个方法也<strong>只执行一次</strong>，用于释放资源，如关闭数据库连接或文件流。</li>
</ul>
</li>
</ol>
<h3 id="Servlet-的配置和部署：两种主要方式"><a href="#Servlet-的配置和部署：两种主要方式" class="headerlink" title="Servlet 的配置和部署：两种主要方式"></a>Servlet 的配置和部署：两种主要方式</h3><p>为了让容器知道如何加载和映射 Servlet，你需要进行配置。</p>
<ol>
<li><strong>web.xml 配置（传统方式）</strong><ul>
<li>在 <code>web.xml</code> 文件中，使用 <code>&lt;servlet&gt;</code> 标签定义 Servlet 类，并使用 <code>&lt;servlet-mapping&gt;</code> 标签将它映射到一个 URL 路径。</li>
<li><strong>优点</strong>：配置集中，易于管理。</li>
<li><strong>缺点</strong>：如果 Servlet 很多，<code>web.xml</code> 文件会变得非常庞大。</li>
</ul>
</li>
<li><strong>注解配置（现代方式）</strong><ul>
<li>从 Servlet 3.0 规范开始，你可以使用 <code>@WebServlet</code> 注解来简化配置。只需在你的 Servlet 类上添加 <code>@WebServlet(&quot;/path&quot;)</code> 注解，容器就会自动识别和配置它。</li>
<li><strong>优点</strong>：配置简单，代码和配置在一起，提高了可读性。</li>
</ul>
</li>
</ol>
<h3 id="Servlet-的核心方法：处理请求和响应"><a href="#Servlet-的核心方法：处理请求和响应" class="headerlink" title="Servlet 的核心方法：处理请求和响应"></a>Servlet 的核心方法：处理请求和响应</h3><p>所有 Servlet 都应该实现 <code>javax.servlet.Servlet</code> 接口。通常，我们更常继承 <code>javax.servlet.http.HttpServlet</code>，因为它提供了更方便的 HTTP 请求处理方法。</p>
<ul>
<li><code>service(HttpServletRequest req, HttpServletResponse res)</code>：这是核心服务方法，由容器调用。它会根据请求的 HTTP 方法（GET、POST、PUT 等）来调用相应的 <code>doGet()</code>、<code>doPost()</code> 等方法。</li>
<li><code>doGet(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 GET 请求。</li>
<li><code>doPost(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 POST 请求。</li>
<li><code>doPut(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 PUT 请求。</li>
<li><code>doDelete(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 DELETE 请求。</li>
</ul>
<p>在这些方法中，你可以通过 <code>req</code> (请求) 和 <code>res</code> (响应) 对象来与客户端进行交互。</p>
<h3 id="Servlet-的请求和响应处理：与客户端交互"><a href="#Servlet-的请求和响应处理：与客户端交互" class="headerlink" title="Servlet 的请求和响应处理：与客户端交互"></a>Servlet 的请求和响应处理：与客户端交互</h3><ul>
<li><strong>获取请求参数</strong><ul>
<li><code>req.getParameter(&quot;paramName&quot;)</code>：获取单个参数值。</li>
<li><code>req.getParameterValues(&quot;paramName&quot;)</code>：获取具有相同名称的多个参数值（如复选框）。</li>
</ul>
</li>
<li><strong>设置响应头</strong><ul>
<li><code>res.setContentType(&quot;text/html;charset=UTF-8&quot;)</code>：设置响应的内容类型和字符编码。</li>
<li><code>res.setHeader(&quot;HeaderName&quot;, &quot;HeaderValue&quot;)</code>：设置自定义响应头。</li>
</ul>
</li>
<li><strong>写入响应内容</strong><ul>
<li><code>res.getWriter()</code>：获取一个 <code>PrintWriter</code>，用于向客户端发送文本响应。</li>
<li><code>res.getOutputStream()</code>：获取一个 <code>ServletOutputStream</code>，用于向客户端发送二进制响应（如图片、文件）。</li>
</ul>
</li>
</ul>
<h3 id="Servlet-的核心组件与作用域"><a href="#Servlet-的核心组件与作用域" class="headerlink" title="Servlet 的核心组件与作用域"></a>Servlet 的核心组件与作用域</h3><p>理解 Servlet 规范中的这些组件，能帮助你更合理地管理数据和资源。</p>
<ol>
<li><strong>ServletContext (应用上下文)</strong><ul>
<li><strong>作用</strong>：代表整个 Web 应用，它的生命周期与应用相同。</li>
<li><strong>作用域</strong>：数据在所有 Servlet、JSP 和 Filter 之间<strong>共享</strong>。</li>
<li><strong>用途</strong>：存储全局配置和共享数据。</li>
</ul>
</li>
<li><strong>ServletConfig (配置对象)</strong><ul>
<li><strong>作用</strong>：代表一个 Servlet 独有的配置。</li>
<li><strong>作用域</strong>：仅在它所关联的 Servlet 内部有效。</li>
<li><strong>用途</strong>：获取特定 Servlet 的初始化参数。</li>
</ul>
</li>
<li><strong>四大作用域</strong><ul>
<li><strong>PageContext (页面作用域)</strong>：仅在 JSP 页面内有效。</li>
<li><strong>HttpServletRequest (请求作用域)</strong>：在一次完整的请求-响应周期内有效，即使请求被转发，数据依然可见。</li>
<li><strong>HttpSession (会话作用域)</strong>：在同一个浏览器会话中有效，用于存储用户特定数据。</li>
<li><strong>ServletContext (应用作用域)</strong>：在整个 Web 应用中都有效，用于存储全局数据。</li>
</ul>
</li>
</ol>
<p>好的，我们来详细、深入地聊聊 Web 开发中至关重要的两个概念：Cookie 和 Session。它们是解决 HTTP 无状态问题的核心方案，但工作机制和应用场景却大不相同。</p>
<hr>
<h3 id="Cookie：客户端的“小纸条”"><a href="#Cookie：客户端的“小纸条”" class="headerlink" title="Cookie：客户端的“小纸条”"></a>Cookie：客户端的“小纸条”</h3><p><strong>Cookie</strong> 是服务器发送给浏览器并存储在客户端的一小段文本信息。浏览器在下次访问同一服务器时，会自动将该 Cookie 包含在请求中发送回去。</p>
<h4 id="核心工作机制"><a href="#核心工作机制" class="headerlink" title="核心工作机制"></a>核心工作机制</h4><ol>
<li><p>服务器创建 Cookie：</p>
<p>当用户首次访问网站时，服务器在响应头（Response Header）中添加一个 Set-Cookie 字段。</p>
<p>比如：Set-Cookie: JSESSIONID&#x3D;abcde12345; Path&#x3D;&#x2F;; HttpOnly</p>
</li>
<li><p>浏览器保存 Cookie：</p>
<p>浏览器接收到响应后，会解析 Set-Cookie 头，并将该信息以键值对的形式存储在本地。</p>
</li>
<li><p>浏览器发送 Cookie：</p>
<p>在后续的请求中，只要请求的域名和路径与 Cookie 的设置相符，浏览器就会自动在请求头（Request Header）中添加 Cookie 字段，将存储的 Cookie 信息发送给服务器。</p>
<p>比如：Cookie: JSESSIONID&#x3D;abcde12345</p>
</li>
</ol>
<h4 id="Cookie-的优缺点"><a href="#Cookie-的优缺点" class="headerlink" title="Cookie 的优缺点"></a>Cookie 的优缺点</h4><ul>
<li><strong>优点</strong>：<ul>
<li><strong>减轻服务器压力</strong>：数据存储在客户端，服务器不需要为每个用户维护状态，适用于大规模访问。</li>
<li><strong>可扩展性强</strong>：无状态，天然适合分布式架构。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>安全性差</strong>：数据以明文形式存储，容易被窃取和篡改。</li>
<li><strong>容量限制</strong>：单个 Cookie 的大小通常不超过 4KB，且一个域名下的 Cookie 总数也有限制。</li>
<li><strong>用户可禁用</strong>：如果用户禁用了浏览器 Cookie 功能，相关功能将无法使用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Session：服务器的“个人档案”"><a href="#Session：服务器的“个人档案”" class="headerlink" title="Session：服务器的“个人档案”"></a>Session：服务器的“个人档案”</h3><p><strong>Session</strong> 是服务器为每个用户创建的一个对象，用于存储特定用户的会话数据。它将用户的状态信息保存在服务器端，并通过一个唯一的 <strong>Session ID</strong> 来识别不同的用户。</p>
<h4 id="核心工作机制-1"><a href="#核心工作机制-1" class="headerlink" title="核心工作机制"></a>核心工作机制</h4><ol>
<li><p>服务器创建 Session：</p>
<p>当用户首次访问 Web 应用时，服务器会创建一个 HttpSession 对象，并为其分配一个唯一的 Session ID。</p>
</li>
<li><p>传递 Session ID：</p>
<p>服务器将这个 Session ID 以 Cookie 的形式发送给浏览器（这个 Cookie 通常叫 JSESSIONID）。</p>
<ul>
<li>如果浏览器禁用了 Cookie，服务器可以通过 <strong>URL 重写</strong>的方式，将 Session ID 附加到每个 URL 的末尾，例如：<code>.../index.jsp;jsessionid=abcde12345</code>。</li>
</ul>
</li>
<li><p>服务器维护 Session：</p>
<p>Session ID 传递到客户端后，服务器会在内存中或持久化存储中保存这个 HttpSession 对象及其数据。</p>
</li>
<li><p>识别用户：</p>
<p>后续的请求中，浏览器都会带着包含 Session ID 的 Cookie。服务器通过这个 ID 就能从内存中找到对应的 HttpSession 对象，从而获取该用户的状态信息。</p>
</li>
</ol>
<h4 id="Session-的优缺点"><a href="#Session-的优缺点" class="headerlink" title="Session 的优缺点"></a>Session 的优缺点</h4><ul>
<li><strong>优点</strong>：<ul>
<li><strong>安全性高</strong>：核心数据存储在服务器，客户端只传递一个无法猜解的 ID。</li>
<li><strong>容量大</strong>：存储在服务器，理论上没有大小限制。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>占用服务器资源</strong>：每个活跃的 Session 都会占用服务器内存，在高并发场景下可能成为瓶颈。</li>
<li><strong>分布式挑战</strong>：在多台服务器组成的集群环境中，需要额外的机制（如 Session 共享或粘性会话）来确保用户的请求总是被转发到同一个 Session 所在的服务器，或者所有服务器都能访问到 Session 数据。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Cookie-与-Session-的对比总结"><a href="#Cookie-与-Session-的对比总结" class="headerlink" title="Cookie 与 Session 的对比总结"></a>Cookie 与 Session 的对比总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据存储位置</strong></td>
<td>客户端（浏览器）</td>
<td>服务器端</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>较低，易被篡改</td>
<td>较高，数据安全</td>
</tr>
<tr>
<td><strong>数据容量</strong></td>
<td>较小（~4KB）</td>
<td>较大，无明显限制</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>轻量，不占用服务器资源</td>
<td>占用服务器内存，可能影响性能</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td>天然无状态，易于扩展</td>
<td>分布式环境下需要额外配置</td>
</tr>
<tr>
<td><strong>主要用途</strong></td>
<td>购物车、用户偏好、轻量级状态</td>
<td>登录状态、权限验证、敏感数据</td>
</tr>
</tbody></table>
<p>好的，我已将 GET 和 POST 请求的所有核心区别整理成一个简洁明了的表格，并补充了更多细节，使其更全面。</p>
<h3 id="GET-和-POST-请求的全面对比"><a href="#GET-和-POST-请求的全面对比" class="headerlink" title="GET 和 POST 请求的全面对比"></a>GET 和 POST 请求的全面对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>GET 请求</th>
<th>POST 请求</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基本作用</strong></td>
<td>从服务器<strong>获取</strong>资源</td>
<td>向服务器<strong>提交</strong>数据，通常用于<strong>创建</strong>资源。</td>
<td>语义不同是所有区别的根本。</td>
</tr>
<tr>
<td><strong>传参方式</strong></td>
<td>参数附加在 URL 中</td>
<td>参数放在请求体（Request Body）中</td>
<td>GET 参数可见，POST 参数隐藏。</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td><strong>不安全</strong>，URL 暴露</td>
<td><strong>相对安全</strong>，参数隐藏在请求体中</td>
<td>这里的“安全”指数据不被暴露。</td>
</tr>
<tr>
<td><strong>幂等性</strong></td>
<td><strong>是</strong>（多次执行结果相同）</td>
<td><strong>否</strong>（多次执行可能产生新资源）</td>
<td>幂等性是 RESTful 设计的关键原则。</td>
</tr>
<tr>
<td><strong>浏览器行为</strong></td>
<td>回退无害，可被记录在历史、收藏为书签。</td>
<td>回退时通常会提示重新提交，不记录在历史、不可收藏。</td>
<td>防止意外提交导致数据重复。</td>
</tr>
<tr>
<td><strong>缓存</strong></td>
<td><strong>可以被缓存</strong></td>
<td><strong>不会被缓存</strong></td>
<td>缓存能提高性能，但仅限于只读操作。</td>
</tr>
<tr>
<td><strong>传输数据量</strong></td>
<td>有长度限制（URL长度限制）</td>
<td>无长度限制（取决于服务器配置）</td>
<td>GET 不适合传输大量数据。</td>
</tr>
<tr>
<td><strong>数据编码</strong></td>
<td>只支持 URL 编码</td>
<td>支持多种编码（如<code>application/json</code>）</td>
<td>POST 灵活性高，适合各种数据类型。</td>
</tr>
<tr>
<td><strong>发送文件</strong></td>
<td>不支持</td>
<td>支持 (<code>multipart/form-data</code>)</td>
<td>文件必须通过请求体传输。</td>
</tr>
<tr>
<td><strong>HTTP 报文</strong></td>
<td>无请求体</td>
<td>有请求体</td>
<td>GET 请求报文更小，更轻量。</td>
</tr>
<tr>
<td><strong>TCP&#x2F;IP 协议</strong></td>
<td>一次性发送所有数据包</td>
<td>浏览器通常会先发送请求头，服务器响应 100-continue 后再发送请求体</td>
<td>POST 的分步发送机制可以避免发送不必要的数据。</td>
</tr>
</tbody></table>
<p>好的，我们将以 Servlet 的详细剖析方式，全面、深入地介绍 WebSocket。我们将从它的概念、生命周期、核心 API，到它与 HTTP 的区别以及在现代 Web 中的应用，进行系统性的梳理。</p>
<hr>
<h3 id="WebSocket-概述：Web-通信的革命"><a href="#WebSocket-概述：Web-通信的革命" class="headerlink" title="WebSocket 概述：Web 通信的革命"></a>WebSocket 概述：Web 通信的革命</h3><p><strong>WebSocket</strong> 协议是 HTML5 开始提供的一种在单个 TCP 连接上进行<strong>全双工通信</strong>的协议。与传统的 HTTP 协议不同，它打破了请求-响应的单向模式，使得客户端和服务器可以<strong>实时地双向自由传输数据</strong>。</p>
<p><strong>它的核心作用</strong>是解决 Web 应用中<strong>实时通信</strong>的需求，例如：聊天应用、在线游戏、股票行情、实时协作工具等。它极大地减少了网络开销，提高了通信效率。</p>
<h3 id="WebSocket-的核心工作原理"><a href="#WebSocket-的核心工作原理" class="headerlink" title="WebSocket 的核心工作原理"></a>WebSocket 的核心工作原理</h3><p>要理解 WebSocket，必须首先理解它与 HTTP 的关系。</p>
<ol>
<li><strong>基于 HTTP 的握手（Handshake）</strong>：<ul>
<li>WebSocket 的连接建立过程是基于 HTTP 协议的。</li>
<li>客户端发送一个特殊的 HTTP 请求，其中包含 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code> 请求头，向服务器请求将 HTTP 协议升级到 WebSocket 协议。</li>
<li>这是一个**“握手”**过程。</li>
</ul>
</li>
<li><strong>协议升级与持久连接</strong>：<ul>
<li>如果服务器支持 WebSocket，它会返回一个特殊的 HTTP 响应（状态码 <code>101 Switching Protocols</code>）。</li>
<li>握手成功后，客户端和服务器之间的 TCP 连接将<strong>保持打开状态</strong>。</li>
<li>这时，协议就从 HTTP 升级到了 WebSocket，双方可以在这个<strong>持久的 TCP 连接</strong>上自由地双向发送数据，而无需再进行 HTTP 头部开销。</li>
</ul>
</li>
<li><strong>数据帧传输</strong>：<ul>
<li>WebSocket 协议定义了**数据帧（Data Frames）**的概念。它将数据分割成更小、更轻量级的帧，而不是像 HTTP 那样发送整个报文。</li>
<li>这样，即使传输少量数据，也不会有很大的协议开销，非常适合实时通信。</li>
</ul>
</li>
</ol>
<h3 id="WebSocket-的生命周期：事件驱动模型"><a href="#WebSocket-的生命周期：事件驱动模型" class="headerlink" title="WebSocket 的生命周期：事件驱动模型"></a>WebSocket 的生命周期：事件驱动模型</h3><p>WebSocket 的生命周期由客户端和服务器共同维护，由一系列事件驱动：</p>
<h4 id="1-连接建立（Connection-Establishment）"><a href="#1-连接建立（Connection-Establishment）" class="headerlink" title="1. 连接建立（Connection Establishment）"></a>1. 连接建立（Connection Establishment）</h4><ul>
<li><strong>客户端</strong>：通过 <code>new WebSocket(url)</code> 建立连接。</li>
<li><strong>服务器</strong>：当客户端发送握手请求后，服务器处理并接受连接，此时触发 <code>onopen</code> 事件。</li>
</ul>
<h4 id="2-数据传输（Data-Transmission）"><a href="#2-数据传输（Data-Transmission）" class="headerlink" title="2. 数据传输（Data Transmission）"></a>2. 数据传输（Data Transmission）</h4><ul>
<li><strong>发送</strong>：客户端和服务器都可以通过各自的 <code>send()</code> 方法向对方发送数据。</li>
<li><strong>接收</strong>：当一方接收到数据时，会触发 <code>onmessage</code> 事件。</li>
</ul>
<h4 id="3-连接关闭（Connection-Close）"><a href="#3-连接关闭（Connection-Close）" class="headerlink" title="3. 连接关闭（Connection Close）"></a>3. 连接关闭（Connection Close）</h4><ul>
<li><strong>主动关闭</strong>：客户端或服务器可以调用 <code>close()</code> 方法主动关闭连接。</li>
<li><strong>异常关闭</strong>：连接可能因网络故障、心跳超时等原因意外关闭。</li>
<li><strong>事件</strong>：无论是主动还是被动，连接关闭时都会触发 <code>onclose</code> 事件。</li>
</ul>
<h3 id="WebSocket-的核心-API（以-JavaScript-为例）"><a href="#WebSocket-的核心-API（以-JavaScript-为例）" class="headerlink" title="WebSocket 的核心 API（以 JavaScript 为例）"></a>WebSocket 的核心 API（以 JavaScript 为例）</h3><p>WebSocket 的 API 设计非常简洁，主要基于事件监听和方法调用。</p>
<ul>
<li><strong>new WebSocket(url)</strong>：创建一个 WebSocket 客户端实例。</li>
<li><strong>websocket.onopen</strong>：连接成功建立时触发。</li>
<li><strong>websocket.onmessage &#x3D; function(event)</strong>：接收到服务器数据时触发，数据在 <code>event.data</code> 中。</li>
<li><strong>websocket.onerror</strong>：连接发生错误时触发。</li>
<li><strong>websocket.onclose</strong>：连接关闭时触发。</li>
<li><strong>websocket.send(data)</strong>：向服务器发送数据。</li>
<li><strong>websocket.close()</strong>：关闭连接。</li>
</ul>
<h3 id="WebSocket-与-HTTP-的本质区别"><a href="#WebSocket-与-HTTP-的本质区别" class="headerlink" title="WebSocket 与 HTTP 的本质区别"></a>WebSocket 与 HTTP 的本质区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>HTTP</th>
<th>WebSocket</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>通信模式</strong></td>
<td><strong>单向</strong>（请求-响应）</td>
<td><strong>双向</strong>（全双工）</td>
<td>HTTP 客户端必须先发请求，服务器才能响应。</td>
</tr>
<tr>
<td><strong>连接状态</strong></td>
<td><strong>无状态</strong>，短连接</td>
<td><strong>有状态</strong>，长连接</td>
<td>HTTP 每次请求都需要重新建立连接。</td>
</tr>
<tr>
<td><strong>协议开销</strong></td>
<td><strong>大</strong>（每次请求都携带头部）</td>
<td><strong>小</strong>（握手后只传输数据帧）</td>
<td>HTTP 适合传输大文件，WebSocket 适合小数据频繁传输。</td>
</tr>
<tr>
<td><strong>服务器主动性</strong></td>
<td><strong>被动</strong>（无法主动推送）</td>
<td><strong>主动</strong>（可随时推送数据）</td>
<td>WebSocket 解决了 HTTP 的“服务器推”难题。</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>网页浏览、API 调用、文件下载</td>
<td>聊天、游戏、实时数据更新</td>
<td></td>
</tr>
</tbody></table>
<h3 id="WebSocket-在现代-Java-Web-中的应用"><a href="#WebSocket-在现代-Java-Web-中的应用" class="headerlink" title="WebSocket 在现代 Java Web 中的应用"></a>WebSocket 在现代 Java Web 中的应用</h3><p>在 Java 后端，WebSocket 通常由专门的框架或容器来实现，如：</p>
<ul>
<li><strong>JavaEE 7+ 的 WebSocket API</strong>：提供了 <code>javax.websocket</code> 包，可以直接在 Servlet 容器中开发 WebSocket 应用。</li>
<li><strong>Spring Framework</strong>：提供了强大的 WebSocket 支持，集成了 STOMP（Simple Text Oriented Messaging Protocol）协议，简化了消息路由和管理。</li>
</ul>
<p>在这些框架中，你通常会定义一个 WebSocket 端点（Endpoint），类似于 Servlet，它负责处理连接的建立、消息的接收和发送、以及连接的关闭。</p>
<p>总而言之，WebSocket 是 HTTP 协议在实时通信领域的有力补充。它通过一次性的握手建立一个持久的双向通道，极大地提高了 Web 应用的交互性和效率，是现代 Web 架构中不可或缺的一部分。</p>
<p>好的，为了更好地理解 WebSocket 的工作原理，我将提供几个具体的应用场景和相应的代码示例。这些示例将涵盖客户端（JavaScript）和服务器端（Java&#x2F;Spring Boot）的代码，以便你能够完整地看到双向通信是如何实现的。</p>
<hr>
<h3 id="示例一：实时聊天应用"><a href="#示例一：实时聊天应用" class="headerlink" title="示例一：实时聊天应用"></a>示例一：实时聊天应用</h3><p>这是 WebSocket 最经典的用例。</p>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a><strong>应用场景</strong>：</h4><p>多个用户连接到聊天室，当一个用户发送消息时，服务器将该消息实时广播给所有其他在线用户。</p>
<h4 id="核心逻辑："><a href="#核心逻辑：" class="headerlink" title="核心逻辑："></a><strong>核心逻辑</strong>：</h4><ul>
<li><strong>客户端</strong>：当用户在输入框中按下回车，JavaScript 将消息通过 WebSocket 连接发送给服务器。</li>
<li><strong>服务器</strong>：接收到消息后，遍历所有已连接的 WebSocket 会话，将消息逐一发送给每个会话。</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a><strong>代码示例</strong>：</h4><p><strong>1. 客户端 (JavaScript)</strong></p>
<p>JavaScript</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接 WebSocket 服务器</span></span><br><span class="line"><span class="type">const</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/chat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接成功事件</span></span><br><span class="line">socket.onopen = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket连接已建立&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听接收消息事件</span></span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="variable">message</span> <span class="operator">=</span> event.data;</span><br><span class="line">  <span class="type">const</span> <span class="variable">chatBox</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;chat-box&#x27;</span>);</span><br><span class="line">  chatBox.innerHTML += `&lt;p&gt;$&#123;message&#125;&lt;/p&gt;`; <span class="comment">// 将消息添加到聊天框</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接关闭事件</span></span><br><span class="line">socket.onclose = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket连接已关闭&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听错误事件</span></span><br><span class="line">socket.onerror = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket发生错误:&quot;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息函数</span></span><br><span class="line">function <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="variable">input</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;message-input&#x27;</span>);</span><br><span class="line">  <span class="type">const</span> <span class="variable">message</span> <span class="operator">=</span> input.value;</span><br><span class="line">  <span class="keyword">if</span> (message) &#123;</span><br><span class="line">    socket.send(message); <span class="comment">// 通过 WebSocket 发送消息</span></span><br><span class="line">    input.value = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 清空输入框</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定回车事件</span></span><br><span class="line">document.getElementById(<span class="string">&#x27;message-input&#x27;</span>).addEventListener(<span class="string">&#x27;keypress&#x27;</span>, function(e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.key === <span class="string">&#x27;Enter&#x27;</span>) &#123;</span><br><span class="line">    sendMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>2. 服务器端 (Java&#x2F;Spring Boot)</strong></p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatWebSocketEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储所有连接的客户端会话</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端连接成功时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.add(session); <span class="comment">// 添加新会话</span></span><br><span class="line">        System.out.println(<span class="string">&quot;新连接：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端发送消息时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息：&quot;</span> + message + <span class="string">&quot; 来自：&quot;</span> + session.getId());</span><br><span class="line">        <span class="comment">// 遍历所有会话，广播消息</span></span><br><span class="line">        sessions.forEach(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当连接关闭时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.remove(session); <span class="comment">// 移除会话</span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接关闭：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当发生错误时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接发生错误：&quot;</span> + session.getId());</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="示例二：实时股票行情或数据看板"><a href="#示例二：实时股票行情或数据看板" class="headerlink" title="示例二：实时股票行情或数据看板"></a>示例二：实时股票行情或数据看板</h3><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a><strong>应用场景</strong>：</h4><p>客户端连接到服务器，服务器定期或在数据更新时，向所有连接的客户端推送最新的股票价格或监控数据。</p>
<h4 id="核心逻辑：-1"><a href="#核心逻辑：-1" class="headerlink" title="核心逻辑："></a><strong>核心逻辑</strong>：</h4><ul>
<li><strong>客户端</strong>：只监听 <code>onmessage</code> 事件，被动接收服务器推送的数据。</li>
<li><strong>服务器</strong>：在后台启动一个定时任务或数据监听器。当数据变化时，主动通过 WebSocket 连接将新数据发送给客户端。</li>
</ul>
<h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a><strong>代码示例</strong>：</h4><p><strong>1. 客户端 (JavaScript)</strong></p>
<p>JavaScript</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/stock&#x27;</span>);</span><br><span class="line"></span><br><span class="line">socket.onopen = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;股票行情连接已建立&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">  <span class="comment">// 假设服务器发送的是JSON格式的股票数据</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">stockData</span> <span class="operator">=</span> JSON.parse(event.data);</span><br><span class="line">  <span class="type">const</span> <span class="variable">stockPriceElement</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;stock-price&#x27;</span>);</span><br><span class="line">  stockPriceElement.innerText = `当前价格: $&#123;stockData.price&#125;`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无需 sendMessage 函数，因为是单向被动接收</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 服务器端 (Java&#x2F;Spring Boot)</strong></p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/stock&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockWebSocketEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.add(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;新股票行情订阅者：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是一个定时任务，每隔5秒向所有客户端推送数据</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushStockData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟获取最新股票价格</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> Math.random() * <span class="number">100</span> + <span class="number">100</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;price\&quot;: &quot;</span> + String.format(<span class="string">&quot;%.2f&quot;</span>, price) + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有会话，推送数据</span></span><br><span class="line">        sessions.forEach(session -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                    session.getBasicRemote().sendText(json);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个例子清楚地展示了 WebSocket 如何通过<strong>持久连接</strong>和<strong>双向通信</strong>来解决实时应用中的核心痛点。</p>
<p>好的，让我们详细、清晰地解释<strong>静态资源</strong>和<strong>动态资源</strong>的概念，以及为什么某些服务器或工具只能处理静态资源。</p>
<hr>
<h3 id="一、静态资源-Static-Resources"><a href="#一、静态资源-Static-Resources" class="headerlink" title="一、静态资源 (Static Resources)"></a>一、静态资源 (Static Resources)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>静态资源</strong>是指在服务器端<strong>不需要经过任何处理或计算</strong>，就能直接返回给客户端的资源。它们的<strong>内容是固定不变</strong>的，无论何时、被谁请求，服务器返回的都是同一个文件。</p>
<h4 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h4><ul>
<li><strong>HTML 文件</strong> (<code>.html</code>)：纯 HTML 代码，浏览器直接渲染。</li>
<li><strong>CSS 样式表</strong> (<code>.css</code>)：定义网页样式。</li>
<li><strong>JavaScript 脚本</strong> (<code>.js</code>)：用于网页交互。</li>
<li><strong>图片</strong> (<code>.jpg</code>, <code>.png</code>, <code>.gif</code>)：图像文件。</li>
<li><strong>字体文件</strong> (<code>.woff</code>, <code>.ttf</code>)：网页字体。</li>
<li><strong>视频</strong> (<code>.mp4</code>, <code>.webm</code>)：视频文件。</li>
</ul>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li>客户端向服务器请求一个 URL，例如 <code>http://example.com/styles.css</code>。</li>
<li>服务器接收到请求，直接从<strong>文件系统</strong>中找到名为 <code>styles.css</code> 的文件。</li>
<li>服务器将 <code>styles.css</code> 的内容原封不动地返回给客户端。</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>高效</strong>：无需服务器计算，直接读取文件，响应速度极快。</li>
<li><strong>可缓存</strong>：由于内容不变，浏览器、代理服务器都可以对静态资源进行缓存，进一步减少网络传输。</li>
<li><strong>部署简单</strong>：只需将文件放在服务器的特定目录下即可。</li>
</ul>
<h3 id="二、动态资源-Dynamic-Resources"><a href="#二、动态资源-Dynamic-Resources" class="headerlink" title="二、动态资源 (Dynamic Resources)"></a>二、动态资源 (Dynamic Resources)</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>动态资源</strong>是指服务器端<strong>需要经过处理、计算或查询数据库</strong>，才能生成并返回给客户端的资源。它们的内容是<strong>可变</strong>的，不同的请求、不同的时间，返回的内容可能不同。</p>
<h4 id="常见类型-1"><a href="#常见类型-1" class="headerlink" title="常见类型"></a>常见类型</h4><ul>
<li><strong>Servlet&#x2F;JSP</strong>：Java 后端通过 Servlet 或 JSP 动态生成 HTML。</li>
<li><strong>PHP 脚本</strong> (<code>.php</code>)：PHP 后端生成 HTML。</li>
<li><strong>Python&#x2F;Django 视图</strong>：Python 后端处理请求并返回数据。</li>
<li><strong>RESTful API</strong>：返回 JSON、XML 等格式的数据。</li>
</ul>
<h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li>客户端向服务器请求一个 URL，例如 <code>http://example.com/user/profile?id=123</code>。</li>
<li>服务器接收到请求，将请求转发给<strong>后端程序</strong>（如 Servlet 容器）。</li>
<li>后端程序接收请求，根据请求参数 <code>id=123</code> 查询数据库，获取该用户的信息。</li>
<li>后端程序将数据渲染到 HTML 模板中，或者将数据封装成 JSON 格式。</li>
<li>后端程序将<strong>动态生成的内容</strong>作为响应返回给服务器。</li>
<li>服务器将该响应发送给客户端。</li>
</ol>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>灵活</strong>：可以根据业务逻辑生成个性化内容。</li>
<li><strong>消耗资源</strong>：需要消耗 CPU、内存、数据库连接等资源进行计算。</li>
<li><strong>不可直接缓存</strong>：由于内容可变，通常无法像静态资源那样直接缓存。</li>
</ul>
<h3 id="三、是什么东西只能解析静态资源？"><a href="#三、是什么东西只能解析静态资源？" class="headerlink" title="三、是什么东西只能解析静态资源？"></a>三、是什么东西只能解析静态资源？</h3><p>这个问题的核心在于**“解析”<strong>这个词。能“解析”静态资源的，通常指的是</strong>Web 服务器**。</p>
<ul>
<li><strong>Web 服务器</strong>：一种软件，它的主要职责是处理 HTTP 请求并返回文件。</li>
</ul>
<h4 id="1-纯静态-Web-服务器-Static-Web-Server"><a href="#1-纯静态-Web-服务器-Static-Web-Server" class="headerlink" title="1. 纯静态 Web 服务器 (Static Web Server)"></a>1. 纯静态 Web 服务器 (Static Web Server)</h4><p><strong>这类服务器的核心功能就是提供静态文件服务。</strong> 它们只知道如何根据 URL 路径，去文件系统找到对应的文件，然后返回。</p>
<ul>
<li><strong>工作原理</strong>：它们没有内置的后端语言解析器（如 Java 虚拟机、PHP 解释器）。当它们收到一个请求时，只会将 URL 映射到文件目录。如果文件存在，就返回；如果不存在，就返回 404 错误。</li>
<li><strong>代表</strong>：<strong>Nginx</strong>（作为反向代理或静态文件服务器时）、<strong>Apache HTTP Server</strong>（作为静态文件服务器时）。</li>
</ul>
<p><strong>为什么它们不能解析动态资源？</strong></p>
<p>因为它们<strong>不具备</strong>执行后端代码的能力。例如，当 Nginx 收到一个对 <code>.jsp</code> 文件的请求时，它不知道如何运行 Java 代码来生成 HTML。它只会把 <code>.jsp</code> 文件当作一个普通的文本文件返回给浏览器，浏览器也无法正确地解析。</p>
<h4 id="2-动态-Web-服务器-Dynamic-Web-Server"><a href="#2-动态-Web-服务器-Dynamic-Web-Server" class="headerlink" title="2. 动态 Web 服务器 (Dynamic Web Server)"></a>2. 动态 Web 服务器 (Dynamic Web Server)</h4><p>这类服务器通常被称为 <strong>“应用服务器”</strong>，它们在 Web 服务器的功能上，<strong>内置了后端语言的运行环境</strong>。</p>
<ul>
<li><strong>工作原理</strong>：<ul>
<li>当它们收到静态资源请求时，行为与静态服务器相同：直接返回文件。</li>
<li>当它们收到动态资源请求时，会将请求转发给内置的<strong>后端程序运行环境</strong>。例如，Tomcat 会将 <code>.jsp</code> 文件交给 JSP 引擎来编译和执行。</li>
</ul>
</li>
<li><strong>代表</strong>：<strong>Apache Tomcat</strong>、<strong>Jetty</strong>。</li>
</ul>
<p>因此，在实际生产环境中，我们经常采用<strong>动静分离</strong>的架构：</p>
<ul>
<li><strong>静态资源</strong>（<code>index.html</code>、<code>style.css</code> 等）交给 <strong>Nginx</strong> 这样的高效静态服务器处理。</li>
<li><strong>动态资源</strong>（<code>api/user</code>, <code>.jsp</code> 等）交给 <strong>Tomcat</strong> 这样的应用服务器处理。</li>
</ul>
<p>这样做的目的是，让专业的工具做专业的事：Nginx 擅长高并发的静态文件服务，而 Tomcat 则专注于复杂的动态业务逻辑。</p>
<p>好的，让我们来系统、全面地梳理前端的核心知识，这不仅是前端工程师的必备技能，也是后端开发者理解整个 Web 应用架构的关键。</p>
<h3 id="一、基础三剑客：构建网页的基石"><a href="#一、基础三剑客：构建网页的基石" class="headerlink" title="一、基础三剑客：构建网页的基石"></a>一、基础三剑客：构建网页的基石</h3><p>这三者是所有前端技术的基础，就像建筑的钢筋、水泥和水电。</p>
<h4 id="1-HTML-HyperText-Markup-Language"><a href="#1-HTML-HyperText-Markup-Language" class="headerlink" title="1. HTML (HyperText Markup Language)"></a>1. HTML (HyperText Markup Language)</h4><ul>
<li><strong>是什么</strong>：超文本标记语言，用于<strong>定义网页的结构和内容</strong>。它由一系列标签（tag）组成，这些标签告诉浏览器如何组织页面内容，如段落、标题、图片、链接等。</li>
<li><strong>核心概念</strong>：<ul>
<li><strong>标签（Tags）</strong>：如 <code>&lt;p&gt;</code> (段落), <code>&lt;h1&gt;</code> (一级标题), <code>&lt;img&gt;</code> (图片), <code>&lt;a&gt;</code> (超链接)。</li>
<li><strong>元素（Elements）</strong>：由开始标签、内容和结束标签组成，例如 <code>&lt;p&gt;这是一个段落。&lt;/p&gt;</code>。</li>
<li><strong>属性（Attributes）</strong>：提供关于元素的额外信息，如 <code>&lt;img src=&quot;image.jpg&quot; alt=&quot;描述&quot;&gt;</code> 中的 <code>src</code> 和 <code>alt</code>。</li>
<li><strong>语义化（Semantic HTML）</strong>：使用恰当的标签来表达内容的含义，如 <code>&lt;header&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;footer&gt;</code>，这有助于搜索引擎优化（SEO）和无障碍访问。</li>
</ul>
</li>
</ul>
<h4 id="2-CSS-Cascading-Style-Sheets"><a href="#2-CSS-Cascading-Style-Sheets" class="headerlink" title="2. CSS (Cascading Style Sheets)"></a>2. CSS (Cascading Style Sheets)</h4><ul>
<li><strong>是什么</strong>：层叠样式表，用于<strong>定义网页的样式和表现</strong>。它告诉浏览器如何显示 HTML 元素，如颜色、字体、布局、大小等。</li>
<li><strong>核心概念</strong>：<ul>
<li><strong>选择器（Selectors）</strong>：用于选中要应用样式的 HTML 元素，如 <code>h1</code> (标签选择器), <code>.my-class</code> (类选择器), <code>#my-id</code> (ID 选择器)。</li>
<li><strong>盒模型（Box Model）</strong>：每个 HTML 元素都被视为一个矩形盒子，包含 <code>content</code>（内容）、<code>padding</code>（内边距）、<code>border</code>（边框）和 <code>margin</code>（外边距）。</li>
<li><strong>布局（Layout）</strong>：<ul>
<li><strong>传统布局</strong>：<code>float</code>, <code>position</code>, <code>display</code>。</li>
<li><strong>现代布局</strong>：<strong>Flexbox</strong> (弹性盒子，用于一维布局) 和 <strong>Grid</strong> (网格系统，用于二维布局)。这两种是目前最主流的布局方式。</li>
</ul>
</li>
<li><strong>响应式设计（Responsive Design）</strong>：使用 <code>@media</code> 查询来根据设备屏幕大小调整样式，使网页在不同设备上都能良好显示。</li>
</ul>
</li>
</ul>
<h4 id="3-JavaScript-JS"><a href="#3-JavaScript-JS" class="headerlink" title="3. JavaScript (JS)"></a>3. JavaScript (JS)</h4><ul>
<li><strong>是什么</strong>：一种高级编程语言，用于<strong>实现网页的动态行为和交互</strong>。它可以操作 HTML 和 CSS，处理用户事件，并与服务器进行通信。</li>
<li><strong>核心概念</strong>：<ul>
<li><strong>DOM (Document Object Model) 操作</strong>：通过 <code>document</code> 对象，JS 可以获取、修改、添加或删除页面上的 HTML 元素。例如 <code>document.getElementById(&#39;myId&#39;)</code>。</li>
<li><strong>事件处理（Event Handling）</strong>：响应用户的行为，如点击、输入、鼠标移动等。例如 <code>element.addEventListener(&#39;click&#39;, function() &#123; ... &#125;)</code>。</li>
<li><strong>异步编程（Asynchronous Programming）</strong>：处理耗时操作，如网络请求。<ul>
<li><strong>Callback (回调函数)</strong>：传统方式。</li>
<li><strong>Promise</strong>：ES6 引入，解决了回调地狱问题。</li>
<li><strong>async&#x2F;await</strong>：基于 <code>Promise</code> 的语法糖，使异步代码看起来像同步代码，更易读。</li>
</ul>
</li>
<li><strong>AJAX (Asynchronous JavaScript and XML)</strong>：在不重新加载整个页面的情况下，与服务器进行异步通信。现代应用中通常使用 <code>fetch()</code> API 或 <code>Axios</code> 库来发送 JSON 数据。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、现代前端框架：提升开发效率"><a href="#二、现代前端框架：提升开发效率" class="headerlink" title="二、现代前端框架：提升开发效率"></a>二、现代前端框架：提升开发效率</h3><p>为了处理日益复杂的 Web 应用，开发者通常会使用以下框架。</p>
<ul>
<li><strong>React</strong>：由 Facebook 开发，<strong>组件化</strong>、<strong>声明式</strong>的 UI 库。<ul>
<li><strong>核心</strong>：<strong>组件（Components）</strong>，将 UI 拆分成独立、可复用的部分。</li>
<li><strong>工作原理</strong>：使用<strong>虚拟 DOM (Virtual DOM)</strong>，在内存中进行计算，然后只更新实际改变的部分，提高了性能。</li>
<li><strong>生态</strong>：庞大而活跃，有成熟的状态管理（Redux, Zustand）、路由（React Router）等解决方案。</li>
</ul>
</li>
<li><strong>Vue.js</strong>：由尤雨溪开发，易学易用，<strong>渐进式</strong>框架。<ul>
<li><strong>核心</strong>：<strong>响应式数据绑定</strong>，数据改变，视图自动更新。</li>
<li><strong>特点</strong>：上手快，文档友好，社区生态完善。</li>
</ul>
</li>
<li><strong>Angular</strong>：由 Google 开发，<strong>全能型</strong>框架。<ul>
<li><strong>核心</strong>：提供了完整的解决方案，包括路由、依赖注入、状态管理等。</li>
<li><strong>特点</strong>：适合大型企业级应用，学习曲线相对陡峭。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三、工程化：高效协作和自动化"><a href="#三、工程化：高效协作和自动化" class="headerlink" title="三、工程化：高效协作和自动化"></a>三、工程化：高效协作和自动化</h3><p>现代前端开发已经不仅仅是写代码，还需要使用一系列工具来提高效率。</p>
<ul>
<li><strong>包管理器</strong>：<code>npm</code>, <code>yarn</code>, <code>pnpm</code>。用于管理项目依赖。</li>
<li><strong>构建工具</strong>：<ul>
<li><strong>Webpack</strong>：将多个模块打包成一个或多个文件，并能处理资源依赖、代码压缩等。</li>
<li><strong>Vite</strong>：基于 ES Modules 的新一代构建工具，开发模式下速度极快。</li>
</ul>
</li>
<li><strong>转译工具</strong>：<strong>Babel</strong>。将 ES6+ 的代码转译为浏览器兼容的 ES5 代码。</li>
<li><strong>代码规范</strong>：<strong>ESLint</strong> (代码风格检查), <strong>Prettier</strong> (代码格式化)。</li>
<li><strong>版本控制</strong>：<strong>Git</strong>。用于团队协作和代码版本管理。</li>
</ul>
<p>好的，让我们详细、全面地介绍 CSS 选择器。选择器是 CSS 的核心，掌握它才能精确地控制网页样式。我们将从基础到高级，系统地梳理不同类型的选择器及其用法。</p>
<hr>
<h3 id="一、基础选择器-Basic-Selectors"><a href="#一、基础选择器-Basic-Selectors" class="headerlink" title="一、基础选择器 (Basic Selectors)"></a>一、基础选择器 (Basic Selectors)</h3><p>这些是 CSS 中最简单、最常用的选择器，用于直接选中元素。</p>
<h4 id="1-元素选择器-Type-Selector"><a href="#1-元素选择器-Type-Selector" class="headerlink" title="1. 元素选择器 (Type Selector)"></a>1. 元素选择器 (Type Selector)</h4><ul>
<li><strong>作用</strong>：根据元素的标签名来选择元素。</li>
<li><strong>语法</strong>：<code>element_name &#123; ... &#125;</code></li>
<li><strong>示例</strong>：<ul>
<li><code>p &#123; color: blue; &#125;</code>：选中所有 <code>&lt;p&gt;</code> 元素。</li>
<li><code>h1 &#123; font-size: 24px; &#125;</code>：选中所有 <code>&lt;h1&gt;</code> 元素。</li>
</ul>
</li>
</ul>
<h4 id="2-类选择器-Class-Selector"><a href="#2-类选择器-Class-Selector" class="headerlink" title="2. 类选择器 (Class Selector)"></a>2. 类选择器 (Class Selector)</h4><ul>
<li><strong>作用</strong>：根据元素的 <code>class</code> 属性来选择元素。</li>
<li><strong>语法</strong>：<code>.class_name &#123; ... &#125;</code></li>
<li><strong>特点</strong>：一个元素可以有多个类名，类名可以重复使用，非常灵活。</li>
<li><strong>示例</strong>：<ul>
<li><code>.highlight &#123; background-color: yellow; &#125;</code>：选中所有 <code>class</code> 属性中包含 <code>highlight</code> 的元素。</li>
</ul>
</li>
</ul>
<h4 id="3-ID-选择器-ID-Selector"><a href="#3-ID-选择器-ID-Selector" class="headerlink" title="3. ID 选择器 (ID Selector)"></a>3. ID 选择器 (ID Selector)</h4><ul>
<li><strong>作用</strong>：根据元素的 <code>id</code> 属性来选择元素。</li>
<li><strong>语法</strong>：<code>#id_name &#123; ... &#125;</code></li>
<li><strong>特点</strong>：在 HTML 文档中，一个 <code>id</code> 属性的值必须是<strong>唯一的</strong>。</li>
<li><strong>示例</strong>：<ul>
<li><code>#header &#123; height: 100px; &#125;</code>：选中 <code>id</code> 为 <code>header</code> 的唯一元素。</li>
</ul>
</li>
</ul>
<h4 id="4-通用选择器-Universal-Selector"><a href="#4-通用选择器-Universal-Selector" class="headerlink" title="4. 通用选择器 (Universal Selector)"></a>4. 通用选择器 (Universal Selector)</h4><ul>
<li><strong>作用</strong>：选择页面上的所有元素。</li>
<li><strong>语法</strong>：<code>* &#123; ... &#125;</code></li>
<li><strong>示例</strong>：<ul>
<li><code>* &#123; margin: 0; padding: 0; &#125;</code>：清除所有元素的默认外边距和内边距，常用于 CSS 重置。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、组合选择器-Combinators"><a href="#二、组合选择器-Combinators" class="headerlink" title="二、组合选择器 (Combinators)"></a>二、组合选择器 (Combinators)</h3><p>这些选择器用于根据元素之间的关系来选择元素，如父子关系、兄弟关系等。</p>
<h4 id="1-后代选择器-Descendant-Selector"><a href="#1-后代选择器-Descendant-Selector" class="headerlink" title="1. 后代选择器 (Descendant Selector)"></a>1. 后代选择器 (Descendant Selector)</h4><ul>
<li><strong>作用</strong>：选择某个元素内部的<strong>所有</strong>后代元素（包括子元素、孙子元素等）。</li>
<li><strong>语法</strong>：<code>ancestor descendant &#123; ... &#125;</code>，用<strong>空格</strong>分隔。</li>
<li><strong>示例</strong>：<ul>
<li><code>ul li &#123; list-style-type: none; &#125;</code>：选中所有 <code>&lt;ul&gt;</code> 内部的 <code>&lt;li&gt;</code> 元素。</li>
</ul>
</li>
</ul>
<h4 id="2-子选择器-Child-Selector"><a href="#2-子选择器-Child-Selector" class="headerlink" title="2. 子选择器 (Child Selector)"></a>2. 子选择器 (Child Selector)</h4><ul>
<li><strong>作用</strong>：选择某个元素的<strong>直接子元素</strong>。</li>
<li><strong>语法</strong>：<code>parent &gt; child &#123; ... &#125;</code>，用 <code>&gt;</code> 分隔。</li>
<li><strong>示例</strong>：<ul>
<li><code>ul &gt; li &#123; list-style-type: none; &#125;</code>：只选中 <code>&lt;ul&gt;</code> 的直接子元素 <code>&lt;li&gt;</code>。</li>
<li><strong>区别</strong>：与后代选择器相比，更加精确，性能也更好。</li>
</ul>
</li>
</ul>
<h4 id="3-相邻兄弟选择器-Adjacent-Sibling-Selector"><a href="#3-相邻兄弟选择器-Adjacent-Sibling-Selector" class="headerlink" title="3. 相邻兄弟选择器 (Adjacent Sibling Selector)"></a>3. 相邻兄弟选择器 (Adjacent Sibling Selector)</h4><ul>
<li><strong>作用</strong>：选择紧接在另一个元素后面的<strong>兄弟元素</strong>。</li>
<li><strong>语法</strong>：<code>element + adjacent_element &#123; ... &#125;</code>，用 <code>+</code> 分隔。</li>
<li><strong>示例</strong>：<ul>
<li><code>h1 + p &#123; margin-top: 0; &#125;</code>：选中紧跟在 <code>&lt;h1&gt;</code> 后的第一个 <code>&lt;p&gt;</code> 元素。</li>
</ul>
</li>
</ul>
<h4 id="4-通用兄弟选择器-General-Sibling-Selector"><a href="#4-通用兄弟选择器-General-Sibling-Selector" class="headerlink" title="4. 通用兄弟选择器 (General Sibling Selector)"></a>4. 通用兄弟选择器 (General Sibling Selector)</h4><ul>
<li><strong>作用</strong>：选择某个元素后面<strong>所有</strong>的兄弟元素（不限于紧邻的）。</li>
<li><strong>语法</strong>：<code>element ~ sibling &#123; ... &#125;</code>，用 <code>~</code> 分隔。</li>
<li><strong>示例</strong>：<ul>
<li><code>h1 ~ p &#123; margin-top: 0; &#125;</code>：选中 <code>&lt;h1&gt;</code> 后的所有 <code>&lt;p&gt;</code> 元素。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三、属性选择器-Attribute-Selectors"><a href="#三、属性选择器-Attribute-Selectors" class="headerlink" title="三、属性选择器 (Attribute Selectors)"></a>三、属性选择器 (Attribute Selectors)</h3><p>这些选择器根据元素的属性及其值来选择元素。</p>
<ul>
<li><strong>[attribute]</strong>：选择具有该属性的元素。<ul>
<li><code>[title] &#123; ... &#125;</code>：选中所有具有 <code>title</code> 属性的元素。</li>
</ul>
</li>
<li><strong>[attribute&#x3D;”value”]</strong>：选择具有特定属性和值的元素。<ul>
<li><code>input[type=&quot;text&quot;] &#123; ... &#125;</code>：选中所有 <code>type</code> 属性值为 <code>text</code> 的 <code>&lt;input&gt;</code> 元素。</li>
</ul>
</li>
<li><strong>[attribute~&#x3D;”value”]</strong>：选择属性值中包含特定<strong>独立单词</strong>的元素。<ul>
<li><code>[class~=&quot;box&quot;] &#123; ... &#125;</code>：选中所有 <code>class</code> 属性中包含 <code>box</code> 这个独立单词的元素（如 <code>class=&quot;card box&quot;</code>）。</li>
</ul>
</li>
<li><strong>[attribute|&#x3D;”value”]</strong>：选择属性值以特定字符串开头（后跟连字符 <code>-</code>）的元素。<ul>
<li><code>[lang|=&quot;en&quot;] &#123; ... &#125;</code>：选中 <code>lang</code> 属性值为 <code>en</code> 或 <code>en-us</code> 等的元素。</li>
</ul>
</li>
<li><strong>[attribute^&#x3D;”value”]</strong>：选择属性值以特定字符串开头的元素。<ul>
<li><code>a[href^=&quot;https&quot;] &#123; ... &#125;</code>：选中所有 <code>href</code> 属性以 <code>https</code> 开头的 <code>&lt;a&gt;</code> 元素。</li>
</ul>
</li>
<li><strong>[attribute$&#x3D;”value”]</strong>：选择属性值以特定字符串结尾的元素。<ul>
<li><code>img[src$=&quot;.png&quot;] &#123; ... &#125;</code>：选中所有 <code>src</code> 属性以 <code>.png</code> 结尾的 <code>&lt;img&gt;</code> 元素。</li>
</ul>
</li>
<li><strong>[attribute*&#x3D;”value”]</strong>：选择属性值中包含特定字符串的元素。<ul>
<li><code>[title*=&quot;hello&quot;] &#123; ... &#125;</code>：选中所有 <code>title</code> 属性值中包含 <code>hello</code> 的元素。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四、伪类选择器-Pseudo-class-Selectors"><a href="#四、伪类选择器-Pseudo-class-Selectors" class="headerlink" title="四、伪类选择器 (Pseudo-class Selectors)"></a>四、伪类选择器 (Pseudo-class Selectors)</h3><p>伪类用于选择元素的<strong>特定状态</strong>。</p>
<ul>
<li><strong>a:link</strong>：未访问的链接。</li>
<li><strong>a:visited</strong>：已访问的链接。</li>
<li><strong>a:hover</strong>：鼠标悬停在元素上。</li>
<li><strong>a:active</strong>：元素被点击时。</li>
<li><strong>element:focus</strong>：元素获得焦点时（常用于表单）。</li>
<li><strong>:nth-child(n)</strong>：选择属于其父元素的第 n 个子元素。</li>
<li><strong>:first-child</strong>：选择属于其父元素的第一个子元素。</li>
<li><strong>:last-child</strong>：选择属于其父元素的最后一个子元素。</li>
<li><strong>:not(selector)</strong>：选择不匹配指定选择器的元素。</li>
<li><strong>:empty</strong>：选择没有子元素或文本内容的元素。</li>
</ul>
<hr>
<h3 id="五、伪元素选择器-Pseudo-element-Selectors"><a href="#五、伪元素选择器-Pseudo-element-Selectors" class="headerlink" title="五、伪元素选择器 (Pseudo-element Selectors)"></a>五、伪元素选择器 (Pseudo-element Selectors)</h3><p>伪元素用于选择元素的<strong>特定部分</strong>。</p>
<ul>
<li><strong>::first-line</strong>：选择元素的第一行。</li>
<li><strong>::first-letter</strong>：选择元素的首个字母。</li>
<li><strong>::before</strong>：在元素的内容前面插入生成的内容。</li>
<li><strong>::after</strong>：在元素的内容后面插入生成的内容。</li>
</ul>
<hr>
<h3 id="优先级与层叠"><a href="#优先级与层叠" class="headerlink" title="优先级与层叠"></a>优先级与层叠</h3><p>当多个选择器选中同一个元素并应用不同的样式时，浏览器会根据**优先级（Specificity）**来决定最终样式。</p>
<ul>
<li><strong>优先级计算</strong>：<ul>
<li><code>!important</code>：最高优先级。</li>
<li><strong>行内样式</strong>：1000</li>
<li><strong>ID 选择器</strong>：100</li>
<li><strong>类、属性、伪类选择器</strong>：10</li>
<li><strong>元素、伪元素选择器</strong>：1</li>
<li><strong>通用选择器</strong>：0</li>
</ul>
</li>
<li><strong>举例</strong>：<ul>
<li><code>p &#123; color: red; &#125;</code>（优先级 1）</li>
<li><code>.highlight &#123; color: blue; &#125;</code>（优先级 10）</li>
<li><code>#main p &#123; color: green; &#125;</code>（优先级 101）</li>
</ul>
</li>
</ul>
<p>在这个例子中，即使 <code>p</code> 的样式最先声明，但 <code>main p</code> 的优先级最高，因此 <code>&lt;p id=&quot;main&quot;&gt;</code> 的字体颜色最终会是绿色。</p>
<p>好的，让我们来全面、深入地介绍 Maven，并剖析一些关键细节以及面试中可能遇到的问题。</p>
<hr>
<h3 id="一、Maven-核心概念"><a href="#一、Maven-核心概念" class="headerlink" title="一、Maven 核心概念"></a>一、Maven 核心概念</h3><h4 id="1-什么是-Maven？"><a href="#1-什么是-Maven？" class="headerlink" title="1. 什么是 Maven？"></a>1. 什么是 Maven？</h4><p>Maven 是一个<strong>项目管理和构建自动化工具</strong>。它提供了一套标准化的项目结构、统一的构建生命周期，并依赖于一个<strong>中央仓库</strong>来管理项目所需的依赖。</p>
<p>它的核心思想是**“约定优于配置”（Convention over Configuration）**，这意味着它有一套默认的项目目录结构和构建流程。只要你遵循这些约定，就可以用很少的配置完成复杂的构建任务。</p>
<h4 id="2-为什么需要-Maven？"><a href="#2-为什么需要-Maven？" class="headerlink" title="2. 为什么需要 Maven？"></a>2. 为什么需要 Maven？</h4><p>在 Maven 出现之前，Java 项目的构建非常混乱：</p>
<ul>
<li><strong>项目结构不统一</strong>：每个项目都有自己的目录结构，新成员需要花时间熟悉。</li>
<li><strong>依赖管理混乱</strong>：需要手动下载所有 JAR 包，并添加到项目中，非常容易出错。</li>
<li><strong>构建过程不统一</strong>：编译、测试、打包等操作需要手动执行脚本，效率低下。</li>
</ul>
<p>Maven 通过<strong>标准化</strong>解决了这些问题：</p>
<ul>
<li><strong>标准化的项目结构</strong>：所有 Maven 项目都遵循相同的目录结构，如 <code>src/main/java</code>、<code>src/test/java</code> 等。</li>
<li><strong>统一的依赖管理</strong>：通过在 <code>pom.xml</code> 中声明依赖，Maven 会自动从仓库下载并管理。</li>
<li><strong>标准化的构建生命周期</strong>：定义了一系列标准的构建阶段（如 <code>compile</code>, <code>test</code>, <code>package</code>），可以一键执行。</li>
</ul>
<hr>
<h3 id="二、Maven-的核心组成部分"><a href="#二、Maven-的核心组成部分" class="headerlink" title="二、Maven 的核心组成部分"></a>二、Maven 的核心组成部分</h3><h4 id="1-POM-Project-Object-Model"><a href="#1-POM-Project-Object-Model" class="headerlink" title="1. POM (Project Object Model)"></a>1. POM (Project Object Model)</h4><ul>
<li><strong>概念</strong>：<code>pom.xml</code> 文件是 Maven 项目的<strong>核心配置文件</strong>。它定义了项目的元数据、依赖、插件、构建配置等所有信息。</li>
<li><strong>重要标签</strong>：<ul>
<li><code>&lt;project&gt;</code>：根元素。</li>
<li><code>&lt;groupId&gt;</code>, <code>&lt;artifactId&gt;</code>, <code>&lt;version&gt;</code>：项目的唯一标识符，通常称为 <strong>GAV 坐标</strong>。</li>
<li><code>&lt;packaging&gt;</code>：打包类型，如 <code>jar</code>, <code>war</code>, <code>pom</code>。</li>
<li><code>&lt;dependencies&gt;</code>：定义项目所需的依赖。</li>
<li><code>&lt;parent&gt;</code>：继承父 POM，实现依赖的统一管理。</li>
<li><code>&lt;build&gt;</code>：定义构建过程，如插件配置。</li>
</ul>
</li>
</ul>
<h4 id="2-依赖管理-Dependency-Management"><a href="#2-依赖管理-Dependency-Management" class="headerlink" title="2. 依赖管理 (Dependency Management)"></a>2. 依赖管理 (Dependency Management)</h4><ul>
<li><strong>概念</strong>：通过在 <code>&lt;dependencies&gt;</code> 中定义 GAV 坐标，Maven 会自动从本地或远程仓库下载依赖。</li>
<li><strong>传递性依赖</strong>：如果你的项目依赖 A，A 又依赖 B，Maven 会自动将 B 也下载下来。这是其强大的地方，但有时也可能导致版本冲突。</li>
<li><strong><dependencyManagement></strong>：这是一个非常重要的标签，通常在<strong>父 POM</strong> 中使用。它只定义依赖的版本，但<strong>不实际引入</strong>。子项目继承后，只需声明 <code>&lt;artifactId&gt;</code> 和 <code>&lt;groupId&gt;</code>，版本号会自动继承，这能确保整个项目所有模块的依赖版本一致。</li>
</ul>
<h4 id="3-仓库-Repositories"><a href="#3-仓库-Repositories" class="headerlink" title="3. 仓库 (Repositories)"></a>3. 仓库 (Repositories)</h4><p>Maven 仓库是用来存放所有依赖 JAR 包的地方。它分为三种：</p>
<ul>
<li><strong>本地仓库 (Local Repository)</strong>：<code>~/.m2/repository</code>，首次下载的依赖会存放在这里，后续构建时会优先从这里读取。</li>
<li><strong>远程仓库 (Remote Repository)</strong>：<ul>
<li><strong>中央仓库 (Central Repository)</strong>：Maven 官方维护的公共仓库，包含了绝大多数常用的开源库。</li>
<li><strong>私服 (Private Repository)</strong>：企业内部搭建的仓库，用于存放公司内部的 JAR 包或作为中央仓库的代理，加快下载速度。</li>
</ul>
</li>
</ul>
<h4 id="4-生命周期与阶段-Lifecycle-Phases"><a href="#4-生命周期与阶段-Lifecycle-Phases" class="headerlink" title="4. 生命周期与阶段 (Lifecycle &amp; Phases)"></a>4. 生命周期与阶段 (Lifecycle &amp; Phases)</h4><p>Maven 有一套标准的构建生命周期，分为三个：</p>
<ul>
<li><strong>clean</strong>：清理项目。<ul>
<li><code>clean</code>：删除 <code>target</code> 目录。</li>
</ul>
</li>
<li><strong>default</strong>：构建项目。<ul>
<li><code>validate</code></li>
<li><code>compile</code>：编译源代码。</li>
<li><code>test</code>：运行测试。</li>
<li><code>package</code>：打包。</li>
<li><code>install</code>：安装到本地仓库。</li>
<li><code>deploy</code>：部署到远程仓库。</li>
</ul>
</li>
<li><strong>site</strong>：生成项目站点。</li>
</ul>
<p><strong>重要规则</strong>：执行某个阶段时，它之前的所有阶段都会按顺序执行。例如，<code>mvn package</code> 会自动执行 <code>compile</code> 和 <code>test</code>。</p>
<hr>
<h3 id="三、面试常见问题与回答技巧"><a href="#三、面试常见问题与回答技巧" class="headerlink" title="三、面试常见问题与回答技巧"></a>三、面试常见问题与回答技巧</h3><h4 id="1-Maven-的-GAV-坐标是什么？有什么作用？"><a href="#1-Maven-的-GAV-坐标是什么？有什么作用？" class="headerlink" title="1. Maven 的 GAV 坐标是什么？有什么作用？"></a>1. Maven 的 GAV 坐标是什么？有什么作用？</h4><ul>
<li><strong>回答</strong>：GAV 坐标是 Maven 项目的唯一标识符，由 <code>&lt;groupId&gt;</code>, <code>&lt;artifactId&gt;</code>, 和 <code>&lt;version&gt;</code> 三个元素组成。</li>
<li><strong>作用</strong>：<ul>
<li><strong>唯一性</strong>：确保每个项目和每个版本的依赖在仓库中都是唯一的。</li>
<li><strong>定位</strong>：Maven 通过 GAV 坐标来查找和下载依赖。</li>
<li><strong>传递性</strong>：在传递性依赖中，通过 GAV 坐标来识别和处理依赖关系。</li>
</ul>
</li>
</ul>
<h4 id="2-和-有什么区别？"><a href="#2-和-有什么区别？" class="headerlink" title="2. &lt;dependencyManagement&gt; 和 &lt;dependencies&gt; 有什么区别？"></a>2. <code>&lt;dependencyManagement&gt;</code> 和 <code>&lt;dependencies&gt;</code> 有什么区别？</h4><ul>
<li><strong>回答</strong>：这是面试高频问题，需要清晰地说明两者的职责。</li>
<li><strong><dependencies></strong>：<strong>实际引入</strong>依赖。它用于在当前项目中添加一个具体的依赖，Maven 会立即下载并使用它。</li>
<li><strong><dependencyManagement></strong>：<strong>只定义版本</strong>。它只声明依赖的版本，但<strong>不实际引入</strong>。其主要目的是<strong>统一管理子模块的依赖版本</strong>。子模块继承父 POM 后，只需在自己的 <code>&lt;dependencies&gt;</code> 中声明 <code>&lt;groupId&gt;</code> 和 <code>&lt;artifactId&gt;</code>，版本号会自动从父 POM 中继承，这避免了版本不一致的问题。</li>
</ul>
<h4 id="3-什么是-Maven-的生命周期？mvn-install-和-mvn-deploy-有什么区别？"><a href="#3-什么是-Maven-的生命周期？mvn-install-和-mvn-deploy-有什么区别？" class="headerlink" title="3. 什么是 Maven 的生命周期？mvn install 和 mvn deploy 有什么区别？"></a>3. 什么是 Maven 的生命周期？<code>mvn install</code> 和 <code>mvn deploy</code> 有什么区别？</h4><ul>
<li><strong>回答</strong>：</li>
<li><strong>生命周期</strong>：Maven 有三个标准的生命周期：<code>clean</code>、<code>default</code> 和 <code>site</code>。其中 <code>default</code> 包含了从编译到部署的所有阶段。</li>
<li><strong>mvn install</strong>：执行 <code>default</code> 生命周期到 <code>install</code> 阶段。它会将项目打包，并安装到<strong>本地仓库</strong>。这样，其他本地项目就可以依赖这个包。</li>
<li><strong>mvn deploy</strong>：执行 <code>default</code> 生命周期到 <code>deploy</code> 阶段。它会将项目打包，并部署到<strong>远程仓库</strong>（私服或中央仓库）。这使得其他团队成员或项目可以从远程仓库获取并使用这个包。</li>
</ul>
<h4 id="4-Maven-依赖冲突如何解决？"><a href="#4-Maven-依赖冲突如何解决？" class="headerlink" title="4. Maven 依赖冲突如何解决？"></a>4. Maven 依赖冲突如何解决？</h4><ul>
<li><strong>回答</strong>：当多个依赖间接引入了同一个库的不同版本时，就会发生依赖冲突。</li>
<li><strong>解决策略</strong>：<ul>
<li><strong>依赖调解（Dependency Mediation）</strong>：Maven 的默认规则是“<strong>路径最短者优先</strong>”。即在依赖树中，路径最短的那个版本会被选中。</li>
<li><strong>手动排除（Exclusion）</strong>：如果默认规则不能解决问题，可以在 <code>&lt;dependency&gt;</code> 标签内使用 <code>&lt;exclusions&gt;</code> 标签手动排除有问题的传递性依赖。</li>
<li><strong>手动引入（Declaration）</strong>：在 <code>&lt;dependencies&gt;</code> 中明确声明需要使用的版本。Maven 的另一个规则是“<strong>最近声明者优先</strong>”，即如果两个依赖路径长度相同，先声明的那个会被使用。但更好的做法是直接在父 POM 的 <code>&lt;dependencyManagement&gt;</code> 中统一版本。</li>
</ul>
</li>
</ul>
<p>好的，我们来详细梳理你提供的这份关于会话技术的笔记，并按照你要求的逻辑，以一种更清晰、更专业的面试回答或技术讲解的方式进行重新组织和补充。</p>
<hr>
<h3 id="一、会话技术概述：解决-HTTP-无状态问题"><a href="#一、会话技术概述：解决-HTTP-无状态问题" class="headerlink" title="一、会话技术概述：解决 HTTP 无状态问题"></a>一、会话技术概述：解决 HTTP 无状态问题</h3><p>HTTP 协议本身是无状态的，它不记得上一次请求的任何信息。为了在多次请求之间共享数据并识别用户，引入了两种核心的会话技术：客户端会话（Cookie）和服务器端会话（Session）。</p>
<h3 id="二、客户端会话：Cookie"><a href="#二、客户端会话：Cookie" class="headerlink" title="二、客户端会话：Cookie"></a>二、客户端会话：Cookie</h3><p><strong>核心概念</strong>：Cookie 是服务器发送给浏览器并存储在客户端的一小段文本信息。浏览器在下次访问同一服务器时会自动将该 Cookie 携带在请求中。</p>
<h4 id="1-关于-Cookie-的几个常见问题"><a href="#1-关于-Cookie-的几个常见问题" class="headerlink" title="1. 关于 Cookie 的几个常见问题"></a>1. 关于 Cookie 的几个常见问题</h4><ul>
<li><strong>一次请求响应可以发送多个 Cookie 吗？</strong><ul>
<li><strong>回答</strong>：<strong>可以</strong>。服务器可以在一个响应中通过多个 <code>Set-Cookie</code> 响应头来设置多个 Cookie。浏览器会分别存储这些 Cookie，并在后续请求中将它们全部发送给服务器。</li>
</ul>
</li>
<li><strong>Cookie 支持中文传输吗？</strong><ul>
<li><strong>回答</strong>：<strong>在大多数现代服务器和浏览器中都支持。</strong> 在早期的 Servlet 容器（如 Tomcat 8.0 之前），Cookie 不能直接存储中文，需要手动进行 URL 编码（<code>URLEncoder</code>）和解码（<code>URLDecoder</code>）。<strong>在 Tomcat 8.0 及以后版本</strong>，容器默认支持 UTF-8 编码，可以直接存储中文。</li>
</ul>
</li>
<li><strong>Cookie 的过期时间如何设置？</strong><ul>
<li><strong>回答</strong>：通过 <code>response.addCookie(cookie)</code> 方法，并调用 <code>cookie.setMaxAge(int expiry)</code> 方法来设置。<ul>
<li><code>expiry &gt; 0</code>：表示 Cookie 将被<strong>持久化</strong>到客户端硬盘，有效期为 <code>expiry</code> 秒。即使浏览器关闭，Cookie 依然存在，直到过期。</li>
<li><code>expiry = 0</code>：表示<strong>立即删除</strong>该 Cookie。常用于退出登录功能。</li>
<li><code>expiry &lt; 0</code>：<strong>默认值</strong>。表示 Cookie 只在内存中存在，当<strong>浏览器关闭时</strong>，该 Cookie 就会被删除。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-Cookie-的特点"><a href="#2-Cookie-的特点" class="headerlink" title="2. Cookie 的特点"></a>2. Cookie 的特点</h4><ul>
<li><strong>存储位置</strong>：存储在客户端（浏览器）。</li>
<li><strong>大小限制</strong>：单个 Cookie 最大约 4KB。</li>
<li><strong>数量限制</strong>：一个服务器最多可以向一个浏览器保存 20 个 Cookie，一个浏览器最多可以保存 300 个 Cookie（这些是早期的规范，现代浏览器已放宽，但仍有限制）。</li>
<li><strong>安全性</strong>：数据以明文形式存储，且容易被用户修改，安全性较差。</li>
</ul>
<h4 id="3-Cookie-案例：获取上一次访问时间"><a href="#3-Cookie-案例：获取上一次访问时间" class="headerlink" title="3. Cookie 案例：获取上一次访问时间"></a>3. Cookie 案例：获取上一次访问时间</h4><p>这个案例是经典的 Cookie 用法。</p>
<ul>
<li><strong>首次访问</strong>：服务器接收请求，判断 Cookie 中没有记录上次访问时间。服务器创建一个新的 Cookie，存储当前时间，并将其发送给浏览器。</li>
<li><strong>再次访问</strong>：浏览器自动将上次存储的 Cookie 发送给服务器。服务器读取 Cookie，获取上次访问时间，并将其显示给用户。然后，服务器可以更新 Cookie 的时间，再次发送给浏览器。</li>
</ul>
<h3 id="三、服务器端会话：HttpSession"><a href="#三、服务器端会话：HttpSession" class="headerlink" title="三、服务器端会话：HttpSession"></a>三、服务器端会话：HttpSession</h3><p><strong>核心概念</strong>：Session 是服务器端为每个客户端创建的一个对象，用于在一次会话的多个请求之间存储和共享数据。</p>
<h4 id="1-Session-的快速使用"><a href="#1-Session-的快速使用" class="headerlink" title="1. Session 的快速使用"></a>1. Session 的快速使用</h4><ul>
<li><strong>获取对象</strong>：通过 <code>HttpServletRequest</code> 对象的 <code>getSession()</code> 方法来获取 <code>HttpSession</code> 对象。</li>
<li><strong>使用对象（域对象）</strong>：Session 是一个<strong>域对象</strong>，提供了以下方法：<ul>
<li><code>void setAttribute(String name, Object value)</code>：将数据以键值对形式存储到 Session 中。</li>
<li><code>Object getAttribute(String name)</code>：根据键名获取存储的数据。</li>
<li><code>void removeAttribute(String name)</code>：根据键名删除存储的数据。</li>
</ul>
</li>
</ul>
<h4 id="2-Session-的失效时间"><a href="#2-Session-的失效时间" class="headerlink" title="2. Session 的失效时间"></a>2. Session 的失效时间</h4><ul>
<li><p><strong>服务器关闭</strong>：当服务器关闭时，所有 Session 对象都会被销毁。</p>
</li>
<li><p><strong>手动失效</strong>：调用 <code>session.invalidate()</code> 方法，可以立即强制 Session 失效。常用于用户退出登录。</p>
</li>
<li><p><strong>默认失效时间</strong>：默认情况下，Session 有一个超时时间，通常是 30 分钟。如果客户端在 30 分钟内没有向服务器发送任何请求，Session 就会自动失效。这个时间可以在 <code>web.xml</code> 中配置。</p>
</li>
<li><p>对的 👍，在 **Java Web 应用（Servlet 容器，比如 Tomcat）**里，<code>Session</code> 的默认失效时间通常是 <strong>30 分钟</strong>。</p>
<p>要修改它，可以在 <code>web.xml</code> 中配置 <code>&lt;session-config&gt;</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- session 过期时间设置（单位：分钟） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>60<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>📌 说明：</p>
<ul>
<li><code>60</code> 表示 Session 在 <strong>60 分钟</strong>无请求时会自动失效。</li>
<li>默认值是 <strong>30</strong> 分钟，如果不配置，就走默认。</li>
<li>这个配置对所有用户 Session 都生效。</li>
</ul>
<h3 id="🔧-在代码里动态设置（单个-Session）"><a href="#🔧-在代码里动态设置（单个-Session）" class="headerlink" title="🔧 在代码里动态设置（单个 Session）"></a>🔧 在代码里动态设置（单个 Session）</h3><p>除了在 <code>web.xml</code> 里全局配置，还可以针对某个用户的 Session 动态修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">session.setMaxInactiveInterval(<span class="number">120</span> * <span class="number">60</span>); <span class="comment">// 单位：秒，这里是 2 小时</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔧-特殊情况"><a href="#🔧-特殊情况" class="headerlink" title="🔧 特殊情况"></a>🔧 特殊情况</h3><ul>
<li>如果 <code>session-timeout</code> 设置为 <strong>0</strong> → Session 永不超时（危险 ⚠️，容易导致内存泄露）。</li>
<li>如果设置为 <strong>负数</strong>（如 -1） → 表示 Session 仅在浏览器关闭时销毁（有些容器支持，有些不支持。</li>
</ul>
<h4 id="3-Session-的特点"><a href="#3-Session-的特点" class="headerlink" title="3. Session 的特点"></a>3. Session 的特点</h4><ul>
<li><strong>存储位置</strong>：存储在服务器端。</li>
<li><strong>大小限制</strong>：可以存储任意类型、任意大小的数据（受限于服务器内存）。</li>
<li><strong>安全性</strong>：由于数据存储在服务器，客户端只传递一个 Session ID，安全性相对较高。</li>
</ul>
<h4 id="4-面试题：Cookie-和-Session-的区别？"><a href="#4-面试题：Cookie-和-Session-的区别？" class="headerlink" title="4. 面试题：Cookie 和 Session 的区别？"></a>4. 面试题：Cookie 和 Session 的区别？</h4><ul>
<li><strong>存储位置</strong>：Cookie 存储在<strong>客户端</strong>，Session 存储在<strong>服务器端</strong>。</li>
<li><strong>数据大小</strong>：Cookie 的大小<strong>有限制</strong>（约 4KB），Session 的大小<strong>没有限制</strong>。</li>
<li><strong>安全性</strong>：Session <strong>相对安全</strong>，Cookie <strong>相对不安全</strong>。因为 Session ID 难以被猜测，而 Cookie 存储的数据是明文。</li>
<li><strong>服务器开销</strong>：Session 会占用服务器内存，在高并发场景下可能成为性能瓶颈；而 Cookie 不占用服务器资源。</li>
</ul>
<h3 id="四、Servlet-三大域对象的关系（按照你的逻辑）"><a href="#四、Servlet-三大域对象的关系（按照你的逻辑）" class="headerlink" title="四、Servlet 三大域对象的关系（按照你的逻辑）"></a>四、Servlet 三大域对象的关系（按照你的逻辑）</h3><p><strong>域对象</strong>（Scope Object）是指那些可以用来在不同组件之间共享数据的对象。Servlet 规范提供了三个这样的对象，它们的生命周期不同，从而决定了数据的共享范围。</p>
<ul>
<li><strong>request 域</strong>：生命周期最短。数据只能在<strong>一次请求-响应</strong>的周期内共享。即使请求被转发（forward），数据也依然可见。</li>
<li><strong>session 域</strong>：生命周期中等。数据可以在<strong>一次会话</strong>（多个请求）之间共享。只要浏览器不关闭，且 Session 未超时或失效，数据就一直存在。</li>
<li><strong>servletContext 域</strong>：生命周期最长。数据可以在<strong>整个 Web 应用</strong>中共享。从 Web 应用启动到关闭，数据都一直存在。</li>
</ul>
<p><strong>三大域对象之间的关系是包含关系，即 request &lt; session &lt; servletContext。</strong></p>
<ul>
<li><strong>request 包含于 session</strong>：一个 Session 中可以有多个请求。</li>
<li><strong>session 包含于 servletContext</strong>：一个 Web 应用（ServletContext）中可以有多个 Session。</li>
</ul>
<p>这个关系图清晰地展示了它们各自的生命周期和数据共享范围，是理解 Servlet 域对象的关键。</p>
<p>啊哈～你这个场景就是 <strong>同一个库的两个版本必须共存</strong>，典型的 “深度 JAR hell” 🚨。<br> 比如：</p>
<ul>
<li>你的系统用到 <strong>老版本 log4j</strong>，</li>
<li>但某个第三方库硬性依赖 <strong>新版本 log4j</strong>。</li>
</ul>
<p>这时候如果放到同一个 classpath 里，肯定会冲突。解决思路主要有三类：</p>
<hr>
<h2 id="✅-两个版本-JAR-共存的解决方案"><a href="#✅-两个版本-JAR-共存的解决方案" class="headerlink" title="✅ 两个版本 JAR 共存的解决方案"></a>✅ 两个版本 JAR 共存的解决方案</h2><h3 id="1-ClassLoader-隔离（推荐方式）"><a href="#1-ClassLoader-隔离（推荐方式）" class="headerlink" title="1. ClassLoader 隔离（推荐方式）"></a>1. <strong>ClassLoader 隔离</strong>（推荐方式）</h3><p>利用 <strong>不同的类加载器</strong> 来隔离两个版本的依赖，让它们互不干扰。</p>
<ul>
<li><p><strong>Web 容器隔离</strong>：</p>
<ul>
<li>把一个版本放在 <code>WEB-INF/lib</code>，另一个放在全局 <code>lib/ext</code>。</li>
<li>通过 parent-first &#x2F; parent-last 策略控制加载。</li>
</ul>
</li>
<li><p><strong>自定义 ClassLoader</strong>：</p>
<ul>
<li><p>用 <code>URLClassLoader</code> 指定不同版本 JAR 的路径。</p>
</li>
<li><p>哪个模块需要哪个版本，就用哪个 ClassLoader。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">URLClassLoader loaderV1 = new URLClassLoader(</span><br><span class="line">    new URL[]&#123; new File(&quot;lib/lib-old.jar&quot;).toURI().toURL() &#125;,</span><br><span class="line">    null // 不委托父加载器</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">URLClassLoader loaderV2 = new URLClassLoader(</span><br><span class="line">    new URL[]&#123; new File(&quot;lib/lib-new.jar&quot;).toURI().toURL() &#125;,</span><br><span class="line">    null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; clazz1 = loaderV1.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">Class&lt;?&gt; clazz2 = loaderV2.loadClass(&quot;com.example.MyClass&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>👉 OSGi、Spring Boot 的 <strong>ClassLoader 层级</strong>就是用这种方法解决多版本依赖的。</p>
<hr>
<h3 id="2-包重定位（Shading-Relocation）"><a href="#2-包重定位（Shading-Relocation）" class="headerlink" title="2. 包重定位（Shading &#x2F; Relocation）"></a>2. <strong>包重定位（Shading &#x2F; Relocation）</strong></h3><p>把其中一个版本的包路径 <strong>改名</strong>，让 JVM 认为它是完全不同的类库。</p>
<ul>
<li><p>工具：</p>
<ul>
<li><code>jarjar</code></li>
<li>Maven Shade（即使你不用 Maven，也可以单独跑插件）</li>
<li>Gradle Shadow</li>
</ul>
</li>
<li><p>原理：自动把 <code>org.apache.commons</code> 改成 <code>myproject.shaded.org.apache.commons</code>。</p>
</li>
<li><p>示例（JarJar 规则）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule org.apache.log4j.** com.myapp.shaded.log4j.@1</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样，项目就能同时用 <code>log4j-1.2</code> 和 <code>log4j-2.x</code>。</p>
<hr>
<h3 id="3-服务解耦-模块化"><a href="#3-服务解耦-模块化" class="headerlink" title="3. 服务解耦 &#x2F; 模块化"></a>3. <strong>服务解耦 &#x2F; 模块化</strong></h3><p>如果两个版本都要在 <strong>同一个 JVM 里用</strong>，但 ClassLoader 太麻烦：</p>
<ul>
<li><strong>拆分成微服务 &#x2F; 子进程</strong>，让不同进程使用不同版本的依赖。</li>
<li>或者在 <strong>Java 9+ 模块系统 (JPMS)</strong> 下，给不同模块声明不同依赖，避免直接冲突。</li>
</ul>
<hr>
<h2 id="🚀-实际建议"><a href="#🚀-实际建议" class="headerlink" title="🚀 实际建议"></a>🚀 实际建议</h2><ul>
<li>如果你是 <strong>自己开发的项目</strong> → 用 <strong>包重定位</strong> 比较简单。</li>
<li>如果是 <strong>插件式系统 &#x2F; 容器运行</strong> → 用 <strong>ClassLoader 隔离</strong>。</li>
<li>如果是 <strong>重量级系统</strong>（比如需要不同版本的 JDBC 驱动） → 拆进程更干净。</li>
</ul>
<hr>
<p>要不要我帮你写一个 <strong>最小可运行的 Java Demo</strong>（两个版本 JAR 同时运行，通过 ClassLoader 隔离）？这样你可以直接跑起来看看效果。</p>
<p>好的，我将根据您提供的这份详尽的笔记，以更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p>
<hr>
<h3 id="一、CSS-选择器概述：精准定位网页元素"><a href="#一、CSS-选择器概述：精准定位网页元素" class="headerlink" title="一、CSS 选择器概述：精准定位网页元素"></a>一、CSS 选择器概述：精准定位网页元素</h3><p><strong>选择器</strong>是 CSS 的核心，它用于<strong>精确地选择 HTML 文档中的元素</strong>，并为其应用样式。掌握不同类型的选择器及其组合，是高效编写 CSS 代码的关键。</p>
<h3 id="二、基础选择器-Basic-Selectors"><a href="#二、基础选择器-Basic-Selectors" class="headerlink" title="二、基础选择器 (Basic Selectors)"></a>二、基础选择器 (Basic Selectors)</h3><p>基础选择器用于根据最基本的属性（标签、类、ID）来选择元素。</p>
<h4 id="1-标签选择器-Type-Selector"><a href="#1-标签选择器-Type-Selector" class="headerlink" title="1. 标签选择器 (Type Selector)"></a>1. 标签选择器 (Type Selector)</h4><ul>
<li><p><strong>原理</strong>：根据元素的<strong>标签名称</strong>来匹配。</p>
</li>
<li><p><strong>优点</strong>：简单、直接，可以一次性选中所有同类型的元素。</p>
</li>
<li><p><strong>缺点</strong>：过于笼统，无法对个别元素进行精确控制。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123; color: red; &#125; /* 所有&lt;div&gt;标签的字体颜色都为红色 */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-类选择器-Class-Selector-1"><a href="#2-类选择器-Class-Selector-1" class="headerlink" title="2. 类选择器 (Class Selector)"></a>2. 类选择器 (Class Selector)</h4><ul>
<li><p><strong>原理</strong>：根据元素的 <code>class</code> 属性值来匹配。</p>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>高度复用</strong>：可以在多个元素上使用同一个类名。</li>
<li><strong>灵活</strong>：一个元素可以拥有多个类名，用空格分隔。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.cl1 &#123; color: red; &#125; /* 所有class属性包含cl1的元素，字体颜色为红色 */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-ID-选择器-ID-Selector-1"><a href="#3-ID-选择器-ID-Selector-1" class="headerlink" title="3. ID 选择器 (ID Selector)"></a>3. ID 选择器 (ID Selector)</h4><ul>
<li><p><strong>原理</strong>：根据元素的 <code>id</code> 属性值来匹配。</p>
</li>
<li><p><strong>优点</strong>：<strong>唯一性</strong>，精确地选中文档中唯一的元素。</p>
</li>
<li><p><strong>缺点</strong>：不具复用性，一个 ID 在文档中只能出现一次。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#p1 &#123; color: red; &#125; /* id为p1的唯一元素，字体颜色为红色 */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-通配符选择器-Universal-Selector"><a href="#4-通配符选择器-Universal-Selector" class="headerlink" title="4. 通配符选择器 (Universal Selector)"></a>4. 通配符选择器 (Universal Selector)</h4><ul>
<li><p><strong>原理</strong>：匹配文档中<strong>所有</strong>的元素。</p>
</li>
<li><p><strong>优点</strong>：可以快速设置全局样式，常用于重置浏览器默认样式。</p>
</li>
<li><p><strong>缺点</strong>：性能开销大，因为浏览器需要遍历所有元素，应谨慎使用。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123; margin: 0; padding: 0; &#125; /* 清除所有元素的内外边距 */</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="三、组合选择器-Combinators"><a href="#三、组合选择器-Combinators" class="headerlink" title="三、组合选择器 (Combinators)"></a>三、组合选择器 (Combinators)</h3><p>组合选择器通过符号连接多个选择器，根据元素之间的关系来匹配。</p>
<h4 id="1-交集选择器-Intersection-Selector"><a href="#1-交集选择器-Intersection-Selector" class="headerlink" title="1. 交集选择器 (Intersection Selector)"></a>1. 交集选择器 (Intersection Selector)</h4><ul>
<li><p><strong>原理</strong>：同时满足多个选择器条件的元素。</p>
</li>
<li><p><strong>语法</strong>：<code>selector1selector2 &#123; ... &#125;</code>，中间<strong>没有空格</strong>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.cl1 &#123; color: red; &#125; /* 既是&lt;div&gt;标签，又拥有cl1这个class的元素 */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-并集选择器-Union-Selector"><a href="#2-并集选择器-Union-Selector" class="headerlink" title="2. 并集选择器 (Union Selector)"></a>2. 并集选择器 (Union Selector)</h4><ul>
<li><p><strong>原理</strong>：匹配所有满足其中任意一个选择器条件的元素。</p>
</li>
<li><p><strong>语法</strong>：<code>selector1, selector2 &#123; ... &#125;</code>，以<strong>逗号</strong>分隔。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, p &#123; color: red; &#125; /* 所有&lt;a&gt;标签和所有&lt;p&gt;标签的字体颜色都为红色 */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-子选择器-Child-Selector"><a href="#3-子选择器-Child-Selector" class="headerlink" title="3. 子选择器 (Child Selector)"></a>3. 子选择器 (Child Selector)</h4><ul>
<li><p><strong>原理</strong>：匹配<strong>直接</strong>子元素。</p>
</li>
<li><p><strong>语法</strong>：<code>parent &gt; child &#123; ... &#125;</code>，以 <code>&gt;</code> 符号分隔。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#outer &gt; span &#123; color: red; &#125; /* 只选中id为outer的&lt;div&gt;的直接子元素&lt;span&gt; */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-后代选择器-Descendant-Selector"><a href="#4-后代选择器-Descendant-Selector" class="headerlink" title="4. 后代选择器 (Descendant Selector)"></a>4. 后代选择器 (Descendant Selector)</h4><ul>
<li><p><strong>原理</strong>：匹配所有位于祖先元素内部的<strong>所有后代</strong>元素。</p>
</li>
<li><p><strong>语法</strong>：<code>ancestor descendant &#123; ... &#125;</code>，以<strong>空格</strong>分隔。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#outer span &#123; color: red; &#125; /* 选中id为outer的&lt;div&gt;内部的所有&lt;span&gt;，无论嵌套多深 */</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="四、属性选择器-Attribute-Selectors"><a href="#四、属性选择器-Attribute-Selectors" class="headerlink" title="四、属性选择器 (Attribute Selectors)"></a>四、属性选择器 (Attribute Selectors)</h3><p>属性选择器根据元素的属性及其值来匹配。</p>
<ul>
<li><strong>[attribute]</strong>：匹配具有该属性的元素。<ul>
<li>示例：<code>[class]</code> 匹配所有具有 <code>class</code> 属性的元素。</li>
</ul>
</li>
<li><strong>[attribute&#x3D;”value”]</strong>：匹配属性值完全相等的元素。<ul>
<li>示例：<code>[type=&quot;text&quot;]</code> 匹配 <code>type</code> 属性值恰好为 <code>&quot;text&quot;</code> 的元素。</li>
</ul>
</li>
<li><strong>[attribute~&#x3D;”value”]</strong>：匹配属性值中包含该<strong>独立单词</strong>的元素。</li>
<li><strong>[attribute^&#x3D;”value”]</strong>：匹配属性值以该字符串<strong>开头</strong>的元素。</li>
<li><strong>[attribute$&#x3D;”value”]</strong>：匹配属性值以该字符串<strong>结尾</strong>的元素。</li>
<li><strong>[attribute*&#x3D;”value”]</strong>：匹配属性值中包含该字符串的<strong>任意位置</strong>的元素。</li>
</ul>
<hr>
<h3 id="五、伪类与伪元素选择器-Pseudo-class-Pseudo-element-Selectors"><a href="#五、伪类与伪元素选择器-Pseudo-class-Pseudo-element-Selectors" class="headerlink" title="五、伪类与伪元素选择器 (Pseudo-class &amp; Pseudo-element Selectors)"></a>五、伪类与伪元素选择器 (Pseudo-class &amp; Pseudo-element Selectors)</h3><ul>
<li><strong>伪类</strong>：用<strong>一个冒号 :</strong>，表示元素在<strong>特定状态</strong>下的样式。<ul>
<li><strong>:link</strong>：未访问的链接。</li>
<li><strong>:visited</strong>：已访问的链接。</li>
<li><strong>:hover</strong>：鼠标悬停状态。</li>
<li><strong>:active</strong>：被点击状态。</li>
<li><strong>:focus</strong>：获得焦点状态（常用于表单）。</li>
</ul>
</li>
<li><strong>伪元素</strong>：用<strong>两个冒号 ::</strong>，表示元素的<strong>特定部分</strong>。<ul>
<li><strong>::before</strong> 和 <strong>::after</strong>：在元素内容的前后插入内容。</li>
<li><strong>::first-line</strong>：元素的文本第一行。</li>
<li><strong>::first-letter</strong>：元素的文本第一个字母。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="六、选择器优先级-Specificity"><a href="#六、选择器优先级-Specificity" class="headerlink" title="六、选择器优先级 (Specificity)"></a>六、选择器优先级 (Specificity)</h3><p>这是 CSS 的核心机制，决定了当多个规则应用到同一个元素时，哪一个会生效。</p>
<ul>
<li><strong>计算规则</strong>：优先级由<strong>选择器的类型</strong>和<strong>数量</strong>决定。<ol>
<li><strong>行内样式</strong>：优先级最高，为 <code>1000</code>。</li>
<li><strong>ID 选择器</strong>：优先级为 <code>100</code>。</li>
<li><strong>类、属性、伪类选择器</strong>：优先级为 <code>10</code>。</li>
<li><strong>元素、伪元素选择器</strong>：优先级为 <code>1</code>。</li>
<li><strong>通用选择器 *</strong>：优先级为 <code>0</code>。</li>
</ol>
</li>
<li><strong>!important</strong>：最高优先级，但会破坏层叠机制，应<strong>避免使用</strong>。</li>
</ul>
<p>如何计算：</p>
<p>将每个选择器的优先级数字相加，得到一个最终的权重值。权重值越高的规则越优先。</p>
<ul>
<li>示例：<ul>
<li><code>p</code>：权重 <code>1</code>。</li>
<li><code>.cl1</code>：权重 <code>10</code>。</li>
<li><code>div.cl1</code>：权重 <code>1 + 10 = 11</code>。</li>
<li><code>#p1</code>：权重 <code>100</code>。</li>
<li><code>#outer span</code>：权重 <code>100 + 1 = 101</code>。</li>
</ul>
</li>
</ul>
<p><strong>!important</strong> 会凌驾于所有这些规则之上。当你遇到样式不生效的问题时，首先要检查优先级，其次是是否有 <code>!important</code> 的存在。</p>
<p>好的，让我们来详细、深入地解释 <strong>BOM</strong> 和 <strong>DOM</strong> 这两个 JavaScript 在浏览器中操作网页的核心概念。</p>
<hr>
<h3 id="BOM-Browser-Object-Model"><a href="#BOM-Browser-Object-Model" class="headerlink" title="BOM (Browser Object Model)"></a>BOM (Browser Object Model)</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p><strong>BOM</strong>，即<strong>浏览器对象模型</strong>，是 JavaScript 用于<strong>操作浏览器窗口</strong>的一套 API。它没有统一的标准，而是由各个浏览器厂商各自实现的。BOM 的核心是 <code>window</code> 对象，它既代表了浏览器窗口本身，也是 JavaScript 全局作用域的唯一对象。</p>
<h4 id="2-BOM-的核心对象与功能"><a href="#2-BOM-的核心对象与功能" class="headerlink" title="2. BOM 的核心对象与功能"></a>2. BOM 的核心对象与功能</h4><p>BOM 提供了以下关键对象，用于与浏览器进行交互：</p>
<ul>
<li><strong>window 对象</strong>：<ul>
<li><strong>全局对象</strong>：<code>window</code> 是 JavaScript 的全局对象，所有全局变量和函数都是 <code>window</code> 对象的属性和方法。</li>
<li><strong>窗口控制</strong>：<code>window.open()</code> (打开新窗口), <code>window.close()</code> (关闭当前窗口)。</li>
<li><strong>定时器</strong>：<code>setTimeout()</code> 和 <code>setInterval()</code>，用于延迟或重复执行代码。</li>
<li><strong>导航与位置</strong>：<code>window.location</code>，用于获取和修改当前页面的 URL。</li>
</ul>
</li>
<li><strong>location 对象</strong>：<ul>
<li><strong>URL 信息</strong>：提供了当前 URL 的详细信息，如 <code>location.href</code> (完整 URL), <code>location.protocol</code> (协议), <code>location.hostname</code> (主机名), <code>location.pathname</code> (路径)。</li>
<li><strong>页面跳转</strong>：<code>location.href = &#39;new_url&#39;</code> 或 <code>location.assign(&#39;new_url&#39;)</code> (有历史记录), <code>location.replace(&#39;new_url&#39;)</code> (不留历史记录), <code>location.reload()</code> (刷新页面)。</li>
</ul>
</li>
<li><strong>history 对象</strong>：<ul>
<li><strong>历史记录</strong>：提供了对浏览器历史记录的访问。</li>
<li><strong>导航</strong>：<code>history.back()</code> (后退), <code>history.forward()</code> (前进), <code>history.go(n)</code> (前进或后退 n 页)。</li>
</ul>
</li>
<li><strong>navigator 对象</strong>：<ul>
<li><strong>浏览器信息</strong>：提供了关于浏览器本身的信息，如 <code>navigator.userAgent</code> (用户代理字符串), <code>navigator.platform</code> (操作系统), <code>navigator.onLine</code> (是否在线)。</li>
</ul>
</li>
<li><strong>screen 对象</strong>：<ul>
<li><strong>屏幕信息</strong>：提供了关于用户屏幕的信息，如 <code>screen.width</code> (屏幕宽度), <code>screen.height</code> (屏幕高度)。</li>
</ul>
</li>
</ul>
<h4 id="3-BOM-的特点"><a href="#3-BOM-的特点" class="headerlink" title="3. BOM 的特点"></a>3. BOM 的特点</h4><ul>
<li><strong>没有标准</strong>：BOM 没有 W3C 的正式标准，不同浏览器可能在实现上存在差异。</li>
<li><strong>以 window 为核心</strong>：所有 BOM 对象都是 <code>window</code> 对象的属性。</li>
</ul>
<hr>
<h3 id="DOM-Document-Object-Model"><a href="#DOM-Document-Object-Model" class="headerlink" title="DOM (Document Object Model)"></a>DOM (Document Object Model)</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h4><p><strong>DOM</strong>，即<strong>文档对象模型</strong>，是 JavaScript 用于<strong>操作 HTML 或 XML 文档</strong>的一套 API。它将整个 HTML 文档解析为一个<strong>树形结构</strong>，每个 HTML 标签、属性和文本都成为了树中的一个节点（Node）。DOM 是一个由 W3C 制定的标准。</p>
<h4 id="2-DOM-的核心对象与功能"><a href="#2-DOM-的核心对象与功能" class="headerlink" title="2. DOM 的核心对象与功能"></a>2. DOM 的核心对象与功能</h4><p>DOM 的核心是 <code>document</code> 对象，它是整个文档的入口。</p>
<ul>
<li><strong>document 对象</strong>：<ul>
<li><strong>DOM 树的根节点</strong>：代表整个 HTML 文档。</li>
<li><strong>元素获取</strong>：提供了多种方法来获取页面上的元素：<ul>
<li><code>document.getElementById(&#39;id&#39;)</code>：通过 ID 获取单个元素。</li>
<li><code>document.getElementsByClassName(&#39;class&#39;)</code>：通过类名获取元素集合。</li>
<li><code>document.getElementsByTagName(&#39;tag&#39;)</code>：通过标签名获取元素集合。</li>
<li><code>document.querySelector(&#39;css_selector&#39;)</code>：通过 CSS 选择器获取第一个匹配的元素。</li>
<li><code>document.querySelectorAll(&#39;css_selector&#39;)</code>：通过 CSS 选择器获取所有匹配的元素。</li>
</ul>
</li>
</ul>
</li>
<li><strong>元素节点（Element Nodes）</strong>：<ul>
<li><strong>操作元素</strong>：提供了操作 HTML 元素的方法和属性：<ul>
<li><code>element.innerHTML</code>：获取或设置元素的 HTML 内容。</li>
<li><code>element.style.color</code>：修改元素的行内样式。</li>
<li><code>element.setAttribute(&#39;attr&#39;, &#39;val&#39;)</code>：设置元素的属性。</li>
<li><code>element.addEventListener(&#39;event&#39;, handler)</code>：添加事件监听器。</li>
</ul>
</li>
</ul>
</li>
<li><strong>DOM 树操作</strong>：<ul>
<li><strong>创建</strong>：<code>document.createElement(&#39;tag&#39;)</code> (创建新元素)。</li>
<li><strong>添加</strong>：<code>parent.appendChild(child)</code> (添加子元素)。</li>
<li><strong>删除</strong>：<code>parent.removeChild(child)</code> (删除子元素)。</li>
<li><strong>替换</strong>：<code>parent.replaceChild(newChild, oldChild)</code> (替换子元素)。</li>
</ul>
</li>
</ul>
<h4 id="3-DOM-的特点"><a href="#3-DOM-的特点" class="headerlink" title="3. DOM 的特点"></a>3. DOM 的特点</h4><ul>
<li><strong>有标准</strong>：DOM 是由 W3C 制定的标准，因此在不同浏览器中的实现差异较小。</li>
<li><strong>树形结构</strong>：将 HTML 文档抽象为树形结构，使得我们可以通过编程的方式像操作树一样操作网页。</li>
</ul>
<hr>
<h3 id="BOM-和-DOM-的核心区别与联系"><a href="#BOM-和-DOM-的核心区别与联系" class="headerlink" title="BOM 和 DOM 的核心区别与联系"></a>BOM 和 DOM 的核心区别与联系</h3><table>
<thead>
<tr>
<th>特性</th>
<th>BOM (Browser Object Model)</th>
<th>DOM (Document Object Model)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>主要功能</strong></td>
<td><strong>操作浏览器窗口</strong></td>
<td><strong>操作网页文档内容</strong></td>
</tr>
<tr>
<td><strong>核心对象</strong></td>
<td><code>window</code></td>
<td><code>document</code></td>
</tr>
<tr>
<td><strong>标准化</strong></td>
<td>无统一标准（各浏览器实现不同）</td>
<td>有 W3C 标准</td>
</tr>
<tr>
<td><strong>层级关系</strong></td>
<td><code>window</code> 包含了 <code>location</code>, <code>history</code>, <code>navigator</code> 等，<strong>也包含了 document 对象</strong>。</td>
<td><code>document</code> 包含了 HTML 元素的树形结构。</td>
</tr>
</tbody></table>
<p>它们的关系：</p>
<p>BOM 是 DOM 的超集。window 对象是所有 JavaScript 对象的全局对象，它包含了 document 对象。换句话说，window.document 就是 document。因此，当我们使用 document 对象来操作网页时，实际上是通过 window 对象来访问的。</p>
<p>这个关系可以理解为：</p>
<p>window -&gt; 浏览器窗口</p>
<p>document -&gt; 窗口中加载的文档</p>
<p>掌握 BOM 和 DOM 是成为一个合格前端工程师的基础，它们是 JavaScript 驱动 Web 页面交互的两个最重要的工具。</p>
<p>好的，我将根据您提供的这份 JS 学习笔记，以一种更深入、更条理化的方式，逐一进行详细的展开和补充。这不仅是对知识点的梳理，也包含了其背后的原理和一些进阶用法，使其更具面试和实战价值。</p>
<hr>
<h3 id="一、JavaScript-中的数据类型"><a href="#一、JavaScript-中的数据类型" class="headerlink" title="一、JavaScript 中的数据类型"></a>一、JavaScript 中的数据类型</h3><h4 id="1-基础数据类型（原始数据类型）"><a href="#1-基础数据类型（原始数据类型）" class="headerlink" title="1. 基础数据类型（原始数据类型）"></a>1. 基础数据类型（原始数据类型）</h4><ul>
<li><p><strong>number 类型</strong>：</p>
<ul>
<li><strong>深入</strong>：JS 采用 IEEE 754 标准的双精度 64 位浮点数来表示所有数字。这意味着它<strong>没有单独的整数类型</strong>，所有数字都是浮点数。</li>
<li><code>NaN</code> (Not a Number)：表示非数字值。需要注意的是，<code>typeof NaN</code> 结果是 <code>number</code>。<code>NaN</code> 不等于自身，<code>NaN === NaN</code> 结果为 <code>false</code>。</li>
<li><code>Infinity</code>：表示正无穷大，<code>+Infinity</code> 和 <code>-Infinity</code> 分别表示正负无穷大。</li>
<li><code>0.1 + 0.2 !== 0.3</code>：由于浮点数表示的精度问题，这个经典问题需要注意。</li>
</ul>
</li>
<li><p><strong>boolean 类型</strong>：</p>
<ul>
<li><strong>深入</strong>：<code>true</code> 和 <code>false</code>。在条件判断中，所有数据类型都会被隐式转换为布尔值。</li>
</ul>
</li>
<li><p><strong>undefined 类型</strong>：</p>
<ul>
<li><strong>深入</strong>：表示一个<strong>未定义</strong>的变量或变量<strong>未被赋值</strong>。<code>typeof undefined</code> 结果为 <code>undefined</code>。它是一个值也是一个类型。</li>
<li><code>null</code>：与 <code>undefined</code> 的区别在于，<code>null</code> 是一种<strong>意图</strong>，表示变量被显式地赋予了“空”值。<code>typeof null</code> 结果为 <code>object</code>，这是一个历史遗留的 bug。</li>
</ul>
</li>
<li><p><strong>string 类型</strong>：</p>
<ul>
<li><p><strong>深入</strong>：JS 中<strong>没有字符类型</strong>。字符串是不可变的，一旦创建就不能修改。</p>
</li>
<li><p><strong>反引号（     ）</strong>：ES6 引入，支持<strong>模板字面量</strong>。它允许在字符串中嵌入变量和表达式，并支持多行书写，极大提升了字符串拼接的便利性。</p>
<p>JavaScript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = &quot;张三&quot;;</span><br><span class="line">console.log(`你好，我的名字是$&#123;name&#125;。`);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-数据类型转换"><a href="#2-数据类型转换" class="headerlink" title="2. 数据类型转换"></a>2. 数据类型转换</h4><ul>
<li><p><strong>转换为 number</strong>：<code>Number(value)</code></p>
<ul>
<li><strong>深入</strong>：会尝试将参数转换为数字。非数字字符串会返回 <code>NaN</code>。<code>null</code> 转为 <code>0</code>，<code>undefined</code> 转为 <code>NaN</code>。</li>
</ul>
</li>
<li><p><strong>转换为 boolean</strong>：<code>Boolean(value)</code></p>
<ul>
<li><strong>深入</strong>：所有能被转换为 <code>false</code> 的值被称为<strong>假值（Falsy Value）</strong>。</li>
<li><strong>假值列表</strong>：<code>0</code>, <code>-0</code>, <code>null</code>, <code>false</code>, <code>NaN</code>, <code>undefined</code>, <code>&#39;&#39;</code> (空字符串)。</li>
<li><strong>真值（Truthy Value）</strong>：除上述假值外，所有值都是真值，包括空数组 <code>[]</code> 和空对象 <code>&#123;&#125;</code>。</li>
</ul>
</li>
<li><p><strong>转换为 string</strong>：<code>String(value)</code> 或 <code>value + &#39;&#39;</code></p>
<ul>
<li><strong>深入</strong>：<code>value + &#39;&#39;</code> 是最常用的技巧，利用了 JS 的隐式类型转换。</li>
</ul>
</li>
<li><p><strong>parseInt 和 parseFloat</strong>：</p>
<ul>
<li><p><strong>深入</strong>：这两个函数专门用于从<strong>字符串开头</strong>解析出数字。</p>
</li>
<li><p><code>parseInt</code>：解析<strong>整数</strong>。遇到第一个非数字字符就停止解析。</p>
<p>JavaScript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&quot;100px&quot;); // 100</span><br><span class="line">parseInt(&quot;a100&quot;);  // NaN</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>parseFloat</code>：解析<strong>浮点数</strong>。遇到第一个非数字字符（除了小数点）就停止解析。</p>
</li>
</ul>
</li>
</ul>
<h3 id="二、JavaScript-中的弹出框"><a href="#二、JavaScript-中的弹出框" class="headerlink" title="二、JavaScript 中的弹出框"></a>二、JavaScript 中的弹出框</h3><p>这些是浏览器提供的 BOM API。</p>
<ul>
<li><code>alert(message)</code>：<strong>警告框</strong>。阻塞式，显示一条消息，不返回任何值。</li>
<li><code>prompt(message, default_value)</code>：<strong>询问框</strong>。返回用户输入的字符串，如果点击“取消”则返回 <code>null</code>。</li>
<li><code>confirm(message)</code>：<strong>确认框</strong>。返回一个布尔值，用户点击“确定”返回 <code>true</code>，点击“取消”返回 <code>false</code>。</li>
</ul>
<h3 id="三、条件运算符：-和"><a href="#三、条件运算符：-和" class="headerlink" title="三、条件运算符：== 和 ==="></a>三、条件运算符：<code>==</code> 和 <code>===</code></h3><ul>
<li><p><strong>&#x3D;&#x3D;（宽松相等）</strong>：只比较<strong>值</strong>，不比较类型。它在比较前会进行<strong>隐式类型转换</strong>。</p>
<p>JavaScript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 == &quot;5&quot;;     // true</span><br><span class="line">null == undefined; // true</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x3D;&#x3D;&#x3D;（严格相等）</strong>：既比较<strong>值</strong>，也比较<strong>类型</strong>。不会进行类型转换。</p>
<p>JavaScript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 === &quot;5&quot;;    // false</span><br><span class="line">null === undefined; // false</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>面试建议</strong>：在实际开发中，<strong>强烈建议使用 &#x3D;&#x3D;&#x3D;</strong>，以避免不必要的类型转换带来的 bug。</p>
</li>
</ul>
<h3 id="四、字符串和数组"><a href="#四、字符串和数组" class="headerlink" title="四、字符串和数组"></a>四、字符串和数组</h3><ul>
<li><strong>字符串</strong>：<ul>
<li><strong>深入</strong>：<code>string</code> 是一个<strong>对象</strong>，拥有 <code>length</code> 属性和许多方法（如 <code>split()</code>, <code>slice()</code>, <code>indexOf()</code> 等），但它<strong>不可变</strong>。</li>
</ul>
</li>
<li><strong>数组</strong>：<ul>
<li><strong>特点</strong>：<ol>
<li><strong>动态长度</strong>：JS 数组的长度是可变的，你可以随时添加或删除元素。</li>
<li><strong>异构性</strong>：一个数组可以存放不同数据类型的元素，如 <code>[1, &quot;hello&quot;, true]</code>。</li>
</ol>
</li>
<li><strong>方法</strong>：<ul>
<li><code>push()</code>, <code>pop()</code>：在数组<strong>末尾</strong>添加和删除。</li>
<li><code>unshift()</code>, <code>shift()</code>：在数组<strong>开头</strong>添加和删除。</li>
<li><code>splice()</code>：功能强大的方法，用于删除、替换或添加元素。</li>
<li><code>forEach()</code>, <code>map()</code>, <code>filter()</code>：常用的遍历方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="五、函数和对象"><a href="#五、函数和对象" class="headerlink" title="五、函数和对象"></a>五、函数和对象</h3><ul>
<li><strong>函数</strong>：<ul>
<li><strong>深入</strong>：在 JS 中，函数是<strong>一等公民（First-Class Citizens）</strong>。这意味着函数可以作为参数传递、作为返回值，也可以赋值给变量。</li>
</ul>
</li>
<li><strong>对象</strong>：<ul>
<li><strong>深入</strong>：JS 对象是<strong>键值对</strong>的集合。键是字符串，值可以是任意类型。</li>
<li><strong>访问属性</strong>：<ul>
<li>点语法：<code>obj.prop</code>。</li>
<li>中括号语法：<code>obj[&#39;prop&#39;]</code>。后者适用于键名包含特殊字符或动态键名的情况。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="六、定时器"><a href="#六、定时器" class="headerlink" title="六、定时器"></a>六、定时器</h3><ul>
<li><strong>setTimeout(callback, delay)</strong>：<ul>
<li><strong>用途</strong>：只执行<strong>一次</strong>。</li>
<li><strong>深入</strong>：<code>delay</code> 参数是<strong>最小延迟时间</strong>。由于 JS 是单线程的，如果主线程被阻塞，<code>callback</code> 的执行会延迟。</li>
</ul>
</li>
<li><strong>setInterval(callback, delay)</strong>：<ul>
<li><strong>用途</strong>：<strong>重复</strong>执行。</li>
<li><strong>深入</strong>：每次执行完回调函数后，<code>setInterval</code> 都会将下一个回调任务放入队列。</li>
</ul>
</li>
</ul>
<h3 id="七、ES6-新特性（重要）"><a href="#七、ES6-新特性（重要）" class="headerlink" title="七、ES6 新特性（重要）"></a>七、ES6 新特性（重要）</h3><ul>
<li><strong>let 和 const</strong>：<ul>
<li><strong>var 的问题</strong>：全局作用域，可以被重复声明，有变量提升。</li>
<li><strong>let</strong>：<strong>块级作用域</strong>（<code>&#123;&#125;</code> 内），不能重复声明，没有变量提升。</li>
<li><strong>const</strong>：<strong>块级作用域</strong>，用于声明<strong>常量</strong>。一旦声明，其引用地址不能改变。</li>
</ul>
</li>
<li><strong>字符串模板字面量</strong>：使用反引号（<code>     </code>）创建多行字符串和嵌入变量。</li>
<li><strong>箭头函数</strong>：<ul>
<li><strong>语法</strong>：<code>const func = (param) =&gt; &#123; ... &#125;</code>。</li>
<li><strong>this 指向</strong>：箭头函数<strong>没有自己的 this</strong>，它会捕获其所在上下文的 <code>this</code> 值。这解决了传统函数中 <code>this</code> 绑定复杂的问题。</li>
</ul>
</li>
<li><strong>可变参数</strong>：<code>...args</code>，用于函数接收不确定数量的参数。</li>
</ul>
<h3 id="八、DOM"><a href="#八、DOM" class="headerlink" title="八、DOM"></a>八、DOM</h3><ul>
<li><strong>什么是 DOM</strong>：<ul>
<li><strong>深入</strong>：DOM 是浏览器将 HTML 文档解析后生成的<strong>树形结构</strong>，是 JavaScript 操作网页的接口。HTML 文件是文本，DOM 是一个对象，可以被 JS 编程控制。</li>
</ul>
</li>
<li><strong>DOM 操作</strong>：<ul>
<li><strong>获取标签对象</strong>：<ul>
<li><code>document.getElementById()</code></li>
<li><code>document.getElementsByClassName()</code></li>
<li><code>document.querySelector()</code> (更常用)</li>
</ul>
</li>
<li><strong>操作属性</strong>：<ul>
<li><code>element.attribute = &#39;...&#39;</code> (例如 <code>element.style.color = &#39;red&#39;</code>)</li>
<li><code>element.setAttribute(&#39;attr&#39;, &#39;value&#39;)</code></li>
</ul>
</li>
<li><strong>操作内容</strong>：<ul>
<li><code>element.innerHTML</code>：获取或设置元素的 HTML 内容（包括子标签）。</li>
<li><code>element.textContent</code>：获取或设置元素的文本内容（不含 HTML）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>好的，我将根据您提供的这份详尽的 Web 技术笔记，以一种更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p>
<hr>
<h3 id="一、Web-架构与网络基础"><a href="#一、Web-架构与网络基础" class="headerlink" title="一、Web 架构与网络基础"></a>一、Web 架构与网络基础</h3><h4 id="1-常见的软件架构"><a href="#1-常见的软件架构" class="headerlink" title="1. 常见的软件架构"></a>1. 常见的软件架构</h4><ul>
<li><strong>B&#x2F;S 架构 (Browser&#x2F;Server)</strong>：<ul>
<li><strong>概念</strong>：浏览器和服务器架构。客户端只需安装一个通用的浏览器，业务逻辑和数据都存储在服务器端。</li>
<li><strong>优点</strong>：易于维护和升级，跨平台性好。</li>
<li><strong>缺点</strong>：对网络依赖性强，用户体验可能不如 C&#x2F;S 架构。</li>
</ul>
</li>
<li><strong>C&#x2F;S 架构 (Client&#x2F;Server)</strong>：<ul>
<li><strong>概念</strong>：客户端和服务器架构。客户端需要安装专用的应用程序，例如桌面 QQ、微信等。</li>
<li><strong>优点</strong>：用户体验好，响应速度快，可以离线使用。</li>
<li><strong>缺点</strong>：维护和升级复杂，需要为不同平台开发不同版本。</li>
</ul>
</li>
</ul>
<h4 id="2-网络编程三要素"><a href="#2-网络编程三要素" class="headerlink" title="2. 网络编程三要素"></a>2. 网络编程三要素</h4><p>这是所有网络通信的基础，理解这三点至关重要。</p>
<ul>
<li><strong>IP 地址</strong>：设备在网络上的唯一标识，类似于你的家庭住址。它用于在网络中定位到一台具体的计算机。</li>
<li><strong>端口号</strong>：应用程序在计算机上的唯一标识，类似于你家里的电话号码或门牌号。一台计算机上可以运行多个应用程序，端口号用于区分它们。</li>
<li><strong>协议</strong>：通信规则。就像人与人交流需要遵循共同的语言一样，网络设备之间通信也需要遵循特定的协议，如 HTTP、FTP、TCP 等。</li>
</ul>
<h4 id="3-资源的分类"><a href="#3-资源的分类" class="headerlink" title="3. 资源的分类"></a>3. 资源的分类</h4><ul>
<li><strong>静态资源</strong>：<ul>
<li><strong>特点</strong>：内容固定，无需服务器端处理，可由浏览器直接解析。</li>
<li><strong>原理</strong>：当浏览器请求静态资源时，Web 服务器直接从文件系统中读取文件并返回。</li>
<li><strong>示例</strong>：HTML、CSS、JS、图片等。</li>
</ul>
</li>
<li><strong>动态资源</strong>：<ul>
<li><strong>特点</strong>：内容动态生成，需要服务器端处理后才能返回给浏览器。</li>
<li><strong>原理</strong>：当浏览器请求动态资源时，Web 服务器将请求交给<strong>后台程序</strong>（如 Servlet 容器），后台程序执行业务逻辑，生成静态内容（如 HTML、JSON 等），然后返回给服务器，服务器再返回给浏览器。</li>
<li><strong>示例</strong>：Servlet、JSP、PHP、ASP 等。</li>
</ul>
</li>
</ul>
<h3 id="二、Web-服务器"><a href="#二、Web-服务器" class="headerlink" title="二、Web 服务器"></a>二、Web 服务器</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>Web 服务器（也称为 <strong>Web 容器</strong>）是一个软件，它负责处理 HTTP 请求，并提供静态资源和动态资源。它为动态资源（如 Servlet）提供了一个运行环境。</p>
<h4 id="2-常见的-Web-服务器"><a href="#2-常见的-Web-服务器" class="headerlink" title="2. 常见的 Web 服务器"></a>2. 常见的 Web 服务器</h4><ul>
<li><strong>Tomcat</strong>：Apache 基金组织开发，<strong>中小型的 JavaEE 服务器</strong>，<strong>免费</strong>且开源。它是一个<strong>Servlet 容器</strong>，能够运行 Servlet 和 JSP。</li>
<li><strong>WebSphere</strong>：IBM 公司开发，<strong>大型的 JavaEE 服务器</strong>，<strong>收费</strong>。功能强大，支持完整的 JavaEE 规范。</li>
<li><strong>WebLogic</strong>：Oracle 公司开发，<strong>大型的 JavaEE 服务器</strong>，<strong>收费</strong>。</li>
<li><strong>JBoss&#x2F;WildFly</strong>：开源，但其商业版收费。</li>
</ul>
<h3 id="三、Tomcat-的使用与配置"><a href="#三、Tomcat-的使用与配置" class="headerlink" title="三、Tomcat 的使用与配置"></a>三、Tomcat 的使用与配置</h3><ul>
<li><strong>安装与启动</strong>：Tomcat 是免安装的，解压即可。启动前需要配置 <code>JAVA_HOME</code> 环境变量。启动后，默认监听 <code>8080</code> 端口。</li>
<li><strong>端口号修改</strong>：<ul>
<li><strong>面试题</strong>：修改 Tomcat 端口号在哪个文件？</li>
<li><strong>回答</strong>：在 Tomcat 的 <code>conf</code> 目录下的 <code>server.xml</code> 文件中，修改 <code>&lt;Connector&gt;</code> 标签的 <code>port</code> 属性。</li>
<li><strong>注意</strong>：HTTP 协议的默认端口号是 <code>80</code>。如果将 Tomcat 端口号改为 <code>80</code>，那么访问时就可以省略端口号，例如 <code>http://localhost/</code>。</li>
</ul>
</li>
<li><strong>项目部署</strong>：<ul>
<li><strong>静态项目</strong>：将 HTML、CSS、JS 等文件直接放到 <code>webapps</code> 目录下的文件夹中。</li>
<li><strong>动态项目</strong>：将包含 <code>WEB-INF</code> 文件夹的整个项目目录放到 <code>webapps</code> 目录下。</li>
<li><strong>WEB-INF</strong>：这是动态项目的核心目录，具有特殊作用，外部无法直接通过 URL 访问该目录下的资源，保证了项目的安全性。<ul>
<li><code>classes</code>：存放所有编译后的 <code>.class</code> 字节码文件。</li>
<li><code>lib</code>：存放项目依赖的第三方 <code>.jar</code> 包。</li>
<li><code>web.xml</code>：Web 项目的<strong>核心配置文件</strong>，用于配置 Servlet、监听器、过滤器等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四、Servlet-深入解析"><a href="#四、Servlet-深入解析" class="headerlink" title="四、Servlet 深入解析"></a>四、Servlet 深入解析</h3><h4 id="1-Servlet-的概念和本质"><a href="#1-Servlet-的概念和本质" class="headerlink" title="1. Servlet 的概念和本质"></a>1. Servlet 的概念和本质</h4><ul>
<li><strong>概念</strong>：Servlet 是运行在服务器端的 Java 程序，用于处理客户端请求并生成动态响应。它不是一个独立的程序，<strong>必须部署到支持 Servlet 的容器中</strong>（如 Tomcat）才能运行。</li>
<li><strong>本质</strong>：Servlet 的本质是一个<strong>接口</strong>。所有自定义的 Servlet 类都必须<strong>实现 javax.servlet.Servlet 接口</strong>。</li>
</ul>
<h4 id="2-Servlet-的执行原理（详细解释）"><a href="#2-Servlet-的执行原理（详细解释）" class="headerlink" title="2. Servlet 的执行原理（详细解释）"></a>2. Servlet 的执行原理（详细解释）</h4><p>这是一个非常重要的面试点，需要从请求-响应的整个流程来详细阐述。</p>
<ol>
<li><strong>客户端请求</strong>：用户在浏览器中输入 URL，向服务器发送一个 HTTP 请求。</li>
<li><strong>Web 服务器接收请求</strong>：Web 服务器（Tomcat）接收到这个请求。</li>
<li><strong>Servlet 容器处理</strong>：Tomcat 会根据请求 URL，在 <code>web.xml</code> 或通过注解（如 <code>@WebServlet</code>）查找匹配的 Servlet。</li>
<li><strong>Servlet 实例创建</strong>：<ul>
<li>如果是<strong>第一次</strong>访问该 Servlet，Servlet 容器会创建一个该 Servlet 的实例。</li>
<li><strong>面试点</strong>：Servlet 是<strong>单例的</strong>，一个 Servlet 在容器中只会被创建一次。</li>
</ul>
</li>
<li><strong>init() 方法执行</strong>：<ul>
<li>在 Servlet 实例创建后，容器会立即调用它的 <code>init()</code> 方法。</li>
<li><code>init()</code> 方法只在 Servlet 的<strong>生命周期中执行一次</strong>，用于完成一些初始化工作，如加载配置文件、数据库连接等。</li>
</ul>
</li>
<li><strong>service() 方法执行</strong>：<ul>
<li>每次客户端请求该 Servlet 时，容器都会调用它的 <code>service()</code> 方法。</li>
<li><code>service()</code> 方法根据请求的 HTTP 方法（GET、POST 等），将请求分发给相应的 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li>
<li><strong>面试点</strong>：<code>service()</code> 方法是处理请求的核心方法，它是<strong>多线程的</strong>，每个请求都会在新线程中执行 <code>service()</code> 方法。</li>
</ul>
</li>
<li><strong>destroy() 方法执行</strong>：<ul>
<li>当 Servlet 容器关闭，或者决定卸载该 Servlet 时，会调用其 <code>destroy()</code> 方法。</li>
<li><code>destroy()</code> 方法也只执行一次，用于释放资源，如关闭数据库连接池。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：Servlet 的生命周期是：<strong>创建实例</strong> -&gt; <strong>调用 init()</strong> (只一次) -&gt; <strong>调用 service()</strong> (多次) -&gt; <strong>调用 destroy()</strong> (只一次) -&gt; <strong>销毁实例</strong>。</p>
<p>好的，我们来将“网络编程三要素”这一部分进行更深入、更详细的展开，并补充常见应用的默认端口号，使其更具实用性和面试价值。</p>
<hr>
<h3 id="一、网络编程三要素：深入解析"><a href="#一、网络编程三要素：深入解析" class="headerlink" title="一、网络编程三要素：深入解析"></a>一、网络编程三要素：深入解析</h3><p>网络编程的本质就是让不同的计算机上的应用程序能够进行通信。要实现这一点，必须解决三个核心问题：</p>
<ol>
<li><strong>找到对方计算机</strong>：IP 地址</li>
<li><strong>找到对方计算机上的应用程序</strong>：端口号</li>
<li><strong>以什么样的规则进行通信</strong>：协议</li>
</ol>
<p>这三者缺一不可。</p>
<h4 id="1-IP-地址-Internet-Protocol-Address"><a href="#1-IP-地址-Internet-Protocol-Address" class="headerlink" title="1. IP 地址 (Internet Protocol Address)"></a>1. IP 地址 (Internet Protocol Address)</h4><ul>
<li><strong>概念</strong>：IP 地址是分配给连接到网络中的设备（如计算机、手机、服务器）的一串数字标识。</li>
<li><strong>作用</strong>：它用于<strong>唯一地标识网络上的一个设备</strong>。数据包在网络中传输时，就是根据 IP 地址来路由和寻址的。</li>
<li><strong>版本</strong>：<ul>
<li><strong>IPv4</strong>：由 32 位二进制数组成，通常表示为四个十进制数，用点分隔（例如 <code>192.168.1.1</code>）。由于地址资源枯竭，现在已经不够用。</li>
<li><strong>IPv6</strong>：由 128 位二进制数组成，地址空间巨大，足以满足未来需求。</li>
</ul>
</li>
<li><strong>类型</strong>：<ul>
<li><strong>公网 IP</strong>：在互联网上是唯一的，可以直接访问。</li>
<li><strong>内网 IP</strong>：在局域网内是唯一的，不能直接在互联网上访问。例如 <code>192.168.x.x</code>、<code>10.x.x.x</code>。</li>
</ul>
</li>
</ul>
<h4 id="2-端口号-Port-Number"><a href="#2-端口号-Port-Number" class="headerlink" title="2. 端口号 (Port Number)"></a>2. 端口号 (Port Number)</h4><ul>
<li><strong>概念</strong>：端口号是用于<strong>区分一台计算机上不同应用程序</strong>的数字标识。它的范围是从 <code>0</code> 到 <code>65535</code>。</li>
<li><strong>作用</strong>：当一个数据包到达一台计算机时，操作系统会检查其目的端口号，然后将数据包交给监听该端口号的相应应用程序。</li>
<li><strong>与 IP 地址的关系</strong>：IP 地址解决了“数据包发送到哪台计算机”的问题，而端口号则解决了“数据包发送到这台计算机上的哪个应用程序”的问题。两者结合起来才能唯一确定一个网络连接的端点。</li>
</ul>
<h4 id="3-协议-Protocol"><a href="#3-协议-Protocol" class="headerlink" title="3. 协议 (Protocol)"></a>3. 协议 (Protocol)</h4><ul>
<li><strong>概念</strong>：协议是网络通信中<strong>数据传输的规则和约定</strong>。它定义了数据如何打包、传输、路由和接收。</li>
<li><strong>作用</strong>：确保通信双方能够理解彼此发送的数据。没有协议，数据包就是一堆无意义的字节。</li>
<li><strong>分层</strong>：网络协议通常是分层的，最经典的是 <strong>TCP&#x2F;IP 协议栈</strong>。<ul>
<li><strong>应用层</strong>：<strong>决定数据内容</strong>，如 HTTP、FTP、SMTP。</li>
<li><strong>传输层</strong>：<strong>决定数据如何传输</strong>，如 TCP 和 UDP。<ul>
<li><strong>TCP (Transmission Control Protocol)</strong>：面向连接、可靠、有序。适用于对数据完整性要求高的场景，如文件传输、网页浏览。</li>
<li><strong>UDP (User Datagram Protocol)</strong>：无连接、不可靠、速度快。适用于对实时性要求高的场景，如在线视频、游戏。</li>
</ul>
</li>
<li><strong>网络层</strong>：<strong>决定数据如何路由</strong>，如 IP 协议。</li>
<li><strong>数据链路层&#x2F;物理层</strong>：负责物理设备的通信。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、常见应用的默认端口号"><a href="#二、常见应用的默认端口号" class="headerlink" title="二、常见应用的默认端口号"></a>二、常见应用的默认端口号</h3><p>了解这些默认端口号，可以帮助你更好地理解网络协议和服务。</p>
<ul>
<li><strong>Web 服务</strong><ul>
<li><strong>HTTP</strong> (HyperText Transfer Protocol)：<strong>80</strong></li>
<li><strong>HTTPS</strong> (HTTP Secure)：<strong>443</strong></li>
<li><strong>Tomcat</strong> (默认)：<strong>8080</strong></li>
<li><strong>WebLogic</strong> (默认)：<strong>7001</strong></li>
</ul>
</li>
<li><strong>文件传输</strong><ul>
<li><strong>FTP</strong> (File Transfer Protocol)：<strong>21</strong> (控制连接)</li>
<li><strong>SFTP</strong> (SSH File Transfer Protocol)：<strong>22</strong></li>
</ul>
</li>
<li><strong>远程登录与管理</strong><ul>
<li><strong>SSH</strong> (Secure Shell)：<strong>22</strong></li>
<li><strong>Telnet</strong>：<strong>23</strong></li>
<li><strong>RDP</strong> (Remote Desktop Protocol)：<strong>3389</strong></li>
</ul>
</li>
<li><strong>数据库服务</strong><ul>
<li><strong>MySQL</strong>：<strong>3306</strong></li>
<li><strong>PostgreSQL</strong>：<strong>5432</strong></li>
<li><strong>SQL Server</strong>：<strong>1433</strong></li>
<li><strong>Oracle</strong>：<strong>1521</strong></li>
</ul>
</li>
<li><strong>邮件服务</strong><ul>
<li><strong>SMTP</strong> (Simple Mail Transfer Protocol)：<strong>25</strong> (发送邮件)</li>
<li><strong>POP3</strong> (Post Office Protocol 3)：<strong>110</strong> (接收邮件)</li>
<li><strong>IMAP</strong> (Internet Message Access Protocol)：<strong>143</strong> (接收邮件)</li>
</ul>
</li>
<li><strong>其他常见服务</strong><ul>
<li><strong>DNS</strong> (Domain Name System)：<strong>53</strong></li>
<li><strong>Redis</strong>：<strong>6379</strong></li>
<li><strong>MongoDB</strong>：<strong>27017</strong></li>
<li><strong>Kafka</strong>：<strong>9092</strong></li>
</ul>
</li>
</ul>
<p>为什么需要默认端口号？</p>
<p>为了方便用户。当你在浏览器中访问 <a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a> 时，你不需要手动输入 <a href="http://www.example.com:80，因为浏览器知道">www.example.com:80，因为浏览器知道</a> HTTP 协议的默认端口就是 80。如果服务器的端口不是默认端口，你就必须手动指定，比如 <a href="http://www.example.com:8080。">www.example.com:8080。</a></p>
<p>好的，我将根据您提供的这份详尽的 Web 技术笔记，以一种更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p>
<hr>
<h3 id="一、Servlet-剩余部分"><a href="#一、Servlet-剩余部分" class="headerlink" title="一、Servlet 剩余部分"></a>一、Servlet 剩余部分</h3><h4 id="1-Servlet-的生命周期方法"><a href="#1-Servlet-的生命周期方法" class="headerlink" title="1. Servlet 的生命周期方法"></a>1. Servlet 的生命周期方法</h4><p>这是理解 Servlet 工作原理的核心。</p>
<ul>
<li><strong>init() 方法</strong>：<ul>
<li><strong>特点</strong>：只执行<strong>一次</strong>，用于初始化 Servlet 实例。</li>
<li><strong>执行时机</strong>：<ul>
<li><strong>默认（懒加载）</strong>：第一次被访问时执行。这是一种“按需加载”的策略，节省了服务器启动时的资源。</li>
<li><strong>预加载</strong>：可以在 <code>web.xml</code> 中通过 <code>&lt;load-on-startup&gt;</code> 标签来设置。如果值为非负整数（<code>0</code>或正数），Servlet 容器将在服务器启动时立即创建并初始化该 Servlet。这适用于需要立即提供服务、启动耗时较长的 Servlet。</li>
</ul>
</li>
</ul>
</li>
<li><strong>service() 方法</strong>：<ul>
<li><strong>特点</strong>：每次客户端请求该 Servlet 时，都会执行一次。</li>
<li><strong>原理</strong>：它是 Servlet 接口的核心方法，用于处理请求。对于 <code>HttpServlet</code> 来说，它会根据 HTTP 请求方法（GET、POST 等）来分发请求给相应的 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li>
<li><strong>重要性</strong>：<strong>service() 方法是多线程的</strong>。Servlet 容器会为每个请求创建一个新线程来执行 <code>service()</code> 方法，确保并发访问时互不影响。</li>
</ul>
</li>
<li><strong>destroy() 方法</strong>：<ul>
<li><strong>特点</strong>：只执行<strong>一次</strong>，在 Servlet 实例正常销毁时调用。</li>
<li><strong>执行时机</strong>：通常在 Web 应用关闭或 Servlet 容器关闭时。用于释放资源，如关闭数据库连接、文件句柄等。</li>
</ul>
</li>
</ul>
<h4 id="2-Servlet-的实现方式：XML-vs-注解"><a href="#2-Servlet-的实现方式：XML-vs-注解" class="headerlink" title="2. Servlet 的实现方式：XML vs. 注解"></a>2. Servlet 的实现方式：XML vs. 注解</h4><ul>
<li><p><strong>XML 配置方式</strong>：在 <code>web.xml</code> 文件中，通过 <code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code> 标签来配置 Servlet 的名称、类和访问路径。这是 Servlet 2.x 及以前版本的主流方式。</p>
</li>
<li><p><strong>注解方式</strong>：自 Servlet 3.0 开始引入，可以使用 <code>@WebServlet</code> 注解来代替 XML 配置。</p>
<ul>
<li><strong>优点</strong>：简化了配置，代码和配置更集中，提高了开发效率。</li>
<li><strong>示例</strong>：</li>
</ul>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;/demo&quot;)</span><br><span class="line">public class MyServlet extends HttpServlet &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-Servlet-的体系结构"><a href="#3-Servlet-的体系结构" class="headerlink" title="3. Servlet 的体系结构"></a>3. Servlet 的体系结构</h4><ul>
<li><code>Servlet</code> <strong>接口</strong>：所有 Servlet 的顶层接口，定义了 <code>init()</code>, <code>service()</code>, <code>destroy()</code> 等核心方法。</li>
<li><code>GenericServlet</code> <strong>抽象类</strong>：实现了 <code>Servlet</code> 接口，并提供了 <code>init()</code>, <code>destroy()</code> 的空实现，以及一些通用方法。开发者可以继承它来编写协议无关的 Servlet。</li>
<li><code>HttpServlet</code> <strong>抽象类</strong>：继承自 <code>GenericServlet</code>，专门用于处理 <strong>HTTP 请求</strong>。它重写了 <code>service()</code> 方法，并根据请求方法分发给 <code>doGet()</code>, <code>doPost()</code> 等具体方法。</li>
<li><strong>总结</strong>：在 Web 项目中，我们几乎总是处理 HTTP 请求，因此<strong>继承 HttpServlet 是最常用、最推荐的方式</strong>。</li>
</ul>
<hr>
<h3 id="二、HTTP-协议"><a href="#二、HTTP-协议" class="headerlink" title="二、HTTP 协议"></a>二、HTTP 协议</h3><h4 id="1-概念与特点"><a href="#1-概念与特点" class="headerlink" title="1. 概念与特点"></a>1. 概念与特点</h4><ul>
<li><strong>概念</strong>：<strong>超文本传输协议</strong>，是 Web 应用层协议，基于 TCP&#x2F;IP。它规定了客户端和服务器之间的通信格式。</li>
<li><strong>特点</strong>：<ul>
<li><strong>基于 TCP&#x2F;IP</strong>：它位于 TCP&#x2F;IP 协议栈的应用层，利用了 TCP 的可靠传输特性。</li>
<li><strong>请求&#x2F;响应模型</strong>：客户端发送请求，服务器返回响应，一次请求只对应一次响应。</li>
<li><strong>无状态</strong>：这是 HTTP 的核心特征。服务器不保留任何关于客户端过去请求的信息。每个请求都是独立的。</li>
<li><strong>无状态带来的问题</strong>：服务器无法识别多个请求是否来自同一个用户，因此需要引入<strong>会话技术</strong>（如 Cookie 和 Session）来解决。</li>
</ul>
</li>
</ul>
<h4 id="2-HTTP-协议的数据格式"><a href="#2-HTTP-协议的数据格式" class="headerlink" title="2. HTTP 协议的数据格式"></a>2. HTTP 协议的数据格式</h4><p>HTTP 协议是文本格式，由<strong>请求格式</strong>和<strong>响应格式</strong>两部分组成。</p>
<ul>
<li><strong>请求格式</strong>：<ol>
<li><strong>请求行</strong>：<code>请求方式 虚拟路径/资源路径[?参数] 请求协议/版本</code>。</li>
<li><strong>请求头</strong>：键值对形式，提供额外信息。<ul>
<li><code>Host</code>：目标主机名。</li>
<li><code>User-Agent</code>：浏览器类型和版本。</li>
<li><code>Referer</code>：请求来源地址，常用于防盗链。</li>
</ul>
</li>
<li><strong>请求空行</strong>：一个空行，用于分隔请求头和请求体。</li>
<li><strong>请求体</strong>：<strong>只有 POST 请求才有</strong>，用于封装请求参数。</li>
</ol>
</li>
</ul>
<h4 id="3-ServletRequest-对象"><a href="#3-ServletRequest-对象" class="headerlink" title="3. ServletRequest 对象"></a>3. <code>ServletRequest</code> 对象</h4><p><code>ServletRequest</code> 是 Servlet 容器在接收到请求后，封装请求信息的对象。</p>
<ul>
<li><strong>获取请求行信息</strong>：<ul>
<li><code>getMethod()</code>：获取请求方式（GET&#x2F;POST）。</li>
<li><code>getContextPath()</code>：获取虚拟路径。</li>
<li><code>getRequestURI()</code>：获取 URI，如 <code>/web02/demo4</code>。</li>
<li><code>getRequestURL()</code>：获取 URL，如 <code>http://localhost:8080/web02/demo4</code>。</li>
</ul>
</li>
<li><strong>获取请求头信息</strong>：<ul>
<li><code>getHeader(name)</code>：根据请求头名获取值。</li>
<li><code>getHeaderNames()</code>：获取所有请求头名。</li>
</ul>
</li>
<li><strong>获取请求体信息</strong>：<ul>
<li><code>getReader()</code> (字符流) 和 <code>getInputStream()</code> (字节流)，用于读取 POST 请求的请求体内容。</li>
</ul>
</li>
<li><strong>获取请求参数（通用）</strong>：<ul>
<li><code>getParameter(name)</code>：获取单个参数值。</li>
<li><code>getParameterValues(name)</code>：获取参数值数组，用于复选框等。</li>
</ul>
</li>
<li><strong>中文乱码</strong>：<ul>
<li><strong>GET 请求</strong>：在 Tomcat 8.x 及以后版本，默认已解决。</li>
<li><strong>POST 请求</strong>：需要手动设置编码，<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code>。</li>
</ul>
</li>
</ul>
<h4 id="4-request-请求转发"><a href="#4-request-请求转发" class="headerlink" title="4. request 请求转发"></a>4. <code>request</code> 请求转发</h4><ul>
<li><strong>概念</strong>：是一种<strong>服务器内部</strong>的资源跳转方式。请求从一个 Servlet 转发到另一个 Servlet 或 JSP，<strong>浏览器地址栏不会发生改变</strong>。</li>
<li><strong>特点</strong>：<ol>
<li><strong>地址栏不变</strong>：用户不知道发生了跳转。</li>
<li><strong>一次请求&#x2F;响应</strong>：整个转发过程发生在一次 HTTP 请求和一次 HTTP 响应中。</li>
<li><strong>共享数据</strong>：由于是同一次请求，<code>request</code> 对象中的数据在转发前后是共享的。</li>
</ol>
</li>
</ul>
<h4 id="5-request-作为域对象"><a href="#5-request-作为域对象" class="headerlink" title="5. request 作为域对象"></a>5. <code>request</code> 作为域对象</h4><ul>
<li><strong>概念</strong>：<code>request</code> 是一种<strong>域对象</strong>，其作用范围是<strong>一次请求-响应的生命周期</strong>。</li>
<li><strong>共享数据</strong>：可以使用 <code>setAttribute()</code>, <code>getAttribute()</code>, <code>removeAttribute()</code> 方法在这次请求的生命周期内共享数据。</li>
<li><strong>应用场景</strong>：常用于在 Servlet 和 JSP 之间传递数据。</li>
<li><strong>与会话技术的联系</strong>：<code>request</code> 是三大域对象（<code>request</code>, <code>session</code>, <code>servletContext</code>）中作用范围最小的一个。</li>
</ul>
<p>好的，我将根据您提供的这份详尽的 Web 技术笔记，以一种更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p>
<hr>
<h3 id="一、HTTP-协议的响应格式"><a href="#一、HTTP-协议的响应格式" class="headerlink" title="一、HTTP 协议的响应格式"></a>一、HTTP 协议的响应格式</h3><h4 id="1-响应格式组成"><a href="#1-响应格式组成" class="headerlink" title="1. 响应格式组成"></a>1. 响应格式组成</h4><p>HTTP 响应格式由四部分组成：<code>响应行</code>、<code>响应头</code>、<code>响应空行</code>、<code>响应体</code>。这与 HTTP 请求格式相呼应。</p>
<h4 id="2-响应行"><a href="#2-响应行" class="headerlink" title="2. 响应行"></a>2. 响应行</h4><ul>
<li><strong>格式</strong>：<code>协议/版本号 状态码 状态描述</code>。例如：<code>HTTP/1.1 200 OK</code>。</li>
<li><strong>状态码</strong>：一个三位数的数字，服务器用于告诉浏览器本次响应的状态。<ul>
<li><strong>2xx 成功</strong>：<ul>
<li><strong>200 OK</strong>：请求成功，一切正常。</li>
</ul>
</li>
<li><strong>3xx 重定向</strong>：<ul>
<li><strong>302 Found</strong>：重定向。服务器告诉浏览器，资源临时移动到另一个位置，请重新发起请求。</li>
<li><strong>304 Not Modified</strong>：访问缓存。服务器告诉浏览器，请求的资源没有更新，可以使用浏览器本地的缓存副本。</li>
</ul>
</li>
<li><strong>4xx 客户端错误</strong>：<ul>
<li><strong>404 Not Found</strong>：找不到资源。请求的路径没有对应的资源。</li>
<li><strong>405 Method Not Allowed</strong>：请求方法不被允许。例如，客户端用 POST 请求访问了只支持 GET 方法的 Servlet。</li>
</ul>
</li>
<li><strong>5xx 服务器端错误</strong>：<ul>
<li><strong>500 Internal Server Error</strong>：服务器内部错误。通常是服务器端的代码出现了异常。</li>
</ul>
</li>
</ul>
</li>
<li><strong>面试题</strong>：列举 5 个常见的状态码：200、302、304、404、405、500。</li>
</ul>
<h4 id="3-响应头"><a href="#3-响应头" class="headerlink" title="3. 响应头"></a>3. 响应头</h4><ul>
<li><strong>作用</strong>：以键值对形式提供关于响应的额外信息。</li>
<li><strong>常见响应头</strong>：<ul>
<li><strong>Content-Type</strong>：告诉浏览器响应体的数据类型和字符编码，例如 <code>text/html;charset=utf-8</code>。</li>
<li><strong>Content-disposition</strong>：<ul>
<li><strong>inline</strong> (默认)：浏览器在当前页面内直接打开。</li>
<li><strong>attachment;filename&#x3D;xxx</strong>：浏览器将数据作为附件下载。</li>
</ul>
</li>
<li><strong>Location</strong>：与 <code>3xx</code> 状态码配合使用，用于告诉浏览器重定向到哪个 URL。</li>
</ul>
</li>
</ul>
<h3 id="二、ServletResponse-response"><a href="#二、ServletResponse-response" class="headerlink" title="二、ServletResponse (response)"></a>二、ServletResponse (response)</h3><ul>
<li><strong>简介</strong>：<code>ServletResponse</code> 对象由 Tomcat 创建，封装了服务器发送给客户端的响应消息。</li>
<li><strong>相关方法</strong>：<ul>
<li><strong>设置响应行</strong>：<code>setStatus(int sc)</code></li>
<li><strong>设置响应头</strong>：<code>setHeader(String name, String value)</code></li>
<li><strong>设置响应体</strong>：<ul>
<li><code>getWriter()</code>：获取字符输出流，用于发送<strong>文本</strong>数据。</li>
<li><code>getOutputStream()</code>：获取字节输出流，用于发送<strong>字节</strong>数据（如图片、视频）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三、转发（Forward）和重定向（Redirect）的区别"><a href="#三、转发（Forward）和重定向（Redirect）的区别" class="headerlink" title="三、转发（Forward）和重定向（Redirect）的区别"></a>三、转发（Forward）和重定向（Redirect）的区别</h3><p>这是一个非常重要的面试题，需要从多个角度进行对比。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>转发（Forward）</th>
<th>重定向（Redirect）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>发生方</strong></td>
<td>服务器内部</td>
<td>浏览器</td>
</tr>
<tr>
<td><strong>地址栏</strong></td>
<td><strong>不变</strong></td>
<td><strong>会改变</strong></td>
</tr>
<tr>
<td><strong>请求次数</strong></td>
<td><strong>一次</strong>请求，一次响应</td>
<td><strong>两次</strong>请求，两次响应</td>
</tr>
<tr>
<td><strong>共享数据</strong></td>
<td><code>request</code> 对象共享数据</td>
<td><code>request</code> 对象不共享数据</td>
</tr>
<tr>
<td><strong>跳转范围</strong></td>
<td><strong>只能</strong>在当前 Web 项目内部</td>
<td>可以跳出项目，访问外部资源</td>
</tr>
<tr>
<td><strong>调用方</strong></td>
<td><code>RequestDispatcher</code> (<code>request</code>)</td>
<td><code>ServletResponse</code> (<code>response</code>)</td>
</tr>
<tr>
<td><strong>底层实现</strong></td>
<td><code>request.getRequestDispatcher().forward()</code></td>
<td><code>response.sendRedirect()</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>重定向的实现原理</strong>：<ol>
<li>服务器收到请求，执行 <code>response.sendRedirect()</code>，并发送 <code>302</code> 状态码和 <code>Location</code> 响应头（值为新的 URL）。</li>
<li>浏览器收到响应，解析到 <code>302</code> 和 <code>Location</code> 头后，会<strong>自动</strong>向新的 URL 发起<strong>第二次</strong>请求。</li>
</ol>
</li>
</ul>
<h3 id="四、ServletContext"><a href="#四、ServletContext" class="headerlink" title="四、ServletContext"></a>四、ServletContext</h3><h4 id="1-简介与特点"><a href="#1-简介与特点" class="headerlink" title="1. 简介与特点"></a>1. 简介与特点</h4><ul>
<li><strong>作用</strong>：代表<strong>整个 Web 应用</strong>。可以用来和服务器容器进行通信。</li>
<li><strong>特点</strong>：<ul>
<li><strong>单例</strong>：一个 Web 应用只有一个 <code>ServletContext</code> 对象。</li>
<li><strong>作用域</strong>：是<strong>最大的域对象</strong>，其作用范围是整个 Web 应用，从应用启动到关闭。</li>
</ul>
</li>
</ul>
<h4 id="2-获取-ServletContext-对象"><a href="#2-获取-ServletContext-对象" class="headerlink" title="2. 获取 ServletContext 对象"></a>2. 获取 <code>ServletContext</code> 对象</h4><ul>
<li><strong>通过 request</strong>：<code>request.getServletContext()</code></li>
<li><strong>通过 HttpServlet</strong>：<code>getServletContext()</code></li>
</ul>
<h4 id="3-ServletContext-的方法"><a href="#3-ServletContext-的方法" class="headerlink" title="3. ServletContext 的方法"></a>3. <code>ServletContext</code> 的方法</h4><ul>
<li><strong>获取文件 MIME 类型</strong>：<code>getMimeType(String file)</code>，返回文件的类型，如 <code>image/jpeg</code>。</li>
<li><strong>作为域对象</strong>：提供了 <code>setAttribute()</code>, <code>getAttribute()</code>, <code>removeAttribute()</code> 方法，用于在整个 Web 应用范围内共享数据。<ul>
<li><strong>示例</strong>：您提供的代码片段完美地展示了如何使用 <code>ServletContext</code> 来统计服务器的访问次数。这是 <code>ServletContext</code> 作为域对象最经典的用法。</li>
</ul>
</li>
<li><strong>获取文件真实路径</strong>：<code>getRealPath(String path)</code>，将相对路径转换为服务器上的绝对路径。</li>
</ul>
<h3 id="五、会话（Session）"><a href="#五、会话（Session）" class="headerlink" title="五、会话（Session）"></a>五、会话（Session）</h3><h4 id="1-概念与作用"><a href="#1-概念与作用" class="headerlink" title="1. 概念与作用"></a>1. 概念与作用</h4><ul>
<li><strong>概念</strong>：在 HTTP 协议的无状态特性基础上，通过会话技术将多次请求和响应联系起来，形成一个完整的会话。</li>
<li><strong>作用</strong>：在一次会话范围内的多次请求之间<strong>共享数据</strong>，从而识别用户。</li>
<li><strong>实现方式</strong>：<ul>
<li><strong>客户端会话（Cookie）</strong>：数据存储在客户端浏览器。</li>
<li><strong>服务器端会话（Session）</strong>：数据存储在服务器端。</li>
</ul>
</li>
</ul>
<h4 id="2-客户端会话：Cookie"><a href="#2-客户端会话：Cookie" class="headerlink" title="2. 客户端会话：Cookie"></a>2. 客户端会话：Cookie</h4><ul>
<li><strong>快速开始</strong>：<ol>
<li><strong>创建</strong>：<code>new Cookie(name, value)</code>。</li>
<li><strong>发送</strong>：<code>response.addCookie(cookie)</code>，将 Cookie 发送给浏览器。</li>
<li><strong>获取</strong>：<code>request.getCookies()</code>，从请求中获取所有 Cookie。</li>
</ol>
</li>
<li><strong>特点</strong>：数据存储在客户端，有大小限制，安全性低。</li>
</ul>
<p>这是一个非常好的问题，它触及了 Web 开发中一个容易混淆但至关重要的概念。<code>enctype</code> 和 <code>Content-Type</code> 确实有相似之处，但它们的作用域和角色是完全不同的。</p>
<p>让我来详细解释一下它们的区别：</p>
<hr>
<h3 id="一、enctype"><a href="#一、enctype" class="headerlink" title="一、enctype"></a>一、<code>enctype</code></h3><ul>
<li><strong>作用域</strong>：HTML <code>&lt;form&gt;</code> 标签的属性。</li>
<li><strong>角色</strong>：客户端<strong>表单的编码方式</strong>。</li>
<li><strong>概念</strong>：<code>enctype</code> (Encoding Type) 告诉<strong>浏览器</strong>如何将 <code>&lt;form&gt;</code> 表单中的数据<strong>编码</strong>成 HTTP 请求体中的数据。它只作用于<strong>表单提交</strong>这个行为。</li>
<li><strong>常见值</strong>：<ul>
<li><code>application/x-www-form-urlencoded</code>：默认值，用于文本数据。</li>
<li><code>multipart/form-data</code>：用于文件上传。</li>
<li><code>text/plain</code>：用于纯文本提交。</li>
</ul>
</li>
</ul>
<p><strong>简单来说，enctype 是“表单数据在浏览器端如何打包”的规则。</strong></p>
<h3 id="二、Content-Type"><a href="#二、Content-Type" class="headerlink" title="二、Content-Type"></a>二、<code>Content-Type</code></h3><ul>
<li><strong>作用域</strong>：HTTP 请求头或响应头。</li>
<li><strong>角色</strong>：<strong>通信数据的媒体类型</strong>。</li>
<li><strong>概念</strong>：<code>Content-Type</code> 告诉接收方（服务器或浏览器）请求体或响应体中的<strong>数据是什么格式</strong>。它是一个通用的 HTTP 头部，不仅限于表单提交。</li>
<li><strong>常见值</strong>：<ul>
<li><code>text/html</code>：HTML 文档。</li>
<li><code>application/json</code>：JSON 格式数据。</li>
<li><code>image/jpeg</code>：JPEG 图片。</li>
<li><code>application/xml</code>：XML 文档。</li>
<li><code>text/plain</code>：纯文本。</li>
</ul>
</li>
</ul>
<p><strong>简单来说，Content-Type 是“我发送给你的数据是什么类型”的声明。</strong></p>
<h3 id="三、核心区别与联系"><a href="#三、核心区别与联系" class="headerlink" title="三、核心区别与联系"></a>三、核心区别与联系</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>enctype</code></th>
<th><code>Content-Type</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>位置</strong></td>
<td>HTML <code>&lt;form&gt;</code> 标签的属性</td>
<td>HTTP 请求头或响应头</td>
</tr>
<tr>
<td><strong>谁定义</strong></td>
<td>开发者在 HTML 中设置</td>
<td>发送方（浏览器或服务器）在 HTTP 头部中设置</td>
</tr>
<tr>
<td><strong>作用</strong></td>
<td>告诉<strong>浏览器</strong>如何<strong>打包</strong>表单数据</td>
<td>告诉<strong>接收方</strong>如何<strong>解析</strong>数据</td>
</tr>
<tr>
<td><strong>关系</strong></td>
<td><strong>enctype 的值决定了 HTTP 请求头中 Content-Type 的值。</strong></td>
<td><code>Content-Type</code> 是 HTTP 协议的一部分，<code>enctype</code> 是 HTML 的一部分。</td>
</tr>
</tbody></table>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假设你有一个包含用户名和头像上传的表单：</p>
<p>HTML</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/profile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;avatar&quot;&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>当用户点击提交时，浏览器会做两件事：</p>
<ol>
<li><p><strong>根据 enctype&#x3D;”multipart&#x2F;form-data” 规则</strong>，浏览器会生成一个**多部分（<code>multipart</code>）**的请求体，包含用户名和头像文件的二进制数据。</p>
</li>
<li><p>在发送 HTTP 请求时，浏览器会在请求头中自动添加一个 <code>Content-Type</code> 字段，其值为<strong>与 enctype 匹配的</strong> <code>multipart/form-data</code>。</p>
<p>HTTP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /profile HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>enctype 是一个前端概念</strong>，它是 HTML 表单的属性，用于指导浏览器如何构建请求体。</li>
<li><strong>Content-Type 是一个 HTTP 协议概念</strong>，它是 HTTP 头部的一个字段，用于告知数据格式。</li>
<li>两者之间存在<strong>联动关系</strong>：你在 HTML 中设置的 <code>enctype</code> 值，会<strong>最终影响</strong>浏览器在 HTTP 请求中设置的 <code>Content-Type</code> 头的值。</li>
</ul>
<p>好的，我来为你分别列出 <code>enctype</code> 和 <code>Content-Type</code> 各自常见的属性值，并简要说明其用途。</p>
<hr>
<h3 id="一、enctype-的常见值"><a href="#一、enctype-的常见值" class="headerlink" title="一、enctype 的常见值"></a>一、<code>enctype</code> 的常见值</h3><p><code>enctype</code> 是 HTML <code>&lt;form&gt;</code> 标签的属性，用于定义表单数据提交的编码方式。</p>
<ol>
<li><strong>application&#x2F;x-www-form-urlencoded</strong><ul>
<li><strong>用途</strong>：这是 <code>enctype</code> 的<strong>默认值</strong>。它将表单数据编码为键值对字符串，其中所有特殊字符都会被 URL 编码（例如空格被 <code>%20</code> 替代）。</li>
<li><strong>适用场景</strong>：只包含文本数据的普通表单提交。</li>
</ul>
</li>
<li><strong>multipart&#x2F;form-data</strong><ul>
<li><strong>用途</strong>：将表单数据分割成多个部分，每个部分都有独立的 <code>Content-Type</code> 和 <code>Content-Disposition</code> 头部。这种格式能够<strong>同时处理文本和二进制数据</strong>。</li>
<li><strong>适用场景</strong>：<strong>文件上传</strong>。</li>
</ul>
</li>
<li><strong>text&#x2F;plain</strong><ul>
<li><strong>用途</strong>：将表单数据以纯文本格式发送，不进行任何编码。数据以键值对的形式，用换行符分隔。</li>
<li><strong>适用场景</strong>：不常用，主要用于调试目的。</li>
</ul>
</li>
</ol>
<h3 id="二、Content-Type-的常见值"><a href="#二、Content-Type-的常见值" class="headerlink" title="二、Content-Type 的常见值"></a>二、<code>Content-Type</code> 的常见值</h3><p><code>Content-Type</code> 是 HTTP 头部字段，用于指定消息体的媒体类型（MIME 类型）。</p>
<h4 id="1-文本类型-text"><a href="#1-文本类型-text" class="headerlink" title="1. 文本类型 (text/)"></a>1. 文本类型 (<code>text/</code>)</h4><ul>
<li><strong>text&#x2F;plain</strong>：纯文本。</li>
<li><strong>text&#x2F;html</strong>：HTML 文档。这是浏览器渲染网页的默认类型。</li>
<li><strong>text&#x2F;css</strong>：CSS 样式表。</li>
<li><strong>text&#x2F;javascript</strong>：JavaScript 代码。</li>
</ul>
<h4 id="2-应用类型-application"><a href="#2-应用类型-application" class="headerlink" title="2. 应用类型 (application/)"></a>2. 应用类型 (<code>application/</code>)</h4><ul>
<li><strong>application&#x2F;json</strong>：JSON 格式的数据。目前最常用的前后端数据交互格式。</li>
<li><strong>application&#x2F;xml</strong>：XML 格式的数据。</li>
<li><strong>application&#x2F;pdf</strong>：PDF 文档。</li>
<li><strong>application&#x2F;octet-stream</strong>：通用的<strong>二进制流数据</strong>。通常用于<strong>强制浏览器下载</strong>未知类型的文件，因为它告诉浏览器“这是一个原始的字节流，请不要尝试解析它”。</li>
<li><strong>application&#x2F;x-www-form-urlencoded</strong>：与 <code>enctype</code> 的默认值对应，表明请求体是 URL 编码的键值对。</li>
<li><strong>application&#x2F;javascript</strong>：与 <code>text/javascript</code> 类似，更推荐使用。</li>
</ul>
<h4 id="3-图片类型-image"><a href="#3-图片类型-image" class="headerlink" title="3. 图片类型 (image/)"></a>3. 图片类型 (<code>image/</code>)</h4><ul>
<li><strong>image&#x2F;jpeg</strong>：JPEG&#x2F;JPG 格式的图片。</li>
<li><strong>image&#x2F;png</strong>：PNG 格式的图片。</li>
<li><strong>image&#x2F;gif</strong>：GIF 格式的图片。</li>
<li><strong>image&#x2F;svg+xml</strong>：SVG 矢量图。</li>
</ul>
<h4 id="4-音视频类型"><a href="#4-音视频类型" class="headerlink" title="4. 音视频类型"></a>4. 音视频类型</h4><ul>
<li><strong>audio&#x2F;mpeg</strong>：MP3 音频文件。</li>
<li><strong>video&#x2F;mp4</strong>：MP4 视频文件。</li>
</ul>
<h4 id="5-多部分类型-multipart"><a href="#5-多部分类型-multipart" class="headerlink" title="5. 多部分类型 (multipart/)"></a>5. 多部分类型 (<code>multipart/</code>)</h4><ul>
<li><strong>multipart&#x2F;form-data</strong>：用于文件上传，与 <code>enctype</code> 的值对应。</li>
<li><strong>multipart&#x2F;byteranges</strong>：用于分块下载，支持断点续传。</li>
</ul>
<p>好的，这是一个非常经典的面试题，也是理解 Web 基础知识的关键。我会详细、清晰地解释 URL 和 URI，并用通俗易懂的方式区分它们。</p>
<hr>
<h3 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h3><ul>
<li><strong>URI (Uniform Resource Identifier) - 统一资源标识符</strong><ul>
<li><strong>概念</strong>：URI 是一个用于<strong>标识</strong>互联网上<strong>任何资源</strong>的字符串。它不仅仅能标识网页，还可以标识文件、服务、电子邮箱等。</li>
<li><strong>作用</strong>：<strong>标识</strong>。URI 就像一个资源的“身份证号”，它能唯一地识别一个资源，但<strong>不一定</strong>告诉我们如何访问它。</li>
</ul>
</li>
<li><strong>URL (Uniform Resource Locator) - 统一资源定位符</strong><ul>
<li><strong>概念</strong>：URL 是一个用于<strong>定位</strong>互联网上资源的字符串。它是 URI 的一个<strong>子集</strong>。</li>
<li><strong>作用</strong>：<strong>定位</strong>。URL 就像一个资源的“详细地址”，它不仅标识了资源，还提供了<strong>如何访问该资源</strong>的完整信息，包括协议、主机名、端口号和路径等。</li>
</ul>
</li>
</ul>
<h3 id="二、URL-和-URI-的关系"><a href="#二、URL-和-URI-的关系" class="headerlink" title="二、URL 和 URI 的关系"></a>二、URL 和 URI 的关系</h3><p>用一个比喻来理解：</p>
<ul>
<li><strong>URI</strong> 就像一个人的<strong>名字</strong>。<code>张三</code>这个名字可以标识这个人，但你不知道他在哪里、怎么找到他。</li>
<li><strong>URL</strong> 就像一个人的<strong>家庭住址</strong>。<code>北京市海淀区中关村大街1号</code>。这个地址不仅标识了这个人，还告诉了你如何定位他。</li>
</ul>
<p><strong>因此，所有的 URL 都是 URI，但并非所有的 URI 都是 URL。</strong></p>
<h3 id="三、URL-和-URI-的具体结构"><a href="#三、URL-和-URI-的具体结构" class="headerlink" title="三、URL 和 URI 的具体结构"></a>三、URL 和 URI 的具体结构</h3><h4 id="URI-的结构："><a href="#URI-的结构：" class="headerlink" title="URI 的结构："></a>URI 的结构：</h4><p>一个 URI 通常由两部分组成：</p>
<p><code>scheme:[//authority][path][?query][#fragment]</code></p>
<ul>
<li><code>scheme</code>：协议，如 <code>http</code>, <code>ftp</code>, <code>mailto</code>。</li>
<li><code>path</code>：资源路径。</li>
</ul>
<h4 id="URL-的结构："><a href="#URL-的结构：" class="headerlink" title="URL 的结构："></a>URL 的结构：</h4><p>URL 包含了 URI 的所有组成部分，并加入了定位信息。</p>
<p><code>scheme://host:port/path?query#fragment</code></p>
<ul>
<li><code>scheme</code>：协议。如 <code>http</code>, <code>https</code>, <code>ftp</code>。</li>
<li><code>host</code>：主机名或 IP 地址。</li>
<li><code>port</code>：端口号（可选，如果使用默认端口则可以省略）。</li>
<li><code>path</code>：资源路径。</li>
<li><code>query</code>：查询参数，以 <code>?</code> 开始。</li>
<li><code>fragment</code>：片段标识符，以 <code>#</code> 开始。</li>
</ul>
<h3 id="四、举例说明"><a href="#四、举例说明" class="headerlink" title="四、举例说明"></a>四、举例说明</h3><table>
<thead>
<tr>
<th>字符串</th>
<th>类别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>https://www.google.com/search?q=url+uri</code></td>
<td><strong>URL</strong> 和 <strong>URI</strong></td>
<td>既是 URI（标识），也是 URL（定位），提供了完整的访问信息。</td>
</tr>
<tr>
<td><code>urn:isbn:0451450523</code></td>
<td><strong>URI</strong> 但<strong>不是 URL</strong></td>
<td><code>urn:isbn</code> 是一个 URN (Uniform Resource Name)，它是 URI 的另一种类型，用于标识一本书。它标识了资源，但没有提供如何访问它的位置信息。</td>
</tr>
<tr>
<td><code>/images/logo.png</code></td>
<td><strong>URI</strong> 但<strong>不是 URL</strong></td>
<td>这是一个相对路径，它标识了资源，但没有完整的定位信息（如协议、主机名），需要结合当前页面的 URL 才能确定完整位置。</td>
</tr>
<tr>
<td><code>mailto:test@example.com</code></td>
<td><strong>URI</strong> 但<strong>不是 URL</strong></td>
<td>标识了一个邮箱资源，但无法通过它来定位到具体的文件或服务器。</td>
</tr>
</tbody></table>
<h3 id="五、面试回答总结"><a href="#五、面试回答总结" class="headerlink" title="五、面试回答总结"></a>五、面试回答总结</h3><ol>
<li><p><strong>开门见山</strong>：URL 是 URI 的子集。</p>
</li>
<li><p><strong>核心区别</strong>：</p>
<ul>
<li><strong>URI 是标识符</strong>，它只负责<strong>标识</strong>一个资源，不提供如何访问它的信息。</li>
<li><strong>URL 是定位符</strong>，它在标识资源的同时，还提供了<strong>定位</strong>该资源的完整信息，如协议、主机名等。</li>
</ul>
</li>
<li><p><strong>举例</strong>：</p>
<ul>
<li>URL：<code>https://www.example.com/index.html</code>，包含了协议、主机、路径，可以明确地定位一个资源。</li>
<li>URI：<code>urn:isbn:0451450523</code>，它标识了一本书，但你无法通过它来访问这本书的电子版。</li>
</ul>
</li>
<li><p><strong>关系图</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------------+</span><br><span class="line">|      URI    |</span><br><span class="line">|             |</span><br><span class="line">|  +----------+---------+</span><br><span class="line">|  |   URL    |   URN   |</span><br><span class="line">|  | (定位)   |  (命名) |</span><br><span class="line">|  +----------+---------+</span><br><span class="line">|             |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>用这个图能非常清晰地展现它们之间的关系。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Charlotte</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/web/">http://example.com/2025/09/11/web/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">浮生若梦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web/">web</a><a class="post-meta__tags" href="/tags/servlet/">servlet</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="post-share"><div class="social-share" data-image="/img/title.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">分布式</div></div><div class="info-2"><div class="info-item-1">1. Spring Cloud 体系核心思想Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的规范和解决方案的集合。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。 Netflix OSS 常用组件（部分进入维护模式） 服务注册与发现 (Service Discovery): Eureka 作用: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。 使用: 服务端添加 spring-cloud-starter-netflix-eureka-server 依赖，并使用 @EnableEurekaServer 注解。客...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" title="命令大全"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">命令大全</div></div><div class="info-2"><div class="info-item-1"> 📌 一、Linux 常见命令大全🔹 文件与目录操作   命令 说明 示例    ls 列出目录内容 ls -al 显示隐藏文件和详细信息   pwd 显示当前目录 pwd   cd 切换目录 cd /usr/local   mkdir 创建目录 mkdir -p /data/logs   rmdir 删除空目录 rmdir old   rm 删除文件&#x2F;目录 rm -rf /tmp/test   cp 复制文件&#x2F;目录 cp a.txt /tmp/，cp -r dir1 dir2   mv 移动&#x2F;重命名 mv old.txt new.txt   find 查找文件 find / -name &quot;*.log&quot;   locate 快速查找文件（需 updatedb） locate nginx.conf    🔹 文件查看与编辑   命令 说明 示例    cat 查看文件内容 cat file.txt   tac 反向输出 tac file.txt   less 分页查看 less /var/log/syslog   head 查看...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/title.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Charlotte</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/charlotte030710"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81HTTP-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、HTTP 协议概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81HTTP-%E8%AF%B7%E6%B1%82%EF%BC%88Request%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">二、HTTP 请求（Request）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E6%B1%82%E8%A1%8C%EF%BC%88Request-Line%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">1. 请求行（Request Line）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E6%B1%82%E5%A4%B4%EF%BC%88Request-Headers%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2. 请求头（Request Headers）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A9%BA%E8%A1%8C"><span class="toc-number">2.3.</span> <span class="toc-text">3. 空行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B7%E6%B1%82%E4%BD%93%EF%BC%88Request-Body%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">4. 请求体（Request Body）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81HTTP-%E5%93%8D%E5%BA%94%EF%BC%88Response%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">三、HTTP 响应（Response）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%8A%B6%E6%80%81%E8%A1%8C%EF%BC%88Status-Line%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">1. 状态行（Status Line）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%93%8D%E5%BA%94%E5%A4%B4%EF%BC%88Response-Headers%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">2. 响应头（Response Headers）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A9%BA%E8%A1%8C-1"><span class="toc-number">3.3.</span> <span class="toc-text">3. 空行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%93%8D%E5%BA%94%E4%BD%93%EF%BC%88Response-Body%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">4. 响应体（Response Body）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81HTTP-%E6%96%B9%E6%B3%95%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">四、HTTP 方法的幂等性与安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81HTTP-%E7%9A%84%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%9ACookie"><span class="toc-number">5.</span> <span class="toc-text">五、HTTP 的会话管理：Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81HTTP-1-1-%E4%B8%8E-HTTP-2-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">六、HTTP&#x2F;1.1 与 HTTP&#x2F;2 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81HTTP-%E5%8D%8F%E8%AE%AE%E6%97%8F%E6%BC%94%E5%8F%98%EF%BC%9A%E4%BB%8E-1-0-%E5%88%B0-2-0"><span class="toc-number">7.</span> <span class="toc-text">一、HTTP 协议族演变：从 1.0 到 2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-0"><span class="toc-number">7.1.</span> <span class="toc-text">HTTP&#x2F;1.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1"><span class="toc-number">7.2.</span> <span class="toc-text">HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2-0"><span class="toc-number">7.3.</span> <span class="toc-text">HTTP&#x2F;2.0</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81HTTP-%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">二、HTTP 协议版本对比总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-%E6%A6%82%E8%BF%B0%EF%BC%9AJava-Web-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%9F%B3"><span class="toc-number">9.</span> <span class="toc-text">Servlet 概述：Java Web 的核心基石</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E7%94%B1%E5%AE%B9%E5%99%A8%E4%B8%A5%E6%A0%BC%E7%AE%A1%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">Servlet 的生命周期：由容器严格管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E9%83%A8%E7%BD%B2%EF%BC%9A%E4%B8%A4%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%96%B9%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">Servlet 的配置和部署：两种主要方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94"><span class="toc-number">12.</span> <span class="toc-text">Servlet 的核心方法：处理请求和响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%A4%E4%BA%92"><span class="toc-number">13.</span> <span class="toc-text">Servlet 的请求和响应处理：与客户端交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">14.</span> <span class="toc-text">Servlet 的核心组件与作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E2%80%9C%E5%B0%8F%E7%BA%B8%E6%9D%A1%E2%80%9D"><span class="toc-number">15.</span> <span class="toc-text">Cookie：客户端的“小纸条”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">15.1.</span> <span class="toc-text">核心工作机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">15.2.</span> <span class="toc-text">Cookie 的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E2%80%9C%E4%B8%AA%E4%BA%BA%E6%A1%A3%E6%A1%88%E2%80%9D"><span class="toc-number">16.</span> <span class="toc-text">Session：服务器的“个人档案”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-1"><span class="toc-number">16.1.</span> <span class="toc-text">核心工作机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">16.2.</span> <span class="toc-text">Session 的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-%E4%B8%8E-Session-%E7%9A%84%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">17.</span> <span class="toc-text">Cookie 与 Session 的对比总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%A8%E9%9D%A2%E5%AF%B9%E6%AF%94"><span class="toc-number">18.</span> <span class="toc-text">GET 和 POST 请求的全面对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket-%E6%A6%82%E8%BF%B0%EF%BC%9AWeb-%E9%80%9A%E4%BF%A1%E7%9A%84%E9%9D%A9%E5%91%BD"><span class="toc-number">19.</span> <span class="toc-text">WebSocket 概述：Web 通信的革命</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">20.</span> <span class="toc-text">WebSocket 的核心工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">21.</span> <span class="toc-text">WebSocket 的生命周期：事件驱动模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%EF%BC%88Connection-Establishment%EF%BC%89"><span class="toc-number">21.1.</span> <span class="toc-text">1. 连接建立（Connection Establishment）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%88Data-Transmission%EF%BC%89"><span class="toc-number">21.2.</span> <span class="toc-text">2. 数据传输（Data Transmission）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%EF%BC%88Connection-Close%EF%BC%89"><span class="toc-number">21.3.</span> <span class="toc-text">3. 连接关闭（Connection Close）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket-%E7%9A%84%E6%A0%B8%E5%BF%83-API%EF%BC%88%E4%BB%A5-JavaScript-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">22.</span> <span class="toc-text">WebSocket 的核心 API（以 JavaScript 为例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket-%E4%B8%8E-HTTP-%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">23.</span> <span class="toc-text">WebSocket 与 HTTP 的本质区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket-%E5%9C%A8%E7%8E%B0%E4%BB%A3-Java-Web-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">24.</span> <span class="toc-text">WebSocket 在现代 Java Web 中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8"><span class="toc-number">25.</span> <span class="toc-text">示例一：实时聊天应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">25.1.</span> <span class="toc-text">应用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-number">25.2.</span> <span class="toc-text">核心逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">25.3.</span> <span class="toc-text">代码示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%AE%9E%E6%97%B6%E8%82%A1%E7%A5%A8%E8%A1%8C%E6%83%85%E6%88%96%E6%95%B0%E6%8D%AE%E7%9C%8B%E6%9D%BF"><span class="toc-number">26.</span> <span class="toc-text">示例二：实时股票行情或数据看板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-1"><span class="toc-number">26.1.</span> <span class="toc-text">应用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%EF%BC%9A-1"><span class="toc-number">26.2.</span> <span class="toc-text">核心逻辑：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">26.3.</span> <span class="toc-text">代码示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90-Static-Resources"><span class="toc-number">27.</span> <span class="toc-text">一、静态资源 (Static Resources)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">27.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">27.2.</span> <span class="toc-text">常见类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">27.3.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">27.4.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8A%A8%E6%80%81%E8%B5%84%E6%BA%90-Dynamic-Resources"><span class="toc-number">28.</span> <span class="toc-text">二、动态资源 (Dynamic Resources)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">28.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">28.2.</span> <span class="toc-text">常见类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-1"><span class="toc-number">28.3.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">28.4.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%E5%8F%AA%E8%83%BD%E8%A7%A3%E6%9E%90%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">三、是什么东西只能解析静态资源？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BA%AF%E9%9D%99%E6%80%81-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8-Static-Web-Server"><span class="toc-number">29.1.</span> <span class="toc-text">1. 纯静态 Web 服务器 (Static Web Server)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8-Dynamic-Web-Server"><span class="toc-number">29.2.</span> <span class="toc-text">2. 动态 Web 服务器 (Dynamic Web Server)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E4%B8%89%E5%89%91%E5%AE%A2%EF%BC%9A%E6%9E%84%E5%BB%BA%E7%BD%91%E9%A1%B5%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-number">30.</span> <span class="toc-text">一、基础三剑客：构建网页的基石</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-HTML-HyperText-Markup-Language"><span class="toc-number">30.1.</span> <span class="toc-text">1. HTML (HyperText Markup Language)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CSS-Cascading-Style-Sheets"><span class="toc-number">30.2.</span> <span class="toc-text">2. CSS (Cascading Style Sheets)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-JavaScript-JS"><span class="toc-number">30.3.</span> <span class="toc-text">3. JavaScript (JS)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%8E%B0%E4%BB%A3%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87"><span class="toc-number">31.</span> <span class="toc-text">二、现代前端框架：提升开发效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%9A%E9%AB%98%E6%95%88%E5%8D%8F%E4%BD%9C%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%96"><span class="toc-number">32.</span> <span class="toc-text">三、工程化：高效协作和自动化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E9%80%89%E6%8B%A9%E5%99%A8-Basic-Selectors"><span class="toc-number">33.</span> <span class="toc-text">一、基础选择器 (Basic Selectors)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8-Type-Selector"><span class="toc-number">33.1.</span> <span class="toc-text">1. 元素选择器 (Type Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8-Class-Selector"><span class="toc-number">33.2.</span> <span class="toc-text">2. 类选择器 (Class Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ID-%E9%80%89%E6%8B%A9%E5%99%A8-ID-Selector"><span class="toc-number">33.3.</span> <span class="toc-text">3. ID 选择器 (ID Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%9A%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8-Universal-Selector"><span class="toc-number">33.4.</span> <span class="toc-text">4. 通用选择器 (Universal Selector)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BB%84%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8-Combinators"><span class="toc-number">34.</span> <span class="toc-text">二、组合选择器 (Combinators)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8-Descendant-Selector"><span class="toc-number">34.1.</span> <span class="toc-text">1. 后代选择器 (Descendant Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%90%E9%80%89%E6%8B%A9%E5%99%A8-Child-Selector"><span class="toc-number">34.2.</span> <span class="toc-text">2. 子选择器 (Child Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%9B%B8%E9%82%BB%E5%85%84%E5%BC%9F%E9%80%89%E6%8B%A9%E5%99%A8-Adjacent-Sibling-Selector"><span class="toc-number">34.3.</span> <span class="toc-text">3. 相邻兄弟选择器 (Adjacent Sibling Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%9A%E7%94%A8%E5%85%84%E5%BC%9F%E9%80%89%E6%8B%A9%E5%99%A8-General-Sibling-Selector"><span class="toc-number">34.4.</span> <span class="toc-text">4. 通用兄弟选择器 (General Sibling Selector)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8-Attribute-Selectors"><span class="toc-number">35.</span> <span class="toc-text">三、属性选择器 (Attribute Selectors)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8-Pseudo-class-Selectors"><span class="toc-number">36.</span> <span class="toc-text">四、伪类选择器 (Pseudo-class Selectors)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8-Pseudo-element-Selectors"><span class="toc-number">37.</span> <span class="toc-text">五、伪元素选择器 (Pseudo-element Selectors)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E5%B1%82%E5%8F%A0"><span class="toc-number">38.</span> <span class="toc-text">优先级与层叠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Maven-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">39.</span> <span class="toc-text">一、Maven 核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-Maven%EF%BC%9F"><span class="toc-number">39.1.</span> <span class="toc-text">1. 什么是 Maven？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Maven%EF%BC%9F"><span class="toc-number">39.2.</span> <span class="toc-text">2. 为什么需要 Maven？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Maven-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">40.</span> <span class="toc-text">二、Maven 的核心组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-POM-Project-Object-Model"><span class="toc-number">40.1.</span> <span class="toc-text">1. POM (Project Object Model)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86-Dependency-Management"><span class="toc-number">40.2.</span> <span class="toc-text">2. 依赖管理 (Dependency Management)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%93%E5%BA%93-Repositories"><span class="toc-number">40.3.</span> <span class="toc-text">3. 仓库 (Repositories)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%98%B6%E6%AE%B5-Lifecycle-Phases"><span class="toc-number">40.4.</span> <span class="toc-text">4. 生命周期与阶段 (Lifecycle &amp; Phases)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%9E%E7%AD%94%E6%8A%80%E5%B7%A7"><span class="toc-number">41.</span> <span class="toc-text">三、面试常见问题与回答技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Maven-%E7%9A%84-GAV-%E5%9D%90%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">41.1.</span> <span class="toc-text">1. Maven 的 GAV 坐标是什么？有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%92%8C-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">41.2.</span> <span class="toc-text">2. &lt;dependencyManagement&gt; 和 &lt;dependencies&gt; 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF-Maven-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9Fmvn-install-%E5%92%8C-mvn-deploy-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">41.3.</span> <span class="toc-text">3. 什么是 Maven 的生命周期？mvn install 和 mvn deploy 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Maven-%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">41.4.</span> <span class="toc-text">4. Maven 依赖冲突如何解决？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0%EF%BC%9A%E8%A7%A3%E5%86%B3-HTTP-%E6%97%A0%E7%8A%B6%E6%80%81%E9%97%AE%E9%A2%98"><span class="toc-number">42.</span> <span class="toc-text">一、会话技术概述：解决 HTTP 无状态问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%9A%E8%AF%9D%EF%BC%9ACookie"><span class="toc-number">43.</span> <span class="toc-text">二、客户端会话：Cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%B3%E4%BA%8E-Cookie-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">43.1.</span> <span class="toc-text">1. 关于 Cookie 的几个常见问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Cookie-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">43.2.</span> <span class="toc-text">2. Cookie 的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Cookie-%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4"><span class="toc-number">43.3.</span> <span class="toc-text">3. Cookie 案例：获取上一次访问时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BC%9A%E8%AF%9D%EF%BC%9AHttpSession"><span class="toc-number">44.</span> <span class="toc-text">三、服务器端会话：HttpSession</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Session-%E7%9A%84%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8"><span class="toc-number">44.1.</span> <span class="toc-text">1. Session 的快速使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Session-%E7%9A%84%E5%A4%B1%E6%95%88%E6%97%B6%E9%97%B4"><span class="toc-number">44.2.</span> <span class="toc-text">2. Session 的失效时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A7-%E5%9C%A8%E4%BB%A3%E7%A0%81%E9%87%8C%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE%EF%BC%88%E5%8D%95%E4%B8%AA-Session%EF%BC%89"><span class="toc-number">45.</span> <span class="toc-text">🔧 在代码里动态设置（单个 Session）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A7-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">46.</span> <span class="toc-text">🔧 特殊情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Session-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">46.1.</span> <span class="toc-text">3. Session 的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ACookie-%E5%92%8C-Session-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">46.2.</span> <span class="toc-text">4. 面试题：Cookie 和 Session 的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Servlet-%E4%B8%89%E5%A4%A7%E5%9F%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%88%E6%8C%89%E7%85%A7%E4%BD%A0%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%89"><span class="toc-number">47.</span> <span class="toc-text">四、Servlet 三大域对象的关系（按照你的逻辑）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC-JAR-%E5%85%B1%E5%AD%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number"></span> <span class="toc-text">✅ 两个版本 JAR 共存的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ClassLoader-%E9%9A%94%E7%A6%BB%EF%BC%88%E6%8E%A8%E8%8D%90%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">1. ClassLoader 隔离（推荐方式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8C%85%E9%87%8D%E5%AE%9A%E4%BD%8D%EF%BC%88Shading-Relocation%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">2. 包重定位（Shading &#x2F; Relocation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%8D%E5%8A%A1%E8%A7%A3%E8%80%A6-%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">3. 服务解耦 &#x2F; 模块化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%80-%E5%AE%9E%E9%99%85%E5%BB%BA%E8%AE%AE"><span class="toc-number"></span> <span class="toc-text">🚀 实际建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81CSS-%E9%80%89%E6%8B%A9%E5%99%A8%E6%A6%82%E8%BF%B0%EF%BC%9A%E7%B2%BE%E5%87%86%E5%AE%9A%E4%BD%8D%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0"><span class="toc-number">1.</span> <span class="toc-text">一、CSS 选择器概述：精准定位网页元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E9%80%89%E6%8B%A9%E5%99%A8-Basic-Selectors"><span class="toc-number">2.</span> <span class="toc-text">二、基础选择器 (Basic Selectors)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8-Type-Selector"><span class="toc-number">2.1.</span> <span class="toc-text">1. 标签选择器 (Type Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8-Class-Selector-1"><span class="toc-number">2.2.</span> <span class="toc-text">2. 类选择器 (Class Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ID-%E9%80%89%E6%8B%A9%E5%99%A8-ID-Selector-1"><span class="toc-number">2.3.</span> <span class="toc-text">3. ID 选择器 (ID Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%9A%E9%85%8D%E7%AC%A6%E9%80%89%E6%8B%A9%E5%99%A8-Universal-Selector"><span class="toc-number">2.4.</span> <span class="toc-text">4. 通配符选择器 (Universal Selector)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%84%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8-Combinators"><span class="toc-number">3.</span> <span class="toc-text">三、组合选择器 (Combinators)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%A4%E9%9B%86%E9%80%89%E6%8B%A9%E5%99%A8-Intersection-Selector"><span class="toc-number">3.1.</span> <span class="toc-text">1. 交集选择器 (Intersection Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B9%B6%E9%9B%86%E9%80%89%E6%8B%A9%E5%99%A8-Union-Selector"><span class="toc-number">3.2.</span> <span class="toc-text">2. 并集选择器 (Union Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%90%E9%80%89%E6%8B%A9%E5%99%A8-Child-Selector"><span class="toc-number">3.3.</span> <span class="toc-text">3. 子选择器 (Child Selector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8-Descendant-Selector"><span class="toc-number">3.4.</span> <span class="toc-text">4. 后代选择器 (Descendant Selector)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8-Attribute-Selectors"><span class="toc-number">4.</span> <span class="toc-text">四、属性选择器 (Attribute Selectors)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8-Pseudo-class-Pseudo-element-Selectors"><span class="toc-number">5.</span> <span class="toc-text">五、伪类与伪元素选择器 (Pseudo-class &amp; Pseudo-element Selectors)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7-Specificity"><span class="toc-number">6.</span> <span class="toc-text">六、选择器优先级 (Specificity)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM-Browser-Object-Model"><span class="toc-number">7.</span> <span class="toc-text">BOM (Browser Object Model)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-BOM-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="toc-number">7.2.</span> <span class="toc-text">2. BOM 的核心对象与功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-BOM-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">7.3.</span> <span class="toc-text">3. BOM 的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-Document-Object-Model"><span class="toc-number">8.</span> <span class="toc-text">DOM (Document Object Model)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5-1"><span class="toc-number">8.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-DOM-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="toc-number">8.2.</span> <span class="toc-text">2. DOM 的核心对象与功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-DOM-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.3.</span> <span class="toc-text">3. DOM 的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM-%E5%92%8C-DOM-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">9.</span> <span class="toc-text">BOM 和 DOM 的核心区别与联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81JavaScript-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">一、JavaScript 中的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">10.1.</span> <span class="toc-text">1. 基础数据类型（原始数据类型）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.2.</span> <span class="toc-text">2. 数据类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JavaScript-%E4%B8%AD%E7%9A%84%E5%BC%B9%E5%87%BA%E6%A1%86"><span class="toc-number">11.</span> <span class="toc-text">二、JavaScript 中的弹出框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A-%E5%92%8C"><span class="toc-number">12.</span> <span class="toc-text">三、条件运算符：&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">13.</span> <span class="toc-text">四、字符串和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.</span> <span class="toc-text">五、函数和对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">15.</span> <span class="toc-text">六、定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81ES6-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">七、ES6 新特性（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81DOM"><span class="toc-number">17.</span> <span class="toc-text">八、DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Web-%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-number">18.</span> <span class="toc-text">一、Web 架构与网络基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">18.1.</span> <span class="toc-text">1. 常见的软件架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">18.2.</span> <span class="toc-text">2. 网络编程三要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">18.3.</span> <span class="toc-text">3. 资源的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">19.</span> <span class="toc-text">二、Web 服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8"><span class="toc-number">19.1.</span> <span class="toc-text">1. 作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">19.2.</span> <span class="toc-text">2. 常见的 Web 服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Tomcat-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">20.</span> <span class="toc-text">三、Tomcat 的使用与配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Servlet-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">21.</span> <span class="toc-text">四、Servlet 深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Servlet-%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AC%E8%B4%A8"><span class="toc-number">21.1.</span> <span class="toc-text">1. Servlet 的概念和本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Servlet-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%88%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%EF%BC%89"><span class="toc-number">21.2.</span> <span class="toc-text">2. Servlet 的执行原理（详细解释）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">22.</span> <span class="toc-text">一、网络编程三要素：深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-IP-%E5%9C%B0%E5%9D%80-Internet-Protocol-Address"><span class="toc-number">22.1.</span> <span class="toc-text">1. IP 地址 (Internet Protocol Address)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AB%AF%E5%8F%A3%E5%8F%B7-Port-Number"><span class="toc-number">22.2.</span> <span class="toc-text">2. 端口号 (Port Number)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8D%8F%E8%AE%AE-Protocol"><span class="toc-number">22.3.</span> <span class="toc-text">3. 协议 (Protocol)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">23.</span> <span class="toc-text">二、常见应用的默认端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Servlet-%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86"><span class="toc-number">24.</span> <span class="toc-text">一、Servlet 剩余部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Servlet-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-number">24.1.</span> <span class="toc-text">1. Servlet 的生命周期方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Servlet-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9AXML-vs-%E6%B3%A8%E8%A7%A3"><span class="toc-number">24.2.</span> <span class="toc-text">2. Servlet 的实现方式：XML vs. 注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Servlet-%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">24.3.</span> <span class="toc-text">3. Servlet 的体系结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81HTTP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">25.</span> <span class="toc-text">二、HTTP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-number">25.1.</span> <span class="toc-text">1. 概念与特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-HTTP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">25.2.</span> <span class="toc-text">2. HTTP 协议的数据格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ServletRequest-%E5%AF%B9%E8%B1%A1"><span class="toc-number">25.3.</span> <span class="toc-text">3. ServletRequest 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-request-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91"><span class="toc-number">25.4.</span> <span class="toc-text">4. request 请求转发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-request-%E4%BD%9C%E4%B8%BA%E5%9F%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">25.5.</span> <span class="toc-text">5. request 作为域对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81HTTP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F"><span class="toc-number">26.</span> <span class="toc-text">一、HTTP 协议的响应格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F%E7%BB%84%E6%88%90"><span class="toc-number">26.1.</span> <span class="toc-text">1. 响应格式组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%93%8D%E5%BA%94%E8%A1%8C"><span class="toc-number">26.2.</span> <span class="toc-text">2. 响应行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">26.3.</span> <span class="toc-text">3. 响应头</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ServletResponse-response"><span class="toc-number">27.</span> <span class="toc-text">二、ServletResponse (response)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BD%AC%E5%8F%91%EF%BC%88Forward%EF%BC%89%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%88Redirect%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">28.</span> <span class="toc-text">三、转发（Forward）和重定向（Redirect）的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ServletContext"><span class="toc-number">29.</span> <span class="toc-text">四、ServletContext</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-number">29.1.</span> <span class="toc-text">1. 简介与特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96-ServletContext-%E5%AF%B9%E8%B1%A1"><span class="toc-number">29.2.</span> <span class="toc-text">2. 获取 ServletContext 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ServletContext-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">29.3.</span> <span class="toc-text">3. ServletContext 的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BC%9A%E8%AF%9D%EF%BC%88Session%EF%BC%89"><span class="toc-number">30.</span> <span class="toc-text">五、会话（Session）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="toc-number">30.1.</span> <span class="toc-text">1. 概念与作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%9A%E8%AF%9D%EF%BC%9ACookie"><span class="toc-number">30.2.</span> <span class="toc-text">2. 客户端会话：Cookie</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81enctype"><span class="toc-number">31.</span> <span class="toc-text">一、enctype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Content-Type"><span class="toc-number">32.</span> <span class="toc-text">二、Content-Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">33.</span> <span class="toc-text">三、核心区别与联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">34.</span> <span class="toc-text">举例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81enctype-%E7%9A%84%E5%B8%B8%E8%A7%81%E5%80%BC"><span class="toc-number">35.</span> <span class="toc-text">一、enctype 的常见值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Content-Type-%E7%9A%84%E5%B8%B8%E8%A7%81%E5%80%BC"><span class="toc-number">36.</span> <span class="toc-text">二、Content-Type 的常见值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E6%9C%AC%E7%B1%BB%E5%9E%8B-text"><span class="toc-number">36.1.</span> <span class="toc-text">1. 文本类型 (text&#x2F;)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BA%94%E7%94%A8%E7%B1%BB%E5%9E%8B-application"><span class="toc-number">36.2.</span> <span class="toc-text">2. 应用类型 (application&#x2F;)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9B%BE%E7%89%87%E7%B1%BB%E5%9E%8B-image"><span class="toc-number">36.3.</span> <span class="toc-text">3. 图片类型 (image&#x2F;)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%9F%B3%E8%A7%86%E9%A2%91%E7%B1%BB%E5%9E%8B"><span class="toc-number">36.4.</span> <span class="toc-text">4. 音视频类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A4%9A%E9%83%A8%E5%88%86%E7%B1%BB%E5%9E%8B-multipart"><span class="toc-number">36.5.</span> <span class="toc-text">5. 多部分类型 (multipart&#x2F;)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">37.</span> <span class="toc-text">一、核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81URL-%E5%92%8C-URI-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">38.</span> <span class="toc-text">二、URL 和 URI 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81URL-%E5%92%8C-URI-%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">39.</span> <span class="toc-text">三、URL 和 URI 的具体结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#URI-%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">39.1.</span> <span class="toc-text">URI 的结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URL-%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">39.2.</span> <span class="toc-text">URL 的结构：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">40.</span> <span class="toc-text">四、举例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%80%BB%E7%BB%93"><span class="toc-number">41.</span> <span class="toc-text">五、面试回答总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">数据结构</a><time datetime="2025-09-20T10:29:28.000Z" title="发表于 2025-09-20 18:29:28">2025-09-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" title="命令大全">命令大全</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/web/" title="web">web</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式">分布式</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E7%AE%97%E6%B3%95/" title="算法">算法</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bg.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Charlotte</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
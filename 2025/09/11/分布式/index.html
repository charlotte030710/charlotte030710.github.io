<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>分布式 | 浮生若梦</title><meta name="author" content="Charlotte"><meta name="copyright" content="Charlotte"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Spring Cloud 体系核心思想Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的规范和解决方案的集合。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式">
<meta property="og:url" content="http://example.com/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/index.html">
<meta property="og:site_name" content="浮生若梦">
<meta property="og:description" content="1. Spring Cloud 体系核心思想Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的规范和解决方案的集合。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/title.jpg">
<meta property="article:published_time" content="2025-09-11T10:29:28.000Z">
<meta property="article:modified_time" content="2025-09-16T05:17:13.884Z">
<meta property="article:author" content="Charlotte">
<meta property="article:tag" content="java">
<meta property="article:tag" content="分布式微服务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/title.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "分布式",
  "url": "http://example.com/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/",
  "image": "http://example.com/img/title.jpg",
  "datePublished": "2025-09-11T10:29:28.000Z",
  "dateModified": "2025-09-16T05:17:13.884Z",
  "author": [
    {
      "@type": "Person",
      "name": "Charlotte",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="http://example.com/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分布式',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="浮生若梦" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/title.jpg" alt="Logo"><span class="site-name">浮生若梦</span></a><a class="nav-page-title" href="/"><span class="site-name">分布式</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">分布式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-16T05:17:13.884Z" title="更新于 2025-09-16 13:17:13">2025-09-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h4 id="1-Spring-Cloud-体系"><a href="#1-Spring-Cloud-体系" class="headerlink" title="1. Spring Cloud 体系"></a><strong>1. Spring Cloud 体系</strong></h4><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h5><p>Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的<strong>规范和解决方案的集合</strong>。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。</p>
<h5 id="Netflix-OSS-常用组件（部分进入维护模式）"><a href="#Netflix-OSS-常用组件（部分进入维护模式）" class="headerlink" title="Netflix OSS 常用组件（部分进入维护模式）"></a><strong>Netflix OSS 常用组件（部分进入维护模式）</strong></h5><ul>
<li><strong>服务注册与发现 (Service Discovery): Eureka</strong><ul>
<li><strong>作用</strong>: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。</li>
<li><strong>使用</strong>: 服务端添加 <code>spring-cloud-starter-netflix-eureka-server</code> 依赖，并使用 <code>@EnableEurekaServer</code> 注解。客户端添加 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖，并配置 Eureka Server 地址。</li>
</ul>
</li>
<li><strong>服务调用与负载均衡 (RPC &amp; Load Balancing): OpenFeign + Ribbon</strong><ul>
<li><strong>作用</strong>: Feign 让远程服务调用变得像调用本地方法一样简单。开发者只需定义一个接口，并使用 <code>@FeignClient</code> 注解，即可完成对远程服务的调用。Ribbon（现已被 Spring Cloud LoadBalancer 替代）则提供了客户端负载均衡能力，当从 Eureka 获取到多个服务实例地址时，Ribbon 会根据配置的策略（如轮询、随机）选择一个实例进行调用。</li>
<li><strong>使用</strong>: 添加 <code>spring-cloud-starter-openfeign</code> 依赖，在启动类上加 <code>@EnableFeignClients</code>，创建接口并使用 <code>@FeignClient(&quot;service-name&quot;)</code> 注解。</li>
</ul>
</li>
<li><strong>熔断与降级 (Circuit Breaker): Hystrix</strong><ul>
<li><strong>作用</strong>: 当某个下游服务出现故障或响应缓慢时，为了防止故障在系统中蔓延（即“服务雪崩”），熔断器会快速失败，暂时切断对该服务的调用。同时，可以执行一个预定义的降级逻辑（Fallback），例如返回一个缓存的、默认的或友好的提示信息。</li>
<li><strong>状态</strong>: Hystrix 已进入维护模式，官方推荐使用 Resilience4j 或其他替代方案。</li>
</ul>
</li>
<li><strong>API 网关 (API Gateway): Zuul</strong><ul>
<li><strong>作用</strong>: 作为系统的统一入口，API 网关负责请求路由、协议转换、权限校验、流量控制、日志监控等。所有外部请求都先经过网关，再由网关分发到后端的各个微服务。</li>
<li><strong>状态</strong>: Zuul 1.x 已进入维护模式，官方推荐使用 Spring Cloud Gateway。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Spring-Cloud-Alibaba-详解"><a href="#Spring-Cloud-Alibaba-详解" class="headerlink" title="Spring Cloud Alibaba 详解"></a><strong>Spring Cloud Alibaba 详解</strong></h5><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案，是 Spring Cloud 体系的重要实现。它集成了阿里巴巴开源的优秀组件，为开发者提供了更符合国内技术生态的选择。</p>
<ul>
<li><strong>服务注册与发现 &amp; 分布式配置中心: Nacos</strong><ul>
<li><strong>作用</strong>: Nacos (Naming and Configuration Service) 是一个功能丰富的平台，完美整合了<strong>服务注册发现</strong>和<strong>配置管理</strong>两大核心功能。<ul>
<li><strong>服务发现</strong>: 与 Eureka 类似，提供服务注册、发现和健康检查。但 Nacos 支持基于 DNS 和 RPC 的服务发现，并提供更实时的健康检查机制。</li>
<li><strong>配置管理</strong>: 可以作为分布式配置中心，对所有微服务的配置进行集中化管理。支持配置的热更新，即修改配置后无需重启服务即可生效。还支持配置的版本管理、灰度发布等高级功能。</li>
</ul>
</li>
<li><strong>使用</strong>:<ol>
<li>引入 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 和 <code>spring-cloud-starter-alibaba-nacos-config</code> 依赖。</li>
<li>在 <code>bootstrap.properties</code> (或 <code>.yml</code>) 文件中配置 Nacos 服务器地址和应用名。</li>
<li>使用 <code>@Value</code> 或 <code>@ConfigurationProperties</code> 注解即可动态获取和刷新配置。</li>
</ol>
</li>
</ul>
</li>
<li><strong>熔断、降级与流量控制: Sentinel</strong><ul>
<li><strong>作用</strong>: Sentinel 是面向分布式服务架构的“流量的守护者”，以流量为切入点，从<strong>流量控制、熔断降级、系统负载保护</strong>等多个维度保护服务的稳定性。相较于 Hystrix，Sentinel 功能更强大，提供了可视化的监控和配置平台，并且支持热点参数限流等精细化控制。</li>
<li><strong>核心概念</strong>:<ul>
<li><strong>资源 (Resource)</strong>: Sentinel 中一切皆资源，可以是一个方法、一段代码或一个服务 URL。</li>
<li><strong>规则 (Rule)</strong>: 定义如何保护资源，包括流控规则、降级规则、系统保护规则等。</li>
</ul>
</li>
<li><strong>使用</strong>:<ol>
<li>引入 <code>spring-cloud-starter-alibaba-sentinel</code> 依赖。</li>
<li>配置 Sentinel 控制台地址。</li>
<li>通过 <code>@SentinelResource</code> 注解来定义资源，并指定 Fallback (降级逻辑) 和 BlockHandler (流控&#x2F;熔断逻辑)。</li>
</ol>
</li>
</ul>
</li>
<li><strong>分布式事务解决方案: Seata</strong><ul>
<li><strong>作用</strong>: Seata 是一个开源的分布式事务解决方案，提供了高性能且易于使用的分布式事务服务。它支持多种事务模式，包括 AT（自动补偿）、TCC、Saga 和 XA 模式，旨在解决微服务架构下的数据一致性问题。</li>
<li><strong>使用</strong>: 引入 <code>spring-cloud-starter-alibaba-seata</code> 依赖，配置 Seata Server 地址，并使用 <code>@GlobalTransactional</code> 注解开启全局事务。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-分布式ID：雪花算法（Snowflake）"><a href="#2-分布式ID：雪花算法（Snowflake）" class="headerlink" title="2. 分布式ID：雪花算法（Snowflake）"></a><strong>2. 分布式ID：雪花算法（Snowflake）</strong></h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>Snowflake 是 Twitter 开源的一种分布式 ID 生成算法，它能生成一个 64 位的 <code>long</code> 型数字作为全局唯一 ID。这个 64 位的 ID 由四部分构成：</p>
<ul>
<li><strong>1位符号位</strong>: 最高位，固定为0，表示正数，无实际意义。</li>
<li><strong>41位时间戳 (Timestamp)</strong>: 精确到毫秒级，是 <code>(当前时间戳 - 起始时间戳)</code> 的差值。41位可以表示 (241−1) 毫秒，大约可以使用 69 年。</li>
<li><strong>10位工作机器ID (Worker ID)</strong>: 这 10 位可以被灵活划分，例如前 5 位代表数据中心 ID (Datacenter ID)，后 5 位代表机器 ID (Machine ID)。这样总共可以支持 210&#x3D;1024 台机器。</li>
<li><strong>12位序列号 (Sequence)</strong>: 表示在同一毫秒内，同一台机器上生成的 ID 序列号。12位意味着每台机器每毫秒可以生成 212&#x3D;4096 个不同的 ID。</li>
</ul>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h5><ul>
<li><strong>全局唯一</strong>: 通过时间戳、机器 ID 和序列号的组合，可以保证在分布式环境下的 ID 唯一性。</li>
<li><strong>趋势递增</strong>: 由于时间戳在高位，所以生成的 ID 整体上是按时间趋势递增的，这对于数据库索引（特别是 B+树）非常友好，可以减少页分裂，提高插入性能。</li>
<li><strong>高性能</strong>: ID 在本地生成，不依赖任何外部服务（如数据库或 Redis），生成效率极高。</li>
<li><strong>高可用</strong>: 算法本身不依赖网络，部署简单，具有很高的可用性。</li>
</ul>
<h5 id="面试题：“雪花算法有时钟回拨问题，如何解决？”"><a href="#面试题：“雪花算法有时钟回拨问题，如何解决？”" class="headerlink" title="面试题：“雪花算法有时钟回拨问题，如何解决？”"></a><strong>面试题：“雪花算法有时钟回拨问题，如何解决？”</strong></h5><p>回答要点:</p>
<p>时钟回拨是指服务器时间被同步到一个过去的时间点。如果算法不做处理，可能会生成重复的 ID。解决方案通常是：在生成 ID 时，记录上一次生成 ID 时所使用的时间戳。当发现当前时间戳小于上次记录的时间戳时，就意味着发生了时钟回拨。</p>
<ul>
<li><strong>方案一（拒绝服务）</strong>: 直接抛出异常，拒绝生成 ID，等待时钟恢复正常。这种方案简单，但会暂时影响可用性，适合对 ID 连续性要求不高的场景。</li>
<li><strong>方案二（等待追赶）</strong>: 如果回拨幅度很小（比如几毫秒），程序可以 <code>while(currentTime &lt; lastTimestamp)</code> 这样自旋等待，直到当前时间追赶上上次的时间戳。这会造成短暂的线程阻塞。</li>
<li><strong>方案三（使用备用位）</strong>: 一些改进版的雪花算法会预留几位作为扩展位，当发生时钟回拨时，在这几位上做自增，从而在短时间回拨内仍能生成不同的 ID。（这种方案实现较为复杂）</li>
<li><strong>业界实践（美团 Leaf）</strong>: 在发生时钟回拨时，切换到另一种备用 ID 生成策略（如号段模式），或者直接报错。</li>
</ul>
<hr>
<h4 id="3-RBAC（基于角色的访问控制）"><a href="#3-RBAC（基于角色的访问控制）" class="headerlink" title="3. RBAC（基于角色的访问控制）"></a><strong>3. RBAC（基于角色的访问控制）</strong></h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>RBAC (Role-Based Access Control) 是一种主流且灵活的权限管理模型。它的核心思想是在 <strong>用户 (User)</strong> 和 <strong>权限 (Permission)</strong> 之间引入一个中间层——<strong>角色 (Role)</strong>。权限不再直接授予用户，而是授予角色；然后将角色分配给用户。这样，用户与权限实现了解耦，当需要修改大量用户的权限时，只需修改他们共同拥有的角色的权限即可，极大地简化了权限管理和维护。</p>
<h5 id="核心三要素"><a href="#核心三要素" class="headerlink" title="核心三要素"></a><strong>核心三要素</strong></h5><ul>
<li><strong>用户 (User)</strong>: 系统操作的主体。</li>
<li><strong>角色 (Role)</strong>: 权限的集合，代表了一组特定的职责或身份，如“管理员”、“文章编辑”、“普通会员”。</li>
<li><strong>权限 (Permission)</strong>: 对系统中特定资源进行特定操作的许可。通常用一个字符串表示，如 <code>user:create</code>、<code>order:delete</code>、<code>article:publish</code>。</li>
</ul>
<h5 id="面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”"><a href="#面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”" class="headerlink" title="面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”"></a><strong>面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”</strong></h5><p>回答要点:</p>
<p>一个基础的 RBAC 模型至少需要五张表：</p>
<ul>
<li><strong>用户表 (t_user)</strong>: 存储用户信息。<ul>
<li><code>user_id</code> (主键), <code>username</code>, <code>password</code>, …</li>
</ul>
</li>
<li><strong>角色表 (t_role)</strong>: 存储角色信息。<ul>
<li><code>role_id</code> (主键), <code>role_name</code> (角色名, 如”管理员”), <code>role_key</code> (角色标识, 如”admin”), …</li>
</ul>
</li>
<li><strong>权限表 (t_permission)</strong>: 存储具体的权限点信息。<ul>
<li><code>permission_id</code> (主键), <code>permission_name</code> (权限名称, 如“新增用户”), <code>permission_code</code> (权限标识, 如 <code>user:add</code>), <code>parent_id</code> (用于菜单层级), …</li>
</ul>
</li>
<li><strong>用户-角色关联表 (t_user_role)</strong>: 存储用户和角色的多对多关系。<ul>
<li><code>user_id</code> (外键), <code>role_id</code> (外键)。(主键是 <code>user_id</code> 和 <code>role_id</code> 的联合主键)</li>
</ul>
</li>
<li><strong>角色-权限关联表 (t_role_permission)</strong>: 存储角色和权限的多对多关系。<ul>
<li><code>role_id</code> (外键), <code>permission_id</code> (外键)。(主键是 <code>role_id</code> 和 <code>permission_id</code> 的联合主键)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-Redis-进阶详解"><a href="#4-Redis-进阶详解" class="headerlink" title="4. Redis 进阶详解"></a><strong>4. Redis 进阶详解</strong></h4><h5 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h5><ul>
<li><strong>基于内存</strong>: Redis 是一个内存数据结构存储系统，所有数据都存放在内存中，因此读写速度极快。</li>
<li><strong>单线程模型</strong>: Redis 的核心网络模型处理客户端请求是单线程的。这避免了多线程环境下的上下文切换和锁竞争带来的开销。（注意：Redis 6.0 之后引入了多线程来处理 I&#x2F;O，但执行命令的核心仍然是单线程）。</li>
<li><strong>IO多路复用</strong>: 单线程能实现高性能的关键在于它使用了 IO 多路复用技术（如 Linux 下的 epoll）。该技术允许单个线程同时监听多个网络连接上的 IO 事件，当某个连接准备好读或写时，才去处理它，极大地提高了并发处理能力。</li>
<li><strong>丰富的数据类型</strong>: 支持 String, Hash, List, Set, Sorted Set, Bitmap, HyperLogLog, GEO 等多种数据结构。</li>
</ul>
<h5 id="缓存三大问题与解决方案"><a href="#缓存三大问题与解决方案" class="headerlink" title="缓存三大问题与解决方案"></a><strong>缓存三大问题与解决方案</strong></h5><ul>
<li><strong>缓存穿透</strong>:<ul>
<li><strong>问题</strong>: 客户端查询一个数据库和缓存中<strong>都</strong>不存在的数据。这导致每次请求都会绕过缓存，直接打到数据库上，当有大量此类请求时，会给数据库带来巨大压力。</li>
<li><strong>解决</strong>:<ol>
<li><strong>缓存空对象</strong>: 当从数据库查询不到数据时，也在缓存中存入一个特殊的空值（如 <code>null</code> 或特定字符串），并设置一个较短的过期时间。</li>
<li><strong>布隆过滤器 (Bloom Filter)</strong>: 在访问缓存之前，先通过布隆过滤器判断 key 是否<strong>可能</strong>存在。布隆过滤器可以高效地判断一个元素<strong>一定不存在</strong>，从而在第一层就拦截掉大量无效请求。</li>
</ol>
</li>
</ul>
</li>
<li><strong>缓存击穿</strong>:<ul>
<li><strong>问题</strong>: 某个<strong>热点 Key</strong> 在某一时刻突然失效，而此时恰好有大量的并发请求访问这个 Key，这些请求会同时穿透缓存，直接打到数据库上，可能导致数据库瞬间崩溃。</li>
<li><strong>解决</strong>:<ol>
<li><strong>设置热点 Key 永不过期</strong>: 对于一些访问极其频繁且数据相对固定的热点数据，可以考虑不设置过期时间，通过后台任务定时更新。</li>
<li><strong>使用分布式锁</strong>: 在查询数据库之前，先获取一个该 Key 对应的分布式锁。只有第一个获取到锁的线程才能去查询数据库并回写缓存，其他线程则等待或直接返回。</li>
</ol>
</li>
</ul>
</li>
<li><strong>缓存雪崩</strong>:<ul>
<li><strong>问题</strong>: 大量的缓存 Key 在<strong>同一时间集中失效</strong>（例如，在应用启动时缓存了大量数据，并设置了相同的过期时间），导致所有请求都瞬间涌向数据库，造成数据库压力剧增甚至宕机。</li>
<li><strong>解决</strong>:<ol>
<li><strong>过期时间加随机值</strong>: 在设置缓存的过期时间时，在一个基础时间上增加一个随机数，使得 Key 的失效时间点尽可能分散。</li>
<li><strong>多级缓存</strong>: 建立多级缓存体系，如 Nginx 缓存 + Redis 缓存 + JVM 本地缓存（Caffeine&#x2F;Guava Cache）。</li>
<li><strong>熔断降级</strong>: 使用 Hystrix 或 Sentinel 等组件，当检测到数据库压力过大时，进行熔断或降级处理，暂时不访问数据库，返回一个默认值或提示信息。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-消息队列（MQ）"><a href="#5-消息队列（MQ）" class="headerlink" title="5. 消息队列（MQ）"></a><strong>5. 消息队列（MQ）</strong></h4><h5 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a><strong>核心作用</strong></h5><ul>
<li><strong>异步 (Asynchronous)</strong>: 将耗时的操作（如发送邮件、生成报表）作为消息放入 MQ，主流程可以立即返回，无需等待这些操作完成，从而提高系统的响应速度和吞吐量。</li>
<li><strong>解耦 (Decoupling)</strong>: 生产者和消费者之间通过 MQ 进行通信，无需直接相互依赖。任何一方的修改、宕机或升级都不会影响到另一方，增强了系统的灵活性和可维护性。</li>
<li><strong>削峰 (Peak Shaving)</strong>: 在秒杀、大促等高并发场景下，将瞬时涌入的大量请求暂存在 MQ 中，下游的消费者系统可以按照自己的处理能力，平稳地从 MQ 中拉取并处理请求，避免了流量洪峰直接冲垮下游服务。</li>
</ul>
<h5 id="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"><a href="#面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”" class="headerlink" title="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"></a><strong>面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”</strong></h5><p><strong>回答要点</strong>:</p>
<ul>
<li><strong>消息丢失 (Message Loss)</strong>:<ul>
<li><strong>问题</strong>: 消息从生产者发出后，由于网络或 MQ 服务故障，未能成功到达消费者。</li>
<li><strong>解决</strong>:<ol>
<li><strong>生产者端</strong>: 开启生产者的 <code>confirm</code> 或 <code>ack</code> 机制，确保消息被 MQ 成功接收。如果发送失败，可以进行重试。</li>
<li><strong>MQ 服务端</strong>: 对消息进行持久化，防止 MQ 宕机导致消息丢失（如 RabbitMQ 的持久化队列和消息，Kafka 的磁盘存储）。</li>
<li><strong>消费者端</strong>: 消费者在处理完业务逻辑后，再向 MQ 发送确认应答（<code>ack</code>）。如果处理过程中消费者宕机，MQ 没有收到 <code>ack</code>，会将该消息重新投递给其他消费者。</li>
</ol>
</li>
</ul>
</li>
<li><strong>重复消费 (Duplicate Consumption)</strong>:<ul>
<li><strong>问题</strong>: 由于网络抖动、消费者 <code>ack</code> 超时等原因，MQ 可能会重复投递同一条消息。</li>
<li><strong>解决</strong>: 核心是保证消费逻辑的<strong>幂等性 (Idempotence)</strong>。即多次执行同一个操作，结果都是相同的。实现方式有：<ol>
<li>在数据库中为业务操作创建一个<strong>唯一键</strong>，每次操作前先检查该唯一键是否存在。</li>
<li>使用一个全局唯一的<strong>业务 ID</strong>（如订单号），在处理消息前，先查询这个 ID 是否已经被处理过（例如，存入 Redis Set 或数据库）。</li>
</ol>
</li>
</ul>
</li>
<li><strong>消息堆积 (Message Backlog)</strong>:<ul>
<li><strong>问题</strong>: 生产者的生产速度远大于消费者的消费速度，导致大量消息在 MQ 中积压，占用资源并可能导致消息超时丢失。</li>
<li><strong>解决</strong>:<ol>
<li><strong>水平扩展消费者</strong>: 增加消费者实例的数量，并行处理消息。这是最常用的方法。</li>
<li><strong>优化消费逻辑</strong>: 检查消费者代码，看是否有可以优化的慢操作（如 I&#x2F;O 密集型操作）。</li>
<li><strong>消息分片&#x2F;分区</strong>: 对 Topic 进行分区（Partitioning），让不同的消费者组处理不同的分区，提高并发度。</li>
<li><strong>增加预警监控</strong>: 对消息堆积数量设置阈值，达到阈值时及时告警，人工介入。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-分布式锁详解"><a href="#6-分布式锁详解" class="headerlink" title="6. 分布式锁详解"></a><strong>6. 分布式锁详解</strong></h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在分布式系统环境下，多个进程或服务器上的多个线程需要访问同一个共享资源时，为了保证数据的一致性和操作的原子性，需要一种机制来确保在同一时刻，只有一个客户端能够持有锁并访问该资源。</p>
<h5 id="实现方案对比"><a href="#实现方案对比" class="headerlink" title="实现方案对比"></a><strong>实现方案对比</strong></h5><table>
<thead>
<tr>
<th>实现方式</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基于数据库</strong></td>
<td>实现简单，直接利用数据库（如唯一索引、悲观锁 <code>for update</code>）。</td>
<td>性能开销大，有锁库锁表的风险，不可重入，不是阻塞锁，数据库单点故障问题。</td>
<td>并发度不高的简单场景。</td>
</tr>
<tr>
<td><strong>基于 ZooKeeper</strong></td>
<td>可靠性高，天然支持阻塞锁和可重入，解决死锁问题（临时节点），无锁过期问题，支持公平锁。</td>
<td>性能不如 Redis，实现复杂，依赖 ZK 集群。</td>
<td>对可靠性要求极高，且能容忍一定性能损耗的场景，如分布式协调。</td>
</tr>
<tr>
<td><strong>基于 Redis</strong></td>
<td>性能极高，实现相对简单，有成熟的框架 (Redisson) 可用。</td>
<td>可靠性相对 ZK 稍差，需要处理锁过期和业务未执行完的问题，非公平锁。</td>
<td>互联网高并发、对性能要求高的绝大多数场景。</td>
</tr>
</tbody></table>
<h5 id="基于-Redis-的实现进阶"><a href="#基于-Redis-的实现进阶" class="headerlink" title="基于 Redis 的实现进阶"></a><strong>基于 Redis 的实现进阶</strong></h5><ul>
<li><p>加锁的正确姿势:</p>
<p>使用 SET key value NX EX time 命令。</p>
<ul>
<li><p><code>SET key value</code>: 设置键值。<code>value</code> 通常是一个唯一的随机字符串（如 UUID），用于标识锁的持有者。</p>
</li>
<li><p><code>NX</code>: (if Not eXists)，确保只有在 key 不存在时才能设置成功，实现了“加锁”的原子性。</p>
</li>
<li><p>EX time: 设置一个自动过期时间（秒），防止因客户端宕机而导致死锁。</p>
<p>这三个参数必须在一个命令中执行，保证原子性。</p>
</li>
</ul>
</li>
<li><p><strong>解锁的正确姿势：Lua 脚本</strong></p>
<ul>
<li><p><strong>为什么需要 Lua</strong>: 解锁操作包含“判断”和“删除”两步：1. <code>GET</code> 锁的 <code>value</code>，判断是否与自己加锁时设置的随机字符串相等。2. 如果相等，则 <code>DEL</code> 锁。如果不用 Lua 脚本，在执行完第一步后，若该线程阻塞，此时锁恰好过期，另一个线程获取了锁，那么当原线程恢复执行第二步时，就会<strong>误删掉新线程的锁</strong>。</p>
</li>
<li><p><strong>Lua 脚本示例</strong>:</p>
<p>Lua</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 脚本接收两个参数：KEYS[1] 是锁的 key，ARGV[1] 是加锁时设置的唯一值</span><br><span class="line">if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Lua 脚本可以确保多个命令在 Redis 服务端被原子性地执行，杜绝了上述问题。</p>
</li>
<li><p><strong>Redis 乐观锁：WATCH 命令</strong></p>
<ul>
<li><p><strong>作用</strong>: <code>WATCH</code> 命令可以监视一个或多个 key，如果在事务 <code>EXEC</code> 执行之前，任何一个被监视的 key 被其他命令修改了，那么整个事务将被取消，<code>EXEC</code> 返回 <code>nil</code>。</p>
</li>
<li><p><strong>原理</strong>: 这是一种<strong>检查后设置 (Check-And-Set, CAS)</strong> 的实现。它不是真正的加锁，而是在更新数据时检查数据是否被修改过。</p>
</li>
<li><p><strong>使用场景</strong>: 适用于<strong>读多写少</strong>的并发场景，可以减少锁的开销。例如，更新商品库存。</p>
<ol>
<li><p><code>WATCH stock_key</code> &#x2F;&#x2F; 监视库存</p>
</li>
<li><p><code>current_stock = GET stock_key</code> &#x2F;&#x2F; 获取当前库存</p>
</li>
<li><p>(在客户端代码中判断 <code>current_stock</code> 是否足够)</p>
</li>
<li><p><code>MULTI</code> &#x2F;&#x2F; 开启事务</p>
</li>
<li><p><code>SET stock_key new_stock</code> &#x2F;&#x2F; 准备更新库存</p>
</li>
<li><p>EXEC &#x2F;&#x2F; 执行事务</p>
<p>如果从 WATCH 到 EXEC 之间 stock_key 被其他客户端修改，EXEC 将失败，此时客户端需要重试整个操作。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”"><a href="#面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”" class="headerlink" title="面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”"></a><strong>面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”</strong></h5><p>回答要点:</p>
<p>这是分布式锁的一个经典问题，被称为锁的超时续期问题。</p>
<ul>
<li><strong>问题根源</strong>: 我们给锁设置了一个过期时间，比如 30 秒，但业务执行了 35 秒。在第 30 秒时锁会自动释放，其他线程就能获取到锁，导致并发问题。</li>
<li><strong>解决方案：“看门狗”(Watchdog)机制</strong>。<ul>
<li><strong>原理</strong>: 比如 Java 中的 Redisson 框架就内置了看门狗。当一个线程获取锁成功后，Redisson 会启动一个后台线程（看门狗），定期（例如每 10 秒）检查该线程是否还持有锁。如果持有，并且业务仍在执行，看门狗就会自动为这个锁<strong>延长过期时间</strong>（续期），比如再续 30 秒。这个过程会一直持续，直到业务执行完毕，线程主动释放锁，看门狗才会停止。</li>
<li><strong>总结</strong>: 看门狗机制通过后台线程自动续期，确保了在业务执行完成之前，锁不会因为超时而提前释放，从而保证了锁的可靠性。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-分布式事务详解"><a href="#7-分布式事务详解" class="headerlink" title="7. 分布式事务详解"></a><strong>7. 分布式事务详解</strong></h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在微服务架构中，一个业务操作可能需要调用多个独立的服务来共同完成（例如，电商下单操作需要调用订单服务、库存服务、积分服务）。分布式事务旨在保证这些跨服务的数据库操作能够遵循 ACID 原则，要么全部成功，要么全部回滚，以确保数据的<strong>最终一致性</strong>。</p>
<h5 id="解决方案深入分析"><a href="#解决方案深入分析" class="headerlink" title="解决方案深入分析"></a><strong>解决方案深入分析</strong></h5><ul>
<li><strong>XA (2PC&#x2F;3PC)</strong>: 两阶段&#x2F;三阶段提交协议。<ul>
<li><strong>角色</strong>: 事务管理器 (Transaction Manager, TM) 和 资源管理器 (Resource Manager, RM)。</li>
<li><strong>流程 (2PC)</strong>:<ol>
<li><strong>准备阶段 (Prepare)</strong>: TM 通知所有 RM 准备提交，RM 执行本地事务并锁定资源，但不提交，然后向 TM 报告准备就绪。</li>
<li><strong>提交&#x2F;回滚阶段 (Commit&#x2F;Rollback)</strong>: 如果所有 RM 都准备就绪，TM 通知所有 RM 提交；否则，通知所有 RM 回滚。</li>
</ol>
</li>
<li><strong>评价</strong>: 是一种<strong>强一致性</strong>的方案，但协议复杂，性能差，同步阻塞模型会长时间锁定资源，且协调器存在单点故障风险，在互联网高并发场景下<strong>很少使用</strong>。</li>
</ul>
</li>
<li><strong>TCC (Try-Confirm-Cancel)</strong>: 补偿型事务。<ul>
<li><strong>核心</strong>: 是一种<strong>业务层面</strong>的柔性事务方案，对代码侵入性强。</li>
<li><strong>流程</strong>:<ol>
<li><strong>Try</strong>: 对业务资源进行<strong>检查和预留</strong>。例如，扣减库存操作，Try 阶段是冻结库存。</li>
<li><strong>Confirm</strong>: 如果所有服务的 Try 阶段都成功，则执行所有服务的 <strong>Confirm</strong> 操作，真正完成业务。例如，将冻结的库存真实扣减。</li>
<li><strong>Cancel</strong>: 如果任何一个服务的 Try 阶段失败，则执行所有已成功服务的 <strong>Cancel</strong> 操作，释放预留的资源。例如，解冻之前被冻结的库存。</li>
</ol>
</li>
<li><strong>评价</strong>: 性能较好，数据一致性高于可靠消息方案。但开发成本极高，需要为每个操作都编写 Try, Confirm, Cancel 三个幂等的方法。</li>
</ul>
</li>
<li><strong>Saga 模式</strong>: 长事务解决方案。<ul>
<li><strong>核心</strong>: 将一个大的分布式事务拆分成多个<strong>本地事务</strong>，每个本地事务都有一个对应的<strong>补偿操作</strong>。</li>
<li><strong>流程</strong>:<ul>
<li><strong>正向执行</strong>: Saga 协调器按顺序调用 T1, T2, T3…Tn。</li>
<li><strong>反向补偿</strong>: 如果 Ti 失败，Saga 会按相反顺序调用前面已成功事务的补偿操作 C(i-1)…C2, C1，进行回滚。</li>
</ul>
</li>
<li><strong>与 TCC 对比</strong>:<ul>
<li>TCC 有资源<strong>预留</strong>阶段，锁资源时间长；Saga 没有预留，直接提交本地事务，锁资源时间短。</li>
<li>TCC 的补偿是<strong>逆向操作</strong> (Cancel)；Saga 的补偿是<strong>反向操作</strong>。</li>
</ul>
</li>
<li><strong>评价</strong>: 适合于业务流程长、需要保证最终一致性的场景。同样对代码有侵入性，需要设计好每个子事务的补偿逻辑。</li>
</ul>
</li>
<li><strong>基于可靠消息的最终一致性 (常用)</strong>:<ul>
<li><strong>核心</strong>: 这是微服务架构中<strong>最常用</strong>的柔性事务方案。</li>
<li><strong>原理</strong>: 服务 A 在执行完本地事务后，发送一条消息到 MQ。服务 B 订阅该消息，消费消息并执行自己的本地事务。</li>
<li><strong>关键问题</strong>: 如何保证<strong>本地事务执行</strong>和<strong>消息发送</strong>的原子性？<ul>
<li><strong>事务消息 (RocketMQ 支持)</strong>: 生产者先发送一条“半消息”到 MQ，MQ 收到后不投递。然后生产者执行本地事务。如果事务成功，则向 MQ 发送确认，MQ 投递该消息；如果事务失败，则通知 MQ 删除该半消息。</li>
<li><strong>本地消息表</strong>: 业务操作和“待发送消息”记录在同一本地事务中。一个后台任务定时扫描这张表，将消息发送到 MQ，发送成功后更新表状态。</li>
</ul>
</li>
<li><strong>评价</strong>: 实现了服务间的解耦，性能高，吞吐量大。但它不保证数据的强一致性，只保证<strong>最终一致性</strong>，存在一个短暂的数据不一致状态窗口。需要处理好消息的可靠投递和幂等消费问题。</li>
</ul>
</li>
</ul>
<h3 id="Lua-脚本详解-在-Redis-中的应用"><a href="#Lua-脚本详解-在-Redis-中的应用" class="headerlink" title="Lua 脚本详解 (在 Redis 中的应用)"></a><strong>Lua 脚本详解 (在 Redis 中的应用)</strong></h3><h4 id="1-Lua-是什么？"><a href="#1-Lua-是什么？" class="headerlink" title="1. Lua 是什么？"></a><strong>1. Lua 是什么？</strong></h4><p>Lua 是一种轻量级、可扩展的脚本语言，被设计用于嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。它以其简洁的语法、高效的执行性能和极小的内存占用而闻名。</p>
<p>在 Redis 的上下文中，Lua 脚本提供了一种在 Redis 服务器端执行复杂逻辑的强大能力。</p>
<h4 id="2-为什么-Redis-要支持-Lua-脚本？"><a href="#2-为什么-Redis-要支持-Lua-脚本？" class="headerlink" title="2. 为什么 Redis 要支持 Lua 脚本？"></a><strong>2. 为什么 Redis 要支持 Lua 脚本？</strong></h4><ul>
<li><strong>原子性 (Atomicity)</strong>: 这是在 Redis 中使用 Lua 最核心的原因。Redis 会将整个 Lua 脚本作为一个单独的命令来执行，<strong>在脚本执行期间，不会有其他客户端的命令被插入执行</strong>。这完美地解决了需要组合多个 Redis 命令才能完成一个业务逻辑时，可能出现的竞态条件问题。例如前面提到的“判断锁并删除锁”的操作，如果分两步执行，就不是原子的，而封装在 Lua 脚本中就是原子的。</li>
<li><strong>减少网络开销</strong>: 对于需要多次与 Redis 交互的复杂操作，可以将所有逻辑封装在一个 Lua 脚本中，一次性发送给 Redis 服务器。客户端只需发送一次请求，而不是多次，这显著减少了客户端与服务器之间的网络往返时间（RTT），提升了性能。</li>
<li><strong>代码复用</strong>: 编写好的 Lua 脚本可以被缓存（通过 <code>SCRIPT LOAD</code> 命令生成一个 SHA1 校验和），之后客户端可以通过这个简短的 SHA1 校验和（使用 <code>EVALSHA</code> 命令）来调用脚本，避免了每次都发送完整的脚本内容。</li>
</ul>
<h4 id="3-如何在-Redis-中使用-Lua-脚本？"><a href="#3-如何在-Redis-中使用-Lua-脚本？" class="headerlink" title="3. 如何在 Redis 中使用 Lua 脚本？"></a><strong>3. 如何在 Redis 中使用 Lua 脚本？</strong></h4><p>通过 EVAL 或 EVALSHA 命令来执行。</p>
<p>EVAL script numkeys key [key …] arg [arg …]</p>
<ul>
<li><code>script</code>: 要执行的 Lua 脚本字符串。</li>
<li><code>numkeys</code>: 后面跟的 <code>key</code> 参数的数量。这有助于 Redis 正确地将参数区分为键名（<code>KEYS</code>）和普通参数（<code>ARGV</code>），这对于 Redis Cluster 模式下的路由至关重要。</li>
<li><code>key [key ...]</code>：脚本中要操作的 Redis 键，在 Lua 脚本中可以通过全局变量 <code>KEYS</code> table（例如 <code>KEYS[1]</code>）来访问。</li>
<li><code>arg [arg ...]</code>：传递给脚本的额外参数，在 Lua 脚本中可以通过全局变量 <code>ARGV</code> table（例如 <code>ARGV[1]</code>）来访问。</li>
</ul>
<p><strong>示例：实现一个安全的库存扣减</strong></p>
<p>Lua</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 脚本逻辑：检查库存是否充足，如果充足则扣减并返回1，否则返回0</span><br><span class="line">-- KEYS[1]: 库存的 key，例如 &quot;product:1001:stock&quot;</span><br><span class="line">-- ARGV[1]: 本次要扣减的数量</span><br><span class="line"></span><br><span class="line">local stock = tonumber(redis.call(&#x27;get&#x27;, KEYS[1]))</span><br><span class="line">local quantity = tonumber(ARGV[1])</span><br><span class="line"></span><br><span class="line">if stock &gt;= quantity then</span><br><span class="line">    redis.call(&#x27;decrby&#x27;, KEYS[1], quantity)</span><br><span class="line">    return 1</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这个脚本保证了“读取库存”和“扣减库存”两个操作的原子性，避免了在高并发下超卖的问题。</p>
<hr>
<h3 id="Token-认证机制详解"><a href="#Token-认证机制详解" class="headerlink" title="Token 认证机制详解"></a><strong>Token 认证机制详解</strong></h3><h4 id="1-Token-是什么？"><a href="#1-Token-是什么？" class="headerlink" title="1. Token 是什么？"></a><strong>1. Token 是什么？</strong></h4><p>Token（令牌）是在服务端生成的一串加密字符串，作为客户端进行请求的一个“凭证”。当用户第一次登录成功后，服务端会生成一个 Token 并返回给客户端。之后，客户端在每次请求需要身份认证的接口时，都需要在请求头（通常是 <code>Authorization</code> 字段）中携带这个 Token。服务端接收到请求后，会验证 Token 的有效性，如果验证通过，则处理该请求；否则，拒绝该请求。</p>
<p>一个典型的 Token 是 <strong>JWT (JSON Web Token)</strong>，它由三部分组成，用 <code>.</code> 分隔：</p>
<ul>
<li><strong>Header (头部)</strong>: 包含了令牌的类型（<code>typ</code>，即 JWT）和所使用的签名算法（<code>alg</code>，如 HMAC SHA256 或 RSA）。</li>
<li><strong>Payload (负载)</strong>: 包含了“声明 (claims)”，是存放实际需要传递的数据的地方。例如用户ID（<code>sub</code>）、签发时间（<code>iat</code>）、过期时间（<code>exp</code>）以及其他自定义的用户信息。<strong>注意：Payload 部分是 Base64 编码的，并非加密，因此不应存放敏感信息。</strong></li>
<li><strong>Signature (签名)</strong>: 对前两部分（Header 和 Payload）使用指定的算法和存储在服务端的密钥（secret）进行签名。这个签名的作用是<strong>防止数据被篡改</strong>。服务端收到 Token 后，会用同样的算法和密钥重新计算签名，并与 Token 中的签名进行比对，若一致，则说明 Token 未被篡改且是可信的。</li>
</ul>
<h4 id="2-Token-认证原理（工作流程）"><a href="#2-Token-认证原理（工作流程）" class="headerlink" title="2. Token 认证原理（工作流程）"></a><strong>2. Token 认证原理（工作流程）</strong></h4><ol>
<li><strong>登录</strong>: 用户使用用户名和密码发起登录请求。</li>
<li><strong>验证</strong>: 服务端验证用户的凭据是否正确。</li>
<li><strong>签发 Token</strong>: 验证成功后，服务端根据用户ID、角色等信息，结合密钥（secret），生成一个 Token。</li>
<li><strong>返回 Token</strong>: 服务端将生成的 Token 返回给客户端。</li>
<li><strong>存储 Token</strong>: 客户端（浏览器、App）将 Token 存储起来，通常放在 <code>localStorage</code>、<code>sessionStorage</code> 或 <code>HttpOnly</code> 的 Cookie 中。</li>
<li><strong>携带 Token 请求</strong>: 客户端在后续每次请求受保护的 API 时，都会在 HTTP 请求头的 <code>Authorization</code> 字段中附上 Token，格式通常为 <code>Bearer &lt;token&gt;</code>。</li>
<li><strong>验证 Token</strong>: 服务端收到请求后，从请求头中解析出 Token，然后：<ul>
<li>验证签名是否正确，确保 Token 未被篡改。</li>
<li>检查 Token 是否在有效期内（<code>exp</code> 声明）。</li>
<li>如果验证通过，则从 Payload 中获取用户信息，执行业务逻辑并返回结果。</li>
<li>如果验证失败，则返回 <code>401 Unauthorized</code> 错误。</li>
</ul>
</li>
</ol>
<h4 id="3-为什么使用-Token？（与-Session-的区别）"><a href="#3-为什么使用-Token？（与-Session-的区别）" class="headerlink" title="3. 为什么使用 Token？（与 Session 的区别）"></a><strong>3. 为什么使用 Token？（与 Session 的区别）</strong></h4><p>在 Web 开发早期，<code>Session-Cookie</code> 机制是主流。服务端在用户登录后创建一个 Session 对象存储在内存或 Redis 中，并生成一个 Session ID，通过 Cookie 返回给浏览器。浏览器后续请求会自动带上这个 Session ID，服务端根据 ID 找到对应的 Session 信息来识别用户。</p>
<p><strong>Token 机制相比 Session 机制，核心优势在于“无状态性 (Statelessness)”</strong>，这带来了以下好处：</p>
<table>
<thead>
<tr>
<th>特性对比</th>
<th>Session 机制</th>
<th>Token 机制</th>
<th>优势说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>状态存储</strong></td>
<td><strong>有状态 (Stateful)</strong>。Session 信息需存储在服务端。</td>
<td><strong>无状态 (Stateless)</strong>。用户信息包含在 Token 的 Payload 中，服务端无需存储。</td>
<td><strong>减轻服务端压力</strong>。服务端不需要为每个在线用户维护一个 Session 对象。</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td><strong>差</strong>。在分布式或集群环境下，需要解决 Session 共享问题（如 Session Sticky、Session Replication、集中存储）。</td>
<td><strong>好</strong>。由于服务端不存储状态，任何一台服务器只要有相同的密钥，就能验证 Token，天然适合分布式和微服务架构。</td>
<td><strong>轻松实现水平扩展</strong>。增加服务器节点无需额外配置 Session 共享。</td>
</tr>
<tr>
<td><strong>跨域支持</strong></td>
<td><strong>有限</strong>。基于 Cookie 的 Session 机制在跨域（CORS）场景下处理起来比较麻烦。</td>
<td><strong>优秀</strong>。Token 可以通过 HTTP 请求头发送，不受同源策略限制，非常适合前后端分离和跨域 API 调用。</td>
<td><strong>适应现代架构</strong>。完美支持 SPA（单页应用）、移动 App 等多种客户端。</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>依赖 Cookie 机制，可能遭受 CSRF 攻击。</td>
<td>如果 Token 存储在 <code>localStorage</code>，可能遭受 XSS 攻击。需要综合考虑存储方式。</td>
<td>两者各有安全风险点，需配合其他安全策略。Token 机制不依赖 Cookie，更灵活。</td>
</tr>
<tr>
<td><strong>适用性</strong></td>
<td>适合传统的、一体化的 Web 应用。</td>
<td>适合现代的、分布式的、跨终端的（Web, Mobile, IoT）应用架构。</td>
<td>Token 更具通用性和前瞻性。</td>
</tr>
</tbody></table>
<h4 id="4-双令牌策略-Access-Token-Refresh-Token"><a href="#4-双令牌策略-Access-Token-Refresh-Token" class="headerlink" title="4. 双令牌策略 (Access Token + Refresh Token)"></a><strong>4. 双令牌策略 (Access Token + Refresh Token)</strong></h4><ul>
<li><strong>Q: 为什么不用单个 Token？</strong><ul>
<li><strong>如果 Token 有效期很长（如一个月）</strong>: 安全风险高。一旦 Token 在此期间被窃取，攻击者可以长时间冒充用户身份进行操作。</li>
<li><strong>如果 Token 有效期很短（如 15 分钟）</strong>: 用户体验差。用户需要频繁地重新登录，这是无法接受的。</li>
</ul>
</li>
<li><strong>A: 双令牌策略应运而生，完美平衡了安全性和用户体验。</strong><ul>
<li><strong>Access Token (访问令牌)</strong>: 它的有效期<strong>非常短</strong>（如 15 分钟到 1 小时）。它被用于访问受保护的资源，由于其生命周期短，即使被窃取，攻击者能造成的危害也有限。</li>
<li><strong>Refresh Token (刷新令牌)</strong>: 它的有效期<strong>很长</strong>（如 7 天或 30 天）。它的<strong>唯一作用</strong>是用来获取新的 Access Token。Refresh Token 本身不包含任何权限信息，不能用于直接访问 API。</li>
</ul>
</li>
<li><strong>双令牌工作流程（静默刷新）</strong><ol>
<li><strong>首次登录</strong>: 用户登录成功，服务端返回一个短期的 <code>Access Token</code> 和一个长期的 <code>Refresh Token</code>。客户端将两者都存储起来。</li>
<li><strong>正常访问</strong>: 客户端使用 <code>Access Token</code> 访问 API。服务端验证 <code>Access Token</code> 通过，返回数据。</li>
<li><strong>Access Token 过期</strong>: 客户端再次使用过期的 <code>Access Token</code> 访问 API，服务端返回 <code>401 Unauthorized</code> 错误，并可能带上一个特定错误码，告知客户端是“令牌过期”而非“无效令牌”。</li>
<li><strong>静默刷新</strong>: 客户端的请求拦截器捕获到这个 <code>401</code> 错误后，<strong>不会立即跳转到登录页</strong>。而是自动发起一个特殊的请求，携带那个长期的 <code>Refresh Token</code> 去访问一个专门的刷新接口（如 <code>/api/token/refresh</code>）。</li>
<li><strong>签发新令牌</strong>: 服务端验证 <code>Refresh Token</code> 的有效性（通常会将其存储在 Redis 或数据库中进行比对，以实现强制下线功能）。如果验证通过，就生成一个<strong>新的 Access Token</strong>（有时也会生成一个新的 <code>Refresh Token</code>，这被称为刷新令牌滚动策略）并返回给客户端。</li>
<li><strong>重试请求</strong>: 客户端收到新的 <code>Access Token</code> 后，用它替换掉本地旧的 <code>Access Token</code>，然后<strong>自动重新发送刚才因令牌过期而失败的那个请求</strong>。</li>
<li><strong>无感体验</strong>: 整个过程对用户是透明的，用户感觉不到令牌已经过期并被刷新，实现了“静默刷新”，体验非常流畅。</li>
<li><strong>Refresh Token 过期</strong>: 如果 <code>Refresh Token</code> 也过期了，那么刷新接口会返回错误，此时客户端才会真正清除用户凭证并引导用户重新登录。</li>
</ol>
</li>
</ul>
<h4 id="5-Token-相关场景与面试题"><a href="#5-Token-相关场景与面试题" class="headerlink" title="5. Token 相关场景与面试题"></a><strong>5. Token 相关场景与面试题</strong></h4><ul>
<li><strong>面试题 1：“Token 应该存储在哪里？localStorage、sessionStorage 还是 Cookie？”</strong><ul>
<li><strong>回答要点</strong>:<ul>
<li><strong>localStorage&#x2F;sessionStorage</strong>:<ul>
<li><strong>优点</strong>: 方便 JavaScript 直接读写，容量较大（5MB）。</li>
<li><strong>缺点</strong>: 容易受到 <strong>XSS (跨站脚本攻击)</strong>。如果网站存在 XSS 漏洞，攻击者可以执行 JS 代码直接窃取存储在其中的 Token。</li>
</ul>
</li>
<li><strong>Cookie (HttpOnly)</strong>:<ul>
<li><strong>优点</strong>: 设置为 <code>HttpOnly</code> 后，JavaScript 将无法读写该 Cookie，可以有效<strong>防御 XSS 攻击</strong>。浏览器会自动在同域请求中携带它。</li>
<li><strong>缺点</strong>: 容易受到 <strong>CSRF (跨站请求伪造)</strong> 攻击。攻击者可以诱导用户点击恶意链接，浏览器会自动带上用户的 Cookie 去请求你的网站，执行非用户本意的操作。需要配合 Anti-CSRF Token 等机制来防御。容量较小（4KB）。</li>
</ul>
</li>
<li><strong>最佳实践&#x2F;结论</strong>: 没有绝对完美的选择，需要权衡。<ul>
<li><strong>高安全性方案</strong>: 将 <code>Refresh Token</code> 存储在 <code>HttpOnly</code> 的 Cookie 中（防止 XSS），将 <code>Access Token</code> 存储在内存中（变量里，页面刷新丢失）或 <code>sessionStorage</code> 中。同时，后端接口必须实施 CSRF 防御策略。</li>
<li><strong>主流实践方案 (前后端分离)</strong>: 将 Token 存储在 <code>localStorage</code> 中，并在 <code>Authorization</code> 请求头中携带。同时，前端必须严格做好输入过滤和内容转义，尽最大努力防止 XSS 漏洞的出现。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>面试题 2：“用户点击“退出登录”时，Token 如何失效？”</strong><ul>
<li><strong>回答要点</strong>:<ul>
<li><strong>对于无状态的 JWT</strong>: 由于所有信息都在 Token 自身，服务端无法主动让其失效。因此，“退出登录”主要是一个<strong>客户端行为</strong>。<ul>
<li><strong>客户端</strong>: 只需从 <code>localStorage</code> 或其他存储位置清除 Token 即可。用户将无法再发起认证请求。</li>
</ul>
</li>
<li><strong>如何实现服务端强制下线？</strong>: 如果需要实现“踢人下线”或“修改密码后所有设备强制下线”的功能，就必须打破纯粹的无状态。<ul>
<li><strong>黑名单机制</strong>: 服务端可以建立一个 Token 黑名单（例如，使用 Redis Set）。当用户退出登录时，将该 Token 的 <code>jti</code> (JWT ID) 或整个 Token 放入黑名单，并设置与 Token 剩余有效期相同的过期时间。在每次验证 Token 时，除了常规验证，还需检查该 Token 是否在黑名单中。</li>
<li><strong>基于 Refresh Token</strong>: 在双令牌模式下，退出登录时只需让服务端的 <code>Refresh Token</code> 失效（例如，从 Redis 中删除）。这样用户就无法再获取新的 <code>Access Token</code>，当旧的 <code>Access Token</code> 过期后，自然就下线了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>面试题 3：“请你设计一个支持 Web 端和 App 端统一登录的认证系统。”</strong><ul>
<li><strong>回答要点</strong>:<ul>
<li>这正是 Token 认证机制的典型应用场景。我会采用基于 <strong>OAuth 2.0&#x2F;OIDC</strong> 或自定义的**双令牌（Access&#x2F;Refresh Token）**方案。</li>
<li><strong>统一认证中心 (UAC)</strong>: 建立一个独立的认证服务，负责处理所有客户端（Web, iOS, Android）的登录、注册、Token 签发和刷新。</li>
<li><strong>API 网关</strong>: 所有业务请求都通过 API 网关。网关的核心职责之一就是<strong>统一鉴权</strong>。它会拦截所有请求，解析 <code>Authorization</code> 头中的 <code>Access Token</code>，调用认证中心或自行验证 Token 的有效性。验证通过后，可以将解析出的用户信息（如用户ID）附加到请求头中，再转发给后端的业务微服务。</li>
<li><strong>业务微服务</strong>: 业务微服务本身<strong>不再关心 Token 的验证细节</strong>，它们信任来自网关的请求，直接从请求头中获取用户信息进行业务处理，实现了业务与认证的解耦。</li>
<li><strong>流程</strong>:<ol>
<li>Web&#x2F;App 客户端引导用户到认证中心进行登录。</li>
<li>登录成功后，认证中心返回 <code>Access Token</code> 和 <code>Refresh Token</code>。</li>
<li>客户端保存令牌，后续访问业务 API 时，在请求头携带 <code>Access Token</code>。</li>
<li>API 网关拦截请求，验证 <code>Access Token</code>。</li>
<li><code>Access Token</code> 过期后，客户端使用 <code>Refresh Token</code> 向认证中心申请新令牌。</li>
</ol>
</li>
<li>这个架构具有高内聚、低耦合、可扩展性强、安全性高的优点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Redis-详细技术解析"><a href="#Redis-详细技术解析" class="headerlink" title="Redis 详细技术解析"></a>Redis 详细技术解析</h1><h2 id="Redis-核心架构与原理"><a href="#Redis-核心架构与原理" class="headerlink" title="Redis 核心架构与原理"></a>Redis 核心架构与原理</h2><h3 id="内存模型与数据结构"><a href="#内存模型与数据结构" class="headerlink" title="内存模型与数据结构"></a>内存模型与数据结构</h3><p>Redis采用基于内存的存储架构，所有数据都保存在RAM中，这是其高性能的根本原因。Redis使用了多种底层数据结构来实现上层的抽象数据类型：</p>
<p><strong>SDS（Simple Dynamic String）</strong> Redis没有直接使用C语言的字符串，而是构建了SDS。SDS在字符串头部记录了长度信息，避免了strlen的O(n)复杂度，同时预分配空间减少内存重分配次数。</p>
<p><strong>跳跃表（Skip List）</strong> 有序集合的底层实现之一，是一种随机化的数据结构，通过多层链表实现O(log N)的查找复杂度。相比红黑树，跳跃表实现更简单，且支持范围查询。</p>
<p><strong>压缩列表（Ziplist）</strong> 当哈希、列表、有序集合元素较少时使用的紧凑存储结构，所有元素存储在一块连续内存中，节省内存但插入删除效率较低。</p>
<p><strong>字典（Dict）</strong> Redis的核心数据结构，使用开放寻址法解决哈希冲突，支持渐进式rehash。当负载因子过高时，会创建新的哈希表并逐步迁移数据。</p>
<h3 id="单线程模型与事件循环"><a href="#单线程模型与事件循环" class="headerlink" title="单线程模型与事件循环"></a>单线程模型与事件循环</h3><p>Redis 6.0之前采用单线程模型处理客户端请求，通过I&#x2F;O多路复用（epoll&#x2F;kqueue）实现高并发。单线程避免了线程切换开销和并发控制问题，但也限制了CPU利用率。</p>
<p><strong>事件循环机制</strong> Redis使用Reactor模式的事件循环，分为文件事件和时间事件：</p>
<ul>
<li>文件事件：处理客户端连接、读写请求</li>
<li>时间事件：处理定时任务，如过期键删除、持久化等</li>
</ul>
<p>Redis 6.0引入了多线程I&#x2F;O，但命令执行仍是单线程，多线程只用于网络I&#x2F;O操作的读写，这样既提高了网络处理能力，又保持了数据操作的原子性。</p>
<h2 id="数据类型详解与应用场景"><a href="#数据类型详解与应用场景" class="headerlink" title="数据类型详解与应用场景"></a>数据类型详解与应用场景</h2><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String是Redis最基础的数据类型，底层可以是SDS、整数或浮点数。</p>
<p><strong>常用命令</strong>：SET、GET、INCR、DECR、APPEND、GETRANGE <strong>应用场景</strong>：</p>
<ul>
<li>缓存：存储用户会话、配置信息</li>
<li>计数器：网站访问量、点赞数（INCR原子性保证）</li>
<li>分布式锁：SET key value NX EX seconds</li>
<li>限流：结合EXPIRE实现滑动窗口限流</li>
</ul>
<h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash类型适合存储对象，避免了将对象序列化为JSON字符串的开销。</p>
<p><strong>底层实现</strong>：元素较少时使用ziplist，元素较多时使用hashtable <strong>应用场景</strong>：</p>
<ul>
<li>存储用户信息：HSET user:1001 name “张三” age 25</li>
<li>购物车：HSET cart:1001 product:123 2</li>
<li>配置管理：分类存储不同模块的配置</li>
</ul>
<h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>List是双向链表实现，支持在两端进行O(1)的插入和删除操作。</p>
<p><strong>常用命令</strong>：LPUSH、RPUSH、LPOP、RPOP、LRANGE、BLPOP <strong>应用场景</strong>：</p>
<ul>
<li>消息队列：生产者LPUSH，消费者BRPOP实现阻塞队列</li>
<li>最新列表：朋友圈动态、商品评论</li>
<li>栈和队列：LPUSH+LPOP实现栈，LPUSH+RPOP实现队列</li>
</ul>
<h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Set是无序集合，元素唯一，底层使用hashtable或intset实现。</p>
<p><strong>集合运算</strong>：SINTER（交集）、SUNION（并集）、SDIFF（差集） <strong>应用场景</strong>：</p>
<ul>
<li>去重：统计网站独立访客</li>
<li>社交关系：共同好友、推荐用户</li>
<li>标签系统：用户标签、文章分类</li>
<li>抽奖系统：SRANDMEMBER随机抽取</li>
</ul>
<h3 id="Sorted-Set类型"><a href="#Sorted-Set类型" class="headerlink" title="Sorted Set类型"></a>Sorted Set类型</h3><p>有序集合，每个元素关联一个分数，按分数排序。底层使用跳跃表和哈希表。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li>排行榜：游戏积分、热搜榜</li>
<li>延时队列：分数为执行时间戳</li>
<li>范围查询：按时间、按分数范围获取数据</li>
</ul>
<h2 id="持久化机制深度解析"><a href="#持久化机制深度解析" class="headerlink" title="持久化机制深度解析"></a>持久化机制深度解析</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB通过fork子进程，将内存数据快照写入磁盘。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>文件紧凑，适合备份和灾难恢复</li>
<li>恢复速度快</li>
<li>对Redis性能影响小（子进程操作）</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>数据丢失风险：两次快照间的数据可能丢失</li>
<li>fork过程会阻塞主进程</li>
<li>大数据集fork耗时较长</li>
</ul>
<p><strong>触发条件</strong>：</p>
<ul>
<li>手动执行SAVE或BGSAVE命令</li>
<li>配置自动触发：save 900 1（900秒内至少1个键改变）</li>
<li>主从复制时自动生成RDB</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF记录每个写命令，通过重放命令恢复数据。</p>
<p><strong>写入时机</strong>：</p>
<ul>
<li>always：每个写命令立即同步，安全但性能低</li>
<li>everysec：每秒同步一次，平衡安全性和性能</li>
<li>no：由操作系统决定同步时机，性能高但安全性低</li>
</ul>
<p><strong>AOF重写</strong>： AOF文件会越来越大，Redis提供重写机制优化：</p>
<ul>
<li>遍历内存数据，用最少命令重建AOF文件</li>
<li>重写期间的新命令写入AOF重写缓冲区</li>
<li>原子性替换旧AOF文件</li>
</ul>
<p><strong>混合持久化</strong>： Redis 4.0引入RDB+AOF混合模式，重写时以RDB格式写入基础数据，增量命令以AOF格式追加，兼顾了恢复速度和数据安全。</p>
<h2 id="缓存问题与解决方案"><a href="#缓存问题与解决方案" class="headerlink" title="缓存问题与解决方案"></a>缓存问题与解决方案</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在的数据，缓存无法生效，请求直达数据库。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>空值缓存</strong>：查询结果为空时也缓存，设置较短过期时间</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (data == null) &#123;</span><br><span class="line">    redis.setex(key, 60, &quot;null&quot;);  // 缓存空值60秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>布隆过滤器</strong>：预先将所有可能存在的数据哈希到位数组</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BloomFilter&lt;String&gt; filter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()), 1000000, 0.01);</span><br><span class="line">// 查询前先检查布隆过滤器</span><br><span class="line">if (!filter.mightContain(key)) &#123;</span><br><span class="line">    return null;  // 一定不存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>参数校验</strong>：在API层面进行参数合法性校验</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>热点数据过期瞬间，大量并发请求击穿缓存。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>互斥锁</strong>：只允许一个线程查询数据库并重建缓存</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public String getData(String key) &#123;</span><br><span class="line">    String data = redis.get(key);</span><br><span class="line">    if (data == null) &#123;</span><br><span class="line">        String lockKey = &quot;lock:&quot; + key;</span><br><span class="line">        if (redis.setnx(lockKey, &quot;1&quot;, 10)) &#123;  // 获取锁</span><br><span class="line">            try &#123;</span><br><span class="line">                data = database.query(key);  // 查询数据库</span><br><span class="line">                redis.setex(key, 3600, data);  // 重建缓存</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                redis.del(lockKey);  // 释放锁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Thread.sleep(50);  // 等待其他线程重建缓存</span><br><span class="line">            return getData(key);  // 递归重试</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>热点数据永不过期</strong>：逻辑上设置过期时间，物理上不过期，异步更新</li>
<li><strong>预热机制</strong>：系统启动时预先加载热点数据</li>
<li><strong>二级缓存</strong>：L1缓存过期后，先返回L2缓存数据，异步更新L1</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量缓存同时过期或Redis宕机，请求涌向数据库。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>过期时间随机化</strong>：避免同时过期</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int randomExpire = baseExpire + new Random().nextInt(300);  // 基础时间+随机时间</span><br><span class="line">redis.setex(key, randomExpire, data);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>多级缓存架构</strong>：<ul>
<li>L1：本地缓存（如Caffeine）</li>
<li>L2：Redis分布式缓存</li>
<li>L3：数据库</li>
</ul>
</li>
<li><strong>限流降级</strong>：使用Sentinel、Hystrix等组件</li>
<li><strong>Redis高可用</strong>：主从复制、哨兵模式、集群部署</li>
</ol>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>系统启动时预先加载热点数据到缓存。</p>
<p><strong>实现方式</strong>：</p>
<ol>
<li><strong>定时任务预热</strong>：凌晨低峰期执行</li>
<li><strong>手动预热</strong>：管理后台触发预热任务</li>
<li><strong>实时预热</strong>：监控系统发现热点数据自动预热</li>
</ol>
<h2 id="数据一致性保证"><a href="#数据一致性保证" class="headerlink" title="数据一致性保证"></a>数据一致性保证</h2><h3 id="Cache-Aside模式（旁路缓存）"><a href="#Cache-Aside模式（旁路缓存）" class="headerlink" title="Cache Aside模式（旁路缓存）"></a>Cache Aside模式（旁路缓存）</h3><p>应用程序负责维护缓存和数据库的一致性。</p>
<p><strong>读操作</strong>：</p>
<ol>
<li>先读缓存，命中则返回</li>
<li>缓存不命中，查询数据库</li>
<li>将数据写入缓存并返回</li>
</ol>
<p><strong>写操作</strong>：</p>
<ol>
<li>先更新数据库</li>
<li>删除缓存（让下次读取时重新加载）</li>
</ol>
<p><strong>为什么是删除而不是更新缓存？</strong></p>
<ul>
<li>更新缓存可能存在并发问题</li>
<li>复杂查询的缓存更新成本高</li>
<li>删除缓存更简单可靠</li>
</ul>
<h3 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h3><p>解决读写并发导致的数据不一致问题。</p>
<p><strong>实现步骤</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void updateData(String key, Object data) &#123;</span><br><span class="line">    // 1. 删除缓存</span><br><span class="line">    redis.del(key);</span><br><span class="line">    </span><br><span class="line">    // 2. 更新数据库</span><br><span class="line">    database.update(data);</span><br><span class="line">    </span><br><span class="line">    // 3. 延时删除缓存（异步）</span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);  // 延时500ms</span><br><span class="line">            redis.del(key);     // 再次删除缓存</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            log.error(&quot;延时删除缓存失败&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>延时时间设置</strong>：通常为主从同步时间 + 读数据库时间 + 几十毫秒</p>
<h3 id="基于消息队列的最终一致性"><a href="#基于消息队列的最终一致性" class="headerlink" title="基于消息队列的最终一致性"></a>基于消息队列的最终一致性</h3><p>使用消息队列异步处理缓存更新，保证最终一致性。</p>
<p><strong>实现流程</strong>：</p>
<ol>
<li>更新数据库，发送消息到队列</li>
<li>消息消费者删除相关缓存</li>
<li>消费失败时重试，保证最终一致性</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 发送缓存删除消息</span><br><span class="line">@Transactional</span><br><span class="line">public void updateUser(User user) &#123;</span><br><span class="line">    userDao.update(user);  // 更新数据库</span><br><span class="line">    </span><br><span class="line">    // 发送缓存删除消息（事务提交后发送）</span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(</span><br><span class="line">        new TransactionSynchronizationAdapter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void afterCommit() &#123;</span><br><span class="line">                cacheDeleteMQ.send(&quot;user:&quot; + user.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式事务方案"><a href="#分布式事务方案" class="headerlink" title="分布式事务方案"></a>分布式事务方案</h3><p>对于强一致性要求高的场景，可以使用分布式事务。</p>
<p><strong>2PC（两阶段提交）</strong>：</p>
<ul>
<li>准备阶段：协调者询问参与者是否准备好</li>
<li>提交阶段：所有参与者都准备好则提交，否则回滚</li>
</ul>
<p><strong>TCC（Try-Confirm-Cancel）</strong>：</p>
<ul>
<li>Try：尝试执行，预留资源</li>
<li>Confirm：确认提交</li>
<li>Cancel：取消执行，释放资源</li>
</ul>
<h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><h3 id="基于SET命令的分布式锁"><a href="#基于SET命令的分布式锁" class="headerlink" title="基于SET命令的分布式锁"></a>基于SET命令的分布式锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class RedisDistributedLock &#123;</span><br><span class="line">    private Jedis jedis;</span><br><span class="line">    </span><br><span class="line">    public boolean tryLock(String lockKey, String requestId, int expireTime) &#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, &quot;NX&quot;, &quot;PX&quot;, expireTime);</span><br><span class="line">        return &quot;OK&quot;.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean releaseLock(String lockKey, String requestId) &#123;</span><br><span class="line">        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                       &quot;return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey),</span><br><span class="line">                                 Collections.singletonList(requestId));</span><br><span class="line">        return &quot;1&quot;.equals(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = &quot;lock:user:1001&quot;;</span><br><span class="line">String requestId = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">if (tryLock(lockKey, requestId, 30000)) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 执行业务逻辑</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        releaseLock(lockKey, requestId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h3><p>为了解决单点故障问题，Redis官方提出了Redlock算法。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li>获取当前时间戳</li>
<li>依次向N个Redis实例申请锁</li>
<li>如果在大多数实例（N&#x2F;2+1）上获取锁成功，且总耗时小于锁超时时间，则认为获取锁成功</li>
<li>锁的有效时间 &#x3D; 初始有效时间 - 获取锁消耗的时间</li>
<li>释放锁时，向所有Redis实例发送释放命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Redlock &#123;</span><br><span class="line">    private List&lt;Jedis&gt; jedisInstances;</span><br><span class="line">    </span><br><span class="line">    public boolean lock(String resource, int ttl) &#123;</span><br><span class="line">        int quorum = jedisInstances.size() / 2 + 1;</span><br><span class="line">        int successCount = 0;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        for (Jedis jedis : jedisInstances) &#123;</span><br><span class="line">            if (lockInstance(jedis, resource, ttl)) &#123;</span><br><span class="line">                successCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        long elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        if (successCount &gt;= quorum &amp;&amp; elapsedTime &lt; ttl) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            unlock(resource);  // 释放已获取的锁</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁的问题与优化"><a href="#锁的问题与优化" class="headerlink" title="锁的问题与优化"></a>锁的问题与优化</h3><p><strong>锁超时问题</strong>： 业务执行时间超过锁超时时间，锁自动释放，可能导致并发问题。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>看门狗机制</strong>：定时续期锁的过期时间</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class WatchDog &#123;</span><br><span class="line">    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);</span><br><span class="line">    </span><br><span class="line">    public void startWatchDog(String lockKey, String requestId) &#123;</span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            // 续期锁</span><br><span class="line">            String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                           &quot;return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) else return 0 end&quot;;</span><br><span class="line">            jedis.eval(script, Arrays.asList(lockKey), </span><br><span class="line">                      Arrays.asList(requestId, &quot;30&quot;));</span><br><span class="line">        &#125;, 10, 10, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>合理评估业务执行时间</strong>：设置足够的锁超时时间</li>
</ol>
<p><strong>锁竞争激烈问题</strong>： 大量线程竞争同一把锁，导致性能下降。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>分段锁</strong>：将资源分段，减少锁竞争</li>
<li><strong>队列锁</strong>：使用List实现公平锁</li>
<li><strong>自旋锁优化</strong>：适当的退避算法</li>
</ol>
<h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>假设会发生并发冲突，在操作数据前先获取锁。</p>
<p><strong>Redis实现</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 使用Redis分布式锁实现悲观锁</span><br><span class="line">public void updateWithPessimisticLock(String userId, int amount) &#123;</span><br><span class="line">    String lockKey = &quot;lock:account:&quot; + userId;</span><br><span class="line">    String requestId = UUID.randomUUID().toString();</span><br><span class="line">    </span><br><span class="line">    if (tryLock(lockKey, requestId, 30000)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 查询账户余额</span><br><span class="line">            int balance = getBalance(userId);</span><br><span class="line">            if (balance &gt;= amount) &#123;</span><br><span class="line">                // 扣减余额</span><br><span class="line">                updateBalance(userId, balance - amount);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InsufficientBalanceException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            releaseLock(lockKey, requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new LockAcquisitionException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>假设不会发生冲突，在更新时检查数据是否被修改。</p>
<p><strong>基于版本号的乐观锁</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public boolean updateWithOptimisticLock(String userId, int amount, int expectedVersion) &#123;</span><br><span class="line">    // 使用Lua脚本保证原子性</span><br><span class="line">    String script = </span><br><span class="line">        &quot;local current = redis.call(&#x27;hmget&#x27;, KEYS[1], &#x27;balance&#x27;, &#x27;version&#x27;) &quot; +</span><br><span class="line">        &quot;if current[2] == ARGV[2] then &quot; +</span><br><span class="line">        &quot;  if tonumber(current[1]) &gt;= tonumber(ARGV[1]) then &quot; +</span><br><span class="line">        &quot;    redis.call(&#x27;hmset&#x27;, KEYS[1], &#x27;balance&#x27;, current[1] - ARGV[1], &#x27;version&#x27;, current[2] + 1) &quot; +</span><br><span class="line">        &quot;    return 1 &quot; +</span><br><span class="line">        &quot;  else &quot; +</span><br><span class="line">        &quot;    return -1 &quot; +  // 余额不足</span><br><span class="line">        &quot;  end &quot; +</span><br><span class="line">        &quot;else &quot; +</span><br><span class="line">        &quot;  return 0 &quot; +     // 版本号不匹配</span><br><span class="line">        &quot;end&quot;;</span><br><span class="line">    </span><br><span class="line">    String key = &quot;account:&quot; + userId;</span><br><span class="line">    Object result = jedis.eval(script, Arrays.asList(key), </span><br><span class="line">                              Arrays.asList(String.valueOf(amount), String.valueOf(expectedVersion)));</span><br><span class="line">    </span><br><span class="line">    int code = ((Long) result).intValue();</span><br><span class="line">    if (code == 1) &#123;</span><br><span class="line">        return true;  // 更新成功</span><br><span class="line">    &#125; else if (code == 0) &#123;</span><br><span class="line">        throw new OptimisticLockException(&quot;数据已被修改&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new InsufficientBalanceException(&quot;余额不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基于CAS的乐观锁</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void updateWithCAS(String key, Function&lt;String, String&gt; updater) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 1. 获取当前值</span><br><span class="line">        String currentValue = redis.get(key);</span><br><span class="line">        </span><br><span class="line">        // 2. 计算新值</span><br><span class="line">        String newValue = updater.apply(currentValue);</span><br><span class="line">        </span><br><span class="line">        // 3. CAS更新</span><br><span class="line">        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                       &quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[2]) else return nil end&quot;;</span><br><span class="line">        Object result = redis.eval(script, Arrays.asList(key), </span><br><span class="line">                                  Arrays.asList(currentValue, newValue));</span><br><span class="line">        </span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            break;  // 更新成功</span><br><span class="line">        &#125;</span><br><span class="line">        // 更新失败，重试</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="悲观锁-vs-乐观锁选择"><a href="#悲观锁-vs-乐观锁选择" class="headerlink" title="悲观锁 vs 乐观锁选择"></a>悲观锁 vs 乐观锁选择</h3><p><strong>悲观锁适用场景</strong>：</p>
<ul>
<li>写操作频繁，冲突概率高</li>
<li>业务逻辑复杂，重试成本高</li>
<li>对数据一致性要求严格</li>
</ul>
<p><strong>乐观锁适用场景</strong>：</p>
<ul>
<li>读多写少，冲突概率低</li>
<li>业务逻辑简单，重试成本低</li>
<li>对性能要求高</li>
</ul>
<h2 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Master负责写操作，Slave负责读操作，通过复制实现数据同步。</p>
<p><strong>复制原理</strong>：</p>
<ol>
<li>Slave向Master发送PSYNC命令</li>
<li>Master执行BGSAVE生成RDB文件</li>
<li>Master将RDB文件发送给Slave</li>
<li>Slave载入RDB文件</li>
<li>Master将缓冲区的写命令发送给Slave</li>
<li>后续写命令实时同步</li>
</ol>
<p><strong>部分重同步</strong>： 网络断连后，Slave只需要同步断连期间的命令，而不是完整重同步。</p>
<h3 id="哨兵模式（Sentinel）"><a href="#哨兵模式（Sentinel）" class="headerlink" title="哨兵模式（Sentinel）"></a>哨兵模式（Sentinel）</h3><p>哨兵负责监控Master状态，在Master故障时自动进行故障转移。</p>
<p><strong>哨兵职责</strong>：</p>
<ul>
<li>监控：定期ping Master和Slave</li>
<li>通知：故障时通知管理员和客户端</li>
<li>故障转移：自动将Slave提升为新Master</li>
<li>配置管理：为客户端提供服务发现</li>
</ul>
<p><strong>故障转移流程</strong>：</p>
<ol>
<li>哨兵发现Master下线（主观下线）</li>
<li>多个哨兵确认Master下线（客观下线）</li>
<li>选举领导哨兵执行故障转移</li>
<li>选择合适的Slave作为新Master</li>
<li>修改其他Slave的配置指向新Master</li>
<li>通知客户端Master地址变更</li>
</ol>
<h3 id="集群模式（Cluster）"><a href="#集群模式（Cluster）" class="headerlink" title="集群模式（Cluster）"></a>集群模式（Cluster）</h3><p>Redis Cluster通过分片实现横向扩展和高可用。</p>
<p><strong>分片算法</strong>： 使用CRC16算法计算key的哈希值，然后对16384取模得到槽位号。</p>
<p><strong>节点通信</strong>： 使用Gossip协议在节点间交换状态信息，包括节点上线&#x2F;下线、槽位分配等。</p>
<p><strong>故障转移</strong>： 当Master节点故障时，其Slave自动提升为新Master，过程对客户端透明。</p>
<p><strong>数据迁移</strong>： 集群扩容时，需要将部分槽位从现有节点迁移到新节点。</p>
<h2 id="性能监控与优化"><a href="#性能监控与优化" class="headerlink" title="性能监控与优化"></a>性能监控与优化</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>Redis提供慢查询日志功能，记录执行时间超过阈值的命令。</p>
<p><strong>配置参数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than 10000  # 超过10毫秒记录</span><br><span class="line">slowlog-max-len 128           # 最多保存128条记录</span><br></pre></td></tr></table></figure>

<p><strong>查看慢查询</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLOWLOG GET 10  # 获取最近10条慢查询</span><br></pre></td></tr></table></figure>

<h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p>使用MEMORY命令分析内存使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MEMORY USAGE key         # 查看key占用内存</span><br><span class="line">MEMORY STATS            # 查看内存统计信息</span><br><span class="line">MEMORY DOCTOR           # 内存使用建议</span><br></pre></td></tr></table></figure>

<h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><p><strong>避免大key</strong>：</p>
<ul>
<li>单个key的value不要超过10KB</li>
<li>集合类型元素数量控制在合理范围</li>
<li>使用SCAN代替KEYS命令</li>
</ul>
<p><strong>合理使用数据结构</strong>：</p>
<ul>
<li>小对象使用Hash而不是多个String</li>
<li>合理设置ziplist等压缩结构的阈值</li>
<li>使用位图(bitmap)存储布尔类型大数据集</li>
</ul>
<p><strong>网络优化</strong>：</p>
<ul>
<li>使用Pipeline批量操作</li>
<li>合理设置客户端连接池</li>
<li>启用TCP_NODELAY选项</li>
</ul>
<p><strong>持久化优化</strong>：</p>
<ul>
<li>根据业务需求选择RDB或AOF</li>
<li>合理配置自动保存条件</li>
<li>在从节点上进行持久化操作</li>
</ul>
<p>这些详细的技术点涵盖了Redis的核心概念、常见问题解决方案和实际应用场景，是Redis技术面试的重要考查内容。掌握这些知识点并能结合实际项目经验进行说明，将大大提高面试通过率。</p>
<h2 id="内存管理与淘汰机制"><a href="#内存管理与淘汰机制" class="headerlink" title="内存管理与淘汰机制"></a>内存管理与淘汰机制</h2><h3 id="内存淘汰策略详解"><a href="#内存淘汰策略详解" class="headerlink" title="内存淘汰策略详解"></a>内存淘汰策略详解</h3><p>当Redis内存使用达到maxmemory限制时，会根据配置的策略淘汰数据。</p>
<p><strong>8种淘汰策略</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 针对所有key</span><br><span class="line">noeviction          # 不淘汰，写入返回错误</span><br><span class="line">allkeys-lru         # 所有key中淘汰最近最少使用</span><br><span class="line">allkeys-lfu         # 所有key中淘汰最少频率使用</span><br><span class="line">allkeys-random      # 所有key中随机淘汰</span><br><span class="line"></span><br><span class="line"># 针对设置了过期时间的key</span><br><span class="line">volatile-lru        # 过期key中淘汰最近最少使用</span><br><span class="line">volatile-lfu        # 过期key中淘汰最少频率使用</span><br><span class="line">volatile-random     # 过期key中随机淘汰</span><br><span class="line">volatile-ttl        # 过期key中淘汰即将过期的</span><br></pre></td></tr></table></figure>

<p><strong>LRU vs LFU 实现细节</strong>： Redis的LRU并非严格的LRU，而是近似LRU算法：</p>
<ul>
<li>每个key都有24位的时钟字段记录访问时间</li>
<li>淘汰时随机采样5个key（可配置），选择时钟值最小的</li>
</ul>
<p>LFU算法维护访问频率：</p>
<ul>
<li>高16位存储上次访问时间</li>
<li>低8位存储访问频率计数器</li>
<li>计数器采用概率性递增，避免频率无限增长</li>
</ul>
<h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p><strong>产生原因</strong>：</p>
<ul>
<li>频繁的数据更新导致内存分配&#x2F;释放</li>
<li>Redis使用jemalloc内存分配器，存在内存对齐</li>
<li>删除大key后留下内存空洞</li>
</ul>
<p><strong>检测方法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"># 关注 mem_fragmentation_ratio 指标</span><br><span class="line"># 比值 &gt; 1.5 表示碎片较多</span><br><span class="line"># 比值 &lt; 1 表示使用了swap，性能严重下降</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>内存整理</strong>（Redis 4.0+）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET activedefrag yes        # 开启自动整理</span><br><span class="line">CONFIG SET active-defrag-threshold-lower 10  # 碎片率超过10%启动</span><br><span class="line">MEMORY PURGE                       # 手动触发整理</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>重启Redis</strong>：最彻底但影响服务可用性</li>
<li><strong>优化数据结构</strong>：减少小对象，使用Hash存储相关数据</li>
</ol>
<h2 id="过期策略与删除机制"><a href="#过期策略与删除机制" class="headerlink" title="过期策略与删除机制"></a>过期策略与删除机制</h2><h3 id="三种过期删除策略"><a href="#三种过期删除策略" class="headerlink" title="三种过期删除策略"></a>三种过期删除策略</h3><p><strong>定时删除</strong>：设置过期时间时创建定时器，到期立即删除</p>
<ul>
<li>优点：及时释放内存</li>
<li>缺点：消耗CPU资源创建和管理定时器</li>
</ul>
<p><strong>惰性删除</strong>：访问key时检查是否过期，过期则删除</p>
<ul>
<li>优点：CPU友好，只在必要时删除</li>
<li>缺点：内存不友好，过期key可能长期占用内存</li>
</ul>
<p><strong>定期删除</strong>：定期随机检查部分key，删除过期的</p>
<ul>
<li>Redis的实际策略，平衡CPU和内存使用</li>
</ul>
<h3 id="Redis过期删除实现"><a href="#Redis过期删除实现" class="headerlink" title="Redis过期删除实现"></a>Redis过期删除实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 简化的过期删除逻辑</span><br><span class="line">void activeExpireCycle(int type) &#123;</span><br><span class="line">    static int current_db = 0;</span><br><span class="line">    static int timelimit_exit = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">        redisDb *db = server.db + current_db % server.dbnum;</span><br><span class="line">        </span><br><span class="line">        int iteration = 0;</span><br><span class="line">        while (iteration &lt; 20) &#123;  // 最多检查20个key</span><br><span class="line">            long sampled = 0, expired = 0;</span><br><span class="line">            </span><br><span class="line">            // 随机选择key检查过期</span><br><span class="line">            for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                dictEntry *de = dictGetRandomKey(db-&gt;expires);</span><br><span class="line">                if (de == NULL) break;</span><br><span class="line">                </span><br><span class="line">                sampled++;</span><br><span class="line">                if (keyIsExpired(db, de)) &#123;</span><br><span class="line">                    deleteExpiredKey(db, de);</span><br><span class="line">                    expired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 如果过期比例超过25%，继续下轮检查</span><br><span class="line">            if (expired &gt; 5) iteration++;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        current_db++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构底层实现深度解析"><a href="#数据结构底层实现深度解析" class="headerlink" title="数据结构底层实现深度解析"></a>数据结构底层实现深度解析</h2><h3 id="压缩列表（ZipList）演进"><a href="#压缩列表（ZipList）演进" class="headerlink" title="压缩列表（ZipList）演进"></a>压缩列表（ZipList）演进</h3><p>Redis 7.0用ListPack替代了ZipList，解决了级联更新问题。</p>
<p><strong>ZipList问题</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ZipList结构导致的级联更新</span><br><span class="line">// 当插入元素导致某个entry的长度改变时</span><br><span class="line">// 可能引起后续所有entry的重新编码</span><br></pre></td></tr></table></figure>

<p><strong>ListPack优势</strong>：</p>
<ul>
<li>每个元素独立编码，避免级联更新</li>
<li>支持从尾部遍历，提高某些操作效率</li>
</ul>
<h3 id="字典扩容与rehash"><a href="#字典扩容与rehash" class="headerlink" title="字典扩容与rehash"></a>字典扩容与rehash</h3><p>Redis字典使用增量式rehash避免阻塞：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 渐进式rehash实现</span><br><span class="line">int dictRehash(dict *d, int n) &#123;</span><br><span class="line">    int empty_visits = n * 10;</span><br><span class="line">    </span><br><span class="line">    if (!dictIsRehashing(d)) return 0;</span><br><span class="line">    </span><br><span class="line">    while (n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;</span><br><span class="line">        // 跳过空桶</span><br><span class="line">        while (d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            if (--empty_visits == 0) return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 迁移桶中所有元素</span><br><span class="line">        dictEntry *de = d-&gt;ht[0].table[d-&gt;rehashidx];</span><br><span class="line">        while (de) &#123;</span><br><span class="line">            dictEntry *nextde = de-&gt;next;</span><br><span class="line">            unsigned int h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[1].table[h];</span><br><span class="line">            d-&gt;ht[1].table[h] = de;</span><br><span class="line">            d-&gt;ht[0].used--;</span><br><span class="line">            d-&gt;ht[1].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络模型与性能优化"><a href="#网络模型与性能优化" class="headerlink" title="网络模型与性能优化"></a>网络模型与性能优化</h2><h3 id="Redis-6-0-多线程I-O"><a href="#Redis-6-0-多线程I-O" class="headerlink" title="Redis 6.0 多线程I&#x2F;O"></a>Redis 6.0 多线程I&#x2F;O</h3><p>多线程只用于网络I&#x2F;O，命令执行仍是单线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 多线程I/O处理流程</span><br><span class="line">void *IOThreadMain(void *myid) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 等待主线程分配任务</span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[id]);</span><br><span class="line">        </span><br><span class="line">        while (io_threads_list[id] &amp;&amp; io_threads_pending[id] == 0) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;io_threads_cond[id], &amp;io_threads_mutex[id]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 处理读写任务</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line">        listRewind(io_threads_list[id], &amp;li);</span><br><span class="line">        </span><br><span class="line">        while ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *c = listNodeValue(ln);</span><br><span class="line">            if (io_threads_op == IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                writeToClient(c, 0);</span><br><span class="line">            &#125; else if (io_threads_op == IO_THREADS_OP_READ) &#123;</span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        io_threads_pending[id] = 0;</span><br><span class="line">        pthread_mutex_unlock(&amp;io_threads_mutex[id]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端连接管理"><a href="#客户端连接管理" class="headerlink" title="客户端连接管理"></a>客户端连接管理</h3><p><strong>连接池配置优化</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Jedis连接池配置</span><br><span class="line">JedisPoolConfig config = new JedisPoolConfig();</span><br><span class="line">config.setMaxTotal(200);                    // 最大连接数</span><br><span class="line">config.setMaxIdle(50);                      // 最大空闲连接</span><br><span class="line">config.setMinIdle(10);                      // 最小空闲连接</span><br><span class="line">config.setTestOnBorrow(true);               // 获取连接时测试</span><br><span class="line">config.setTestOnReturn(true);               // 归还连接时测试</span><br><span class="line">config.setTestWhileIdle(true);              // 空闲时测试</span><br><span class="line">config.setTimeBetweenEvictionRunsMillis(30000);  // 检查间隔</span><br><span class="line">config.setNumTestsPerEvictionRun(10);       // 每次检查连接数</span><br><span class="line">config.setMinEvictableIdleTimeMillis(60000);     // 最小空闲时间</span><br><span class="line"></span><br><span class="line">JedisPool pool = new JedisPool(config, &quot;localhost&quot;, 6379);</span><br></pre></td></tr></table></figure>

<p><strong>Pipeline优化</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Pipeline批量操作</span><br><span class="line">public void batchSet(Map&lt;String, String&gt; data) &#123;</span><br><span class="line">    try (Jedis jedis = pool.getResource()) &#123;</span><br><span class="line">        Pipeline pipeline = jedis.pipelined();</span><br><span class="line">        </span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : data.entrySet()) &#123;</span><br><span class="line">            pipeline.set(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Object&gt; results = pipeline.syncAndReturnAll();</span><br><span class="line">        // 处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高级数据类型与应用"><a href="#高级数据类型与应用" class="headerlink" title="高级数据类型与应用"></a>高级数据类型与应用</h2><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>用于基数统计，占用内存固定（12KB），误差率0.81%。</p>
<p><strong>实现原理</strong>：</p>
<ul>
<li>基于概率算法，通过观察随机数的最大前导零个数估算基数</li>
<li>使用调和平均数减少误差</li>
<li>适用于UV统计等场景</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 网站UV统计</span><br><span class="line">PFADD uv:20230815 user1 user2 user3</span><br><span class="line">PFCOUNT uv:20230815                    # 获取UV数量</span><br><span class="line">PFMERGE uv:week uv:20230815 uv:20230816  # 合并多日数据</span><br></pre></td></tr></table></figure>

<h3 id="布隆过滤器（Redis-Module）"><a href="#布隆过滤器（Redis-Module）" class="headerlink" title="布隆过滤器（Redis Module）"></a>布隆过滤器（Redis Module）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Redis布隆过滤器模块</span><br><span class="line">BF.RESERVE myfilter 0.01 1000000       # 创建过滤器，误报率0.01%，预期元素100万</span><br><span class="line">BF.ADD myfilter &quot;user123&quot;              # 添加元素</span><br><span class="line">BF.EXISTS myfilter &quot;user123&quot;           # 检查元素是否存在</span><br><span class="line">BF.MADD myfilter item1 item2 item3     # 批量添加</span><br><span class="line">BF.MEXISTS myfilter item1 item2 item3  # 批量检查</span><br></pre></td></tr></table></figure>

<h3 id="Geo地理位置"><a href="#Geo地理位置" class="headerlink" title="Geo地理位置"></a>Geo地理位置</h3><p>基于Sorted Set实现，使用GeoHash算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 添加地理位置</span><br><span class="line">GEOADD cities 116.397128 39.916527 &quot;北京&quot; 121.473701 31.230416 &quot;上海&quot;</span><br><span class="line"></span><br><span class="line"># 计算距离</span><br><span class="line">GEODIST cities &quot;北京&quot; &quot;上海&quot; km</span><br><span class="line"></span><br><span class="line"># 范围查询</span><br><span class="line">GEORADIUS cities 116.397128 39.916527 1000 km WITHDIST WITHCOORD</span><br><span class="line"></span><br><span class="line"># 根据成员查询</span><br><span class="line">GEORADIUSBYMEMBER cities &quot;北京&quot; 1000 km</span><br></pre></td></tr></table></figure>

<h2 id="安全性问题与防护"><a href="#安全性问题与防护" class="headerlink" title="安全性问题与防护"></a>安全性问题与防护</h2><h3 id="常见安全漏洞"><a href="#常见安全漏洞" class="headerlink" title="常见安全漏洞"></a>常见安全漏洞</h3><p><strong>命令注入</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 错误做法：直接拼接用户输入</span><br><span class="line">String key = &quot;user:&quot; + userInput;  // userInput可能包含恶意命令</span><br><span class="line">jedis.eval(&quot;return redis.call(&#x27;get&#x27;, &#x27;&quot; + key + &quot;&#x27;)&quot;, 0);</span><br><span class="line"></span><br><span class="line">// 正确做法：使用参数化查询</span><br><span class="line">jedis.eval(&quot;return redis.call(&#x27;get&#x27;, KEYS[1])&quot;, 1, key);</span><br></pre></td></tr></table></figure>

<p><strong>未授权访问</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># redis.conf安全配置</span><br><span class="line">bind 127.0.0.1                        # 绑定指定IP</span><br><span class="line">requirepass your_password              # 设置密码</span><br><span class="line">protected-mode yes                     # 开启保护模式</span><br><span class="line">port 0                                # 禁用默认端口</span><br><span class="line">port 6380                             # 使用非标准端口</span><br></pre></td></tr></table></figure>

<p><strong>危险命令禁用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 重命名危险命令</span><br><span class="line">rename-command FLUSHDB &quot;&quot;             # 禁用FLUSHDB</span><br><span class="line">rename-command FLUSHALL &quot;&quot;            # 禁用FLUSHALL</span><br><span class="line">rename-command SHUTDOWN &quot;REDIS_SHUTDOWN&quot;  # 重命名SHUTDOWN</span><br><span class="line">rename-command CONFIG &quot;REDIS_CONFIG&quot;   # 重命名CONFIG</span><br></pre></td></tr></table></figure>

<h3 id="ACL访问控制（Redis-6-0-）"><a href="#ACL访问控制（Redis-6-0-）" class="headerlink" title="ACL访问控制（Redis 6.0+）"></a>ACL访问控制（Redis 6.0+）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户</span><br><span class="line">ACL SETUSER alice on &gt;password123 ~cached:* +get +set</span><br><span class="line"></span><br><span class="line"># 查看用户权限</span><br><span class="line">ACL LIST</span><br><span class="line"></span><br><span class="line"># 删除用户</span><br><span class="line">ACL DELUSER alice</span><br><span class="line"></span><br><span class="line"># 检查权限</span><br><span class="line">AUTH alice password123</span><br></pre></td></tr></table></figure>

<h2 id="监控与运维"><a href="#监控与运维" class="headerlink" title="监控与运维"></a>监控与运维</h2><h3 id="关键监控指标"><a href="#关键监控指标" class="headerlink" title="关键监控指标"></a>关键监控指标</h3><p><strong>性能指标</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 通过INFO命令获取</span><br><span class="line">INFO stats</span><br><span class="line"># 关注指标：</span><br><span class="line"># - instantaneous_ops_per_sec: QPS</span><br><span class="line"># - keyspace_hits/keyspace_misses: 命中率</span><br><span class="line"># - used_cpu_sys/used_cpu_user: CPU使用率</span><br><span class="line"># - connected_clients: 连接数</span><br><span class="line"># - blocked_clients: 阻塞连接数</span><br></pre></td></tr></table></figure>

<p><strong>内存指标</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"># 关注指标：</span><br><span class="line"># - used_memory: 已使用内存</span><br><span class="line"># - used_memory_rss: 物理内存占用</span><br><span class="line"># - mem_fragmentation_ratio: 内存碎片率</span><br><span class="line"># - used_memory_peak: 内存使用峰值</span><br></pre></td></tr></table></figure>

<p><strong>持久化指标</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO persistence</span><br><span class="line"># 关注指标：</span><br><span class="line"># - rdb_last_save_time: 最后RDB保存时间</span><br><span class="line"># - aof_last_rewrite_time_sec: AOF重写耗时</span><br><span class="line"># - aof_current_size: AOF文件大小</span><br></pre></td></tr></table></figure>

<h3 id="故障排查常用命令"><a href="#故障排查常用命令" class="headerlink" title="故障排查常用命令"></a>故障排查常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接信息</span><br><span class="line">CLIENT LIST</span><br><span class="line">CLIENT INFO</span><br><span class="line"></span><br><span class="line"># 慢查询分析</span><br><span class="line">SLOWLOG GET 10</span><br><span class="line">CONFIG GET slowlog-log-slower-than</span><br><span class="line"></span><br><span class="line"># 大key查找</span><br><span class="line">MEMORY USAGE keyname</span><br><span class="line">redis-cli --bigkeys</span><br><span class="line"></span><br><span class="line"># 热点key分析</span><br><span class="line">redis-cli --hotkeys</span><br><span class="line"></span><br><span class="line"># 延迟监控</span><br><span class="line">LATENCY HISTORY command</span><br><span class="line">CONFIG SET latency-monitor-threshold 100</span><br></pre></td></tr></table></figure>

<h2 id="特殊应用场景"><a href="#特殊应用场景" class="headerlink" title="特殊应用场景"></a>特殊应用场景</h2><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p><strong>固定窗口限流</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class RedisRateLimiter &#123;</span><br><span class="line">    public boolean isAllowed(String key, int limit, int window) &#123;</span><br><span class="line">        long current = System.currentTimeMillis() / 1000 / window;</span><br><span class="line">        String windowKey = key + &quot;:&quot; + current;</span><br><span class="line">        </span><br><span class="line">        String script = </span><br><span class="line">            &quot;local count = redis.call(&#x27;incr&#x27;, KEYS[1]) &quot; +</span><br><span class="line">            &quot;if count == 1 then &quot; +</span><br><span class="line">            &quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[1]) &quot; +</span><br><span class="line">            &quot;end &quot; +</span><br><span class="line">            &quot;return count&quot;;</span><br><span class="line">            </span><br><span class="line">        Long count = (Long) jedis.eval(script, Arrays.asList(windowKey), </span><br><span class="line">                                      Arrays.asList(String.valueOf(window)));</span><br><span class="line">        </span><br><span class="line">        return count &lt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>滑动窗口限流</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean slidingWindowLimit(String key, int limit, int window) &#123;</span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line">    long windowStart = now - window * 1000;</span><br><span class="line">    </span><br><span class="line">    String script = </span><br><span class="line">        &quot;redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">        &quot;local count = redis.call(&#x27;zcard&#x27;, KEYS[1]) &quot; +</span><br><span class="line">        &quot;if count &lt; tonumber(ARGV[2]) then &quot; +</span><br><span class="line">        &quot;  redis.call(&#x27;zadd&#x27;, KEYS[1], ARGV[3], ARGV[3]) &quot; +</span><br><span class="line">        &quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[4]) &quot; +</span><br><span class="line">        &quot;  return 1 &quot; +</span><br><span class="line">        &quot;else &quot; +</span><br><span class="line">        &quot;  return 0 &quot; +</span><br><span class="line">        &quot;end&quot;;</span><br><span class="line">    </span><br><span class="line">    Long result = (Long) jedis.eval(script, Arrays.asList(key),</span><br><span class="line">        Arrays.asList(String.valueOf(windowStart), String.valueOf(limit),</span><br><span class="line">                     String.valueOf(now), String.valueOf(window)));</span><br><span class="line">    </span><br><span class="line">    return result == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisSessionManager &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    public void createSession(String sessionId, String userId, int timeout) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        Map&lt;String, Object&gt; sessionData = new HashMap&lt;&gt;();</span><br><span class="line">        sessionData.put(&quot;userId&quot;, userId);</span><br><span class="line">        sessionData.put(&quot;createTime&quot;, System.currentTimeMillis());</span><br><span class="line">        </span><br><span class="line">        redisTemplate.opsForHash().putAll(key, sessionData);</span><br><span class="line">        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean isValidSession(String sessionId) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        return redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void renewSession(String sessionId, int timeout) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        if (redisTemplate.hasKey(key)) &#123;</span><br><span class="line">            redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息队列实现"><a href="#消息队列实现" class="headerlink" title="消息队列实现"></a>消息队列实现</h3><p><strong>基于List的简单队列</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class RedisQueue &#123;</span><br><span class="line">    // 生产者</span><br><span class="line">    public void produce(String queue, String message) &#123;</span><br><span class="line">        jedis.lpush(queue, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 消费者（阻塞式）</span><br><span class="line">    public String consume(String queue, int timeout) &#123;</span><br><span class="line">        List&lt;String&gt; result = jedis.brpop(timeout, queue);</span><br><span class="line">        return result != null ? result.get(1) : null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基于Stream的消息队列</strong>（Redis 5.0+）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 生产消息</span><br><span class="line">XADD mystream * field1 value1 field2 value2</span><br><span class="line"></span><br><span class="line"># 创建消费者组</span><br><span class="line">XGROUP CREATE mystream mygroup $ MKSTREAM</span><br><span class="line"></span><br><span class="line"># 消费消息</span><br><span class="line">XREADGROUP GROUP mygroup consumer1 COUNT 10 STREAMS mystream &gt;</span><br><span class="line"></span><br><span class="line"># 确认消息</span><br><span class="line">XACK mystream mygroup message_id</span><br></pre></td></tr></table></figure>

<h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class RedisDelayQueue &#123;</span><br><span class="line">    </span><br><span class="line">    public void addDelayTask(String task, long delayTime) &#123;</span><br><span class="line">        long executeTime = System.currentTimeMillis() + delayTime;</span><br><span class="line">        jedis.zadd(&quot;delay_queue&quot;, executeTime, task);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public List&lt;String&gt; getReadyTasks() &#123;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        Set&lt;String&gt; tasks = jedis.zrangeByScore(&quot;delay_queue&quot;, 0, now);</span><br><span class="line">        </span><br><span class="line">        if (!tasks.isEmpty()) &#123;</span><br><span class="line">            // 原子性删除已获取的任务</span><br><span class="line">            String script = </span><br><span class="line">                &quot;local tasks = redis.call(&#x27;zrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">                &quot;if #tasks &gt; 0 then &quot; +</span><br><span class="line">                &quot;  redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">                &quot;end &quot; +</span><br><span class="line">                &quot;return tasks&quot;;</span><br><span class="line">            </span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            List&lt;String&gt; result = (List&lt;String&gt;) jedis.eval(script, </span><br><span class="line">                Arrays.asList(&quot;delay_queue&quot;), Arrays.asList(String.valueOf(now)));</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能调优技巧"><a href="#性能调优技巧" class="headerlink" title="性能调优技巧"></a>性能调优技巧</h2><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p><strong>使用Hash存储小对象</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 不推荐：为每个用户字段单独设置key</span><br><span class="line">jedis.set(&quot;user:1001:name&quot;, &quot;张三&quot;);</span><br><span class="line">jedis.set(&quot;user:1001:age&quot;, &quot;25&quot;);</span><br><span class="line">jedis.set(&quot;user:1001:email&quot;, &quot;zhang@example.com&quot;);</span><br><span class="line"></span><br><span class="line">// 推荐：使用Hash存储</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;name&quot;, &quot;张三&quot;);</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;age&quot;, &quot;25&quot;);</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;email&quot;, &quot;zhang@example.com&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>合理设置过期时间</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 避免同时过期导致雪崩</span><br><span class="line">int baseExpire = 3600;  // 1小时</span><br><span class="line">int randomExpire = baseExpire + new Random().nextInt(300);  // 增加0-5分钟随机时间</span><br><span class="line">jedis.setex(key, randomExpire, value);</span><br></pre></td></tr></table></figure>

<h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p><strong>批量操作优化</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用Pipeline</span><br><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    pipeline.set(&quot;key&quot; + i, &quot;value&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">pipeline.sync();</span><br><span class="line"></span><br><span class="line">// 或使用原生批量命令</span><br><span class="line">Map&lt;String, String&gt; batch = new HashMap&lt;&gt;();</span><br><span class="line">// ... 填充数据</span><br><span class="line">jedis.mset(flattenMap(batch));</span><br></pre></td></tr></table></figure>

<h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p><strong>Lua脚本减少网络往返</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 原子性增加库存</span><br><span class="line">local current = redis.call(&#x27;get&#x27;, KEYS[1])</span><br><span class="line">if current == false then</span><br><span class="line">    return -1  -- key不存在</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">current = tonumber(current)</span><br><span class="line">if current &gt;= tonumber(ARGV[1]) then</span><br><span class="line">    redis.call(&#x27;decrby&#x27;, KEYS[1], ARGV[1])</span><br><span class="line">    return current - tonumber(ARGV[1])</span><br><span class="line">else</span><br><span class="line">    return -2  -- 库存不足</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>你好，我很乐意为你详细讲解 Redis。</p>
<p>Redis 是一个开源的、基于内存的、高性能的键值存储系统。它通常被用作数据库、缓存和消息中间件。Redis 支持多种数据结构，如字符串、哈希、列表、集合和有序集合，这使得它在各种应用场景中都非常灵活。</p>
<h3 id="Redis-的核心特点"><a href="#Redis-的核心特点" class="headerlink" title="Redis 的核心特点"></a>Redis 的核心特点</h3><hr>
<ul>
<li><strong>高性能</strong>: Redis 的所有数据都存储在内存中，因此读写速度非常快。通常，单个 Redis 实例每秒能处理超过 10 万次读写操作。</li>
<li><strong>丰富的数据结构</strong>: Redis 不仅仅是简单的键值存储，它支持多种复杂的数据结构，这让它能满足更广泛的应用需求。</li>
<li><strong>持久化</strong>: 虽然 Redis 是基于内存的，但它提供了两种不同的持久化方式，可以将数据从内存中保存到磁盘上，以防止服务器重启后数据丢失。</li>
<li><strong>原子性</strong>: Redis 的所有操作都是原子性的。这意味着一个命令要么完全执行，要么根本不执行，中间不会被打断，这在多客户端并发访问时尤其重要。</li>
<li><strong>主从复制</strong>: Redis 支持主从复制，可以将数据从一个主节点（Master）同步到一个或多个从节点（Slave），从而实现数据的备份和读写分离，提高系统的可用性和扩展性。</li>
<li><strong>高可用性与集群</strong>: Redis 提供了 Sentinel（哨兵）和 Cluster（集群）两种方案，来保证系统的高可用性和扩展性。</li>
</ul>
<h3 id="Redis-的数据结构详解"><a href="#Redis-的数据结构详解" class="headerlink" title="Redis 的数据结构详解"></a>Redis 的数据结构详解</h3><hr>
<p>这是 Redis 最有特色的地方，理解这些数据结构是掌握 Redis 的关键。</p>
<h4 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1. String (字符串)"></a>1. String (字符串)</h4><ul>
<li><strong>最基本的数据结构</strong>，可以存储任何类型的数据，比如字符串、数字或二进制数据。一个键最多可以存储 512MB 的值。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>SET key value</code>: 设置键值对。</li>
<li><code>GET key</code>: 获取键对应的值。</li>
<li><code>INCR key</code>: 将键对应的值加 1，常用于计数器。</li>
<li><code>MSET key1 value1 key2 value2</code>: 同时设置多个键值对。</li>
<li><code>MGET key1 key2</code>: 同时获取多个键的值。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 缓存、计数器、分布式锁等。</li>
</ul>
<h4 id="2-Hash-哈希"><a href="#2-Hash-哈希" class="headerlink" title="2. Hash (哈希)"></a>2. Hash (哈希)</h4><ul>
<li><strong>类似于一个键值对的集合</strong>。一个哈希键可以存储多个字段（field）和对应的值（value），非常适合存储对象。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>HSET key field value</code>: 设置哈希键中一个字段的值。</li>
<li><code>HGET key field</code>: 获取哈希键中一个字段的值。</li>
<li><code>HGETALL key</code>: 获取哈希键中所有的字段和值。</li>
<li><code>HMSET key field1 value1 field2 value2</code>: 同时设置多个字段。</li>
<li><code>HDEL key field1 field2</code>: 删除一个或多个字段。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 存储用户信息（如<code>user:100</code>作为键，<code>name</code>、<code>age</code>、<code>city</code>作为字段），商品信息等。</li>
</ul>
<h4 id="3-List-列表"><a href="#3-List-列表" class="headerlink" title="3. List (列表)"></a>3. List (列表)</h4><ul>
<li><strong>一个有序的、可以重复的字符串集合</strong>。可以从列表的头部或尾部添加或删除元素。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>LPUSH key value1 value2</code>: 从列表的头部插入一个或多个值。</li>
<li><code>RPUSH key value1 value2</code>: 从列表的尾部插入一个或多个值。</li>
<li><code>LPOP key</code>: 从列表的头部移除并返回一个值。</li>
<li><code>RPOP key</code>: 从列表的尾部移除并返回一个值。</li>
<li><code>LRANGE key start stop</code>: 获取列表中指定范围的元素。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 消息队列（队列、栈）、最新文章列表、历史记录等。</li>
</ul>
<h4 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4. Set (集合)"></a>4. Set (集合)</h4><ul>
<li><strong>一个无序的、不重复的字符串集合</strong>。集合提供了交集、并集和差集等操作。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>SADD key member1 member2</code>: 向集合中添加一个或多个成员。</li>
<li><code>SMEMBERS key</code>: 获取集合中的所有成员。</li>
<li><code>SISMEMBER key member</code>: 判断一个成员是否在集合中。</li>
<li><code>SINTER key1 key2</code>: 求两个集合的交集。</li>
<li><code>SUNION key1 key2</code>: 求两个集合的并集。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 社交网络中的共同好友、标签系统、去重等。</li>
</ul>
<h4 id="5-Sorted-Set-有序集合"><a href="#5-Sorted-Set-有序集合" class="headerlink" title="5. Sorted Set (有序集合)"></a>5. Sorted Set (有序集合)</h4><ul>
<li><strong>和集合类似，但每个成员都会关联一个分数（score）</strong>。通过这个分数，可以对集合中的成员进行排序。分数可以重复，但成员必须唯一。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>ZADD key score1 member1 score2 member2</code>: 向有序集合中添加一个或多个带分数的成员。</li>
<li><code>ZRANGE key start stop</code>: 按分数从小到大排序，获取指定范围的成员。</li>
<li><code>ZREVRANGE key start stop</code>: 按分数从大到小排序，获取指定范围的成员。</li>
<li><code>ZSCORE key member</code>: 获取一个成员的分数。</li>
<li><code>ZINCRBY key increment member</code>: 给指定成员的分数增加指定值。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 排行榜（游戏分数、热点新闻）、带权重的任务队列等。</li>
</ul>
<h3 id="Redis-的持久化机制"><a href="#Redis-的持久化机制" class="headerlink" title="Redis 的持久化机制"></a>Redis 的持久化机制</h3><hr>
<p>Redis 提供了两种持久化方式，可以将数据从内存保存到硬盘，确保数据不会因为服务重启而丢失。</p>
<h4 id="1-RDB-Redis-Database"><a href="#1-RDB-Redis-Database" class="headerlink" title="1. RDB (Redis Database)"></a>1. RDB (Redis Database)</h4><ul>
<li><strong>快照方式</strong>。它会在指定的时间间隔内，将内存中的数据快照写入到磁盘上一个二进制文件中（<code>dump.rdb</code>）。</li>
<li><strong>优点</strong>: RDB 文件是一个非常紧凑的二进制文件，非常适合备份和灾难恢复。</li>
<li><strong>缺点</strong>: 每次保存都会丢失从上次快照到现在之间的数据。</li>
</ul>
<h4 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2. AOF (Append Only File)"></a>2. AOF (Append Only File)</h4><ul>
<li><strong>日志方式</strong>。它会记录每一次对 Redis 数据库的写操作命令，并以追加（append）的方式写入到文件中。当 Redis 重启时，会重新执行 AOF 文件中的命令来恢复数据。</li>
<li><strong>优点</strong>: 数据丢失风险低，可以配置为每秒同步一次，或者每执行一个命令就同步一次。</li>
<li><strong>缺点</strong>: AOF 文件通常比 RDB 文件大，且恢复速度可能较慢。</li>
</ul>
<p>在实际应用中，通常会<strong>同时使用 RDB 和 AOF</strong>，以获得更高的可靠性。</p>
<h3 id="Redis-的高可用性"><a href="#Redis-的高可用性" class="headerlink" title="Redis 的高可用性"></a>Redis 的高可用性</h3><hr>
<h4 id="1-主从复制-Replication"><a href="#1-主从复制-Replication" class="headerlink" title="1. 主从复制 (Replication)"></a>1. 主从复制 (Replication)</h4><ul>
<li><strong>基本原理</strong>: 将一个 Redis 实例（主节点）的数据复制到一个或多个其他实例（从节点）。从节点的数据是主节点的完整副本。</li>
<li><strong>作用</strong>:<ul>
<li><strong>数据备份</strong>: 从节点可以作为数据的热备份。</li>
<li><strong>读写分离</strong>: 大多数读操作可以分流到从节点上，减轻主节点的压力。</li>
</ul>
</li>
</ul>
<h4 id="2-Sentinel-哨兵"><a href="#2-Sentinel-哨兵" class="headerlink" title="2. Sentinel (哨兵)"></a>2. Sentinel (哨兵)</h4><ul>
<li><strong>作用</strong>: 自动化管理主从复制集群。它是一个监控系统，可以监控主节点和从节点是否正常运行。</li>
<li><strong>核心功能</strong>:<ul>
<li><strong>监控</strong>: 不断检查主从节点是否正常工作。</li>
<li><strong>通知</strong>: 当某个 Redis 实例出现问题时，会发送通知。</li>
<li><strong>故障转移</strong>: 如果主节点发生故障，Sentinel 会自动从剩下的从节点中选举一个新的主节点，并让其他从节点切换到这个新的主节点上，从而实现高可用。</li>
</ul>
</li>
</ul>
<h4 id="3-Redis-Cluster-集群"><a href="#3-Redis-Cluster-集群" class="headerlink" title="3. Redis Cluster (集群)"></a>3. Redis Cluster (集群)</h4><ul>
<li><strong>作用</strong>: 解决 Redis 单机内存容量和并发量的瓶颈问题。它将数据分散到多个节点上，每个节点只负责存储部分数据。</li>
<li><strong>核心功能</strong>:<ul>
<li><strong>数据分片</strong>: 自动将数据分布在多个节点上。</li>
<li><strong>高可用性</strong>: 即使部分节点宕机，集群也能继续正常工作。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Charlotte</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/">http://example.com/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">浮生若梦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1/">分布式微服务</a></div><div class="post-share"><div class="social-share" data-image="/img/title.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/" title="手写答案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">手写答案</div></div><div class="info-2"><div class="info-item-1">1.实现单例模式 (Singleton Pattern)懒汉式：使用双重检查锁定 (DCL) 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。 1234567891011121314151617181920212223242526272829class Singleton &#123;    // 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到    private static volatile Singleton instance;    // 2. 私有化构造器，防止外部直接 new 实例    private Singleton() &#123;&#125;    // 3. 提供一个全局访问点，使用 DCL 确保线程安全    public static Singleton getInstance() &#123;        // 第一次检查：如果实例已经存在，直接返回，避免不必要的同步        if (instance == null) &#12...</div></div></div></a><a class="pagination-related  no-desc" href="/2025/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" title="计算机基础面试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">计算机基础面试</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/" title="手写答案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">手写答案</div></div><div class="info-2"><div class="info-item-1">1.实现单例模式 (Singleton Pattern)懒汉式：使用双重检查锁定 (DCL) 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。 1234567891011121314151617181920212223242526272829class Singleton &#123;    // 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到    private static volatile Singleton instance;    // 2. 私有化构造器，防止外部直接 new 实例    private Singleton() &#123;&#125;    // 3. 提供一个全局访问点，使用 DCL 确保线程安全    public static Singleton getInstance() &#123;        // 第一次检查：如果实例已经存在，直接返回，避免不必要的同步        if (instance == null) &#12...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" title="面试题目"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">面试题目</div></div><div class="info-2"><div class="info-item-1">一、Java 基础语法 &amp; 关键字1. JDK、JRE 和 JVM 的区别 JVM（Java Virtual Machine）：Java 虚拟机，负责执行字节码（.class）。提供类加载、字节码校验、内存管理（堆、方法区）、执行引擎、垃圾回收、线程调度等。是抽象的规范，具体由不同厂商实现（HotSpot、OpenJ9 等）。 JRE（Java Runtime Environment）：运行环境，包含 JVM、核心类库（rt.jar 或 modules）、以及运行时需要的其它资源。用于运行 Java 程序。 JDK（Java Development Kit）：开发工具包，包含 JRE + 开发工具（javac、jar、javadoc、调试工具等）。用于开发 Java 程序。 总结：JDK ⊃ JRE ⊃ JVM（JDK 包含 JRE，JRE 包含 JVM）。   2. Java 的跨平台原理是什么？ Java 程序先由 javac 编译成与平台无关的 字节码（.class）。字节码不是机器码，而是供 JVM 执行的指令集。 每个平台（Windows&#x2F;Linux&...</div></div></div></a><a class="pagination-related" href="/2025/09/11/java%E7%9F%A5%E8%AF%86%E7%82%B9/" title="重要知识点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">重要知识点</div></div><div class="info-2"><div class="info-item-1"> 一、网络基础概念 网络的定义 网络是多个计算机及通信设备通过通信介质互联的系统，用于信息传输、资源共享、协同工作。 核心目标：可靠、高效、可扩展的数据传输。 设计原则：分层、模块化、接口标准化。   数据传输方式 单工：单向传输（电视广播）。 半双工：双向传输，但不能同时发送（对讲机）。 全双工：双向同时传输（电话、以太网交换机端口）。   通信方式 点对点：两个节点直接通信（PPP）。 广播：单点发送，多点接收（Ethernet）。 组播：单点发送，特定组接收（IP 多播）。   网络分类 按地理范围：LAN、MAN、WAN。 按拓扑结构：星型、总线型、环型、混合型。 按访问控制方式：CSMA&#x2F;CD（Ethernet）、令牌环（Token Ring）。     二、OSI 七层模型OSI 模型将网络通信划分为七层，每层负责特定功能，确保模块化与互操作性。    层 功能 数据单位 典型协议&#x2F;设备 面试易问点    物理层 比特流传输，电气&#x2F;光学&#x2F;机械接口 比特 Bit 网线、光纤、集线器、网卡物理部分、调制解调器 电压、传输速率、双工模...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/title.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Charlotte</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/charlotte030710"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Spring-Cloud-%E4%BD%93%E7%B3%BB"><span class="toc-number">1.</span> <span class="toc-text">1. Spring Cloud 体系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.1.</span> <span class="toc-text">核心思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Netflix-OSS-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%88%E9%83%A8%E5%88%86%E8%BF%9B%E5%85%A5%E7%BB%B4%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">Netflix OSS 常用组件（部分进入维护模式）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Spring-Cloud-Alibaba-%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">Spring Cloud Alibaba 详解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%86%E5%B8%83%E5%BC%8FID%EF%BC%9A%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%EF%BC%88Snowflake%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">2. 分布式ID：雪花算法（Snowflake）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E2%80%9C%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E6%9C%89%E6%97%B6%E9%92%9F%E5%9B%9E%E6%8B%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E2%80%9D"><span class="toc-number">2.3.</span> <span class="toc-text">面试题：“雪花算法有时钟回拨问题，如何解决？”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-RBAC%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">3. RBAC（基于角色的访问控制）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">3.2.</span> <span class="toc-text">核心三要素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E2%80%9C%E8%AF%B7%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA-RBAC-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84%E3%80%82%E2%80%9D"><span class="toc-number">3.3.</span> <span class="toc-text">面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Redis-%E8%BF%9B%E9%98%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">4. Redis 进阶详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">核心特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.2.</span> <span class="toc-text">缓存三大问题与解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MQ%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">5. 消息队列（MQ）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">核心作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E2%80%9C%E8%AF%B7%E5%88%97%E4%B8%BE%E4%BD%A0%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%97%B6%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%B9%B6%E7%BB%99%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82%E2%80%9D"><span class="toc-number">5.2.</span> <span class="toc-text">面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">6. 分布式锁详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="toc-number">6.2.</span> <span class="toc-text">实现方案对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-Redis-%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%9B%E9%98%B6"><span class="toc-number">6.3.</span> <span class="toc-text">基于 Redis 的实现进阶</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E2%80%9CRedis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%94%81%E8%BF%87%E6%9C%9F%E4%BA%86%E4%BD%86%E4%B8%9A%E5%8A%A1%E6%B2%A1%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E2%80%9D"><span class="toc-number">6.4.</span> <span class="toc-text">面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A3"><span class="toc-number">7.</span> <span class="toc-text">7. 分布式事务详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">7.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="toc-number">7.2.</span> <span class="toc-text">解决方案深入分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua-%E8%84%9A%E6%9C%AC%E8%AF%A6%E8%A7%A3-%E5%9C%A8-Redis-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">Lua 脚本详解 (在 Redis 中的应用)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Lua-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. Lua 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-%E8%A6%81%E6%94%AF%E6%8C%81-Lua-%E8%84%9A%E6%9C%AC%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2. 为什么 Redis 要支持 Lua 脚本？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%9C%A8-Redis-%E4%B8%AD%E4%BD%BF%E7%94%A8-Lua-%E8%84%9A%E6%9C%AC%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3. 如何在 Redis 中使用 Lua 脚本？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Token-%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number"></span> <span class="toc-text">Token 认证机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Token-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. Token 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Token-%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86%EF%BC%88%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">2. Token 认证原理（工作流程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-Token%EF%BC%9F%EF%BC%88%E4%B8%8E-Session-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">3. 为什么使用 Token？（与 Session 的区别）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%8C%E4%BB%A4%E7%89%8C%E7%AD%96%E7%95%A5-Access-Token-Refresh-Token"><span class="toc-number">4.</span> <span class="toc-text">4. 双令牌策略 (Access Token + Refresh Token)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Token-%E7%9B%B8%E5%85%B3%E5%9C%BA%E6%99%AF%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">5. Token 相关场景与面试题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E8%AF%A6%E7%BB%86%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">Redis 详细技术解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number"></span> <span class="toc-text">Redis 核心架构与原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">内存模型与数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number"></span> <span class="toc-text">单线程模型与事件循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number"></span> <span class="toc-text">数据类型详解与应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">String类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">Hash类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">List类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">Set类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorted-Set%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">Sorted Set类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">持久化机制深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">RDB持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">AOF持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number"></span> <span class="toc-text">缓存问题与解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number"></span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number"></span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number"></span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number"></span> <span class="toc-text">缓存预热</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number"></span> <span class="toc-text">数据一致性保证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Aside%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">Cache Aside模式（旁路缓存）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0%E7%AD%96%E7%95%A5"><span class="toc-number"></span> <span class="toc-text">延时双删策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">基于消息队列的最终一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88"><span class="toc-number"></span> <span class="toc-text">分布式事务方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">分布式锁实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESET%E5%91%BD%E4%BB%A4%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number"></span> <span class="toc-text">基于SET命令的分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redlock%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">Redlock算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">锁的问题与优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number"></span> <span class="toc-text">悲观锁与乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number"></span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number"></span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81-vs-%E4%B9%90%E8%A7%82%E9%94%81%E9%80%89%E6%8B%A9"><span class="toc-number"></span> <span class="toc-text">悲观锁 vs 乐观锁选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">高可用架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88Sentinel%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">哨兵模式（Sentinel）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Cluster%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">集群模式（Cluster）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">性能监控与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number"></span> <span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">内存分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="toc-number"></span> <span class="toc-text">性能优化建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">内存管理与淘汰机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3"><span class="toc-number"></span> <span class="toc-text">内存淘汰策略详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">内存碎片问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">过期策略与删除机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number"></span> <span class="toc-text">三种过期删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">Redis过期删除实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">数据结构底层实现深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%EF%BC%88ZipList%EF%BC%89%E6%BC%94%E8%BF%9B"><span class="toc-number"></span> <span class="toc-text">压缩列表（ZipList）演进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%89%A9%E5%AE%B9%E4%B8%8Erehash"><span class="toc-number"></span> <span class="toc-text">字典扩容与rehash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">网络模型与性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-6-0-%E5%A4%9A%E7%BA%BF%E7%A8%8BI-O"><span class="toc-number"></span> <span class="toc-text">Redis 6.0 多线程I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number"></span> <span class="toc-text">客户端连接管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">高级数据类型与应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLog"><span class="toc-number"></span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88Redis-Module%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">布隆过滤器（Redis Module）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geo%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-number"></span> <span class="toc-text">Geo地理位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%E4%B8%8E%E9%98%B2%E6%8A%A4"><span class="toc-number"></span> <span class="toc-text">安全性问题与防护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E"><span class="toc-number"></span> <span class="toc-text">常见安全漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACL%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%88Redis-6-0-%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">ACL访问控制（Redis 6.0+）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%BF%90%E7%BB%B4"><span class="toc-number"></span> <span class="toc-text">监控与运维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87"><span class="toc-number"></span> <span class="toc-text">关键监控指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number"></span> <span class="toc-text">故障排查常用命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number"></span> <span class="toc-text">特殊应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81"><span class="toc-number"></span> <span class="toc-text">分布式限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8FSession"><span class="toc-number"></span> <span class="toc-text">分布式Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">消息队列实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">延时队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%8A%80%E5%B7%A7"><span class="toc-number"></span> <span class="toc-text">性能调优技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">内存优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">网络优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E4%BC%98%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">CPU优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">Redis 的核心特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="toc-number"></span> <span class="toc-text">Redis 的数据结构详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.</span> <span class="toc-text">1. String (字符串)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Hash-%E5%93%88%E5%B8%8C"><span class="toc-number">2.</span> <span class="toc-text">2. Hash (哈希)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-List-%E5%88%97%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">3. List (列表)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Set-%E9%9B%86%E5%90%88"><span class="toc-number">4.</span> <span class="toc-text">4. Set (集合)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Sorted-Set-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">5.</span> <span class="toc-text">5. Sorted Set (有序集合)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">Redis 的持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-RDB-Redis-Database"><span class="toc-number">1.</span> <span class="toc-text">1. RDB (Redis Database)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-AOF-Append-Only-File"><span class="toc-number">2.</span> <span class="toc-text">2. AOF (Append Only File)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">Redis 的高可用性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Replication"><span class="toc-number">1.</span> <span class="toc-text">1. 主从复制 (Replication)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Sentinel-%E5%93%A8%E5%85%B5"><span class="toc-number">2.</span> <span class="toc-text">2. Sentinel (哨兵)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Redis-Cluster-%E9%9B%86%E7%BE%A4"><span class="toc-number">3.</span> <span class="toc-text">3. Redis Cluster (集群)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" title="命令大全">命令大全</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E7%AE%97%E6%B3%95/" title="算法">算法</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" title="计算机基础面试">计算机基础面试</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式">分布式</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/" title="手写答案">手写答案</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bg.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Charlotte</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试题目 | 浮生若梦</title><meta name="author" content="Charlotte"><meta name="copyright" content="Charlotte"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Java 基础语法 &amp; 关键字1. JDK、JRE 和 JVM 的区别 JVM（Java Virtual Machine）：Java 虚拟机，负责执行字节码（.class）。提供类加载、字节码校验、内存管理（堆、方法区）、执行引擎、垃圾回收、线程调度等。是抽象的规范，具体由不同厂商实现（HotSpot、OpenJ9 等）。 JRE（Java Runtime Environment）：运">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题目">
<meta property="og:url" content="http://example.com/2025/09/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/index.html">
<meta property="og:site_name" content="浮生若梦">
<meta property="og:description" content="一、Java 基础语法 &amp; 关键字1. JDK、JRE 和 JVM 的区别 JVM（Java Virtual Machine）：Java 虚拟机，负责执行字节码（.class）。提供类加载、字节码校验、内存管理（堆、方法区）、执行引擎、垃圾回收、线程调度等。是抽象的规范，具体由不同厂商实现（HotSpot、OpenJ9 等）。 JRE（Java Runtime Environment）：运">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/title.jpg">
<meta property="article:published_time" content="2025-09-11T10:29:28.000Z">
<meta property="article:modified_time" content="2025-09-20T14:18:59.611Z">
<meta property="article:author" content="Charlotte">
<meta property="article:tag" content="java">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="题目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/title.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "面试题目",
  "url": "http://example.com/2025/09/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/",
  "image": "http://example.com/img/title.jpg",
  "datePublished": "2025-09-11T10:29:28.000Z",
  "dateModified": "2025-09-20T14:18:59.611Z",
  "author": [
    {
      "@type": "Person",
      "name": "Charlotte",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="http://example.com/2025/09/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题目',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="浮生若梦" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/title.jpg" alt="Logo"><span class="site-name">浮生若梦</span></a><a class="nav-page-title" href="/"><span class="site-name">面试题目</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">面试题目</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-20T14:18:59.611Z" title="更新于 2025-09-20 22:18:59">2025-09-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="一、Java-基础语法-关键字"><a href="#一、Java-基础语法-关键字" class="headerlink" title="一、Java 基础语法 &amp; 关键字"></a>一、Java 基础语法 &amp; 关键字</h2><h2 id="1-JDK、JRE-和-JVM-的区别"><a href="#1-JDK、JRE-和-JVM-的区别" class="headerlink" title="1. JDK、JRE 和 JVM 的区别"></a>1. JDK、JRE 和 JVM 的区别</h2><ul>
<li><strong>JVM（Java Virtual Machine）</strong>：Java 虚拟机，负责执行字节码（<code>.class</code>）。提供类加载、字节码校验、内存管理（堆、方法区）、执行引擎、垃圾回收、线程调度等。是抽象的规范，具体由不同厂商实现（HotSpot、OpenJ9 等）。</li>
<li><strong>JRE（Java Runtime Environment）</strong>：运行环境，包含 JVM、核心类库（rt.jar 或 modules）、以及运行时需要的其它资源。用于运行 Java 程序。</li>
<li><strong>JDK（Java Development Kit）</strong>：开发工具包，包含 JRE + 开发工具（<code>javac</code>、<code>jar</code>、<code>javadoc</code>、调试工具等）。用于开发 Java 程序。<br> 总结：JDK ⊃ JRE ⊃ JVM（JDK 包含 JRE，JRE 包含 JVM）。</li>
</ul>
<hr>
<h2 id="2-Java-的跨平台原理是什么？"><a href="#2-Java-的跨平台原理是什么？" class="headerlink" title="2. Java 的跨平台原理是什么？"></a>2. Java 的跨平台原理是什么？</h2><ul>
<li>Java 程序先由 <code>javac</code> 编译成与平台无关的 <strong>字节码</strong>（<code>.class</code>）。字节码不是机器码，而是供 JVM 执行的指令集。</li>
<li>每个平台（Windows&#x2F;Linux&#x2F;macOS）有相应的 JVM 实现，JVM 把字节码翻译成该平台的机器指令（通过解释器、JIT 编译器等）。因此同一套 <code>.class</code> 可以在不同平台的 JVM 上运行 —— “一次编写，处处运行”（Write Once, Run Anywhere）。</li>
<li>其它保证跨平台的要点：标准库隐藏平台差异（I&#x2F;O、线程等），需避免使用与平台绑定的本地代码（JNI）。</li>
</ul>
<hr>
<h2 id="3-Java-的基本数据类型有哪些？各自的默认值？"><a href="#3-Java-的基本数据类型有哪些？各自的默认值？" class="headerlink" title="3. Java 的基本数据类型有哪些？各自的默认值？"></a>3. Java 的基本数据类型有哪些？各自的默认值？</h2><p>8 种基本类型及默认值（成员变量&#x2F;数组元素；局部变量无默认值必须初始化）：</p>
<ul>
<li><code>byte</code>：1 byte，默认值 <code>0</code></li>
<li><code>short</code>：2 bytes，默认值 <code>0</code></li>
<li><code>int</code>：4 bytes，默认值 <code>0</code></li>
<li><code>long</code>：8 bytes，默认值 <code>0L</code></li>
<li><code>float</code>：4 bytes，默认值 <code>0.0f</code></li>
<li><code>double</code>：8 bytes，默认值 <code>0.0d</code></li>
<li><code>char</code>：2 bytes（UTF-16 code unit），默认值 <code>&#39;\u0000&#39;</code>（即 0）</li>
<li><code>boolean</code>：JVM 语义上用 1 bit 表示，默认值 <code>false</code></li>
</ul>
<p>另外，<strong>引用类型</strong>（对象、数组等）的默认值是 <code>null</code>。</p>
<hr>
<h2 id="4-byte、short、int、long-各占多少字节？"><a href="#4-byte、short、int、long-各占多少字节？" class="headerlink" title="4. byte、short、int、long 各占多少字节？"></a>4. <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> 各占多少字节？</h2><ul>
<li><code>byte</code>：<strong>1 字节</strong>（8 位）</li>
<li><code>short</code>：<strong>2 字节</strong>（16 位）</li>
<li><code>int</code>：<strong>4 字节</strong>（32 位）</li>
<li><code>long</code>：<strong>8 字节</strong>（64 位）</li>
</ul>
<p>（上述为 Java 语言规范定义，与平台无关。）</p>
<hr>
<h2 id="5-float-和-double-的区别？"><a href="#5-float-和-double-的区别？" class="headerlink" title="5. float 和 double 的区别？"></a>5. <code>float</code> 和 <code>double</code> 的区别？</h2><ul>
<li>精度与存储：<ul>
<li><code>float</code>：32 位单精度浮点（IEEE 754），约 6~7 位有效数字。</li>
<li><code>double</code>：64 位双精度浮点（IEEE 754），约 15~16 位有效数字。</li>
</ul>
</li>
<li>精度更高的 <code>double</code> 更常用；<code>float</code> 用于节省内存或与特定 API（如图形库）兼容。</li>
<li>注意：浮点数有精度误差，不适合做精确货币计算（应使用 <code>BigDecimal</code>）。</li>
<li>默认浮点字面量为 <code>double</code>（例如 <code>1.2</code> 是 <code>double</code>，写成 <code>1.2f</code> 才是 <code>float</code>）。</li>
</ul>
<hr>
<h2 id="6-char-类型占几个字节？能存汉字吗？"><a href="#6-char-类型占几个字节？能存汉字吗？" class="headerlink" title="6. char 类型占几个字节？能存汉字吗？"></a>6. <code>char</code> 类型占几个字节？能存汉字吗？</h2><ul>
<li><code>char</code> 占 <strong>2 字节</strong>（16 位），表示 UTF-16 的一个 code unit。</li>
<li>能否存汉字：多数常用汉字（位于基本多文种平面 BMP）可以用单个 <code>char</code> 表示（例如 <code>&#39;你&#39;</code>）；但有些罕见汉字或 emoji 属于补充平面（Supplementary Planes），它们需要 <strong>两个 char（称为 surrogate pair）</strong> 来表示。</li>
<li>因此，单个 <code>char</code> 能表示一个 UTF-16 code unit，而不是完整的 Unicode code point。处理 Unicode 字符时注意使用 <code>int codePoint</code> &#x2F; <code>Character</code> 的相关 API。</li>
</ul>
<hr>
<h2 id="7-自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？"><a href="#7-自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？" class="headerlink" title="7. 自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？"></a>7. 自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？</h2><ul>
<li><p><strong>概念</strong>：</p>
<ul>
<li>装箱：把基本类型自动转换成对应的包装类型（如 <code>int</code> → <code>Integer</code>）。</li>
<li>拆箱：把包装类型自动转换回基本类型（如 <code>Integer</code> → <code>int</code>）。</li>
</ul>
</li>
<li><p><strong>编译器行为</strong>：自动装箱&#x2F;拆箱是在编译期由 Java 编译器插入对应的调用，示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 10;        // 编译器会转换为 Integer.valueOf(10)</span><br><span class="line">int b = a;             // 编译器会转换为 a.intValue()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>valueOf 缓存</strong>：包装类（如 <code>Integer.valueOf(int)</code>）会对小整数（默认 -128 到 127）做缓存以重用对象，减少频繁创建对象。</p>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li><p>拆箱 <code>null</code> 会抛出 <code>NullPointerException</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = null;</span><br><span class="line">int y = x; // NPE</span><br></pre></td></tr></table></figure>
</li>
<li><p>装箱&#x2F;拆箱会有性能开销（对象创建、装箱&#x2F;拆箱方法调用），在性能敏感场景尽量使用基本类型或手动优化。</p>
</li>
<li><p>比较时注意：<code>Integer a = 100; Integer b = 100; a==b</code> 在缓存范围内可能为 <code>true</code>，超出范围则通常为 <code>false</code>。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8-和-equals-的区别？"><a href="#8-和-equals-的区别？" class="headerlink" title="8. == 和 equals() 的区别？"></a>8. <code>==</code> 和 <code>equals()</code> 的区别？</h2><ul>
<li><strong>&#x3D;&#x3D;</strong>：<ul>
<li>对于基本类型：比较 <strong>值</strong>（数值是否相等）。</li>
<li>对于引用类型：比较 <strong>引用地址</strong>（是否是同一个对象）。</li>
</ul>
</li>
<li><strong>equals()</strong>：<ul>
<li>是 <code>Object</code> 的方法，默认实现也是比较引用（等价于 <code>==</code>）。</li>
<li>许多类（如 <code>String</code>、<code>Integer</code>、集合类等）重写了 <code>equals()</code>，用于比较<strong>逻辑&#x2F;内容相等</strong>。</li>
</ul>
</li>
<li><strong>使用建议</strong>：<ul>
<li>比较对象内容用 <code>equals()</code>（需检查 <code>null</code>），比较是否同一实例用 <code>==</code>。</li>
<li>与 <code>equals()</code> 配套应重写 <code>hashCode()</code>（见下题）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="9-hashCode-和-equals-的关系？"><a href="#9-hashCode-和-equals-的关系？" class="headerlink" title="9. hashCode 和 equals 的关系？"></a>9. <code>hashCode</code> 和 <code>equals</code> 的关系？</h2><ul>
<li><strong>合同（Contract）</strong>（重要）：<ol>
<li>如果两个对象通过 <code>equals()</code> 被判定为相等（<code>a.equals(b)</code> 为 <code>true</code>），那么 <code>a.hashCode() == b.hashCode()</code> 必须成立。</li>
<li>反之不要求：<code>hashCode</code> 相等的对象不一定 <code>equals()</code> 相等（哈希冲突允许）。</li>
</ol>
</li>
<li><strong>在哈希集合中的角色</strong>：<ul>
<li>哈希表（<code>HashMap</code>&#x2F;<code>HashSet</code>）先用 <code>hashCode()</code> 找到桶（bucket），若桶中有多个元素，再用 <code>equals()</code> 逐个比较确认相等或冲突。</li>
<li>如果只重写 <code>equals()</code> 而不重写 <code>hashCode()</code> 会破坏集合行为（例如放入 <code>HashSet</code> 后无法正确查找）。</li>
</ul>
</li>
<li><strong>实现要点</strong>：<ul>
<li><code>hashCode()</code> 要尽量分散（降低冲突），并在对象不可变字段上基于相同规则计算。</li>
<li>若对象可变，若用于哈希集合要小心：修改字段会导致 <code>hashCode()</code> 改变，破坏集合内部结构。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10-String、StringBuffer、StringBuilder-的区别？"><a href="#10-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="10. String、StringBuffer、StringBuilder 的区别？"></a>10. <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code> 的区别？</h2><ul>
<li><strong>String</strong>：<ul>
<li>不可变（immutable），每次修改都会产生新的对象（或新内部 char&#x2F;byte 数组）。</li>
<li>线程安全（因为不可变），适合频繁读取、少量修改的场景。</li>
</ul>
</li>
<li><strong>StringBuffer</strong>：<ul>
<li>可变的字符序列（内部有缓冲区 <code>char[]</code>&#x2F;<code>byte[]</code>），几乎与 <code>StringBuilder</code> 接口相同。</li>
<li><strong>线程安全</strong>，其方法大多使用 <code>synchronized</code>，因此在多线程下可以被多个线程安全使用。</li>
<li>相对较慢（同步开销）。</li>
</ul>
</li>
<li><strong>StringBuilder（Java 5+）</strong>：<ul>
<li>可变，<strong>非线程安全</strong>（没有同步），比 <code>StringBuffer</code> 快。</li>
<li>推荐在单线程或外部已同步的场景下使用。</li>
</ul>
</li>
<li><strong>选择建议</strong>：<ul>
<li>多线程需要可变字符串：<code>StringBuffer</code>（或外部同步）。</li>
<li>单线程&#x2F;局部构造字符串：<code>StringBuilder</code>。</li>
<li>常量字符串或少量拼接：<code>String</code>（编译器对 <code>+</code> 会优化为 <code>StringBuilder</code>）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="11-为什么-String-是不可变的（immutable）？"><a href="#11-为什么-String-是不可变的（immutable）？" class="headerlink" title="11. 为什么 String 是不可变的（immutable）？"></a>11. 为什么 <code>String</code> 是不可变的（immutable）？</h2><p>原因（几条重要理由）：</p>
<ol>
<li><strong>安全性</strong>：<code>String</code> 经常用于关键场景（类加载器、网络地址、文件名、权限检查、数据库连接字符串等）。不可变保证在传递引用时不被恶意或意外修改。</li>
<li><strong>线程安全</strong>：不可变对象固有线程安全，多个线程可共享同一 <code>String</code> 实例而无需同步。</li>
<li><strong>性能（缓存 hashCode）</strong>：<code>String</code> 的哈希值可缓存（<code>hash</code> 字段），便于作为 Map 的 key，避免重复计算。</li>
<li><strong>字符串常量池</strong>：可安全地将字面量放入池中重用，不用复制或担心修改。</li>
<li><strong>优化</strong>：JVM 可进行共享、常量折叠等优化（更易于实现某些编译期&#x2F;运行期优化）。</li>
</ol>
<hr>
<h2 id="12-String-常量池的实现机制？"><a href="#12-String-常量池的实现机制？" class="headerlink" title="12. String 常量池的实现机制？"></a>12. <code>String</code> 常量池的实现机制？</h2><ul>
<li><strong>概念</strong>：编译期和运行期维护一个字符串池（String Intern Pool），用于存放字符串字面量（literal）和显式 <code>intern()</code> 后的字符串，以便重用相同内容的 <code>String</code> 实例。</li>
<li><strong>编译期</strong>：源代码中的字符串字面量（如 <code>&quot;abc&quot;</code>）会被放到常量池（编译后的 class 文件常量池），类加载后这些字面量会放入运行时的字符串池。</li>
<li><strong>运行期</strong>：<ul>
<li>以前（Java 6 及更早）：字符串常量池在 PermGen（方法区）中。</li>
<li>Java 7 起：常量池迁移到 Java 堆（运行时常量池也在堆里），避免 PermGen 问题。</li>
</ul>
</li>
<li><strong>intern()</strong>：当调用 <code>s.intern()</code> 时，JVM 会检查池中是否已有相同内容的字符串：<ul>
<li>若存在，返回池中的引用；</li>
<li>若不存在，将该字符串的引用加入池并返回它。</li>
</ul>
</li>
<li><strong>编译时优化</strong>：字符串常量的拼接（编译时常量）会在编译期合并，如 <code>&quot;a&quot; + &quot;b&quot;</code> → <code>&quot;ab&quot;</code>，直接放入常量池；而运行时拼接（变量参与）则使用 <code>StringBuilder</code>。</li>
</ul>
<hr>
<h2 id="13-new-String-abc-创建了几个对象？"><a href="#13-new-String-abc-创建了几个对象？" class="headerlink" title="13. new String(&quot;abc&quot;) 创建了几个对象？"></a>13. <code>new String(&quot;abc&quot;)</code> 创建了几个对象？</h2><ul>
<li><strong>通常情形</strong>：<ul>
<li>若 <code>&quot;abc&quot;</code> 字面量尚未在常量池中存在，执行 <code>new String(&quot;abc&quot;)</code> 会导致 <strong>两个对象</strong> 被创建：常量池中的 <code>&quot;abc&quot;</code>（一个 <code>String</code>）和堆中通过 <code>new</code> 创建的新的 <code>String</code> 实例（内容通常是对常量池中字符数组的复制或共享，具体实现随 Java 版本而异）。</li>
<li>如果字面量 <code>&quot;abc&quot;</code> 已经存在于常量池中（例如之前被加载过），那么 <code>new String(&quot;abc&quot;)</code> 只会创建 <strong>一个堆对象</strong>（new 的那个 <code>String</code>）。</li>
</ul>
</li>
<li><strong>注意</strong>：自 Java 7&#x2F;9 后 <code>String</code> 内部实现改变（压缩字符串、byte[] 存储等），但逻辑上上述结论成立：通常 1 或 2 个对象，取决于常量池中是否已存在该字面量。</li>
</ul>
<hr>
<h2 id="14-final-关键字的作用？"><a href="#14-final-关键字的作用？" class="headerlink" title="14. final 关键字的作用？"></a>14. <code>final</code> 关键字的作用？</h2><ul>
<li><strong>用于类（final class）</strong>：类不可被继承（如 <code>String</code>）。</li>
<li><strong>用于方法（final 方法）</strong>：方法不能被子类重写（override），用于确保行为不可变。</li>
<li><strong>用于变量（final 字段&#x2F;局部变量）</strong>：<ul>
<li>对基本类型：赋值后值不可改变（常量）。</li>
<li>对引用类型：引用不可改变（不能指向另一个对象），但所指向对象的内部状态仍可变（除非对象本身不可变）。</li>
<li><code>static final</code> 常用来定义常量（编译期常量）。</li>
</ul>
</li>
<li><strong>用于参数</strong>（方法形参可以声明为 <code>final</code>）：代表方法内不能修改该参数引用&#x2F;值。</li>
<li><strong>其它用途</strong>：在多线程中，<code>final</code> 字段的写-构造过程被 JMM（Java 内存模型）处理，确保构造完成后其他线程可见（安全发布方面有好处）。</li>
</ul>
<hr>
<h2 id="15-static-关键字的作用？"><a href="#15-static-关键字的作用？" class="headerlink" title="15. static 关键字的作用？"></a>15. <code>static</code> 关键字的作用？</h2><ul>
<li>用于声明类级别成员（字段、方法、初始化块、嵌套类），不依赖实例。</li>
<li><strong>static 变量</strong>：类变量，所有实例共享一份。内存中仅有一份副本。</li>
<li><strong>static 方法</strong>：类方法，可通过 <code>ClassName.method()</code> 调用；不能直接访问非静态成员（因无 this）。</li>
<li><strong>static 代码块</strong>：类加载时执行一次（用于静态初始化）。</li>
<li><strong>static 嵌套类</strong>：可以声明为静态的内部类（静态嵌套类），没有外部实例引用。</li>
</ul>
<hr>
<h2 id="16-static-修饰变量、方法、代码块分别意味着什么？"><a href="#16-static-修饰变量、方法、代码块分别意味着什么？" class="headerlink" title="16. static 修饰变量、方法、代码块分别意味着什么？"></a>16. <code>static</code> 修饰变量、方法、代码块分别意味着什么？</h2><ul>
<li><strong>static 变量（类变量）</strong>：<ul>
<li>随类加载而创建，所有对象共享同一份数据。</li>
<li>可通过 <code>ClassName.field</code> 或 <code>instance.field</code>（不推荐）访问。</li>
</ul>
</li>
<li><strong>static 方法</strong>：<ul>
<li>属于类，调用时无需实例。</li>
<li>不能使用 <code>this</code>、不能直接访问非静态成员。</li>
<li>可作为工具方法（如 <code>Math.abs()</code>）。</li>
</ul>
</li>
<li><strong>static 代码块</strong>：<ul>
<li>在类加载阶段执行一次，用于复杂静态初始化（比如初始化静态常量、加载本地库等）。</li>
<li>执行顺序：静态块按定义顺序执行，类加载时运行（在实例化之前）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="17-static-和-final-能一起用吗？"><a href="#17-static-和-final-能一起用吗？" class="headerlink" title="17. static 和 final 能一起用吗？"></a>17. <code>static</code> 和 <code>final</code> 能一起用吗？</h2><ul>
<li><p><strong>能</strong>。<code>static final</code> 常用于定义类常量（尤其是基本类型和 <code>String</code>），例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static final int MAX = 100;</span><br><span class="line">public static final String NAME = &quot;abc&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>区别</strong>：</p>
<ul>
<li>如果是编译期常量（<code>static final</code> 基本类型或 <code>String</code> 且在编译时可以确定），编译器会将其内联到使用处（被引用的类编译后看到的是常量值），注意跨模块修改可能导致需要重新编译引用方。</li>
<li>如果是 <code>static final</code> 引用对象且不是编译期常量，则引用本身不可变，但对象内容可能可变。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="18-static-内部类和非静态内部类的区别？"><a href="#18-static-内部类和非静态内部类的区别？" class="headerlink" title="18. static 内部类和非静态内部类的区别？"></a>18. <code>static</code> 内部类和非静态内部类的区别？</h2><ul>
<li><strong>静态内部类（static nested class）</strong>：<ul>
<li>相当于外部类的一个静态成员。</li>
<li><strong>没有</strong>对外部类实例的隐式引用（不能直接访问外部类的非静态成员）。</li>
<li>可以像普通类那样实例化：<code>Outer.StaticInner inner = new Outer.StaticInner();</code></li>
</ul>
</li>
<li><strong>非静态内部类（inner class）</strong>：<ul>
<li>每个实例隐式持有一个外部类实例引用（<code>Outer.this</code>），可以直接访问外部类的所有成员（包括私有成员）。</li>
<li>创建方式：<code>Outer outer = new Outer(); Outer.Inner inner = outer.new Inner();</code></li>
<li>占用外部类对象的内存引用，可能导致内存泄露（如果长期持有内部类实例导致外部类不能被回收）。</li>
</ul>
</li>
<li><strong>选择原则</strong>：如果内部类不需要访问外部实例成员，优先使用 <code>static</code> 嵌套类，避免额外引用。</li>
</ul>
<hr>
<h2 id="19-Java-中的-this-和-super-的区别？"><a href="#19-Java-中的-this-和-super-的区别？" class="headerlink" title="19. Java 中的 this 和 super 的区别？"></a>19. Java 中的 <code>this</code> 和 <code>super</code> 的区别？</h2><ul>
<li><strong>this</strong>：<ul>
<li>引用当前对象的引用。</li>
<li>用于访问当前类的实例变量、调用当前类的其他构造器（<code>this(...)</code>）、或传递当前对象引用。</li>
</ul>
</li>
<li><strong>super</strong>：<ul>
<li>引用当前对象的父类部分。</li>
<li>用于访问父类被覆盖的方法（<code>super.method()</code>）、父类字段（若有同名字段）、以及在子类构造器第一行调用父类构造器（<code>super(...)</code>）。</li>
</ul>
</li>
<li><strong>注意</strong>：<ul>
<li><code>this()</code> 或 <code>super()</code> 必须在构造器的第一行（两者不能同时出现）。</li>
<li><code>super</code> 不能用于访问父类的 private 成员（编译期限制）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="20-Java-中构造方法能否被重写？"><a href="#20-Java-中构造方法能否被重写？" class="headerlink" title="20. Java 中构造方法能否被重写？"></a>20. Java 中构造方法能否被重写？</h2><ul>
<li><strong>不能</strong>。重写（override）适用于实例方法，构造方法不是继承的成员，子类不能重写父类的构造器。</li>
<li><strong>可以重载（overload）</strong>：在同一类中同名构造器有不同参数列表属于重载。</li>
<li>子类构造器可通过 <code>super(...)</code> 显式调用父类构造器来完成父类初始化。</li>
</ul>
<hr>
<h2 id="21-接口和抽象类的区别？"><a href="#21-接口和抽象类的区别？" class="headerlink" title="21. 接口和抽象类的区别？"></a>21. 接口和抽象类的区别？</h2><ul>
<li><strong>接口（interface）</strong>：<ul>
<li>早期（Java 7 之前）：只包含抽象方法（默认是 <code>public abstract</code>）和 <code>public static final</code> 常量。</li>
<li>Java 8+：可以包含 <code>default</code> 方法与 <code>static</code> 方法（可以有部分实现）；Java 9+ 允许 <code>private</code> 方法。</li>
<li>支持多继承（一个类可以实现多个接口）。</li>
<li>没有实例字段（除 <code>static final</code> 常量外）。</li>
</ul>
</li>
<li><strong>抽象类（abstract class）</strong>：<ul>
<li>可以有实例字段（非静态成员变量）、已有实现的方法（具体方法）、构造器。</li>
<li>适合表示一类有共同行为并共享状态的类层次。</li>
<li>类只能单继承（只能继承一个抽象类）。</li>
</ul>
</li>
<li><strong>选择建议</strong>：<ul>
<li>如果需要多继承行为、只定义方法契约且不需要状态，使用接口。</li>
<li>如果需要提供共有实现和状态，使用抽象类。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="22-接口中可以有-default-方法和-static-方法吗？"><a href="#22-接口中可以有-default-方法和-static-方法吗？" class="headerlink" title="22. 接口中可以有 default 方法和 static 方法吗？"></a>22. 接口中可以有 <code>default</code> 方法和 <code>static</code> 方法吗？</h2><ul>
<li><strong>可以（Java 8 起）</strong>。<ul>
<li><code>default</code> 方法：为实现类提供默认实现，避免破坏已有实现（接口演化）。实现类可以覆盖（override）。</li>
<li><code>static</code> 方法：属于接口自身，可以通过 <code>InterfaceName.method()</code> 调用，不能通过实例调用。</li>
</ul>
</li>
<li>Java 9 及以后还可有 <code>private</code> 方法，供接口内部复用实现逻辑。</li>
</ul>
<hr>
<h2 id="23-Java-8-接口新增了什么？"><a href="#23-Java-8-接口新增了什么？" class="headerlink" title="23. Java 8 接口新增了什么？"></a>23. Java 8 接口新增了什么？</h2><ul>
<li>Java 8 在接口中新增了 <strong>default 方法</strong> 和 <strong>static 方法</strong>，允许接口提供带实现的方法，从而便于接口的演化（向后兼容）。这也是 Java 8 引入函数式编程支持的基础之一（允许接口作为函数式接口）。</li>
</ul>
<hr>
<h2 id="24-Java-8-有什么新特性，并详细介绍（重点）"><a href="#24-Java-8-有什么新特性，并详细介绍（重点）" class="headerlink" title="24. Java 8 有什么新特性，并详细介绍（重点）"></a>24. Java 8 有什么新特性，并详细介绍（重点）</h2><hr>
<h1 id="一、Java-8-新特性深入解析"><a href="#一、Java-8-新特性深入解析" class="headerlink" title="一、Java 8 新特性深入解析"></a>一、Java 8 新特性深入解析</h1><h2 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1. Lambda 表达式"></a>1. Lambda 表达式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>匿名函数，允许把行为作为参数传递。</li>
<li>简化匿名内部类写法，实现函数式编程。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">Collections.sort(list, (s1, s2) -&gt; s1.length() - s2.length());</span><br></pre></td></tr></table></figure>

<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><ul>
<li>编译器生成静态&#x2F;实例方法 + <code>invokedynamic</code> 指令。</li>
<li>JVM 调用 <code>LambdaMetafactory</code> 动态生成函数对象，实现 <strong>函数式接口</strong>。</li>
<li>捕获外部变量通过闭包机制存储（必须是 <code>effectively final</code>）。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>语法简洁</li>
<li>可作为参数传递行为</li>
<li>性能高于匿名内部类（减少对象创建）</li>
</ul>
<hr>
<h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>仅有一个抽象方法的接口，用作 Lambda 表达式的目标类型。</li>
<li>可用 <code>@FunctionalInterface</code> 标识。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Converter&lt;String, Integer&gt; c = Integer::valueOf;</span><br><span class="line">System.out.println(c.convert(&quot;123&quot;)); // 123</span><br></pre></td></tr></table></figure>

<h3 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h3><ul>
<li>Lambda 表达式编译时生成实现函数式接口的函数对象。</li>
<li>捕获变量通过闭包对象保存。</li>
</ul>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>简化匿名类</li>
<li>支持函数式编程</li>
<li>可与 Stream &#x2F; Optional 等结合</li>
</ul>
<hr>
<h2 id="3-Stream-API"><a href="#3-Stream-API" class="headerlink" title="3. Stream API"></a>3. Stream API</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul>
<li>对集合进行声明式操作（过滤、映射、归约）。</li>
<li>支持 <strong>惰性求值</strong> 和 <strong>并行处理</strong>。</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;);</span><br><span class="line">List&lt;String&gt; filtered = names.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt; 3)</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">System.out.println(filtered); // [ALICE, CHARLIE]</span><br></pre></td></tr></table></figure>

<h3 id="底层原理-2"><a href="#底层原理-2" class="headerlink" title="底层原理"></a>底层原理</h3><ul>
<li>Stream 是流水线对象，中间操作返回新的 Stream，终端操作触发计算。</li>
<li>串行流：顺序迭代器处理</li>
<li>并行流：ForkJoinPool 分块处理</li>
</ul>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>声明式、链式操作</li>
<li>支持并行</li>
<li>可与 Lambda &#x2F; 方法引用结合</li>
</ul>
<hr>
<h2 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul>
<li>Lambda 表达式的简化写法，引用现有方法。</li>
<li>类型：<ol>
<li>静态方法引用：<code>ClassName::staticMethod</code></li>
<li>实例方法引用：<code>instance::method</code></li>
<li>构造器引用：<code>ClassName::new</code></li>
</ol>
</li>
</ul>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;);</span><br><span class="line">names.forEach(System.out::println); // 实例方法引用</span><br><span class="line">Supplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::new; // 构造器引用</span><br></pre></td></tr></table></figure>

<h3 id="底层原理-3"><a href="#底层原理-3" class="headerlink" title="底层原理"></a>底层原理</h3><ul>
<li>编译器转成 Lambda 表达式 + invokedynamic。</li>
<li>JVM 生成实现函数式接口的函数对象，内部持有方法引用。</li>
</ul>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul>
<li>简洁直观</li>
<li>可减少 Lambda 代码</li>
<li>与 Stream &#x2F; Optional 配合使用</li>
</ul>
<hr>
<h2 id="5-java-time-API"><a href="#5-java-time-API" class="headerlink" title="5. java.time API"></a>5. java.time API</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><ul>
<li>替代 <code>Date</code> &#x2F; <code>Calendar</code>，不可变、线程安全。</li>
<li>核心类：<ul>
<li><code>LocalDate</code> &#x2F; <code>LocalTime</code> &#x2F; <code>LocalDateTime</code>（无时区）</li>
<li><code>ZonedDateTime</code>（带时区）</li>
<li><code>Duration</code> &#x2F; <code>Period</code>（时间段）</li>
</ul>
</li>
</ul>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plusDays(1);</span><br><span class="line">ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(&quot;Asia/Singapore&quot;));</span><br><span class="line">System.out.println(tomorrow);</span><br><span class="line">System.out.println(zdt);</span><br></pre></td></tr></table></figure>

<h3 id="底层原理-4"><a href="#底层原理-4" class="headerlink" title="底层原理"></a>底层原理</h3><ul>
<li>内部字段 <code>final</code> 保存值，不可变。</li>
<li>工厂方法创建对象，链式操作返回新对象。</li>
<li>使用 enum + 整型&#x2F;字节优化存储（如 LocalDate 年月日用 int）。</li>
</ul>
<h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul>
<li>不可变，线程安全</li>
<li>链式操作，易组合</li>
<li>支持各种历法和时区计算</li>
</ul>
<hr>
<h2 id="6-Optional"><a href="#6-Optional" class="headerlink" title="6. Optional"></a>6. Optional</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><ul>
<li>容器对象，防止 <code>NullPointerException</code>。</li>
<li>可以包含值或为空（empty）。</li>
</ul>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt1 = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">Optional&lt;String&gt; opt2 = Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(opt1.isPresent()); <span class="comment">// true</span></span><br><span class="line">System.out.println(opt2.orElse(<span class="string">&quot;Default&quot;</span>)); <span class="comment">// Default</span></span><br><span class="line">opt1.map(String::toUpperCase).ifPresent(System.out::println); <span class="comment">// HELLO</span></span><br></pre></td></tr></table></figure>

<h3 id="底层原理-5"><a href="#底层原理-5" class="headerlink" title="底层原理"></a>底层原理</h3><ul>
<li>内部 <code>value</code> 字段存储非空值，空值使用单例 <code>EMPTY</code>。</li>
<li><code>map</code> &#x2F; <code>flatMap</code> &#x2F; <code>filter</code> 返回新的 Optional，对象不可变。</li>
<li>与 Lambda &#x2F; 函数式接口结合实现链式安全操作。</li>
</ul>
<h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><ul>
<li>避免显式 null 判断</li>
<li>支持链式调用</li>
<li>可与 Stream &#x2F; Lambda 配合</li>
</ul>
<hr>
<h2 id="Java-8-六大核心特性底层对比表"><a href="#Java-8-六大核心特性底层对比表" class="headerlink" title="Java 8 六大核心特性底层对比表"></a>Java 8 六大核心特性底层对比表</h2><table>
<thead>
<tr>
<th>特性</th>
<th>底层实现</th>
<th>核心原理</th>
<th>优势</th>
</tr>
</thead>
<tbody><tr>
<td>Lambda</td>
<td>invokedynamic + LambdaMetafactory</td>
<td>动态生成函数对象</td>
<td>简洁、性能高</td>
</tr>
<tr>
<td>函数式接口</td>
<td>单抽象方法接口</td>
<td>捕获变量通过闭包存储</td>
<td>简化匿名类，函数式编程</td>
</tr>
<tr>
<td>Stream API</td>
<td>流水线 + 延迟求值</td>
<td>中间操作惰性，终端触发</td>
<td>声明式、可并行</td>
</tr>
<tr>
<td>方法引用</td>
<td>Lambda 简化语法 + invokedynamic</td>
<td>内部持有方法引用</td>
<td>简洁直观，减少代码</td>
</tr>
<tr>
<td>java.time</td>
<td>不可变对象 + 工厂方法</td>
<td>final字段保存值，链式返回新对象</td>
<td>线程安全，可组合</td>
</tr>
<tr>
<td>Optional</td>
<td>包装对象 + 单例 EMPTY</td>
<td>不可变容器，函数式链式调用</td>
<td>避免 NPE，安全链式操作</td>
</tr>
</tbody></table>
<hr>
<h1 id="二、synchronized-底层原理深入解析"><a href="#二、synchronized-底层原理深入解析" class="headerlink" title="二、synchronized 底层原理深入解析"></a>二、synchronized 底层原理深入解析</h1><h2 id="1-JVM-锁的类型"><a href="#1-JVM-锁的类型" class="headerlink" title="1. JVM 锁的类型"></a>1. JVM 锁的类型</h2><table>
<thead>
<tr>
<th>锁类型</th>
<th>特点</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁 (Biased Lock)</td>
<td>无竞争时偏向第一个线程，轻量</td>
<td>高</td>
</tr>
<tr>
<td>轻量级锁 (Lightweight)</td>
<td>竞争少时使用 CAS 升级锁</td>
<td>中</td>
</tr>
<tr>
<td>重量级锁 (Monitor)</td>
<td>高竞争时使用 OS mutex，阻塞线程</td>
<td>低</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-synchronized-对象头结构"><a href="#2-synchronized-对象头结构" class="headerlink" title="2. synchronized 对象头结构"></a>2. synchronized 对象头结构</h2><ul>
<li>每个对象在 JVM 内存中都有 <strong>对象头（Mark Word）</strong>，存储锁信息、哈希码、GC 标记等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象头 Mark Word (32/64bit)</span><br><span class="line">+----------------+----------------+----------------+</span><br><span class="line">| HashCode       | GC info        | Lock info      |</span><br><span class="line">+----------------+----------------+----------------+</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>锁标记位</strong>：<ul>
<li>00：无锁</li>
<li>01：偏向锁</li>
<li>10：轻量级锁</li>
<li>11：重量级锁</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-synchronized-执行流程"><a href="#3-synchronized-执行流程" class="headerlink" title="3. synchronized 执行流程"></a>3. synchronized 执行流程</h2><h3 id="a-偏向锁（无竞争）"><a href="#a-偏向锁（无竞争）" class="headerlink" title="a) 偏向锁（无竞争）"></a>a) 偏向锁（无竞争）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程获取锁 -&gt; 在对象头打上线程ID -&gt; 执行 -&gt; 释放锁 -&gt; 保持偏向状态</span><br></pre></td></tr></table></figure>

<h3 id="b-轻量级锁（CAS竞争）"><a href="#b-轻量级锁（CAS竞争）" class="headerlink" title="b) 轻量级锁（CAS竞争）"></a>b) 轻量级锁（CAS竞争）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程尝试CAS抢锁 -&gt; 成功：持有锁 -&gt; 执行 -&gt; 释放</span><br><span class="line">                      |-&gt; 失败：升级为重量级锁</span><br></pre></td></tr></table></figure>

<h3 id="c-重量级锁（阻塞）"><a href="#c-重量级锁（阻塞）" class="headerlink" title="c) 重量级锁（阻塞）"></a>c) 重量级锁（阻塞）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程无法获取锁 -&gt; 阻塞（OS等待队列） -&gt; 被唤醒 -&gt; 获取锁 -&gt; 执行 -&gt; 释放锁</span><br></pre></td></tr></table></figure>

<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|  synchronized()  |</span><br><span class="line">+------------------+</span><br><span class="line">          |</span><br><span class="line">    JVM对象头Mark Word</span><br><span class="line">          |</span><br><span class="line">+------------------------+</span><br><span class="line">| 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-synchronized-方法示例"><a href="#4-synchronized-方法示例" class="headerlink" title="4. synchronized 方法示例"></a>4. synchronized 方法示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>锁对象</strong>：实例方法锁住 <code>this</code>，静态方法锁住类对象 <code>ClassName.class</code>。</li>
<li><strong>效果</strong>：同一时间只有一个线程能进入 <code>increment()</code>，保证 <code>count++</code> 操作的原子性。</li>
</ul>
<hr>
<h2 id="5-JVM-优化"><a href="#5-JVM-优化" class="headerlink" title="5. JVM 优化"></a>5. JVM 优化</h2><ul>
<li><strong>锁消除</strong>：编译器或 JIT 可检测无竞争情况，消除同步锁。</li>
<li><strong>锁粗化</strong>：把多次连续的小范围锁合并，减少加锁次数。</li>
<li><strong>偏向锁 &#x2F; 轻量级锁 &#x2F; 重量级锁升级</strong>：动态适应竞争情况，兼顾性能与正确性。</li>
</ul>
<h2 id="25-多态的实现机制是什么？"><a href="#25-多态的实现机制是什么？" class="headerlink" title="25.多态的实现机制是什么？"></a>25.多态的实现机制是什么？</h2><ul>
<li><strong>概念</strong>：同一操作作用于不同对象时表现出不同的行为（主要表现为方法的动态绑定）。</li>
<li><strong>实现机制</strong>：<ul>
<li><strong>编译时</strong>：根据引用类型检查方法签名（静态类型检查）。</li>
<li><strong>运行时</strong>：实际调用的方法根据对象的实际类型（运行时类型）决定；即 <strong>动态绑定（dynamic dispatch）</strong>。</li>
<li>JVM 通常通过 <strong>虚方法表（vtable）&#x2F;方法查找机制</strong> 实现。调用一个非 <code>static</code>、非 <code>private</code>、非 <code>final</code> 的方法时，会在运行时查找实际类的实现并调用。</li>
</ul>
</li>
<li><strong>结果</strong>：子类可以覆盖父类方法，调用者使用父类引用指向子类对象时，调用的是子类的覆盖方法（运行时决定）。</li>
<li><strong>注意</strong>：<code>static</code>、<code>private</code>、<code>final</code> 方法不会被动态绑定（是静态绑定）。</li>
</ul>
<hr>
<h2 id="26-方法重载（overload）和方法重写（override）的区别？"><a href="#26-方法重载（overload）和方法重写（override）的区别？" class="headerlink" title="26. 方法重载（overload）和方法重写（override）的区别？"></a>26. 方法重载（overload）和方法重写（override）的区别？</h2><ul>
<li><p><strong>方法重载（Overloading）</strong>：</p>
<ul>
<li>同一类中方法名相同、参数列表不同（参数类型&#x2F;个数&#x2F;顺序），返回类型可以不同。</li>
<li>编译时决定（重载解析在编译期完成），与继承关系无关。</li>
</ul>
</li>
<li><p><strong>方法重写（Overriding）</strong>：</p>
<ul>
<li>子类定义与父类相同方法签名（方法名 + 参数类型相同）的实现，目的是改变&#x2F;扩展父类行为。</li>
<li>运行时动态绑定，必须满足访问权限不能更严格，抛出的受检异常不能超过父类版本等规则。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overload</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(String s)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// override</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;&#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; <span class="meta">@Override</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;&#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="27-Java-支持多继承吗？如何实现类似效果？"><a href="#27-Java-支持多继承吗？如何实现类似效果？" class="headerlink" title="27. Java 支持多继承吗？如何实现类似效果？"></a>27. Java 支持多继承吗？如何实现类似效果？</h2><ul>
<li><strong>类的多继承</strong>：Java <strong>不支持类的多继承</strong>（不能继承多个类），以避免菱形继承问题（diamond problem）。</li>
<li><strong>实现类似效果的方法</strong>：<ul>
<li><strong>接口多实现</strong>：一个类可以实现多个接口（Java 8 的 <code>default</code> 方法也带来类似多继承方法实现的可能，但有冲突解决规则）。</li>
<li><strong>组合&#x2F;委托（composition&#x2F;delegation）</strong>：在类中持有其它类的实例并把调用委托给它们（优于继承的面向对象设计原则）。</li>
</ul>
</li>
<li><strong>接口冲突解决</strong>：若多个接口提供相同默认方法，类必须重写该方法并明确调用哪个接口的默认实现（<code>InterfaceName.super.method()</code>）。</li>
</ul>
<hr>
<h2 id="28-Java-的四种访问修饰符？"><a href="#28-Java-的四种访问修饰符？" class="headerlink" title="28. Java 的四种访问修饰符？"></a>28. Java 的四种访问修饰符？</h2><ul>
<li><code>public</code>：对所有类可见（任何包）。</li>
<li><code>protected</code>：对同包类和子类可见（即同包或子类可以访问）。</li>
<li><strong>默认（包私有，package-private）</strong>（不写修饰符）：对同包类可见，包外不可见。</li>
<li><code>private</code>：仅在本类内可见，包外&#x2F;子类不可访问（子类无法直接访问父类 private 成员）。</li>
<li><strong>注意</strong>：对类（顶层类）只能使用 <code>public</code> 或默认（包私有），不能声明为 <code>private</code>&#x2F;<code>protected</code>。</li>
</ul>
<hr>
<h2 id="29-transient-关键字的作用？"><a href="#29-transient-关键字的作用？" class="headerlink" title="29. transient 关键字的作用？"></a>29. <code>transient</code> 关键字的作用？</h2><ul>
<li>用于标记字段在 Java 序列化（<code>Serializable</code>）过程中<strong>不被序列化</strong>。</li>
<li>被标记为 <code>transient</code> 的字段在序列化后不会写入序列化流，反序列化时这些字段会以默认值恢复（基本类型 0，引用类型 <code>null</code>）。</li>
<li>常用于敏感信息（密码）、不需要持久化的缓存字段、或可重建的状态字段。</li>
<li>注意：<code>static</code> 字段本身也不会被序列化（因为是类级别，不属于实例状态）。</li>
</ul>
<hr>
<h2 id="30-volatile-关键字的作用？"><a href="#30-volatile-关键字的作用？" class="headerlink" title="30. volatile 关键字的作用？"></a>30. <code>volatile</code> 关键字的作用？</h2><ul>
<li><strong>可见性</strong>：保证对 <code>volatile</code> 变量的写入对其它线程立即可见（读取总是从主内存而不是线程缓存读取）。</li>
<li><strong>禁止指令重排序（部分）</strong>：读&#x2F;写 <code>volatile</code> 存在的内存屏障能保证一定的有序性（写 <code>volatile</code> 发生在后续读的可见性上，更多细节参考 JMM）。</li>
<li><strong>不保证原子性</strong>：对单次读&#x2F;写操作是原子的（对 <code>long</code>&#x2F;<code>double</code> 在 Java 5 后也保证原子），但非原子操作（如 <code>i++</code>）不是原子的。</li>
<li><strong>典型用途</strong>：<ul>
<li>状态标志（如 <code>volatile boolean running</code>）。</li>
<li>用于实现双重检查锁定（DCL）单例中的 <code>instance</code>（在 Java 5+ 环境下有效）。</li>
</ul>
</li>
<li><strong>与 synchronized 比较</strong>：<ul>
<li><code>volatile</code> 轻量，只保证可见性与部分有序性，不保证互斥；适用于简单状态通信。</li>
<li><code>synchronized</code> 提供互斥和可见性保证（更重），并可配合 <code>wait/notify</code>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="31-synchronized-的作用及底层原理？"><a href="#31-synchronized-的作用及底层原理？" class="headerlink" title="31. synchronized 的作用及底层原理？"></a>31. <code>synchronized</code> 的作用及底层原理？</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><strong>互斥（排它）</strong>：保证同一时间只有一个线程可以执行被 <code>synchronized</code> 修饰的代码块或方法（针对同一把锁）。</li>
<li><strong>可见性</strong>：进入&#x2F;退出同步块会建立 happens-before 关系，确保锁释放前的写对随后获取该锁的线程可见。</li>
<li><strong>用途</strong>：保护临界区、确保多个线程对共享可变状态的安全访问。</li>
</ul>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul>
<li><strong>方法级别</strong>：<ul>
<li><code>synchronized void m() &#123; ... &#125;</code>：等价于 <code>synchronized(this)</code>（实例方法）或 <code>synchronized (ClassName.class)</code>（静态方法）。</li>
</ul>
</li>
<li><strong>代码块级别</strong>：<ul>
<li><code>synchronized(this) &#123; ... &#125;</code> 或 <code>synchronized(lockObj) &#123; ... &#125;</code> 更灵活，能减小锁的粒度。</li>
</ul>
</li>
</ul>
<h3 id="底层原理（HotSpot-实现概要）"><a href="#底层原理（HotSpot-实现概要）" class="headerlink" title="底层原理（HotSpot 实现概要）"></a>底层原理（HotSpot 实现概要）</h3><ul>
<li>JVM 使用对象头（object header）中的 <strong>mark word</strong> 和关联数据结构维护锁状态。</li>
<li>锁优化策略（为提升性能，HotSpot 引入若干优化）：<ol>
<li><strong>偏向锁（Biased Locking）</strong>：在没有竞争的情况下，锁会偏向于第一次获得它的线程，重复获取无需 CAS，减少开销。</li>
<li><strong>轻量级锁（Lightweight Locking）</strong>：使用 CAS 操作在栈上记录加锁记录，避免进入重量级监视器（monitor）。</li>
<li><strong>重量级锁（Monitor&#x2F;Mutex）</strong>：当竞争激烈或 CAS 失败时，升级为重量级锁，使用操作系统互斥量（可能涉及线程阻塞&#x2F;唤醒）。</li>
</ol>
</li>
<li><code>monitorenter</code> &#x2F; <code>monitorexit</code> 是字节码指令（由编译器&#x2F;字节码生成器生成）。</li>
<li>JIT 编译器可进行锁消除、锁粗化、锁优化等（当能证明无并发访问或已外部同步时）。</li>
</ul>
<h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait/notify&#x2F;notifyAll"></a><code>wait/notify</code>&#x2F;<code>notifyAll</code></h3><ul>
<li><code>Object.wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 必须在持有对象监视器（即在 <code>synchronized</code> 块内）时调用，用于线程间协作（条件等待&#x2F;通知）。</li>
<li><code>wait()</code> 会释放锁并进入等待队列；<code>notify()</code> 唤醒等待队列中的一个线程（被唤醒线程在重新获得锁后继续）。</li>
</ul>
<h3 id="注意与陷阱"><a href="#注意与陷阱" class="headerlink" title="注意与陷阱"></a>注意与陷阱</h3><ul>
<li>锁粒度：避免用过大锁（如 <code>synchronized</code> 在方法头部锁住大量操作），谨慎使用 <code>String</code> 或装箱对象作为锁（可能会导致多个实例共用同一锁或锁被外部持有）。</li>
<li>死锁：多线程锁顺序不当可能死锁；设计时谨防。</li>
<li>性能：在高并发下可考虑使用 <code>java.util.concurrent</code> 包（<code>ReentrantLock</code>、<code>ConcurrentHashMap</code>、<code>AtomicXxx</code>）等更细粒度、高性能的并发工具。</li>
</ul>
<hr>
<h2 id="二、面向对象编程（OOP）"><a href="#二、面向对象编程（OOP）" class="headerlink" title="二、面向对象编程（OOP）"></a>二、面向对象编程（OOP）</h2><hr>
<h2 id="1-面向对象的三大特性是什么？"><a href="#1-面向对象的三大特性是什么？" class="headerlink" title="1. 面向对象的三大特性是什么？"></a><strong>1. 面向对象的三大特性是什么？</strong></h2><ul>
<li><strong>封装（Encapsulation）</strong>：隐藏实现细节，只暴露必要接口。</li>
<li><strong>继承（Inheritance）</strong>：子类复用父类属性和方法，扩展功能。</li>
<li><strong>多态（Polymorphism）</strong>：同一接口，不同实现。表现为方法重写、方法重载。</li>
</ul>
<hr>
<h2 id="2-封装的作用是什么？"><a href="#2-封装的作用是什么？" class="headerlink" title="2. 封装的作用是什么？"></a><strong>2. 封装的作用是什么？</strong></h2><ul>
<li>隐藏对象内部实现细节，只暴露必要接口。</li>
<li>提高代码复用性、安全性，避免数据被随意修改。</li>
<li>例如：类的成员变量用 <code>private</code>，提供 <code>getter/setter</code> 访问。</li>
</ul>
<hr>
<h2 id="3-多态的优点是什么？"><a href="#3-多态的优点是什么？" class="headerlink" title="3. 多态的优点是什么？"></a><strong>3. 多态的优点是什么？</strong></h2><ul>
<li><strong>接口统一</strong>：不同实现类可通过父类&#x2F;接口操作。</li>
<li><strong>可扩展性强</strong>：新增子类不影响原有代码。</li>
<li><strong>解耦</strong>：调用方只依赖抽象，而不依赖具体实现。</li>
<li>例：<code>List list = new ArrayList();</code>，后续可换成 <code>LinkedList</code>。</li>
</ul>
<hr>
<h2 id="4-重写方法时返回值能否不同？"><a href="#4-重写方法时返回值能否不同？" class="headerlink" title="4. 重写方法时返回值能否不同？"></a><strong>4. 重写方法时返回值能否不同？</strong></h2><ul>
<li><strong>不能完全不同</strong>。</li>
<li>Java 允许 <strong>协变返回类型</strong>：子类方法的返回值类型可以是父类方法返回值的子类。</li>
<li>例如：父类返回 <code>Number</code>，子类可以返回 <code>Integer</code>。</li>
</ul>
<hr>
<h2 id="5-构造函数能否被继承？"><a href="#5-构造函数能否被继承？" class="headerlink" title="5. 构造函数能否被继承？"></a><strong>5. 构造函数能否被继承？</strong></h2><ul>
<li><strong>不能继承</strong>，因为构造函数名必须与类名相同。</li>
<li>但子类可通过 <code>super(...)</code> 调用父类构造方法。</li>
</ul>
<hr>
<h2 id="6-构造函数能否-private？"><a href="#6-构造函数能否-private？" class="headerlink" title="6. 构造函数能否 private？"></a><strong>6. 构造函数能否 private？</strong></h2><ul>
<li><strong>可以</strong>，常见于单例模式（饿汉&#x2F;懒汉&#x2F;枚举单例）。</li>
<li>作用：禁止外部 <code>new</code>，只能通过类提供的方法获取实例。</li>
</ul>
<hr>
<h2 id="7-单例模式的几种实现方式？"><a href="#7-单例模式的几种实现方式？" class="headerlink" title="7. 单例模式的几种实现方式？"></a><strong>7. 单例模式的几种实现方式？</strong></h2><ol>
<li>饿汉式（类加载即实例化，线程安全，但可能浪费内存）。</li>
<li>懒汉式（延迟加载，需加 <code>synchronized</code> 保证线程安全）。</li>
<li>双重检查锁（DCL，volatile + synchronized，性能优）。</li>
<li>静态内部类（推荐，利用类加载机制，线程安全）。</li>
<li>枚举单例（最佳实践，防止反射和反序列化攻击）。</li>
</ol>
<hr>
<h2 id="8-饿汉式和懒汉式单例的区别？"><a href="#8-饿汉式和懒汉式单例的区别？" class="headerlink" title="8. 饿汉式和懒汉式单例的区别？"></a><strong>8. 饿汉式和懒汉式单例的区别？</strong></h2><ul>
<li><strong>饿汉式</strong>：类加载时实例化 → 线程安全，启动时可能浪费内存。</li>
<li><strong>懒汉式</strong>：第一次使用时才实例化 → 节省资源，但需加锁保证线程安全。</li>
</ul>
<hr>
<h2 id="9-为什么要使用内部类？"><a href="#9-为什么要使用内部类？" class="headerlink" title="9. 为什么要使用内部类？"></a><strong>9. 为什么要使用内部类？</strong></h2><ul>
<li>内部类可以 <strong>访问外部类的私有成员</strong>。</li>
<li>更好地组织代码，使逻辑更紧密。</li>
<li>在需要回调或事件监听时常用。</li>
</ul>
<hr>
<h2 id="10-成员内部类、局部内部类、静态内部类的区别？"><a href="#10-成员内部类、局部内部类、静态内部类的区别？" class="headerlink" title="10. 成员内部类、局部内部类、静态内部类的区别？"></a><strong>10. 成员内部类、局部内部类、静态内部类的区别？</strong></h2><ul>
<li><strong>成员内部类</strong>：依附于外部类实例，可以访问外部类实例变量。</li>
<li><strong>局部内部类</strong>：定义在方法内部，作用范围仅在方法内。</li>
<li><strong>静态内部类</strong>：不依赖外部类实例，只能访问外部类静态成员。</li>
</ul>
<hr>
<h2 id="11-Java-中对象的创建方式有哪些？"><a href="#11-Java-中对象的创建方式有哪些？" class="headerlink" title="11. Java 中对象的创建方式有哪些？"></a><strong>11. Java 中对象的创建方式有哪些？</strong></h2><ol>
<li><code>new</code> 关键字。</li>
<li>反射 <code>Class.newInstance()</code>。</li>
<li><code>Constructor.newInstance()</code>。</li>
<li>通过 <code>clone()</code>。</li>
<li>通过反序列化 <code>ObjectInputStream.readObject()</code>。</li>
</ol>
<hr>
<h2 id="12-对象之间的浅拷贝和深拷贝的区别？"><a href="#12-对象之间的浅拷贝和深拷贝的区别？" class="headerlink" title="12. 对象之间的浅拷贝和深拷贝的区别？"></a><strong>12. 对象之间的浅拷贝和深拷贝的区别？</strong></h2><ul>
<li><strong>浅拷贝</strong>：只复制对象本身，引用字段仍指向同一对象。</li>
<li><strong>深拷贝</strong>：连引用对象也复制一份，完全独立。</li>
</ul>
<hr>
<h2 id="13-clone-方法的原理？"><a href="#13-clone-方法的原理？" class="headerlink" title="13. clone() 方法的原理？"></a><strong>13. clone() 方法的原理？</strong></h2><ul>
<li>来自 <code>Object</code> 类，默认是 <strong>浅拷贝</strong>。</li>
<li>必须实现 <code>Cloneable</code> 接口，否则抛出 <code>CloneNotSupportedException</code>。</li>
<li>可重写 <code>clone()</code> 实现深拷贝。</li>
</ul>
<hr>
<h2 id="14-为什么-Java-不支持多继承？"><a href="#14-为什么-Java-不支持多继承？" class="headerlink" title="14. 为什么 Java 不支持多继承？"></a><strong>14. 为什么 Java 不支持多继承？</strong></h2><ul>
<li>为了避免 <strong>菱形继承问题</strong>（多个父类方法冲突）。</li>
<li>Java 使用 <strong>接口</strong> 来实现多继承特性。</li>
</ul>
<hr>
<h2 id="15-Java-是值传递还是引用传递？"><a href="#15-Java-是值传递还是引用传递？" class="headerlink" title="15. Java 是值传递还是引用传递？"></a><strong>15. Java 是值传递还是引用传递？</strong></h2><ul>
<li>Java <strong>只有值传递</strong>。</li>
<li>对象参数传递的是 <strong>引用的副本</strong>（值），但指向同一对象。</li>
</ul>
<hr>
<h2 id="16-方法参数传递时是如何处理对象的？"><a href="#16-方法参数传递时是如何处理对象的？" class="headerlink" title="16. 方法参数传递时是如何处理对象的？"></a><strong>16. 方法参数传递时是如何处理对象的？</strong></h2><ul>
<li>方法内修改对象的字段 → 会影响外部对象。</li>
<li>方法内给引用变量重新赋值 → 不会影响外部对象。</li>
</ul>
<hr>
<h2 id="17-封装性体现在哪些方面？"><a href="#17-封装性体现在哪些方面？" class="headerlink" title="17. 封装性体现在哪些方面？"></a><strong>17. 封装性体现在哪些方面？</strong></h2><ul>
<li>使用 <code>private</code> 修饰成员变量。</li>
<li>提供 <code>getter/setter</code> 控制访问权限。</li>
<li>使用访问修饰符（public&#x2F;protected&#x2F;default&#x2F;private）控制类和方法的可见性。</li>
</ul>
<hr>
<h2 id="18-为什么需要继承？"><a href="#18-为什么需要继承？" class="headerlink" title="18. 为什么需要继承？"></a><strong>18. 为什么需要继承？</strong></h2><ul>
<li>代码复用（减少重复）。</li>
<li>提高扩展性（子类扩展父类功能）。</li>
<li>实现多态，解耦业务逻辑。</li>
</ul>
<hr>
<h2 id="19-重写-Object-类的-toString-方法的意义？"><a href="#19-重写-Object-类的-toString-方法的意义？" class="headerlink" title="19. 重写 Object 类的 toString 方法的意义？"></a><strong>19. 重写 Object 类的 toString 方法的意义？</strong></h2><ul>
<li>提高可读性，方便调试和日志记录。</li>
<li>默认 <code>toString()</code> 打印类名+hashcode，不直观。</li>
<li>重写后可打印对象核心字段信息。</li>
</ul>
<hr>
<h2 id="20-重写-Object-类的-equals-方法时需要注意什么？"><a href="#20-重写-Object-类的-equals-方法时需要注意什么？" class="headerlink" title="20. 重写 Object 类的 equals 方法时需要注意什么？"></a><strong>20. 重写 Object 类的 equals 方法时需要注意什么？</strong></h2><ul>
<li>必须满足 <strong>自反性、对称性、传递性、一致性</strong>。</li>
<li>与 <code>hashCode()</code> 保持一致：相等对象必须有相同的 hashCode。</li>
<li>避免 <code>NullPointerException</code>。</li>
</ul>
<hr>
<h2 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h2><hr>
<h3 id="1-Java-的异常体系结构？"><a href="#1-Java-的异常体系结构？" class="headerlink" title="1. Java 的异常体系结构？"></a>1. Java 的异常体系结构？</h3><ul>
<li><strong>顶层类</strong>：<code>Throwable</code><ul>
<li><strong>Error</strong>（错误，程序无法处理，通常由 JVM 抛出）<ul>
<li>如：<code>OutOfMemoryError</code>、<code>StackOverflowError</code></li>
</ul>
</li>
<li><strong>Exception</strong>（异常，程序可处理）<ul>
<li><strong>Checked Exception</strong>（受检异常，编译期检查）<ul>
<li>如：<code>IOException</code>、<code>SQLException</code></li>
</ul>
</li>
<li><strong>Unchecked Exception</strong>（运行时异常，编译器不强制处理）<ul>
<li>如：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>👉 结构图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Throwable</span><br><span class="line"> ├── Error</span><br><span class="line"> └── Exception</span><br><span class="line">      ├── Checked Exception</span><br><span class="line">      └── Unchecked Exception (RuntimeException)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-Checked-Exception-和-Unchecked-Exception-的区别？"><a href="#2-Checked-Exception-和-Unchecked-Exception-的区别？" class="headerlink" title="2. Checked Exception 和 Unchecked Exception 的区别？"></a>2. Checked Exception 和 Unchecked Exception 的区别？</h3><ul>
<li><strong>Checked Exception（受检异常）</strong><ul>
<li>必须显式处理（try-catch 或 throws 声明）。</li>
<li>编译器强制检查，否则无法通过编译。</li>
<li>典型场景：IO、数据库、网络调用。</li>
</ul>
</li>
<li><strong>Unchecked Exception（非受检异常 &#x2F; 运行时异常）</strong><ul>
<li>不强制处理，编译器不检查。</li>
<li>通常由程序逻辑错误导致。</li>
<li>典型场景：NPE、除零、数组越界。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-throw-和-throws-的区别？"><a href="#3-throw-和-throws-的区别？" class="headerlink" title="3. throw 和 throws 的区别？"></a>3. throw 和 throws 的区别？</h3><ul>
<li><strong>throw</strong><ul>
<li>用于方法体内部，<strong>抛出具体的异常对象</strong>。</li>
<li>语法：<code>throw new Exception(&quot;msg&quot;);</code></li>
</ul>
</li>
<li><strong>throws</strong><ul>
<li>用于方法声明处，<strong>标识该方法可能抛出的异常类型</strong>。</li>
<li>语法：<code>public void test() throws IOException &#123;&#125;</code></li>
</ul>
</li>
</ul>
<p>👉 总结：</p>
<ul>
<li><code>throw</code> &#x3D; 抛出异常实例。</li>
<li><code>throws</code> &#x3D; 声明可能抛出的异常类型。</li>
</ul>
<hr>
<h3 id="4-try-catch-finally-的执行顺序？"><a href="#4-try-catch-finally-的执行顺序？" class="headerlink" title="4. try-catch-finally 的执行顺序？"></a>4. try-catch-finally 的执行顺序？</h3><ol>
<li><code>try</code> 块先执行。</li>
<li>如果发生异常，跳到对应 <code>catch</code> 执行。</li>
<li><code>finally</code> <strong>一定会执行</strong>（除非 <code>System.exit()</code>）。</li>
<li>如果 <code>try</code> 或 <code>catch</code> 有 <code>return</code>，会先执行 <code>finally</code>，再返回结果。</li>
</ol>
<hr>
<h3 id="5-finally-中的-return-会覆盖-try-中的-return-吗？"><a href="#5-finally-中的-return-会覆盖-try-中的-return-吗？" class="headerlink" title="5. finally 中的 return 会覆盖 try 中的 return 吗？"></a>5. finally 中的 return 会覆盖 try 中的 return 吗？</h3><p>✅ <strong>会覆盖</strong>。</p>
<ul>
<li>如果 <code>try</code> 中有 <code>return</code>，但 <code>finally</code> 中也有 <code>return</code>，最终返回的是 <code>finally</code> 的结果。<br> 👉 因此实际开发中 <strong>不推荐在 finally 中写 return</strong>。</li>
</ul>
<hr>
<h3 id="6-try-with-resources-的作用？"><a href="#6-try-with-resources-的作用？" class="headerlink" title="6. try-with-resources 的作用？"></a>6. try-with-resources 的作用？</h3><ul>
<li>Java 7 引入，简化资源管理（如流、数据库连接）。</li>
<li>自动关闭实现了 <code>AutoCloseable</code> 或 <code>Closeable</code> 接口的资源。</li>
<li>避免忘记 <code>finally &#123; resource.close(); &#125;</code>。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>))) &#123;</span><br><span class="line">    System.out.println(br.readLine());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-自定义异常类如何实现？"><a href="#7-自定义异常类如何实现？" class="headerlink" title="7. 自定义异常类如何实现？"></a>7. 自定义异常类如何实现？</h3><ul>
<li>继承 <code>Exception</code>（Checked）或 <code>RuntimeException</code>（Unchecked）。</li>
<li>提供构造方法：无参、带 message、带 cause。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-Error-和-Exception-的区别？"><a href="#8-Error-和-Exception-的区别？" class="headerlink" title="8. Error 和 Exception 的区别？"></a>8. Error 和 Exception 的区别？</h3><ul>
<li><strong>Error</strong>：系统级错误，JVM 无法恢复，程序不应该捕获。<ul>
<li>如 <code>OutOfMemoryError</code>、<code>StackOverflowError</code>。</li>
</ul>
</li>
<li><strong>Exception</strong>：应用级异常，程序应该处理。<ul>
<li>如 <code>IOException</code>、<code>SQLException</code>、<code>NullPointerException</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="9-NullPointerException-常见场景有哪些？"><a href="#9-NullPointerException-常见场景有哪些？" class="headerlink" title="9. NullPointerException 常见场景有哪些？"></a>9. NullPointerException 常见场景有哪些？</h3><ol>
<li>调用空对象的方法：<code>obj.toString()</code>。</li>
<li>访问空数组：<code>arr.length</code>。</li>
<li>访问空集合：<code>list.size()</code>。</li>
<li>自动拆箱：<code>Integer num = null; int n = num;</code>。</li>
<li>Map 查找为 null，再调用方法：<code>map.get(&quot;key&quot;).toString()</code>。</li>
<li>依赖注入&#x2F;未初始化的对象。</li>
</ol>
<hr>
<h3 id="10-运行时异常需要捕获吗？为什么"><a href="#10-运行时异常需要捕获吗？为什么" class="headerlink" title="10. 运行时异常需要捕获吗？为什么"></a>10. 运行时异常需要捕获吗？为什么</h3><ul>
<li><strong>通常不需要显式捕获</strong>，因为它们多由逻辑错误导致（如 NPE、除零）。</li>
<li>捕获运行时异常并不能解决问题，应该<strong>通过修改代码逻辑</strong>避免。</li>
<li>但在某些关键服务（如 API 层）可以用统一异常处理（如 Spring @ControllerAdvice）拦截，避免程序直接崩溃。</li>
</ul>
<hr>
<h2 id="四、集合框架（Collections）"><a href="#四、集合框架（Collections）" class="headerlink" title="四、集合框架（Collections）"></a>四、集合框架（Collections）</h2><hr>
<h3 id="1-Collection-和-Collections-的区别？"><a href="#1-Collection-和-Collections-的区别？" class="headerlink" title="1. Collection 和 Collections 的区别？"></a>1. Collection 和 Collections 的区别？</h3><ul>
<li><strong>Collection</strong>：集合接口，是所有集合类的父接口（List、Set）。</li>
<li><strong>Collections</strong>：工具类，提供操作集合的静态方法（排序、搜索、同步包装等）。</li>
</ul>
<hr>
<h3 id="2-List、Set、Map-的区别？"><a href="#2-List、Set、Map-的区别？" class="headerlink" title="2. List、Set、Map 的区别？"></a>2. List、Set、Map 的区别？</h3><ul>
<li><strong>List</strong>：有序、可重复，按索引访问（ArrayList、LinkedList）。</li>
<li><strong>Set</strong>：无序、不可重复，基于哈希或树（HashSet、TreeSet）。</li>
<li><strong>Map</strong>：键值对存储，Key 不可重复，Value 可重复（HashMap、TreeMap）。</li>
</ul>
<hr>
<h3 id="3-ArrayList-和-LinkedList-的区别？"><a href="#3-ArrayList-和-LinkedList-的区别？" class="headerlink" title="3. ArrayList 和 LinkedList 的区别？"></a>3. ArrayList 和 LinkedList 的区别？</h3><ul>
<li><strong>ArrayList</strong>：基于动态数组，查询快（O(1)），增删慢（O(n)）。</li>
<li><strong>LinkedList</strong>：基于双向链表，增删快（O(1)），查询慢（O(n)）。</li>
</ul>
<hr>
<h3 id="4-HashMap-的底层实现？"><a href="#4-HashMap-的底层实现？" class="headerlink" title="4. HashMap 的底层实现？"></a>4. HashMap 的底层实现？</h3><ul>
<li><strong>JDK 1.7</strong>：数组 + 链表。</li>
<li><strong>JDK 1.8</strong>：数组 + 链表 + 红黑树（链表长度 ≥ 8 时转为树）。</li>
</ul>
<hr>
<h3 id="5-HashMap-1-7-和-1-8-的区别？"><a href="#5-HashMap-1-7-和-1-8-的区别？" class="headerlink" title="5. HashMap 1.7 和 1.8 的区别？"></a>5. HashMap 1.7 和 1.8 的区别？</h3><ol>
<li>1.7：数组 + 链表，采用头插法，易出现并发死循环。</li>
<li>1.8：数组 + 链表&#x2F;红黑树，尾插法，避免死循环，提高性能。</li>
<li>1.8 引入红黑树，查找效率从 O(n) 优化为 O(log n)。</li>
</ol>
<hr>
<h3 id="6-HashMap-如何解决哈希冲突？"><a href="#6-HashMap-如何解决哈希冲突？" class="headerlink" title="6. HashMap 如何解决哈希冲突？"></a>6. HashMap 如何解决哈希冲突？</h3><ul>
<li>方法：拉链法（链表）+ 红黑树。</li>
<li>冲突时，将元素挂到链表&#x2F;树上。</li>
</ul>
<hr>
<h3 id="7-HashSet-的底层实现？"><a href="#7-HashSet-的底层实现？" class="headerlink" title="7. HashSet 的底层实现？"></a>7. HashSet 的底层实现？</h3><ul>
<li>基于 <strong>HashMap</strong> 实现。</li>
<li><code>HashSet</code> 的元素存储在 <code>HashMap</code> 的 key 上，value 为一个固定对象 <code>PRESENT</code>。</li>
</ul>
<hr>
<h3 id="8-ConcurrentHashMap-的底层实现？"><a href="#8-ConcurrentHashMap-的底层实现？" class="headerlink" title="8. ConcurrentHashMap 的底层实现？"></a>8. ConcurrentHashMap 的底层实现？</h3><ul>
<li><strong>JDK 1.7</strong>：分段锁（Segment + HashEntry）。</li>
<li><strong>JDK 1.8</strong>：CAS + synchronized，数据结构与 HashMap 类似，数组 + 链表 + 红黑树。</li>
</ul>
<hr>
<h3 id="9-Hashtable-和-HashMap-的区别？"><a href="#9-Hashtable-和-HashMap-的区别？" class="headerlink" title="9. Hashtable 和 HashMap 的区别？"></a>9. Hashtable 和 HashMap 的区别？</h3><ul>
<li><strong>线程安全性</strong>：Hashtable 是同步的，HashMap 不是。</li>
<li><strong>null</strong>：Hashtable 不允许 key、value 为 null；HashMap 允许一个 null key 和多个 null value。</li>
<li><strong>效率</strong>：HashMap 更高效。</li>
</ul>
<hr>
<h3 id="10-TreeMap-和-HashMap-的区别？"><a href="#10-TreeMap-和-HashMap-的区别？" class="headerlink" title="10. TreeMap 和 HashMap 的区别？"></a>10. TreeMap 和 HashMap 的区别？</h3><ul>
<li><strong>TreeMap</strong>：基于红黑树，有序（按 Key 排序）。</li>
<li><strong>HashMap</strong>：基于哈希表，无序。</li>
</ul>
<hr>
<h3 id="11-WeakHashMap-的特点？"><a href="#11-WeakHashMap-的特点？" class="headerlink" title="11. WeakHashMap 的特点？"></a>11. WeakHashMap 的特点？</h3><ul>
<li>Key 使用 <strong>弱引用</strong>，当没有强引用指向该 Key 时，会被 GC 回收。</li>
<li>常用于缓存。</li>
</ul>
<hr>
<h3 id="12-CopyOnWriteArrayList-的应用场景？"><a href="#12-CopyOnWriteArrayList-的应用场景？" class="headerlink" title="12. CopyOnWriteArrayList 的应用场景？"></a>12. CopyOnWriteArrayList 的应用场景？</h3><ul>
<li>写时复制：写操作时复制新数组，读操作不加锁。</li>
<li>适用于 <strong>读多写少</strong> 的并发场景，比如缓存、订阅列表。</li>
</ul>
<hr>
<h3 id="13-LinkedHashMap-的底层原理？"><a href="#13-LinkedHashMap-的底层原理？" class="headerlink" title="13. LinkedHashMap 的底层原理？"></a>13. LinkedHashMap 的底层原理？</h3><ul>
<li>基于 HashMap + 双向链表。</li>
<li>保证插入顺序（或 LRU 顺序）。</li>
</ul>
<hr>
<h3 id="14-Map-的-key-是否可以为-null？"><a href="#14-Map-的-key-是否可以为-null？" class="headerlink" title="14. Map 的 key 是否可以为 null？"></a>14. Map 的 key 是否可以为 null？</h3><ul>
<li><strong>HashMap</strong>：允许一个 null key。</li>
<li><strong>Hashtable &#x2F; TreeMap</strong>：不允许 null key。</li>
</ul>
<hr>
<h3 id="15-ArrayList-扩容机制？"><a href="#15-ArrayList-扩容机制？" class="headerlink" title="15. ArrayList 扩容机制？"></a>15. ArrayList 扩容机制？</h3><ul>
<li>初始容量 10，超过容量时扩容为原来的 1.5 倍。</li>
<li>通过 <code>Arrays.copyOf()</code> 实现数组复制。</li>
</ul>
<hr>
<h3 id="16-Vector-和-ArrayList-的区别？"><a href="#16-Vector-和-ArrayList-的区别？" class="headerlink" title="16. Vector 和 ArrayList 的区别？"></a>16. Vector 和 ArrayList 的区别？</h3><ul>
<li><strong>Vector</strong>：线程安全（方法加 synchronized），扩容为 2 倍。</li>
<li><strong>ArrayList</strong>：非线程安全，扩容为 1.5 倍。</li>
</ul>
<hr>
<h3 id="17-PriorityQueue-的底层实现？"><a href="#17-PriorityQueue-的底层实现？" class="headerlink" title="17. PriorityQueue 的底层实现？"></a>17. PriorityQueue 的底层实现？</h3><ul>
<li>基于 <strong>二叉小顶堆</strong>，保证队头元素是最小值。</li>
<li>插入、删除操作时间复杂度 O(log n)。</li>
</ul>
<hr>
<h3 id="18-BlockingQueue-的几种实现类？"><a href="#18-BlockingQueue-的几种实现类？" class="headerlink" title="18. BlockingQueue 的几种实现类？"></a>18. BlockingQueue 的几种实现类？</h3><ul>
<li><strong>ArrayBlockingQueue</strong>：数组结构，有界。</li>
<li><strong>LinkedBlockingQueue</strong>：链表结构，可选容量。</li>
<li><strong>PriorityBlockingQueue</strong>：优先级队列。</li>
<li><strong>DelayQueue</strong>：延时队列。</li>
<li><strong>SynchronousQueue</strong>：不存储元素，直接移交。</li>
</ul>
<hr>
<h3 id="19-HashMap-死循环问题出现在哪个版本？"><a href="#19-HashMap-死循环问题出现在哪个版本？" class="headerlink" title="19. HashMap 死循环问题出现在哪个版本？"></a>19. HashMap 死循环问题出现在哪个版本？</h3><ul>
<li><strong>JDK 1.7</strong> 多线程扩容时，链表采用头插法，可能形成环，导致死循环。</li>
<li><strong>JDK 1.8</strong> 使用尾插法，解决该问题。</li>
</ul>
<hr>
<h3 id="20-fail-fast-和-fail-safe-的区别？"><a href="#20-fail-fast-和-fail-safe-的区别？" class="headerlink" title="20. fail-fast 和 fail-safe 的区别？"></a>20. fail-fast 和 fail-safe 的区别？</h3><ul>
<li><strong>fail-fast</strong>：迭代过程中结构被修改，会抛出 <code>ConcurrentModificationException</code>。如：ArrayList、HashMap。</li>
<li><strong>fail-safe</strong>：迭代基于副本，不会抛异常。如：CopyOnWriteArrayList、ConcurrentHashMap。</li>
</ul>
<hr>
<h2 id="五、并发编程（JUC）"><a href="#五、并发编程（JUC）" class="headerlink" title="五、并发编程（JUC）"></a>五、并发编程（JUC）</h2><hr>
<h3 id="1-Java-中的线程生命周期？"><a href="#1-Java-中的线程生命周期？" class="headerlink" title="1. Java 中的线程生命周期？"></a>1. Java 中的线程生命周期？</h3><ul>
<li><strong>NEW（新建）</strong>：<code>new Thread()</code> 后，还没调用 <code>start()</code>。</li>
<li><strong>RUNNABLE（就绪&#x2F;运行中）</strong>：调用 <code>start()</code>，等待 CPU 调度。</li>
<li><strong>BLOCKED（阻塞）</strong>：等待锁。</li>
<li><strong>WAITING（无限等待）</strong>：调用 <code>wait()</code>、<code>join()</code>，需其他线程唤醒。</li>
<li><strong>TIMED_WAITING（限时等待）</strong>：调用 <code>sleep()</code>、<code>wait(timeout)</code>。</li>
<li><strong>TERMINATED（终止）</strong>：线程执行完毕或异常退出。</li>
</ul>
<hr>
<h3 id="2-Runnable-和-Callable-的区别？"><a href="#2-Runnable-和-Callable-的区别？" class="headerlink" title="2. Runnable 和 Callable 的区别？"></a>2. Runnable 和 Callable 的区别？</h3><ul>
<li><strong>Runnable</strong>：无返回值，不能抛出受检异常。</li>
<li><strong>Callable</strong>：有返回值（Future 获取），可抛出异常。</li>
</ul>
<hr>
<h3 id="3-ThreadPoolExecutor-的参数有哪些？"><a href="#3-ThreadPoolExecutor-的参数有哪些？" class="headerlink" title="3. ThreadPoolExecutor 的参数有哪些？"></a>3. ThreadPoolExecutor 的参数有哪些？</h3><ul>
<li><strong>corePoolSize</strong>：核心线程数。</li>
<li><strong>maximumPoolSize</strong>：最大线程数。</li>
<li><strong>keepAliveTime</strong>：非核心线程存活时间。</li>
<li><strong>unit</strong>：时间单位。</li>
<li><strong>workQueue</strong>：任务队列（BlockingQueue）。</li>
<li><strong>threadFactory</strong>：线程工厂（自定义线程名）。</li>
<li><strong>handler</strong>：拒绝策略。</li>
</ul>
<hr>
<h3 id="4-线程池的拒绝策略有哪些？"><a href="#4-线程池的拒绝策略有哪些？" class="headerlink" title="4. 线程池的拒绝策略有哪些？"></a>4. 线程池的拒绝策略有哪些？</h3><ul>
<li><strong>AbortPolicy</strong>（默认）：抛 <code>RejectedExecutionException</code>。</li>
<li><strong>CallerRunsPolicy</strong>：任务交给提交任务的线程执行。</li>
<li><strong>DiscardPolicy</strong>：直接丢弃任务。</li>
<li><strong>DiscardOldestPolicy</strong>：丢弃队列里最旧的任务，再尝试提交。</li>
</ul>
<hr>
<h3 id="5-创建线程的四种方式？"><a href="#5-创建线程的四种方式？" class="headerlink" title="5. 创建线程的四种方式？"></a>5. 创建线程的四种方式？</h3><ol>
<li>继承 Thread 类。</li>
<li>实现 Runnable 接口。</li>
<li>实现 Callable + FutureTask。</li>
<li>使用线程池（ExecutorService）。</li>
</ol>
<hr>
<h3 id="6-synchronized-的底层实现原理？"><a href="#6-synchronized-的底层实现原理？" class="headerlink" title="6. synchronized 的底层实现原理？"></a>6. synchronized 的底层实现原理？</h3><ul>
<li>基于 <strong>对象头 (Mark Word)</strong> 和 <strong>Monitor（管程）</strong>。</li>
<li>进入同步块时，尝试获取对象的 Monitor，获取不到则阻塞。</li>
<li>底层依赖 <strong>JVM 指令</strong>：<code>monitorenter</code>、<code>monitorexit</code>。</li>
</ul>
<hr>
<h3 id="7-synchronized-和-ReentrantLock-的区别？"><a href="#7-synchronized-和-ReentrantLock-的区别？" class="headerlink" title="7. synchronized 和 ReentrantLock 的区别？"></a>7. synchronized 和 ReentrantLock 的区别？</h3><ul>
<li><strong>锁类型</strong>：synchronized 是 JVM 级别，ReentrantLock 是 JUC 提供的 API。</li>
<li><strong>功能</strong>：ReentrantLock 支持公平锁&#x2F;非公平锁、可中断、尝试加锁、条件变量。</li>
<li><strong>可重入性</strong>：两者都可重入。</li>
<li><strong>性能</strong>：synchronized 在 JDK1.6 之后优化（偏向锁、轻量级锁）性能已提升。</li>
</ul>
<hr>
<h3 id="8-公平锁和非公平锁的区别？"><a href="#8-公平锁和非公平锁的区别？" class="headerlink" title="8. 公平锁和非公平锁的区别？"></a>8. 公平锁和非公平锁的区别？</h3><ul>
<li><strong>公平锁</strong>：按照等待顺序获取锁。</li>
<li><strong>非公平锁</strong>：允许“插队”，减少上下文切换，提高吞吐量。</li>
<li>ReentrantLock 默认非公平。</li>
</ul>
<hr>
<h3 id="9-AQS-的原理？"><a href="#9-AQS-的原理？" class="headerlink" title="9. AQS 的原理？"></a>9. AQS 的原理？</h3><ul>
<li><strong>AQS（AbstractQueuedSynchronizer）</strong> 是构建锁和同步器的框架。</li>
<li>内部维护一个 <strong>state</strong>（表示资源数量）和 <strong>FIFO 双向队列</strong>。</li>
<li>通过 CAS 修改 state，失败则将线程加入等待队列，挂起阻塞，等资源释放再唤醒。</li>
</ul>
<hr>
<h3 id="10-CountDownLatch-的应用场景？"><a href="#10-CountDownLatch-的应用场景？" class="headerlink" title="10. CountDownLatch 的应用场景？"></a>10. CountDownLatch 的应用场景？</h3><ul>
<li>倒计数器：一个线程等待多个线程完成后再执行。</li>
<li>例子：主线程等待多个子任务执行完毕。</li>
</ul>
<hr>
<h3 id="11-CyclicBarrier-的应用场景？"><a href="#11-CyclicBarrier-的应用场景？" class="headerlink" title="11. CyclicBarrier 的应用场景？"></a>11. CyclicBarrier 的应用场景？</h3><ul>
<li>栅栏：一组线程互相等待，直到所有线程到达屏障点再继续。</li>
<li>例子：多人游戏，所有玩家都准备好再开始。</li>
</ul>
<hr>
<h3 id="12-Semaphore-的应用场景？"><a href="#12-Semaphore-的应用场景？" class="headerlink" title="12. Semaphore 的应用场景？"></a>12. Semaphore 的应用场景？</h3><ul>
<li>信号量：控制并发访问的线程数量。</li>
<li>例子：停车场限制车位数、数据库连接池。</li>
</ul>
<hr>
<h3 id="13-Exchanger-的应用场景？"><a href="#13-Exchanger-的应用场景？" class="headerlink" title="13. Exchanger 的应用场景？"></a>13. Exchanger 的应用场景？</h3><ul>
<li>线程间数据交换：两个线程配对交换数据。</li>
<li>例子：生产者和消费者交换缓冲区。</li>
</ul>
<hr>
<h3 id="14-volatile-能保证原子性吗？"><a href="#14-volatile-能保证原子性吗？" class="headerlink" title="14. volatile 能保证原子性吗？"></a>14. volatile 能保证原子性吗？</h3><ul>
<li><strong>不能</strong>，只能保证可见性和禁止指令重排。</li>
<li>例子：<code>count++</code> 在多线程下仍然不安全。</li>
</ul>
<hr>
<h3 id="15-CAS-的原理？"><a href="#15-CAS-的原理？" class="headerlink" title="15. CAS 的原理？"></a>15. CAS 的原理？</h3><ul>
<li>Compare And Swap：比较内存值是否为预期值，如果是则更新，否则重试。</li>
<li>底层依赖 CPU 的 <strong>cmpxchg</strong> 指令，保证原子性。</li>
</ul>
<hr>
<h3 id="16-ABA-问题是什么？怎么解决？"><a href="#16-ABA-问题是什么？怎么解决？" class="headerlink" title="16. ABA 问题是什么？怎么解决？"></a>16. ABA 问题是什么？怎么解决？</h3><ul>
<li><strong>问题</strong>：CAS 只比较值，无法感知值被改过。例如 A→B→A。</li>
<li><strong>解决</strong>：使用 <strong>版本号&#x2F;时间戳</strong>（AtomicStampedReference、AtomicMarkableReference）。</li>
</ul>
<hr>
<h3 id="17-ThreadLocal-的作用及原理？"><a href="#17-ThreadLocal-的作用及原理？" class="headerlink" title="17. ThreadLocal 的作用及原理？"></a>17. ThreadLocal 的作用及原理？</h3><ul>
<li><strong>作用</strong>：为每个线程提供独立变量副本，避免共享数据冲突。</li>
<li><strong>原理</strong>：Thread 内部有个 ThreadLocalMap，以 ThreadLocal 为 key 存储变量。</li>
</ul>
<hr>
<h3 id="18-ThreadLocal-内存泄漏的原因？"><a href="#18-ThreadLocal-内存泄漏的原因？" class="headerlink" title="18. ThreadLocal 内存泄漏的原因？"></a>18. ThreadLocal 内存泄漏的原因？</h3><ul>
<li>ThreadLocalMap 的 key 是 <strong>弱引用</strong>，可能被回收，value 却还存在，导致泄漏。</li>
<li>解决：用完及时 <code>remove()</code>。</li>
</ul>
<hr>
<h3 id="19-JUC-中的原子类有哪些？"><a href="#19-JUC-中的原子类有哪些？" class="headerlink" title="19. JUC 中的原子类有哪些？"></a>19. JUC 中的原子类有哪些？</h3><ul>
<li><strong>基本类型原子类</strong>：AtomicInteger、AtomicLong、AtomicBoolean。</li>
<li><strong>引用类型原子类</strong>：AtomicReference、AtomicStampedReference。</li>
<li><strong>数组原子类</strong>：AtomicIntegerArray、AtomicLongArray。</li>
<li><strong>对象属性更新器</strong>：AtomicIntegerFieldUpdater 等。</li>
</ul>
<hr>
<h3 id="20-乐观锁和悲观锁的区别？"><a href="#20-乐观锁和悲观锁的区别？" class="headerlink" title="20. 乐观锁和悲观锁的区别？"></a>20. 乐观锁和悲观锁的区别？</h3><ul>
<li><strong>悲观锁</strong>：假设会发生冲突，先加锁再操作（synchronized、ReentrantLock）。</li>
<li><strong>乐观锁</strong>：假设不会冲突，先操作再检查（CAS）。</li>
</ul>
<hr>
<h2 id="六、JVM-内存模型"><a href="#六、JVM-内存模型" class="headerlink" title="六、JVM &amp; 内存模型"></a>六、JVM &amp; 内存模型</h2><hr>
<h3 id="1-JVM-内存结构？"><a href="#1-JVM-内存结构？" class="headerlink" title="1. JVM 内存结构？"></a>1. JVM 内存结构？</h3><p>JVM 运行时主要分为：</p>
<ul>
<li><strong>堆（Heap）</strong>：存放对象实例，垃圾回收的主要区域。</li>
<li><strong>虚拟机栈（Stack）</strong>：存放方法调用的局部变量、操作数栈、动态链接、返回地址。</li>
<li><strong>本地方法栈（Native Method Stack）</strong>：为 native 方法服务。</li>
<li><strong>程序计数器（PC Register）</strong>：记录线程当前执行的字节码位置。</li>
<li><strong>方法区（Method Area &#x2F; Metaspace）</strong>：存放类元数据、常量池、静态变量、JIT 编译后的代码。</li>
</ul>
<hr>
<h3 id="2-堆和栈的区别？"><a href="#2-堆和栈的区别？" class="headerlink" title="2. 堆和栈的区别？"></a>2. 堆和栈的区别？</h3><ul>
<li><strong>堆</strong>：存放对象实例，线程共享，需垃圾回收。</li>
<li><strong>栈</strong>：存放方法帧、局部变量，线程私有，生命周期随线程结束。</li>
</ul>
<hr>
<h3 id="3-堆内存的分代模型？"><a href="#3-堆内存的分代模型？" class="headerlink" title="3. 堆内存的分代模型？"></a>3. 堆内存的分代模型？</h3><ul>
<li><strong>新生代（Young Generation）</strong>：Eden + Survivor（S0&#x2F;S1）。</li>
<li><strong>老年代（Old Generation）</strong>：存放长生命周期对象。</li>
<li><strong>永久代&#x2F;元空间</strong>：存放类元信息、常量池。</li>
</ul>
<hr>
<h3 id="4-新生代、老年代、永久代的区别？"><a href="#4-新生代、老年代、永久代的区别？" class="headerlink" title="4. 新生代、老年代、永久代的区别？"></a>4. 新生代、老年代、永久代的区别？</h3><ul>
<li><strong>新生代</strong>：对象新建时分配，大部分对象“朝生夕死”。</li>
<li><strong>老年代</strong>：存活时间长或大对象直接进入。</li>
<li><strong>永久代（JDK 7 及之前）</strong>：存放类信息、静态变量。</li>
<li><strong>元空间（JDK 8 之后）</strong>：替代永久代，使用本地内存，避免 OOM: PermGen。</li>
</ul>
<hr>
<h3 id="5-元空间和永久代的区别？"><a href="#5-元空间和永久代的区别？" class="headerlink" title="5. 元空间和永久代的区别？"></a>5. 元空间和永久代的区别？</h3><ul>
<li>永久代（PermGen）：使用 JVM 内存，容易 OOM。</li>
<li>元空间（Metaspace）：使用本地内存，理论上更大，更灵活。</li>
</ul>
<hr>
<h3 id="6-对象在堆中的分配过程？"><a href="#6-对象在堆中的分配过程？" class="headerlink" title="6. 对象在堆中的分配过程？"></a>6. 对象在堆中的分配过程？</h3><ol>
<li>在 Eden 区分配。</li>
<li>Minor GC 时，幸存的对象进入 Survivor 区。</li>
<li>多次 Minor GC 仍存活 → 晋升老年代。</li>
<li>大对象（如大数组）可能直接进入老年代。</li>
</ol>
<hr>
<h3 id="7-对象什么时候进入老年代？"><a href="#7-对象什么时候进入老年代？" class="headerlink" title="7. 对象什么时候进入老年代？"></a>7. 对象什么时候进入老年代？</h3><ul>
<li>在 Survivor 区经过多次 Minor GC，达到晋升阈值（默认 15 次）。</li>
<li>大对象超过阈值，直接进入老年代。</li>
<li>Survivor 区放不下，直接进入老年代。</li>
</ul>
<hr>
<h3 id="8-JVM-的垃圾回收算法？"><a href="#8-JVM-的垃圾回收算法？" class="headerlink" title="8. JVM 的垃圾回收算法？"></a>8. JVM 的垃圾回收算法？</h3><ul>
<li><strong>标记-清除</strong>：标记存活对象，清除未标记。缺点：碎片多。</li>
<li><strong>标记-整理</strong>：标记存活对象并移动，整理内存，避免碎片。</li>
<li><strong>复制算法</strong>：将活对象复制到新区域，清空旧区域，适合新生代。</li>
</ul>
<hr>
<h3 id="9-垃圾收集器有哪些？"><a href="#9-垃圾收集器有哪些？" class="headerlink" title="9. 垃圾收集器有哪些？"></a>9. 垃圾收集器有哪些？</h3><ul>
<li><strong>Serial</strong>（单线程，适合小内存）。</li>
<li><strong>ParNew</strong>（多线程版 Serial）。</li>
<li><strong>Parallel Scavenge（吞吐量优先）</strong>。</li>
<li><strong>CMS（低延迟，响应快）</strong>。</li>
<li><strong>G1（区域化，均衡停顿时间）</strong>。</li>
<li><strong>ZGC、Shenandoah（超低延迟，适合大内存场景）</strong>。</li>
</ul>
<hr>
<h3 id="10-CMS-和-G1-的区别？"><a href="#10-CMS-和-G1-的区别？" class="headerlink" title="10. CMS 和 G1 的区别？"></a>10. CMS 和 G1 的区别？</h3><ul>
<li><strong>CMS</strong>：并发收集，低延迟，但可能产生内存碎片。</li>
<li><strong>G1</strong>：基于分区（Region），可预测停顿时间，整理内存，适合大堆内存。</li>
</ul>
<hr>
<h3 id="11-Minor-GC-和-Full-GC-的区别？"><a href="#11-Minor-GC-和-Full-GC-的区别？" class="headerlink" title="11. Minor GC 和 Full GC 的区别？"></a>11. Minor GC 和 Full GC 的区别？</h3><ul>
<li><strong>Minor GC</strong>：回收新生代，速度快，频繁。</li>
<li><strong>Full GC</strong>：回收整个堆（新生代 + 老年代 + 元空间），耗时长，频率低。</li>
</ul>
<hr>
<h3 id="12-什么是-Stop-The-World？"><a href="#12-什么是-Stop-The-World？" class="headerlink" title="12. 什么是 Stop The World？"></a>12. 什么是 Stop The World？</h3><ul>
<li>GC 期间，所有工作线程必须停下来等待，造成应用暂停（STW）。</li>
<li>STW 是不可避免的，只能尽量减少时长。</li>
</ul>
<hr>
<h3 id="13-JVM-常见的调优参数？"><a href="#13-JVM-常见的调优参数？" class="headerlink" title="13. JVM 常见的调优参数？"></a>13. JVM 常见的调优参数？</h3><ul>
<li><code>-Xms</code> 初始堆大小。</li>
<li><code>-Xmx</code> 最大堆大小。</li>
<li><code>-Xmn</code> 新生代大小。</li>
<li><code>-XX:SurvivorRatio</code> Eden:Survivor 比例。</li>
<li><code>-XX:+PrintGCDetails</code> 打印 GC 日志。</li>
<li><code>-XX:+UseG1GC</code> 指定垃圾收集器。</li>
<li><code>-XX:MaxMetaspaceSize</code> 元空间大小。</li>
</ul>
<hr>
<h3 id="14-类加载的双亲委派机制？"><a href="#14-类加载的双亲委派机制？" class="headerlink" title="14. 类加载的双亲委派机制？"></a>14. 类加载的双亲委派机制？</h3><ul>
<li><strong>过程</strong>：加载请求先交给父加载器，如果父加载器无法加载，再由子加载器加载。</li>
</ul>
<hr>
<h3 id="15-双亲委派的好处？"><a href="#15-双亲委派的好处？" class="headerlink" title="15. 双亲委派的好处？"></a>15. 双亲委派的好处？</h3><ul>
<li>避免类重复加载。</li>
<li>保证核心类（如 java.lang.String）不会被篡改。</li>
</ul>
<hr>
<h3 id="16-类加载器的种类？"><a href="#16-类加载器的种类？" class="headerlink" title="16. 类加载器的种类？"></a>16. 类加载器的种类？</h3><ul>
<li><strong>Bootstrap ClassLoader</strong>：加载核心类库。</li>
<li><strong>Extension ClassLoader</strong>：加载扩展类。</li>
<li><strong>Application ClassLoader</strong>：加载用户应用类。</li>
<li><strong>自定义 ClassLoader</strong>：用户自己扩展。</li>
</ul>
<hr>
<h3 id="17-OOM-的常见类型？"><a href="#17-OOM-的常见类型？" class="headerlink" title="17. OOM 的常见类型？"></a>17. OOM 的常见类型？</h3><ul>
<li><strong>Java heap space</strong>：堆溢出。</li>
<li><strong>GC overhead limit exceeded</strong>：GC 回收无效。</li>
<li><strong>Metaspace</strong>：元空间溢出。</li>
<li><strong>Direct buffer memory</strong>：直接内存溢出。</li>
<li><strong>Unable to create new native thread</strong>：线程数过多。</li>
</ul>
<hr>
<h3 id="18-内存泄漏和内存溢出的区别？"><a href="#18-内存泄漏和内存溢出的区别？" class="headerlink" title="18. 内存泄漏和内存溢出的区别？"></a>18. 内存泄漏和内存溢出的区别？</h3><ul>
<li><strong>内存泄漏</strong>：不再使用的对象仍然被引用，不能被 GC 回收。</li>
<li><strong>内存溢出</strong>：内存不足，申请不到更多空间。</li>
</ul>
<hr>
<h3 id="19-finalize-方法的作用？"><a href="#19-finalize-方法的作用？" class="headerlink" title="19. finalize() 方法的作用？"></a>19. finalize() 方法的作用？</h3><ul>
<li>对象被 GC 前执行一次清理逻辑。</li>
<li>缺点：执行不确定、性能差，JDK9 开始废弃，推荐使用 <strong>try-with-resources&#x2F;AutoCloseable</strong>。</li>
</ul>
<hr>
<h3 id="20-Java-内存模型（JMM）的核心内容？"><a href="#20-Java-内存模型（JMM）的核心内容？" class="headerlink" title="20. Java 内存模型（JMM）的核心内容？"></a>20. Java 内存模型（JMM）的核心内容？</h3><ul>
<li>定义了多线程如何共享内存。</li>
<li>关键点：<ul>
<li><strong>主内存</strong>：存放共享变量。</li>
<li><strong>工作内存</strong>：每个线程的本地副本。</li>
<li><strong>happens-before 规则</strong>：保证可见性、有序性。</li>
<li><strong>volatile、synchronized、final</strong> 提供内存语义。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="七、泛型、注解、反射"><a href="#七、泛型、注解、反射" class="headerlink" title="七、泛型、注解、反射"></a>七、泛型、注解、反射</h2><hr>
<h3 id="1-什么是泛型？"><a href="#1-什么是泛型？" class="headerlink" title="1. 什么是泛型？"></a>1. 什么是泛型？</h3><ul>
<li><p><strong>定义</strong>：泛型（Generic）是 <strong>参数化类型</strong>，让类、接口、方法可以操作不同类型的数据，而不用编写重复代码。</p>
</li>
<li><p><strong>好处</strong>：</p>
<ol>
<li><strong>类型安全</strong>（编译期检查，避免 <code>ClassCastException</code>）。</li>
<li><strong>代码复用</strong>（相同逻辑可适配多种类型）。</li>
<li><strong>可读性高</strong>（类型明确）。</li>
</ol>
</li>
<li><p><strong>例子</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 编译期检查类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-泛型的类型擦除机制？"><a href="#2-泛型的类型擦除机制？" class="headerlink" title="2. 泛型的类型擦除机制？"></a>2. 泛型的类型擦除机制？</h3><ul>
<li><p><strong>原理</strong>：Java 的泛型是 <strong>伪泛型</strong>，只在 <strong>编译期有效</strong>，编译后泛型信息被擦除（Type Erasure）。</p>
</li>
<li><p><strong>结果</strong>：</p>
<ul>
<li><code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在运行时是同一个类型：<code>List</code>。</li>
<li>泛型方法的类型参数会被擦除为 <strong>上界（extends）或 Object</strong>。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; l2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">System.out.println(l1.getClass() == l2.getClass()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-泛型通配符-extends-和-super-的区别？"><a href="#3-泛型通配符-extends-和-super-的区别？" class="headerlink" title="3. 泛型通配符 ? extends 和 ? super 的区别？"></a>3. 泛型通配符 ? extends 和 ? super 的区别？</h3><ul>
<li><code>? extends T</code>：表示类型的 <strong>上界</strong>，接受 <code>T</code> 及其子类。<ul>
<li>适合 <strong>生产者（Producer）</strong>，只读，不可写。</li>
</ul>
</li>
<li><code>? super T</code>：表示类型的 <strong>下界</strong>，接受 <code>T</code> 及其父类。<ul>
<li>适合 <strong>消费者（Consumer）</strong>，可以写入 T 及其子类对象。</li>
</ul>
</li>
<li><strong>口诀</strong>：PECS（Producer Extends, Consumer Super）。</li>
</ul>
<hr>
<h3 id="4-注解的作用是什么？"><a href="#4-注解的作用是什么？" class="headerlink" title="4. 注解的作用是什么？"></a>4. 注解的作用是什么？</h3><ul>
<li><strong>作用</strong>：注解（Annotation）是 <strong>元数据</strong>，为代码提供说明信息。</li>
<li><strong>分类</strong>：<ul>
<li>编译期使用（如 <code>@Override</code>, <code>@SuppressWarnings</code>）。</li>
<li>运行时使用（结合反射，驱动框架逻辑，如 <code>@Autowired</code>）。</li>
</ul>
</li>
<li><strong>应用场景</strong>：框架开发（Spring、Hibernate）、编译器检查、文档生成等。</li>
</ul>
<hr>
<h3 id="5-元注解有哪些？"><a href="#5-元注解有哪些？" class="headerlink" title="5. 元注解有哪些？"></a>5. 元注解有哪些？</h3><p>Java 提供了四个元注解（注解的注解）：</p>
<ol>
<li><code>@Target</code> —— 指定注解可用的位置（类、方法、字段、参数等）。</li>
<li><code>@Retention</code> —— 指定注解的生命周期（源码&#x2F;编译期&#x2F;运行时）。</li>
<li><code>@Documented</code> —— 是否包含在 javadoc 中。</li>
<li><code>@Inherited</code> —— 子类是否能继承父类的注解。</li>
</ol>
<hr>
<h3 id="6-自定义注解如何实现？"><a href="#6-自定义注解如何实现？" class="headerlink" title="6. 自定义注解如何实现？"></a>6. 自定义注解如何实现？</h3><ul>
<li><p><strong>定义</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解析</strong>（反射）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">ann</span> <span class="operator">=</span> m.getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(ann.value());</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="7-反射的作用？"><a href="#7-反射的作用？" class="headerlink" title="7. 反射的作用？"></a>7. 反射的作用？</h3><ul>
<li><strong>定义</strong>：反射（Reflection）允许程序在 <strong>运行时</strong> 获取类的信息，并操作其属性、方法、构造器。</li>
<li><strong>作用</strong>：<ul>
<li>框架（如 Spring、MyBatis）自动注入和配置。</li>
<li>动态代理。</li>
<li>动态加载类。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8-反射的性能问题？"><a href="#8-反射的性能问题？" class="headerlink" title="8. 反射的性能问题？"></a>8. 反射的性能问题？</h3><ul>
<li><strong>原因</strong>：<ul>
<li>反射调用方法比直接调用多了安全检查、方法查找，性能差 10~20 倍。</li>
</ul>
</li>
<li><strong>优化</strong>：<ul>
<li>使用 <code>setAccessible(true)</code> 关闭安全检查。</li>
<li>使用 <code>MethodHandle</code>（JDK7+）。</li>
<li>使用 <code>LambdaMetafactory</code>（JDK8+）做动态代理。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="9-反射能否访问私有字段？"><a href="#9-反射能否访问私有字段？" class="headerlink" title="9. 反射能否访问私有字段？"></a>9. 反射能否访问私有字段？</h3><ul>
<li><p><strong>能</strong>，需要 <code>setAccessible(true)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(obj, <span class="string">&quot;newValue&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意</strong>：JDK 9 模块化后，跨模块访问可能会有 <code>InaccessibleObjectException</code>。</p>
</li>
</ul>
<hr>
<h3 id="10-动态代理的两种实现方式？"><a href="#10-动态代理的两种实现方式？" class="headerlink" title="10. 动态代理的两种实现方式？"></a>10. 动态代理的两种实现方式？</h3><ol>
<li><strong>JDK 动态代理</strong>：基于 <code>InvocationHandler + Proxy</code>，只能代理 <strong>接口</strong>。</li>
<li><strong>CGLIB 动态代理</strong>：基于 ASM 字节码生成，继承目标类，能代理 <strong>类</strong>。</li>
</ol>
<hr>
<h3 id="11-JDK-动态代理和-CGLIB-的区别？"><a href="#11-JDK-动态代理和-CGLIB-的区别？" class="headerlink" title="11. JDK 动态代理和 CGLIB 的区别？"></a>11. JDK 动态代理和 CGLIB 的区别？</h3><ul>
<li><strong>JDK 动态代理</strong>：<ul>
<li>代理接口。</li>
<li>JDK 自带，无需依赖。</li>
<li>性能略低。</li>
</ul>
</li>
<li><strong>CGLIB</strong>：<ul>
<li>代理类（生成子类）。</li>
<li>不能代理 <code>final</code> 类&#x2F;方法。</li>
<li>性能更高（字节码生成）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="12-反射如何创建对象？"><a href="#12-反射如何创建对象？" class="headerlink" title="12. 反射如何创建对象？"></a>12. 反射如何创建对象？</h3><ol>
<li><p><strong>使用 Class 的 <code>newInstance()</code></strong>（已废弃）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 Constructor</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt; ctor = clazz.getConstructor(String.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ctor.newInstance(<span class="string">&quot;param&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="13-Class-forName-和-ClassLoader-loadClass-的区别？"><a href="#13-Class-forName-和-ClassLoader-loadClass-的区别？" class="headerlink" title="13. Class.forName 和 ClassLoader.loadClass 的区别？"></a>13. Class.forName 和 ClassLoader.loadClass 的区别？</h3><ul>
<li><strong>Class.forName</strong>：加载并 <strong>初始化</strong> 类（会执行静态代码块）。</li>
<li><strong>ClassLoader.loadClass</strong>：仅加载，不初始化（延迟执行 <code>&lt;clinit&gt;</code>）。</li>
</ul>
<hr>
<h3 id="14-注解和反射结合能实现哪些功能？"><a href="#14-注解和反射结合能实现哪些功能？" class="headerlink" title="14. 注解和反射结合能实现哪些功能？"></a>14. 注解和反射结合能实现哪些功能？</h3><ul>
<li>IOC &#x2F; DI（依赖注入，Spring 的 <code>@Autowired</code>）。</li>
<li>ORM 框架（MyBatis 的 <code>@Mapper</code>，JPA 的 <code>@Entity</code>）。</li>
<li>AOP（<code>@Aspect</code>）。</li>
<li>配置驱动开发（<code>@Configuration</code>, <code>@Value</code>）。</li>
</ul>
<hr>
<h3 id="15-注解处理器（APT）的作用？"><a href="#15-注解处理器（APT）的作用？" class="headerlink" title="15. 注解处理器（APT）的作用？"></a>15. 注解处理器（APT）的作用？</h3><ul>
<li><strong>APT（Annotation Processing Tool）</strong>：编译期扫描注解并生成代码。</li>
<li><strong>典型应用</strong>：<ul>
<li>Dagger2（依赖注入）。</li>
<li>ButterKnife（视图注入）。</li>
<li>Lombok（自动生成 getter&#x2F;setter&#x2F;toString 等）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="八、Java-8-新特性"><a href="#八、Java-8-新特性" class="headerlink" title="八、Java 8+ 新特性"></a>八、Java 8+ 新特性</h2><ol>
<li>Lambda 表达式的作用？</li>
<li>函数式接口有哪些？</li>
<li>Stream 流的常见操作？</li>
<li>Optional 的作用？</li>
<li>CompletableFuture 的作用？</li>
<li>Java 8 接口的默认方法和静态方法？</li>
<li>forEach 和传统 for 的区别？</li>
<li>parallelStream 的原理？</li>
<li>Java 9 模块化系统（Jigsaw）是什么？</li>
<li>Java 14 的 switch 表达式增强？</li>
<li>Java 16 的 record 特性？</li>
<li>Java 17 的 sealed class 特性？</li>
<li>var 关键字是什么？</li>
<li>ZGC 的特性？</li>
<li>Project Loom 的虚拟线程是什么？</li>
</ol>
<h2 id="九、IO"><a href="#九、IO" class="headerlink" title="九、IO"></a>九、IO</h2><hr>
<h2 id="一、Java-IO-基础与流（1–20）"><a href="#一、Java-IO-基础与流（1–20）" class="headerlink" title="一、Java IO 基础与流（1–20）"></a>一、Java IO 基础与流（1–20）</h2><hr>
<h3 id="1-Java-IO-的总体体系结构是什么？"><a href="#1-Java-IO-的总体体系结构是什么？" class="headerlink" title="1. Java IO 的总体体系结构是什么？"></a>1. Java IO 的总体体系结构是什么？</h3><ul>
<li><strong>IO 的两大基类</strong>：<ul>
<li>字节流：<code>InputStream</code>、<code>OutputStream</code>（处理二进制数据）。</li>
<li>字符流：<code>Reader</code>、<code>Writer</code>（处理文本字符）。</li>
</ul>
</li>
<li><strong>按功能划分</strong>：<ul>
<li>节点流（直接对接数据源，如 <code>FileInputStream</code>、<code>FileReader</code>）。</li>
<li>处理流（包装其他流，如 <code>BufferedReader</code>、<code>DataInputStream</code>）。</li>
</ul>
</li>
<li><strong>核心设计模式</strong>：装饰器模式（Decorator Pattern），通过层层包装增强功能。</li>
</ul>
<hr>
<h3 id="2-InputStream-OutputStream-的常见子类有哪些？"><a href="#2-InputStream-OutputStream-的常见子类有哪些？" class="headerlink" title="2. InputStream &#x2F; OutputStream 的常见子类有哪些？"></a>2. InputStream &#x2F; OutputStream 的常见子类有哪些？</h3><ul>
<li><strong>InputStream</strong>：<code>FileInputStream</code>、<code>BufferedInputStream</code>、<code>DataInputStream</code>、<code>ObjectInputStream</code>、<code>ByteArrayInputStream</code>。</li>
<li><strong>OutputStream</strong>：<code>FileOutputStream</code>、<code>BufferedOutputStream</code>、<code>DataOutputStream</code>、<code>ObjectOutputStream</code>、<code>ByteArrayOutputStream</code>。</li>
</ul>
<hr>
<h3 id="3-Reader-Writer-的常见子类有哪些？"><a href="#3-Reader-Writer-的常见子类有哪些？" class="headerlink" title="3. Reader &#x2F; Writer 的常见子类有哪些？"></a>3. Reader &#x2F; Writer 的常见子类有哪些？</h3><ul>
<li><strong>Reader</strong>：<code>FileReader</code>、<code>BufferedReader</code>、<code>InputStreamReader</code>、<code>CharArrayReader</code>、<code>StringReader</code>。</li>
<li><strong>Writer</strong>：<code>FileWriter</code>、<code>BufferedWriter</code>、<code>OutputStreamWriter</code>、<code>CharArrayWriter</code>、<code>StringWriter</code>。</li>
</ul>
<hr>
<h3 id="4-字节流与字符流的本质区别和使用场景？"><a href="#4-字节流与字符流的本质区别和使用场景？" class="headerlink" title="4. 字节流与字符流的本质区别和使用场景？"></a>4. 字节流与字符流的本质区别和使用场景？</h3><ul>
<li><strong>字节流</strong>（8bit）：面向二进制数据，如图片、音视频、压缩文件。</li>
<li><strong>字符流</strong>（16bit，基于 Unicode）：面向文本，自动处理字符编码。</li>
<li><strong>联系</strong>：字符流常常通过 <code>InputStreamReader/OutputStreamWriter</code> 包装字节流并指定编码。</li>
</ul>
<hr>
<h3 id="5-为什么要有缓冲流？"><a href="#5-为什么要有缓冲流？" class="headerlink" title="5. 为什么要有缓冲流？"></a>5. 为什么要有缓冲流？</h3><ul>
<li><strong>原因</strong>：文件 IO 属于系统调用，每次读写代价高。</li>
<li><strong>作用</strong>：减少磁盘交互次数，提高性能。</li>
<li><strong>例子</strong>：<code>BufferedReader.readLine()</code> 能按行读取，效率远高于 <code>FileReader.read()</code>。</li>
</ul>
<hr>
<h3 id="6-flush-与-close-的区别？"><a href="#6-flush-与-close-的区别？" class="headerlink" title="6. flush() 与 close() 的区别？"></a>6. flush() 与 close() 的区别？</h3><ul>
<li><strong>flush()</strong>：将内存缓冲区数据立刻写入目标（但不关闭流）。</li>
<li><strong>close()</strong>：先执行 <code>flush()</code>，然后释放底层资源。</li>
<li><strong>注意点</strong>：<ul>
<li>若忘记 <code>flush()</code>，可能导致部分数据未写入文件。</li>
<li><code>close()</code> 后再调用 <code>write()</code> 会抛异常。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-try-with-resources-的工作原理？"><a href="#7-try-with-resources-的工作原理？" class="headerlink" title="7. try-with-resources 的工作原理？"></a>7. try-with-resources 的工作原理？</h3><ul>
<li><strong>语法糖</strong>：<code>try (Resource r = ...) &#123;&#125;</code>，要求资源实现 <code>AutoCloseable</code>。</li>
<li><strong>原理</strong>：编译器自动生成 <code>finally &#123; r.close() &#125;</code>。</li>
<li><strong>suppressed exceptions</strong>：如果 <code>try</code> 和 <code>close()</code> 都抛异常，关闭时的异常会被标记为 <strong>suppressed</strong>，可通过 <code>Throwable.getSuppressed()</code> 获取。</li>
</ul>
<hr>
<h3 id="8-装饰器模式在-Java-IO-中如何体现？"><a href="#8-装饰器模式在-Java-IO-中如何体现？" class="headerlink" title="8. 装饰器模式在 Java IO 中如何体现？"></a>8. 装饰器模式在 Java IO 中如何体现？</h3><ul>
<li><p><strong>例子</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>), StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>本质</strong>：每层流只关心自己的功能（缓冲、解码、行读取），通过链式组合增强能力。</p>
</li>
</ul>
<hr>
<h3 id="9-File-类的能力与限制？"><a href="#9-File-类的能力与限制？" class="headerlink" title="9. File 类的能力与限制？"></a>9. File 类的能力与限制？</h3><ul>
<li><strong>能做的</strong>：文件&#x2F;目录的元数据操作（路径、存在性、权限、大小、修改时间等）。</li>
<li><strong>不能做的</strong>：不支持读写文件内容，需结合 <code>InputStream/OutputStream</code>。</li>
</ul>
<hr>
<h3 id="10-RandomAccessFile-的用途？"><a href="#10-RandomAccessFile-的用途？" class="headerlink" title="10. RandomAccessFile 的用途？"></a>10. RandomAccessFile 的用途？</h3><ul>
<li><strong>功能</strong>：支持随机读写，内部有一个文件指针，可 <code>seek()</code> 到任意位置读写。</li>
<li><strong>典型场景</strong>：日志文件、数据库存储文件。</li>
<li><strong>并发问题</strong>：不是线程安全的，多线程写需加锁。</li>
</ul>
<hr>
<h3 id="11-FileInputStream-与-FileReader-的区别？"><a href="#11-FileInputStream-与-FileReader-的区别？" class="headerlink" title="11. FileInputStream 与 FileReader 的区别？"></a>11. FileInputStream 与 FileReader 的区别？</h3><ul>
<li><strong>FileInputStream</strong>：字节流，直接读二进制。</li>
<li><strong>FileReader</strong>：字符流，内部用 <code>InputStreamReader</code> 并默认使用平台编码。</li>
<li><strong>使用建议</strong>：<ul>
<li>非文本 → <code>FileInputStream</code>。</li>
<li>文本（需编码处理） → <code>FileReader</code>（但最好用 <code>InputStreamReader</code> 显式指定编码）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="12-常见文件拷贝方式性能对比"><a href="#12-常见文件拷贝方式性能对比" class="headerlink" title="12. 常见文件拷贝方式性能对比"></a>12. 常见文件拷贝方式性能对比</h3><ol>
<li><strong>裸 read&#x2F;write</strong>：逐字节拷贝，最慢。</li>
<li><strong>带缓冲</strong>：<code>BufferedInputStream/BufferedOutputStream</code>，性能提升 5~10 倍。</li>
<li><strong>NIO <code>FileChannel.transferTo()</code></strong>：利用零拷贝，性能最高。</li>
</ol>
<hr>
<h3 id="13-如何安全处理字符编码？"><a href="#13-如何安全处理字符编码？" class="headerlink" title="13. 如何安全处理字符编码？"></a>13. 如何安全处理字符编码？</h3><ul>
<li><p><strong>方式</strong>：使用 <code>InputStreamReader</code>&#x2F;<code>OutputStreamWriter</code> 并显式指定编码。</p>
</li>
<li><p><strong>例子</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="14-字符编码常见坑？"><a href="#14-字符编码常见坑？" class="headerlink" title="14. 字符编码常见坑？"></a>14. 字符编码常见坑？</h3><ul>
<li>UTF-8 vs GBK 混用：解码错误，出现乱码。</li>
<li>BOM（Byte Order Mark）：部分 UTF-8 文件前 3 字节 BOM 可能导致解析失败。</li>
<li>截断：写入时按字节截断 UTF-8 多字节字符 → 乱码。</li>
<li><strong>解决</strong>：统一编码（UTF-8），避免隐式编码。</li>
</ul>
<hr>
<h3 id="15-文件追加（append）方式？"><a href="#15-文件追加（append）方式？" class="headerlink" title="15. 文件追加（append）方式？"></a>15. 文件追加（append）方式？</h3><ul>
<li><p><strong>实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原子性问题</strong>：多线程写入需加锁，否则可能交叉覆盖。</p>
</li>
</ul>
<hr>
<h3 id="16-如何判断并处理文件状态？"><a href="#16-如何判断并处理文件状态？" class="headerlink" title="16. 如何判断并处理文件状态？"></a>16. 如何判断并处理文件状态？</h3><ul>
<li><strong>存在性</strong>：<code>file.exists()</code>。</li>
<li><strong>权限</strong>：<code>file.canRead()</code>, <code>file.canWrite()</code>。</li>
<li><strong>占用</strong>：只能通过打开尝试，若被占用会抛异常。</li>
</ul>
<hr>
<h3 id="17-File-mkdirs-与-mkdir-区别？"><a href="#17-File-mkdirs-与-mkdir-区别？" class="headerlink" title="17. File.mkdirs() 与 mkdir() 区别？"></a>17. File.mkdirs() 与 mkdir() 区别？</h3><ul>
<li><strong>mkdir()</strong>：只创建当前目录，父目录不存在则失败。</li>
<li><strong>mkdirs()</strong>：会递归创建所有不存在的父目录。</li>
<li><strong>返回值</strong>：成功返回 <code>true</code>，否则 <code>false</code>。</li>
</ul>
<hr>
<h3 id="18-临时文件（createTempFile）的用途？"><a href="#18-临时文件（createTempFile）的用途？" class="headerlink" title="18. 临时文件（createTempFile）的用途？"></a>18. 临时文件（createTempFile）的用途？</h3><ul>
<li><strong>方法</strong>：<code>File.createTempFile(&quot;prefix&quot;, &quot;.tmp&quot;)</code>。</li>
<li><strong>特点</strong>：自动生成唯一文件名。</li>
<li><strong>删除策略</strong>：<code>file.deleteOnExit()</code> JVM 退出时删除，但依赖于正常退出。</li>
</ul>
<hr>
<h3 id="19-文件的读写锁与并发访问？"><a href="#19-文件的读写锁与并发访问？" class="headerlink" title="19. 文件的读写锁与并发访问？"></a>19. 文件的读写锁与并发访问？</h3><ul>
<li><strong>Java NIO</strong>：<code>FileChannel.lock()</code> 提供文件锁（独占锁、共享锁）。</li>
<li><strong>注意</strong>：文件锁是 OS 级别，跨进程生效；性能开销较大，不适合频繁操作。</li>
</ul>
<hr>
<h3 id="20-流关闭异常处理最佳实践"><a href="#20-流关闭异常处理最佳实践" class="headerlink" title="20. 流关闭异常处理最佳实践"></a>20. 流关闭异常处理最佳实践</h3><ul>
<li><strong>传统写法</strong>：try-finally 手动关闭流。</li>
<li><strong>推荐</strong>：try-with-resources，避免遗漏关闭。</li>
<li><strong>关闭异常</strong>：只 log，不影响主要业务异常处理。</li>
</ul>
<hr>
<h2 id="二、Java-IO-设计与模式（21–40）"><a href="#二、Java-IO-设计与模式（21–40）" class="headerlink" title="二、Java IO 设计与模式（21–40）"></a>二、Java IO 设计与模式（21–40）</h2><ol>
<li>InputStream&#x2F;OutputStream 的装饰器链常见组合（Buffered -&gt; GZIP -&gt; Cipher 等）。</li>
<li>PushbackInputStream、SequenceInputStream 的作用与应用场景。</li>
<li>PipedInputStream &#x2F; PipedOutputStream（管道流）的使用与线程注意点。</li>
<li>FilterInputStream&#x2F;FilterOutputStream 的设计与扩展。</li>
<li>IO 与异常处理：IOException 的常见子类与处理策略。</li>
<li>流复制的常见实现模板（模板方法式代码）。</li>
<li>NIO 引入前的 IO 局限性（可扩展性、线程模型）。</li>
<li>如何实现一个带超时的读操作（Socket&#x2F;Channel）？</li>
<li>流式处理与内存友好型处理（流式处理大文件）实践。</li>
<li>Base64 编解码在流中的高效集成方法。</li>
<li>加密&#x2F;解密流（CipherInputStream&#x2F;CipherOutputStream）如何正确关闭？</li>
<li>GZIPInputStream&#x2F;GZIPOutputStream 的压缩流使用注意事项。</li>
<li>ObjectInputStream&#x2F;ObjectOutputStream 的工作机制（类元数据、句柄表）。</li>
<li>如何实现跨语言的序列化兼容（JSON&#x2F;Protobuf&#x2F;Avro）？</li>
<li>实现自定义 InputStream 子类时需要注意什么（read 方法语义）？</li>
<li>设计用于日志写入的高吞吐 IO 模式（异步批量写）。</li>
<li>流复制时如何统计速率与进度（带进度回调）？</li>
<li>如何安全处理二进制文件（流边界、magic header）？</li>
<li>大对象&#x2F;大数组写入流时的内存优化策略（分块、流化）。</li>
<li>如何实现可重入&#x2F;可恢复的断点续传文件写入？</li>
</ol>
<hr>
<h2 id="三、文件系统、锁与操作（41–60）"><a href="#三、文件系统、锁与操作（41–60）" class="headerlink" title="三、文件系统、锁与操作（41–60）"></a>三、文件系统、锁与操作（41–60）</h2><ol>
<li>Java 中文件锁 FileLock 的类型（共享&#x2F;独占）及实现原理。</li>
<li>FileLock 的局限性（跨 JVM、跨 OS 行为差异）。</li>
<li>文件描述符泄露的常见原因与定位方法。</li>
<li>文件句柄上限（ulimit）对 Java 服务的影响与排查。</li>
<li>硬链接与软链接在 Java 中如何区分与操作？</li>
<li>MappedByteBuffer（内存映射文件）的优劣与风险（内存回收、文件锁）。</li>
<li>大文件分片读取与并发合并策略。</li>
<li>如何高效统计大日志文件中某条件的行数（分块 + 并行）？</li>
<li>文件系统缓存（PageCache）对读写性能的影响机制。</li>
<li>fsync &#x2F; FileDescriptor.sync 在持久化保障上的作用。</li>
<li>文件顺序写与随机写的性能差异与优化建议。</li>
<li>磁盘类型（SSD vs HDD）对 IO 策略的影响。</li>
<li>原子重命名（renameTo&#x2F;Files.move）的跨平台差异。</li>
<li>文件监控（WatchService）的实现限制与替代方案。</li>
<li>处理日志切割（rotation）时的文件句柄管理策略。</li>
<li>如何实现零停机部署中对文件的平滑迁移？</li>
<li>软删除（标记删除）与物理删除的 IO 考量。</li>
<li>备份&#x2F;快照策略对 IO 的影响（冷备 vs 热备）。</li>
<li>大文件校验（MD5&#x2F;SHA）在流式处理中的实现。</li>
<li>文件系统一致性问题（写入后立即读取到不同步）如何诊断。</li>
</ol>
<hr>
<h2 id="四、序列化与反序列化（61–75）"><a href="#四、序列化与反序列化（61–75）" class="headerlink" title="四、序列化与反序列化（61–75）"></a>四、序列化与反序列化（61–75）</h2><ol>
<li>Java 原生序列化（Serializable）的机制和对象写入格式。</li>
<li>serialVersionUID 的作用、自动生成与兼容性策略。</li>
<li>transient 字段、static 字段在序列化中的处理。</li>
<li>Externalizable 与 Serializable 的区别与使用场景。</li>
<li>Java 序列化的安全风险（反序列化漏洞）与防护措施。</li>
<li>高性能二进制序列化方案对比：Kryo、Protostuff、Protobuf、Avro。</li>
<li>JSON 和二进制序列化的权衡（可读性 vs 性能&#x2F;大小）。</li>
<li>如何实现可演化的序列化协议（向前&#x2F;向后兼容）？</li>
<li>对象图序列化时循环引用的处理（句柄机制）。</li>
<li>对象序列化性能调优要点（缓冲、对象重用）。</li>
<li>在分布式系统中如何管理序列化策略（跨服务版本）？</li>
<li>自定义序列化（writeObject&#x2F;readObject）常见陷阱。</li>
<li>序列化时如何处理类加载器问题？</li>
<li>大对象序列化时的内存与 GC 风险如何降低？</li>
<li>使用序列化作为缓存（Redis&#x2F;Memcached）时的注意事项。</li>
</ol>
<hr>
<h2 id="五、NIO-深入：Buffer-Channel-Selector（76–100）"><a href="#五、NIO-深入：Buffer-Channel-Selector（76–100）" class="headerlink" title="五、NIO 深入：Buffer &#x2F; Channel &#x2F; Selector（76–100）"></a>五、NIO 深入：Buffer &#x2F; Channel &#x2F; Selector（76–100）</h2><hr>
<h3 id="1-NIO-三大核心（Buffer、Channel、Selector）"><a href="#1-NIO-三大核心（Buffer、Channel、Selector）" class="headerlink" title="1. NIO 三大核心（Buffer、Channel、Selector）"></a>1. NIO 三大核心（Buffer、Channel、Selector）</h3><ul>
<li><strong>Buffer</strong>：数据容器，所有读写操作都要通过它完成。</li>
<li><strong>Channel</strong>：通道，连接数据源与 Buffer，支持双向读写。</li>
<li><strong>Selector</strong>：多路复用器，检测多个 Channel 的事件（读、写、连接等），实现非阻塞 IO。</li>
</ul>
<hr>
<h3 id="2-ByteBuffer-的-position-limit-capacity"><a href="#2-ByteBuffer-的-position-limit-capacity" class="headerlink" title="2. ByteBuffer 的 position &#x2F; limit &#x2F; capacity"></a>2. ByteBuffer 的 position &#x2F; limit &#x2F; capacity</h3><ul>
<li><strong>capacity</strong>：缓冲区的总容量，创建时确定。</li>
<li><strong>position</strong>：当前读写指针，表示下一个操作的位置。</li>
<li><strong>limit</strong>：可操作的边界，写模式下&#x3D;capacity，读模式下&#x3D;写入的数据量。</li>
</ul>
<hr>
<h3 id="3-flip-clear-rewind-compact"><a href="#3-flip-clear-rewind-compact" class="headerlink" title="3. flip(), clear(), rewind(), compact()"></a>3. flip(), clear(), rewind(), compact()</h3><ul>
<li><strong>flip()</strong>：切换写 → 读模式（limit&#x3D;position，position&#x3D;0）。</li>
<li><strong>clear()</strong>：清空缓冲，准备写（position&#x3D;0，limit&#x3D;capacity）。</li>
<li><strong>rewind()</strong>：重新读（position&#x3D;0，limit 不变）。</li>
<li><strong>compact()</strong>：未读数据前移，position 指向未读数据末尾。</li>
</ul>
<hr>
<h3 id="4-DirectByteBuffer-vs-HeapByteBuffer"><a href="#4-DirectByteBuffer-vs-HeapByteBuffer" class="headerlink" title="4. DirectByteBuffer vs HeapByteBuffer"></a>4. DirectByteBuffer vs HeapByteBuffer</h3><ul>
<li><strong>HeapByteBuffer</strong>：数据在 JVM 堆内存，GC 管理，拷贝到内核态多一份。</li>
<li><strong>DirectByteBuffer</strong>：数据在堆外内存，IO 时零拷贝，性能更高，但分配释放代价大。</li>
</ul>
<hr>
<h3 id="5-ByteBuffer-slice-asReadOnlyBuffer"><a href="#5-ByteBuffer-slice-asReadOnlyBuffer" class="headerlink" title="5. ByteBuffer slice() &#x2F; asReadOnlyBuffer()"></a>5. ByteBuffer slice() &#x2F; asReadOnlyBuffer()</h3><ul>
<li><strong>slice()</strong>：共享底层数据，新的缓冲区 position&#x3D;0，limit&#x3D;剩余。</li>
<li><strong>asReadOnlyBuffer()</strong>：生成只读视图，修改会抛 <code>ReadOnlyBufferException</code>。</li>
</ul>
<hr>
<h3 id="6-Scatter-Gather-IO"><a href="#6-Scatter-Gather-IO" class="headerlink" title="6. Scatter&#x2F;Gather IO"></a>6. Scatter&#x2F;Gather IO</h3><ul>
<li><strong>Scatter Read</strong>：一个 Channel → 多个 Buffer（适合固定头+体）。</li>
<li><strong>Gather Write</strong>：多个 Buffer → 一个 Channel（避免拼接）。</li>
</ul>
<hr>
<h3 id="7-FileChannel-的关键方法"><a href="#7-FileChannel-的关键方法" class="headerlink" title="7. FileChannel 的关键方法"></a>7. FileChannel 的关键方法</h3><ul>
<li><strong>position()</strong>：获取&#x2F;设置文件指针。</li>
<li><strong>size()</strong>：返回文件大小。</li>
<li><strong>truncate(long size)</strong>：截断文件。</li>
<li><strong>force(boolean metaData)</strong>：强制写入磁盘。</li>
</ul>
<hr>
<h3 id="8-MappedByteBuffer（内存映射）"><a href="#8-MappedByteBuffer（内存映射）" class="headerlink" title="8. MappedByteBuffer（内存映射）"></a>8. MappedByteBuffer（内存映射）</h3><ul>
<li><strong>创建</strong>：<code>FileChannel.map(mode, position, size)</code></li>
<li><strong>优点</strong>：直接操作内存映射，效率高。</li>
<li><strong>释放</strong>：JDK 无直接 API，通常通过反射 <code>Cleaner.clean()</code>，需注意内存泄露。</li>
</ul>
<hr>
<h3 id="9-Channel-vs-Stream"><a href="#9-Channel-vs-Stream" class="headerlink" title="9. Channel vs Stream"></a>9. Channel vs Stream</h3><ul>
<li><strong>Stream</strong>：单向、阻塞。</li>
<li><strong>Channel</strong>：双向、可非阻塞，可和 Selector 配合。</li>
</ul>
<hr>
<h3 id="10-Selector-工作流程"><a href="#10-Selector-工作流程" class="headerlink" title="10. Selector 工作流程"></a>10. Selector 工作流程</h3><ol>
<li><strong>注册</strong>：<code>channel.register(selector, ops)</code></li>
<li><strong>选择</strong>：<code>selector.select(timeout)</code></li>
<li><strong>遍历</strong>：<code>selectedKeys()</code> 遍历处理</li>
<li><strong>取消</strong>：调用 <code>key.cancel()</code></li>
</ol>
<hr>
<h3 id="11-Selector-底层实现"><a href="#11-Selector-底层实现" class="headerlink" title="11. Selector 底层实现"></a>11. Selector 底层实现</h3><ul>
<li><strong>Linux</strong>：epoll</li>
<li><strong>Windows</strong>：select</li>
<li><strong>macOS</strong>：kqueue<br> 影响性能和可扩展性（epoll 适合高并发）。</li>
</ul>
<hr>
<h3 id="12-非阻塞-Channel-的-read-write-返回值"><a href="#12-非阻塞-Channel-的-read-write-返回值" class="headerlink" title="12. 非阻塞 Channel 的 read&#x2F;write 返回值"></a>12. 非阻塞 Channel 的 read&#x2F;write 返回值</h3><ul>
<li><p><strong>read</strong>：</p>
<ul>
<li><blockquote>
<p>0：读取字节数</p>
</blockquote>
</li>
<li><p>0：无数据</p>
</li>
<li><p>-1：EOF（关闭）</p>
</li>
</ul>
</li>
<li><p><strong>write</strong>：</p>
<ul>
<li><blockquote>
<p>0：写入字节数</p>
</blockquote>
</li>
<li><p>0：内核缓冲区满</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="13-粘包-拆包问题"><a href="#13-粘包-拆包问题" class="headerlink" title="13. 粘包&#x2F;拆包问题"></a>13. 粘包&#x2F;拆包问题</h3><p>原因：TCP 流式传输无边界。<br> 解决策略：</p>
<ul>
<li>固定长度（定长协议）</li>
<li>分隔符（如 <code>\n</code>）</li>
<li>长度前置（常见）</li>
</ul>
<hr>
<h3 id="14-超时断开-心跳检测"><a href="#14-超时断开-心跳检测" class="headerlink" title="14. 超时断开 &amp; 心跳检测"></a>14. 超时断开 &amp; 心跳检测</h3><ul>
<li><strong>超时断开</strong>：在 <code>select(timeout)</code> 中检测长时间无读写的连接。</li>
<li><strong>心跳检测</strong>：客户端&#x2F;服务端定期发送 <code>PING</code>，无响应则断开。</li>
</ul>
<hr>
<h3 id="15-Pipe-在-NIO-中的作用"><a href="#15-Pipe-在-NIO-中的作用" class="headerlink" title="15. Pipe 在 NIO 中的作用"></a>15. Pipe 在 NIO 中的作用</h3><ul>
<li>单向通信（写端 → 读端），常用于线程间通信。</li>
<li>但性能不如 BlockingQueue。</li>
</ul>
<hr>
<h3 id="16-多-Selector-多-Reactor"><a href="#16-多-Selector-多-Reactor" class="headerlink" title="16. 多 Selector &#x2F; 多 Reactor"></a>16. 多 Selector &#x2F; 多 Reactor</h3><ul>
<li><strong>单 Reactor</strong>：一个线程负责 Selector。</li>
<li><strong>多 Reactor</strong>：主 Reactor 处理 accept，子 Reactor 处理 read&#x2F;write。</li>
<li><strong>多 Selector</strong>：线程池分担 Channel 负载。</li>
</ul>
<hr>
<h3 id="17-ByteBuffer-多线程问题"><a href="#17-ByteBuffer-多线程问题" class="headerlink" title="17. ByteBuffer 多线程问题"></a>17. ByteBuffer 多线程问题</h3><ul>
<li><strong>不是线程安全的</strong>。</li>
<li>解决：每个线程独立 Buffer，或外部加锁。</li>
</ul>
<hr>
<h3 id="18-DirectByteBuffer-避免泄露"><a href="#18-DirectByteBuffer-避免泄露" class="headerlink" title="18. DirectByteBuffer 避免泄露"></a>18. DirectByteBuffer 避免泄露</h3><ul>
<li>使用 <code>ByteBuffer.allocateDirect()</code> 代价大。</li>
<li>建议：使用 <code>-XX:+UseLargePages</code>、池化管理（Netty 的 <code>PooledByteBufAllocator</code>）。</li>
</ul>
<hr>
<h3 id="19-Selector-selectedKeys-正确用法"><a href="#19-Selector-selectedKeys-正确用法" class="headerlink" title="19. Selector selectedKeys 正确用法"></a>19. Selector selectedKeys 正确用法</h3><ul>
<li>遍历 <code>selectedKeys()</code></li>
<li>处理完一个 key → <code>iterator.remove()</code></li>
<li>否则下次循环仍会触发。</li>
</ul>
<hr>
<h3 id="20-NIO-高效读写循环模板"><a href="#20-NIO-高效读写循环模板" class="headerlink" title="20. NIO 高效读写循环模板"></a>20. NIO 高效读写循环模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    selector.select();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.read(buf);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) sc.close();</span><br><span class="line">            <span class="keyword">else</span> &#123; buf.flip(); sc.write(buf); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="21-transferTo-transferFrom（零拷贝）"><a href="#21-transferTo-transferFrom（零拷贝）" class="headerlink" title="21. transferTo&#x2F;transferFrom（零拷贝）"></a>21. transferTo&#x2F;transferFrom（零拷贝）</h3><ul>
<li>直接在内核空间完成文件复制（减少用户态拷贝）。</li>
<li>局限：Windows 一次传输大小有限，需循环。</li>
</ul>
<hr>
<h3 id="22-FileChannel-高效复制"><a href="#22-FileChannel-高效复制" class="headerlink" title="22. FileChannel 高效复制"></a>22. FileChannel 高效复制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src).getChannel();</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest).getChannel()) &#123;</span><br><span class="line">    in.transferTo(<span class="number">0</span>, in.size(), out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="23-高并发服务器瓶颈"><a href="#23-高并发服务器瓶颈" class="headerlink" title="23. 高并发服务器瓶颈"></a>23. 高并发服务器瓶颈</h3><ul>
<li>单线程 Selector 性能不足。</li>
<li>Buffer&#x2F;Direct 内存泄露。</li>
<li>大量小包（TCP 粘拆包）。</li>
<li>epoll 空轮询 bug（CPU 飙高）。</li>
</ul>
<hr>
<h3 id="24-Windows-vs-Linux"><a href="#24-Windows-vs-Linux" class="headerlink" title="24. Windows vs Linux"></a>24. Windows vs Linux</h3><ul>
<li><strong>Linux</strong>：epoll，可伸缩到百万连接。</li>
<li><strong>Windows</strong>：select，fd 数量受限，扩展性差。</li>
</ul>
<hr>
<h3 id="25-简单-Echo-Server-思路"><a href="#25-简单-Echo-Server-思路" class="headerlink" title="25. 简单 Echo Server 思路"></a>25. 简单 Echo Server 思路</h3><ol>
<li>创建 <code>Selector</code></li>
<li>注册 <code>ServerSocketChannel</code></li>
<li>循环 <code>select()</code></li>
<li>处理 <code>accept</code> → 注册 SocketChannel</li>
<li>处理 <code>read</code> → 回写数据</li>
</ol>
<hr>
<p>⚡总结：NIO 的核心是 <strong>缓冲区管理</strong>（ByteBuffer）、<strong>多路复用</strong>（Selector）、<strong>零拷贝优化</strong>（FileChannel.transferTo&#x2F;MappedByteBuffer）。<br> 在高并发系统里（如 Netty），这些 API 会结合线程模型和内存池进一步优化。</p>
<hr>
<h2 id="六、Socket-TCP-UDP-WebSocket（101–140）"><a href="#六、Socket-TCP-UDP-WebSocket（101–140）" class="headerlink" title="六、Socket &#x2F; TCP &#x2F; UDP &#x2F; WebSocket（101–140）"></a>六、Socket &#x2F; TCP &#x2F; UDP &#x2F; WebSocket（101–140）</h2><ol>
<li>Socket 的基本概念：端点、三元组&#x2F;四元组（IP:port + peer）。</li>
<li>Java 中 Socket、ServerSocket、DatagramSocket 的主要 API 区别。</li>
<li>TCP 与 UDP 的核心差异（可靠性、有序性、连接性）。</li>
<li>TCP 三次握手（SYN、SYN-ACK、ACK）与四次挥手流程详解。</li>
<li>TIME_WAIT、CLOSE_WAIT、FIN_WAIT1&#x2F;2 等 TCP 状态含义与产生原因。</li>
<li>半开连接（half-open）是什么，如何检测与恢复？</li>
<li>TCP 的流量控制（窗口）与拥塞控制（慢启动、拥塞避免、快重传、快恢复）基础。</li>
<li>Nagle 算法（TCP_NODELAY）的原理和在延迟场景下的影响。</li>
<li>TCP 延迟确认（delayed ACK）对交互型应用的影响。</li>
<li>Socket 选项 SO_TIMEOUT、SO_KEEPALIVE、SO_REUSEADDR、SO_REUSEPORT、SO_LINGER 含义与使用场景。</li>
<li>backlog 参数（ServerSocket 构造或 listen）与 accept 队列（syn, accept 队列）区别。</li>
<li>ephemeral port（短暂端口）与端口耗尽问题及解决办法。</li>
<li>SYN flood 攻击的原理和防护（SYN cookies、firewall）。</li>
<li>TCP 快速打开（TCP Fast Open）是什么，有何优劣？（简述）</li>
<li>MTU、MSS 与 IP 分片对传输的影响与诊断方法。</li>
<li>UDP 的组播（Multicast）与广播（Broadcast）机制与 Java 支持（MulticastSocket）。</li>
<li>UDP 丢包、乱序、包大小限制（最佳实践）。</li>
<li>UDP 穿透 NAT（STUN&#x2F;ICE）的基本原理。</li>
<li>如何在 Java 中实现高性能 UDP 服务器？（NIO + DatagramChannel）</li>
<li>WebSocket 协议基础（握手、帧格式、ping&#x2F;pong、close）。</li>
<li>Java 实现 WebSocket 的常见库（javax.websocket、Netty websocket、Undertow）。</li>
<li>TLS over TCP（HTTPS）的握手流程要点（证书验证、对称密钥协商）。</li>
<li>使用 SSLSocket &#x2F; SSLServerSocket 和 SSLEngine 的差别及适用场景。</li>
<li>SSL&#x2F;TLS 握手的重用（session resumption）与性能优化。</li>
<li>中间人攻击（MITM）与证书链、CA、信任根的角色。</li>
<li>如何在 Socket 程序中实现心跳、超时与断线重连？</li>
<li>TCP Keepalive 与应用层心跳的区别和协同使用。</li>
<li>如何通过抓包（tcpdump&#x2F;wireshark）诊断 Socket 连接问题？</li>
<li>Socket 的非阻塞 accept&#x2F;read&#x2F;write 实现注意点（资源&#x2F;异步安全）。</li>
<li>如何避免 TCP 粘包&#x2F;拆包在 Socket 原生编程中的影响（流式协议设计）？</li>
<li>实战：实现一个带长度前缀的 TCP 协议的 Java 服务端&#x2F;客户端（思路）。</li>
<li>如何优雅处理大量短连接的场景？（连接池、HTTP keep-alive）</li>
<li>Socket 端口复用（SO_REUSEADDR vs SO_REUSEPORT）在负载均衡中的用法。</li>
<li>多路复用（select&#x2F;poll&#x2F;epoll）与 socket 大连接数的处理。</li>
<li>网络字节序（big-endian）与数据编解码注意点。</li>
<li>使用 TCP_NODELAY（禁用 Nagle）时的 CPU&#x2F;网络 trade-off。</li>
<li>如何在 Java 中做到零拷贝文件传输（Socket + FileChannel.transferTo）？</li>
<li>Socket 关闭流程中遇到阻塞（SO_LINGER）的处理办法。</li>
<li>如何防止或检测 “socket half-closed” 的资源泄漏？</li>
<li>实战题：用 BIO、NIO、Netty 各实现一个简易的聊天服务器，比较性能与代码复杂度（思路要点）。</li>
</ol>
<hr>
<h2 id="七、异步-IO、IO-模型与高阶模式（141–150）"><a href="#七、异步-IO、IO-模型与高阶模式（141–150）" class="headerlink" title="七、异步 IO、IO 模型与高阶模式（141–150）"></a>七、异步 IO、IO 模型与高阶模式（141–150）</h2><ol>
<li>IO 模型分类：同步阻塞、同步非阻塞、IO 多路复用、信号驱动、异步（AIO）。</li>
<li>Reactor 模式与 Proactor 模式的原理与区别。</li>
<li>Java AIO（AsynchronousChannel、AsynchronousSocketChannel）API 介绍。</li>
<li>CompletionHandler 与 Future 风格的异步回调比较。</li>
<li>高并发下选择 NIO 还是 AIO 的实际考量（实现复杂度、平台支持）。</li>
<li>事件驱动系统的 back-pressure 设计（流控、速率限制）。</li>
<li>线程模型设计：acceptors &#x2F; io workers &#x2F; business workers 的权衡。</li>
<li>RCU、无锁队列在高并发 IO 框架中的应用场景。</li>
<li>如何在应用层实现请求队列与排队策略来缓解突发流量？</li>
<li>实战题：设计一个支持百万连接的服务器架构（核心组件与 IO 策略）。</li>
</ol>
<hr>
<h2 id="八、零拷贝、内核与性能调优（151–160）"><a href="#八、零拷贝、内核与性能调优（151–160）" class="headerlink" title="八、零拷贝、内核与性能调优（151–160）"></a>八、零拷贝、内核与性能调优（151–160）</h2><ol>
<li>零拷贝（zero-copy）概念和常见实现（sendfile, mmap, splice）。</li>
<li>FileChannel.transferTo&#x2F;transferFrom 在 Linux 下如何利用 sendfile 实现零拷贝？</li>
<li>mmap（内存映射文件）的实现原理与 GC &#x2F;回收问题。</li>
<li>DMA（Direct Memory Access）在零拷贝中的作用与限制。</li>
<li>内核态 &#x2F; 用户态拷贝次数与零拷贝带来的减少效果。</li>
<li>TCP 窗口、拥塞控制调优参数（net.ipv4.tcp_* 系列常见项）。</li>
<li>系统级调优：文件描述符上限（ulimit -n）、somaxconn、backlog、epoll_limits 等。</li>
<li>高并发网络服务的监控指标（fd 使用、accept latency、context switch、cpu steal）。</li>
<li>性能诊断工具与流程：iostat, vmstat, sar, perf, tcpdump, ss, strace。</li>
<li>实战题：如何定位并修复一个高并发服务器的 accept 阻塞 &#x2F; 连接丢失 问题（诊断步骤）。</li>
</ol>
<hr>
<h1 id="Java-基础面试题"><a href="#Java-基础面试题" class="headerlink" title="Java 基础面试题"></a>Java 基础面试题</h1><h3 id="一、语言特性-基础语法"><a href="#一、语言特性-基础语法" class="headerlink" title="一、语言特性 &amp; 基础语法"></a>一、语言特性 &amp; 基础语法</h3><hr>
<h3 id="1-Java-中的-和-equals-有什么区别？如何正确重写-equals-？"><a href="#1-Java-中的-和-equals-有什么区别？如何正确重写-equals-？" class="headerlink" title="1. Java 中的 &#x3D;&#x3D; 和 equals() 有什么区别？如何正确重写 equals()？"></a>1. Java 中的 &#x3D;&#x3D; 和 equals() 有什么区别？如何正确重写 equals()？</h3><ul>
<li><strong>&#x3D;&#x3D;</strong><ul>
<li>对于基本数据类型：比较值是否相等。</li>
<li>对于引用类型：比较两个引用是否指向同一块内存地址（即是否是同一个对象）。</li>
</ul>
</li>
<li><strong>equals()</strong><ul>
<li>定义在 <code>Object</code> 类中，默认实现也是 <code>==</code>。</li>
<li>一般会被类（如 <code>String</code>、<code>Integer</code> 等）重写，用来比较“内容”是否相同，而不是内存地址。</li>
</ul>
</li>
</ul>
<p>👉 正确重写 <code>equals()</code> 要满足 <strong>自反性、对称性、传递性、一致性</strong>，并且和 <code>null</code> 比较时返回 <code>false</code>。<br> 典型实现步骤：</p>
<ol>
<li>判断 <code>this == obj</code>，若相等直接返回 <code>true</code>。</li>
<li>判断 <code>obj</code> 是否为同类实例。</li>
<li>强制类型转换后逐个比较关键字段。</li>
</ol>
<hr>
<h3 id="2-为什么重写-equals-时必须重写-hashCode-？不重写会怎样？"><a href="#2-为什么重写-equals-时必须重写-hashCode-？不重写会怎样？" class="headerlink" title="2. 为什么重写 equals() 时必须重写 hashCode()？不重写会怎样？"></a>2. 为什么重写 equals() 时必须重写 hashCode()？不重写会怎样？</h3><ul>
<li><strong>原因</strong>：因为 <code>HashMap</code>、<code>HashSet</code> 等基于哈希表的集合使用 <code>hashCode()</code> 来决定元素存放位置，然后再用 <code>equals()</code> 判断元素是否相同。</li>
<li><strong>契约</strong>（JDK 文档规定）：<ul>
<li>如果两个对象 <code>equals()</code> 相等，那么它们的 <code>hashCode()</code> 必须相等。</li>
<li>反之，<code>hashCode()</code> 相等并不一定意味着 <code>equals()</code> 相等。</li>
</ul>
</li>
<li><strong>不重写会怎样</strong>：<ul>
<li>两个内容相同的对象可能 <code>equals()</code> 为 true，但 <code>hashCode()</code> 不同，导致放进 <code>HashSet</code> 时被当作两个对象存储，违背集合“不重复”的原则。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-Object-类有哪些方法？哪些方法经常需要重写？"><a href="#3-Object-类有哪些方法？哪些方法经常需要重写？" class="headerlink" title="3. Object 类有哪些方法？哪些方法经常需要重写？"></a>3. Object 类有哪些方法？哪些方法经常需要重写？</h3><ul>
<li><strong>常用方法</strong>：<ul>
<li><code>equals()</code>：对象内容比较。</li>
<li><code>hashCode()</code>：哈希值，配合 <code>equals</code>。</li>
<li><code>toString()</code>：对象的字符串表示。</li>
<li><code>clone()</code>：对象克隆（浅拷贝，需实现 <code>Cloneable</code>）。</li>
<li><code>finalize()</code>：对象被 GC 前调用（已不推荐使用）。</li>
</ul>
</li>
<li><strong>同步方法</strong>：<ul>
<li><code>wait()</code> &#x2F; <code>notify()</code> &#x2F; <code>notifyAll()</code>：线程通信。</li>
</ul>
</li>
<li><strong>类相关方法</strong>：<ul>
<li><code>getClass()</code>：获取对象的运行时类型。</li>
</ul>
</li>
</ul>
<p>👉 经常需要重写的：<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>。</p>
<hr>
<h3 id="4-final、finally、finalize-有什么区别？"><a href="#4-final、finally、finalize-有什么区别？" class="headerlink" title="4. final、finally、finalize() 有什么区别？"></a>4. final、finally、finalize() 有什么区别？</h3><ul>
<li><strong>final</strong>：关键字<ul>
<li>修饰类：类不能被继承。</li>
<li>修饰方法：方法不能被重写。</li>
<li>修饰变量：变量成为常量，只能赋值一次。</li>
</ul>
</li>
<li><strong>finally</strong>：关键字<ul>
<li>用于 <code>try-catch-finally</code>，无论是否有异常，<code>finally</code> 块中的代码一定会执行（除非 <code>System.exit(0)</code>）。</li>
</ul>
</li>
<li><strong>finalize()</strong>：方法<ul>
<li><code>Object</code> 类定义，在 GC 前调用，常用于释放非托管资源。</li>
<li>已被标记为废弃（Java 9 开始），因为不可预测、不可靠。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-Java-中的-instanceof-关键字是如何实现的？"><a href="#5-Java-中的-instanceof-关键字是如何实现的？" class="headerlink" title="5. Java 中的 instanceof 关键字是如何实现的？"></a>5. Java 中的 instanceof 关键字是如何实现的？</h3><ul>
<li><strong>作用</strong>：判断某个对象是否为某个类或其子类的实例。</li>
<li><strong>实现原理</strong>：<ul>
<li>JVM 在对象头中存储了对象所属的类的元数据指针。</li>
<li><code>instanceof</code> 实际是检查该类元数据是否是指定类或其子类。</li>
<li>编译器会将 <code>obj instanceof A</code> 转换为字节码 <code>instanceof</code> 指令，由 JVM 在运行时判断。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-接口和抽象类的区别？接口能不能有构造函数？"><a href="#6-接口和抽象类的区别？接口能不能有构造函数？" class="headerlink" title="6. 接口和抽象类的区别？接口能不能有构造函数？"></a>6. 接口和抽象类的区别？接口能不能有构造函数？</h3><ul>
<li><strong>接口</strong>：<ul>
<li>只能定义方法（Java 8 之后可有 <code>default</code> 和 <code>static</code> 方法）。</li>
<li>不能有构造函数（因为接口不能直接实例化）。</li>
<li>可以实现 <strong>多继承</strong>（一个类可以实现多个接口）。</li>
</ul>
</li>
<li><strong>抽象类</strong>：<ul>
<li>可以有普通方法、抽象方法、成员变量。</li>
<li>可以有构造函数（但不能直接 new，用于子类构造时调用）。</li>
<li>只能单继承。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-接口可以多继承吗？抽象类可以实现接口吗？"><a href="#7-接口可以多继承吗？抽象类可以实现接口吗？" class="headerlink" title="7. 接口可以多继承吗？抽象类可以实现接口吗？"></a>7. 接口可以多继承吗？抽象类可以实现接口吗？</h3><ul>
<li><strong>接口可以多继承</strong>：<code>interface A extends B, C &#123;&#125;</code></li>
<li><strong>抽象类可以实现接口</strong>：可以选择性实现接口的方法，未实现的方法仍保持 <code>abstract</code>，由子类实现。</li>
</ul>
<hr>
<h3 id="8-default-方法和-static-方法在接口中的意义是什么？"><a href="#8-default-方法和-static-方法在接口中的意义是什么？" class="headerlink" title="8. default 方法和 static 方法在接口中的意义是什么？"></a>8. default 方法和 static 方法在接口中的意义是什么？</h3><ul>
<li><strong>default 方法</strong>：<ul>
<li>Java 8 引入，接口中可以有默认实现的方法。</li>
<li>解决接口扩展的兼容性问题（给老接口新增方法不会导致所有实现类报错）。</li>
</ul>
</li>
<li><strong>static 方法</strong>：<ul>
<li>属于接口本身，而不是实现类。</li>
<li>用于提供工具方法或公共逻辑（类似 <code>Collections</code> 的工具类方法）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="9-什么是内部类？分为哪几种？"><a href="#9-什么是内部类？分为哪几种？" class="headerlink" title="9. 什么是内部类？分为哪几种？"></a>9. 什么是内部类？分为哪几种？</h3><ul>
<li><strong>内部类</strong>：定义在类中的类，可以访问外部类的成员。</li>
<li><strong>种类</strong>：<ol>
<li><strong>成员内部类</strong>（非静态内部类）<ul>
<li>依赖外部类实例，不能有 <code>static</code> 成员。</li>
</ul>
</li>
<li><strong>静态内部类</strong><ul>
<li>类似普通类，但作用域在外部类内，可以有 <code>static</code> 成员。</li>
</ul>
</li>
<li><strong>局部内部类</strong><ul>
<li>定义在方法体或代码块中，只能在该范围内使用。</li>
</ul>
</li>
<li><strong>匿名内部类</strong><ul>
<li>没有名字，通常在需要“临时实现接口或继承类”的场景使用。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="10-匿名内部类和-Lambda-表达式的区别？"><a href="#10-匿名内部类和-Lambda-表达式的区别？" class="headerlink" title="10. 匿名内部类和 Lambda 表达式的区别？"></a>10. 匿名内部类和 Lambda 表达式的区别？</h3><ul>
<li><strong>匿名内部类</strong>：<ul>
<li>实现接口&#x2F;继承抽象类的 <strong>具体匿名类对象</strong>。</li>
<li>可以有多个方法，但通常只重写需要的方法。</li>
<li>生成 <code>.class</code> 文件（额外开销）。</li>
</ul>
</li>
<li><strong>Lambda 表达式</strong>：<ul>
<li>仅能用于 <strong>函数式接口</strong>（只有一个抽象方法的接口）。</li>
<li>更简洁，本质是语法糖，编译后生成 <code>invokedynamic</code> 字节码指令，调用运行时生成的函数对象。</li>
<li>不会创建新的 <code>.class</code> 文件，更轻量。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、数据类型-内存"><a href="#二、数据类型-内存" class="headerlink" title="二、数据类型 &amp; 内存"></a>二、数据类型 &amp; 内存</h3><hr>
<h3 id="1-Java-中的基本数据类型和包装类型有哪些区别？"><a href="#1-Java-中的基本数据类型和包装类型有哪些区别？" class="headerlink" title="1. Java 中的基本数据类型和包装类型有哪些区别？"></a>1. Java 中的基本数据类型和包装类型有哪些区别？</h3><ul>
<li><strong>基本数据类型</strong>（primitive）：<code>byte, short, int, long, float, double, char, boolean</code><ul>
<li>存储在栈上（或寄存器），效率高，空间占用固定。</li>
<li>不能为 <code>null</code>，默认值固定（如 <code>int</code> 默认 <code>0</code>，<code>boolean</code> 默认 <code>false</code>）。</li>
</ul>
</li>
<li><strong>包装类型</strong>（wrapper）：<code>Byte, Short, Integer, Long, Float, Double, Character, Boolean</code><ul>
<li>是对象，存储在堆中。</li>
<li>可以为 <code>null</code>，有丰富的 API。</li>
<li>可以参与集合类（如 <code>ArrayList</code> 只能存对象）。</li>
</ul>
</li>
<li><strong>自动装箱&#x2F;拆箱</strong>：Java 会在基本类型和包装类之间自动转换。</li>
</ul>
<hr>
<h3 id="2-为什么-Integer-有缓存机制？范围是多少？"><a href="#2-为什么-Integer-有缓存机制？范围是多少？" class="headerlink" title="2. 为什么 Integer 有缓存机制？范围是多少？"></a>2. 为什么 Integer 有缓存机制？范围是多少？</h3><ul>
<li><strong>原因</strong>：<ul>
<li>为了避免频繁创建对象，提高性能。</li>
<li>小整数使用频率高（如循环、下标），所以缓存常用的整数。</li>
</ul>
</li>
<li><strong>范围</strong>：<code>-128 ~ 127</code>。</li>
<li><strong>实现</strong>：<ul>
<li><code>IntegerCache</code> 静态内部类在类加载时初始化缓存数组。</li>
<li><code>Integer.valueOf(int i)</code> 方法会先查缓存，再决定是否 new 对象。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-为什么-new-Integer-127-new-Integer-127-为-false，而-Integer-valueOf-127-Integer-valueOf-127-为-true？"><a href="#3-为什么-new-Integer-127-new-Integer-127-为-false，而-Integer-valueOf-127-Integer-valueOf-127-为-true？" class="headerlink" title="3. 为什么 new Integer(127) == new Integer(127) 为 false，而 Integer.valueOf(127) == Integer.valueOf(127) 为 true？"></a>3. 为什么 <code>new Integer(127) == new Integer(127)</code> 为 false，而 <code>Integer.valueOf(127) == Integer.valueOf(127)</code> 为 true？</h3><ul>
<li><code>new Integer(127)</code>：每次都会创建新对象，内存地址不同，所以 <code>==</code> 为 false。</li>
<li><code>Integer.valueOf(127)</code>：会查缓存，<code>127</code> 在 <code>-128~127</code> 范围内，返回同一个对象引用，所以 <code>==</code> 为 true。</li>
</ul>
<p>👉 <strong>总结</strong>：</p>
<ul>
<li><code>==</code> 比较的是引用地址。</li>
<li><code>equals()</code> 才是比较数值。</li>
</ul>
<hr>
<h3 id="4-NaN-和-Infinity-在-Java-中如何表示？"><a href="#4-NaN-和-Infinity-在-Java-中如何表示？" class="headerlink" title="4. NaN 和 Infinity 在 Java 中如何表示？"></a>4. NaN 和 Infinity 在 Java 中如何表示？</h3><ul>
<li><strong>NaN（Not a Number）</strong>：<ul>
<li>如 <code>0.0 / 0.0</code> 或 <code>Math.sqrt(-1)</code>。</li>
<li>特点：<code>NaN != NaN</code>，要用 <code>Double.isNaN()</code> 检测。</li>
</ul>
</li>
<li><strong>Infinity（正&#x2F;负无穷大）</strong>：<ul>
<li>如 <code>1.0 / 0.0 = Infinity</code>，<code>-1.0 / 0.0 = -Infinity</code>。</li>
<li>用 <code>Double.isInfinite()</code> 检测。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-为什么浮点数计算有精度问题？如何避免？"><a href="#5-为什么浮点数计算有精度问题？如何避免？" class="headerlink" title="5. 为什么浮点数计算有精度问题？如何避免？"></a>5. 为什么浮点数计算有精度问题？如何避免？</h3><ul>
<li><strong>原因</strong>：<ul>
<li>浮点数采用 <strong>IEEE 754 二进制浮点表示</strong>，大多数十进制小数（如 <code>0.1</code>）不能精确表示，只能存储近似值。</li>
<li>计算时会累积误差。</li>
</ul>
</li>
<li><strong>避免方法</strong>：<ul>
<li>使用 <code>BigDecimal</code>（推荐）。</li>
<li>或使用整数替代（如金额用分而不是元）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-BigDecimal-为什么能解决浮点数精度问题？"><a href="#6-BigDecimal-为什么能解决浮点数精度问题？" class="headerlink" title="6. BigDecimal 为什么能解决浮点数精度问题？"></a>6. BigDecimal 为什么能解决浮点数精度问题？</h3><ul>
<li><strong>原理</strong>：<ul>
<li>内部使用 <strong>BigInteger + 精度标识 scale</strong> 表示任意精度的十进制数。</li>
<li>不依赖二进制浮点存储，而是基于字符串或整数进行精确计算。</li>
</ul>
</li>
<li><strong>注意</strong>：<ul>
<li>不能用 <code>new BigDecimal(double)</code>（会带入二进制误差）。</li>
<li>推荐 <code>BigDecimal.valueOf(double)</code> 或 <code>new BigDecimal(String)</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-Java-中的字符集默认是什么？在不同平台上会不一样吗？"><a href="#7-Java-中的字符集默认是什么？在不同平台上会不一样吗？" class="headerlink" title="7. Java 中的字符集默认是什么？在不同平台上会不一样吗？"></a>7. Java 中的字符集默认是什么？在不同平台上会不一样吗？</h3><ul>
<li>Java 内部使用 <strong>UTF-16（Unicode）</strong> 存储 <code>char</code> 和 <code>String</code>。</li>
<li>默认字符集（<code>Charset.defaultCharset()</code>）会随平台不同而不同：<ul>
<li>Windows（中文环境）：<code>GBK</code> 或 <code>GB2312</code>。</li>
<li>Linux &#x2F; macOS：通常是 <code>UTF-8</code>。<br> 👉 这会影响文件读写、网络传输等。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8-String、StringBuilder、StringBuffer-区别？线程安全性？"><a href="#8-String、StringBuilder、StringBuffer-区别？线程安全性？" class="headerlink" title="8. String、StringBuilder、StringBuffer 区别？线程安全性？"></a>8. String、StringBuilder、StringBuffer 区别？线程安全性？</h3><ul>
<li><strong>String</strong><ul>
<li>不可变类（底层 <code>final char[]</code>），每次拼接都会生成新对象。</li>
</ul>
</li>
<li><strong>StringBuilder</strong><ul>
<li>可变字符序列（底层 <code>char[]</code>），高效，<strong>非线程安全</strong>。</li>
</ul>
</li>
<li><strong>StringBuffer</strong><ul>
<li>可变字符序列，方法加了 <code>synchronized</code>，<strong>线程安全</strong>，效率比 <code>StringBuilder</code> 低。</li>
</ul>
</li>
</ul>
<p>👉 单线程推荐 <code>StringBuilder</code>，多线程推荐 <code>StringBuffer</code>。</p>
<hr>
<h3 id="9-为什么-String-是不可变的？背后实现细节？"><a href="#9-为什么-String-是不可变的？背后实现细节？" class="headerlink" title="9. 为什么 String 是不可变的？背后实现细节？"></a>9. 为什么 String 是不可变的？背后实现细节？</h3><ul>
<li><strong>原因</strong>：<ol>
<li><strong>安全性</strong>：如网络请求 URL、文件路径、ClassLoader 名称等，一旦创建不可修改，避免被篡改。</li>
<li><strong>线程安全</strong>：不可变对象天然线程安全。</li>
<li><strong>哈希值缓存</strong>：<code>String</code> 缓存了 <code>hashCode</code>，不可变保证哈希值不会变化。</li>
<li><strong>字符串常量池优化</strong>：不可变对象可被复用。</li>
</ol>
</li>
<li><strong>实现</strong>：<ul>
<li><code>private final char[] value</code>（JDK 9 以后改成 <code>byte[]</code> + <code>coder</code>，节省内存）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10-intern-方法的作用是什么？"><a href="#10-intern-方法的作用是什么？" class="headerlink" title="10. intern() 方法的作用是什么？"></a>10. intern() 方法的作用是什么？</h3><ul>
<li><p><strong>作用</strong>：</p>
<ul>
<li>将字符串放入 <strong>字符串常量池</strong>，返回池中的引用。</li>
<li>若池中已有等值字符串，则返回已有对象引用。</li>
</ul>
</li>
<li><p><strong>意义</strong>：</p>
<ul>
<li>减少内存占用，提高比较效率（常量池中的 <code>String</code> 可以直接用 <code>==</code> 比较）。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s2 == s3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="三、集合框架"><a href="#三、集合框架" class="headerlink" title="三、集合框架"></a>三、集合框架</h3><hr>
<h2 id="1-ArrayList-和-Vector-的区别"><a href="#1-ArrayList-和-Vector-的区别" class="headerlink" title="1. ArrayList 和 Vector 的区别"></a><strong>1. ArrayList 和 Vector 的区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>ArrayList</th>
<th>Vector</th>
</tr>
</thead>
<tbody><tr>
<td>线程安全</td>
<td>非线程安全</td>
<td>线程安全（方法加 synchronized）</td>
</tr>
<tr>
<td>扩容机制</td>
<td>默认 1.5 倍</td>
<td>默认 2 倍</td>
</tr>
<tr>
<td>性能</td>
<td>高（无锁）</td>
<td>低（同步开销）</td>
</tr>
<tr>
<td>用途</td>
<td>多线程外部不安全</td>
<td>适合多线程共享场景，但现在较少使用</td>
</tr>
<tr>
<td>面试拓展</td>
<td>如何在多线程下安全使用 ArrayList？可用 <code>Collections.synchronizedList()</code> 或 <code>CopyOnWriteArrayList</code></td>
<td></td>
</tr>
</tbody></table>
<p><strong>原理</strong>：</p>
<ul>
<li>都基于动态数组实现</li>
<li>添加元素时如果容量不够，会创建一个新的数组并复制原数组内容</li>
</ul>
<hr>
<h2 id="2-为什么-ArrayList-的扩容是-1-5-倍？"><a href="#2-为什么-ArrayList-的扩容是-1-5-倍？" class="headerlink" title="2. 为什么 ArrayList 的扩容是 1.5 倍？"></a><strong>2. 为什么 ArrayList 的扩容是 1.5 倍？</strong></h2><ul>
<li><p><strong>目的</strong>：平衡 <strong>内存消耗</strong> 和 <strong>扩容频率</strong></p>
</li>
<li><p><strong>原理</strong>：</p>
<ul>
<li>过小扩容：频繁创建新数组，复制开销大</li>
<li>过大扩容：浪费内存</li>
</ul>
</li>
<li><p>JDK 1.8 的扩容公式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 相当于 1.5 倍</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>面试点：</p>
<ul>
<li>LinkedList 不需要扩容，因为链表动态增长</li>
<li>如何自定义扩容策略？</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-LinkedList-是双向链表还是单向链表？"><a href="#3-LinkedList-是双向链表还是单向链表？" class="headerlink" title="3. LinkedList 是双向链表还是单向链表？"></a><strong>3. LinkedList 是双向链表还是单向链表？</strong></h2><ul>
<li><p><strong>Java 中 LinkedList 是双向链表</strong></p>
</li>
<li><p><strong>结构</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>支持快速插入&#x2F;删除（O(1)）</li>
<li>支持从头尾遍历</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>随机访问慢（O(n)）</li>
<li>内存占用大（需要 prev 指针）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-HashSet-底层实现"><a href="#4-HashSet-底层实现" class="headerlink" title="4. HashSet 底层实现"></a><strong>4. HashSet 底层实现</strong></h2><ul>
<li><strong>底层使用 HashMap 实现</strong></li>
<li><strong>原理</strong>：<ul>
<li>每个元素作为 <code>HashMap</code> 的 key</li>
<li>value 使用一个固定的 Object 对象 <code>PRESENT</code></li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>不允许重复</li>
<li>无序存储</li>
</ul>
</li>
<li><strong>性能</strong>：<ul>
<li>插入、删除、查找均 O(1) 平均</li>
</ul>
</li>
<li>面试拓展：HashSet 和 LinkedHashSet 的区别？<ul>
<li>LinkedHashSet 维护了插入顺序</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-TreeSet-和-TreeMap-的底层实现"><a href="#5-TreeSet-和-TreeMap-的底层实现" class="headerlink" title="5. TreeSet 和 TreeMap 的底层实现"></a><strong>5. TreeSet 和 TreeMap 的底层实现</strong></h2><ul>
<li><strong>TreeMap</strong>：基于 <strong>红黑树</strong> 实现</li>
<li><strong>TreeSet</strong>：内部使用 TreeMap 存储元素</li>
<li><strong>特点</strong>：<ul>
<li>自动排序（自然排序或 Comparator）</li>
<li>查找、插入、删除 O(log n)</li>
</ul>
</li>
<li><strong>红黑树特性</strong>：<ul>
<li>自平衡二叉搜索树</li>
<li>插入&#x2F;删除保持平衡，通过旋转和染色操作</li>
</ul>
</li>
</ul>
<hr>
<h2 id="6-PriorityQueue-的底层数据结构"><a href="#6-PriorityQueue-的底层数据结构" class="headerlink" title="6. PriorityQueue 的底层数据结构"></a><strong>6. PriorityQueue 的底层数据结构</strong></h2><ul>
<li><p><strong>基于堆实现</strong>（默认最小堆）</p>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li>插入 O(log n)</li>
<li>取出最小值 O(log n)</li>
</ul>
</li>
<li><p><strong>内部实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] queue; <span class="comment">// 动态数组存储堆</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>应用</strong>：</p>
<ul>
<li>定时任务调度</li>
<li>Dijkstra 算法</li>
</ul>
</li>
<li><p>面试拓展：如何实现最大堆？</p>
<ul>
<li>使用 Comparator 或覆写 compare 方法</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-ConcurrentSkipListMap-的底层原理"><a href="#7-ConcurrentSkipListMap-的底层原理" class="headerlink" title="7. ConcurrentSkipListMap 的底层原理"></a><strong>7. ConcurrentSkipListMap 的底层原理</strong></h2><ul>
<li><strong>基于跳表实现</strong></li>
<li><strong>特点</strong>：<ul>
<li>有序 Map，支持并发操作</li>
<li>读操作无锁（lock-free），写操作使用 CAS&#x2F;锁粒度较小</li>
</ul>
</li>
<li><strong>跳表原理</strong>：<ul>
<li>多层链表</li>
<li>顶层链表间隔大</li>
<li>查找、插入、删除 O(log n) 平均</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8-CopyOnWriteArrayList-的写时复制"><a href="#8-CopyOnWriteArrayList-的写时复制" class="headerlink" title="8. CopyOnWriteArrayList 的写时复制"></a><strong>8. CopyOnWriteArrayList 的写时复制</strong></h2><ul>
<li><strong>原理</strong>：<ul>
<li>每次写操作（add、remove）都会复制一份底层数组</li>
<li>读操作不加锁，直接读取旧数组</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>高度并发读性能</li>
<li>避免 ConcurrentModificationException</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>写操作成本高（数组复制）</li>
<li>内存开销大</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>读多写少（如监听器列表、配置缓存）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="9-EnumMap-和-EnumSet"><a href="#9-EnumMap-和-EnumSet" class="headerlink" title="9. EnumMap 和 EnumSet"></a><strong>9. EnumMap 和 EnumSet</strong></h2><ul>
<li><strong>EnumMap</strong>：<ul>
<li>Key 是枚举类型</li>
<li>底层使用数组存储，效率高</li>
</ul>
</li>
<li><strong>EnumSet</strong>：<ul>
<li>元素为枚举</li>
<li>底层使用 <strong>位向量(bit vector)</strong> 存储</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>高效，占用内存小</li>
<li>遍历速度快</li>
</ul>
</li>
<li><strong>应用</strong>：<ul>
<li>状态机、标志位集合</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10-WeakHashMap-和-HashMap-的区别"><a href="#10-WeakHashMap-和-HashMap-的区别" class="headerlink" title="10. WeakHashMap 和 HashMap 的区别"></a><strong>10. WeakHashMap 和 HashMap 的区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>HashMap</th>
<th>WeakHashMap</th>
</tr>
</thead>
<tbody><tr>
<td>Key 引用类型</td>
<td>强引用</td>
<td>弱引用</td>
</tr>
<tr>
<td>GC 行为</td>
<td>不受垃圾回收影响</td>
<td>Key 被回收时自动删除 Entry</td>
</tr>
<tr>
<td>用途</td>
<td>普通 Map</td>
<td>缓存、内存敏感对象的映射</td>
</tr>
<tr>
<td>面试点</td>
<td>WeakHashMap 如何防止内存泄漏？</td>
<td></td>
</tr>
</tbody></table>
<p><strong>原理</strong>：</p>
<ul>
<li>WeakHashMap 的 key 是 <code>WeakReference</code></li>
<li>当 key 不再被外部强引用时，垃圾回收器回收，并通过 ReferenceQueue 清理 Entry</li>
</ul>
<hr>
<h3 id="四、异常-错误处理"><a href="#四、异常-错误处理" class="headerlink" title="四、异常 &amp; 错误处理"></a>四、异常 &amp; 错误处理</h3><hr>
<h2 id="1-Java-中的异常分为哪两大类？"><a href="#1-Java-中的异常分为哪两大类？" class="headerlink" title="1. Java 中的异常分为哪两大类？"></a><strong>1. Java 中的异常分为哪两大类？</strong></h2><ul>
<li><strong>Error（错误）</strong>：<ul>
<li>系统级错误，通常无法恢复</li>
<li>例子：<code>OutOfMemoryError</code>、<code>StackOverflowError</code></li>
<li>不建议捕获</li>
</ul>
</li>
<li><strong>Exception（异常）</strong>：<ul>
<li>程序可以捕获、处理</li>
<li>子类：<ol>
<li><strong>受检异常（CheckedException）</strong>：必须 try&#x2F;catch 或 throws 抛出<ul>
<li>例子：<code>IOException</code>、<code>SQLException</code></li>
</ul>
</li>
<li><strong>非受检异常（UncheckedException &#x2F; RuntimeException）</strong>：可选择捕获<ul>
<li>例子：<code>NullPointerException</code>、<code>IllegalArgumentException</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>面试点</strong>：</p>
<ul>
<li>Checked vs Unchecked 异常的设计初衷：<ul>
<li>Checked 异常强制处理，提高程序健壮性</li>
<li>RuntimeException 用于编程错误，不必强制捕获</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-Error-和-Exception-的区别"><a href="#2-Error-和-Exception-的区别" class="headerlink" title="2. Error 和 Exception 的区别"></a><strong>2. Error 和 Exception 的区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>Error</th>
<th>Exception</th>
</tr>
</thead>
<tbody><tr>
<td>是否可恢复</td>
<td>不可恢复</td>
<td>可恢复（程序可处理）</td>
</tr>
<tr>
<td>捕获建议</td>
<td>不建议捕获</td>
<td>建议捕获和处理</td>
</tr>
<tr>
<td>子类示例</td>
<td>OutOfMemoryError</td>
<td>IOException, SQLException</td>
</tr>
<tr>
<td>使用场景</td>
<td>JVM 内部错误</td>
<td>应用程序异常处理</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-受检异常和非受检异常区别"><a href="#3-受检异常和非受检异常区别" class="headerlink" title="3. 受检异常和非受检异常区别"></a><strong>3. 受检异常和非受检异常区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>CheckedException</th>
<th>UncheckedException</th>
</tr>
</thead>
<tbody><tr>
<td>编译器检查</td>
<td>编译器强制要求处理</td>
<td>编译器不要求</td>
</tr>
<tr>
<td>继承关系</td>
<td>Exception 除 RuntimeException</td>
<td>RuntimeException 子类</td>
</tr>
<tr>
<td>使用场景</td>
<td>可恢复异常，如文件不存在</td>
<td>编程错误，如空指针</td>
</tr>
</tbody></table>
<p><strong>面试点</strong>：</p>
<ul>
<li>Checked 异常在 API 设计中可提示调用者</li>
<li>RuntimeException 多用于程序逻辑错误，防止过多 try&#x2F;catch</li>
</ul>
<hr>
<h2 id="4-throw-和-throws-的区别"><a href="#4-throw-和-throws-的区别" class="headerlink" title="4. throw 和 throws 的区别"></a><strong>4. throw 和 throws 的区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>throw</th>
<th>throws</th>
</tr>
</thead>
<tbody><tr>
<td>位置</td>
<td>方法体内</td>
<td>方法声明上</td>
</tr>
<tr>
<td>用途</td>
<td>抛出具体异常实例</td>
<td>声明方法可能抛出的异常类型</td>
</tr>
<tr>
<td>个数限制</td>
<td>一次抛出一个</td>
<td>可声明多个异常</td>
</tr>
<tr>
<td>面试示例</td>
<td><code>throw new IOException()</code></td>
<td><code>void read() throws IOException</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="5-try-with-resources-的底层原理"><a href="#5-try-with-resources-的底层原理" class="headerlink" title="5. try-with-resources 的底层原理"></a><strong>5. try-with-resources 的底层原理</strong></h2><ul>
<li><p><strong>语法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>底层实现</strong>：</p>
<ul>
<li><p>自动调用资源的 <code>close()</code> 方法</p>
</li>
<li><p>资源必须实现 <strong>AutoCloseable</strong> 接口</p>
</li>
<li><p>编译器将其转换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="literal">null</span>) br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>优势</strong>：</p>
<ul>
<li>自动关闭资源，避免资源泄漏</li>
<li>支持多个资源声明</li>
</ul>
</li>
<li><p><strong>面试拓展</strong>：多资源关闭的异常抑制机制 (<code>addSuppressed</code>)</p>
</li>
</ul>
<hr>
<h2 id="6-自定义异常如何设计？继承哪个类"><a href="#6-自定义异常如何设计？继承哪个类" class="headerlink" title="6. 自定义异常如何设计？继承哪个类"></a><strong>6. 自定义异常如何设计？继承哪个类</strong></h2><ul>
<li><p><strong>继承 RuntimeException</strong>：</p>
<ul>
<li>用于非受检异常（编程错误、业务逻辑异常）</li>
</ul>
</li>
<li><p><strong>继承 Exception</strong>：</p>
<ul>
<li>用于受检异常（需要调用者处理）</li>
</ul>
</li>
<li><p><strong>实现建议</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBusinessException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBusinessException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>面试点</strong>：</p>
<ul>
<li>自定义异常加上异常链（cause）</li>
<li>规范异常信息，便于日志追踪</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-为什么不建议捕获-Throwable？"><a href="#7-为什么不建议捕获-Throwable？" class="headerlink" title="7. 为什么不建议捕获 Throwable？"></a><strong>7. 为什么不建议捕获 Throwable？</strong></h2><ul>
<li>Throwable 包含 Error 和 Exception</li>
<li>捕获 Throwable 会：<ul>
<li>捕获系统级错误（OutOfMemoryError）</li>
<li>破坏 JVM 正常工作</li>
</ul>
</li>
<li><strong>最佳实践</strong>：<ul>
<li>只捕获可恢复的 Exception 或 RuntimeException</li>
<li>捕获 Throwable 仅用于日志收集或监控</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8-异常链（Exception-Chaining）是什么"><a href="#8-异常链（Exception-Chaining）是什么" class="headerlink" title="8. 异常链（Exception Chaining）是什么"></a><strong>8. 异常链（Exception Chaining）是什么</strong></h2><ul>
<li><p><strong>概念</strong>：</p>
<ul>
<li>在捕获一个异常时，将原异常封装在新异常中抛出</li>
</ul>
</li>
<li><p><strong>实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;读取文件失败&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优势</strong>：</p>
<ul>
<li>保留原始异常信息</li>
<li>便于调试和日志追踪</li>
</ul>
</li>
</ul>
<hr>
<h2 id="9-Java-8-之后对异常处理的改进"><a href="#9-Java-8-之后对异常处理的改进" class="headerlink" title="9. Java 8 之后对异常处理的改进"></a><strong>9. Java 8 之后对异常处理的改进</strong></h2><ul>
<li><p><strong>Lambda 表达式</strong>：</p>
<ul>
<li>对受检异常的处理更加简洁，但需要特殊处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(item -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; process(item); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(IOException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Optional &amp; Streams</strong>：</p>
<ul>
<li>避免空指针异常</li>
<li>可以在 <code>map</code>&#x2F;<code>filter</code> 中处理异常</li>
</ul>
</li>
<li><p><strong>面试拓展</strong>：</p>
<ul>
<li>异常在并行 Stream 中如何传递</li>
<li><code>CompletableFuture</code> 异常处理</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10-多线程环境下如何正确传递异常"><a href="#10-多线程环境下如何正确传递异常" class="headerlink" title="10. 多线程环境下如何正确传递异常"></a><strong>10. 多线程环境下如何正确传递异常</strong></h2><ul>
<li><p><strong>问题</strong>：</p>
<ul>
<li>子线程异常不会直接抛给主线程</li>
</ul>
</li>
<li><p><strong>解决方案</strong>：</p>
<ol>
<li><p><strong>Future &#x2F; Callable</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executor.submit(() -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error&quot;</span>); &#125;);</span><br><span class="line">future.get(); <span class="comment">// 会抛 ExecutionException</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Thread.UncaughtExceptionHandler</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setUncaughtExceptionHandler((t, e) -&gt; log.error(<span class="string">&quot;线程异常&quot;</span>, e));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CompletableFuture.exceptionally</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(); &#125;)</span><br><span class="line">                 .exceptionally(ex -&gt; &#123; log.error(ex); <span class="keyword">return</span> <span class="literal">null</span>; &#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>面试拓展</strong>：</p>
<ul>
<li>如何处理线程池中未捕获异常</li>
<li>异步任务异常链追踪</li>
</ul>
</li>
</ul>
<hr>
<h3 id="五、JVM-内存管理"><a href="#五、JVM-内存管理" class="headerlink" title="五、JVM &amp; 内存管理"></a>五、JVM &amp; 内存管理</h3><hr>
<h2 id="1-Java-内存模型（JMM）是什么？"><a href="#1-Java-内存模型（JMM）是什么？" class="headerlink" title="1. Java 内存模型（JMM）是什么？"></a><strong>1. Java 内存模型（JMM）是什么？</strong></h2><ul>
<li><strong>定义</strong>：<ul>
<li>Java 内存模型（Java Memory Model，JMM）是 Java 虚拟机规范中定义的一套规范，用于描述 <strong>Java 程序中各个线程如何访问共享内存以及如何保证可见性、原子性、有序性</strong>。</li>
</ul>
</li>
<li><strong>核心作用</strong>：<ol>
<li><strong>解决多线程可见性问题</strong></li>
<li><strong>规定内存操作顺序</strong>（happens-before 原则）</li>
<li><strong>定义变量访问原子性</strong></li>
</ol>
</li>
<li><strong>关键概念</strong>：<ul>
<li><strong>主内存（Main Memory）</strong>：共享变量存储位置</li>
<li><strong>工作内存（Working Memory &#x2F; Thread Local Cache）</strong>：线程私有缓存</li>
<li><strong>volatile、synchronized、final</strong> 的语义保证不同层次的可见性和原子性</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-JVM-内存分为哪几个区域？每个区域的作用是什么？"><a href="#2-JVM-内存分为哪几个区域？每个区域的作用是什么？" class="headerlink" title="2. JVM 内存分为哪几个区域？每个区域的作用是什么？"></a><strong>2. JVM 内存分为哪几个区域？每个区域的作用是什么？</strong></h2><ol>
<li><strong>程序计数器（PC Register）</strong><ul>
<li>每个线程私有</li>
<li>保存当前线程执行的字节码指令地址</li>
<li>支持线程切换和方法调用返回</li>
</ul>
</li>
<li><strong>虚拟机栈（Stack）</strong><ul>
<li>每个线程私有</li>
<li>存储局部变量、操作栈、动态链接信息、方法出口</li>
<li>栈帧：方法执行的最小单位</li>
<li>异常：StackOverflowError</li>
</ul>
</li>
<li><strong>本地方法栈（Native Method Stack）</strong><ul>
<li>JVM 调用本地方法（C&#x2F;C++实现）使用</li>
<li>HotSpot 通常与虚拟机栈合并</li>
</ul>
</li>
<li><strong>堆（Heap）</strong><ul>
<li>所有线程共享</li>
<li>存储对象实例及数组</li>
<li>垃圾收集的主要区域</li>
<li>子区域：<ul>
<li><strong>年轻代（Young Generation）</strong>：Eden + Survivor0 + Survivor1</li>
<li><strong>老年代（Old Generation）</strong></li>
<li><strong>元空间（Metaspace &#x2F; 方法区）</strong>：存放类元信息</li>
</ul>
</li>
</ul>
</li>
<li><strong>方法区（Metaspace &#x2F; 以前称为 PermGen）</strong><ul>
<li>存储类信息、常量池、静态变量</li>
<li>Metaspace 从本地内存分配（不再受 JVM 堆大小限制）</li>
</ul>
</li>
<li><strong>运行时常量池</strong><ul>
<li>类加载时生成</li>
<li>存放字面量、符号引用、字符串常量等</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-为什么-String-常量池要放在堆里而不是方法区？"><a href="#3-为什么-String-常量池要放在堆里而不是方法区？" class="headerlink" title="3. 为什么 String 常量池要放在堆里而不是方法区？"></a><strong>3. 为什么 String 常量池要放在堆里而不是方法区？</strong></h2><ul>
<li><strong>历史原因</strong>：<ul>
<li>JDK 1.6 及以前：字符串常量池在永久代（PermGen），易导致 OOM</li>
</ul>
</li>
<li><strong>现代实现</strong>：<ul>
<li>JDK 7+ 将常量池移到堆</li>
</ul>
</li>
<li><strong>优势</strong>：<ol>
<li>垃圾回收可管理</li>
<li>内存分配灵活，避免方法区溢出</li>
<li>多线程访问安全性提升（与堆对象 GC 同步）</li>
</ol>
</li>
</ul>
<hr>
<h2 id="4-什么是垃圾回收（GC）的可达性分析算法？"><a href="#4-什么是垃圾回收（GC）的可达性分析算法？" class="headerlink" title="4. 什么是垃圾回收（GC）的可达性分析算法？"></a><strong>4. 什么是垃圾回收（GC）的可达性分析算法？</strong></h2><ul>
<li><p><strong>可达性分析（Reachability Analysis）</strong>：</p>
<ul>
<li>从 <strong>GC Roots</strong> 开始，通过引用链判断对象是否可达</li>
<li><strong>不可达对象</strong>即为垃圾，可以回收</li>
</ul>
</li>
<li><p><strong>示意</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GC Roots</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">Object A --&gt; Object B</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 Object B 无法通过 GC Roots 访问，则被回收</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-哪些对象可以作为-GC-Roots？"><a href="#5-哪些对象可以作为-GC-Roots？" class="headerlink" title="5. 哪些对象可以作为 GC Roots？"></a><strong>5. 哪些对象可以作为 GC Roots？</strong></h2><p>常见 GC Roots：</p>
<ol>
<li><strong>虚拟机栈中的引用</strong>（局部变量、方法参数）</li>
<li><strong>静态变量</strong>（类静态成员）</li>
<li><strong>常量引用</strong>（常量池引用）</li>
<li><strong>JNI 引用</strong>（本地方法栈中的引用）</li>
</ol>
<hr>
<h2 id="6-强引用、软引用、弱引用、虚引用的区别"><a href="#6-强引用、软引用、弱引用、虚引用的区别" class="headerlink" title="6. 强引用、软引用、弱引用、虚引用的区别"></a><strong>6. 强引用、软引用、弱引用、虚引用的区别</strong></h2><table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>GC 行为</th>
<th>面试应用</th>
</tr>
</thead>
<tbody><tr>
<td>强引用（Strong Reference）</td>
<td>普通对象引用</td>
<td>不可回收</td>
<td>普通对象</td>
</tr>
<tr>
<td>软引用（Soft Reference）</td>
<td>通过 SoftReference 引用</td>
<td>内存不足时回收</td>
<td>缓存（Memory-sensitive cache）</td>
</tr>
<tr>
<td>弱引用（Weak Reference）</td>
<td>WeakReference 引用</td>
<td>GC 时立即回收</td>
<td>ThreadLocal 清理、缓存</td>
</tr>
<tr>
<td>虚引用（Phantom Reference）</td>
<td>PhantomReference 引用</td>
<td>仅做引用队列通知</td>
<td>对象回收前做清理、资源释放</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-GC-算法"><a href="#7-GC-算法" class="headerlink" title="7. GC 算法"></a><strong>7. GC 算法</strong></h2><ol>
<li><strong>标记-清除（Mark-Sweep）</strong><ul>
<li>标记可达对象，清除未标记对象</li>
<li>优点：简单</li>
<li>缺点：产生碎片</li>
</ul>
</li>
<li><strong>标记-整理（Mark-Compact）</strong><ul>
<li>标记可达对象</li>
<li>将存活对象移动到一端</li>
<li>优点：解决碎片问题</li>
<li>缺点：移动对象成本高</li>
</ul>
</li>
<li><strong>复制算法（Copying）</strong><ul>
<li>将内存分为两块</li>
<li>将存活对象复制到另一块，清理旧块</li>
<li>优点：分配快，整理快</li>
<li>缺点：内存利用率低</li>
</ul>
</li>
</ol>
<hr>
<h2 id="8-常见的垃圾收集器"><a href="#8-常见的垃圾收集器" class="headerlink" title="8. 常见的垃圾收集器"></a><strong>8. 常见的垃圾收集器</strong></h2><table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>适用场景</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Serial GC</td>
<td>单核</td>
<td>STW 串行，简单、高吞吐量低</td>
</tr>
<tr>
<td>Parallel GC</td>
<td>多核</td>
<td>并行回收年轻代，高吞吐量</td>
</tr>
<tr>
<td>CMS GC</td>
<td>多核</td>
<td>并发回收老年代，减少 STW</td>
</tr>
<tr>
<td>G1 GC</td>
<td>大堆</td>
<td>分区回收，低延迟，预测停顿</td>
</tr>
<tr>
<td>ZGC</td>
<td>超大堆</td>
<td>并发标记-清理，低延迟</td>
</tr>
<tr>
<td>Shenandoah</td>
<td>大堆</td>
<td>并发标记-整理，减少 STW</td>
</tr>
</tbody></table>
<hr>
<h2 id="9-什么是-Stop-The-World-STW-？"><a href="#9-什么是-Stop-The-World-STW-？" class="headerlink" title="9. 什么是 Stop-The-World (STW)？"></a><strong>9. 什么是 Stop-The-World (STW)？</strong></h2><ul>
<li><strong>定义</strong>：JVM 暂停所有应用线程执行，专门进行 GC</li>
<li><strong>原因</strong>：<ul>
<li>防止对象被修改导致回收错误</li>
</ul>
</li>
<li><strong>面试拓展</strong>：<ul>
<li>G1&#x2F;ZGC&#x2F;Shenandoah 尽量缩短 STW 时间</li>
<li>并发 GC 与 STW 的折中</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10-JVM-调优常见参数"><a href="#10-JVM-调优常见参数" class="headerlink" title="10. JVM 调优常见参数"></a><strong>10. JVM 调优常见参数</strong></h2><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>-Xmx</code></td>
<td>最大堆大小</td>
</tr>
<tr>
<td><code>-Xms</code></td>
<td>初始堆大小</td>
</tr>
<tr>
<td><code>-Xmn</code></td>
<td>年轻代大小</td>
</tr>
<tr>
<td><code>-XX:SurvivorRatio</code></td>
<td>Eden&#x2F;Survivor 比例</td>
</tr>
<tr>
<td><code>-XX:+UseG1GC</code></td>
<td>使用 G1 GC</td>
</tr>
<tr>
<td><code>-XX:MaxGCPauseMillis</code></td>
<td>最大停顿时间</td>
</tr>
<tr>
<td><code>-XX:+PrintGCDetails</code></td>
<td>打印 GC 日志</td>
</tr>
<tr>
<td><code>-XX:+HeapDumpOnOutOfMemoryError</code></td>
<td>OOM 时生成堆转储</td>
</tr>
</tbody></table>
<p><strong>面试拓展</strong>：</p>
<ul>
<li>如何调优老年代和年轻代比例？</li>
<li>GC 日志分析示例：年轻代满、老年代晋升、STW 停顿</li>
</ul>
<hr>
<h3 id="六、并发编程基础"><a href="#六、并发编程基础" class="headerlink" title="六、并发编程基础"></a>六、并发编程基础</h3><hr>
<h2 id="1-Java-中的-volatile-关键字的底层实现原理"><a href="#1-Java-中的-volatile-关键字的底层实现原理" class="headerlink" title="1. Java 中的 volatile 关键字的底层实现原理"></a><strong>1. Java 中的 volatile 关键字的底层实现原理</strong></h2><ul>
<li><strong>作用</strong>：<ol>
<li><strong>保证可见性</strong>：一个线程修改变量后，其他线程立即可见</li>
<li><strong>禁止指令重排</strong>：保证顺序性</li>
</ol>
</li>
<li><strong>原理</strong>：<ul>
<li>底层通过 <strong>内存屏障（Memory Barrier &#x2F; Fence）</strong> 实现</li>
<li><code>volatile</code> 读操作：<ul>
<li>加载屏障（LoadLoad + LoadStore）</li>
</ul>
</li>
<li><code>volatile</code> 写操作：<ul>
<li>写屏障（StoreStore + StoreLoad）</li>
</ul>
</li>
</ul>
</li>
<li><strong>注意</strong>：<ul>
<li>不能保证 <strong>原子性</strong></li>
<li>适合 <strong>状态标识、开关变量</strong></li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-synchronized-的实现原理"><a href="#2-synchronized-的实现原理" class="headerlink" title="2. synchronized 的实现原理"></a><strong>2. synchronized 的实现原理</strong></h2><ul>
<li><strong>作用</strong>：<ul>
<li>保证 <strong>互斥访问</strong></li>
<li>保证 <strong>可见性</strong></li>
</ul>
</li>
<li><strong>底层机制</strong>：<ul>
<li>Java 对象头包含 <strong>Mark Word</strong></li>
<li>每个对象可以关联一个 <strong>Monitor</strong></li>
<li><strong>Monitor</strong> 用于管理线程的加锁、阻塞、唤醒</li>
</ul>
</li>
<li><strong>锁升级流程</strong>：<ol>
<li><strong>偏向锁</strong>（默认轻量级线程无竞争）</li>
<li><strong>轻量级锁</strong>（CAS 竞争，膨胀前）</li>
<li><strong>重量级锁</strong>（锁膨胀，阻塞其他线程）</li>
</ol>
</li>
</ul>
<hr>
<h2 id="3-偏向锁、轻量级锁、重量级锁"><a href="#3-偏向锁、轻量级锁、重量级锁" class="headerlink" title="3. 偏向锁、轻量级锁、重量级锁"></a><strong>3. 偏向锁、轻量级锁、重量级锁</strong></h2><table>
<thead>
<tr>
<th>锁类型</th>
<th>适用场景</th>
<th>实现方式</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>单线程</td>
<td>在对象头标记线程 ID</td>
<td>减少无竞争开销</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>多线程竞争轻量</td>
<td>CAS 自旋 + 栈记录锁</td>
<td>高效，避免阻塞</td>
</tr>
<tr>
<td>重量级锁</td>
<td>多线程竞争严重</td>
<td>Monitor + 阻塞</td>
<td>开销大，可能 STW</td>
</tr>
</tbody></table>
<p><strong>面试拓展</strong>：</p>
<ul>
<li>如何通过 <code>-XX:+PrintFlagsFinal</code> 查看锁标志位</li>
<li>偏向锁默认延迟 4 秒启用</li>
</ul>
<hr>
<h2 id="4-什么是-CAS-操作？ABA-问题如何解决？"><a href="#4-什么是-CAS-操作？ABA-问题如何解决？" class="headerlink" title="4. 什么是 CAS 操作？ABA 问题如何解决？"></a><strong>4. 什么是 CAS 操作？ABA 问题如何解决？</strong></h2><ul>
<li><p><strong>CAS（Compare-And-Swap）</strong>：</p>
<ul>
<li>原子操作</li>
<li>比较内存值是否为预期值，如果是就更新</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAS(V, A, B)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ABA 问题</strong>：</p>
<ul>
<li>值先从 A 改成 B，又改回 A</li>
<li>CAS 无法检测变化，可能出错</li>
</ul>
</li>
<li><p><strong>解决方案</strong>：</p>
<ol>
<li><strong>版本号机制</strong>（AtomicStampedReference）</li>
<li><strong>加锁</strong></li>
</ol>
</li>
</ul>
<hr>
<h2 id="5-什么是线程安全？举例线程安全类"><a href="#5-什么是线程安全？举例线程安全类" class="headerlink" title="5. 什么是线程安全？举例线程安全类"></a><strong>5. 什么是线程安全？举例线程安全类</strong></h2><ul>
<li><strong>定义</strong>：多个线程访问同一个对象时，不会破坏对象的状态，并保证正确性</li>
<li><strong>线程安全类示例</strong>：<ul>
<li>集合类：<code>Vector</code>, <code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code></li>
<li>原子类：<code>AtomicInteger</code>, <code>AtomicReference</code></li>
<li>工具类：<code>ThreadLocal</code>, <code>BlockingQueue</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="6-ThreadLocal-的底层原理与内存泄漏问题"><a href="#6-ThreadLocal-的底层原理与内存泄漏问题" class="headerlink" title="6. ThreadLocal 的底层原理与内存泄漏问题"></a><strong>6. ThreadLocal 的底层原理与内存泄漏问题</strong></h2><ul>
<li><strong>原理</strong>：<ul>
<li>每个线程维护一个 <code>ThreadLocalMap</code></li>
<li>key 是 <strong>ThreadLocal 对象</strong></li>
<li>value 是对应的值</li>
</ul>
</li>
<li><strong>内存泄漏原因</strong>：<ul>
<li>ThreadLocalMap 的 key 是 <strong>弱引用</strong></li>
<li>如果 ThreadLocal 对象被回收，但线程仍存活，value 仍然存在</li>
</ul>
</li>
<li><strong>解决方法</strong>：<ul>
<li>使用 <code>remove()</code> 方法</li>
<li>避免长生命周期线程存储大量 ThreadLocal</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-线程池的核心参数"><a href="#7-线程池的核心参数" class="headerlink" title="7. 线程池的核心参数"></a><strong>7. 线程池的核心参数</strong></h2><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>核心线程数，常驻线程</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>非核心线程空闲存活时间</td>
</tr>
<tr>
<td>workQueue</td>
<td>等待队列，用于存放任务</td>
</tr>
<tr>
<td>threadFactory</td>
<td>线程创建工厂</td>
</tr>
<tr>
<td>RejectedExecutionHandler</td>
<td>拒绝策略</td>
</tr>
</tbody></table>
<hr>
<h2 id="8-什么是拒绝策略"><a href="#8-什么是拒绝策略" class="headerlink" title="8. 什么是拒绝策略"></a><strong>8. 什么是拒绝策略</strong></h2><ul>
<li><strong>触发场景</strong>：线程池满了，队列满了</li>
<li><strong>常见策略</strong>：<ol>
<li><strong>AbortPolicy</strong>：抛异常，默认</li>
<li><strong>CallerRunsPolicy</strong>：由调用线程执行任务</li>
<li><strong>DiscardPolicy</strong>：直接丢弃任务</li>
<li><strong>DiscardOldestPolicy</strong>：丢弃队列中最旧任务</li>
</ol>
</li>
</ul>
<hr>
<h2 id="9-Executors-提供的常见线程池"><a href="#9-Executors-提供的常见线程池" class="headerlink" title="9. Executors 提供的常见线程池"></a><strong>9. Executors 提供的常见线程池</strong></h2><table>
<thead>
<tr>
<th>线程池类型</th>
<th>特点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>FixedThreadPool</td>
<td>固定线程数</td>
<td>CPU密集型任务</td>
</tr>
<tr>
<td>CachedThreadPool</td>
<td>可扩容线程池</td>
<td>短生命周期任务</td>
</tr>
<tr>
<td>SingleThreadExecutor</td>
<td>单线程顺序执行</td>
<td>顺序任务</td>
</tr>
<tr>
<td>ScheduledThreadPool</td>
<td>支持定时&#x2F;周期执行</td>
<td>定时任务</td>
</tr>
</tbody></table>
<p><strong>面试拓展</strong>：</p>
<ul>
<li>Executors.newFixedThreadPool 会使用 <strong>LinkedBlockingQueue</strong></li>
<li>CachedThreadPool 使用 <strong>SynchronousQueue</strong>，任务直接交给线程</li>
</ul>
<hr>
<h2 id="10-Future-和-CompletableFuture-区别"><a href="#10-Future-和-CompletableFuture-区别" class="headerlink" title="10. Future 和 CompletableFuture 区别"></a><strong>10. Future 和 CompletableFuture 区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>Future</th>
<th>CompletableFuture</th>
</tr>
</thead>
<tbody><tr>
<td>异步</td>
<td>提交任务后可阻塞获取结果</td>
<td>可链式异步操作</td>
</tr>
<tr>
<td>API</td>
<td>get() 阻塞</td>
<td>thenApply, thenAccept 等链式</td>
</tr>
<tr>
<td>异常处理</td>
<td>阻塞式，捕获 ExecutionException</td>
<td>支持 exceptionally&#x2F;handle</td>
</tr>
<tr>
<td>组合任务</td>
<td>组合困难</td>
<td>支持 allOf &#x2F; anyOf &#x2F; thenCombine</td>
</tr>
</tbody></table>
<p><strong>面试点</strong>：</p>
<ul>
<li>CompletableFuture 适合多异步任务组合</li>
<li>FutureTask 可作为 Future 的实现类</li>
</ul>
<hr>
<h3 id="七、编译-运行时"><a href="#七、编译-运行时" class="headerlink" title="七、编译 &amp; 运行时"></a>七、编译 &amp; 运行时</h3><hr>
<h2 id="1-Java-的反射机制是什么？底层原理？"><a href="#1-Java-的反射机制是什么？底层原理？" class="headerlink" title="1. Java 的反射机制是什么？底层原理？"></a><strong>1. Java 的反射机制是什么？底层原理？</strong></h2><ul>
<li><p><strong>概念</strong>：</p>
<ul>
<li>反射机制允许在运行时 <strong>获取类的信息、实例化对象、访问字段和方法</strong>，而不需要在编译期知道具体类型</li>
</ul>
</li>
<li><p><strong>常用 API</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.User&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line">method.invoke(obj, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>底层原理</strong>：</p>
<ul>
<li>JVM 中类对象 <code>Class</code> 对应内存中的元数据（方法表、字段表、常量池）</li>
<li>通过 <strong>Native 方法</strong> 调用，访问类的元数据和对象实例</li>
</ul>
</li>
<li><p><strong>面试拓展</strong>：</p>
<ul>
<li>反射可访问私有字段&#x2F;方法（<code>setAccessible(true)</code>）</li>
<li>反射适用于框架（Spring、MyBatis）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-为什么反射性能差？JDK-9-之后如何优化？"><a href="#2-为什么反射性能差？JDK-9-之后如何优化？" class="headerlink" title="2. 为什么反射性能差？JDK 9 之后如何优化？"></a><strong>2. 为什么反射性能差？JDK 9 之后如何优化？</strong></h2><ul>
<li><strong>性能差原因</strong>：<ol>
<li>每次访问方法&#x2F;字段都要进行动态解析</li>
<li>JVM 无法做内联优化（方法调用不是静态绑定）</li>
<li>需要检查权限、类型转换</li>
</ol>
</li>
<li><strong>优化措施</strong>：<ul>
<li><strong>JDK 7 及以后</strong>：<code>MethodHandle</code> 和 <code>invokeDynamic</code></li>
<li><strong>JDK 9+</strong>：增强模块化（模块边界检查优化）</li>
<li><strong>热点编译器 JIT</strong> 可以对反射调用做内联</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-什么是动态代理？JDK-动态代理和-CGLIB-区别？"><a href="#3-什么是动态代理？JDK-动态代理和-CGLIB-区别？" class="headerlink" title="3. 什么是动态代理？JDK 动态代理和 CGLIB 区别？"></a><strong>3. 什么是动态代理？JDK 动态代理和 CGLIB 区别？</strong></h2><ul>
<li><p><strong>动态代理</strong>：</p>
<ul>
<li>在运行时生成代理对象，拦截方法调用，增强行为</li>
</ul>
</li>
<li><p><strong>JDK 动态代理</strong>：</p>
<ul>
<li>基于接口</li>
<li>使用 <code>Proxy.newProxyInstance</code></li>
<li>通过 <code>InvocationHandler.invoke</code> 调用</li>
</ul>
</li>
<li><p><strong>CGLIB</strong>：</p>
<ul>
<li>基于子类继承（无接口也可代理）</li>
<li>使用 ASM 字节码生成子类</li>
<li>注意 final 类&#x2F;方法不能被代理</li>
</ul>
</li>
<li><p><strong>对比</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>JDK 动态代理</th>
<th>CGLIB</th>
</tr>
</thead>
<tbody><tr>
<td>是否需要接口</td>
<td>必须</td>
<td>不需要</td>
</tr>
<tr>
<td>原理</td>
<td>Proxy + InvocationHandler</td>
<td>ASM 字节码生成子类</td>
</tr>
<tr>
<td>性能</td>
<td>略慢</td>
<td>较快</td>
</tr>
<tr>
<td>局限性</td>
<td>无</td>
<td>final 类&#x2F;方法不可代理</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h2 id="4-注解的底层原理是什么？运行时注解如何实现？"><a href="#4-注解的底层原理是什么？运行时注解如何实现？" class="headerlink" title="4. 注解的底层原理是什么？运行时注解如何实现？"></a><strong>4. 注解的底层原理是什么？运行时注解如何实现？</strong></h2><ul>
<li><strong>概念</strong>：<ul>
<li>注解是一种 <strong>元数据</strong>，用于给类、方法、字段等提供信息</li>
</ul>
</li>
<li><strong>底层原理</strong>：<ul>
<li>编译时生成 <code>.class</code> 文件中 <code>RuntimeVisibleAnnotations</code> 属性</li>
<li>JVM 通过 <code>java.lang.reflect.AnnotatedElement</code> 获取</li>
</ul>
</li>
<li><strong>运行时注解</strong>：<ul>
<li><code>@Retention(RetentionPolicy.RUNTIME)</code></li>
<li>通过反射 API 读取注解并执行逻辑</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>Spring 注解（<code>@Autowired</code>、<code>@Service</code>）</li>
<li>JPA 注解（<code>@Entity</code>、<code>@Column</code>）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-ClassLoader-的双亲委派模型是什么？"><a href="#5-ClassLoader-的双亲委派模型是什么？" class="headerlink" title="5. ClassLoader 的双亲委派模型是什么？"></a><strong>5. ClassLoader 的双亲委派模型是什么？</strong></h2><ul>
<li><p><strong>原理</strong>：</p>
<ul>
<li>当类加载请求到来时，<strong>先委托父 ClassLoader 加载</strong></li>
<li>如果父 ClassLoader 加载失败，再由子 ClassLoader 加载</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ol>
<li>避免重复加载</li>
<li>保证核心类（如 <code>java.lang.*</code>）唯一性</li>
</ol>
</li>
<li><p><strong>示意</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap -&gt; Extension -&gt; App -&gt; Custom</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>面试拓展</strong>：</p>
<ul>
<li>双亲委派模型是保证 JVM 核心类安全的重要机制</li>
</ul>
</li>
</ul>
<hr>
<h2 id="6-如何打破双亲委派？"><a href="#6-如何打破双亲委派？" class="headerlink" title="6. 如何打破双亲委派？"></a><strong>6. 如何打破双亲委派？</strong></h2><ul>
<li>自定义 ClassLoader</li>
<li>在 <code>loadClass</code> 中先加载自己定义的类，再委派父类（逆向委派）</li>
<li>注意：破坏双亲委派可能引发类冲突、内存泄漏</li>
</ul>
<hr>
<h2 id="7-什么是-SPI（Service-Provider-Interface）机制？"><a href="#7-什么是-SPI（Service-Provider-Interface）机制？" class="headerlink" title="7. 什么是 SPI（Service Provider Interface）机制？"></a><strong>7. 什么是 SPI（Service Provider Interface）机制？</strong></h2><ul>
<li><strong>概念</strong>：<ul>
<li>Java 提供的一种服务发现机制</li>
<li>通过接口 + 配置文件，动态加载实现类</li>
</ul>
</li>
<li><strong>实现</strong>：<ol>
<li>接口 <code>MyService</code></li>
<li>文件 <code>META-INF/services/com.example.MyService</code><ul>
<li>内容：实现类全限定名</li>
</ul>
</li>
<li><code>ServiceLoader.load(MyService.class)</code> 自动加载实现类</li>
</ol>
</li>
<li><strong>应用</strong>：<ul>
<li>JDBC 驱动加载</li>
<li>Logging 框架（SLF4J）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8-Java-是如何实现跨平台的？"><a href="#8-Java-是如何实现跨平台的？" class="headerlink" title="8. Java 是如何实现跨平台的？"></a><strong>8. Java 是如何实现跨平台的？</strong></h2><ul>
<li><strong>原理</strong>：<ol>
<li>Java 代码 -&gt; 编译成 <strong>字节码（.class）</strong></li>
<li>JVM 负责字节码解释或即时编译（JIT）执行</li>
<li>JVM 将字节码映射到不同操作系统和 CPU</li>
</ol>
</li>
<li><strong>面试拓展</strong>：<ul>
<li>字节码验证机制确保安全性</li>
<li>HotSpot JIT 提供本地优化</li>
</ul>
</li>
</ul>
<hr>
<h2 id="9-JIT（即时编译器）优化了哪些东西？"><a href="#9-JIT（即时编译器）优化了哪些东西？" class="headerlink" title="9. JIT（即时编译器）优化了哪些东西？"></a><strong>9. JIT（即时编译器）优化了哪些东西？</strong></h2><ul>
<li><strong>JIT（Just-In-Time Compiler）</strong>：<ul>
<li>将热点字节码动态编译成本地机器码</li>
</ul>
</li>
<li><strong>优化策略</strong>：<ol>
<li><strong>方法内联</strong>：减少方法调用开销</li>
<li><strong>循环优化</strong>：消除冗余计算</li>
<li><strong>逃逸分析</strong>：栈上分配对象</li>
<li><strong>锁消除&#x2F;锁粗化</strong>：减少锁开销</li>
<li><strong>指令重排序优化</strong></li>
</ol>
</li>
</ul>
<hr>
<h2 id="10-什么是逃逸分析？"><a href="#10-什么是逃逸分析？" class="headerlink" title="10. 什么是逃逸分析？"></a><strong>10. 什么是逃逸分析？</strong></h2><ul>
<li><strong>概念</strong>：<ul>
<li>分析对象的引用范围</li>
<li>判断对象是否“逃逸”出方法或线程</li>
</ul>
</li>
<li><strong>优化应用</strong>：<ol>
<li><strong>栈上分配</strong>：对象不逃逸可以直接分配在栈上</li>
<li><strong>标量替换</strong>：将对象拆解为基本类型，提高缓存命中</li>
<li><strong>锁消除</strong>：对象不逃逸，synchronized 可被消除</li>
</ol>
</li>
<li><strong>面试拓展</strong>：<ul>
<li>JIT 结合逃逸分析可显著提升性能</li>
<li>适用于短生命周期对象</li>
</ul>
</li>
</ul>
<hr>
<h3 id="八、常见场景-设计"><a href="#八、常见场景-设计" class="headerlink" title="八、常见场景 &amp; 设计"></a>八、常见场景 &amp; 设计</h3><hr>
<h2 id="1-单例模式在-Java-中有哪些实现方式？哪种最优？"><a href="#1-单例模式在-Java-中有哪些实现方式？哪种最优？" class="headerlink" title="1. 单例模式在 Java 中有哪些实现方式？哪种最优？"></a><strong>1. 单例模式在 Java 中有哪些实现方式？哪种最优？</strong></h2><ul>
<li><p><strong>常见实现方式</strong>：</p>
<ol>
<li><p><strong>饿汉式（静态常量）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：线程安全，简单</li>
<li>缺点：类加载即初始化，不支持延迟加载</li>
</ul>
</li>
<li><p><strong>懒汉式（加锁）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：支持延迟加载</li>
<li>缺点：每次访问都有同步开销</li>
</ul>
</li>
<li><p><strong>双重检查锁（Double-Checked Locking）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：线程安全 + 延迟加载 + 高性能</li>
<li><strong>推荐</strong></li>
</ul>
</li>
<li><p><strong>静态内部类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123; <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> Holder.INSTANCE; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原理：JVM 保证类加载线程安全</li>
<li>优点：懒加载 + 高性能</li>
<li><strong>最佳实践之一</strong></li>
</ul>
</li>
<li><p><strong>枚举单例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123; INSTANCE; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原理：JVM 保证枚举类型单例</li>
<li>优点：线程安全、防止反射和序列化破坏</li>
<li><strong>最佳实践</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-懒汉模式和饿汉模式的区别"><a href="#2-懒汉模式和饿汉模式的区别" class="headerlink" title="2. 懒汉模式和饿汉模式的区别"></a><strong>2. 懒汉模式和饿汉模式的区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>懒汉模式</th>
<th>饿汉模式</th>
</tr>
</thead>
<tbody><tr>
<td>加载时机</td>
<td>延迟加载，第一次使用</td>
<td>类加载即初始化</td>
</tr>
<tr>
<td>线程安全</td>
<td>需加锁&#x2F;双重检查</td>
<td>天然线程安全</td>
</tr>
<tr>
<td>性能</td>
<td>多线程同步有开销</td>
<td>无额外开销</td>
</tr>
<tr>
<td>内存使用</td>
<td>按需分配</td>
<td>类加载时分配</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-枚举单例为什么是最佳实践"><a href="#3-枚举单例为什么是最佳实践" class="headerlink" title="3. 枚举单例为什么是最佳实践"></a><strong>3. 枚举单例为什么是最佳实践</strong></h2><ul>
<li>JVM 保证枚举实例唯一性</li>
<li><strong>防止反射和序列化破坏</strong></li>
<li>实现简洁，无需手动同步</li>
<li>面试常考点：相比双重检查锁更安全</li>
</ul>
<hr>
<h2 id="4-为什么要用工厂模式？"><a href="#4-为什么要用工厂模式？" class="headerlink" title="4. 为什么要用工厂模式？"></a><strong>4. 为什么要用工厂模式？</strong></h2><ul>
<li><strong>作用</strong>：<ul>
<li>隐藏对象创建逻辑</li>
<li>解耦调用方和实现类</li>
</ul>
</li>
<li><strong>类型</strong>：<ol>
<li><strong>简单工厂</strong>：静态方法返回对象</li>
<li><strong>工厂方法</strong>：子类决定创建哪种对象</li>
<li><strong>抽象工厂</strong>：一组相关对象的创建</li>
</ol>
</li>
<li><strong>优势</strong>：<ul>
<li>可扩展性高</li>
<li>符合开闭原则</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-装饰器模式和代理模式区别"><a href="#5-装饰器模式和代理模式区别" class="headerlink" title="5. 装饰器模式和代理模式区别"></a><strong>5. 装饰器模式和代理模式区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>装饰器模式</th>
<th>代理模式</th>
</tr>
</thead>
<tbody><tr>
<td>目的</td>
<td>动态增强对象功能</td>
<td>控制对象访问</td>
</tr>
<tr>
<td>结构</td>
<td>包装原对象，继承接口</td>
<td>持有原对象，方法委托</td>
</tr>
<tr>
<td>场景</td>
<td>IO 流（BufferedReader）</td>
<td>远程调用、权限控制</td>
</tr>
<tr>
<td>动态性</td>
<td>高</td>
<td>可以通过动态代理实现</td>
</tr>
</tbody></table>
<hr>
<h2 id="6-Java-中的事件监听模型是怎么实现的？"><a href="#6-Java-中的事件监听模型是怎么实现的？" class="headerlink" title="6. Java 中的事件监听模型是怎么实现的？"></a><strong>6. Java 中的事件监听模型是怎么实现的？</strong></h2><ul>
<li><strong>机制</strong>：<ol>
<li><strong>事件源（Event Source）</strong>：产生事件</li>
<li><strong>事件监听器（Listener）</strong>：接口，定义回调方法</li>
<li><strong>注册与触发</strong>：源对象维护监听器列表，事件发生时通知监听器</li>
</ol>
</li>
<li><strong>典型应用</strong>：<ul>
<li>Swing&#x2F;AWT 事件</li>
<li>Spring ApplicationEvent</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-为什么-Java-不支持多继承？"><a href="#7-为什么-Java-不支持多继承？" class="headerlink" title="7. 为什么 Java 不支持多继承？"></a><strong>7. 为什么 Java 不支持多继承？</strong></h2><ul>
<li><strong>原因</strong>：<ul>
<li>避免 <strong>钻石问题</strong>（多继承产生方法冲突）</li>
<li>简化对象模型，保证 JVM 类型安全</li>
</ul>
</li>
<li><strong>替代方案</strong>：<ul>
<li>接口多继承 + 默认方法（Java 8+）</li>
<li>组合设计模式（优先使用 has-a 而不是 is-a）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8-如何用-Java-实现回调机制？"><a href="#8-如何用-Java-实现回调机制？" class="headerlink" title="8. 如何用 Java 实现回调机制？"></a><strong>8. 如何用 Java 实现回调机制？</strong></h2><ul>
<li><p><strong>原理</strong>：</p>
<ul>
<li>将函数封装成对象或接口传递给另一个对象</li>
<li>由被调用对象在合适时机调用接口方法</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123; <span class="keyword">void</span> <span class="title function_">onDone</span><span class="params">(String result)</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">asyncProcess</span><span class="params">(Callback callback)</span> &#123; <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; callback.onDone(<span class="string">&quot;ok&quot;</span>)).start(); &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="9-Java-中如何实现观察者模式？"><a href="#9-Java-中如何实现观察者模式？" class="headerlink" title="9. Java 中如何实现观察者模式？"></a><strong>9. Java 中如何实现观察者模式？</strong></h2><ul>
<li><p><strong>机制</strong>：</p>
<ol>
<li><strong>Subject（被观察者）</strong>：维护观察者列表，提供注册&#x2F;注销方法</li>
<li><strong>Observer（观察者）</strong>：接口，定义 update 方法</li>
<li><strong>触发事件</strong>：Subject 状态变化时调用所有 Observer 的 update</li>
</ol>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123; <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String msg)</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer o)</span> &#123; observers.add(o); &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        observers.forEach(o -&gt; o.update(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="10-Optional-的设计初衷是什么？"><a href="#10-Optional-的设计初衷是什么？" class="headerlink" title="10. Optional 的设计初衷是什么？"></a><strong>10. Optional 的设计初衷是什么？</strong></h2><ul>
<li><p><strong>目的</strong>：</p>
<ul>
<li>避免 null 值导致的 <strong>NullPointerException</strong></li>
<li>提供函数式 API，提高可读性</li>
</ul>
</li>
<li><p><strong>使用方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.ofNullable(getValue());</span><br><span class="line">optional.ifPresent(System.out::println);</span><br><span class="line"><span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> optional.orElse(<span class="string">&quot;default&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优势</strong>：</p>
<ul>
<li>显示处理缺失值</li>
<li>支持链式调用、函数式风格</li>
</ul>
</li>
<li><p><strong>面试拓展</strong>：</p>
<ul>
<li>Optional 不适合用于集合属性，避免滥用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="二、Java-并发编程（30题）"><a href="#二、Java-并发编程（30题）" class="headerlink" title="二、Java 并发编程（30题）"></a>二、Java 并发编程（30题）</h2><hr>
<h2 id="1-线程的生命周期"><a href="#1-线程的生命周期" class="headerlink" title="1. 线程的生命周期"></a><strong>1. 线程的生命周期</strong></h2><ul>
<li><strong>状态</strong>：<ol>
<li><strong>NEW</strong>：创建后，未调用 <code>start()</code></li>
<li><strong>RUNNABLE</strong>：调用 <code>start()</code>，可运行（线程调度器决定何时执行）</li>
<li><strong>BLOCKED</strong>：等待锁</li>
<li><strong>WAITING</strong>：无限期等待（<code>Object.wait()</code> &#x2F; <code>LockSupport.park()</code>）</li>
<li><strong>TIMED_WAITING</strong>：超时等待（<code>sleep()</code>, <code>join(timeout)</code>）</li>
<li><strong>TERMINATED</strong>：执行完毕</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-创建线程的方式"><a href="#2-创建线程的方式" class="headerlink" title="2. 创建线程的方式"></a><strong>2. 创建线程的方式</strong></h2><ol>
<li><strong>继承 Thread 类</strong></li>
<li><strong>实现 Runnable 接口</strong></li>
<li><strong>实现 Callable + FutureTask</strong></li>
<li><strong>线程池（推荐）</strong></li>
</ol>
<hr>
<h2 id="3-Runnable-和-Callable-区别"><a href="#3-Runnable-和-Callable-区别" class="headerlink" title="3. Runnable 和 Callable 区别"></a><strong>3. Runnable 和 Callable 区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>Runnable</th>
<th>Callable</th>
</tr>
</thead>
<tbody><tr>
<td>返回值</td>
<td>无</td>
<td>可以有返回值</td>
</tr>
<tr>
<td>异常</td>
<td>不可抛出检查异常</td>
<td>可以抛出异常</td>
</tr>
<tr>
<td>执行方式</td>
<td>new Thread(runnable)</td>
<td>ExecutorService.submit(callable)</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-Future-和-CompletableFuture-区别"><a href="#4-Future-和-CompletableFuture-区别" class="headerlink" title="4. Future 和 CompletableFuture 区别"></a><strong>4. Future 和 CompletableFuture 区别</strong></h2><ul>
<li><strong>Future</strong>：<ul>
<li>阻塞式获取结果</li>
<li>不支持链式异步处理</li>
</ul>
</li>
<li><strong>CompletableFuture</strong>：<ul>
<li>支持链式异步处理（thenApply, thenCombine, exceptionally）</li>
<li>可组合多个异步任务</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-ThreadLocal-原理"><a href="#5-ThreadLocal-原理" class="headerlink" title="5. ThreadLocal 原理"></a><strong>5. ThreadLocal 原理</strong></h2><ul>
<li>每个线程持有一个 <strong>ThreadLocalMap</strong></li>
<li>key 是 <strong>ThreadLocal 对象</strong>，value 是线程私有变量</li>
<li>内存泄漏风险：<ul>
<li>ThreadLocal 弱引用被 GC，value 没有被回收</li>
</ul>
</li>
<li>解决方法：<ul>
<li>使用 <code>remove()</code> 清理</li>
</ul>
</li>
</ul>
<hr>
<h2 id="6-synchronized-的锁优化机制"><a href="#6-synchronized-的锁优化机制" class="headerlink" title="6. synchronized 的锁优化机制"></a><strong>6. synchronized 的锁优化机制</strong></h2><ol>
<li><strong>偏向锁</strong>：减少无竞争开销</li>
<li><strong>轻量级锁</strong>：CAS + 自旋</li>
<li><strong>重量级锁</strong>：Monitor 阻塞线程</li>
<li><strong>锁消除&#x2F;锁粗化</strong>：JIT 优化</li>
</ol>
<hr>
<h2 id="7-ReentrantLock-实现原理"><a href="#7-ReentrantLock-实现原理" class="headerlink" title="7. ReentrantLock 实现原理"></a><strong>7. ReentrantLock 实现原理</strong></h2><ul>
<li>基于 <strong>AQS（AbstractQueuedSynchronizer）</strong></li>
<li>内部维护一个 <strong>state</strong> 表示锁状态</li>
<li>队列 FIFO 管理等待线程</li>
<li>支持公平锁&#x2F;非公平锁</li>
</ul>
<hr>
<h2 id="8-公平锁和非公平锁区别"><a href="#8-公平锁和非公平锁区别" class="headerlink" title="8. 公平锁和非公平锁区别"></a><strong>8. 公平锁和非公平锁区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>公平锁</th>
<th>非公平锁</th>
</tr>
</thead>
<tbody><tr>
<td>加锁顺序</td>
<td>FIFO</td>
<td>不保证</td>
</tr>
<tr>
<td>性能</td>
<td>低</td>
<td>高（线程争抢）</td>
</tr>
<tr>
<td>场景</td>
<td>避免饥饿</td>
<td>高性能锁场景</td>
</tr>
</tbody></table>
<hr>
<h2 id="9-乐观锁和悲观锁区别"><a href="#9-乐观锁和悲观锁区别" class="headerlink" title="9. 乐观锁和悲观锁区别"></a><strong>9. 乐观锁和悲观锁区别</strong></h2><ul>
<li><strong>悲观锁</strong>：假设会发生冲突，直接加锁（如 synchronized &#x2F; ReentrantLock）</li>
<li><strong>乐观锁</strong>：假设冲突少，使用 CAS（如 Atomic 类）</li>
</ul>
<hr>
<h2 id="10-AQS-原理"><a href="#10-AQS-原理" class="headerlink" title="10. AQS 原理"></a><strong>10. AQS 原理</strong></h2><ul>
<li><strong>核心</strong>：state + CLH 队列</li>
<li><strong>特性</strong>：<ul>
<li>独占模式 &#x2F; 共享模式</li>
<li>基于 FIFO 队列管理等待线程</li>
</ul>
</li>
<li><strong>应用</strong>：<ul>
<li>ReentrantLock、Semaphore、CountDownLatch、FutureTask</li>
</ul>
</li>
</ul>
<hr>
<h2 id="11-CountDownLatch-和-CyclicBarrier-区别"><a href="#11-CountDownLatch-和-CyclicBarrier-区别" class="headerlink" title="11. CountDownLatch 和 CyclicBarrier 区别"></a><strong>11. CountDownLatch 和 CyclicBarrier 区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td>使用次数</td>
<td>一次性</td>
<td>可重复使用</td>
</tr>
<tr>
<td>功能</td>
<td>等待线程完成</td>
<td>等待线程到达同一点</td>
</tr>
<tr>
<td>场景</td>
<td>线程结束同步</td>
<td>多线程并行分段</td>
</tr>
</tbody></table>
<hr>
<h2 id="12-Semaphore-的实现原理"><a href="#12-Semaphore-的实现原理" class="headerlink" title="12. Semaphore 的实现原理"></a><strong>12. Semaphore 的实现原理</strong></h2><ul>
<li>控制并发线程数量</li>
<li>基于 AQS 的共享锁</li>
<li>acquire() 获取许可，release() 释放许可</li>
</ul>
<hr>
<h2 id="13-Exchanger-的使用场景"><a href="#13-Exchanger-的使用场景" class="headerlink" title="13. Exchanger 的使用场景"></a><strong>13. Exchanger 的使用场景</strong></h2><ul>
<li>两个线程交换数据</li>
<li>典型场景：生产者-消费者线程交换缓冲区</li>
</ul>
<hr>
<h2 id="14-ForkJoinPool-的原理"><a href="#14-ForkJoinPool-的原理" class="headerlink" title="14. ForkJoinPool 的原理"></a><strong>14. ForkJoinPool 的原理</strong></h2><ul>
<li><strong>工作窃取算法</strong>：<ul>
<li>空闲线程从其他线程队列中窃取任务</li>
</ul>
</li>
<li>适合 <strong>递归任务</strong></li>
<li>通过 <strong>ForkJoinTask</strong> 递归拆分计算</li>
</ul>
<hr>
<h2 id="15-CAS-操作的底层实现"><a href="#15-CAS-操作的底层实现" class="headerlink" title="15. CAS 操作的底层实现"></a><strong>15. CAS 操作的底层实现</strong></h2><ul>
<li>基于 CPU <strong>原子指令（CMPXCHG）</strong></li>
<li>JVM <code>Unsafe</code> 提供支持</li>
<li><strong>优点</strong>：无锁、线程安全</li>
<li><strong>缺点</strong>：ABA 问题</li>
</ul>
<hr>
<h2 id="16-ABA-问题及解决"><a href="#16-ABA-问题及解决" class="headerlink" title="16. ABA 问题及解决"></a><strong>16. ABA 问题及解决</strong></h2><ul>
<li><strong>问题</strong>：值先 A → B → A，CAS 无法判断变化</li>
<li><strong>解决</strong>：<ul>
<li>版本号机制（AtomicStampedReference）</li>
<li>双重检查</li>
</ul>
</li>
</ul>
<hr>
<h2 id="17-Atomic-原子类原理"><a href="#17-Atomic-原子类原理" class="headerlink" title="17. Atomic 原子类原理"></a><strong>17. Atomic 原子类原理</strong></h2><ul>
<li>基于 <strong>CAS + Unsafe + volatile</strong></li>
<li>实现非阻塞线程安全</li>
<li>示例：<code>AtomicInteger</code> 使用 <code>compareAndSwapInt</code></li>
</ul>
<hr>
<h2 id="18-BlockingQueue-实现原理"><a href="#18-BlockingQueue-实现原理" class="headerlink" title="18. BlockingQueue 实现原理"></a><strong>18. BlockingQueue 实现原理</strong></h2><ul>
<li>内部维护 <strong>锁 + 条件队列</strong></li>
<li>put 阻塞满队列，take 阻塞空队列</li>
<li>常用实现：<ul>
<li>ArrayBlockingQueue（数组 + ReentrantLock）</li>
<li>LinkedBlockingQueue（链表 + ReentrantLock）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="19-ConcurrentHashMap-的分段锁机制"><a href="#19-ConcurrentHashMap-的分段锁机制" class="headerlink" title="19. ConcurrentHashMap 的分段锁机制"></a><strong>19. ConcurrentHashMap 的分段锁机制</strong></h2><ul>
<li>JDK 1.7：<ul>
<li><strong>Segment[] + synchronized</strong></li>
</ul>
</li>
<li>JDK 1.8：<ul>
<li><strong>CAS + synchronized 链表 + 红黑树 + Node</strong></li>
</ul>
</li>
<li>支持高并发读写</li>
</ul>
<hr>
<h2 id="20-ConcurrentHashMap-扩容机制"><a href="#20-ConcurrentHashMap-扩容机制" class="headerlink" title="20. ConcurrentHashMap 扩容机制"></a><strong>20. ConcurrentHashMap 扩容机制</strong></h2><ul>
<li>采用 <strong>分段扩容 + CAS</strong></li>
<li>链表转红黑树提高查找性能</li>
<li>扩容过程中使用 <strong>迁移节点</strong></li>
</ul>
<hr>
<h2 id="21-CopyOnWriteArrayList-原理"><a href="#21-CopyOnWriteArrayList-原理" class="headerlink" title="21. CopyOnWriteArrayList 原理"></a><strong>21. CopyOnWriteArrayList 原理</strong></h2><ul>
<li>写时复制：<ol>
<li>写操作复制数组</li>
<li>修改后替换引用</li>
</ol>
</li>
<li>适合读多写少场景</li>
</ul>
<hr>
<h2 id="22-线程池核心参数"><a href="#22-线程池核心参数" class="headerlink" title="22. 线程池核心参数"></a><strong>22. 线程池核心参数</strong></h2><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>核心线程数</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>非核心线程存活时间</td>
</tr>
<tr>
<td>workQueue</td>
<td>任务队列</td>
</tr>
<tr>
<td>RejectedExecutionHandler</td>
<td>拒绝策略</td>
</tr>
</tbody></table>
<hr>
<h2 id="23-线程池拒绝策略"><a href="#23-线程池拒绝策略" class="headerlink" title="23. 线程池拒绝策略"></a><strong>23. 线程池拒绝策略</strong></h2><ol>
<li>AbortPolicy（默认，抛异常）</li>
<li>CallerRunsPolicy（调用线程执行）</li>
<li>DiscardPolicy（丢弃任务）</li>
<li>DiscardOldestPolicy（丢弃队列最老任务）</li>
</ol>
<hr>
<h2 id="24-线程池工作流程"><a href="#24-线程池工作流程" class="headerlink" title="24. 线程池工作流程"></a><strong>24. 线程池工作流程</strong></h2><ol>
<li>提交任务 → 放入队列</li>
<li>核心线程未满 → 创建线程</li>
<li>队列满 → 创建非核心线程</li>
<li>达到最大线程 → 触发拒绝策略</li>
</ol>
<hr>
<h2 id="25-ThreadPoolExecutor-vs-ScheduledThreadPoolExecutor"><a href="#25-ThreadPoolExecutor-vs-ScheduledThreadPoolExecutor" class="headerlink" title="25. ThreadPoolExecutor vs ScheduledThreadPoolExecutor"></a><strong>25. ThreadPoolExecutor vs ScheduledThreadPoolExecutor</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>ThreadPoolExecutor</th>
<th>ScheduledThreadPoolExecutor</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>通用线程池</td>
<td>支持定时 &#x2F; 周期任务</td>
</tr>
<tr>
<td>队列</td>
<td>BlockingQueue</td>
<td>DelayQueue</td>
</tr>
<tr>
<td>场景</td>
<td>并发任务</td>
<td>定时任务</td>
</tr>
</tbody></table>
<hr>
<h2 id="26-为什么不建议使用-Executors-创建线程池"><a href="#26-为什么不建议使用-Executors-创建线程池" class="headerlink" title="26. 为什么不建议使用 Executors 创建线程池"></a><strong>26. 为什么不建议使用 Executors 创建线程池</strong></h2><ul>
<li>Executors 会产生 <strong>无限队列</strong>（如 newCachedThreadPool）</li>
<li>容易 <strong>OOM &#x2F; 线程数过多</strong></li>
<li>推荐：手动使用 <strong>ThreadPoolExecutor</strong> 配置核心参数</li>
</ul>
<hr>
<h2 id="27-JMM-内存可见性问题"><a href="#27-JMM-内存可见性问题" class="headerlink" title="27. JMM 内存可见性问题"></a><strong>27. JMM 内存可见性问题</strong></h2><ul>
<li>多线程访问共享变量，修改不立即可见</li>
<li><strong>解决方法</strong>：<ul>
<li><code>volatile</code></li>
<li><code>synchronized</code> &#x2F; Lock</li>
</ul>
</li>
</ul>
<hr>
<h2 id="28-happens-before-规则"><a href="#28-happens-before-规则" class="headerlink" title="28. happens-before 规则"></a><strong>28. happens-before 规则</strong></h2><ul>
<li><strong>保证操作顺序与可见性</strong></li>
<li>常见规则：<ol>
<li><strong>锁的解锁 → 加锁</strong></li>
<li><strong>volatile 写 → 读</strong></li>
<li><strong>线程 start() → run()</strong></li>
<li><strong>线程 join() → 结束</strong></li>
</ol>
</li>
</ul>
<hr>
<h2 id="29-死锁产生条件及避免"><a href="#29-死锁产生条件及避免" class="headerlink" title="29. 死锁产生条件及避免"></a><strong>29. 死锁产生条件及避免</strong></h2><ul>
<li><strong>四个必要条件</strong>：<ol>
<li>互斥</li>
<li>占有且等待</li>
<li>不可抢占</li>
<li>循环等待</li>
</ol>
</li>
<li><strong>避免方法</strong>：<ul>
<li>避免循环等待，按顺序加锁</li>
<li>使用 tryLock + 超时</li>
<li>使用单一锁</li>
</ul>
</li>
</ul>
<hr>
<h2 id="30-常见并发容器及区别"><a href="#30-常见并发容器及区别" class="headerlink" title="30. 常见并发容器及区别"></a><strong>30. 常见并发容器及区别</strong></h2><table>
<thead>
<tr>
<th>容器</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>ConcurrentHashMap</td>
<td>高并发读写，分段&#x2F;链表+红黑树</td>
</tr>
<tr>
<td>CopyOnWriteArrayList</td>
<td>写时复制，读多写少</td>
</tr>
<tr>
<td>ConcurrentLinkedQueue</td>
<td>非阻塞</td>
</tr>
</tbody></table>
<p>队列，基于 CAS |<br> | BlockingQueue（Array&#x2F;Linked） | 支持阻塞 put&#x2F;take |<br> | ConcurrentSkipListMap | 有序，基于跳表，线程安全 |</p>
<hr>
<h2 id="三、JVM-与性能优化（30题）"><a href="#三、JVM-与性能优化（30题）" class="headerlink" title="三、JVM 与性能优化（30题）"></a>三、JVM 与性能优化（30题）</h2><hr>
<h2 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1. JVM 内存结构"></a><strong>1. JVM 内存结构</strong></h2><ul>
<li><strong>方法区 &#x2F; 元空间（Metaspace）</strong>：存放类信息、常量、静态变量</li>
<li><strong>堆（Heap）</strong>：对象实例、GC 管理区</li>
<li><strong>栈（Stack）</strong>：方法调用、局部变量</li>
<li><strong>程序计数器（PC）</strong>：记录线程执行地址</li>
<li><strong>本地方法栈（Native Stack）</strong>：执行 native 方法</li>
<li><strong>直接内存（Direct Memory）</strong>：堆外内存，用于 NIO</li>
</ul>
<hr>
<h2 id="2-堆和栈的区别"><a href="#2-堆和栈的区别" class="headerlink" title="2. 堆和栈的区别"></a><strong>2. 堆和栈的区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>堆</th>
<th>栈</th>
</tr>
</thead>
<tbody><tr>
<td>存储内容</td>
<td>对象实例</td>
<td>方法调用帧、局部变量</td>
</tr>
<tr>
<td>生命周期</td>
<td>GC 管理</td>
<td>随方法结束释放</td>
</tr>
<tr>
<td>线程共享</td>
<td>是</td>
<td>否（线程私有）</td>
</tr>
<tr>
<td>访问速度</td>
<td>较慢</td>
<td>快</td>
</tr>
<tr>
<td>内存大小</td>
<td>大</td>
<td>小</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-新生代、老年代、永久代（元空间）的区别"><a href="#3-新生代、老年代、永久代（元空间）的区别" class="headerlink" title="3. 新生代、老年代、永久代（元空间）的区别"></a><strong>3. 新生代、老年代、永久代（元空间）的区别</strong></h2><ul>
<li><strong>新生代</strong>（Young Generation）：<ul>
<li>存放新创建对象</li>
<li>分为 Eden + 2 个 Survivor 区</li>
<li>Minor GC 主要发生在此</li>
</ul>
</li>
<li><strong>老年代</strong>（Old&#x2F;Tenured Generation）：<ul>
<li>长寿命对象</li>
<li>Full GC 主要作用区域</li>
</ul>
</li>
<li><strong>永久代 &#x2F; 元空间</strong>：<ul>
<li>存放类元数据</li>
<li>Java 8+ 使用 Metaspace（Native 内存）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-对象的创建过程"><a href="#4-对象的创建过程" class="headerlink" title="4. 对象的创建过程"></a><strong>4. 对象的创建过程</strong></h2><ol>
<li><strong>类加载检查</strong></li>
<li><strong>分配内存</strong>：<ul>
<li>堆上分配对象空间（TLAB&#x2F;大对象直接分配）</li>
</ul>
</li>
<li><strong>初始化零值</strong></li>
<li><strong>构造器初始化</strong></li>
<li><strong>引用赋值</strong></li>
</ol>
<hr>
<h2 id="5-对象的内存分配策略"><a href="#5-对象的内存分配策略" class="headerlink" title="5. 对象的内存分配策略"></a><strong>5. 对象的内存分配策略</strong></h2><ul>
<li><strong>年轻代分配</strong>：TLAB（Thread Local Allocation Buffer）</li>
<li><strong>大对象直接进入老年代</strong>（如数组 &gt; 1MB）</li>
<li><strong>长期存活对象晋升到老年代</strong></li>
<li><strong>栈上分配</strong>：通过逃逸分析优化</li>
</ul>
<hr>
<h2 id="6-GC-Roots"><a href="#6-GC-Roots" class="headerlink" title="6. GC Roots"></a><strong>6. GC Roots</strong></h2><ul>
<li><strong>常见类型</strong>：<ul>
<li>栈帧中的引用变量</li>
<li>方法区静态变量</li>
<li>常量引用</li>
<li>本地方法栈引用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-垃圾回收算法"><a href="#7-垃圾回收算法" class="headerlink" title="7. 垃圾回收算法"></a><strong>7. 垃圾回收算法</strong></h2><ul>
<li><strong>引用计数</strong>（不可解决循环引用）</li>
<li><strong>可达性分析</strong>（GC Roots）</li>
<li><strong>具体回收算法</strong>：<ul>
<li>标记-清除</li>
<li>标记-整理</li>
<li>复制算法</li>
<li>分代回收</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8-CMS-垃圾回收器流程"><a href="#8-CMS-垃圾回收器流程" class="headerlink" title="8. CMS 垃圾回收器流程"></a><strong>8. CMS 垃圾回收器流程</strong></h2><ol>
<li>初始标记（Stop-The-World）</li>
<li>并发标记（标记可回收对象）</li>
<li>并发预清理</li>
<li>重新标记（Stop-The-World）</li>
<li>并发清理（回收老年代）</li>
</ol>
<ul>
<li><strong>特点</strong>：低停顿，但有浮动垃圾和内存碎片问题</li>
</ul>
<hr>
<h2 id="9-G1-垃圾回收器原理"><a href="#9-G1-垃圾回收器原理" class="headerlink" title="9. G1 垃圾回收器原理"></a><strong>9. G1 垃圾回收器原理</strong></h2><ul>
<li><strong>Region（分区）管理堆</strong></li>
<li><strong>分代+并行+增量收集</strong></li>
<li><strong>垃圾回收策略</strong>：<ul>
<li>优先回收回收成本低的 Region</li>
<li>并发标记 + 并行清理</li>
</ul>
</li>
<li><strong>目标</strong>：控制停顿时间</li>
<li><strong>优势</strong>：无碎片、可预测停顿</li>
</ul>
<hr>
<h2 id="10-ZGC-和-Shenandoah-特点"><a href="#10-ZGC-和-Shenandoah-特点" class="headerlink" title="10. ZGC 和 Shenandoah 特点"></a><strong>10. ZGC 和 Shenandoah 特点</strong></h2><ul>
<li><strong>低延迟 GC</strong>，停顿时间 &lt; 10ms</li>
<li><strong>并发标记 + 并发压缩</strong></li>
<li><strong>内存可扩展性好</strong></li>
<li>支持大内存 (&gt;100GB)</li>
<li>面试常问区别：ZGC 使用 <strong>Load Barrier</strong>，Shenandoah 使用 <strong>Region Pinning</strong></li>
</ul>
<hr>
<h2 id="11-Minor-GC-与-Full-GC-区别"><a href="#11-Minor-GC-与-Full-GC-区别" class="headerlink" title="11. Minor GC 与 Full GC 区别"></a><strong>11. Minor GC 与 Full GC 区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>Minor GC</th>
<th>Full GC</th>
</tr>
</thead>
<tbody><tr>
<td>触发区域</td>
<td>新生代</td>
<td>整个堆（包括老年代）</td>
</tr>
<tr>
<td>停顿时间</td>
<td>短</td>
<td>长</td>
</tr>
<tr>
<td>频率</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>GC 类型</td>
<td>复制算法</td>
<td>标记-整理 &#x2F; CMS &#x2F; G1</td>
</tr>
</tbody></table>
<hr>
<h2 id="12-OOM-常见类型及排查"><a href="#12-OOM-常见类型及排查" class="headerlink" title="12. OOM 常见类型及排查"></a><strong>12. OOM 常见类型及排查</strong></h2><ul>
<li><strong>Java Heap Space</strong>：堆内存不足</li>
<li><strong>GC Overhead Limit</strong>：GC 花费过多时间</li>
<li><strong>Metaspace</strong>：类元信息过多</li>
<li><strong>Direct Memory</strong>：堆外内存溢出</li>
<li><strong>排查工具</strong>：<ul>
<li>jmap、jstack、VisualVM、MAT</li>
</ul>
</li>
</ul>
<hr>
<h2 id="13-类加载器分类"><a href="#13-类加载器分类" class="headerlink" title="13. 类加载器分类"></a><strong>13. 类加载器分类</strong></h2><ul>
<li>Bootstrap（根类加载器）</li>
<li>Extension（扩展类加载器）</li>
<li>Application（系统类加载器）</li>
<li>自定义 ClassLoader</li>
</ul>
<hr>
<h2 id="14-双亲委派模型破坏场景"><a href="#14-双亲委派模型破坏场景" class="headerlink" title="14. 双亲委派模型破坏场景"></a><strong>14. 双亲委派模型破坏场景</strong></h2><ul>
<li>动态加载不同版本类</li>
<li>热部署、插件化框架（Tomcat、OSGi）</li>
</ul>
<hr>
<h2 id="15-JVM-常见参数调优"><a href="#15-JVM-常见参数调优" class="headerlink" title="15. JVM 常见参数调优"></a><strong>15. JVM 常见参数调优</strong></h2><ul>
<li><strong>堆大小</strong>：<code>-Xms -Xmx</code></li>
<li><strong>新生代比例</strong>：<code>-XX:NewRatio</code></li>
<li><strong>GC 类型</strong>：<code>-XX:+UseG1GC</code></li>
<li><strong>线程栈大小</strong>：<code>-Xss</code></li>
<li><strong>Metaspace</strong>：<code>-XX:MetaspaceSize</code></li>
</ul>
<hr>
<h2 id="16-内存泄漏-vs-内存溢出"><a href="#16-内存泄漏-vs-内存溢出" class="headerlink" title="16. 内存泄漏 vs 内存溢出"></a><strong>16. 内存泄漏 vs 内存溢出</strong></h2><ul>
<li><strong>内存泄漏</strong>：对象不再使用，但仍有引用</li>
<li><strong>内存溢出（OOM）</strong>：申请内存失败</li>
</ul>
<hr>
<h2 id="17-逃逸分析"><a href="#17-逃逸分析" class="headerlink" title="17. 逃逸分析"></a><strong>17. 逃逸分析</strong></h2><ul>
<li><strong>作用</strong>：<ul>
<li>分析对象作用域</li>
<li>栈上分配、锁消除、同步优化</li>
</ul>
</li>
<li><strong>JVM 优化</strong>：<ul>
<li>栈上分配（不入堆）</li>
<li>去掉无用锁（锁消除）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="18-方法内联"><a href="#18-方法内联" class="headerlink" title="18. 方法内联"></a><strong>18. 方法内联</strong></h2><ul>
<li>JIT 优化</li>
<li>小方法直接替换调用，减少方法调用开销</li>
<li>增加 CPU 指令局部性，提高性能</li>
</ul>
<hr>
<h2 id="19-JIT-编译器优化"><a href="#19-JIT-编译器优化" class="headerlink" title="19. JIT 编译器优化"></a><strong>19. JIT 编译器优化</strong></h2><ul>
<li>方法内联</li>
<li>循环展开</li>
<li>逃逸分析</li>
<li>常量折叠</li>
<li>逃逸分析 + 栈上分配</li>
</ul>
<hr>
<h2 id="20-Safepoint-机制"><a href="#20-Safepoint-机制" class="headerlink" title="20. Safepoint 机制"></a><strong>20. Safepoint 机制</strong></h2><ul>
<li>所有线程暂停，进行 GC 或其他全局操作</li>
<li>JVM 可安全修改线程状态</li>
</ul>
<hr>
<h2 id="21-Stop-The-World-STW"><a href="#21-Stop-The-World-STW" class="headerlink" title="21. Stop The World (STW)"></a><strong>21. Stop The World (STW)</strong></h2><ul>
<li><strong>定义</strong>：暂停所有用户线程进行 GC 或其他 JVM 内部操作</li>
<li><strong>影响</strong>：应用停顿，低延迟场景需控制 STW 时间</li>
</ul>
<hr>
<h2 id="22-Finalize-方法问题"><a href="#22-Finalize-方法问题" class="headerlink" title="22. Finalize 方法问题"></a><strong>22. Finalize 方法问题</strong></h2><ul>
<li>不确定执行时间</li>
<li>性能开销大</li>
<li>可导致对象“复活”，增加内存压力</li>
<li><strong>替代方案</strong>：try-with-resources &#x2F; Cleaner</li>
</ul>
<hr>
<h2 id="23-JVM-如何判断对象可回收"><a href="#23-JVM-如何判断对象可回收" class="headerlink" title="23. JVM 如何判断对象可回收"></a><strong>23. JVM 如何判断对象可回收</strong></h2><ul>
<li><strong>可达性分析</strong>：从 GC Roots 出发，未被可达的对象可回收</li>
</ul>
<hr>
<h2 id="24-TLAB（Thread-Local-Allocation-Buffer）作用"><a href="#24-TLAB（Thread-Local-Allocation-Buffer）作用" class="headerlink" title="24. TLAB（Thread Local Allocation Buffer）作用"></a><strong>24. TLAB（Thread Local Allocation Buffer）作用</strong></h2><ul>
<li>每个线程独享一块 Eden 内存</li>
<li><strong>作用</strong>：<ul>
<li>减少多线程竞争</li>
<li>提高对象分配效率</li>
</ul>
</li>
</ul>
<hr>
<h2 id="25-Direct-Memory-为什么会-OOM"><a href="#25-Direct-Memory-为什么会-OOM" class="headerlink" title="25. Direct Memory 为什么会 OOM"></a><strong>25. Direct Memory 为什么会 OOM</strong></h2><ul>
<li>堆外内存不足</li>
<li>NIO Buffer 使用 <code>Unsafe</code> 分配</li>
<li>不受堆内存限制，但 JVM 无法直接管理</li>
</ul>
<hr>
<h2 id="26-Metaspace-作用"><a href="#26-Metaspace-作用" class="headerlink" title="26. Metaspace 作用"></a><strong>26. Metaspace 作用</strong></h2><ul>
<li>存放类元数据</li>
<li>Java 8+ 替代永久代</li>
<li>可以通过 <code>-XX:MetaspaceSize</code> 限制</li>
</ul>
<hr>
<h2 id="27-Full-GC-触发条件"><a href="#27-Full-GC-触发条件" class="headerlink" title="27. Full GC 触发条件"></a><strong>27. Full GC 触发条件</strong></h2><ul>
<li>老年代空间不足</li>
<li>永久代 &#x2F; 元空间不足</li>
<li>System.gc() 调用</li>
<li>内存分配失败</li>
</ul>
<hr>
<h2 id="28-查看-JVM-内存使用情况"><a href="#28-查看-JVM-内存使用情况" class="headerlink" title="28. 查看 JVM 内存使用情况"></a><strong>28. 查看 JVM 内存使用情况</strong></h2><ul>
<li><code>jstat -gc &lt;pid&gt;</code></li>
<li><code>jmap -heap &lt;pid&gt;</code></li>
<li><code>VisualVM</code> &#x2F; <code>JConsole</code></li>
<li><code>MAT</code> 分析 heap dump</li>
</ul>
<hr>
<h2 id="29-Arthas-常用命令"><a href="#29-Arthas-常用命令" class="headerlink" title="29. Arthas 常用命令"></a><strong>29. Arthas 常用命令</strong></h2><ul>
<li><code>dashboard</code>：系统指标</li>
<li><code>thread</code>：线程状态</li>
<li><code>heapdump</code>：堆转储</li>
<li><code>monitor</code>：方法耗时</li>
<li><code>watch</code>：方法参数&#x2F;返回值</li>
<li><code>jad</code>：反编译类</li>
</ul>
<hr>
<h2 id="30-JVM-调优常见面试题"><a href="#30-JVM-调优常见面试题" class="headerlink" title="30. JVM 调优常见面试题"></a><strong>30. JVM 调优常见面试题</strong></h2><ul>
<li>堆大小设置策略</li>
<li>新生代&#x2F;老年代比例</li>
<li>GC 选择（G1 &#x2F; CMS &#x2F; Parallel）</li>
<li>TLAB 与对象分配优化</li>
<li>Full GC 触发条件</li>
<li>内存泄漏排查与 MAT 使用</li>
</ul>
<hr>
<h2 id="四、Spring-Spring-Boot（30题）"><a href="#四、Spring-Spring-Boot（30题）" class="headerlink" title="四、Spring &amp; Spring Boot（30题）"></a>四、Spring &amp; Spring Boot（30题）</h2><h3 id="1-Spring-的-IoC-容器原理？"><a href="#1-Spring-的-IoC-容器原理？" class="headerlink" title="1. Spring 的 IoC 容器原理？"></a>1. Spring 的 IoC 容器原理？</h3><p><strong>核心回答：</strong><br> IoC（控制反转）是通过容器管理对象创建和依赖注入，开发者不需要手动 new 对象，而是由 Spring 容器统一管理。</p>
<p><strong>深入解析：</strong></p>
<ul>
<li>IoC 容器的核心是 <strong>BeanFactory</strong> 和 <strong>ApplicationContext</strong>。</li>
<li>工作流程：<ol>
<li><strong>配置解析</strong>：读取 XML &#x2F; 注解 &#x2F; JavaConfig；</li>
<li><strong>BeanDefinition</strong>：将配置转成 BeanDefinition；</li>
<li><strong>Bean 实例化</strong>：通过反射或 CGLIB 创建对象；</li>
<li><strong>依赖注入</strong>：根据构造方法 &#x2F; Setter &#x2F; @Autowired 注入依赖；</li>
<li><strong>初始化回调</strong>：执行 BeanPostProcessor &#x2F; InitializingBean；</li>
<li><strong>放入单例池</strong>：容器保存对象供全局使用。</li>
</ol>
</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>IoC 是 <strong>依赖查找（DL）</strong> 和 <strong>依赖注入（DI）</strong> 的结合。</li>
<li>面试可能追问：Spring 如何实现延迟加载？（@Lazy + 单例池管理）</li>
<li>实战：配置文件少时用 XML，大项目推荐 <strong>JavaConfig + 注解</strong>。</li>
</ul>
<hr>
<h3 id="2-Bean-的生命周期？"><a href="#2-Bean-的生命周期？" class="headerlink" title="2. Bean 的生命周期？"></a>2. Bean 的生命周期？</h3><p><strong>核心回答：</strong><br> 创建 → 属性注入 → 初始化 → 使用 → 销毁。</p>
<p><strong>深入解析：</strong></p>
<ol>
<li><strong>实例化</strong>：通过反射创建对象；</li>
<li><strong>依赖注入</strong>：注入属性；</li>
<li><strong>Aware 接口回调</strong>：如 BeanNameAware、ApplicationContextAware；</li>
<li><strong>BeanPostProcessor 前置处理</strong>：比如 @Autowired 的处理；</li>
<li><strong>初始化方法</strong>：@PostConstruct &#x2F; InitializingBean.afterPropertiesSet() &#x2F; init-method；</li>
<li><strong>BeanPostProcessor 后置处理</strong>；</li>
<li><strong>就绪使用</strong>；</li>
<li><strong>销毁回调</strong>：@PreDestroy &#x2F; DisposableBean.destroy() &#x2F; destroy-method。</li>
</ol>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试常追问：Spring 容器关闭时，单例 Bean 会被销毁吗？（会，调用 destroy 回调）。</li>
<li>原型作用域 Bean 不会被销毁，需要开发者手动管理。</li>
</ul>
<hr>
<h3 id="3-BeanFactory-和-ApplicationContext-的区别？"><a href="#3-BeanFactory-和-ApplicationContext-的区别？" class="headerlink" title="3. BeanFactory 和 ApplicationContext 的区别？"></a>3. BeanFactory 和 ApplicationContext 的区别？</h3><p><strong>核心回答：</strong></p>
<ul>
<li><strong>BeanFactory</strong>：最基础 IoC 容器，懒加载，轻量级；</li>
<li><strong>ApplicationContext</strong>：继承 BeanFactory，支持 AOP、国际化、事件机制、自动装配，默认预实例化。</li>
</ul>
<p><strong>深入解析：</strong></p>
<ul>
<li>BeanFactory：面向低资源环境，功能有限；</li>
<li>ApplicationContext：常用实现有 ClassPathXmlApplicationContext、AnnotationConfigApplicationContext。</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试常问：为什么 ApplicationContext 默认是预加载？（减少运行时性能开销，启动时完成依赖检查）。</li>
</ul>
<hr>
<h3 id="4-单例-Bean-如何保证线程安全？"><a href="#4-单例-Bean-如何保证线程安全？" class="headerlink" title="4. 单例 Bean 如何保证线程安全？"></a>4. 单例 Bean 如何保证线程安全？</h3><p><strong>核心回答：</strong><br> Spring <strong>不保证单例 Bean 的线程安全</strong>，需要开发者在代码中保证。</p>
<p><strong>深入解析：</strong></p>
<ul>
<li>IoC 容器中的单例 Bean 是 <strong>多线程共享的</strong>；</li>
<li>常见的线程安全措施：<ol>
<li><strong>无状态设计</strong>（推荐）；</li>
<li><strong>使用 ThreadLocal 保存状态</strong>；</li>
<li><strong>方法内部使用局部变量</strong>；</li>
<li><strong>必要时加锁（synchronized &#x2F; Lock）</strong>。</li>
</ol>
</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试陷阱：Spring 单例 Bean 是不是线程安全的？答：不是。</li>
<li>例子：Controller、Service 通常是无状态的，可以安全单例。</li>
</ul>
<hr>
<h3 id="5-Spring-AOP-的实现原理？"><a href="#5-Spring-AOP-的实现原理？" class="headerlink" title="5. Spring AOP 的实现原理？"></a>5. Spring AOP 的实现原理？</h3><p><strong>核心回答：</strong><br> AOP（面向切面编程）通过 <strong>动态代理</strong> 实现，在方法执行前后插入增强逻辑。</p>
<p><strong>深入解析：</strong></p>
<ul>
<li>实现方式：<ol>
<li><strong>JDK 动态代理</strong>：基于接口；</li>
<li><strong>CGLIB 代理</strong>：基于子类字节码增强。</li>
</ol>
</li>
<li>AOP 核心组件：<ul>
<li>JoinPoint（连接点）、Pointcut（切点）、Advice（通知）、Weaving（织入）、Proxy（代理对象）。</li>
</ul>
</li>
<li>AOP 流程：调用目标方法 → 代理对象拦截 → 执行切面逻辑 → 继续执行原方法。</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试官可能问：Spring 默认用哪种代理？<ul>
<li>如果有接口 → JDK 动态代理；</li>
<li>没有接口 → CGLIB。</li>
</ul>
</li>
<li>JDK 代理只能基于接口，CGLIB 可以基于类。</li>
</ul>
<hr>
<h3 id="6-JDK-动态代理和-CGLIB-的区别？"><a href="#6-JDK-动态代理和-CGLIB-的区别？" class="headerlink" title="6. JDK 动态代理和 CGLIB 的区别？"></a>6. JDK 动态代理和 CGLIB 的区别？</h3><p><strong>核心回答：</strong></p>
<ul>
<li>JDK：基于接口，生成实现类；</li>
<li>CGLIB：基于继承，生成子类字节码。</li>
</ul>
<p><strong>深入解析：</strong></p>
<ul>
<li>JDK 动态代理：利用 <code>Proxy.newProxyInstance</code>，性能较高；</li>
<li>CGLIB：利用 ASM 字节码操作生成子类，性能稍慢，但支持类代理；</li>
<li>Spring 默认优先使用 JDK，如果没有接口再用 CGLIB。</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>限制：CGLIB 无法代理 <code>final</code> 类 &#x2F; <code>final</code> 方法；</li>
<li>Spring Boot 可通过 <code>spring.aop.proxy-target-class=true</code> 强制使用 CGLIB。</li>
</ul>
<hr>
<h3 id="7-Spring-事务的传播机制？"><a href="#7-Spring-事务的传播机制？" class="headerlink" title="7. Spring 事务的传播机制？"></a>7. Spring 事务的传播机制？</h3><p><strong>核心回答：</strong><br> 事务传播机制定义了方法在调用时事务的边界，常见类型：</p>
<ul>
<li>REQUIRED（默认）、REQUIRES_NEW、NESTED、SUPPORTS、NOT_SUPPORTED、MANDATORY、NEVER。</li>
</ul>
<p><strong>深入解析：</strong></p>
<ul>
<li><strong>REQUIRED</strong>：有事务就加入，没有就新建；</li>
<li><strong>REQUIRES_NEW</strong>：挂起当前事务，新建一个；</li>
<li><strong>NESTED</strong>：嵌套事务（依赖保存点 rollback）；</li>
<li><strong>SUPPORTS</strong>：有就用，没有就不用；</li>
<li><strong>NOT_SUPPORTED</strong>：挂起事务，以非事务运行；</li>
<li><strong>MANDATORY</strong>：必须在事务中调用；</li>
<li><strong>NEVER</strong>：必须在非事务中运行。</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试陷阱：嵌套事务和新事务的区别？<ul>
<li>嵌套事务依赖外层事务回滚；</li>
<li>新事务互相独立。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8-Spring-事务的隔离级别？"><a href="#8-Spring-事务的隔离级别？" class="headerlink" title="8. Spring 事务的隔离级别？"></a>8. Spring 事务的隔离级别？</h3><p><strong>核心回答：</strong><br> 事务隔离级别解决并发问题，Spring 支持数据库的 5 种隔离级别：</p>
<ul>
<li>DEFAULT（数据库默认）</li>
<li>READ_UNCOMMITTED（可能脏读）</li>
<li>READ_COMMITTED（防脏读）</li>
<li>REPEATABLE_READ（防脏读、不可重复读）</li>
<li>SERIALIZABLE（防脏读、不可重复读、幻读）</li>
</ul>
<p><strong>深入解析：</strong></p>
<ul>
<li>InnoDB 默认是 <strong>REPEATABLE_READ</strong>；</li>
<li>Oracle 默认是 <strong>READ_COMMITTED</strong>。</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试可能追问：MySQL 的 REPEATABLE_READ 如何避免幻读？（MVCC + 间隙锁）。</li>
</ul>
<hr>
<h3 id="9-Transactional-的实现原理？"><a href="#9-Transactional-的实现原理？" class="headerlink" title="9. @Transactional 的实现原理？"></a>9. @Transactional 的实现原理？</h3><p><strong>核心回答：</strong><br> @Transactional 通过 <strong>AOP 代理</strong>，在方法执行前后控制事务。</p>
<p><strong>深入解析：</strong></p>
<ul>
<li>Spring 容器解析 @Transactional → 生成代理 → 在代理方法里执行事务增强逻辑：<ol>
<li>获取事务管理器；</li>
<li>开启事务；</li>
<li>执行目标方法；</li>
<li>异常回滚 &#x2F; 正常提交；</li>
<li>清理资源。</li>
</ol>
</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>默认只回滚 RuntimeException 和 Error，检查异常需要 <code>rollbackFor</code>。</li>
<li>面试常问：为什么 @Transactional 方法用 <code>private</code> 修饰无效？<br> → 因为 AOP 代理无法拦截 private 方法。</li>
</ul>
<hr>
<h3 id="10-循环依赖如何解决？"><a href="#10-循环依赖如何解决？" class="headerlink" title="10. 循环依赖如何解决？"></a>10. 循环依赖如何解决？</h3><p><strong>核心回答：</strong><br> Spring 通过 <strong>三级缓存</strong> 解决单例 Bean 的循环依赖。</p>
<p><strong>深入解析：</strong></p>
<ul>
<li>三级缓存：<ol>
<li>singletonObjects（成品对象）</li>
<li>earlySingletonObjects（提前暴露的对象，半成品）</li>
<li>singletonFactories（对象工厂，提供代理对象）</li>
</ol>
</li>
<li>流程：A → 依赖 B → B 依赖 A → 提前暴露 A 的引用给 B → 依赖注入成功。</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>只能解决 <strong>单例 + setter 注入</strong> 的循环依赖；</li>
<li><strong>构造器注入循环依赖</strong> 无法解决，会抛出异常。</li>
</ul>
<h3 id="11-Spring-的三级缓存解决了什么问题？"><a href="#11-Spring-的三级缓存解决了什么问题？" class="headerlink" title="11. Spring 的三级缓存解决了什么问题？"></a>11. Spring 的三级缓存解决了什么问题？</h3><p><strong>核心回答：</strong><br> 解决 <strong>单例 Bean 的循环依赖</strong>，保证在创建过程中能提前暴露代理对象。</p>
<p><strong>深入解析：</strong></p>
<ul>
<li>Spring 单例池维护了 <strong>三级缓存</strong>：<ol>
<li><code>singletonObjects</code> → 一级缓存（完全初始化的单例）；</li>
<li><code>earlySingletonObjects</code> → 二级缓存（提前暴露的半成品对象）；</li>
<li><code>singletonFactories</code> → 三级缓存（对象工厂，通常生成代理对象）。</li>
</ol>
</li>
<li>流程：<ul>
<li>当 A 依赖 B，B 又依赖 A 时：<ol>
<li>创建 A → 放入三级缓存；</li>
<li>B 依赖 A 时，先从三级缓存拿到 A 的工厂，暴露提前代理对象 → 放入二级缓存；</li>
<li>等 A 完成初始化后，替换为一级缓存。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试官可能追问：为什么要三级缓存，不是二级就够了吗？<br> → 因为 AOP 代理对象需要通过工厂提前暴露，不能只放半成品对象。</li>
<li>只支持 <strong>setter 注入的循环依赖</strong>，不支持 <strong>构造函数循环依赖</strong>。</li>
</ul>
<hr>
<h3 id="12-Spring-MVC-的工作流程？"><a href="#12-Spring-MVC-的工作流程？" class="headerlink" title="12. Spring MVC 的工作流程？"></a>12. Spring MVC 的工作流程？</h3><p><strong>核心回答：</strong><br> 请求 → DispatcherServlet → HandlerMapping → HandlerAdapter → Controller → ViewResolver → 响应。</p>
<p><strong>深入解析：</strong></p>
<ol>
<li>用户请求到达 DispatcherServlet；</li>
<li>DispatcherServlet 调用 HandlerMapping 寻找处理器；</li>
<li>通过 HandlerAdapter 调用具体 Controller；</li>
<li>Controller 执行业务逻辑，返回 ModelAndView；</li>
<li>ViewResolver 解析视图；</li>
<li>DispatcherServlet 渲染并返回响应给客户端。</li>
</ol>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试官常问：DispatcherServlet 是单例还是多例？（单例，线程安全依赖于无状态设计）。</li>
<li>实战：可以用 <code>@RestController</code> 直接返回 JSON，省略 ViewResolver。</li>
</ul>
<hr>
<h3 id="13-DispatcherServlet-的作用？"><a href="#13-DispatcherServlet-的作用？" class="headerlink" title="13. DispatcherServlet 的作用？"></a>13. DispatcherServlet 的作用？</h3><p><strong>核心回答：</strong><br> Spring MVC 的 <strong>前端控制器</strong>，负责请求分发和响应渲染。</p>
<p><strong>深入解析：</strong></p>
<ul>
<li>职责：<ol>
<li>拦截请求；</li>
<li>调用 HandlerMapping 找到 Controller；</li>
<li>调用 HandlerAdapter 执行 Controller；</li>
<li>调用 ViewResolver 渲染视图；</li>
<li>返回响应。</li>
</ol>
</li>
<li>核心思想：<strong>统一入口，集中控制</strong>。</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试追问：DispatcherServlet 在 Spring Boot 中怎么注册的？<br> → 自动配置类 <code>DispatcherServletAutoConfiguration</code> 注册。</li>
</ul>
<hr>
<h3 id="14-Spring-Boot-的自动装配原理？"><a href="#14-Spring-Boot-的自动装配原理？" class="headerlink" title="14. Spring Boot 的自动装配原理？"></a>14. Spring Boot 的自动装配原理？</h3><p><strong>核心回答：</strong><br> 基于 <code>@EnableAutoConfiguration</code> + <code>SpringFactoriesLoader</code> 实现，根据 classpath 条件加载配置类。</p>
<p><strong>深入解析：</strong></p>
<ol>
<li><code>@SpringBootApplication</code> → 启用 <code>@EnableAutoConfiguration</code>；</li>
<li><code>SpringFactoriesLoader</code> 读取 <code>META-INF/spring.factories</code> 文件；</li>
<li>根据 <code>@Conditional</code> 注解判断是否加载；</li>
<li>把匹配的 Bean 注册到容器。</li>
</ol>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试官可能追问：怎么禁用某个自动配置？<br> → <code>@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</code></li>
<li>或者在 <code>application.yml</code> 中配置 <code>spring.autoconfigure.exclude</code>。</li>
</ul>
<hr>
<h3 id="15-Spring-Boot-Starter-的机制？"><a href="#15-Spring-Boot-Starter-的机制？" class="headerlink" title="15. Spring Boot Starter 的机制？"></a>15. Spring Boot Starter 的机制？</h3><p><strong>核心回答：</strong><br> Starter 是一组 <strong>依赖封装 + 自动配置</strong>，简化第三方库集成。</p>
<p><strong>深入解析：</strong></p>
<ul>
<li>命名规范：<code>spring-boot-starter-xxx</code>；</li>
<li>依赖 Starter → 自动引入必要依赖 + 自动装配类；</li>
<li>例子：<code>spring-boot-starter-web</code> → 引入 Spring MVC + Tomcat + Jackson，并自动配置 DispatcherServlet。</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试官常问：怎么写一个自定义 Starter？<ol>
<li>提供 <code>AutoConfiguration</code> 类；</li>
<li>在 <code>META-INF/spring.factories</code> 注册；</li>
<li>打包发布。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="16-ConfigurationProperties-和-Value-的区别？"><a href="#16-ConfigurationProperties-和-Value-的区别？" class="headerlink" title="16. @ConfigurationProperties 和 @Value 的区别？"></a>16. @ConfigurationProperties 和 @Value 的区别？</h3><p><strong>核心回答：</strong></p>
<ul>
<li><code>@Value</code>：单个属性注入；</li>
<li><code>@ConfigurationProperties</code>：批量绑定配置，支持类型安全。</li>
</ul>
<p><strong>深入解析：</strong></p>
<ul>
<li><code>@Value(&quot;$&#123;key&#125;&quot;)</code>：只能注入单个值；</li>
<li><code>@ConfigurationProperties(prefix = &quot;xxx&quot;)</code>：把配置文件中 <code>xxx.*</code> 映射到 JavaBean。</li>
<li><code>@ConfigurationProperties</code> 更适合复杂配置对象。</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试官可能追问：推荐用哪个？<br> → <code>@ConfigurationProperties</code>，因为支持校验（<code>@Validated</code>）、IDE 提示。</li>
<li>实战：数据库配置常用 <code>@ConfigurationProperties</code>。</li>
</ul>
<hr>
<h3 id="17-Spring-Boot-如何实现热部署？"><a href="#17-Spring-Boot-如何实现热部署？" class="headerlink" title="17. Spring Boot 如何实现热部署？"></a>17. Spring Boot 如何实现热部署？</h3><p><strong>核心回答：</strong><br> 主要通过 <strong>Spring Boot DevTools</strong> 或 <strong>JRebel</strong>。</p>
<p><strong>深入解析：</strong></p>
<ul>
<li>DevTools：监控 classpath 文件变化，触发 SpringContext 重启；</li>
<li>JRebel：字节码增强，做到无感知热替换；</li>
<li>IDE（IntelliJ IDEA &#x2F; Eclipse）也支持 Build 自动 reload。</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>DevTools 适合开发，JRebel 更强大但收费。</li>
<li>生产环境不建议热部署，而是灰度发布&#x2F;滚动更新。</li>
</ul>
<hr>
<h3 id="18-Spring-Boot-如何处理配置文件？"><a href="#18-Spring-Boot-如何处理配置文件？" class="headerlink" title="18. Spring Boot 如何处理配置文件？"></a>18. Spring Boot 如何处理配置文件？</h3><p><strong>核心回答：</strong><br> Spring Boot 读取 <code>application.yml/properties</code>，并支持多环境和优先级加载。</p>
<p><strong>深入解析：</strong></p>
<ul>
<li>默认加载顺序：<ol>
<li>命令行参数；</li>
<li><code>application.properties</code> &#x2F; <code>application.yml</code>；</li>
<li>外部配置文件（config 目录）；</li>
<li>默认配置。</li>
</ol>
</li>
<li>支持多环境：<code>application-dev.yml</code>、<code>application-prod.yml</code>，通过 <code>spring.profiles.active=dev</code> 切换。</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试官可能问：优先级谁最高？<br> → 命令行参数。</li>
<li>实战：生产环境常用外部化配置（如 <code>--spring.config.location</code>）。</li>
</ul>
<hr>
<h3 id="19-Conditional-注解的作用？"><a href="#19-Conditional-注解的作用？" class="headerlink" title="19. @Conditional 注解的作用？"></a>19. @Conditional 注解的作用？</h3><p><strong>核心回答：</strong><br> 用于 <strong>条件装配</strong>，根据环境 &#x2F; 配置 &#x2F; Bean 是否存在决定是否加载 Bean。</p>
<p><strong>深入解析：</strong></p>
<ul>
<li>常见实现：<ul>
<li><code>@ConditionalOnClass</code>（类存在时装配）；</li>
<li><code>@ConditionalOnMissingBean</code>（没有 Bean 时装配）；</li>
<li><code>@ConditionalOnProperty</code>（配置项满足条件时装配）；</li>
<li><code>@ConditionalOnWebApplication</code>。</li>
</ul>
</li>
<li>广泛用于自动配置。</li>
</ul>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试追问：怎么写自定义条件？<br> → 实现 <code>Condition</code> 接口，重写 <code>matches()</code> 方法。</li>
</ul>
<hr>
<h3 id="20-Spring-Boot-常见的优化点？"><a href="#20-Spring-Boot-常见的优化点？" class="headerlink" title="20. Spring Boot 常见的优化点？"></a>20. Spring Boot 常见的优化点？</h3><p><strong>核心回答：</strong></p>
<ul>
<li>启动优化：懒加载、裁剪 Starter；</li>
<li>内存优化：减小 Bean 数量、引入轻量组件；</li>
<li>数据库优化：连接池、批量操作；</li>
<li>生产优化：Actuator 监控、外部化配置。</li>
</ul>
<p><strong>深入解析：</strong></p>
<ol>
<li><strong>启动性能</strong>：<code>spring.main.lazy-initialization=true</code>；</li>
<li><strong>数据库性能</strong>：HikariCP 连接池、批处理 SQL；</li>
<li><strong>缓存优化</strong>：整合 Redis、Caffeine；</li>
<li><strong>日志优化</strong>：异步日志（Logback AsyncAppender）；</li>
<li><strong>部署优化</strong>：分层构建（Layered Jar）、Docker 镜像加速。</li>
</ol>
<p><strong>延伸思考：</strong></p>
<ul>
<li>面试常问：Spring Boot 为什么启动比 Spring 慢？<br> → 因为要做自动装配和环境扫描。</li>
<li>实战：生产中可用 <code>spring-context-indexer</code> 加快启动。</li>
</ul>
<hr>
<h3 id="21-Spring-Boot-的自动配置原理"><a href="#21-Spring-Boot-的自动配置原理" class="headerlink" title="21. Spring Boot 的自动配置原理"></a><strong>21. Spring Boot 的自动配置原理</strong></h3><p><strong>核心回答</strong><br> Spring Boot 的自动配置基于 <strong>SpringFactoriesLoader + @EnableAutoConfiguration + 条件注解（@ConditionalXXX）</strong>。<br> 它会根据 classpath 中依赖的 jar 包和已有 Bean 自动装配所需的配置。</p>
<p><strong>深入解析</strong></p>
<ol>
<li><strong>关键入口</strong>：<ul>
<li><code>@SpringBootApplication</code> → <code>@EnableAutoConfiguration</code> → <code>AutoConfigurationImportSelector</code>。</li>
</ul>
</li>
<li><strong>配置来源</strong>：<ul>
<li><code>META-INF/spring.factories</code> 或 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>。</li>
</ul>
</li>
<li><strong>条件装配</strong>：<ul>
<li>通过 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等来避免重复配置。</li>
</ul>
</li>
<li><strong>运行时流程</strong>：<ul>
<li>启动时加载所有候选配置类 → 根据条件筛选 → 注册 BeanDefinition → 实例化 Bean。</li>
</ul>
</li>
</ol>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试追问：如何排查“为什么某个 Bean 没有生效”？<br> → 使用 <code>--debug</code> 参数查看 <strong>自动配置报告</strong>。</li>
<li>实战：如果不想加载某个自动配置，可以用 <code>@SpringBootApplication(exclude=XXXAutoConfiguration.class)</code>。</li>
</ul>
<hr>
<h3 id="22-Spring-Boot-的启动流程"><a href="#22-Spring-Boot-的启动流程" class="headerlink" title="22. Spring Boot 的启动流程"></a><strong>22. Spring Boot 的启动流程</strong></h3><p><strong>核心回答</strong><br> 启动流程：</p>
<ol>
<li>创建 <code>SpringApplication</code> 对象。</li>
<li>准备环境（Environment）。</li>
<li>加载 ApplicationContext。</li>
<li>调用自动配置。</li>
<li>启动内嵌容器（Tomcat&#x2F;Jetty&#x2F;Netty）。</li>
<li>执行 <code>CommandLineRunner</code> 和 <code>ApplicationRunner</code>。</li>
</ol>
<p><strong>深入解析</strong></p>
<ul>
<li><strong>源码入口</strong>：<code>SpringApplication.run()</code>。</li>
<li><strong>事件监听</strong>：<ul>
<li><code>ApplicationStartingEvent</code>（最早事件），</li>
<li><code>ApplicationReadyEvent</code>（启动完成）。</li>
</ul>
</li>
<li><strong>Bean 加载</strong>：<ul>
<li>先加载主类所在包及子包的组件（<code>@ComponentScan</code>）。</li>
<li>再结合自动配置。</li>
</ul>
</li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试官可能问：<strong>Spring Boot 如何支持外部配置？</strong><br> → 通过 <code>ConfigFileApplicationListener</code> 解析 <code>application.properties</code> &#x2F; <code>application.yml</code> 并注入 Environment。</li>
</ul>
<hr>
<h3 id="23-Spring-Boot-的配置文件加载顺序"><a href="#23-Spring-Boot-的配置文件加载顺序" class="headerlink" title="23. Spring Boot 的配置文件加载顺序"></a><strong>23. Spring Boot 的配置文件加载顺序</strong></h3><p><strong>核心回答</strong><br> Spring Boot 的配置优先级（从高到低）：</p>
<ol>
<li>命令行参数</li>
<li><code>application.properties/yml</code>（在 <code>config/</code> &gt; 当前目录 &gt; classpath 下）</li>
<li>外部系统环境变量</li>
<li>JNDI、系统属性</li>
<li>默认配置</li>
</ol>
<p><strong>深入解析</strong></p>
<ul>
<li><strong>多 profile</strong>：<code>application-dev.yml</code> 会在 <code>--spring.profiles.active=dev</code> 时覆盖默认配置。</li>
<li><strong>优先级控制</strong>：同一属性多次定义时，高优先级覆盖低优先级。</li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试追问：如果配置冲突，如何快速定位？<br> → 启动时加参数 <code>--debug</code>，查看配置源和优先级。</li>
</ul>
<hr>
<h3 id="24-Spring-Boot-如何实现热部署"><a href="#24-Spring-Boot-如何实现热部署" class="headerlink" title="24. Spring Boot 如何实现热部署"></a><strong>24. Spring Boot 如何实现热部署</strong></h3><p><strong>核心回答</strong><br> 通过 <strong>Spring Boot DevTools</strong> 或 <strong>JRebel</strong> 实现热部署。</p>
<p><strong>深入解析</strong></p>
<ul>
<li><strong>DevTools 原理</strong>：<ul>
<li>使用两个 ClassLoader：<ul>
<li>Base ClassLoader（第三方依赖不会变），</li>
<li>Restart ClassLoader（自己代码，改动后只重新加载）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>局限性</strong>：修改依赖库不会触发热部署，只能重启。</li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>实际开发中推荐用 <strong>DevTools + IDEA 自动构建</strong>。</li>
<li>面试追问：生产环境如何实现热更新？<br> → 使用 Spring Cloud Config + 动态刷新（<code>/actuator/refresh</code>）。</li>
</ul>
<hr>
<h3 id="25-Spring-Boot-中的监控和健康检查"><a href="#25-Spring-Boot-中的监控和健康检查" class="headerlink" title="25. Spring Boot 中的监控和健康检查"></a><strong>25. Spring Boot 中的监控和健康检查</strong></h3><p><strong>核心回答</strong><br> Spring Boot 提供 <strong>Actuator 模块</strong>，可监控应用运行状态。</p>
<p><strong>深入解析</strong></p>
<ul>
<li>常见端点：<ul>
<li><code>/actuator/health</code>（健康检查）</li>
<li><code>/actuator/metrics</code>（性能指标）</li>
<li><code>/actuator/env</code>（环境变量）</li>
<li><code>/actuator/beans</code>（已加载 Bean）</li>
</ul>
</li>
<li>健康检查可扩展：实现 <code>HealthIndicator</code> 接口，自定义检查逻辑（如 Redis、MQ）。</li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试追问：如何在 Kubernetes 中结合健康检查？<br> → 配置 <strong>livenessProbe</strong> 和 <strong>readinessProbe</strong> 调用 <code>/actuator/health</code>。</li>
</ul>
<hr>
<h3 id="26-Spring-Boot-如何集成数据库（JDBC、JPA、MyBatis）"><a href="#26-Spring-Boot-如何集成数据库（JDBC、JPA、MyBatis）" class="headerlink" title="26. Spring Boot 如何集成数据库（JDBC、JPA、MyBatis）"></a><strong>26. Spring Boot 如何集成数据库（JDBC、JPA、MyBatis）</strong></h3><p><strong>核心回答</strong><br> Spring Boot 提供 <code>spring-boot-starter-jdbc</code>、<code>spring-boot-starter-data-jpa</code> 等 starter，支持开箱即用。</p>
<p><strong>深入解析</strong></p>
<ul>
<li><strong>JDBC</strong>：直接操作数据库，结合 <code>JdbcTemplate</code>。</li>
<li><strong>JPA</strong>：基于 Hibernate，支持声明式 ORM（<code>@Entity</code>）。</li>
<li><strong>MyBatis</strong>：需引入第三方 starter（<code>mybatis-spring-boot-starter</code>），用 <code>@MapperScan</code>。</li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试追问：<strong>Spring Data JPA 与 MyBatis 区别？</strong><ul>
<li>JPA → ORM 自动化，适合快速开发。</li>
<li>MyBatis → SQL 手写，灵活可控，适合复杂业务。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="27-Spring-Boot-如何实现日志管理"><a href="#27-Spring-Boot-如何实现日志管理" class="headerlink" title="27. Spring Boot 如何实现日志管理"></a><strong>27. Spring Boot 如何实现日志管理</strong></h3><p><strong>核心回答</strong><br> Spring Boot 默认使用 <strong>SLF4J + Logback</strong>，可支持 Log4j2。</p>
<p><strong>深入解析</strong></p>
<ul>
<li><strong>配置方式</strong>：<ul>
<li><code>application.yml</code> 或 <code>logback-spring.xml</code>。</li>
</ul>
</li>
<li><strong>日志级别</strong>：<code>TRACE</code> &lt; <code>DEBUG</code> &lt; <code>INFO</code> &lt; <code>WARN</code> &lt; <code>ERROR</code>。</li>
<li><strong>多环境日志</strong>：<ul>
<li><code>logback-spring.xml</code> + <code>springProfile</code> 标签可区分 dev &#x2F; prod。</li>
</ul>
</li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试追问：如何将日志输出到 ELK（ElasticSearch + Logstash + Kibana）？<br> → 使用 <code>logstash-logback-encoder</code>。</li>
</ul>
<hr>
<h3 id="28-Spring-Boot-如何处理跨域问题（CORS）"><a href="#28-Spring-Boot-如何处理跨域问题（CORS）" class="headerlink" title="28. Spring Boot 如何处理跨域问题（CORS）"></a><strong>28. Spring Boot 如何处理跨域问题（CORS）</strong></h3><p><strong>核心回答</strong><br> 通过 <strong>@CrossOrigin</strong> 或全局配置 <code>CorsFilter</code>。</p>
<p><strong>深入解析</strong></p>
<ul>
<li><p><strong>方式1：注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins=&quot;http://example.com&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/api/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方式2：全局配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WebMvcConfigurer <span class="title function_">corsConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">            registry.addMapping(<span class="string">&quot;/**&quot;</span>).allowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试追问：CORS 和 Nginx 反向代理跨域的区别？<ul>
<li>CORS → Spring Boot 处理，适合单应用。</li>
<li>Nginx → 网关层处理，适合微服务架构。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="29-Spring-Boot-中的安全机制（Spring-Security）"><a href="#29-Spring-Boot-中的安全机制（Spring-Security）" class="headerlink" title="29. Spring Boot 中的安全机制（Spring Security）"></a><strong>29. Spring Boot 中的安全机制（Spring Security）</strong></h3><p><strong>核心回答</strong><br> Spring Security 提供认证（Authentication）+ 授权（Authorization）。</p>
<p><strong>深入解析</strong></p>
<ol>
<li><strong>认证流程</strong>：<ul>
<li>用户请求 → <code>UsernamePasswordAuthenticationFilter</code> → AuthenticationManager → UserDetailsService → 认证成功 → SecurityContext 保存信息。</li>
</ul>
</li>
<li><strong>授权机制</strong>：<ul>
<li>基于 URL（拦截路径）、方法级（<code>@PreAuthorize</code>）、表达式。</li>
</ul>
</li>
<li><strong>默认用户</strong>：Spring Boot 2.x 默认生成随机密码（日志中输出）。</li>
</ol>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试追问：如何在 Spring Security 中集成 JWT？<ul>
<li>自定义过滤器，解析 JWT 并注入 SecurityContext。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="30-如何优化-Spring-Boot-启动速度"><a href="#30-如何优化-Spring-Boot-启动速度" class="headerlink" title="30. 如何优化 Spring Boot 启动速度"></a><strong>30. 如何优化 Spring Boot 启动速度</strong></h3><p><strong>核心回答</strong><br> 优化手段：减少自动配置、延迟初始化、引入轻量依赖。</p>
<p><strong>深入解析</strong></p>
<ul>
<li><strong>延迟加载</strong>：<code>spring.main.lazy-initialization=true</code>。</li>
<li><strong>移除不必要的 starter</strong>。</li>
<li><strong>本地调试时跳过安全&#x2F;监控配置</strong>。</li>
<li><strong>使用 GraalVM Native Image 加速启动</strong>。</li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试追问：Spring Boot 启动慢，如何排查？<ul>
<li>使用 <code>--debug</code> 和 <code>ApplicationStartup</code> 查看 Bean 加载耗时。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="五、Spring-Cloud（30题）"><a href="#五、Spring-Cloud（30题）" class="headerlink" title="五、Spring Cloud（30题）"></a>五、Spring Cloud（30题）</h2><hr>
<h2 id="1-Spring-Cloud-是什么？"><a href="#1-Spring-Cloud-是什么？" class="headerlink" title="1. Spring Cloud 是什么？"></a><strong>1. Spring Cloud 是什么？</strong></h2><p><strong>核心回答</strong><br> Spring Cloud 是基于 Spring Boot 的微服务治理框架，提供了分布式系统所需的全套组件：服务注册发现、负载均衡、配置中心、网关、熔断限流、链路追踪等。</p>
<p><strong>深入原理</strong></p>
<ul>
<li><strong>定位</strong>：微服务的 “生态整合者”，不是单一技术，而是一套解决方案。</li>
<li><strong>核心组件</strong>：<ul>
<li>Eureka（注册中心）</li>
<li>Ribbon &#x2F; LoadBalancer（客户端负载均衡）</li>
<li>Feign（声明式远程调用）</li>
<li>Hystrix &#x2F; Resilience4j &#x2F; Sentinel（熔断限流）</li>
<li>Config Server（配置中心）</li>
<li>Gateway（网关）</li>
<li>Sleuth + Zipkin（链路追踪）</li>
</ul>
</li>
<li><strong>本质</strong>：解决分布式复杂性，降低开发门槛。</li>
</ul>
<p><strong>面试延伸</strong></p>
<ul>
<li>Spring Cloud 与 Kubernetes Service Mesh 的区别：前者 SDK 模式，后者 Sidecar 模式。</li>
</ul>
<hr>
<h2 id="2-Spring-Cloud-和-Dubbo-的区别？"><a href="#2-Spring-Cloud-和-Dubbo-的区别？" class="headerlink" title="2. Spring Cloud 和 Dubbo 的区别？"></a><strong>2. Spring Cloud 和 Dubbo 的区别？</strong></h2><p><strong>核心回答</strong></p>
<ul>
<li>Dubbo：高性能 RPC 框架，核心是远程调用。</li>
<li>Spring Cloud：全家桶式微服务生态，功能更全面。</li>
</ul>
<p><strong>深入原理</strong></p>
<ul>
<li>协议层：Dubbo 用 TCP&#x2F;自定义协议，性能高；Spring Cloud 多用 REST&#x2F;HTTP。</li>
<li>功能覆盖：Dubbo 主要做服务调用，Spring Cloud 包含注册、配置、熔断、网关等。</li>
<li>演进：Dubbo3.0 开始支持 gRPC&#x2F;Triple 协议，与 Spring Cloud 越来越接近。</li>
</ul>
<p><strong>面试延伸</strong></p>
<ul>
<li>公司内网场景（追求性能） → Dubbo；</li>
<li>大规模分布式互联网场景（追求生态） → Spring Cloud。</li>
</ul>
<hr>
<h2 id="3-Eureka-的工作原理？"><a href="#3-Eureka-的工作原理？" class="headerlink" title="3. Eureka 的工作原理？"></a><strong>3. Eureka 的工作原理？</strong></h2><p><strong>核心回答</strong><br> Eureka 是 Netflix 开源的注册中心，负责 <strong>服务注册与发现</strong>，遵循 <strong>AP</strong> 原则。</p>
<p><strong>深入原理</strong></p>
<ul>
<li><strong>注册</strong>：服务启动后将自身信息（IP、端口、状态）注册到 Eureka Server。</li>
<li><strong>续约</strong>：服务定期发送心跳（默认 30s）。</li>
<li><strong>下线</strong>：服务关闭时发送下线请求。</li>
<li><strong>拉取</strong>：客户端定期从 Server 拉取注册表（默认 30s），本地缓存，提高可用性。</li>
</ul>
<p><strong>面试延伸</strong></p>
<ul>
<li>面试官可能问：Eureka 与 Zookeeper 区别？<ul>
<li>Eureka AP → 保证可用性（即使部分节点挂了仍能服务）；</li>
<li>Zookeeper CP → 强一致性（选举可能导致服务不可用）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-Eureka-的自我保护机制？"><a href="#4-Eureka-的自我保护机制？" class="headerlink" title="4. Eureka 的自我保护机制？"></a><strong>4. Eureka 的自我保护机制？</strong></h2><p><strong>核心回答</strong><br> Eureka 会在网络分区或心跳丢失时，<strong>不立即移除服务实例</strong>，保证可用性。</p>
<p><strong>深入原理</strong></p>
<ul>
<li>触发条件：在 15 分钟内心跳失败比例 &gt; 85%。</li>
<li>行为：<ul>
<li>暂停剔除失效服务。</li>
<li>保留已有注册表，允许客户端继续获取服务。</li>
</ul>
</li>
<li>好处：防止因网络抖动导致“服务雪崩”。</li>
</ul>
<p><strong>面试延伸</strong></p>
<ul>
<li>缺点：可能把已经宕机的实例继续暴露出去。</li>
<li>可配置 <code>eureka.server.enable-self-preservation=false</code> 来关闭。</li>
</ul>
<hr>
<h2 id="5-Ribbon-的负载均衡策略？"><a href="#5-Ribbon-的负载均衡策略？" class="headerlink" title="5. Ribbon 的负载均衡策略？"></a><strong>5. Ribbon 的负载均衡策略？</strong></h2><p><strong>核心回答</strong><br> Ribbon 是客户端负载均衡组件，常见策略有：</p>
<ul>
<li>轮询（RoundRobin）</li>
<li>随机（Random）</li>
<li>权重（WeightedResponseTimeRule）</li>
<li>最小并发（BestAvailableRule）</li>
</ul>
<p><strong>深入原理</strong><br> Ribbon 在客户端维护服务列表，从注册中心拉取后，根据策略选择目标服务发起请求。</p>
<p><strong>面试延伸</strong></p>
<ul>
<li>与 Nginx 的区别：Ribbon 是 <strong>客户端负载均衡</strong>（调用方决定），Nginx 是 <strong>服务端负载均衡</strong>（请求先到代理）。</li>
</ul>
<hr>
<h2 id="6-Ribbon-和-Nginx-的区别？"><a href="#6-Ribbon-和-Nginx-的区别？" class="headerlink" title="6. Ribbon 和 Nginx 的区别？"></a><strong>6. Ribbon 和 Nginx 的区别？</strong></h2><p><strong>核心回答</strong></p>
<ul>
<li>Ribbon：客户端负载均衡，本地决定调用哪台服务。</li>
<li>Nginx：服务端负载均衡，所有流量先经过代理。</li>
</ul>
<p><strong>深入原理</strong></p>
<ul>
<li><strong>部署位置</strong>：Ribbon 在调用方应用中，Nginx 独立部署。</li>
<li><strong>扩展性</strong>：Ribbon 与 Eureka 配合，支持动态上下线；Nginx 需手动改配置或借助 Consul&#x2F;Keepalived。</li>
</ul>
<p><strong>面试延伸</strong></p>
<ul>
<li>面试官追问：为什么微服务更倾向于 Ribbon？<ul>
<li>因为客户端模式更灵活，可以无感知扩容&#x2F;缩容。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-Feign-的工作原理？"><a href="#7-Feign-的工作原理？" class="headerlink" title="7. Feign 的工作原理？"></a><strong>7. Feign 的工作原理？</strong></h2><p><strong>核心回答</strong><br> Feign 是声明式 HTTP 客户端，通过接口 + 注解的方式调用远程服务。</p>
<p><strong>深入原理</strong></p>
<ul>
<li>运行时基于 <strong>动态代理</strong>（JDK Proxy）。</li>
<li>结合 Ribbon 负载均衡，自动选择服务实例。</li>
<li>可集成 Hystrix&#x2F;Sentinel，支持熔断。</li>
</ul>
<p><strong>面试延伸</strong></p>
<ul>
<li>面试官问：Feign 和 RestTemplate 的区别？<ul>
<li>RestTemplate → 代码侵入性强，需要手动拼接请求。</li>
<li>Feign → 声明式，更优雅。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8-Feign-如何支持熔断？"><a href="#8-Feign-如何支持熔断？" class="headerlink" title="8. Feign 如何支持熔断？"></a><strong>8. Feign 如何支持熔断？</strong></h2><p><strong>核心回答</strong><br> Feign 可集成 Hystrix 或 Sentinel，通过 <strong>Fallback</strong> 提供降级逻辑。</p>
<p><strong>深入原理</strong></p>
<ul>
<li>Hystrix：在请求失败&#x2F;超时时调用 fallback 方法。</li>
<li>Sentinel：通过注解 @SentinelResource + fallback 实现。</li>
</ul>
<p><strong>面试延伸</strong></p>
<ul>
<li>面试官追问：熔断和降级区别？<ul>
<li>熔断：保护系统不被拖垮。</li>
<li>降级：提供兜底逻辑，保证用户体验。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="9-Hystrix-的工作原理？"><a href="#9-Hystrix-的工作原理？" class="headerlink" title="9. Hystrix 的工作原理？"></a><strong>9. Hystrix 的工作原理？</strong></h2><p><strong>核心回答</strong><br> Hystrix 通过 <strong>线程池隔离 + 熔断器机制</strong> 保护服务，防止雪崩效应。</p>
<p><strong>深入原理</strong></p>
<ul>
<li><strong>线程池隔离</strong>：不同服务调用用不同线程池，避免相互影响。</li>
<li><strong>熔断机制</strong>：<ul>
<li>统计请求失败率。</li>
<li>达到阈值 → 熔断打开，直接走 fallback。</li>
<li>一段时间后 → 尝试半开，成功则恢复。</li>
</ul>
</li>
</ul>
<p><strong>面试延伸</strong></p>
<ul>
<li>Hystrix 已停止维护，推荐用 Resilience4j 或 Sentinel。</li>
</ul>
<hr>
<h2 id="10-Hystrix-的线程池隔离和信号量隔离？"><a href="#10-Hystrix-的线程池隔离和信号量隔离？" class="headerlink" title="10. Hystrix 的线程池隔离和信号量隔离？"></a><strong>10. Hystrix 的线程池隔离和信号量隔离？</strong></h2><p><strong>核心回答</strong></p>
<ul>
<li><strong>线程池隔离</strong>：每个依赖用独立线程池，适合耗时操作。</li>
<li><strong>信号量隔离</strong>：限制并发数，不开线程池，适合低延迟操作。</li>
</ul>
<p><strong>深入原理</strong></p>
<ul>
<li>线程池隔离：开销大，但最安全。</li>
<li>信号量隔离：轻量，但不能防止调用阻塞线程。</li>
</ul>
<p><strong>面试延伸</strong></p>
<ul>
<li>实战经验：大多数 IO 调用用线程池隔离，本地计算或轻量调用用信号量隔离。</li>
</ul>
<hr>
<h2 id="11-Resilience4j-和-Hystrix-区别？"><a href="#11-Resilience4j-和-Hystrix-区别？" class="headerlink" title="11. Resilience4j 和 Hystrix 区别？"></a><strong>11. Resilience4j 和 Hystrix 区别？</strong></h2><ul>
<li>Resilience4j 基于 Java 8 函数式接口，更轻量，支持熔断、限流、重试、隔离等；</li>
<li>Hystrix 已停止维护，功能单一（熔断+线程隔离）。</li>
<li>Resilience4j 模块化，可按需引入。</li>
</ul>
<hr>
<h2 id="12-Gateway-的核心功能？"><a href="#12-Gateway-的核心功能？" class="headerlink" title="12. Gateway 的核心功能？"></a><strong>12. Gateway 的核心功能？</strong></h2><ul>
<li><strong>路由转发</strong>（根据路径、Header、参数转发请求）。</li>
<li><strong>过滤器机制</strong>（统一鉴权、日志、限流）。</li>
<li><strong>负载均衡</strong>（结合注册中心）。</li>
<li><strong>协议支持</strong>（WebSocket、HTTPS）。</li>
</ul>
<hr>
<h2 id="13-Gateway-和-Zuul-的区别？"><a href="#13-Gateway-和-Zuul-的区别？" class="headerlink" title="13. Gateway 和 Zuul 的区别？"></a><strong>13. Gateway 和 Zuul 的区别？</strong></h2><ul>
<li>Zuul1 基于 Servlet，阻塞 IO，性能差。</li>
<li>Gateway 基于 Netty + Reactor，支持响应式，性能高。</li>
<li>Zuul2 虽然改为异步，但生态上 Gateway 更推荐。</li>
</ul>
<hr>
<h2 id="14-Config-Server-的作用？"><a href="#14-Config-Server-的作用？" class="headerlink" title="14. Config Server 的作用？"></a><strong>14. Config Server 的作用？</strong></h2><ul>
<li>统一管理微服务配置，支持 Git、SVN 等存储。</li>
<li>动态刷新配置，保证环境一致性。</li>
<li>与 Bus 结合可广播刷新。</li>
</ul>
<hr>
<h2 id="15-Config-Server-如何保证配置实时刷新？"><a href="#15-Config-Server-如何保证配置实时刷新？" class="headerlink" title="15. Config Server 如何保证配置实时刷新？"></a><strong>15. Config Server 如何保证配置实时刷新？</strong></h2><ul>
<li>客户端通过 <code>@RefreshScope</code> 实现动态刷新。</li>
<li>手动触发 <code>/actuator/refresh</code>。</li>
<li>结合 Spring Cloud Bus，可用消息队列广播刷新。</li>
</ul>
<hr>
<h2 id="16-Spring-Cloud-Bus-的原理？"><a href="#16-Spring-Cloud-Bus-的原理？" class="headerlink" title="16. Spring Cloud Bus 的原理？"></a><strong>16. Spring Cloud Bus 的原理？</strong></h2><ul>
<li>底层基于消息队列（Kafka、RabbitMQ）。</li>
<li>当配置变更时，Bus 广播事件，所有服务接收并刷新配置。</li>
</ul>
<hr>
<h2 id="17-Sleuth-的作用？"><a href="#17-Sleuth-的作用？" class="headerlink" title="17. Sleuth 的作用？"></a><strong>17. Sleuth 的作用？</strong></h2><ul>
<li>在微服务调用链路中，自动生成 <strong>TraceId &#x2F; SpanId</strong>。</li>
<li>实现请求链路追踪，定位性能瓶颈。</li>
</ul>
<hr>
<h2 id="18-Sleuth-与-Zipkin-的关系？"><a href="#18-Sleuth-与-Zipkin-的关系？" class="headerlink" title="18. Sleuth 与 Zipkin 的关系？"></a><strong>18. Sleuth 与 Zipkin 的关系？</strong></h2><ul>
<li>Sleuth：负责埋点、生成日志。</li>
<li>Zipkin：负责收集、存储、展示调用链数据。</li>
</ul>
<hr>
<h2 id="19-分布式链路追踪的原理？"><a href="#19-分布式链路追踪的原理？" class="headerlink" title="19. 分布式链路追踪的原理？"></a><strong>19. 分布式链路追踪的原理？</strong></h2><ul>
<li>通过唯一 TraceId 贯穿整个调用链。</li>
<li>每次远程调用生成新的 SpanId。</li>
<li>数据上报到集中式系统（Zipkin&#x2F;Jaeger）。</li>
</ul>
<hr>
<h2 id="20-Spring-Cloud-Stream-的作用？"><a href="#20-Spring-Cloud-Stream-的作用？" class="headerlink" title="20. Spring Cloud Stream 的作用？"></a><strong>20. Spring Cloud Stream 的作用？</strong></h2><ul>
<li>封装消息中间件（Kafka&#x2F;RabbitMQ）。</li>
<li>提供统一编程模型，屏蔽底层差异。</li>
<li>支持消息驱动架构。</li>
</ul>
<hr>
<h2 id="21-消息驱动模型和事件驱动模型区别？"><a href="#21-消息驱动模型和事件驱动模型区别？" class="headerlink" title="21. 消息驱动模型和事件驱动模型区别？"></a><strong>21. 消息驱动模型和事件驱动模型区别？</strong></h2><ul>
<li>消息驱动：强调解耦，消息可靠投递。</li>
<li>事件驱动：强调系统对事件的响应。</li>
<li>Spring Cloud Stream 更偏消息驱动，但也支持事件模式。</li>
</ul>
<hr>
<h2 id="22-Nacos-和-Eureka-的区别？"><a href="#22-Nacos-和-Eureka-的区别？" class="headerlink" title="22. Nacos 和 Eureka 的区别？"></a><strong>22. Nacos 和 Eureka 的区别？</strong></h2><ul>
<li>Nacos 除了服务注册发现，还提供配置中心功能。</li>
<li>Nacos 支持 <strong>AP&#x2F;CP 模式切换</strong>；Eureka 固定 AP。</li>
<li>Nacos 提供 UI，更易运维。</li>
</ul>
<hr>
<h2 id="23-Nacos-配置中心和注册中心的实现原理？"><a href="#23-Nacos-配置中心和注册中心的实现原理？" class="headerlink" title="23. Nacos 配置中心和注册中心的实现原理？"></a><strong>23. Nacos 配置中心和注册中心的实现原理？</strong></h2><ul>
<li>配置中心：基于推拉结合（长轮询 + Server 推送）。</li>
<li>注册中心：基于心跳机制维护服务健康状态。</li>
</ul>
<hr>
<h2 id="24-Sentinel-的工作原理？"><a href="#24-Sentinel-的工作原理？" class="headerlink" title="24. Sentinel 的工作原理？"></a><strong>24. Sentinel 的工作原理？</strong></h2><ul>
<li>基于 <strong>滑动窗口统计</strong> 请求 QPS、响应时间。</li>
<li>支持多种限流、熔断、降级规则。</li>
<li>与 Dubbo&#x2F;Spring Cloud&#x2F;Feign 无缝集成。</li>
</ul>
<hr>
<h2 id="25-限流的常见算法（令牌桶、漏桶）？"><a href="#25-限流的常见算法（令牌桶、漏桶）？" class="headerlink" title="25. 限流的常见算法（令牌桶、漏桶）？"></a><strong>25. 限流的常见算法（令牌桶、漏桶）？</strong></h2><ul>
<li><strong>令牌桶</strong>：系统以固定速率生成令牌，请求需拿到令牌才执行。</li>
<li><strong>漏桶</strong>：请求先进入桶，系统以固定速率处理，超出则丢弃。</li>
<li>区别：令牌桶允许突发流量，漏桶更平滑。</li>
</ul>
<hr>
<h2 id="26-熔断和降级的区别？"><a href="#26-熔断和降级的区别？" class="headerlink" title="26. 熔断和降级的区别？"></a><strong>26. 熔断和降级的区别？</strong></h2><ul>
<li>熔断：系统保护机制，拒绝调用，防止雪崩。</li>
<li>降级：业务兜底方案，返回备用结果。</li>
<li>熔断是“硬防护”，降级是“软兜底”。</li>
</ul>
<hr>
<h2 id="27-CAP-定理和-Spring-Cloud-的关系？"><a href="#27-CAP-定理和-Spring-Cloud-的关系？" class="headerlink" title="27. CAP 定理和 Spring Cloud 的关系？"></a><strong>27. CAP 定理和 Spring Cloud 的关系？</strong></h2><ul>
<li>CAP：一致性（C）、可用性（A）、分区容错性（P）。</li>
<li>Eureka → AP；Consul → CP；Nacos → AP&#x2F;CP 切换。</li>
</ul>
<hr>
<h2 id="28-Spring-Cloud-与-Kubernetes-的关系？"><a href="#28-Spring-Cloud-与-Kubernetes-的关系？" class="headerlink" title="28. Spring Cloud 与 Kubernetes 的关系？"></a><strong>28. Spring Cloud 与 Kubernetes 的关系？</strong></h2><ul>
<li>Spring Cloud：偏应用层，开发框架。</li>
<li>Kubernetes：偏基础设施，容器编排。</li>
<li>可结合使用：Spring Cloud 负责应用治理，K8s 负责资源调度。</li>
</ul>
<hr>
<h2 id="29-微服务中的灰度发布？"><a href="#29-微服务中的灰度发布？" class="headerlink" title="29. 微服务中的灰度发布？"></a><strong>29. 微服务中的灰度发布？</strong></h2><ul>
<li>指新版本只对部分用户开放。</li>
<li>实现方式：<ul>
<li>Nginx&#x2F;Gateway 按用户 ID 或流量比例路由。</li>
<li>Service Mesh（Istio）支持更灵活的流量控制。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="30-Spring-Cloud-如何实现服务网格？"><a href="#30-Spring-Cloud-如何实现服务网格？" class="headerlink" title="30. Spring Cloud 如何实现服务网格？"></a><strong>30. Spring Cloud 如何实现服务网格？</strong></h2><ul>
<li>原生 Spring Cloud 偏 SDK 模式，缺乏服务网格能力。</li>
<li>可结合 <strong>Spring Cloud + Istio&#x2F;Envoy</strong>，实现流量治理、观测、熔断、灰度。</li>
<li>越来越多团队采用 <strong>Spring Cloud Alibaba + Service Mesh</strong> 的混合方案。</li>
</ul>
<hr>
<h2 id="六、微服务架构-分布式系统（30题）"><a href="#六、微服务架构-分布式系统（30题）" class="headerlink" title="六、微服务架构 &amp; 分布式系统（30题）"></a>六、微服务架构 &amp; 分布式系统（30题）</h2><hr>
<h2 id="1-什么是微服务？"><a href="#1-什么是微服务？" class="headerlink" title="1. 什么是微服务？"></a><strong>1. 什么是微服务？</strong></h2><p><strong>核心回答</strong><br> 微服务是一种架构风格，将单体应用拆分为一组小型、独立部署的服务，每个服务聚焦某个业务能力，通过 API（HTTP&#x2F;gRPC&#x2F;MQ）通信。</p>
<p><strong>深入原理</strong></p>
<ul>
<li>每个服务独立开发、部署、扩容。</li>
<li>服务自治：有自己的数据库、缓存、逻辑。</li>
<li>通常结合容器化、CI&#x2F;CD、服务治理框架（如 Spring Cloud、Dubbo、K8s）。</li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试追问：和单体应用区别？ → 单体耦合度高，微服务解耦但更复杂。</li>
</ul>
<hr>
<h2 id="2-微服务与-SOA-的区别？"><a href="#2-微服务与-SOA-的区别？" class="headerlink" title="2. 微服务与 SOA 的区别？"></a><strong>2. 微服务与 SOA 的区别？</strong></h2><p><strong>核心回答</strong></p>
<ul>
<li><strong>SOA</strong>：面向服务的架构，通常依赖 ESB（企业服务总线）。</li>
<li><strong>微服务</strong>：轻量级、去中心化，强调小而独立，常用 REST&#x2F;gRPC。</li>
</ul>
<p><strong>深入原理</strong></p>
<ul>
<li>SOA → 偏企业内部，服务较大，依赖统一中间件（如 ESB）。</li>
<li>微服务 → 服务更小，避免单点中心，强调去中心化自治。</li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试追问：为什么微服务比 SOA 更流行？ → 云原生背景下，微服务更适应敏捷开发和快速迭代。</li>
</ul>
<hr>
<h2 id="3-微服务的优缺点？"><a href="#3-微服务的优缺点？" class="headerlink" title="3. 微服务的优缺点？"></a><strong>3. 微服务的优缺点？</strong></h2><p><strong>核心回答</strong></p>
<ul>
<li>优点：独立部署、技术多样性、弹性伸缩、快速迭代。</li>
<li>缺点：分布式复杂性、运维难度高、数据一致性挑战、服务治理成本高。</li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试官常问：什么时候不适合微服务？ → 业务小、团队小、系统简单时。</li>
</ul>
<hr>
<h2 id="4-微服务的拆分原则？"><a href="#4-微服务的拆分原则？" class="headerlink" title="4. 微服务的拆分原则？"></a><strong>4. 微服务的拆分原则？</strong></h2><p><strong>核心回答</strong></p>
<ul>
<li>按业务边界（DDD 的领域驱动设计）。</li>
<li>高内聚、低耦合。</li>
<li>一个服务只聚焦一个核心业务能力。</li>
</ul>
<p><strong>深入原理</strong></p>
<ul>
<li>拆分方式：按业务（订单、用户、支付）、按场景（核心 vs 辅助）、按非功能需求（性能瓶颈点）。</li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>常见错误：按数据库表拆分，导致过度依赖跨服务调用。</li>
</ul>
<hr>
<h2 id="5-如何保证微服务之间的数据一致性？"><a href="#5-如何保证微服务之间的数据一致性？" class="headerlink" title="5. 如何保证微服务之间的数据一致性？"></a><strong>5. 如何保证微服务之间的数据一致性？</strong></h2><p><strong>核心回答</strong></p>
<ul>
<li>避免强一致，采用 <strong>最终一致性</strong>。</li>
<li>方案：分布式事务、消息驱动、补偿机制。</li>
</ul>
<p><strong>深入原理</strong></p>
<ul>
<li>同步方案：XA（两阶段提交）。</li>
<li>异步方案：TCC、SAGA、可靠消息。</li>
</ul>
<p><strong>延伸思考</strong></p>
<ul>
<li>面试官追问：你在项目中怎么做？ → 消息队列（事务消息&#x2F;本地消息表）。</li>
</ul>
<hr>
<h2 id="6-分布式事务有哪些解决方案？"><a href="#6-分布式事务有哪些解决方案？" class="headerlink" title="6. 分布式事务有哪些解决方案？"></a><strong>6. 分布式事务有哪些解决方案？</strong></h2><p><strong>核心回答</strong></p>
<ul>
<li>XA（两阶段提交）</li>
<li>TCC（Try-Confirm-Cancel）</li>
<li>SAGA（长事务补偿）</li>
<li>本地消息表 &#x2F; 事务消息</li>
</ul>
<p><strong>深入原理</strong></p>
<ul>
<li>XA：强一致性，但性能差。</li>
<li>TCC：业务入侵高，但灵活。</li>
<li>SAGA：长事务场景，失败时用补偿。</li>
<li>本地消息表：保证最终一致性。</li>
</ul>
<hr>
<h2 id="7-TCC、SAGA、XA-的区别？"><a href="#7-TCC、SAGA、XA-的区别？" class="headerlink" title="7. TCC、SAGA、XA 的区别？"></a><strong>7. TCC、SAGA、XA 的区别？</strong></h2><ul>
<li><strong>XA</strong>：数据库层两阶段提交，强一致，性能差。</li>
<li><strong>TCC</strong>：应用层三步（预留资源、确认、回滚），侵入性高。</li>
<li><strong>SAGA</strong>：长事务，每步都有补偿动作，保证最终一致性。</li>
</ul>
<hr>
<h2 id="8-本地消息表和可靠消息最终一致性？"><a href="#8-本地消息表和可靠消息最终一致性？" class="headerlink" title="8. 本地消息表和可靠消息最终一致性？"></a><strong>8. 本地消息表和可靠消息最终一致性？</strong></h2><ul>
<li>本地消息表：在本地事务中写业务表 + 消息表 → MQ 异步投递 → 消费端确认。</li>
<li>可靠消息：MQ 支持事务（如 RocketMQ 半消息），确保消息必达，保证最终一致性。</li>
</ul>
<hr>
<h2 id="9-分布式锁的实现方式？"><a href="#9-分布式锁的实现方式？" class="headerlink" title="9. 分布式锁的实现方式？"></a><strong>9. 分布式锁的实现方式？</strong></h2><ul>
<li>数据库锁（悲观锁&#x2F;唯一索引）。</li>
<li>Redis 分布式锁（setnx + expire）。</li>
<li>Zookeeper 分布式锁（临时顺序节点）。</li>
</ul>
<hr>
<h2 id="10-Redis-分布式锁的缺陷？"><a href="#10-Redis-分布式锁的缺陷？" class="headerlink" title="10. Redis 分布式锁的缺陷？"></a><strong>10. Redis 分布式锁的缺陷？</strong></h2><ul>
<li>单点问题（需 Redis Cluster 或 Redlock）。</li>
<li>锁过期可能导致误释放。</li>
<li>不能保证严格公平。</li>
</ul>
<hr>
<h2 id="11-Zookeeper-分布式锁的实现？"><a href="#11-Zookeeper-分布式锁的实现？" class="headerlink" title="11. Zookeeper 分布式锁的实现？"></a><strong>11. Zookeeper 分布式锁的实现？</strong></h2><ul>
<li>利用 <strong>临时顺序节点</strong>：<ul>
<li>客户端创建顺序节点。</li>
<li>判断自己是否是最小节点 → 获取锁。</li>
<li>不是则监听前一个节点的删除事件。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="12-数据库分库分表策略？"><a href="#12-数据库分库分表策略？" class="headerlink" title="12. 数据库分库分表策略？"></a><strong>12. 数据库分库分表策略？</strong></h2><ul>
<li>垂直分库（按业务拆分）。</li>
<li>水平分表（按用户 ID、时间做分片）。</li>
<li>常见路由方式：哈希取模、范围、时间。</li>
</ul>
<hr>
<h2 id="13-水平拆分与垂直拆分区别？"><a href="#13-水平拆分与垂直拆分区别？" class="headerlink" title="13. 水平拆分与垂直拆分区别？"></a><strong>13. 水平拆分与垂直拆分区别？</strong></h2><ul>
<li><strong>水平拆分</strong>：同一张表的数据分到多个库表（按范围&#x2F;哈希）。</li>
<li><strong>垂直拆分</strong>：不同业务表放到不同库（用户库、订单库）。</li>
</ul>
<hr>
<h2 id="14-分布式-ID-生成方案？"><a href="#14-分布式-ID-生成方案？" class="headerlink" title="14. 分布式 ID 生成方案？"></a><strong>14. 分布式 ID 生成方案？</strong></h2><ul>
<li>UUID（无序，不适合数据库）。</li>
<li>数据库自增 ID（单点瓶颈）。</li>
<li>Redis 自增。</li>
<li>雪花算法（Snowflake）。</li>
<li>Leaf（美团开源）。</li>
</ul>
<hr>
<h2 id="15-雪花算法的原理？"><a href="#15-雪花算法的原理？" class="headerlink" title="15. 雪花算法的原理？"></a><strong>15. 雪花算法的原理？</strong></h2><ul>
<li>64 位长整型：<ul>
<li>时间戳（41 位）</li>
<li>机器 ID（10 位）</li>
<li>序列号（12 位）</li>
</ul>
</li>
<li>保证全局唯一、有序。</li>
</ul>
<hr>
<h2 id="16-API-网关的作用？"><a href="#16-API-网关的作用？" class="headerlink" title="16. API 网关的作用？"></a><strong>16. API 网关的作用？</strong></h2><ul>
<li>统一入口，做路由转发。</li>
<li>鉴权、安全控制。</li>
<li>流量控制、熔断、降级。</li>
<li>日志监控。</li>
</ul>
<hr>
<h2 id="17-服务注册与发现机制？"><a href="#17-服务注册与发现机制？" class="headerlink" title="17. 服务注册与发现机制？"></a><strong>17. 服务注册与发现机制？</strong></h2><ul>
<li>服务启动 → 注册中心注册（IP&#x2F;端口&#x2F;状态）。</li>
<li>调用方 → 从注册中心获取地址列表。</li>
<li>注册中心 → 通过心跳维持健康状态。</li>
</ul>
<hr>
<h2 id="18-微服务如何保证高可用？"><a href="#18-微服务如何保证高可用？" class="headerlink" title="18. 微服务如何保证高可用？"></a><strong>18. 微服务如何保证高可用？</strong></h2><ul>
<li>服务冗余（多实例部署）。</li>
<li>负载均衡。</li>
<li>熔断、降级、限流。</li>
<li>自动故障转移（K8s + 服务治理框架）。</li>
</ul>
<hr>
<h2 id="19-微服务中的限流和熔断？"><a href="#19-微服务中的限流和熔断？" class="headerlink" title="19. 微服务中的限流和熔断？"></a><strong>19. 微服务中的限流和熔断？</strong></h2><ul>
<li>限流：控制流量，保护系统（令牌桶&#x2F;漏桶）。</li>
<li>熔断：当下游服务异常时，直接失败并快速返回。</li>
</ul>
<hr>
<h2 id="20-微服务如何保证安全性？"><a href="#20-微服务如何保证安全性？" class="headerlink" title="20. 微服务如何保证安全性？"></a><strong>20. 微服务如何保证安全性？</strong></h2><ul>
<li>认证授权（OAuth2、JWT）。</li>
<li>HTTPS、加密通信。</li>
<li>API 网关统一鉴权。</li>
<li>数据脱敏。</li>
</ul>
<hr>
<h2 id="21-OAuth2-的原理？"><a href="#21-OAuth2-的原理？" class="headerlink" title="21. OAuth2 的原理？"></a><strong>21. OAuth2 的原理？</strong></h2><ul>
<li>基于令牌的认证授权协议。</li>
<li>四种模式：授权码、密码、客户端凭证、简化模式。</li>
<li>典型流程：用户 → 授权服务器 → 获取 Token → 调用资源服务器。</li>
</ul>
<hr>
<h2 id="22-JWT-的作用？"><a href="#22-JWT-的作用？" class="headerlink" title="22. JWT 的作用？"></a><strong>22. JWT 的作用？</strong></h2><ul>
<li>JSON Web Token，一种无状态令牌。</li>
<li>内容包含三部分：Header、Payload、Signature。</li>
<li>适合分布式系统做认证，无需存储 Session。</li>
</ul>
<hr>
<h2 id="23-单点登录-SSO-的实现？"><a href="#23-单点登录-SSO-的实现？" class="headerlink" title="23. 单点登录 SSO 的实现？"></a><strong>23. 单点登录 SSO 的实现？</strong></h2><ul>
<li>用户只需登录一次，获取全局 Token&#x2F;Session。</li>
<li>常见实现：CAS、OAuth2、JWT。</li>
<li>核心：统一认证中心。</li>
</ul>
<hr>
<h2 id="24-配置中心的作用？"><a href="#24-配置中心的作用？" class="headerlink" title="24. 配置中心的作用？"></a><strong>24. 配置中心的作用？</strong></h2><ul>
<li>集中化配置管理。</li>
<li>支持动态刷新。</li>
<li>环境隔离（dev&#x2F;test&#x2F;prod）。</li>
</ul>
<hr>
<h2 id="25-微服务中的监控体系？"><a href="#25-微服务中的监控体系？" class="headerlink" title="25. 微服务中的监控体系？"></a><strong>25. 微服务中的监控体系？</strong></h2><ul>
<li>指标监控：Prometheus + Grafana。</li>
<li>日志监控：ELK（Elasticsearch + Logstash + Kibana）。</li>
<li>链路追踪：Sleuth + Zipkin&#x2F;Jaeger。</li>
</ul>
<hr>
<h2 id="26-Prometheus-的原理？"><a href="#26-Prometheus-的原理？" class="headerlink" title="26. Prometheus 的原理？"></a><strong>26. Prometheus 的原理？</strong></h2><ul>
<li>基于 Pull 模型，定期从应用&#x2F;Exporter 拉取指标。</li>
<li>TSDB（时间序列数据库）存储数据。</li>
<li>结合 Grafana 做可视化。</li>
</ul>
<hr>
<h2 id="27-ELK-在微服务中的应用？"><a href="#27-ELK-在微服务中的应用？" class="headerlink" title="27. ELK 在微服务中的应用？"></a><strong>27. ELK 在微服务中的应用？</strong></h2><ul>
<li>Logstash：日志采集。</li>
<li>Elasticsearch：日志存储、搜索。</li>
<li>Kibana：日志分析、可视化。</li>
<li>用于统一日志平台。</li>
</ul>
<hr>
<h2 id="28-服务调用链路追踪的意义？"><a href="#28-服务调用链路追踪的意义？" class="headerlink" title="28. 服务调用链路追踪的意义？"></a><strong>28. 服务调用链路追踪的意义？</strong></h2><ul>
<li>解决“调用链不清楚”的问题。</li>
<li>快速定位性能瓶颈、错误位置。</li>
<li>提升运维可观测性。</li>
</ul>
<hr>
<h2 id="29-服务雪崩效应是什么？"><a href="#29-服务雪崩效应是什么？" class="headerlink" title="29. 服务雪崩效应是什么？"></a><strong>29. 服务雪崩效应是什么？</strong></h2><ul>
<li>一个服务故障 → 引发调用它的服务故障 → 最终导致整个系统崩溃。</li>
<li>原因：依赖调用无保护（无熔断&#x2F;限流）。</li>
</ul>
<hr>
<h2 id="30-如何设计一个高并发的微服务系统？"><a href="#30-如何设计一个高并发的微服务系统？" class="headerlink" title="30. 如何设计一个高并发的微服务系统？"></a><strong>30. 如何设计一个高并发的微服务系统？</strong></h2><p><strong>核心思路</strong></p>
<ul>
<li>架构：微服务 + API 网关 + 服务治理。</li>
<li>高可用：负载均衡、多副本、自动故障转移。</li>
<li>高性能：缓存（Redis）、异步化、限流、降级。</li>
<li>数据层：分库分表、读写分离。</li>
<li>安全：OAuth2&#x2F;JWT。</li>
<li>可观测性：监控 + 日志 + 链路追踪。</li>
</ul>
<hr>
<h2 id="七、数据库-缓存（30题）"><a href="#七、数据库-缓存（30题）" class="headerlink" title="七、数据库 &amp; 缓存（30题）"></a>七、数据库 &amp; 缓存（30题）</h2><hr>
<h2 id="1-MySQL-的存储引擎区别"><a href="#1-MySQL-的存储引擎区别" class="headerlink" title="1. MySQL 的存储引擎区别"></a><strong>1. MySQL 的存储引擎区别</strong></h2><ul>
<li><strong>存储引擎</strong>是 MySQL 管理数据的底层组件，决定了数据存储方式、事务支持、锁机制、索引支持等。</li>
<li><strong>主要存储引擎</strong>：<ul>
<li><strong>InnoDB</strong>：事务型，支持行级锁、外键、MVCC、崩溃恢复。适合高并发、事务要求高的场景。</li>
<li><strong>MyISAM</strong>：非事务型，表级锁，支持全文索引。适合读多写少、日志或统计类表。</li>
<li><strong>Memory</strong>：数据存储在内存中，访问速度快，但断电数据丢失。适合临时表。</li>
<li><strong>Archive</strong>：归档引擎，只支持插入和查询，不支持更新，压缩存储。</li>
</ul>
</li>
<li><strong>面试重点</strong>：<ul>
<li>选择存储引擎需根据业务需求：事务要求、并发量、数据量和恢复策略。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-InnoDB-和-MyISAM-的区别"><a href="#2-InnoDB-和-MyISAM-的区别" class="headerlink" title="2. InnoDB 和 MyISAM 的区别"></a><strong>2. InnoDB 和 MyISAM 的区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>支持 ACID</td>
<td>不支持</td>
</tr>
<tr>
<td>锁类型</td>
<td>行级锁+表锁</td>
<td>表级锁</td>
</tr>
<tr>
<td>外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>崩溃恢复</td>
<td>自动恢复</td>
<td>需手动修复</td>
</tr>
<tr>
<td>全文索引</td>
<td>5.6+ 支持</td>
<td>支持</td>
</tr>
<tr>
<td>并发场景</td>
<td>高并发写+读</td>
<td>读多写少</td>
</tr>
<tr>
<td>适用案例</td>
<td>金融、电商订单</td>
<td>日志分析、统计表</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-MySQL-事务特性"><a href="#3-MySQL-事务特性" class="headerlink" title="3. MySQL 事务特性"></a><strong>3. MySQL 事务特性</strong></h2><ul>
<li><strong>ACID 原则</strong>：<ol>
<li><strong>原子性（Atomic）</strong>：事务全部执行或全部回滚。</li>
<li><strong>一致性（Consistency）</strong>：事务执行前后数据库状态合法。</li>
<li><strong>隔离性（Isolation）</strong>：事务互不干扰。</li>
<li><strong>持久性（Durability）</strong>：提交后数据不会丢失。</li>
</ol>
</li>
<li><strong>隔离级别</strong>：<ul>
<li><strong>Read Uncommitted</strong>：允许脏读。</li>
<li><strong>Read Committed</strong>：防止脏读，但可能不可重复读。</li>
<li><strong>Repeatable Read（默认 InnoDB）</strong>：防止不可重复读，间隙锁解决幻读。</li>
<li><strong>Serializable</strong>：完全串行执行，性能最低，但完全隔离。</li>
</ul>
</li>
<li><strong>面试追问</strong>：隔离级别与死锁、性能的权衡。</li>
</ul>
<hr>
<h2 id="4-MVCC-的实现原理"><a href="#4-MVCC-的实现原理" class="headerlink" title="4. MVCC 的实现原理"></a><strong>4. MVCC 的实现原理</strong></h2><ul>
<li><strong>原理</strong>：<ul>
<li>InnoDB 为每行增加隐藏列 <code>trx_id</code> 和 <code>roll_pointer</code>。</li>
<li>查询时根据事务 ID 判断哪一版本可见。</li>
<li>读操作不阻塞写操作，实现 <strong>非阻塞读</strong>。</li>
</ul>
</li>
<li><strong>应用</strong>：提高并发性能，避免读写互相阻塞。</li>
<li><strong>面试追问</strong>：MVCC 如何实现 Repeatable Read，为什么不锁表。</li>
</ul>
<hr>
<h2 id="5-MySQL-的索引类型"><a href="#5-MySQL-的索引类型" class="headerlink" title="5. MySQL 的索引类型"></a><strong>5. MySQL 的索引类型</strong></h2><ul>
<li><strong>B+ 树索引</strong>：范围查询、排序，叶子节点按顺序连接。</li>
<li><strong>哈希索引</strong>：精确查找快（Memory 引擎）。</li>
<li><strong>全文索引</strong>：文本搜索。</li>
<li><strong>空间索引</strong>：地理信息查询（R-Tree）。</li>
<li><strong>面试追问</strong>：什么时候选择组合索引，覆盖索引优化查询。</li>
</ul>
<hr>
<h2 id="6-聚簇索引-vs-非聚簇索引"><a href="#6-聚簇索引-vs-非聚簇索引" class="headerlink" title="6. 聚簇索引 vs 非聚簇索引"></a><strong>6. 聚簇索引 vs 非聚簇索引</strong></h2><ul>
<li><strong>聚簇索引</strong>：<ul>
<li>数据行存储顺序与主键顺序一致。</li>
<li>查询范围、排序效率高。</li>
</ul>
</li>
<li><strong>非聚簇索引</strong>：<ul>
<li>索引存 key + 主键，回表获取其他字段。</li>
</ul>
</li>
<li><strong>面试追问</strong>：聚簇索引插入顺序对性能影响，回表成本。</li>
</ul>
<hr>
<h2 id="7-B-树索引原理"><a href="#7-B-树索引原理" class="headerlink" title="7. B+ 树索引原理"></a><strong>7. B+ 树索引原理</strong></h2><ul>
<li>内节点：存 key + 子节点指针</li>
<li>叶子节点：存完整记录或指针，并链表连接</li>
<li><strong>特点</strong>：<ul>
<li>支持范围查询</li>
<li>磁盘 IO 高效</li>
</ul>
</li>
<li><strong>面试追问</strong>：为什么 MySQL 选择 B+ 树而不是 B 树或 Hash。</li>
</ul>
<hr>
<h2 id="8-覆盖索引-vs-回表"><a href="#8-覆盖索引-vs-回表" class="headerlink" title="8. 覆盖索引 vs 回表"></a><strong>8. 覆盖索引 vs 回表</strong></h2><ul>
<li><strong>覆盖索引</strong>：索引包含所有查询字段，无需访问表。</li>
<li><strong>回表</strong>：索引只包含部分字段，需要通过主键查表。</li>
<li><strong>优化方法</strong>：尽量让热点查询使用覆盖索引，减少 IO。</li>
</ul>
<hr>
<h2 id="9-索引下推优化"><a href="#9-索引下推优化" class="headerlink" title="9. 索引下推优化"></a><strong>9. 索引下推优化</strong></h2><ul>
<li>WHERE 条件在存储引擎层过滤，减少返回上层的数据量。</li>
<li>特别在组合索引或函数查询时有效。</li>
<li><strong>面试追问</strong>：索引下推能否应用于非 InnoDB 存储引擎。</li>
</ul>
<hr>
<h2 id="10-MySQL-锁机制"><a href="#10-MySQL-锁机制" class="headerlink" title="10. MySQL 锁机制"></a><strong>10. MySQL 锁机制</strong></h2><ul>
<li><strong>表锁</strong>：锁整张表，低并发。</li>
<li><strong>行锁</strong>：锁单行，InnoDB 默认。</li>
<li><strong>意向锁</strong>：表级锁意图，避免死锁。</li>
<li><strong>间隙锁</strong>：防止幻读。</li>
<li><strong>面试追问</strong>：行锁、表锁的实现原理，锁冲突如何处理。</li>
</ul>
<hr>
<h2 id="11-行锁-vs-表锁"><a href="#11-行锁-vs-表锁" class="headerlink" title="11. 行锁 vs 表锁"></a><strong>11. 行锁 vs 表锁</strong></h2><ul>
<li>行锁：粒度小，高并发，事务安全。</li>
<li>表锁：粒度大，适合批量操作。</li>
<li><strong>应用场景</strong>：高并发写用行锁，批量更新可用表锁。</li>
</ul>
<hr>
<h2 id="12-间隙锁"><a href="#12-间隙锁" class="headerlink" title="12. 间隙锁"></a><strong>12. 间隙锁</strong></h2><ul>
<li>锁定索引间隙，防止其他事务插入幻读。</li>
<li>与记录锁结合形成 <strong>Next-Key Lock</strong>。</li>
<li>默认在 Repeatable Read 下使用。</li>
</ul>
<hr>
<h2 id="13-死锁排查"><a href="#13-死锁排查" class="headerlink" title="13. 死锁排查"></a><strong>13. 死锁排查</strong></h2><ul>
<li><code>SHOW ENGINE INNODB STATUS\G</code> 查看最新死锁。</li>
<li>优化：<ol>
<li>统一访问表顺序。</li>
<li>尽量缩短事务时间。</li>
<li>加索引减少扫描行数。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="14-SQL-执行计划"><a href="#14-SQL-执行计划" class="headerlink" title="14. SQL 执行计划"></a><strong>14. SQL 执行计划</strong></h2><ul>
<li>使用 <code>EXPLAIN</code> 分析：<ul>
<li>type：访问类型（ALL &lt; INDEX &lt; REF &lt; CONST）</li>
<li>key：使用的索引</li>
<li>rows：扫描行数</li>
<li>Extra：如 Using index, Using temporary</li>
</ul>
</li>
</ul>
<hr>
<h2 id="15-慢查询优化"><a href="#15-慢查询优化" class="headerlink" title="15. 慢查询优化"></a><strong>15. 慢查询优化</strong></h2><ul>
<li>建索引（覆盖索引、组合索引）</li>
<li>避免 SELECT *</li>
<li>避免在列上函数操作</li>
<li>分库分表</li>
<li>缓存（Redis&#x2F;Caffeine）</li>
</ul>
<hr>
<h2 id="16-分库分表难点"><a href="#16-分库分表难点" class="headerlink" title="16. 分库分表难点"></a><strong>16. 分库分表难点</strong></h2><ul>
<li>跨库 join、分页</li>
<li>分布式事务</li>
<li>全局唯一 ID</li>
<li>数据路由、迁移</li>
</ul>
<hr>
<h2 id="17-分布式事务"><a href="#17-分布式事务" class="headerlink" title="17. 分布式事务"></a><strong>17. 分布式事务</strong></h2><ul>
<li><strong>XA</strong>：两阶段提交，保证强一致性。</li>
<li><strong>TCC</strong>：Try → Confirm → Cancel，业务补偿操作。</li>
<li><strong>SAGA</strong>：长事务补偿。</li>
<li><strong>本地消息表 + MQ</strong>：最终一致性。</li>
</ul>
<hr>
<h2 id="18-Redis-数据结构"><a href="#18-Redis-数据结构" class="headerlink" title="18. Redis 数据结构"></a><strong>18. Redis 数据结构</strong></h2><ul>
<li><strong>String</strong>、<strong>Hash</strong>、<strong>List</strong>、<strong>Set</strong>、<strong>Sorted Set</strong></li>
<li>Bitmap、HyperLogLog、Geo</li>
<li>应用：排行榜、计数、集合操作、地理位置、布隆过滤器</li>
</ul>
<hr>
<h2 id="19-Redis-为什么快"><a href="#19-Redis-为什么快" class="headerlink" title="19. Redis 为什么快"></a><strong>19. Redis 为什么快</strong></h2><ul>
<li>全内存存储</li>
<li>单线程 + epoll</li>
<li>高效数据结构</li>
<li>避免锁竞争</li>
</ul>
<hr>
<h2 id="20-Redis-持久化"><a href="#20-Redis-持久化" class="headerlink" title="20. Redis 持久化"></a><strong>20. Redis 持久化</strong></h2><ul>
<li><strong>RDB</strong>：定期快照</li>
<li><strong>AOF</strong>：写命令日志，append only</li>
<li><strong>混合持久化</strong>：RDB + AOF，提高安全性与效率</li>
</ul>
<hr>
<h2 id="21-Redis-过期策略"><a href="#21-Redis-过期策略" class="headerlink" title="21. Redis 过期策略"></a><strong>21. Redis 过期策略</strong></h2><ul>
<li><strong>惰性删除</strong>：访问时检查 TTL</li>
<li><strong>定期删除</strong>：周期性扫描</li>
<li><strong>定时删除</strong>：每个 key 单独定时器</li>
</ul>
<hr>
<h2 id="22-Redis-内存淘汰策略"><a href="#22-Redis-内存淘汰策略" class="headerlink" title="22. Redis 内存淘汰策略"></a><strong>22. Redis 内存淘汰策略</strong></h2><ul>
<li>noeviction、allkeys-lru、volatile-lru、allkeys-lfu、volatile-ttl</li>
<li>LRU：最近最少使用</li>
<li>LFU：使用频率最低</li>
<li>TTL：临期优先淘汰</li>
</ul>
<hr>
<h2 id="23-Redis-主从复制"><a href="#23-Redis-主从复制" class="headerlink" title="23. Redis 主从复制"></a><strong>23. Redis 主从复制</strong></h2><ul>
<li>异步复制</li>
<li>全量复制 + 增量复制</li>
<li>读写分离，提升扩展性</li>
</ul>
<hr>
<h2 id="24-Redis-哨兵机制"><a href="#24-Redis-哨兵机制" class="headerlink" title="24. Redis 哨兵机制"></a><strong>24. Redis 哨兵机制</strong></h2><ul>
<li>监控、通知、故障转移</li>
<li>Sentinel 投票机制切换主节点</li>
<li>高可用架构核心组件</li>
</ul>
<hr>
<h2 id="25-Redis-集群模式"><a href="#25-Redis-集群模式" class="headerlink" title="25. Redis 集群模式"></a><strong>25. Redis 集群模式</strong></h2><ul>
<li>16384 个哈希槽分片</li>
<li>Master + Slave</li>
<li>跨槽操作有限制</li>
<li>高可用 + 水平扩展</li>
</ul>
<hr>
<h2 id="26-Redis-分布式锁"><a href="#26-Redis-分布式锁" class="headerlink" title="26. Redis 分布式锁"></a><strong>26. Redis 分布式锁</strong></h2><ul>
<li><strong>单机</strong>：SETNX + EXPIRE</li>
<li><strong>Redisson</strong>：<ul>
<li>自动续期（看门狗机制）</li>
<li>可重入锁</li>
<li>公平锁</li>
</ul>
</li>
<li><strong>RedLock</strong>：多节点强一致性</li>
</ul>
<hr>
<h2 id="27-Redis-常见问题"><a href="#27-Redis-常见问题" class="headerlink" title="27. Redis 常见问题"></a><strong>27. Redis 常见问题</strong></h2><ul>
<li>内存不足 &#x2F; OOM</li>
<li>热点 key</li>
<li>bigkey 导致阻塞</li>
<li>RDB fork 阻塞</li>
<li>主从延迟</li>
</ul>
<hr>
<h2 id="28-缓存穿透、击穿、雪崩"><a href="#28-缓存穿透、击穿、雪崩" class="headerlink" title="28. 缓存穿透、击穿、雪崩"></a><strong>28. 缓存穿透、击穿、雪崩</strong></h2><ul>
<li><strong>穿透</strong>：不存在数据频繁访问 → 布隆过滤器</li>
<li><strong>击穿</strong>：热点 key 瞬间失效 → 互斥锁&#x2F;永不过期缓存</li>
<li><strong>雪崩</strong>：大量 key 同时过期 → TTL + 随机值</li>
</ul>
<hr>
<h2 id="29-缓存与数据库一致性"><a href="#29-缓存与数据库一致性" class="headerlink" title="29. 缓存与数据库一致性"></a><strong>29. 缓存与数据库一致性</strong></h2><ul>
<li><strong>Cache Aside</strong>：先 DB，再删缓存</li>
<li><strong>双写</strong>：DB + 缓存同步更新</li>
<li><strong>异步消息</strong>：MQ + 延时队列，实现最终一致性</li>
</ul>
<hr>
<h2 id="30-Redis-vs-Caffeine"><a href="#30-Redis-vs-Caffeine" class="headerlink" title="30. Redis vs Caffeine"></a><strong>30. Redis vs Caffeine</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>Redis</th>
<th>Caffeine</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>分布式缓存</td>
<td>本地缓存</td>
</tr>
<tr>
<td>持久化</td>
<td>RDB &#x2F; AOF</td>
<td>不支持</td>
</tr>
<tr>
<td>集群</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>访问速度</td>
<td>毫秒级</td>
<td>纳秒级</td>
</tr>
<tr>
<td>场景</td>
<td>分布式共享，高并发</td>
<td>本地热点缓存</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong>：Caffeine（本地缓存）+ Redis（分布式缓存）+ DB → 多级缓存结构。</p>
<hr>
<h2 id="八、消息队列（30题）"><a href="#八、消息队列（30题）" class="headerlink" title="八、消息队列（30题）"></a>八、消息队列（30题）</h2><hr>
<h2 id="1-为什么要使用消息队列？"><a href="#1-为什么要使用消息队列？" class="headerlink" title="1. 为什么要使用消息队列？"></a><strong>1. 为什么要使用消息队列？</strong></h2><ul>
<li><strong>解耦系统</strong>：生产者与消费者不直接调用，通过队列传递消息。</li>
<li><strong>异步处理</strong>：用户请求不等待后端业务完成，提高响应速度。</li>
<li><strong>削峰填谷</strong>：缓冲高峰流量，避免数据库或服务压力过大。</li>
<li><strong>可靠传输</strong>：通过持久化、ACK 机制保证消息不丢失。</li>
<li><strong>可扩展性</strong>：增加消费者可水平扩展，提高系统吞吐量。</li>
<li><strong>面试追问</strong>：为什么 MQ 可以解决微服务间耦合问题？</li>
</ul>
<hr>
<h2 id="2-消息队列的优缺点"><a href="#2-消息队列的优缺点" class="headerlink" title="2. 消息队列的优缺点"></a><strong>2. 消息队列的优缺点</strong></h2><ul>
<li><strong>优点</strong>：<ul>
<li>异步处理提升吞吐量</li>
<li>系统解耦</li>
<li>支持削峰填谷</li>
<li>消息可靠性可控</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>系统复杂度增加</li>
<li>消息延迟</li>
<li>顺序和重复消费需要额外处理</li>
</ul>
</li>
<li><strong>优化点</strong>：结合幂等设计、延迟队列和批量处理</li>
</ul>
<hr>
<h2 id="3-RabbitMQ-核心组件"><a href="#3-RabbitMQ-核心组件" class="headerlink" title="3. RabbitMQ 核心组件"></a><strong>3. RabbitMQ 核心组件</strong></h2><ul>
<li><strong>Producer</strong>：发送消息</li>
<li><strong>Exchange</strong>：路由消息（Direct、Fanout、Topic、Headers）</li>
<li><strong>Queue</strong>：存储消息</li>
<li><strong>Binding</strong>：绑定 Exchange 和 Queue</li>
<li><strong>Consumer</strong>：接收消息</li>
<li><strong>原理</strong>：Exchange 决定路由规则，Queue 负责缓冲和投递</li>
</ul>
<hr>
<h2 id="4-RabbitMQ-消息确认机制"><a href="#4-RabbitMQ-消息确认机制" class="headerlink" title="4. RabbitMQ 消息确认机制"></a><strong>4. RabbitMQ 消息确认机制</strong></h2><ul>
<li><strong>生产者端</strong>：<ul>
<li>Publisher Confirm，确保消息写入 Broker</li>
</ul>
</li>
<li><strong>消费者端</strong>：<ul>
<li>自动 ack：消费即确认</li>
<li>手动 ack：成功处理后确认</li>
</ul>
</li>
<li><strong>应用实践</strong>：手动 ack 可处理异常重试，保证消息不丢失</li>
</ul>
<hr>
<h2 id="5-Kafka-核心概念"><a href="#5-Kafka-核心概念" class="headerlink" title="5. Kafka 核心概念"></a><strong>5. Kafka 核心概念</strong></h2><ul>
<li><strong>Producer&#x2F;Consumer</strong>：消息发送和接收</li>
<li><strong>Topic&#x2F;Partition</strong>：主题和分区</li>
<li><strong>Broker&#x2F;Cluster</strong>：节点和集群</li>
<li><strong>Consumer Group</strong>：消费组实现负载均衡</li>
<li><strong>Offset</strong>：记录消费位置</li>
<li><strong>原理</strong>：生产者写入 Partition，消费者根据 Offset 消费</li>
</ul>
<hr>
<h2 id="6-Kafka-分区机制"><a href="#6-Kafka-分区机制" class="headerlink" title="6. Kafka 分区机制"></a><strong>6. Kafka 分区机制</strong></h2><ul>
<li><strong>Partition 提高并行</strong></li>
<li><strong>分区内顺序保证</strong></li>
<li><strong>路由策略</strong>：默认轮询，或 Key 哈希分区</li>
<li><strong>面试点</strong>：如何保证全局顺序？只能保证分区内顺序</li>
</ul>
<hr>
<h2 id="7-Kafka-副本机制"><a href="#7-Kafka-副本机制" class="headerlink" title="7. Kafka 副本机制"></a><strong>7. Kafka 副本机制</strong></h2><ul>
<li><strong>Leader&#x2F;Follower 结构</strong></li>
<li><strong>同步机制</strong>：ISR 列表跟随 Leader</li>
<li><strong>高可用</strong>：Leader 异常自动切换</li>
<li><strong>面试拓展</strong>：副本同步模式对性能的影响</li>
</ul>
<hr>
<h2 id="8-Kafka-ISR-原理"><a href="#8-Kafka-ISR-原理" class="headerlink" title="8. Kafka ISR 原理"></a><strong>8. Kafka ISR 原理</strong></h2><ul>
<li><strong>ISR（In-Sync Replicas）</strong>：跟上 Leader 的副本集合</li>
<li><strong>消息提交规则</strong>：只要 ISR 内副本写入才算成功</li>
<li><strong>优化</strong>：副本数量与 ACK 策略可调节可靠性与吞吐量</li>
</ul>
<hr>
<h2 id="9-Kafka-消费组原理"><a href="#9-Kafka-消费组原理" class="headerlink" title="9. Kafka 消费组原理"></a><strong>9. Kafka 消费组原理</strong></h2><ul>
<li>同一组内的每个 Partition 只被一个 Consumer 消费</li>
<li>多组可重复消费，实现广播</li>
<li>提高并行消费，减少重复消费</li>
<li><strong>拓展</strong>：消费组重平衡、再均衡机制</li>
</ul>
<hr>
<h2 id="10-Kafka-Offset-提交方式"><a href="#10-Kafka-Offset-提交方式" class="headerlink" title="10. Kafka Offset 提交方式"></a><strong>10. Kafka Offset 提交方式</strong></h2><ul>
<li>自动提交：消费完成后自动提交 Offset</li>
<li>手动提交：<ul>
<li>同步提交：阻塞等待</li>
<li>异步提交：性能高，可能丢少量消息</li>
</ul>
</li>
<li><strong>实践</strong>：结合事务实现 Exactly Once</li>
</ul>
<hr>
<h2 id="11-Kafka-高吞吐量原理"><a href="#11-Kafka-高吞吐量原理" class="headerlink" title="11. Kafka 高吞吐量原理"></a><strong>11. Kafka 高吞吐量原理</strong></h2><ul>
<li>顺序写磁盘，避免随机 IO</li>
<li>批量发送消息，减少网络开销</li>
<li>零拷贝机制，减少 CPU 消耗</li>
<li><strong>面试拓展</strong>：如何调整批量大小提高吞吐量</li>
</ul>
<hr>
<h2 id="12-Kafka-零拷贝机制"><a href="#12-Kafka-零拷贝机制" class="headerlink" title="12. Kafka 零拷贝机制"></a><strong>12. Kafka 零拷贝机制</strong></h2><ul>
<li>直接从磁盘 buffer 传到网络 buffer，无用户态复制</li>
<li>利用 sendfile() 提升大流量传输效率</li>
</ul>
<hr>
<h2 id="13-RocketMQ-核心特点"><a href="#13-RocketMQ-核心特点" class="headerlink" title="13. RocketMQ 核心特点"></a><strong>13. RocketMQ 核心特点</strong></h2><ul>
<li>高可靠，高性能</li>
<li>顺序消息、事务消息原生支持</li>
<li>Broker 无状态，易水平扩展</li>
<li>支持多语言客户端</li>
<li>消息存储：CommitLog + ConsumeQueue + IndexFile</li>
</ul>
<hr>
<h2 id="14-RocketMQ-顺序消息"><a href="#14-RocketMQ-顺序消息" class="headerlink" title="14. RocketMQ 顺序消息"></a><strong>14. RocketMQ 顺序消息</strong></h2><ul>
<li>通过 Key 哈希映射到队列</li>
<li>队列内顺序严格保证</li>
<li>应用场景：订单支付、流水处理</li>
</ul>
<hr>
<h2 id="15-RocketMQ-事务消息"><a href="#15-RocketMQ-事务消息" class="headerlink" title="15. RocketMQ 事务消息"></a><strong>15. RocketMQ 事务消息</strong></h2><ul>
<li><strong>半消息机制</strong>：<ol>
<li>发送半消息到 Broker</li>
<li>执行本地事务</li>
<li>提交或回滚消息</li>
</ol>
</li>
<li>保证分布式事务最终一致性</li>
</ul>
<hr>
<h2 id="16-如何保证消息不丢失"><a href="#16-如何保证消息不丢失" class="headerlink" title="16. 如何保证消息不丢失"></a><strong>16. 如何保证消息不丢失</strong></h2><ul>
<li><strong>生产者端</strong>：确认机制</li>
<li><strong>Broker端</strong>：消息持久化</li>
<li><strong>消费者端</strong>：手动 ack + 幂等消费</li>
</ul>
<hr>
<h2 id="17-如何保证消息不重复消费"><a href="#17-如何保证消息不重复消费" class="headerlink" title="17. 如何保证消息不重复消费"></a><strong>17. 如何保证消息不重复消费</strong></h2><ul>
<li>消息幂等：唯一 ID + 数据库唯一约束 + Redis 去重</li>
<li>Kafka Exactly Once + 事务处理</li>
</ul>
<hr>
<h2 id="18-如何保证消息有序"><a href="#18-如何保证消息有序" class="headerlink" title="18. 如何保证消息有序"></a><strong>18. 如何保证消息有序</strong></h2><ul>
<li><strong>Kafka</strong>：Partition 内顺序</li>
<li><strong>RocketMQ</strong>：队列内顺序</li>
<li><strong>注意</strong>：多 Partition 并行可能导致整体无序</li>
</ul>
<hr>
<h2 id="19-消息堆积解决办法"><a href="#19-消息堆积解决办法" class="headerlink" title="19. 消息堆积解决办法"></a><strong>19. 消息堆积解决办法</strong></h2><ul>
<li>增加消费者数量</li>
<li>扩展队列分区</li>
<li>流量削峰</li>
<li>消费端批量处理，提高吞吐量</li>
</ul>
<hr>
<h2 id="20-如何设计延迟队列"><a href="#20-如何设计延迟队列" class="headerlink" title="20. 如何设计延迟队列"></a><strong>20. 如何设计延迟队列</strong></h2><ul>
<li><strong>RabbitMQ</strong>：TTL + Dead Letter Queue</li>
<li><strong>Kafka</strong>：延迟消息插件 &#x2F; 时间轮</li>
<li><strong>Redis</strong>：SortedSet + 轮询</li>
<li><strong>场景</strong>：订单超时、短信延迟发送</li>
</ul>
<hr>
<h2 id="21-死信队列作用"><a href="#21-死信队列作用" class="headerlink" title="21. 死信队列作用"></a><strong>21. 死信队列作用</strong></h2><ul>
<li>消费失败消息收集到死信队列</li>
<li>支持重试、告警和问题排查</li>
<li>提高系统可靠性</li>
</ul>
<hr>
<h2 id="22-幂等实现方式"><a href="#22-幂等实现方式" class="headerlink" title="22. 幂等实现方式"></a><strong>22. 幂等实现方式</strong></h2><ul>
<li>消息唯一 ID</li>
<li>数据库唯一约束</li>
<li>Redis 去重缓存</li>
<li>本地事务结合 MQ 保证幂等</li>
</ul>
<hr>
<h2 id="23-消息队列限流方式"><a href="#23-消息队列限流方式" class="headerlink" title="23. 消息队列限流方式"></a><strong>23. 消息队列限流方式</strong></h2><ul>
<li>消费者限流：处理速率限制</li>
<li>生产者限流：令牌桶&#x2F;漏桶</li>
<li>Broker 队列容量限制 + 拒绝策略</li>
</ul>
<hr>
<h2 id="24-消息队列监控"><a href="#24-消息队列监控" class="headerlink" title="24. 消息队列监控"></a><strong>24. 消息队列监控</strong></h2><ul>
<li>消息堆积量</li>
<li>消费速率</li>
<li>Broker 健康状态</li>
<li>延迟时间</li>
<li>工具：Prometheus + Grafana、Kafka Manager、RocketMQ Console、RabbitMQ Management</li>
</ul>
<hr>
<h2 id="25-Kafka-vs-RabbitMQ"><a href="#25-Kafka-vs-RabbitMQ" class="headerlink" title="25. Kafka vs RabbitMQ"></a><strong>25. Kafka vs RabbitMQ</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>Kafka</th>
<th>RabbitMQ</th>
</tr>
</thead>
<tbody><tr>
<td>模型</td>
<td>Pub&#x2F;Sub + Queue</td>
<td>AMQP</td>
</tr>
<tr>
<td>消息存储</td>
<td>持久化日志</td>
<td>队列存储</td>
</tr>
<tr>
<td>顺序保证</td>
<td>Partition 内顺序</td>
<td>队列顺序</td>
</tr>
<tr>
<td>高吞吐</td>
<td>高（批量 + 零拷贝）</td>
<td>中等</td>
</tr>
<tr>
<td>消费模式</td>
<td>Pull &#x2F; Push</td>
<td>Push</td>
</tr>
<tr>
<td>使用场景</td>
<td>大数据流、日志、事件驱动</td>
<td>任务队列、异步处理、可靠投递</td>
</tr>
</tbody></table>
<hr>
<h2 id="26-Kafka-vs-RocketMQ"><a href="#26-Kafka-vs-RocketMQ" class="headerlink" title="26. Kafka vs RocketMQ"></a><strong>26. Kafka vs RocketMQ</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>Kafka</th>
<th>RocketMQ</th>
</tr>
</thead>
<tbody><tr>
<td>顺序消息</td>
<td>Partition 内顺序</td>
<td>队列内顺序全局可控</td>
</tr>
<tr>
<td>事务消息</td>
<td>限制较多</td>
<td>原生支持</td>
</tr>
<tr>
<td>存储方式</td>
<td>CommitLog</td>
<td>CommitLog + ConsumeQueue + IndexFile</td>
</tr>
<tr>
<td>高可用</td>
<td>ISR + 副本</td>
<td>Master-Slave + HA</td>
</tr>
<tr>
<td>生态</td>
<td>Flink、Spark 集成</td>
<td>分布式事务、支付系统应用</td>
</tr>
</tbody></table>
<hr>
<h2 id="27-Pulsar-特点"><a href="#27-Pulsar-特点" class="headerlink" title="27. Pulsar 特点"></a><strong>27. Pulsar 特点</strong></h2><ul>
<li>多租户支持</li>
<li>持久化使用 BookKeeper</li>
<li>Topic 可分 Partition</li>
<li>支持事务、延迟消息</li>
<li>Push&#x2F;Pull 消费模式灵活</li>
</ul>
<hr>
<h2 id="28-消息中间件如何保证高可用"><a href="#28-消息中间件如何保证高可用" class="headerlink" title="28. 消息中间件如何保证高可用"></a><strong>28. 消息中间件如何保证高可用</strong></h2><ul>
<li>多副本 + 自动切换</li>
<li>Broker 集群</li>
<li>消息持久化</li>
<li>客户端重试</li>
<li>Zookeeper&#x2F;Controller 管理元数据</li>
</ul>
<hr>
<h2 id="29-消息队列水平扩展"><a href="#29-消息队列水平扩展" class="headerlink" title="29. 消息队列水平扩展"></a><strong>29. 消息队列水平扩展</strong></h2><ul>
<li>Kafka：增加 Partition &#x2F; Broker</li>
<li>RabbitMQ：集群 + Shovel&#x2F;Federation</li>
<li>RocketMQ：增加 Broker + Topic 分区</li>
<li><strong>注意</strong>：分区扩展可能影响顺序，需要 Key 路由</li>
</ul>
<hr>
<h2 id="30-消息队列-vs-事件总线"><a href="#30-消息队列-vs-事件总线" class="headerlink" title="30. 消息队列 vs 事件总线"></a><strong>30. 消息队列 vs 事件总线</strong></h2><ul>
<li>MQ：关注消息可靠性、顺序、确认</li>
<li>EventBus：关注解耦、广播、轻量级</li>
<li>MQ 偏向可靠持久化，EventBus 偏向系统内部事件触发</li>
</ul>
<hr>
<h2 id="九、DevOps-容器化（30题）"><a href="#九、DevOps-容器化（30题）" class="headerlink" title="九、DevOps &amp; 容器化（30题）"></a>九、DevOps &amp; 容器化（30题）</h2><hr>
<h2 id="1-CI-CD-的流程"><a href="#1-CI-CD-的流程" class="headerlink" title="1. CI&#x2F;CD 的流程"></a><strong>1. CI&#x2F;CD 的流程</strong></h2><ul>
<li><strong>CI（Continuous Integration，持续集成）</strong>：<ul>
<li>开发者提交代码 → 自动构建 → 自动单元测试 → 自动生成构建产物</li>
</ul>
</li>
<li><strong>CD（Continuous Delivery&#x2F;Deployment，持续交付&#x2F;部署）</strong>：<ul>
<li>自动部署到测试&#x2F;生产环境 → 自动化验证 → 生产发布</li>
</ul>
</li>
<li><strong>工具链</strong>：<ul>
<li>Jenkins、GitLab CI、Argo CD</li>
</ul>
</li>
<li><strong>实践要点</strong>：<ul>
<li>流程自动化</li>
<li>保证构建产物可回滚</li>
</ul>
</li>
<li><strong>面试拓展</strong>：CI&#x2F;CD 与 DevOps 的关系</li>
</ul>
<hr>
<h2 id="2-Jenkins-的作用"><a href="#2-Jenkins-的作用" class="headerlink" title="2. Jenkins 的作用"></a><strong>2. Jenkins 的作用</strong></h2><ul>
<li>自动化构建、测试、部署工具</li>
<li><strong>核心功能</strong>：<ul>
<li>支持多种 SCM（Git、SVN）</li>
<li>Pipeline 管理</li>
<li>插件生态丰富（Docker、K8s 集成）</li>
</ul>
</li>
<li><strong>面试追问</strong>：Pipeline 如何保证构建可重复、可回滚</li>
</ul>
<hr>
<h2 id="3-Docker-核心原理"><a href="#3-Docker-核心原理" class="headerlink" title="3. Docker 核心原理"></a><strong>3. Docker 核心原理</strong></h2><ul>
<li><strong>容器化技术</strong>：<ul>
<li>Linux <strong>namespace</strong> 隔离（进程、网络、文件系统）</li>
<li>Linux <strong>cgroups</strong> 限制资源（CPU、内存）</li>
<li>**联合文件系统（UnionFS）**实现镜像分层</li>
</ul>
</li>
<li><strong>容器 ≈ 轻量级虚拟机</strong>，共享宿主 OS 内核</li>
</ul>
<hr>
<h2 id="4-Docker-镜像-vs-容器"><a href="#4-Docker-镜像-vs-容器" class="headerlink" title="4. Docker 镜像 vs 容器"></a><strong>4. Docker 镜像 vs 容器</strong></h2><table>
<thead>
<tr>
<th>区别</th>
<th>镜像</th>
<th>容器</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>只读模板</td>
<td>镜像运行实例</td>
</tr>
<tr>
<td>存储</td>
<td>分层只读文件系统</td>
<td>读写层 + 镜像</td>
</tr>
<tr>
<td>生命周期</td>
<td>永久</td>
<td>临时，可停止&#x2F;删除</td>
</tr>
<tr>
<td>用途</td>
<td>构建应用</td>
<td>运行应用</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-Dockerfile-常用指令"><a href="#5-Dockerfile-常用指令" class="headerlink" title="5. Dockerfile 常用指令"></a><strong>5. Dockerfile 常用指令</strong></h2><ul>
<li><code>FROM</code>：基础镜像</li>
<li><code>RUN</code>：执行命令构建镜像</li>
<li><code>COPY</code>&#x2F;<code>ADD</code>：复制文件到镜像</li>
<li><code>CMD</code>&#x2F;<code>ENTRYPOINT</code>：容器启动命令</li>
<li><code>EXPOSE</code>：声明端口</li>
<li><code>ENV</code>：环境变量</li>
<li><strong>优化</strong>：减少镜像层，顺序合理缓存</li>
</ul>
<hr>
<h2 id="6-镜像分层机制"><a href="#6-镜像分层机制" class="headerlink" title="6. 镜像分层机制"></a><strong>6. 镜像分层机制</strong></h2><ul>
<li>镜像每条指令生成一个只读层</li>
<li>联合文件系统（UnionFS）叠加这些层</li>
<li>容器启动时增加读写层</li>
<li><strong>优势</strong>：<ul>
<li>共享公共层，节省空间</li>
<li>支持增量构建</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-容器-vs-虚拟机"><a href="#7-容器-vs-虚拟机" class="headerlink" title="7. 容器 vs 虚拟机"></a><strong>7. 容器 vs 虚拟机</strong></h2><table>
<thead>
<tr>
<th>区别</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>内核</td>
<td>共享宿主 OS 内核</td>
<td>独立 OS</td>
</tr>
<tr>
<td>启动速度</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>资源占用</td>
<td>轻量</td>
<td>重量</td>
</tr>
<tr>
<td>隔离</td>
<td>进程级</td>
<td>硬件级</td>
</tr>
</tbody></table>
<hr>
<h2 id="8-Kubernetes-核心组件"><a href="#8-Kubernetes-核心组件" class="headerlink" title="8. Kubernetes 核心组件"></a><strong>8. Kubernetes 核心组件</strong></h2><ul>
<li><strong>Master</strong>：<ul>
<li>API Server：接收用户请求</li>
<li>Scheduler：Pod 调度</li>
<li>Controller Manager：状态管理</li>
<li>etcd：分布式配置存储</li>
</ul>
</li>
<li><strong>Node</strong>：<ul>
<li>Kubelet：Pod 生命周期管理</li>
<li>Kube-proxy：服务网络代理</li>
<li>Container Runtime（Docker&#x2F;CRI-O）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="9-Pod-生命周期"><a href="#9-Pod-生命周期" class="headerlink" title="9. Pod 生命周期"></a><strong>9. Pod 生命周期</strong></h2><ul>
<li><strong>Pending</strong> → <strong>Running</strong> → <strong>Succeeded&#x2F;Failed</strong></li>
<li><strong>状态管理</strong>：<ul>
<li>initContainer → main container → postStop Hook</li>
</ul>
</li>
<li><strong>面试点</strong>：Pod 重启策略（Always&#x2F;OnFailure&#x2F;Never）</li>
</ul>
<hr>
<h2 id="10-Deployment-vs-StatefulSet"><a href="#10-Deployment-vs-StatefulSet" class="headerlink" title="10. Deployment vs StatefulSet"></a><strong>10. Deployment vs StatefulSet</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>Deployment</th>
<th>StatefulSet</th>
</tr>
</thead>
<tbody><tr>
<td>Pod 标识</td>
<td>无固定名字</td>
<td>有固定名字</td>
</tr>
<tr>
<td>顺序更新</td>
<td>可并行更新</td>
<td>严格顺序更新</td>
</tr>
<tr>
<td>持久化存储</td>
<td>共享卷</td>
<td>独立持久卷</td>
</tr>
<tr>
<td>应用场景</td>
<td>无状态服务</td>
<td>数据库、Kafka Broker 等状态服务</td>
</tr>
</tbody></table>
<hr>
<h2 id="11-K8s-服务发现机制"><a href="#11-K8s-服务发现机制" class="headerlink" title="11. K8s 服务发现机制"></a><strong>11. K8s 服务发现机制</strong></h2><ul>
<li><strong>ClusterIP</strong>：集群内部访问</li>
<li><strong>NodePort</strong>：节点端口访问</li>
<li><strong>LoadBalancer</strong>：外部访问</li>
<li><strong>DNS + kube-proxy</strong>：Pod 名称解析 + iptables 转发</li>
</ul>
<hr>
<h2 id="12-ConfigMap-和-Secret"><a href="#12-ConfigMap-和-Secret" class="headerlink" title="12. ConfigMap 和 Secret"></a><strong>12. ConfigMap 和 Secret</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>ConfigMap</th>
<th>Secret</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>明文配置</td>
<td>Base64 编码敏感信息</td>
</tr>
<tr>
<td>使用方式</td>
<td>Env&#x2F;Volume</td>
<td>Env&#x2F;Volume</td>
</tr>
<tr>
<td>安全性</td>
<td>不加密</td>
<td>加密可集成 KMS</td>
</tr>
</tbody></table>
<hr>
<h2 id="13-Ingress-的作用"><a href="#13-Ingress-的作用" class="headerlink" title="13. Ingress 的作用"></a><strong>13. Ingress 的作用</strong></h2><ul>
<li>集群外部访问 Pod 的入口</li>
<li>功能：<ul>
<li>路由到不同服务</li>
<li>TLS 终端</li>
<li>负载均衡</li>
</ul>
</li>
<li><strong>面试点</strong>：Ingress Controller vs Service LB</li>
</ul>
<hr>
<h2 id="14-K8s-水平扩缩容机制"><a href="#14-K8s-水平扩缩容机制" class="headerlink" title="14. K8s 水平扩缩容机制"></a><strong>14. K8s 水平扩缩容机制</strong></h2><ul>
<li><strong>HPA（Horizontal Pod Autoscaler）</strong>：根据 CPU、内存或自定义指标调整 Pod 数量</li>
<li><strong>VPA（Vertical Pod Autoscaler）</strong>：自动调整 Pod 资源配置</li>
<li><strong>Cluster Autoscaler</strong>：节点自动扩缩容</li>
</ul>
<hr>
<h2 id="15-K8s-滚动更新机制"><a href="#15-K8s-滚动更新机制" class="headerlink" title="15. K8s 滚动更新机制"></a><strong>15. K8s 滚动更新机制</strong></h2><ul>
<li><strong>Deployment</strong> 滚动更新策略：<ul>
<li><code>maxUnavailable</code>：最大不可用 Pod</li>
<li><code>maxSurge</code>：最大新增 Pod</li>
</ul>
</li>
<li><strong>保证无中断升级</strong></li>
</ul>
<hr>
<h2 id="16-K8s-灰度发布"><a href="#16-K8s-灰度发布" class="headerlink" title="16. K8s 灰度发布"></a><strong>16. K8s 灰度发布</strong></h2><ul>
<li><strong>方法</strong>：<ul>
<li>分流流量（Ingress&#x2F;Service Mesh）</li>
<li>多版本 Deployment</li>
<li>Canary Pod + 路由权重</li>
</ul>
</li>
</ul>
<hr>
<h2 id="17-K8s-调度策略"><a href="#17-K8s-调度策略" class="headerlink" title="17. K8s 调度策略"></a><strong>17. K8s 调度策略</strong></h2><ul>
<li><strong>默认调度</strong>：基于资源（CPU&#x2F;Memory）</li>
<li><strong>亲和性&#x2F;反亲和性</strong>：<ul>
<li>NodeAffinity</li>
<li>PodAffinity &#x2F; PodAntiAffinity</li>
</ul>
</li>
<li><strong>Taints &amp; Tolerations</strong>：节点污点控制 Pod 调度</li>
</ul>
<hr>
<h2 id="18-K8s-网络模型"><a href="#18-K8s-网络模型" class="headerlink" title="18. K8s 网络模型"></a><strong>18. K8s 网络模型</strong></h2><ul>
<li><strong>要求</strong>：<ul>
<li>Pod 可以直接互相通信</li>
<li>Pod 与 Node 通信</li>
</ul>
</li>
<li><strong>方案</strong>：<ul>
<li>Flannel、Calico、Cilium 等</li>
</ul>
</li>
<li><strong>面试点</strong>：Overlay 网络 vs Underlay 网络</li>
</ul>
<hr>
<h2 id="19-Service-Mesh-作用"><a href="#19-Service-Mesh-作用" class="headerlink" title="19. Service Mesh 作用"></a><strong>19. Service Mesh 作用</strong></h2><ul>
<li>透明通信管理</li>
<li>流量控制、熔断、限流</li>
<li>可观察性（Tracing、Metrics）</li>
<li>安全（mTLS）</li>
</ul>
<hr>
<h2 id="20-Istio-工作原理"><a href="#20-Istio-工作原理" class="headerlink" title="20. Istio 工作原理"></a><strong>20. Istio 工作原理</strong></h2><ul>
<li><strong>Sidecar Proxy</strong>：每个 Pod 注入 Envoy</li>
<li><strong>控制平面（Pilot）</strong>：下发路由规则</li>
<li><strong>Mixer &#x2F; Telemetry</strong>：采集指标和日志</li>
<li><strong>应用</strong>：<ul>
<li>灰度发布、流量镜像、故障注入、服务间安全通信</li>
</ul>
</li>
</ul>
<hr>
<h2 id="21-Helm-的作用"><a href="#21-Helm-的作用" class="headerlink" title="21. Helm 的作用"></a><strong>21. Helm 的作用</strong></h2><ul>
<li>Kubernetes 包管理工具</li>
<li><strong>功能</strong>：<ul>
<li>Chart 模板化部署</li>
<li>版本管理</li>
<li>一键升级&#x2F;回滚</li>
</ul>
</li>
<li><strong>面试拓展</strong>：Helm 与 Kustomize 区别</li>
</ul>
<hr>
<h2 id="22-K8s-存储方案"><a href="#22-K8s-存储方案" class="headerlink" title="22. K8s 存储方案"></a><strong>22. K8s 存储方案</strong></h2><ul>
<li><strong>临时存储</strong>：emptyDir</li>
<li><strong>持久卷</strong>：PersistentVolume + PersistentVolumeClaim</li>
<li><strong>存储类型</strong>：<ul>
<li>本地存储</li>
<li>NFS</li>
<li>Ceph &#x2F; GlusterFS</li>
<li>云存储（EBS、OSS）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="23-Prometheus-监控体系"><a href="#23-Prometheus-监控体系" class="headerlink" title="23. Prometheus 监控体系"></a><strong>23. Prometheus 监控体系</strong></h2><ul>
<li>Pull 模型采集指标</li>
<li>TSDB 存储时间序列数据</li>
<li>AlertManager 告警</li>
<li>可监控 K8s 组件、Pod、应用指标</li>
</ul>
<hr>
<h2 id="24-Grafana-的作用"><a href="#24-Grafana-的作用" class="headerlink" title="24. Grafana 的作用"></a><strong>24. Grafana 的作用</strong></h2><ul>
<li>可视化 Prometheus 数据</li>
<li>仪表盘定制</li>
<li>支持多数据源（InfluxDB、ElasticSearch）</li>
<li>面试点：报警可视化和多租户支持</li>
</ul>
<hr>
<h2 id="25-K8s-安全机制"><a href="#25-K8s-安全机制" class="headerlink" title="25. K8s 安全机制"></a><strong>25. K8s 安全机制</strong></h2><ul>
<li><strong>认证（Authentication）</strong>：Token &#x2F; X.509 &#x2F; OIDC</li>
<li><strong>授权（Authorization）</strong>：RBAC</li>
<li><strong>网络策略（NetworkPolicy）</strong></li>
<li><strong>Secret 加密</strong></li>
</ul>
<hr>
<h2 id="26-容器资源限制"><a href="#26-容器资源限制" class="headerlink" title="26. 容器资源限制"></a><strong>26. 容器资源限制</strong></h2><ul>
<li><strong>CPU &#x2F; Memory</strong>：requests &#x2F; limits</li>
<li><strong>QoS 分类</strong>：<ul>
<li>Guaranteed、Burstable、BestEffort</li>
</ul>
</li>
<li><strong>面试点</strong>：容器 OOM 及限流策略</li>
</ul>
<hr>
<h2 id="27-Docker-Compose-作用"><a href="#27-Docker-Compose-作用" class="headerlink" title="27. Docker Compose 作用"></a><strong>27. Docker Compose 作用</strong></h2><ul>
<li>多容器应用管理</li>
<li>本地开发、测试</li>
<li>声明式配置网络、依赖关系</li>
</ul>
<hr>
<h2 id="28-DevOps-最佳实践"><a href="#28-DevOps-最佳实践" class="headerlink" title="28. DevOps 最佳实践"></a><strong>28. DevOps 最佳实践</strong></h2><ul>
<li>持续集成&#x2F;持续交付</li>
<li>基础设施即代码（IaC）</li>
<li>自动化测试与部署</li>
<li>微服务 + 容器化 + 云原生</li>
</ul>
<hr>
<h2 id="29-GitOps-理念"><a href="#29-GitOps-理念" class="headerlink" title="29. GitOps 理念"></a><strong>29. GitOps 理念</strong></h2><ul>
<li>将 Git 作为单一真源</li>
<li>K8s 自动同步 Git 状态</li>
<li>优点：<ul>
<li>可追踪、可回滚</li>
<li>流程统一、可审计</li>
</ul>
</li>
</ul>
<hr>
<h2 id="30-K8s-如何保证高可用"><a href="#30-K8s-如何保证高可用" class="headerlink" title="30. K8s 如何保证高可用"></a><strong>30. K8s 如何保证高可用</strong></h2><ul>
<li>Master 节点多副本（HA）</li>
<li>ETCD 集群存储</li>
<li>Pod 多副本 + Deployment&#x2F;StatefulSet</li>
<li>Service + LoadBalancer 提供稳定访问</li>
<li>Cluster Autoscaler 支持节点弹性扩展</li>
</ul>
<hr>
<h2 id="十、场景设计题（30题）"><a href="#十、场景设计题（30题）" class="headerlink" title="十、场景设计题（30题）"></a>十、场景设计题（30题）</h2><ol>
<li>如何设计一个秒杀系统？</li>
<li>如何设计一个短链系统？</li>
<li>如何设计一个分布式 ID 生成系统？</li>
<li>如何设计一个高可用缓存系统？</li>
<li>如何设计一个订单系统？</li>
<li>如何设计一个支付系统？</li>
<li>如何设计一个消息推送系统？</li>
<li>如何设计一个日志收集系统？</li>
<li>如何设计一个搜索引擎？</li>
<li>如何设计一个推荐系统？</li>
<li>如何设计一个分布式锁？</li>
<li>如何设计一个统一鉴权系统？</li>
<li>如何设计一个限流系统？</li>
<li>如何设计一个灰度发布系统？</li>
<li>如何设计一个电商购物车？</li>
<li>如何设计一个库存系统？</li>
<li>如何设计一个分布式文件存储系统？</li>
<li>如何设计一个微服务网关？</li>
<li>如何设计一个分布式任务调度系统？</li>
<li>如何设计一个监控报警系统？</li>
<li>如何设计一个高并发聊天室？</li>
<li>如何设计一个排行榜系统？</li>
<li>如何设计一个评论系统？</li>
<li>如何设计一个分布式事务系统？</li>
<li>如何设计一个高可用注册中心？</li>
<li>如何设计一个数据同步系统？</li>
<li>如何设计一个 API 限速系统？</li>
<li>如何设计一个高可用的支付网关？</li>
<li>如何设计一个跨境电商架构？</li>
<li>如何设计一个金融级别的微服务系统？</li>
</ol>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Charlotte</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/">http://example.com/2025/09/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">浮生若梦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E9%A2%98%E7%9B%AE/">题目</a></div><div class="post-share"><div class="social-share" data-image="/img/title.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数据结构</div></div><div class="info-2"><div class="info-item-1"> 1. 数组 (Array)特点：连续内存，随机访问 O(1)，插入&#x2F;删除 O(n)。 常见操作12345678910111213141516171819202122232425262728293031323334353637383940// 遍历int[] arr = &#123;1, 2, 3, 4, 5&#125;;for (int i = 0; i &lt; arr.length; i++) System.out.print(arr[i] + &quot; &quot;);// 查找（线性查找）public static int find(int[] arr, int target) &#123;    for (int i = 0; i &lt; arr.length; i++) &#123;        if (arr[i] == target) return i;    &#125;    return -1;&#125;// 插入（指定位置）public static int[] insert(int[] arr, int pos, int val) ...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E9%A2%98%E5%8D%95/" title="题单"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">题单</div></div><div class="info-2"><div class="info-item-1"> 🔹 数组（Array）1. 两数之和1234567891011public int[] twoSum(int[] nums, int target) &#123;    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; nums.length; i++) &#123;        int diff = target - nums[i];        if (map.containsKey(diff)) &#123;            return new int[]&#123;map.get(diff), i&#125;;        &#125;        map.put(nums[i], i);    &#125;    return new int[0];&#125;  2. 最大子数组和（Kadane 算法）12345678public int maxSubArray(int[] nums) &#123;    int max = nums...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">分布式</div></div><div class="info-2"><div class="info-item-1">1. Spring Cloud 体系核心思想Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的规范和解决方案的集合。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。 Netflix OSS 常用组件（部分进入维护模式） 服务注册与发现 (Service Discovery): Eureka 作用: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。 使用: 服务端添加 spring-cloud-starter-netflix-eureka-server 依赖，并使用 @EnableEurekaServer 注解。客...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/" title="手写答案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">手写答案</div></div><div class="info-2"><div class="info-item-1">1.实现单例模式 (Singleton Pattern)懒汉式：使用双重检查锁定 (DCL) 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。 1234567891011121314151617181920212223242526272829class Singleton &#123;    // 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到    private static volatile Singleton instance;    // 2. 私有化构造器，防止外部直接 new 实例    private Singleton() &#123;&#125;    // 3. 提供一个全局访问点，使用 DCL 确保线程安全    public static Singleton getInstance() &#123;        // 第一次检查：如果实例已经存在，直接返回，避免不必要的同步        if (instance == null) &#12...</div></div></div></a><a class="pagination-related" href="/2025/09/11/java%E7%9F%A5%E8%AF%86%E7%82%B9/" title="重要知识点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">重要知识点</div></div><div class="info-2"><div class="info-item-1"> 一、网络基础概念 网络的定义 网络是多个计算机及通信设备通过通信介质互联的系统，用于信息传输、资源共享、协同工作。 核心目标：可靠、高效、可扩展的数据传输。 设计原则：分层、模块化、接口标准化。   数据传输方式 单工：单向传输（电视广播）。 半双工：双向传输，但不能同时发送（对讲机）。 全双工：双向同时传输（电话、以太网交换机端口）。   通信方式 点对点：两个节点直接通信（PPP）。 广播：单点发送，多点接收（Ethernet）。 组播：单点发送，特定组接收（IP 多播）。   网络分类 按地理范围：LAN、MAN、WAN。 按拓扑结构：星型、总线型、环型、混合型。 按访问控制方式：CSMA&#x2F;CD（Ethernet）、令牌环（Token Ring）。     二、OSI 七层模型OSI 模型将网络通信划分为七层，每层负责特定功能，确保模块化与互操作性。    层 功能 数据单位 典型协议&#x2F;设备 面试易问点    物理层 比特流传输，电气&#x2F;光学&#x2F;机械接口 比特 Bit 网线、光纤、集线器、网卡物理部分、调制解调器 电压、传输速率、双工模...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/title.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Charlotte</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/charlotte030710"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.</span> <span class="toc-text">一、Java 基础语法 &amp; 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JDK%E3%80%81JRE-%E5%92%8C-JVM-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">1. JDK、JRE 和 JVM 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java-%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">2. Java 的跨平台原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%90%84%E8%87%AA%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">3. Java 的基本数据类型有哪些？各自的默认值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-byte%E3%80%81short%E3%80%81int%E3%80%81long-%E5%90%84%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">4. byte、short、int、long 各占多少字节？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-float-%E5%92%8C-double-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">5. float 和 double 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-char-%E7%B1%BB%E5%9E%8B%E5%8D%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%9F%E8%83%BD%E5%AD%98%E6%B1%89%E5%AD%97%E5%90%97%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">6. char 类型占几个字节？能存汉字吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%EF%BC%88autoboxing%EF%BC%89%E5%92%8C%E6%8B%86%E7%AE%B1%EF%BC%88unboxing%EF%BC%89%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">7. 自动装箱（autoboxing）和拆箱（unboxing）的原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">8. &#x3D;&#x3D; 和 equals() 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-hashCode-%E5%92%8C-equals-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">9. hashCode 和 equals 的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-String%E3%80%81StringBuffer%E3%80%81StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">10. String、StringBuffer、StringBuilder 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88-String-%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%88immutable%EF%BC%89%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">11. 为什么 String 是不可变的（immutable）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-String-%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">12. String 常量池的实现机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-new-String-abc-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">13. new String(&quot;abc&quot;) 创建了几个对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-final-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">14. final 关键字的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-static-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">15. static 关键字的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-static-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E5%88%86%E5%88%AB%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">16. static 修饰变量、方法、代码块分别意味着什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-static-%E5%92%8C-final-%E8%83%BD%E4%B8%80%E8%B5%B7%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">17. static 和 final 能一起用吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-static-%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">18. static 内部类和非静态内部类的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Java-%E4%B8%AD%E7%9A%84-this-%E5%92%8C-super-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">19. Java 中的 this 和 super 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Java-%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">20. Java 中构造方法能否被重写？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">21. 接口和抽象类的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%9C%89-default-%E6%96%B9%E6%B3%95%E5%92%8C-static-%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">22. 接口中可以有 default 方法和 static 方法吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Java-8-%E6%8E%A5%E5%8F%A3%E6%96%B0%E5%A2%9E%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">23. Java 8 接口新增了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Java-8-%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B9%B6%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">25.</span> <span class="toc-text">24. Java 8 有什么新特性，并详细介绍（重点）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java-8-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">一、Java 8 新特性深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">1. Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">2. 函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.3.</span> <span class="toc-text">底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">2.4.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Stream-API"><span class="toc-number">3.</span> <span class="toc-text">3. Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">3.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-2"><span class="toc-number">3.3.</span> <span class="toc-text">底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">3.4.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">4. 方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="toc-number">4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">4.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-3"><span class="toc-number">4.3.</span> <span class="toc-text">底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-number">4.4.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-java-time-API"><span class="toc-number">5.</span> <span class="toc-text">5. java.time API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="toc-number">5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">5.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-4"><span class="toc-number">5.3.</span> <span class="toc-text">底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-number">5.4.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Optional"><span class="toc-number">6.</span> <span class="toc-text">6. Optional</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-5"><span class="toc-number">6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">6.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-5"><span class="toc-number">6.3.</span> <span class="toc-text">底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-5"><span class="toc-number">6.4.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-8-%E5%85%AD%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%BA%95%E5%B1%82%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">Java 8 六大核心特性底层对比表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">二、synchronized 底层原理深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JVM-%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">1. JVM 锁的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-synchronized-%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">2. synchronized 对象头结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-synchronized-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">3. synchronized 执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E5%81%8F%E5%90%91%E9%94%81%EF%BC%88%E6%97%A0%E7%AB%9E%E4%BA%89%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">a) 偏向锁（无竞争）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88CAS%E7%AB%9E%E4%BA%89%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">b) 轻量级锁（CAS竞争）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">c) 重量级锁（阻塞）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA"><span class="toc-number">3.4.</span> <span class="toc-text">图示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-synchronized-%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.</span> <span class="toc-text">4. synchronized 方法示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-JVM-%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">5. JVM 优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">25.多态的实现机制是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%88overload%EF%BC%89%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%EF%BC%88override%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">26. 方法重载（overload）和方法重写（override）的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-Java-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E6%95%88%E6%9E%9C%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">27. Java 支持多继承吗？如何实现类似效果？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-Java-%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">28. Java 的四种访问修饰符？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-transient-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">29. transient 关键字的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">30. volatile 关键字的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-synchronized-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">31. synchronized 的作用及底层原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">12.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">12.2.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88HotSpot-%E5%AE%9E%E7%8E%B0%E6%A6%82%E8%A6%81%EF%BC%89"><span class="toc-number">12.3.</span> <span class="toc-text">底层原理（HotSpot 实现概要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-notify-notifyAll"><span class="toc-number">12.4.</span> <span class="toc-text">wait&#x2F;notify&#x2F;notifyAll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%B8%8E%E9%99%B7%E9%98%B1"><span class="toc-number">12.5.</span> <span class="toc-text">注意与陷阱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">二、面向对象编程（OOP）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">1. 面向对象的三大特性是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%81%E8%A3%85%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">2. 封装的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">3. 多态的优点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%E6%97%B6%E8%BF%94%E5%9B%9E%E5%80%BC%E8%83%BD%E5%90%A6%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">4. 重写方法时返回值能否不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">5. 构造函数能否被继承？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6-private%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">6. 构造函数能否 private？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">7. 单例模式的几种实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%92%8C%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">8. 饿汉式和懒汉式单例的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">9. 为什么要使用内部类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">10. 成员内部类、局部内部类、静态内部类的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Java-%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">11. Java 中对象的创建方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">12. 对象之间的浅拷贝和深拷贝的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-clone-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">13. clone() 方法的原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">14. 为什么 Java 不支持多继承？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Java-%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">15. Java 是值传递还是引用传递？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%97%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">16. 方法参数传递时是如何处理对象的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%B0%81%E8%A3%85%E6%80%A7%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">17. 封装性体现在哪些方面？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">18. 为什么需要继承？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E9%87%8D%E5%86%99-Object-%E7%B1%BB%E7%9A%84-toString-%E6%96%B9%E6%B3%95%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">19. 重写 Object 类的 toString 方法的意义？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E9%87%8D%E5%86%99-Object-%E7%B1%BB%E7%9A%84-equals-%E6%96%B9%E6%B3%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">20. 重写 Object 类的 equals 方法时需要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">34.</span> <span class="toc-text">三、异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java-%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">34.1.</span> <span class="toc-text">1. Java 的异常体系结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Checked-Exception-%E5%92%8C-Unchecked-Exception-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">34.2.</span> <span class="toc-text">2. Checked Exception 和 Unchecked Exception 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-throw-%E5%92%8C-throws-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">34.3.</span> <span class="toc-text">3. throw 和 throws 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-try-catch-finally-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">34.4.</span> <span class="toc-text">4. try-catch-finally 的执行顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-finally-%E4%B8%AD%E7%9A%84-return-%E4%BC%9A%E8%A6%86%E7%9B%96-try-%E4%B8%AD%E7%9A%84-return-%E5%90%97%EF%BC%9F"><span class="toc-number">34.5.</span> <span class="toc-text">5. finally 中的 return 会覆盖 try 中的 return 吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-try-with-resources-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">34.6.</span> <span class="toc-text">6. try-with-resources 的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">34.7.</span> <span class="toc-text">7. 自定义异常类如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Error-%E5%92%8C-Exception-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">34.8.</span> <span class="toc-text">8. Error 和 Exception 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-NullPointerException-%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">34.9.</span> <span class="toc-text">9. NullPointerException 常见场景有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E9%9C%80%E8%A6%81%E6%8D%95%E8%8E%B7%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">34.10.</span> <span class="toc-text">10. 运行时异常需要捕获吗？为什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88Collections%EF%BC%89"><span class="toc-number">35.</span> <span class="toc-text">四、集合框架（Collections）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Collection-%E5%92%8C-Collections-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">35.1.</span> <span class="toc-text">1. Collection 和 Collections 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-List%E3%80%81Set%E3%80%81Map-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">35.2.</span> <span class="toc-text">2. List、Set、Map 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ArrayList-%E5%92%8C-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">35.3.</span> <span class="toc-text">3. ArrayList 和 LinkedList 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">35.4.</span> <span class="toc-text">4. HashMap 的底层实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HashMap-1-7-%E5%92%8C-1-8-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">35.5.</span> <span class="toc-text">5. HashMap 1.7 和 1.8 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-HashMap-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-number">35.6.</span> <span class="toc-text">6. HashMap 如何解决哈希冲突？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-HashSet-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">35.7.</span> <span class="toc-text">7. HashSet 的底层实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ConcurrentHashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">35.8.</span> <span class="toc-text">8. ConcurrentHashMap 的底层实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Hashtable-%E5%92%8C-HashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">35.9.</span> <span class="toc-text">9. Hashtable 和 HashMap 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-TreeMap-%E5%92%8C-HashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">35.10.</span> <span class="toc-text">10. TreeMap 和 HashMap 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-WeakHashMap-%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">35.11.</span> <span class="toc-text">11. WeakHashMap 的特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-CopyOnWriteArrayList-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">35.12.</span> <span class="toc-text">12. CopyOnWriteArrayList 的应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-LinkedHashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">35.13.</span> <span class="toc-text">13. LinkedHashMap 的底层原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Map-%E7%9A%84-key-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%B8%BA-null%EF%BC%9F"><span class="toc-number">35.14.</span> <span class="toc-text">14. Map 的 key 是否可以为 null？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-ArrayList-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">35.15.</span> <span class="toc-text">15. ArrayList 扩容机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Vector-%E5%92%8C-ArrayList-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">35.16.</span> <span class="toc-text">16. Vector 和 ArrayList 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-PriorityQueue-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">35.17.</span> <span class="toc-text">17. PriorityQueue 的底层实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-BlockingQueue-%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9F"><span class="toc-number">35.18.</span> <span class="toc-text">18. BlockingQueue 的几种实现类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-HashMap-%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%89%88%E6%9C%AC%EF%BC%9F"><span class="toc-number">35.19.</span> <span class="toc-text">19. HashMap 死循环问题出现在哪个版本？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-fail-fast-%E5%92%8C-fail-safe-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">35.20.</span> <span class="toc-text">20. fail-fast 和 fail-safe 的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88JUC%EF%BC%89"><span class="toc-number">36.</span> <span class="toc-text">五、并发编程（JUC）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">36.1.</span> <span class="toc-text">1. Java 中的线程生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Runnable-%E5%92%8C-Callable-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">36.2.</span> <span class="toc-text">2. Runnable 和 Callable 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ThreadPoolExecutor-%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">36.3.</span> <span class="toc-text">3. ThreadPoolExecutor 的参数有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">36.4.</span> <span class="toc-text">4. 线程池的拒绝策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">36.5.</span> <span class="toc-text">5. 创建线程的四种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-synchronized-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">36.6.</span> <span class="toc-text">6. synchronized 的底层实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-synchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">36.7.</span> <span class="toc-text">7. synchronized 和 ReentrantLock 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">36.8.</span> <span class="toc-text">8. 公平锁和非公平锁的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-AQS-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">36.9.</span> <span class="toc-text">9. AQS 的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-CountDownLatch-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">36.10.</span> <span class="toc-text">10. CountDownLatch 的应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-CyclicBarrier-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">36.11.</span> <span class="toc-text">11. CyclicBarrier 的应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Semaphore-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">36.12.</span> <span class="toc-text">12. Semaphore 的应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Exchanger-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">36.13.</span> <span class="toc-text">13. Exchanger 的应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-volatile-%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%9F"><span class="toc-number">36.14.</span> <span class="toc-text">14. volatile 能保证原子性吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-CAS-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">36.15.</span> <span class="toc-text">15. CAS 的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-ABA-%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">36.16.</span> <span class="toc-text">16. ABA 问题是什么？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-ThreadLocal-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">36.17.</span> <span class="toc-text">17. ThreadLocal 的作用及原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">36.18.</span> <span class="toc-text">18. ThreadLocal 内存泄漏的原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-JUC-%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">36.19.</span> <span class="toc-text">19. JUC 中的原子类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">36.20.</span> <span class="toc-text">20. 乐观锁和悲观锁的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">37.</span> <span class="toc-text">六、JVM &amp; 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">37.1.</span> <span class="toc-text">1. JVM 内存结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">37.2.</span> <span class="toc-text">2. 堆和栈的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E4%BB%A3%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">37.3.</span> <span class="toc-text">3. 堆内存的分代模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%81%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">37.4.</span> <span class="toc-text">4. 新生代、老年代、永久代的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%83%E7%A9%BA%E9%97%B4%E5%92%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">37.5.</span> <span class="toc-text">5. 元空间和永久代的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E4%B8%AD%E7%9A%84%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">37.6.</span> <span class="toc-text">6. 对象在堆中的分配过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="toc-number">37.7.</span> <span class="toc-text">7. 对象什么时候进入老年代？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-JVM-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">37.8.</span> <span class="toc-text">8. JVM 的垃圾回收算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">37.9.</span> <span class="toc-text">9. 垃圾收集器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-CMS-%E5%92%8C-G1-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">37.10.</span> <span class="toc-text">10. CMS 和 G1 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Minor-GC-%E5%92%8C-Full-GC-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">37.11.</span> <span class="toc-text">11. Minor GC 和 Full GC 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AF-Stop-The-World%EF%BC%9F"><span class="toc-number">37.12.</span> <span class="toc-text">12. 什么是 Stop The World？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-JVM-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">37.13.</span> <span class="toc-text">13. JVM 常见的调优参数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">37.14.</span> <span class="toc-text">14. 类加载的双亲委派机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">37.15.</span> <span class="toc-text">15. 双亲委派的好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%9F"><span class="toc-number">37.16.</span> <span class="toc-text">16. 类加载器的种类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-OOM-%E7%9A%84%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">37.17.</span> <span class="toc-text">17. OOM 的常见类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">37.18.</span> <span class="toc-text">18. 内存泄漏和内存溢出的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-finalize-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">37.19.</span> <span class="toc-text">19. finalize() 方法的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89%E7%9A%84%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%EF%BC%9F"><span class="toc-number">37.20.</span> <span class="toc-text">20. Java 内存模型（JMM）的核心内容？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E6%B3%A8%E8%A7%A3%E3%80%81%E5%8F%8D%E5%B0%84"><span class="toc-number">38.</span> <span class="toc-text">七、泛型、注解、反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">38.1.</span> <span class="toc-text">1. 什么是泛型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">38.2.</span> <span class="toc-text">2. 泛型的类型擦除机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6-extends-%E5%92%8C-super-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">38.3.</span> <span class="toc-text">3. 泛型通配符 ? extends 和 ? super 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">38.4.</span> <span class="toc-text">4. 注解的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%83%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">38.5.</span> <span class="toc-text">5. 元注解有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">38.6.</span> <span class="toc-text">6. 自定义注解如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">38.7.</span> <span class="toc-text">7. 反射的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%8F%8D%E5%B0%84%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">38.8.</span> <span class="toc-text">8. 反射的性能问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%8F%8D%E5%B0%84%E8%83%BD%E5%90%A6%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-number">38.9.</span> <span class="toc-text">9. 反射能否访问私有字段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">38.10.</span> <span class="toc-text">10. 动态代理的两种实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-CGLIB-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">38.11.</span> <span class="toc-text">11. JDK 动态代理和 CGLIB 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%8F%8D%E5%B0%84%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">38.12.</span> <span class="toc-text">12. 反射如何创建对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Class-forName-%E5%92%8C-ClassLoader-loadClass-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">38.13.</span> <span class="toc-text">13. Class.forName 和 ClassLoader.loadClass 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84%E7%BB%93%E5%90%88%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">38.14.</span> <span class="toc-text">14. 注解和反射结合能实现哪些功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88APT%EF%BC%89%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">38.15.</span> <span class="toc-text">15. 注解处理器（APT）的作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81Java-8-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">39.</span> <span class="toc-text">八、Java 8+ 新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81IO"><span class="toc-number">40.</span> <span class="toc-text">九、IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java-IO-%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%EF%BC%881%E2%80%9320%EF%BC%89"><span class="toc-number">41.</span> <span class="toc-text">一、Java IO 基础与流（1–20）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java-IO-%E7%9A%84%E6%80%BB%E4%BD%93%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">41.1.</span> <span class="toc-text">1. Java IO 的总体体系结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-InputStream-OutputStream-%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AD%90%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">41.2.</span> <span class="toc-text">2. InputStream &#x2F; OutputStream 的常见子类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Reader-Writer-%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AD%90%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">41.3.</span> <span class="toc-text">3. Reader &#x2F; Writer 的常见子类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">41.4.</span> <span class="toc-text">4. 字节流与字符流的本质区别和使用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%BC%93%E5%86%B2%E6%B5%81%EF%BC%9F"><span class="toc-number">41.5.</span> <span class="toc-text">5. 为什么要有缓冲流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-flush-%E4%B8%8E-close-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">41.6.</span> <span class="toc-text">6. flush() 与 close() 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-try-with-resources-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">41.7.</span> <span class="toc-text">7. try-with-resources 的工作原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%A8-Java-IO-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%EF%BC%9F"><span class="toc-number">41.8.</span> <span class="toc-text">8. 装饰器模式在 Java IO 中如何体现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-File-%E7%B1%BB%E7%9A%84%E8%83%BD%E5%8A%9B%E4%B8%8E%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">41.9.</span> <span class="toc-text">9. File 类的能力与限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-RandomAccessFile-%E7%9A%84%E7%94%A8%E9%80%94%EF%BC%9F"><span class="toc-number">41.10.</span> <span class="toc-text">10. RandomAccessFile 的用途？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-FileInputStream-%E4%B8%8E-FileReader-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">41.11.</span> <span class="toc-text">11. FileInputStream 与 FileReader 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">41.12.</span> <span class="toc-text">12. 常见文件拷贝方式性能对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%9F"><span class="toc-number">41.13.</span> <span class="toc-text">13. 如何安全处理字符编码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%B8%B8%E8%A7%81%E5%9D%91%EF%BC%9F"><span class="toc-number">41.14.</span> <span class="toc-text">14. 字符编码常见坑？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%96%87%E4%BB%B6%E8%BF%BD%E5%8A%A0%EF%BC%88append%EF%BC%89%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">41.15.</span> <span class="toc-text">15. 文件追加（append）方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%B9%B6%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">41.16.</span> <span class="toc-text">16. 如何判断并处理文件状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-File-mkdirs-%E4%B8%8E-mkdir-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">41.17.</span> <span class="toc-text">17. File.mkdirs() 与 mkdir() 区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%EF%BC%88createTempFile%EF%BC%89%E7%9A%84%E7%94%A8%E9%80%94%EF%BC%9F"><span class="toc-number">41.18.</span> <span class="toc-text">18. 临时文件（createTempFile）的用途？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81%E4%B8%8E%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%EF%BC%9F"><span class="toc-number">41.19.</span> <span class="toc-text">19. 文件的读写锁与并发访问？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E6%B5%81%E5%85%B3%E9%97%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">41.20.</span> <span class="toc-text">20. 流关闭异常处理最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java-IO-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%A8%A1%E5%BC%8F%EF%BC%8821%E2%80%9340%EF%BC%89"><span class="toc-number">42.</span> <span class="toc-text">二、Java IO 设计与模式（21–40）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81%E9%94%81%E4%B8%8E%E6%93%8D%E4%BD%9C%EF%BC%8841%E2%80%9360%EF%BC%89"><span class="toc-number">43.</span> <span class="toc-text">三、文件系统、锁与操作（41–60）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8861%E2%80%9375%EF%BC%89"><span class="toc-number">44.</span> <span class="toc-text">四、序列化与反序列化（61–75）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81NIO-%E6%B7%B1%E5%85%A5%EF%BC%9ABuffer-Channel-Selector%EF%BC%8876%E2%80%93100%EF%BC%89"><span class="toc-number">45.</span> <span class="toc-text">五、NIO 深入：Buffer &#x2F; Channel &#x2F; Selector（76–100）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-NIO-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%EF%BC%88Buffer%E3%80%81Channel%E3%80%81Selector%EF%BC%89"><span class="toc-number">45.1.</span> <span class="toc-text">1. NIO 三大核心（Buffer、Channel、Selector）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ByteBuffer-%E7%9A%84-position-limit-capacity"><span class="toc-number">45.2.</span> <span class="toc-text">2. ByteBuffer 的 position &#x2F; limit &#x2F; capacity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-flip-clear-rewind-compact"><span class="toc-number">45.3.</span> <span class="toc-text">3. flip(), clear(), rewind(), compact()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-DirectByteBuffer-vs-HeapByteBuffer"><span class="toc-number">45.4.</span> <span class="toc-text">4. DirectByteBuffer vs HeapByteBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-ByteBuffer-slice-asReadOnlyBuffer"><span class="toc-number">45.5.</span> <span class="toc-text">5. ByteBuffer slice() &#x2F; asReadOnlyBuffer()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Scatter-Gather-IO"><span class="toc-number">45.6.</span> <span class="toc-text">6. Scatter&#x2F;Gather IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-FileChannel-%E7%9A%84%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95"><span class="toc-number">45.7.</span> <span class="toc-text">7. FileChannel 的关键方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-MappedByteBuffer%EF%BC%88%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%EF%BC%89"><span class="toc-number">45.8.</span> <span class="toc-text">8. MappedByteBuffer（内存映射）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Channel-vs-Stream"><span class="toc-number">45.9.</span> <span class="toc-text">9. Channel vs Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Selector-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">45.10.</span> <span class="toc-text">10. Selector 工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Selector-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">45.11.</span> <span class="toc-text">11. Selector 底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E9%9D%9E%E9%98%BB%E5%A1%9E-Channel-%E7%9A%84-read-write-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">45.12.</span> <span class="toc-text">12. 非阻塞 Channel 的 read&#x2F;write 返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">45.13.</span> <span class="toc-text">13. 粘包&#x2F;拆包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E8%B6%85%E6%97%B6%E6%96%AD%E5%BC%80-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B"><span class="toc-number">45.14.</span> <span class="toc-text">14. 超时断开 &amp; 心跳检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Pipe-%E5%9C%A8-NIO-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">45.15.</span> <span class="toc-text">15. Pipe 在 NIO 中的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%A4%9A-Selector-%E5%A4%9A-Reactor"><span class="toc-number">45.16.</span> <span class="toc-text">16. 多 Selector &#x2F; 多 Reactor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-ByteBuffer-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">45.17.</span> <span class="toc-text">17. ByteBuffer 多线程问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-DirectByteBuffer-%E9%81%BF%E5%85%8D%E6%B3%84%E9%9C%B2"><span class="toc-number">45.18.</span> <span class="toc-text">18. DirectByteBuffer 避免泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Selector-selectedKeys-%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95"><span class="toc-number">45.19.</span> <span class="toc-text">19. Selector selectedKeys 正确用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-NIO-%E9%AB%98%E6%95%88%E8%AF%BB%E5%86%99%E5%BE%AA%E7%8E%AF%E6%A8%A1%E6%9D%BF"><span class="toc-number">45.20.</span> <span class="toc-text">20. NIO 高效读写循环模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-transferTo-transferFrom%EF%BC%88%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%89"><span class="toc-number">45.21.</span> <span class="toc-text">21. transferTo&#x2F;transferFrom（零拷贝）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-FileChannel-%E9%AB%98%E6%95%88%E5%A4%8D%E5%88%B6"><span class="toc-number">45.22.</span> <span class="toc-text">22. FileChannel 高效复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%93%B6%E9%A2%88"><span class="toc-number">45.23.</span> <span class="toc-text">23. 高并发服务器瓶颈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-Windows-vs-Linux"><span class="toc-number">45.24.</span> <span class="toc-text">24. Windows vs Linux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E7%AE%80%E5%8D%95-Echo-Server-%E6%80%9D%E8%B7%AF"><span class="toc-number">45.25.</span> <span class="toc-text">25. 简单 Echo Server 思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Socket-TCP-UDP-WebSocket%EF%BC%88101%E2%80%93140%EF%BC%89"><span class="toc-number">46.</span> <span class="toc-text">六、Socket &#x2F; TCP &#x2F; UDP &#x2F; WebSocket（101–140）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%BC%82%E6%AD%A5-IO%E3%80%81IO-%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%AB%98%E9%98%B6%E6%A8%A1%E5%BC%8F%EF%BC%88141%E2%80%93150%EF%BC%89"><span class="toc-number">47.</span> <span class="toc-text">七、异步 IO、IO 模型与高阶模式（141–150）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%81%E5%86%85%E6%A0%B8%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%88151%E2%80%93160%EF%BC%89"><span class="toc-number">48.</span> <span class="toc-text">八、零拷贝、内核与性能调优（151–160）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">Java 基础面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">0.1.</span> <span class="toc-text">一、语言特性 &amp; 基础语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java-%E4%B8%AD%E7%9A%84-%E5%92%8C-equals-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%87%8D%E5%86%99-equals-%EF%BC%9F"><span class="toc-number">0.2.</span> <span class="toc-text">1. Java 中的 &#x3D;&#x3D; 和 equals() 有什么区别？如何正确重写 equals()？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%EF%BC%9F%E4%B8%8D%E9%87%8D%E5%86%99%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">0.3.</span> <span class="toc-text">2. 为什么重写 equals() 时必须重写 hashCode()？不重写会怎样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Object-%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E7%BB%8F%E5%B8%B8%E9%9C%80%E8%A6%81%E9%87%8D%E5%86%99%EF%BC%9F"><span class="toc-number">0.4.</span> <span class="toc-text">3. Object 类有哪些方法？哪些方法经常需要重写？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-final%E3%80%81finally%E3%80%81finalize-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">0.5.</span> <span class="toc-text">4. final、finally、finalize() 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Java-%E4%B8%AD%E7%9A%84-instanceof-%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">0.6.</span> <span class="toc-text">5. Java 中的 instanceof 关键字是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%8E%A5%E5%8F%A3%E8%83%BD%E4%B8%8D%E8%83%BD%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">0.7.</span> <span class="toc-text">6. 接口和抽象类的区别？接口能不能有构造函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="toc-number">0.8.</span> <span class="toc-text">7. 接口可以多继承吗？抽象类可以实现接口吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-default-%E6%96%B9%E6%B3%95%E5%92%8C-static-%E6%96%B9%E6%B3%95%E5%9C%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">0.9.</span> <span class="toc-text">8. default 方法和 static 方法在接口中的意义是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">0.10.</span> <span class="toc-text">9. 什么是内部类？分为哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">0.11.</span> <span class="toc-text">10. 匿名内部类和 Lambda 表达式的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%86%85%E5%AD%98"><span class="toc-number">0.12.</span> <span class="toc-text">二、数据类型 &amp; 内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java-%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">0.13.</span> <span class="toc-text">1. Java 中的基本数据类型和包装类型有哪些区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-Integer-%E6%9C%89%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%9F%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">0.14.</span> <span class="toc-text">2. 为什么 Integer 有缓存机制？范围是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88-new-Integer-127-new-Integer-127-%E4%B8%BA-false%EF%BC%8C%E8%80%8C-Integer-valueOf-127-Integer-valueOf-127-%E4%B8%BA-true%EF%BC%9F"><span class="toc-number">0.15.</span> <span class="toc-text">3. 为什么 new Integer(127) &#x3D;&#x3D; new Integer(127) 为 false，而 Integer.valueOf(127) &#x3D;&#x3D; Integer.valueOf(127) 为 true？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-NaN-%E5%92%8C-Infinity-%E5%9C%A8-Java-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%EF%BC%9F"><span class="toc-number">0.16.</span> <span class="toc-text">4. NaN 和 Infinity 在 Java 中如何表示？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E6%9C%89%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">0.17.</span> <span class="toc-text">5. 为什么浮点数计算有精度问题？如何避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-BigDecimal-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%A7%A3%E5%86%B3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">0.18.</span> <span class="toc-text">6. BigDecimal 为什么能解决浮点数精度问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Java-%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E9%BB%98%E8%AE%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BC%9A%E4%B8%8D%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F"><span class="toc-number">0.19.</span> <span class="toc-text">7. Java 中的字符集默认是什么？在不同平台上会不一样吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-String%E3%80%81StringBuilder%E3%80%81StringBuffer-%E5%8C%BA%E5%88%AB%EF%BC%9F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">0.20.</span> <span class="toc-text">8. String、StringBuilder、StringBuffer 区别？线程安全性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%B8%BA%E4%BB%80%E4%B9%88-String-%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F%E8%83%8C%E5%90%8E%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%EF%BC%9F"><span class="toc-number">0.21.</span> <span class="toc-text">9. 为什么 String 是不可变的？背后实现细节？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-intern-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">0.22.</span> <span class="toc-text">10. intern() 方法的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">0.23.</span> <span class="toc-text">三、集合框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ArrayList-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">1. ArrayList 和 Vector 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-ArrayList-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%98%AF-1-5-%E5%80%8D%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2. 为什么 ArrayList 的扩容是 1.5 倍？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-LinkedList-%E6%98%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E8%BF%98%E6%98%AF%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3. LinkedList 是双向链表还是单向链表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-HashSet-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">4. HashSet 底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-TreeSet-%E5%92%8C-TreeMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">5. TreeSet 和 TreeMap 的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-PriorityQueue-%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">6. PriorityQueue 的底层数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-ConcurrentSkipListMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">7. ConcurrentSkipListMap 的底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-CopyOnWriteArrayList-%E7%9A%84%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">8. CopyOnWriteArrayList 的写时复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-EnumMap-%E5%92%8C-EnumSet"><span class="toc-number">9.</span> <span class="toc-text">9. EnumMap 和 EnumSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-WeakHashMap-%E5%92%8C-HashMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">10. WeakHashMap 和 HashMap 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BC%82%E5%B8%B8-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">10.1.</span> <span class="toc-text">四、异常 &amp; 错误处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%88%86%E4%B8%BA%E5%93%AA%E4%B8%A4%E5%A4%A7%E7%B1%BB%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">1. Java 中的异常分为哪两大类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Error-%E5%92%8C-Exception-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">2. Error 和 Exception 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9D%9E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">3. 受检异常和非受检异常区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-throw-%E5%92%8C-throws-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">4. throw 和 throws 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-try-with-resources-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">15.</span> <span class="toc-text">5. try-with-resources 的底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F%E7%BB%A7%E6%89%BF%E5%93%AA%E4%B8%AA%E7%B1%BB"><span class="toc-number">16.</span> <span class="toc-text">6. 自定义异常如何设计？继承哪个类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E6%8D%95%E8%8E%B7-Throwable%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">7. 为什么不建议捕获 Throwable？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%BC%82%E5%B8%B8%E9%93%BE%EF%BC%88Exception-Chaining%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">18.</span> <span class="toc-text">8. 异常链（Exception Chaining）是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Java-8-%E4%B9%8B%E5%90%8E%E5%AF%B9%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">19.</span> <span class="toc-text">9. Java 8 之后对异常处理的改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BC%A0%E9%80%92%E5%BC%82%E5%B8%B8"><span class="toc-number">20.</span> <span class="toc-text">10. 多线程环境下如何正确传递异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">20.1.</span> <span class="toc-text">五、JVM &amp; 内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">1. Java 内存模型（JMM）是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JVM-%E5%86%85%E5%AD%98%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E5%8C%BA%E5%9F%9F%EF%BC%9F%E6%AF%8F%E4%B8%AA%E5%8C%BA%E5%9F%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">2. JVM 内存分为哪几个区域？每个区域的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88-String-%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A6%81%E6%94%BE%E5%9C%A8%E5%A0%86%E9%87%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">3. 为什么 String 常量池要放在堆里而不是方法区？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">4. 什么是垃圾回收（GC）的可达性分析算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA-GC-Roots%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">5. 哪些对象可以作为 GC Roots？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">26.</span> <span class="toc-text">6. 强引用、软引用、弱引用、虚引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-GC-%E7%AE%97%E6%B3%95"><span class="toc-number">27.</span> <span class="toc-text">7. GC 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">28.</span> <span class="toc-text">8. 常见的垃圾收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%BB%80%E4%B9%88%E6%98%AF-Stop-The-World-STW-%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">9. 什么是 Stop-The-World (STW)？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-JVM-%E8%B0%83%E4%BC%98%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0"><span class="toc-number">30.</span> <span class="toc-text">10. JVM 调优常见参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">30.1.</span> <span class="toc-text">六、并发编程基础</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java-%E4%B8%AD%E7%9A%84-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">31.</span> <span class="toc-text">1. Java 中的 volatile 关键字的底层实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-synchronized-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">32.</span> <span class="toc-text">2. synchronized 的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">33.</span> <span class="toc-text">3. 偏向锁、轻量级锁、重量级锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF-CAS-%E6%93%8D%E4%BD%9C%EF%BC%9FABA-%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">4. 什么是 CAS 操作？ABA 问题如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%E4%B8%BE%E4%BE%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="toc-number">35.</span> <span class="toc-text">5. 什么是线程安全？举例线程安全类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-ThreadLocal-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">36.</span> <span class="toc-text">6. ThreadLocal 的底层原理与内存泄漏问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">37.</span> <span class="toc-text">7. 线程池的核心参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">38.</span> <span class="toc-text">8. 什么是拒绝策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Executors-%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">39.</span> <span class="toc-text">9. Executors 提供的常见线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Future-%E5%92%8C-CompletableFuture-%E5%8C%BA%E5%88%AB"><span class="toc-number">40.</span> <span class="toc-text">10. Future 和 CompletableFuture 区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%BC%96%E8%AF%91-%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-number">40.1.</span> <span class="toc-text">七、编译 &amp; 运行时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java-%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">1. Java 的反射机制是什么？底层原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%8D%E5%B0%84%E6%80%A7%E8%83%BD%E5%B7%AE%EF%BC%9FJDK-9-%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">2. 为什么反射性能差？JDK 9 之后如何优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9FJDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-CGLIB-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">3. 什么是动态代理？JDK 动态代理和 CGLIB 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%B3%A8%E8%A7%A3%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">44.</span> <span class="toc-text">4. 注解的底层原理是什么？运行时注解如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-ClassLoader-%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">5. ClassLoader 的双亲委派模型是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%EF%BC%9F"><span class="toc-number">46.</span> <span class="toc-text">6. 如何打破双亲委派？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF-SPI%EF%BC%88Service-Provider-Interface%EF%BC%89%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">47.</span> <span class="toc-text">7. 什么是 SPI（Service Provider Interface）机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Java-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">48.</span> <span class="toc-text">8. Java 是如何实现跨平台的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-JIT%EF%BC%88%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%89%E4%BC%98%E5%8C%96%E4%BA%86%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">9. JIT（即时编译器）优化了哪些东西？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">10. 什么是逃逸分析？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF-%E8%AE%BE%E8%AE%A1"><span class="toc-number">50.1.</span> <span class="toc-text">八、常见场景 &amp; 设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8-Java-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%93%AA%E7%A7%8D%E6%9C%80%E4%BC%98%EF%BC%9F"><span class="toc-number">51.</span> <span class="toc-text">1. 单例模式在 Java 中有哪些实现方式？哪种最优？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">52.</span> <span class="toc-text">2. 懒汉模式和饿汉模式的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">53.</span> <span class="toc-text">3. 枚举单例为什么是最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">54.</span> <span class="toc-text">4. 为什么要用工厂模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">55.</span> <span class="toc-text">5. 装饰器模式和代理模式区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Java-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">56.</span> <span class="toc-text">6. Java 中的事件监听模型是怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">57.</span> <span class="toc-text">7. 为什么 Java 不支持多继承？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E7%94%A8-Java-%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">58.</span> <span class="toc-text">8. 如何用 Java 实现回调机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Java-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">9. Java 中如何实现观察者模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Optional-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%88%9D%E8%A1%B7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">60.</span> <span class="toc-text">10. Optional 的设计初衷是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%8830%E9%A2%98%EF%BC%89"><span class="toc-number">61.</span> <span class="toc-text">二、Java 并发编程（30题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">62.</span> <span class="toc-text">1. 线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">63.</span> <span class="toc-text">2. 创建线程的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Runnable-%E5%92%8C-Callable-%E5%8C%BA%E5%88%AB"><span class="toc-number">64.</span> <span class="toc-text">3. Runnable 和 Callable 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Future-%E5%92%8C-CompletableFuture-%E5%8C%BA%E5%88%AB"><span class="toc-number">65.</span> <span class="toc-text">4. Future 和 CompletableFuture 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-ThreadLocal-%E5%8E%9F%E7%90%86"><span class="toc-number">66.</span> <span class="toc-text">5. ThreadLocal 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-synchronized-%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">67.</span> <span class="toc-text">6. synchronized 的锁优化机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-ReentrantLock-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">68.</span> <span class="toc-text">7. ReentrantLock 实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8C%BA%E5%88%AB"><span class="toc-number">69.</span> <span class="toc-text">8. 公平锁和非公平锁区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E5%8C%BA%E5%88%AB"><span class="toc-number">70.</span> <span class="toc-text">9. 乐观锁和悲观锁区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-AQS-%E5%8E%9F%E7%90%86"><span class="toc-number">71.</span> <span class="toc-text">10. AQS 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-CountDownLatch-%E5%92%8C-CyclicBarrier-%E5%8C%BA%E5%88%AB"><span class="toc-number">72.</span> <span class="toc-text">11. CountDownLatch 和 CyclicBarrier 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Semaphore-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">73.</span> <span class="toc-text">12. Semaphore 的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Exchanger-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">74.</span> <span class="toc-text">13. Exchanger 的使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-ForkJoinPool-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">75.</span> <span class="toc-text">14. ForkJoinPool 的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-CAS-%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">76.</span> <span class="toc-text">15. CAS 操作的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-ABA-%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">77.</span> <span class="toc-text">16. ABA 问题及解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%8E%9F%E7%90%86"><span class="toc-number">78.</span> <span class="toc-text">17. Atomic 原子类原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-BlockingQueue-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">79.</span> <span class="toc-text">18. BlockingQueue 实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-ConcurrentHashMap-%E7%9A%84%E5%88%86%E6%AE%B5%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">80.</span> <span class="toc-text">19. ConcurrentHashMap 的分段锁机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-ConcurrentHashMap-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">81.</span> <span class="toc-text">20. ConcurrentHashMap 扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-CopyOnWriteArrayList-%E5%8E%9F%E7%90%86"><span class="toc-number">82.</span> <span class="toc-text">21. CopyOnWriteArrayList 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">83.</span> <span class="toc-text">22. 线程池核心参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">84.</span> <span class="toc-text">23. 线程池拒绝策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">85.</span> <span class="toc-text">24. 线程池工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-ThreadPoolExecutor-vs-ScheduledThreadPoolExecutor"><span class="toc-number">86.</span> <span class="toc-text">25. ThreadPoolExecutor vs ScheduledThreadPoolExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8-Executors-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">87.</span> <span class="toc-text">26. 为什么不建议使用 Executors 创建线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-JMM-%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">88.</span> <span class="toc-text">27. JMM 内存可见性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-happens-before-%E8%A7%84%E5%88%99"><span class="toc-number">89.</span> <span class="toc-text">28. happens-before 规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6%E5%8F%8A%E9%81%BF%E5%85%8D"><span class="toc-number">90.</span> <span class="toc-text">29. 死锁产生条件及避免</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-number">91.</span> <span class="toc-text">30. 常见并发容器及区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81JVM-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8830%E9%A2%98%EF%BC%89"><span class="toc-number">92.</span> <span class="toc-text">三、JVM 与性能优化（30题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">93.</span> <span class="toc-text">1. JVM 内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">94.</span> <span class="toc-text">2. 堆和栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%81%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%88%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">95.</span> <span class="toc-text">3. 新生代、老年代、永久代（元空间）的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">96.</span> <span class="toc-text">4. 对象的创建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">97.</span> <span class="toc-text">5. 对象的内存分配策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-GC-Roots"><span class="toc-number">98.</span> <span class="toc-text">6. GC Roots</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">99.</span> <span class="toc-text">7. 垃圾回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-CMS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">100.</span> <span class="toc-text">8. CMS 垃圾回收器流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">101.</span> <span class="toc-text">9. G1 垃圾回收器原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-ZGC-%E5%92%8C-Shenandoah-%E7%89%B9%E7%82%B9"><span class="toc-number">102.</span> <span class="toc-text">10. ZGC 和 Shenandoah 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Minor-GC-%E4%B8%8E-Full-GC-%E5%8C%BA%E5%88%AB"><span class="toc-number">103.</span> <span class="toc-text">11. Minor GC 与 Full GC 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-OOM-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8E%92%E6%9F%A5"><span class="toc-number">104.</span> <span class="toc-text">12. OOM 常见类型及排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">105.</span> <span class="toc-text">13. 类加载器分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%A0%B4%E5%9D%8F%E5%9C%BA%E6%99%AF"><span class="toc-number">106.</span> <span class="toc-text">14. 双亲委派模型破坏场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-JVM-%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="toc-number">107.</span> <span class="toc-text">15. JVM 常见参数调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-vs-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">108.</span> <span class="toc-text">16. 内存泄漏 vs 内存溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">109.</span> <span class="toc-text">17. 逃逸分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="toc-number">110.</span> <span class="toc-text">18. 方法内联</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-JIT-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-number">111.</span> <span class="toc-text">19. JIT 编译器优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Safepoint-%E6%9C%BA%E5%88%B6"><span class="toc-number">112.</span> <span class="toc-text">20. Safepoint 机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Stop-The-World-STW"><span class="toc-number">113.</span> <span class="toc-text">21. Stop The World (STW)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-Finalize-%E6%96%B9%E6%B3%95%E9%97%AE%E9%A2%98"><span class="toc-number">114.</span> <span class="toc-text">22. Finalize 方法问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-JVM-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E5%9B%9E%E6%94%B6"><span class="toc-number">115.</span> <span class="toc-text">23. JVM 如何判断对象可回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-TLAB%EF%BC%88Thread-Local-Allocation-Buffer%EF%BC%89%E4%BD%9C%E7%94%A8"><span class="toc-number">116.</span> <span class="toc-text">24. TLAB（Thread Local Allocation Buffer）作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Direct-Memory-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A-OOM"><span class="toc-number">117.</span> <span class="toc-text">25. Direct Memory 为什么会 OOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Metaspace-%E4%BD%9C%E7%94%A8"><span class="toc-number">118.</span> <span class="toc-text">26. Metaspace 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-Full-GC-%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">119.</span> <span class="toc-text">27. Full GC 触发条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E6%9F%A5%E7%9C%8B-JVM-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">120.</span> <span class="toc-text">28. 查看 JVM 内存使用情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-Arthas-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">121.</span> <span class="toc-text">29. Arthas 常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-JVM-%E8%B0%83%E4%BC%98%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">122.</span> <span class="toc-text">30. JVM 调优常见面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Spring-Spring-Boot%EF%BC%8830%E9%A2%98%EF%BC%89"><span class="toc-number">123.</span> <span class="toc-text">四、Spring &amp; Spring Boot（30题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring-%E7%9A%84-IoC-%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">123.1.</span> <span class="toc-text">1. Spring 的 IoC 容器原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">123.2.</span> <span class="toc-text">2. Bean 的生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-BeanFactory-%E5%92%8C-ApplicationContext-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">123.3.</span> <span class="toc-text">3. BeanFactory 和 ApplicationContext 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8D%95%E4%BE%8B-Bean-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">123.4.</span> <span class="toc-text">4. 单例 Bean 如何保证线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Spring-AOP-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">123.5.</span> <span class="toc-text">5. Spring AOP 的实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-CGLIB-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">123.6.</span> <span class="toc-text">6. JDK 动态代理和 CGLIB 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Spring-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">123.7.</span> <span class="toc-text">7. Spring 事务的传播机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Spring-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F"><span class="toc-number">123.8.</span> <span class="toc-text">8. Spring 事务的隔离级别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Transactional-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">123.9.</span> <span class="toc-text">9. @Transactional 的实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">123.10.</span> <span class="toc-text">10. 循环依赖如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Spring-%E7%9A%84%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">123.11.</span> <span class="toc-text">11. Spring 的三级缓存解决了什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Spring-MVC-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">123.12.</span> <span class="toc-text">12. Spring MVC 的工作流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-DispatcherServlet-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">123.13.</span> <span class="toc-text">13. DispatcherServlet 的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Spring-Boot-%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">123.14.</span> <span class="toc-text">14. Spring Boot 的自动装配原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Spring-Boot-Starter-%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">123.15.</span> <span class="toc-text">15. Spring Boot Starter 的机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-ConfigurationProperties-%E5%92%8C-Value-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">123.16.</span> <span class="toc-text">16. @ConfigurationProperties 和 @Value 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Spring-Boot-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2%EF%BC%9F"><span class="toc-number">123.17.</span> <span class="toc-text">17. Spring Boot 如何实现热部署？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Spring-Boot-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-number">123.18.</span> <span class="toc-text">18. Spring Boot 如何处理配置文件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Conditional-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">123.19.</span> <span class="toc-text">19. @Conditional 注解的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Spring-Boot-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BC%98%E5%8C%96%E7%82%B9%EF%BC%9F"><span class="toc-number">123.20.</span> <span class="toc-text">20. Spring Boot 常见的优化点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-Spring-Boot-%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">123.21.</span> <span class="toc-text">21. Spring Boot 的自动配置原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-Spring-Boot-%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">123.22.</span> <span class="toc-text">22. Spring Boot 的启动流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-Spring-Boot-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">123.23.</span> <span class="toc-text">23. Spring Boot 的配置文件加载顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-Spring-Boot-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2"><span class="toc-number">123.24.</span> <span class="toc-text">24. Spring Boot 如何实现热部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-Spring-Boot-%E4%B8%AD%E7%9A%84%E7%9B%91%E6%8E%A7%E5%92%8C%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="toc-number">123.25.</span> <span class="toc-text">25. Spring Boot 中的监控和健康检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-Spring-Boot-%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88JDBC%E3%80%81JPA%E3%80%81MyBatis%EF%BC%89"><span class="toc-number">123.26.</span> <span class="toc-text">26. Spring Boot 如何集成数据库（JDBC、JPA、MyBatis）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-Spring-Boot-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86"><span class="toc-number">123.27.</span> <span class="toc-text">27. Spring Boot 如何实现日志管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-Spring-Boot-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%88CORS%EF%BC%89"><span class="toc-number">123.28.</span> <span class="toc-text">28. Spring Boot 如何处理跨域问题（CORS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-Spring-Boot-%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%EF%BC%88Spring-Security%EF%BC%89"><span class="toc-number">123.29.</span> <span class="toc-text">29. Spring Boot 中的安全机制（Spring Security）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-Spring-Boot-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6"><span class="toc-number">123.30.</span> <span class="toc-text">30. 如何优化 Spring Boot 启动速度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Spring-Cloud%EF%BC%8830%E9%A2%98%EF%BC%89"><span class="toc-number">124.</span> <span class="toc-text">五、Spring Cloud（30题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Spring-Cloud-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">125.</span> <span class="toc-text">1. Spring Cloud 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Spring-Cloud-%E5%92%8C-Dubbo-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">126.</span> <span class="toc-text">2. Spring Cloud 和 Dubbo 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Eureka-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">127.</span> <span class="toc-text">3. Eureka 的工作原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Eureka-%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">128.</span> <span class="toc-text">4. Eureka 的自我保护机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Ribbon-%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">129.</span> <span class="toc-text">5. Ribbon 的负载均衡策略？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Ribbon-%E5%92%8C-Nginx-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">130.</span> <span class="toc-text">6. Ribbon 和 Nginx 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Feign-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">131.</span> <span class="toc-text">7. Feign 的工作原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Feign-%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E7%86%94%E6%96%AD%EF%BC%9F"><span class="toc-number">132.</span> <span class="toc-text">8. Feign 如何支持熔断？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Hystrix-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">133.</span> <span class="toc-text">9. Hystrix 的工作原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Hystrix-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9A%94%E7%A6%BB%EF%BC%9F"><span class="toc-number">134.</span> <span class="toc-text">10. Hystrix 的线程池隔离和信号量隔离？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Resilience4j-%E5%92%8C-Hystrix-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">135.</span> <span class="toc-text">11. Resilience4j 和 Hystrix 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Gateway-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">136.</span> <span class="toc-text">12. Gateway 的核心功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Gateway-%E5%92%8C-Zuul-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">137.</span> <span class="toc-text">13. Gateway 和 Zuul 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Config-Server-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">138.</span> <span class="toc-text">14. Config Server 的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Config-Server-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%97%B6%E5%88%B7%E6%96%B0%EF%BC%9F"><span class="toc-number">139.</span> <span class="toc-text">15. Config Server 如何保证配置实时刷新？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Spring-Cloud-Bus-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">140.</span> <span class="toc-text">16. Spring Cloud Bus 的原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Sleuth-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">141.</span> <span class="toc-text">17. Sleuth 的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Sleuth-%E4%B8%8E-Zipkin-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">142.</span> <span class="toc-text">18. Sleuth 与 Zipkin 的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">143.</span> <span class="toc-text">19. 分布式链路追踪的原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Spring-Cloud-Stream-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">144.</span> <span class="toc-text">20. Spring Cloud Stream 的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">145.</span> <span class="toc-text">21. 消息驱动模型和事件驱动模型区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-Nacos-%E5%92%8C-Eureka-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">146.</span> <span class="toc-text">22. Nacos 和 Eureka 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Nacos-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%92%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">147.</span> <span class="toc-text">23. Nacos 配置中心和注册中心的实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Sentinel-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">148.</span> <span class="toc-text">24. Sentinel 的工作原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E9%99%90%E6%B5%81%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%EF%BC%88%E4%BB%A4%E7%89%8C%E6%A1%B6%E3%80%81%E6%BC%8F%E6%A1%B6%EF%BC%89%EF%BC%9F"><span class="toc-number">149.</span> <span class="toc-text">25. 限流的常见算法（令牌桶、漏桶）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E7%86%94%E6%96%AD%E5%92%8C%E9%99%8D%E7%BA%A7%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">150.</span> <span class="toc-text">26. 熔断和降级的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-CAP-%E5%AE%9A%E7%90%86%E5%92%8C-Spring-Cloud-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">151.</span> <span class="toc-text">27. CAP 定理和 Spring Cloud 的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-Spring-Cloud-%E4%B8%8E-Kubernetes-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">152.</span> <span class="toc-text">28. Spring Cloud 与 Kubernetes 的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%EF%BC%9F"><span class="toc-number">153.</span> <span class="toc-text">29. 微服务中的灰度发布？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-Spring-Cloud-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%EF%BC%9F"><span class="toc-number">154.</span> <span class="toc-text">30. Spring Cloud 如何实现服务网格？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%8830%E9%A2%98%EF%BC%89"><span class="toc-number">155.</span> <span class="toc-text">六、微服务架构 &amp; 分布式系统（30题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="toc-number">156.</span> <span class="toc-text">1. 什么是微服务？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E-SOA-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">157.</span> <span class="toc-text">2. 微服务与 SOA 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">158.</span> <span class="toc-text">3. 微服务的优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">159.</span> <span class="toc-text">4. 微服务的拆分原则？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">160.</span> <span class="toc-text">5. 如何保证微服务之间的数据一致性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">161.</span> <span class="toc-text">6. 分布式事务有哪些解决方案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-TCC%E3%80%81SAGA%E3%80%81XA-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">162.</span> <span class="toc-text">7. TCC、SAGA、XA 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">163.</span> <span class="toc-text">8. 本地消息表和可靠消息最终一致性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">164.</span> <span class="toc-text">9. 分布式锁的实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-number">165.</span> <span class="toc-text">10. Redis 分布式锁的缺陷？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">166.</span> <span class="toc-text">11. Zookeeper 分布式锁的实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">167.</span> <span class="toc-text">12. 数据库分库分表策略？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86%E4%B8%8E%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">168.</span> <span class="toc-text">13. 水平拆分与垂直拆分区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%88%86%E5%B8%83%E5%BC%8F-ID-%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">169.</span> <span class="toc-text">14. 分布式 ID 生成方案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">170.</span> <span class="toc-text">15. 雪花算法的原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-API-%E7%BD%91%E5%85%B3%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">171.</span> <span class="toc-text">16. API 网关的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">172.</span> <span class="toc-text">17. 服务注册与发现机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="toc-number">173.</span> <span class="toc-text">18. 微服务如何保证高可用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%99%90%E6%B5%81%E5%92%8C%E7%86%94%E6%96%AD%EF%BC%9F"><span class="toc-number">174.</span> <span class="toc-text">19. 微服务中的限流和熔断？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">175.</span> <span class="toc-text">20. 微服务如何保证安全性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-OAuth2-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">176.</span> <span class="toc-text">21. OAuth2 的原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-JWT-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">177.</span> <span class="toc-text">22. JWT 的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-SSO-%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">178.</span> <span class="toc-text">23. 单点登录 SSO 的实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">179.</span> <span class="toc-text">24. 配置中心的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB%EF%BC%9F"><span class="toc-number">180.</span> <span class="toc-text">25. 微服务中的监控体系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Prometheus-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">181.</span> <span class="toc-text">26. Prometheus 的原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-ELK-%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-number">182.</span> <span class="toc-text">27. ELK 在微服务中的应用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-number">183.</span> <span class="toc-text">28. 服务调用链路追踪的意义？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">184.</span> <span class="toc-text">29. 服务雪崩效应是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="toc-number">185.</span> <span class="toc-text">30. 如何设计一个高并发的微服务系统？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98%EF%BC%8830%E9%A2%98%EF%BC%89"><span class="toc-number">186.</span> <span class="toc-text">七、数据库 &amp; 缓存（30题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-MySQL-%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">187.</span> <span class="toc-text">1. MySQL 的存储引擎区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-InnoDB-%E5%92%8C-MyISAM-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">188.</span> <span class="toc-text">2. InnoDB 和 MyISAM 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-MySQL-%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7"><span class="toc-number">189.</span> <span class="toc-text">3. MySQL 事务特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MVCC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">190.</span> <span class="toc-text">4. MVCC 的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-MySQL-%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">191.</span> <span class="toc-text">5. MySQL 的索引类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-vs-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">192.</span> <span class="toc-text">6. 聚簇索引 vs 非聚簇索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="toc-number">193.</span> <span class="toc-text">7. B+ 树索引原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95-vs-%E5%9B%9E%E8%A1%A8"><span class="toc-number">194.</span> <span class="toc-text">8. 覆盖索引 vs 回表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BC%98%E5%8C%96"><span class="toc-number">195.</span> <span class="toc-text">9. 索引下推优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-MySQL-%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">196.</span> <span class="toc-text">10. MySQL 锁机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E8%A1%8C%E9%94%81-vs-%E8%A1%A8%E9%94%81"><span class="toc-number">197.</span> <span class="toc-text">11. 行锁 vs 表锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-number">198.</span> <span class="toc-text">12. 间隙锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5"><span class="toc-number">199.</span> <span class="toc-text">13. 死锁排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-SQL-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">200.</span> <span class="toc-text">14. SQL 执行计划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">201.</span> <span class="toc-text">15. 慢查询优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E9%9A%BE%E7%82%B9"><span class="toc-number">202.</span> <span class="toc-text">16. 分库分表难点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">203.</span> <span class="toc-text">17. 分布式事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">204.</span> <span class="toc-text">18. Redis 数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="toc-number">205.</span> <span class="toc-text">19. Redis 为什么快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">206.</span> <span class="toc-text">20. Redis 持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Redis-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">207.</span> <span class="toc-text">21. Redis 过期策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">208.</span> <span class="toc-text">22. Redis 内存淘汰策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">209.</span> <span class="toc-text">23. Redis 主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Redis-%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">210.</span> <span class="toc-text">24. Redis 哨兵机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Redis-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">211.</span> <span class="toc-text">25. Redis 集群模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">212.</span> <span class="toc-text">26. Redis 分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-Redis-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">213.</span> <span class="toc-text">27. Redis 常见问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9"><span class="toc-number">214.</span> <span class="toc-text">28. 缓存穿透、击穿、雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">215.</span> <span class="toc-text">29. 缓存与数据库一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-Redis-vs-Caffeine"><span class="toc-number">216.</span> <span class="toc-text">30. Redis vs Caffeine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8830%E9%A2%98%EF%BC%89"><span class="toc-number">217.</span> <span class="toc-text">八、消息队列（30题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">218.</span> <span class="toc-text">1. 为什么要使用消息队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">219.</span> <span class="toc-text">2. 消息队列的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-RabbitMQ-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">220.</span> <span class="toc-text">3. RabbitMQ 核心组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-RabbitMQ-%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">221.</span> <span class="toc-text">4. RabbitMQ 消息确认机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Kafka-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">222.</span> <span class="toc-text">5. Kafka 核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Kafka-%E5%88%86%E5%8C%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">223.</span> <span class="toc-text">6. Kafka 分区机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Kafka-%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6"><span class="toc-number">224.</span> <span class="toc-text">7. Kafka 副本机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Kafka-ISR-%E5%8E%9F%E7%90%86"><span class="toc-number">225.</span> <span class="toc-text">8. Kafka ISR 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Kafka-%E6%B6%88%E8%B4%B9%E7%BB%84%E5%8E%9F%E7%90%86"><span class="toc-number">226.</span> <span class="toc-text">9. Kafka 消费组原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Kafka-Offset-%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F"><span class="toc-number">227.</span> <span class="toc-text">10. Kafka Offset 提交方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Kafka-%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F%E5%8E%9F%E7%90%86"><span class="toc-number">228.</span> <span class="toc-text">11. Kafka 高吞吐量原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Kafka-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6"><span class="toc-number">229.</span> <span class="toc-text">12. Kafka 零拷贝机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-RocketMQ-%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="toc-number">230.</span> <span class="toc-text">13. RocketMQ 核心特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-RocketMQ-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">231.</span> <span class="toc-text">14. RocketMQ 顺序消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-RocketMQ-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">232.</span> <span class="toc-text">15. RocketMQ 事务消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">233.</span> <span class="toc-text">16. 如何保证消息不丢失</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">234.</span> <span class="toc-text">17. 如何保证消息不重复消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F"><span class="toc-number">235.</span> <span class="toc-text">18. 如何保证消息有序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">236.</span> <span class="toc-text">19. 消息堆积解决办法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">237.</span> <span class="toc-text">20. 如何设计延迟队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%BD%9C%E7%94%A8"><span class="toc-number">238.</span> <span class="toc-text">21. 死信队列作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E5%B9%82%E7%AD%89%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">239.</span> <span class="toc-text">22. 幂等实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%99%90%E6%B5%81%E6%96%B9%E5%BC%8F"><span class="toc-number">240.</span> <span class="toc-text">23. 消息队列限流方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9B%91%E6%8E%A7"><span class="toc-number">241.</span> <span class="toc-text">24. 消息队列监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Kafka-vs-RabbitMQ"><span class="toc-number">242.</span> <span class="toc-text">25. Kafka vs RabbitMQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Kafka-vs-RocketMQ"><span class="toc-number">243.</span> <span class="toc-text">26. Kafka vs RocketMQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-Pulsar-%E7%89%B9%E7%82%B9"><span class="toc-number">244.</span> <span class="toc-text">27. Pulsar 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">245.</span> <span class="toc-text">28. 消息中间件如何保证高可用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95"><span class="toc-number">246.</span> <span class="toc-text">29. 消息队列水平扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-vs-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="toc-number">247.</span> <span class="toc-text">30. 消息队列 vs 事件总线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81DevOps-%E5%AE%B9%E5%99%A8%E5%8C%96%EF%BC%8830%E9%A2%98%EF%BC%89"><span class="toc-number">248.</span> <span class="toc-text">九、DevOps &amp; 容器化（30题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-CI-CD-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">249.</span> <span class="toc-text">1. CI&#x2F;CD 的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Jenkins-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">250.</span> <span class="toc-text">2. Jenkins 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Docker-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">251.</span> <span class="toc-text">3. Docker 核心原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Docker-%E9%95%9C%E5%83%8F-vs-%E5%AE%B9%E5%99%A8"><span class="toc-number">252.</span> <span class="toc-text">4. Docker 镜像 vs 容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Dockerfile-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">253.</span> <span class="toc-text">5. Dockerfile 常用指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-number">254.</span> <span class="toc-text">6. 镜像分层机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%B9%E5%99%A8-vs-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">255.</span> <span class="toc-text">7. 容器 vs 虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Kubernetes-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">256.</span> <span class="toc-text">8. Kubernetes 核心组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Pod-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">257.</span> <span class="toc-text">9. Pod 生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Deployment-vs-StatefulSet"><span class="toc-number">258.</span> <span class="toc-text">10. Deployment vs StatefulSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-K8s-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">259.</span> <span class="toc-text">11. K8s 服务发现机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-ConfigMap-%E5%92%8C-Secret"><span class="toc-number">260.</span> <span class="toc-text">12. ConfigMap 和 Secret</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Ingress-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">261.</span> <span class="toc-text">13. Ingress 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-K8s-%E6%B0%B4%E5%B9%B3%E6%89%A9%E7%BC%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">262.</span> <span class="toc-text">14. K8s 水平扩缩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-K8s-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">263.</span> <span class="toc-text">15. K8s 滚动更新机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-K8s-%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83"><span class="toc-number">264.</span> <span class="toc-text">16. K8s 灰度发布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-K8s-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">265.</span> <span class="toc-text">17. K8s 调度策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-K8s-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">266.</span> <span class="toc-text">18. K8s 网络模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Service-Mesh-%E4%BD%9C%E7%94%A8"><span class="toc-number">267.</span> <span class="toc-text">19. Service Mesh 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Istio-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">268.</span> <span class="toc-text">20. Istio 工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Helm-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">269.</span> <span class="toc-text">21. Helm 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-K8s-%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88"><span class="toc-number">270.</span> <span class="toc-text">22. K8s 存储方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Prometheus-%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB"><span class="toc-number">271.</span> <span class="toc-text">23. Prometheus 监控体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Grafana-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">272.</span> <span class="toc-text">24. Grafana 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-K8s-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">273.</span> <span class="toc-text">25. K8s 安全机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">274.</span> <span class="toc-text">26. 容器资源限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-Docker-Compose-%E4%BD%9C%E7%94%A8"><span class="toc-number">275.</span> <span class="toc-text">27. Docker Compose 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-DevOps-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">276.</span> <span class="toc-text">28. DevOps 最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-GitOps-%E7%90%86%E5%BF%B5"><span class="toc-number">277.</span> <span class="toc-text">29. GitOps 理念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-K8s-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">278.</span> <span class="toc-text">30. K8s 如何保证高可用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%A2%98%EF%BC%8830%E9%A2%98%EF%BC%89"><span class="toc-number">279.</span> <span class="toc-text">十、场景设计题（30题）</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">数据结构</a><time datetime="2025-09-20T10:29:28.000Z" title="发表于 2025-09-20 18:29:28">2025-09-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" title="命令大全">命令大全</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/web/" title="web">web</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式">分布式</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/%E7%AE%97%E6%B3%95/" title="算法">算法</a><time datetime="2025-09-11T10:29:28.000Z" title="发表于 2025-09-11 18:29:28">2025-09-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bg.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Charlotte</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
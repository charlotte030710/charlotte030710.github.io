<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>题库 | 浮生若梦</title><meta name="author" content="Charlotte"><meta name="copyright" content="Charlotte"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="模块 1：网络OSI七层模型物理层（比特流传输，网线、光纤、网卡）题目 1（基础）： 物理层的主要功能是什么？常见设备有哪些？ 答案：  功能：在物理媒介上传输比特流（0&#x2F;1），实现数据的原始传输，不关心数据含义。 设备：网线（铜缆）、光纤、网卡、集线器、收发器。  题目 2（场景题）： 公司内网出现频繁掉线，怀疑是物理层问题，你会如何排查？ 答案：  检查网线是否损坏或接触不良； 使">
<meta property="og:type" content="article">
<meta property="og:title" content="题库">
<meta property="og:url" content="https://charlotte030710.github.io/2025/09/22/%E9%A2%98%E5%BA%93/index.html">
<meta property="og:site_name" content="浮生若梦">
<meta property="og:description" content="模块 1：网络OSI七层模型物理层（比特流传输，网线、光纤、网卡）题目 1（基础）： 物理层的主要功能是什么？常见设备有哪些？ 答案：  功能：在物理媒介上传输比特流（0&#x2F;1），实现数据的原始传输，不关心数据含义。 设备：网线（铜缆）、光纤、网卡、集线器、收发器。  题目 2（场景题）： 公司内网出现频繁掉线，怀疑是物理层问题，你会如何排查？ 答案：  检查网线是否损坏或接触不良； 使">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://charlotte030710.github.io/img/title.jpg">
<meta property="article:published_time" content="2025-09-21T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-24T11:49:38.272Z">
<meta property="article:author" content="Charlotte">
<meta property="article:tag" content="java">
<meta property="article:tag" content="Mysql">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://charlotte030710.github.io/img/title.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "题库",
  "url": "https://charlotte030710.github.io/2025/09/22/%E9%A2%98%E5%BA%93/",
  "image": "https://charlotte030710.github.io/img/title.jpg",
  "datePublished": "2025-09-21T16:00:00.000Z",
  "dateModified": "2025-09-24T11:49:38.272Z",
  "author": [
    {
      "@type": "Person",
      "name": "Charlotte",
      "url": "https://charlotte030710.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="https://charlotte030710.github.io/2025/09/22/%E9%A2%98%E5%BA%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '题库',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="浮生若梦" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/title.jpg" alt="Logo"><span class="site-name">浮生若梦</span></a><a class="nav-page-title" href="/"><span class="site-name">题库</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">题库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-21T16:00:00.000Z" title="发表于 2025-09-22 00:00:00">2025-09-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-24T11:49:38.272Z" title="更新于 2025-09-24 19:49:38">2025-09-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<h2 id="模块-1：网络"><a href="#模块-1：网络" class="headerlink" title="模块 1：网络"></a>模块 1：网络</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><h4 id="物理层（比特流传输，网线、光纤、网卡）"><a href="#物理层（比特流传输，网线、光纤、网卡）" class="headerlink" title="物理层（比特流传输，网线、光纤、网卡）"></a>物理层（比特流传输，网线、光纤、网卡）</h4><p><strong>题目 1（基础）</strong>：<br> 物理层的主要功能是什么？常见设备有哪些？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>功能：在物理媒介上传输比特流（0&#x2F;1），实现数据的原始传输，不关心数据含义。</li>
<li>设备：网线（铜缆）、光纤、网卡、集线器、收发器。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 公司内网出现频繁掉线，怀疑是物理层问题，你会如何排查？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>检查网线是否损坏或接触不良；</li>
<li>使用网线测试仪或更换线缆；</li>
<li>检查光纤接口是否有污染或折损；</li>
<li>查看网卡指示灯或更换网卡；</li>
<li>检查集线器&#x2F;交换机端口状态。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 物理层和数据链路层的主要区别是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>物理层：负责比特流传输，只关注信号，不处理数据含义；</li>
<li>数据链路层：负责成帧、MAC 地址寻址、差错检测，保证帧正确到达邻居节点。</li>
</ul>
<hr>
<h4 id="数据链路层（成帧、MAC-地址、交换机、以太网协议）"><a href="#数据链路层（成帧、MAC-地址、交换机、以太网协议）" class="headerlink" title="数据链路层（成帧、MAC 地址、交换机、以太网协议）"></a>数据链路层（成帧、MAC 地址、交换机、以太网协议）</h4><p><strong>题目 1（基础）</strong>：<br> 交换机是如何通过 MAC 地址转发数据的？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>交换机维护 MAC 地址表，将端口和 MAC 地址对应；</li>
<li>帧到达交换机时查表决定转发端口，若未知则广播。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 内网出现广播风暴，网络拥堵，原因可能是什么？如何解决？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>原因：交换机环路、MAC 表不完整导致频繁广播。</li>
<li>解决方案：启用 STP（生成树协议）、检查拓扑避免环路、划分 VLAN 减少广播域。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 以太网帧结构包含哪些字段？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>前导码+帧头（同步）；</li>
<li>目的 MAC（6B）、源 MAC（6B）；</li>
<li>类型&#x2F;长度（2B）；</li>
<li>数据（46~1500B）；</li>
<li>CRC（4B）用于错误检测。</li>
</ul>
<hr>
<h4 id="网络层（IP-地址、子网、路由、ICMP、ARP）"><a href="#网络层（IP-地址、子网、路由、ICMP、ARP）" class="headerlink" title="网络层（IP 地址、子网、路由、ICMP、ARP）"></a>网络层（IP 地址、子网、路由、ICMP、ARP）</h4><p><strong>题目 1（基础）</strong>：<br> 网络层的主要功能是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>功能：为数据包选择路径和传输，进行逻辑地址寻址；</li>
<li>主要协议：IP、ICMP、ARP；</li>
<li>设备：路由器。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 用户无法访问某服务器，ping 不通，如何排查网络层问题？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>检查本机 IP、子网掩码、默认网关；</li>
<li>使用 <strong>ping</strong> 测试本机、网关、目标 IP；</li>
<li>使用 <strong>traceroute</strong> 查看路由是否异常；</li>
<li>检查防火墙和路由策略。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> ARP 协议的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>ARP 用于将 IP 地址映射到 MAC 地址，实现局域网通信；</li>
<li>通过广播请求目标 IP 的 MAC，目标回复 MAC。</li>
</ul>
<hr>
<h4 id="传输层（TCP、UDP）"><a href="#传输层（TCP、UDP）" class="headerlink" title="传输层（TCP、UDP）"></a>传输层（TCP、UDP）</h4><p><strong>题目 1（基础）</strong>：<br> TCP 和 UDP 的区别是什么？</p>
<p><strong>答案</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>连接</td>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>可靠性</td>
<td>可靠传输</td>
<td>不可靠</td>
</tr>
<tr>
<td>传输方式</td>
<td>流式</td>
<td>数据报</td>
</tr>
<tr>
<td>应用</td>
<td>文件传输、HTTP</td>
<td>视频、语音、DNS</td>
</tr>
</tbody></table>
<p><strong>题目 2（场景题）</strong>：<br> 视频会议使用 UDP 而不是 TCP，为什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>UDP 无连接、延迟低；</li>
<li>丢包不会触发重传，保证实时性；</li>
<li>TCP 重传可能导致延迟增加，影响视频流畅度。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> TCP 如何保证可靠传输？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>三次握手建立连接；</li>
<li>序列号、确认号保证顺序与可靠性；</li>
<li>流量控制：滑动窗口；</li>
<li>拥塞控制：慢启动、拥塞避免、快重传、快恢复。</li>
</ul>
<hr>
<h4 id="会话层（建立、管理、终止会话）"><a href="#会话层（建立、管理、终止会话）" class="headerlink" title="会话层（建立、管理、终止会话）"></a>会话层（建立、管理、终止会话）</h4><p><strong>题目 1（基础）</strong>：<br> 会话层的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>建立、管理、终止应用间会话；</li>
<li>提供会话恢复、同步、对话控制。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 在长连接的聊天应用中，会话层出现问题可能导致什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>会话无法正确建立 → 无法通信；</li>
<li>会话异常终止 → 消息丢失或重复；</li>
<li>解决方案：心跳包检测、会话重连机制。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 举例说明会话层协议。</p>
<p><strong>答案</strong>：</p>
<ul>
<li>PPTP、RPC、NetBIOS、SSL&#x2F;TLS（兼作表示层加密）。</li>
</ul>
<hr>
<h4 id="表示层（数据表示、加密解密、编码）"><a href="#表示层（数据表示、加密解密、编码）" class="headerlink" title="表示层（数据表示、加密解密、编码）"></a>表示层（数据表示、加密解密、编码）</h4><p><strong>题目 1（基础）</strong>：<br> 表示层的主要功能是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>数据表示、加密解密、编码转换；</li>
<li>常用协议：SSL&#x2F;TLS、Unicode、ASCII。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> HTTP 数据在网络上传输是明文还是加密？TLS 在表示层如何工作？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>HTTP 明文传输，HTTPS 使用 TLS 加密；</li>
<li>TLS 握手交换公钥、协商对称密钥，建立加密通道；</li>
<li>表示层负责数据加密和解密。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 解释前向保密（PFS）是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>即使私钥泄露，也无法解密历史通信数据；</li>
<li>TLS1.3 默认支持 PFS，通过临时密钥保证安全。</li>
</ul>
<hr>
<h4 id="应用层（HTTP、HTTPS、FTP、DNS、SMTP、SSH）"><a href="#应用层（HTTP、HTTPS、FTP、DNS、SMTP、SSH）" class="headerlink" title="应用层（HTTP、HTTPS、FTP、DNS、SMTP、SSH）"></a>应用层（HTTP、HTTPS、FTP、DNS、SMTP、SSH）</h4><p><strong>题目 1（基础）</strong>：<br> 应用层协议有哪些？功能是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>HTTP&#x2F;HTTPS：网页传输；</li>
<li>FTP：文件传输；</li>
<li>DNS：域名解析；</li>
<li>SMTP：邮件发送；</li>
<li>SSH：远程登录。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 用户访问网页显示 404，说明了什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>HTTP 状态码 404 → 请求的资源不存在；</li>
<li>可通过 URL 检查、服务器文件路径、虚拟主机配置排查。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> HTTPS 与 HTTP 的区别是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>HTTP 明文传输；</li>
<li>HTTPS 使用 TLS 加密，保证数据机密性、完整性和身份验证。</li>
</ul>
<h4 id="网络接口层（驱动、网卡、MAC）"><a href="#网络接口层（驱动、网卡、MAC）" class="headerlink" title="网络接口层（驱动、网卡、MAC）"></a>网络接口层（驱动、网卡、MAC）</h4><p><strong>题目 1（基础）</strong>：<br> 网络接口层的主要功能是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>功能：负责把数据从主机传到物理网络，处理网卡驱动、MAC 地址寻址。</li>
<li>设备：网卡、驱动程序。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 网卡被替换后，局域网无法访问，怀疑网络接口层问题，你如何排查？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>检查网卡是否正确安装驱动；</li>
<li>确认 MAC 地址是否被禁用或冲突；</li>
<li>使用 <code>ifconfig</code> 或 <code>ip addr</code> 查看网卡状态；</li>
<li>测试物理连通性。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> MAC 地址在网络接口层的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>唯一标识网络接口设备；</li>
<li>局域网中用于帧的目的&#x2F;源地址寻址；</li>
<li>交换机根据 MAC 地址转发帧。</li>
</ul>
<hr>
<h4 id="网络层（IP、ICMP）"><a href="#网络层（IP、ICMP）" class="headerlink" title="网络层（IP、ICMP）"></a>网络层（IP、ICMP）</h4><p><strong>题目 1（基础）</strong>：<br> 网络层的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>功能：逻辑地址寻址、路由选择、数据包传输。</li>
<li>协议：IP、ICMP、ARP（局域网辅助）。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 用户无法访问外网，ping 路由器成功但 ping 外网失败，如何排查？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>检查默认网关配置是否正确；</li>
<li>查看路由表（<code>route -n</code> 或 <code>ip route</code>）；</li>
<li>检查防火墙规则或 NAT 设置；</li>
<li>使用 <code>traceroute</code> 确认数据包到达路径。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> ICMP 的主要作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>网络诊断（如 <code>ping</code>）；</li>
<li>报告网络错误（目的不可达、超时等）；</li>
<li>帮助路由器控制数据流。</li>
</ul>
<hr>
<h4 id="传输层（TCP、UDP）-1"><a href="#传输层（TCP、UDP）-1" class="headerlink" title="传输层（TCP、UDP）"></a>传输层（TCP、UDP）</h4><p><strong>题目 1（基础）</strong>：<br> 传输层的功能是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>为应用提供端到端通信；</li>
<li>实现可靠传输（TCP）或低延迟传输（UDP）；</li>
<li>流量控制、端口寻址。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 同一台服务器同时运行 HTTP（TCP）和 DNS（UDP）服务，它们如何通过端口区分？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>传输层通过 <strong>端口号</strong> 区分不同应用；</li>
<li>TCP HTTP 默认 80&#x2F;443，UDP DNS 默认 53；</li>
<li>内核根据四元组（源 IP&#x2F;端口 + 目的 IP&#x2F;端口 + 协议）区分流量。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> TCP 如何保证可靠传输？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>三次握手建立连接；</li>
<li>序列号、确认号保证顺序；</li>
<li>滑动窗口进行流量控制；</li>
<li>拥塞控制：慢启动、拥塞避免、快重传、快恢复。</li>
</ul>
<hr>
<h3 id="TCP-机制"><a href="#TCP-机制" class="headerlink" title="TCP 机制"></a>TCP 机制</h3><h4 id="三次握手（SYN、SYN-ACK、ACK）"><a href="#三次握手（SYN、SYN-ACK、ACK）" class="headerlink" title="三次握手（SYN、SYN+ACK、ACK）"></a>三次握手（SYN、SYN+ACK、ACK）</h4><p><strong>题目 1（基础）</strong>：<br> TCP 三次握手的目的是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>建立可靠连接；</li>
<li>双方同步初始序列号；</li>
<li>确认通道可用。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 三次握手中客户端发送 SYN 但服务器未响应，可能原因是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>服务器端口未开启；</li>
<li>防火墙阻止 SYN 包；</li>
<li>网络丢包或路由问题；</li>
<li>SYN 攻击导致资源耗尽。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 三次握手与四次挥手的区别是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>三次握手用于建立连接，双方确认序列号；</li>
<li>四次挥手用于断开连接，双方确认数据已传输完毕，涉及 TIME_WAIT 状态。</li>
</ul>
<hr>
<h4 id="四次挥手（FIN-ACK、TIME-WAIT）"><a href="#四次挥手（FIN-ACK、TIME-WAIT）" class="headerlink" title="四次挥手（FIN&#x2F;ACK、TIME_WAIT）"></a>四次挥手（FIN&#x2F;ACK、TIME_WAIT）</h4><p><strong>题目 1（基础）</strong>：<br> TCP 四次挥手的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>正确关闭 TCP 连接；</li>
<li>确保双方数据传输完毕；</li>
<li>TIME_WAIT 防止旧报文干扰新连接。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 客户端关闭连接后一直处于 TIME_WAIT，这会影响服务器吗？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>TIME_WAIT 会占用本地端口；</li>
<li>不会直接影响服务器，但大量短连接可能耗尽可用端口；</li>
<li>可通过缩短 TIME_WAIT 或复用端口优化。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> TCP 状态机中 CLOSE_WAIT、FIN_WAIT 的含义是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>CLOSE_WAIT：等待本端关闭连接（收到 FIN）；</li>
<li>FIN_WAIT：等待对端确认关闭连接。</li>
</ul>
<hr>
<h4 id="拥塞控制、流量控制"><a href="#拥塞控制、流量控制" class="headerlink" title="拥塞控制、流量控制"></a>拥塞控制、流量控制</h4><p><strong>题目 1（基础）</strong>：<br> TCP 拥塞控制包含哪些算法？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>慢启动（Slow Start）；</li>
<li>拥塞避免（Congestion Avoidance）；</li>
<li>快重传（Fast Retransmit）；</li>
<li>快恢复（Fast Recovery）。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 大量并发用户下载文件，服务器出现拥塞，TCP 如何缓解？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>慢启动限制初始发送窗口；</li>
<li>拥塞避免算法动态调整窗口大小；</li>
<li>快重传+快恢复减少丢包重传延迟；</li>
<li>流量控制（滑动窗口）防止接收端过载。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 流量控制与拥塞控制的区别是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>流量控制：接收端控制发送端，保证接收端不溢出；</li>
<li>拥塞控制：网络控制，防止过多报文导致网络拥塞。</li>
</ul>
<hr>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p><strong>题目 1（基础）</strong>：<br> UDP 的特点是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>无连接、不可靠；</li>
<li>无序到达、无重传；</li>
<li>低延迟，适合实时通信。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 在线直播使用 UDP，如果出现丢包，该怎么办？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>丢包不重传保证实时性；</li>
<li>使用前向纠错（FEC）或应用层重传部分关键帧；</li>
<li>使用 QoS 优化网络优先级。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> UDP 如何区分不同应用？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>通过 <strong>源端口和目的端口</strong>；</li>
<li>内核使用四元组（源 IP&#x2F;端口 + 目的 IP&#x2F;端口 + 协议）区分不同数据流。</li>
</ul>
<hr>
<h3 id="HTTPS-TLS"><a href="#HTTPS-TLS" class="headerlink" title="HTTPS&#x2F;TLS"></a>HTTPS&#x2F;TLS</h3><h3 id="握手、证书、加密"><a href="#握手、证书、加密" class="headerlink" title="握手、证书、加密"></a>握手、证书、加密</h3><p><strong>题目 1（基础）</strong>：<br> HTTPS 与 HTTP 的区别是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>HTTP 明文传输；</li>
<li>HTTPS 在应用层使用 TLS 加密，保证机密性、完整性和身份验证。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 访问 HTTPS 网站时，浏览器提示证书不可信，可能原因是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>自签名证书；</li>
<li>CA 根证书未安装或过期；</li>
<li>中间证书链缺失；</li>
<li>域名与证书不匹配。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> TLS 握手流程简述。</p>
<p><strong>答案</strong>：</p>
<ol>
<li>客户端发 ClientHello，支持协议版本和加密套件；</li>
<li>服务端发 ServerHello，选择协议和套件，并发送证书；</li>
<li>客户端验证证书，生成预主密钥并加密发送；</li>
<li>双方生成会话密钥，完成握手；</li>
<li>加密通信开始。</li>
</ol>
<h3 id="TLS-版本与前向保密"><a href="#TLS-版本与前向保密" class="headerlink" title="TLS 版本与前向保密"></a>TLS 版本与前向保密</h3><p><strong>题目 1（基础）</strong>：<br> TLS1.3 相比 TLS1.2 有哪些改进？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>简化握手，减少 RTT；</li>
<li>默认启用前向保密（PFS）；</li>
<li>弃用不安全加密算法（如 RC4、MD5）。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 攻击者获取服务器私钥，是否可以解密历史 HTTPS 会话？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>TLS1.2+使用 PFS 或 TLS1.3：不能解密历史会话；</li>
<li>非 PFS 情况：可解密历史通信。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 证书链、CA、OCSP 的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>证书链验证身份的可信性；</li>
<li>CA 签发证书，保证合法性；</li>
<li>CRL&#x2F;OCSP 用于撤销检查，防止使用被吊销的证书。</li>
</ul>
<hr>
<h3 id="常用网络工具"><a href="#常用网络工具" class="headerlink" title="常用网络工具"></a>常用网络工具</h3><h4 id="ping、traceroute"><a href="#ping、traceroute" class="headerlink" title="ping、traceroute"></a>ping、traceroute</h4><p><strong>题目 1（基础）</strong>：<br> ping 命令的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>检测网络连通性；</li>
<li>测量往返时间（RTT）；</li>
<li>使用 ICMP 回显请求。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> ping 成功但网页访问失败，可能原因是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>HTTP&#x2F;HTTPS 服务未启动或端口被阻塞；</li>
<li>防火墙允许 ICMP、阻止 TCP；</li>
<li>DNS 解析失败。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> traceroute 的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>显示数据包经过的路由节点；</li>
<li>帮助定位网络延迟或故障点。</li>
</ul>
<hr>
<h4 id="tcpdump、wireshark"><a href="#tcpdump、wireshark" class="headerlink" title="tcpdump、wireshark"></a>tcpdump、wireshark</h4><p><strong>题目 1（基础）</strong>：<br> tcpdump 和 Wireshark 的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>抓包、分析网络流量；</li>
<li>tcpdump 命令行，Wireshark 图形化。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 用户访问 HTTP 网站超时，用 tcpdump 如何分析？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>抓取客户端和服务器通信包；</li>
<li>检查 SYN&#x2F;ACK 是否正常返回；</li>
<li>检查是否有丢包、重传或拒绝连接。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> tcpdump 常用参数有哪些？</p>
<p><strong>答案</strong>：</p>
<ul>
<li><code>-i</code> 指定接口；</li>
<li><code>-n</code> 不解析域名；</li>
<li><code>-s</code> 指定抓包长度；</li>
<li><code>port</code> 或 <code>host</code> 过滤特定流量。</li>
</ul>
<hr>
<h4 id="ss、netstat、iftop"><a href="#ss、netstat、iftop" class="headerlink" title="ss、netstat、iftop"></a>ss、netstat、iftop</h4><p><strong>题目 1（基础）</strong>：<br> netstat 和 ss 有什么区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>ss 更快、替代 netstat；</li>
<li>显示 TCP&#x2F;UDP 连接、监听端口、套接字状态；</li>
<li>支持高级过滤。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 服务器高负载时，如何用 iftop 排查流量？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>iftop 实时显示网络带宽使用情况；</li>
<li>可按源&#x2F;目的 IP 排序，找到流量大户；</li>
<li>可结合 tcpdump 精细抓包分析。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> netstat&#x2F;ss 可以查看哪些信息？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>本地和远端 IP&#x2F;端口；</li>
<li>TCP 状态（ESTABLISHED、TIME_WAIT）；</li>
<li>使用的程序 PID&#x2F;名称；</li>
<li>统计数据（包数、字节数）。</li>
</ul>
<hr>
<h2 id="模块-2：Linux"><a href="#模块-2：Linux" class="headerlink" title="模块 2：Linux"></a>模块 2：Linux</h2><h3 id="常用命令（top、ps、df、du、netstat、ss、lsof、journalctl）"><a href="#常用命令（top、ps、df、du、netstat、ss、lsof、journalctl）" class="headerlink" title="常用命令（top、ps、df、du、netstat、ss、lsof、journalctl）"></a>常用命令（top、ps、df、du、netstat、ss、lsof、journalctl）</h3><p><strong>题目 1（基础）</strong>：<br> <code>top</code> 命令显示了哪些关键指标？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>CPU 使用率（us、sy、id、wa）；</li>
<li>内存使用情况（total、used、free、buffers&#x2F;cache）；</li>
<li>进程信息（PID、USER、%CPU、%MEM、COMMAND）；</li>
<li>负载平均值（load average）。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 服务器 CPU 占用过高，如何使用 <code>top</code> 和 <code>ps</code> 排查？</p>
<p><strong>答案</strong>：</p>
<ul>
<li><code>top</code> 查看占用 CPU 高的进程；</li>
<li><code>ps aux --sort=-%cpu</code> 查看 CPU 排名前几的进程；</li>
<li>结合 <code>lsof</code> 查看进程打开的文件；</li>
<li>判断是否为异常进程或应用逻辑问题。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> <code>df</code> 与 <code>du</code> 的区别是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li><code>df</code> 显示文件系统剩余空间（按分区统计）；</li>
<li><code>du</code> 显示目录或文件占用的实际空间；</li>
<li><code>df</code> 查看磁盘整体使用，<code>du</code> 查看具体目录。</li>
</ul>
<hr>
<h3 id="权限管理（rwx、chmod、chown、ACL、SUID-SGID-sticky-bit）"><a href="#权限管理（rwx、chmod、chown、ACL、SUID-SGID-sticky-bit）" class="headerlink" title="权限管理（rwx、chmod、chown、ACL、SUID&#x2F;SGID&#x2F;sticky bit）"></a>权限管理（rwx、chmod、chown、ACL、SUID&#x2F;SGID&#x2F;sticky bit）</h3><p><strong>题目 1（基础）</strong>：<br> Linux 文件权限 r、w、x 分别代表什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>r：可读；</li>
<li>w：可写；</li>
<li>x：可执行；</li>
<li>权限分为 <strong>用户、用户组、其他</strong> 三类。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 用户 A 无法执行某脚本，文件权限显示 <code>-rw-r--r--</code>，如何解决？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>脚本缺少执行权限；</li>
<li>使用 <code>chmod +x script.sh</code> 添加执行权限；</li>
<li>若需要指定特定用户或组执行，可使用 SUID&#x2F;SGID 或修改所有者。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> SUID、SGID 和 sticky bit 的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>SUID：执行文件时以文件所有者权限运行；</li>
<li>SGID：新建文件继承目录组或执行文件以文件组权限运行；</li>
<li>Sticky bit：目录下文件只能被所有者或 root 删除。</li>
</ul>
<hr>
<h3 id="进程管理（kill、jobs、fg、bg、nohup、tmux）"><a href="#进程管理（kill、jobs、fg、bg、nohup、tmux）" class="headerlink" title="进程管理（kill、jobs、fg、bg、nohup、tmux）"></a>进程管理（kill、jobs、fg、bg、nohup、tmux）</h3><p><strong>题目 1（基础）</strong>：<br> Linux 中如何查看所有进程？</p>
<p><strong>答案</strong>：</p>
<ul>
<li><code>ps aux</code> 显示所有进程；</li>
<li><code>top</code> 实时监控；</li>
<li><code>htop</code> 图形化显示（如安装）。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 后台运行的任务被意外终止，如何保证任务继续执行？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用 <code>nohup command &amp;</code> 或 <code>disown</code>；</li>
<li>使用 <code>tmux</code> 或 <code>screen</code> 启动会话保持任务；</li>
<li>可通过 <code>jobs</code>、<code>fg</code>、<code>bg</code> 管理作业。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> kill 命令中不同信号作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li><code>kill -9</code>：强制终止（不可捕获）；</li>
<li><code>kill -15</code>：正常终止，可捕获处理；</li>
<li><code>kill -HUP</code>：重新加载配置。</li>
</ul>
<hr>
<h3 id="文件系统（ext4、inode、硬-软链接、挂载）"><a href="#文件系统（ext4、inode、硬-软链接、挂载）" class="headerlink" title="文件系统（ext4、inode、硬&#x2F;软链接、挂载）"></a>文件系统（ext4、inode、硬&#x2F;软链接、挂载）</h3><p><strong>题目 1（基础）</strong>：<br> inode 在文件系统中的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>保存文件元数据（权限、所有者、时间戳、数据块地址）；</li>
<li>文件名存储在目录结构中与 inode 对应；</li>
<li>修改文件名不影响 inode。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 硬链接和软链接有什么区别？</p>
<p><strong>答案</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>硬链接</th>
<th>软链接</th>
</tr>
</thead>
<tbody><tr>
<td>指向对象</td>
<td>inode</td>
<td>文件路径</td>
</tr>
<tr>
<td>可跨文件系统</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>删除原文件</td>
<td>链接仍可访问数据</td>
<td>链接失效</td>
</tr>
</tbody></table>
<p><strong>题目 3（考点延伸）</strong>：<br> 如何挂载新磁盘并永久生效？</p>
<p><strong>答案</strong>：</p>
<ol>
<li>分区：<code>fdisk</code> 或 <code>parted</code>；</li>
<li>格式化：<code>mkfs.ext4 /dev/sdx1</code>；</li>
<li>临时挂载：<code>mount /dev/sdx1 /mnt</code>；</li>
<li>永久挂载：编辑 <code>/etc/fstab</code> 添加挂载信息。</li>
</ol>
<hr>
<h3 id="IO-模型（阻塞、非阻塞、I-O-多路复用）"><a href="#IO-模型（阻塞、非阻塞、I-O-多路复用）" class="headerlink" title="IO 模型（阻塞、非阻塞、I&#x2F;O 多路复用）"></a>IO 模型（阻塞、非阻塞、I&#x2F;O 多路复用）</h3><p><strong>题目 1（基础）</strong>：<br> Linux 中常见 IO 模型有哪些？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>阻塞 IO：调用阻塞，等待完成；</li>
<li>非阻塞 IO：立即返回，需轮询；</li>
<li>I&#x2F;O 多路复用：<code>select</code>、<code>poll</code>、<code>epoll</code>；</li>
<li>信号驱动 IO、异步 IO（AIO）。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 高并发服务器使用阻塞 IO，会遇到什么问题？如何优化？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>问题：线程&#x2F;进程数受限，CPU 利用率低，阻塞等待影响性能；</li>
<li>优化：使用 epoll 或异步 IO，实现单线程处理大量连接。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> epoll 相比 select 有哪些优势？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>支持大量 fd（文件描述符）；</li>
<li>O(1) 查询事件；</li>
<li>支持水平触发（LT）和边缘触发（ET）；</li>
<li>减少内核&#x2F;用户空间复制开销。</li>
</ul>
<hr>
<h3 id="网络排查（ping、tcpdump、iftop）"><a href="#网络排查（ping、tcpdump、iftop）" class="headerlink" title="网络排查（ping、tcpdump、iftop）"></a>网络排查（ping、tcpdump、iftop）</h3><p><strong>题目 1（基础）</strong>：<br> ping 命令用于什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>检测网络连通性；</li>
<li>测量延迟（RTT）；</li>
<li>使用 ICMP 回显请求。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 网络访问慢，如何用 iftop 和 tcpdump 排查？</p>
<p><strong>答案</strong>：</p>
<ul>
<li><code>iftop</code>：实时显示带宽使用情况，找出流量大 IP；</li>
<li><code>tcpdump</code>：抓取异常流量或丢包数据包；</li>
<li>分析网络瓶颈或异常连接。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> ss 和 netstat 的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>查看 TCP&#x2F;UDP 连接、监听端口；</li>
<li>查看套接字状态和对应进程 PID；</li>
<li>ss 更快，可替代 netstat。</li>
</ul>
<hr>
<h3 id="性能调优（ulimit、sysctl、内存管理、I-O-调度）"><a href="#性能调优（ulimit、sysctl、内存管理、I-O-调度）" class="headerlink" title="性能调优（ulimit、sysctl、内存管理、I&#x2F;O 调度）"></a>性能调优（ulimit、sysctl、内存管理、I&#x2F;O 调度）</h3><p><strong>题目 1（基础）</strong>：<br> <code>ulimit</code> 的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>限制用户进程资源：最大打开文件数、最大内存、最大进程数等；</li>
<li>可防止单用户消耗过多系统资源。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 高并发应用报 “Too many open files”，如何解决？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>增加用户文件描述符限制：<code>ulimit -n 65535</code>；</li>
<li>修改 <code>/etc/security/limits.conf</code> 永久生效；</li>
<li>检查应用是否正确关闭文件。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> Linux I&#x2F;O 调度器有哪些？如何选择？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>cfq：适合桌面系统；</li>
<li>deadline：实时&#x2F;数据库系统；</li>
<li>noop： SSD 设备，最少调度；</li>
<li>可通过 <code>cat /sys/block/sda/queue/scheduler</code> 查看并切换。</li>
</ul>
<hr>
<h3 id="systemd（systemctl、服务管理）"><a href="#systemd（systemctl、服务管理）" class="headerlink" title="systemd（systemctl、服务管理）"></a>systemd（systemctl、服务管理）</h3><p><strong>题目 1（基础）</strong>：<br> <code>systemctl</code> 用于什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>管理 systemd 服务：启动、停止、重启、状态查询；</li>
<li>管理开机启动项。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 某服务无法启动，日志提示依赖未满足，如何排查？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>查看服务状态：<code>systemctl status service</code>；</li>
<li>查看依赖关系：<code>systemctl list-dependencies service</code>；</li>
<li>查看 journal 日志：<code>journalctl -u service</code>；</li>
<li>修复依赖或配置后重新启动。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> systemd 启动流程简述。</p>
<p><strong>答案</strong>：</p>
<ul>
<li>PID 1 启动 systemd；</li>
<li>读取 <code>/etc/systemd/system</code> 配置；</li>
<li>启动 target（类似 runlevel）；</li>
<li>按依赖顺序启动服务单元。</li>
</ul>
<hr>
<h3 id="安全（SELinux、AppArmor）"><a href="#安全（SELinux、AppArmor）" class="headerlink" title="安全（SELinux、AppArmor）"></a>安全（SELinux、AppArmor）</h3><p><strong>题目 1（基础）</strong>：<br> SELinux 的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>提供强制访问控制（MAC），限制进程对资源访问；</li>
<li>安全策略：enforcing、permissive、disabled。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 应用访问文件被拒绝，但权限正常，如何排查？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>检查 SELinux 状态：<code>getenforce</code>；</li>
<li>查看审计日志 <code>/var/log/audit/audit.log</code>；</li>
<li>临时切换 permissive 或调整策略解决。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> AppArmor 与 SELinux 区别是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>SELinux：基于标签的强制访问控制，粒度更细；</li>
<li>AppArmor：基于路径控制，策略易于配置，但粒度相对粗；</li>
<li>SELinux 更复杂、AppArmor 更易上手。</li>
</ul>
<hr>
<p>好的，我们继续生成 <strong>模块 3：MySQL</strong> 的完整面试题库，每个小要点至少三题（基础题、场景题、考点延伸题），并给出详细解答。</p>
<hr>
<h2 id="模块-3：MySQL"><a href="#模块-3：MySQL" class="headerlink" title="模块 3：MySQL"></a>模块 3：MySQL</h2><h3 id="慢查询优化（slow-query-log、EXPLAIN、performance-schema）"><a href="#慢查询优化（slow-query-log、EXPLAIN、performance-schema）" class="headerlink" title="慢查询优化（slow_query_log、EXPLAIN、performance_schema）"></a>慢查询优化（slow_query_log、EXPLAIN、performance_schema）</h3><p><strong>题目 1（基础）</strong>：<br> 如何开启 MySQL 慢查询日志？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>配置 <code>my.cnf</code>：</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/log/mysql/slow.log</span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">log_queries_not_using_indexes</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动后，记录执行时间超过 <code>long_query_time</code> 的 SQL；</li>
<li>可通过 <code>mysqldumpslow</code> 分析日志。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 查询执行很慢，如何定位瓶颈？</p>
<p><strong>答案</strong>：</p>
<ol>
<li>查看慢查询日志，找出耗时 SQL；</li>
<li>使用 <code>EXPLAIN SELECT ...</code> 查看执行计划（全表扫描、索引使用情况）；</li>
<li>使用 <code>performance_schema</code> 监控查询、锁、IO、等待事件；</li>
<li>针对慢查询优化：添加索引、改写 SQL、分表分库。</li>
</ol>
<p><strong>题目 3（考点延伸）</strong>：<br> <code>EXPLAIN</code> 输出中 key、type、rows 字段分别代表什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>key：使用的索引；</li>
<li>type：访问类型（ALL、index、range、ref、eq_ref、const）；</li>
<li>rows：估计扫描行数；</li>
<li>通过这些信息判断是否全表扫描或索引失效。</li>
</ul>
<hr>
<h3 id="索引（B-树结构、聚簇索引-vs-非聚簇索引）"><a href="#索引（B-树结构、聚簇索引-vs-非聚簇索引）" class="headerlink" title="索引（B+ 树结构、聚簇索引 vs 非聚簇索引）"></a>索引（B+ 树结构、聚簇索引 vs 非聚簇索引）</h3><p><strong>题目 1（基础）</strong>：<br> InnoDB 默认索引结构是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>B+ 树；</li>
<li>主键索引为聚簇索引，数据和索引在一起存储；</li>
<li>辅助索引为非聚簇索引，叶子节点存主键。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 查询使用了索引但速度仍慢，可能原因是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>索引失效：函数操作、隐式类型转换、<code>like %xxx</code>；</li>
<li>数据分布不均衡导致索引选择不理想；</li>
<li>覆盖索引未命中，需要回表。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 聚簇索引和非聚簇索引的区别？</p>
<p><strong>答案</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>聚簇索引</th>
<th>非聚簇索引</th>
</tr>
</thead>
<tbody><tr>
<td>数据存储</td>
<td>叶子节点存数据</td>
<td>叶子节点存主键</td>
</tr>
<tr>
<td>查询效率</td>
<td>范围查询快</td>
<td>单值查询快</td>
</tr>
<tr>
<td>占用空间</td>
<td>较大</td>
<td>较小</td>
</tr>
</tbody></table>
<hr>
<h3 id="事务（ACID、隔离级别、并发问题、MVCC）"><a href="#事务（ACID、隔离级别、并发问题、MVCC）" class="headerlink" title="事务（ACID、隔离级别、并发问题、MVCC）"></a>事务（ACID、隔离级别、并发问题、MVCC）</h3><p><strong>题目 1（基础）</strong>：<br> MySQL 支持哪些事务隔离级别？</p>
<p><strong>答案</strong>：</p>
<ol>
<li>读未提交（Read Uncommitted）：可能脏读；</li>
<li>读已提交（Read Committed）：避免脏读，但可能不可重复读；</li>
<li>可重复读（Repeatable Read，默认）：避免脏读和不可重复读，但可能幻读；</li>
<li>串行化（Serializable）：完全避免并发问题，但性能最低。</li>
</ol>
<p><strong>题目 2（场景题）</strong>：<br> 两条并发事务读写同一行数据，出现不可重复读，如何解决？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>设置事务隔离级别为可重复读或串行化；</li>
<li>使用锁（行锁）保证一致性；</li>
<li>使用 MVCC（InnoDB 默认）避免读阻塞。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> MVCC 的实现原理是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>利用 <strong>undo log</strong> 保存数据旧版本；</li>
<li><strong>read view</strong> 决定事务可见数据版本；</li>
<li>隐藏列存储事务 ID，保证快照读；</li>
<li>保证读写不阻塞，提高并发。</li>
</ul>
<hr>
<h3 id="锁（表锁、行锁、共享锁、排他锁、间隙锁、Next-Key-锁、乐观锁、悲观锁）"><a href="#锁（表锁、行锁、共享锁、排他锁、间隙锁、Next-Key-锁、乐观锁、悲观锁）" class="headerlink" title="锁（表锁、行锁、共享锁、排他锁、间隙锁、Next-Key 锁、乐观锁、悲观锁）"></a>锁（表锁、行锁、共享锁、排他锁、间隙锁、Next-Key 锁、乐观锁、悲观锁）</h3><p><strong>题目 1（基础）</strong>：<br> InnoDB 支持哪些锁类型？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>行锁（Record Lock）、表锁；</li>
<li>共享锁（S）：可读但不可写；</li>
<li>排他锁（X）：读写都阻塞；</li>
<li>Next-Key 锁 &#x3D; 行锁 + 间隙锁（防止幻读）。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 大量更新出现死锁，如何排查并解决？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用 <code>SHOW ENGINE INNODB STATUS\G</code> 查看死锁信息；</li>
<li>确认事务操作顺序一致，避免交叉锁；</li>
<li>对热点数据加索引，减少锁粒度；</li>
<li>考虑乐观锁（版本号）替代悲观锁。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 乐观锁与悲观锁的区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>乐观锁：假设无冲突，通过版本号&#x2F;时间戳检查冲突，适合读多写少；</li>
<li>悲观锁：假设会冲突，先加锁，适合写多场景。</li>
</ul>
<hr>
<h3 id="存储引擎（InnoDB、MyISAM）"><a href="#存储引擎（InnoDB、MyISAM）" class="headerlink" title="存储引擎（InnoDB、MyISAM）"></a>存储引擎（InnoDB、MyISAM）</h3><p><strong>题目 1（基础）</strong>：<br> InnoDB 与 MyISAM 区别？</p>
<p><strong>答案</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
</tr>
<tr>
<td>MVCC</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p><strong>题目 2（场景题）</strong>：<br> MyISAM 表频繁更新大表导致锁争用，如何优化？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>改用 InnoDB 支持行锁；</li>
<li>分表分库降低单表压力；</li>
<li>优化索引减少全表扫描。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> InnoDB 事务日志有哪些？作用？</p>
<p><strong>答案</strong>：</p>
<ul>
<li><strong>redo log</strong>：保证持久性（Crash 恢复）；</li>
<li><strong>undo log</strong>：回滚事务，实现 MVCC；</li>
<li><strong>binlog</strong>：主从复制和数据恢复。</li>
</ul>
<hr>
<h3 id="日志（redo-log、undo-log、binlog）"><a href="#日志（redo-log、undo-log、binlog）" class="headerlink" title="日志（redo log、undo log、binlog）"></a>日志（redo log、undo log、binlog）</h3><p><strong>题目 1（基础）</strong>：<br> redo log 的作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>保证事务提交的持久性；</li>
<li>写入磁盘前采用预写日志（WAL），事务提交后再刷新数据页。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 数据库突然宕机，如何利用日志恢复？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>利用 redo log 恢复已提交事务；</li>
<li>利用 undo log 回滚未提交事务；</li>
<li>binlog 可用于主从同步或点时间恢复。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> binlog 有哪些格式？</p>
<p><strong>答案</strong>：</p>
<ul>
<li><strong>STATEMENT</strong>：记录 SQL 语句，体积小，但可能出现不可重复执行问题；</li>
<li><strong>ROW</strong>：记录每行数据变化，精确但体积大；</li>
<li><strong>MIXED</strong>：混合模式，根据情况选择。</li>
</ul>
<hr>
<h2 id="模块-4：Java"><a href="#模块-4：Java" class="headerlink" title="模块 4：Java"></a>模块 4：Java</h2><h3 id="基本类型与包装类"><a href="#基本类型与包装类" class="headerlink" title="基本类型与包装类"></a>基本类型与包装类</h3><p><strong>题目 1（基础）</strong>：<br> Java 有哪八种基本数据类型及其包装类？</p>
<p><strong>答案</strong>：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p><strong>题目 2（场景题）</strong>：<br> <code>Integer a = 100; Integer b = 100;</code> <code>a == b</code> 是 true 还是 false？为什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>true；</li>
<li>因为 JVM 缓存了 -128~127 的 Integer 对象；</li>
<li>超出范围则 <code>==</code> 比较不同对象引用返回 false。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 自动装箱&#x2F;拆箱可能带来哪些性能或空指针风险？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>装箱：基本类型 → 包装类对象，增加对象创建开销；</li>
<li>拆箱：包装类 → 基本类型；</li>
<li>null 拆箱会抛出 NullPointerException。</li>
</ul>
<hr>
<h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><p><strong>题目 1（基础）</strong>：<br> Object 类常用方法有哪些？</p>
<p><strong>答案</strong>：</p>
<ul>
<li><code>equals()</code>：比较对象内容；</li>
<li><code>hashCode()</code>：返回对象哈希值；</li>
<li><code>toString()</code>：对象字符串表示；</li>
<li><code>clone()</code>：浅拷贝对象；</li>
<li><code>wait()</code>&#x2F;<code>notify()</code>&#x2F;<code>notifyAll()</code>：线程通信。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 两个对象 <code>a</code> 和 <code>b</code> 内容相同但 <code>a == b</code> 返回 false，如何让 <code>a.equals(b)</code> 返回 true？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>重写 <code>equals()</code> 方法，按属性判断对象内容是否相等；</li>
<li>通常同时重写 <code>hashCode()</code> 保证哈希一致性。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> clone() 和深拷贝、浅拷贝区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>浅拷贝：对象属性引用仍指向原对象；</li>
<li>深拷贝：对象属性也复制新对象；</li>
<li><code>clone()</code> 默认浅拷贝，需手动实现深拷贝。</li>
</ul>
<hr>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><strong>题目 1（基础）</strong>：<br> 为什么 String 是不可变对象？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>String 存储在字符串常量池中；</li>
<li>通过不可变性保证线程安全；</li>
<li>修改操作会生成新对象，原对象不变。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 大量字符串拼接性能低，如何优化？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用 <code>StringBuilder</code>（非线程安全，效率高）或 <code>StringBuffer</code>（线程安全，略慢）；</li>
<li>避免频繁生成临时 String 对象。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> StringPool 是如何工作的？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>字符串常量池保存编译期确定的字符串；</li>
<li>相同字面量只存一份，节省内存；</li>
<li><code>new String(&quot;abc&quot;)</code> 会生成新对象，不在池中。</li>
</ul>
<hr>
<h3 id="异常（Checked-vs-Unchecked、try-with-resources）"><a href="#异常（Checked-vs-Unchecked、try-with-resources）" class="headerlink" title="异常（Checked vs Unchecked、try-with-resources）"></a>异常（Checked vs Unchecked、try-with-resources）</h3><p><strong>题目 1（基础）</strong>：<br> Checked 与 Unchecked 异常区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Checked：编译器检查，必须处理或抛出（如 IOException）；</li>
<li>Unchecked：运行时异常，不强制捕获（如 NullPointerException、ArrayIndexOutOfBoundsException）。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 如何保证文件操作后资源被正确关闭？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用 <code>try-with-resources</code> 自动关闭实现 <code>AutoCloseable</code> 接口的资源；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 读文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目 3（考点延伸）</strong>：<br> 异常的传播机制是怎样的？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>异常沿调用栈向上抛出；</li>
<li>捕获最接近的匹配 <code>catch</code> 块；</li>
<li>finally 块保证无论是否抛异常都执行资源释放。</li>
</ul>
<hr>
<h3 id="并发（synchronized、ReentrantLock、CAS、原子类、ThreadLocal、Thread、Runnable、Callable、线程池）"><a href="#并发（synchronized、ReentrantLock、CAS、原子类、ThreadLocal、Thread、Runnable、Callable、线程池）" class="headerlink" title="并发（synchronized、ReentrantLock、CAS、原子类、ThreadLocal、Thread、Runnable、Callable、线程池）"></a>并发（synchronized、ReentrantLock、CAS、原子类、ThreadLocal、Thread、Runnable、Callable、线程池）</h3><p><strong>题目 1（基础）</strong>：<br> synchronized 与 ReentrantLock 区别？</p>
<p><strong>答案</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td>是否可重入</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>公平锁</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>手动释放锁</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>支持条件变量</td>
<td>否</td>
<td>是（Condition）</td>
</tr>
</tbody></table>
<p><strong>题目 2（场景题）</strong>：<br> 多线程累加共享变量出现错误，如何解决？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用 <code>synchronized</code> 或 <code>ReentrantLock</code> 保护共享变量；</li>
<li>使用 <code>AtomicInteger</code> 等原子类；</li>
<li>避免同时修改非线程安全对象。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> Thread、Runnable、Callable 的区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Thread：继承 Thread 类实现线程；</li>
<li>Runnable：实现接口，适合资源共享，不能返回值；</li>
<li>Callable：实现接口，可返回值并抛异常；</li>
<li>Runnable 可通过 <code>FutureTask</code> 转 Callable 使用。</li>
</ul>
<p><strong>题目 4（线程池）</strong>：<br> ThreadPoolExecutor 核心参数及作用？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>corePoolSize：核心线程数；</li>
<li>maximumPoolSize：最大线程数；</li>
<li>keepAliveTime：空闲线程存活时间；</li>
<li>workQueue：任务队列；</li>
<li>RejectionPolicy：拒绝策略（Abort、CallerRuns、Discard、DiscardOldest）。</li>
</ul>
<hr>
<h3 id="集合（List、Set、Map、并发集合）"><a href="#集合（List、Set、Map、并发集合）" class="headerlink" title="集合（List、Set、Map、并发集合）"></a>集合（List、Set、Map、并发集合）</h3><p><strong>题目 1（基础）</strong>：<br> ArrayList 与 LinkedList 区别？</p>
<p><strong>答案</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>底层结构</td>
<td>动态数组</td>
<td>双向链表</td>
</tr>
<tr>
<td>随机访问</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>插入删除</td>
<td>慢（数组搬移）</td>
<td>快（链表操作）</td>
</tr>
</tbody></table>
<p><strong>题目 2（场景题）</strong>：<br> HashMap 的 get() 方法能否判断 key 是否存在？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>不能；因为 value 可能为 null；</li>
<li>使用 <code>containsKey()</code> 判断 key 是否存在。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> ConcurrentHashMap 如何保证线程安全？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Java 8 采用 <strong>CAS + 链表&#x2F;红黑树 + 分段锁</strong> 机制；</li>
<li>读操作无锁，写操作仅锁局部桶，提高并发性能；</li>
<li>避免全局锁。</li>
</ul>
<hr>
<h3 id="JVM-内部结构（运行时内存区域、类加载、双亲委派、OOM）"><a href="#JVM-内部结构（运行时内存区域、类加载、双亲委派、OOM）" class="headerlink" title="JVM 内部结构（运行时内存区域、类加载、双亲委派、OOM）"></a>JVM 内部结构（运行时内存区域、类加载、双亲委派、OOM）</h3><p><strong>题目 1（基础）</strong>：<br> JVM 堆和方法区区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>堆：存对象实例，垃圾回收主要区域；</li>
<li>方法区（元空间）：存类元信息、静态变量、常量；</li>
<li>堆可调节大小，方法区可使用 Metaspace。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 出现 <code>java.lang.OutOfMemoryError: Metaspace</code>，可能原因及解决？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>原因：类加载过多、内存泄漏（动态生成类未卸载）；</li>
<li>解决：增加 Metaspace 大小，检查类加载逻辑，避免动态类泄漏。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 双亲委派机制为什么重要？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>保证核心类优先由父类加载器加载，避免类冲突；</li>
<li>防止加载不安全的自定义类覆盖核心类；</li>
<li>提高类加载安全性和稳定性。</li>
</ul>
<hr>
<h3 id="GC（垃圾回收）"><a href="#GC（垃圾回收）" class="headerlink" title="GC（垃圾回收）"></a>GC（垃圾回收）</h3><p><strong>题目 1（基础）</strong>：<br> 常见垃圾回收算法有哪些？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>引用计数；</li>
<li>标记清除；</li>
<li>标记整理；</li>
<li>复制算法。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 新生代 Minor GC 和老年代 Full GC 的区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Minor GC：回收新生代对象，频繁、快速；</li>
<li>Full GC：回收整个堆（新生代 + 老年代），耗时长；</li>
<li>调优：控制对象存活时间，减少 Full GC。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> G1、CMS、ZGC、Shenandoah 各自特点？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>CMS：并发标记清理，减少停顿；</li>
<li>G1：分代 + 区域化管理，控制停顿时间；</li>
<li>ZGC、Shenandoah：低延迟 GC，适合大内存应用。</li>
</ul>
<hr>
<h2 id="模块-5：Web"><a href="#模块-5：Web" class="headerlink" title="模块 5：Web"></a>模块 5：Web</h2><h3 id="HTTP（请求方法、状态码、Header）"><a href="#HTTP（请求方法、状态码、Header）" class="headerlink" title="HTTP（请求方法、状态码、Header）"></a>HTTP（请求方法、状态码、Header）</h3><p><strong>题目 1（基础）</strong>：<br> 常用 HTTP 请求方法有哪些？分别作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>GET：获取资源，不应有副作用；</li>
<li>POST：提交数据，可能创建或修改资源；</li>
<li>PUT：更新或创建资源；</li>
<li>DELETE：删除资源；</li>
<li>PATCH：部分更新资源；</li>
<li>HEAD：只获取响应头，不返回正文；</li>
<li>OPTIONS：获取支持的方法。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 浏览器请求页面返回 304 状态码，意味着什么？如何处理？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>304 Not Modified：客户端缓存未过期，资源未修改；</li>
<li>浏览器直接使用缓存，减少带宽和加载时间；</li>
<li>通过 ETag 或 Last-Modified 进行缓存验证。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> HTTP 常用 Header 及作用？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>请求头：<code>Content-Type</code>（请求类型）、<code>Authorization</code>（身份验证）、<code>Accept</code>（可接受类型）；</li>
<li>响应头：<code>Content-Type</code>、<code>Cache-Control</code>、<code>Set-Cookie</code>、<code>Location</code>（重定向）；</li>
<li>Header 用于控制缓存、安全、数据格式等。</li>
</ul>
<hr>
<h3 id="HTTPS（TLS-加密）"><a href="#HTTPS（TLS-加密）" class="headerlink" title="HTTPS（TLS 加密）"></a>HTTPS（TLS 加密）</h3><p><strong>题目 1（基础）</strong>：<br> HTTPS 与 HTTP 区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>HTTPS 在 HTTP 基础上使用 TLS&#x2F;SSL 加密；</li>
<li>确保数据传输机密性、完整性、身份认证；</li>
<li>HTTPS 端口默认 443，HTTP 端口 80。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 浏览器访问 HTTPS 页面提示证书错误，可能原因？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>证书过期；</li>
<li>证书不被信任（非 CA 签发）；</li>
<li>域名不匹配；</li>
<li>证书链不完整。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> TLS 握手流程简述。</p>
<p><strong>答案</strong>：</p>
<ol>
<li>客户端发起握手，发送支持的加密套件；</li>
<li>服务端返回证书及选定加密套件；</li>
<li>客户端验证证书，生成对称密钥并加密发送；</li>
<li>服务端解密，握手完成，双方使用对称密钥加密数据。</li>
</ol>
<hr>
<h3 id="Cookie、Session、Token"><a href="#Cookie、Session、Token" class="headerlink" title="Cookie、Session、Token"></a>Cookie、Session、Token</h3><p><strong>题目 1（基础）</strong>：<br> Cookie 与 Session 区别？</p>
<p><strong>答案</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>
<tbody><tr>
<td>存储位置</td>
<td>客户端</td>
<td>服务器</td>
</tr>
<tr>
<td>容量限制</td>
<td>小（4KB）</td>
<td>较大（服务器内存）</td>
</tr>
<tr>
<td>安全性</td>
<td>容易被篡改</td>
<td>相对安全</td>
</tr>
<tr>
<td>生命周期</td>
<td>可设置过期</td>
<td>默认会话结束清除</td>
</tr>
</tbody></table>
<p><strong>题目 2（场景题）</strong>：<br> 实现用户登录状态保持有哪些方式？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Cookie + Session：服务器存储 Session，客户端保存 SessionID；</li>
<li>JWT（Token）：无状态认证，客户端存储 Token，每次请求携带验证；</li>
<li>Redis 保存 Token，提高分布式场景一致性。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> Token 相比 Session 的优势？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>无状态，易扩展分布式系统；</li>
<li>不依赖服务器内存；</li>
<li>支持自包含信息，减少数据库查询。</li>
</ul>
<hr>
<h3 id="RESTful-API-设计"><a href="#RESTful-API-设计" class="headerlink" title="RESTful API 设计"></a>RESTful API 设计</h3><p><strong>题目 1（基础）</strong>：<br> RESTful API 设计原则有哪些？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>资源为中心（URI 表示资源）；</li>
<li>使用 HTTP 方法表示操作（GET、POST、PUT、DELETE）；</li>
<li>无状态请求；</li>
<li>返回合适 HTTP 状态码；</li>
<li>可使用 JSON&#x2F;XML 表示数据。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 设计用户管理接口，哪些 URL 和方法符合 RESTful 规范？</p>
<p><strong>答案</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>URL</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>查询用户</td>
<td>&#x2F;users&#x2F;{id}</td>
<td>GET</td>
</tr>
<tr>
<td>创建用户</td>
<td>&#x2F;users</td>
<td>POST</td>
</tr>
<tr>
<td>更新用户</td>
<td>&#x2F;users&#x2F;{id}</td>
<td>PUT</td>
</tr>
<tr>
<td>删除用户</td>
<td>&#x2F;users&#x2F;{id}</td>
<td>DELETE</td>
</tr>
</tbody></table>
<p><strong>题目 3（考点延伸）</strong>：<br> RESTful 与 RPC 风格 API 区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>RESTful：以资源为中心，使用标准 HTTP 方法；</li>
<li>RPC：以动作或函数为中心，通常 POST 调用；</li>
<li>RESTful 易于缓存、可扩展，符合 Web 标准。</li>
</ul>
<hr>
<h3 id="跨域（CORS、JSONP）"><a href="#跨域（CORS、JSONP）" class="headerlink" title="跨域（CORS、JSONP）"></a>跨域（CORS、JSONP）</h3><p><strong>题目 1（基础）</strong>：<br> 什么是跨域请求？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>浏览器同源策略限制不同域、协议或端口的请求访问资源；</li>
<li>跨域请求需特殊处理。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 前端请求跨域接口报错，如何解决？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>CORS：服务端设置 <code>Access-Control-Allow-Origin</code> 等 Header；</li>
<li>JSONP：通过 <code>&lt;script&gt;</code> 标签请求跨域 GET 接口；</li>
<li>代理转发：前端请求同源接口，由后端转发到目标域。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> CORS 的简单请求与预检请求区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>简单请求：GET&#x2F;POST（Content-Type 为 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain），直接发送；</li>
<li>预检请求：复杂请求（PUT、DELETE 或自定义 Header），浏览器先发 OPTIONS 请求确认。</li>
</ul>
<hr>
<h3 id="缓存（Cache-Control、ETag、Last-Modified）"><a href="#缓存（Cache-Control、ETag、Last-Modified）" class="headerlink" title="缓存（Cache-Control、ETag、Last-Modified）"></a>缓存（Cache-Control、ETag、Last-Modified）</h3><p><strong>题目 1（基础）</strong>：<br> HTTP 缓存机制有哪些？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>强缓存：浏览器直接使用缓存，<code>Cache-Control</code> 或 <code>Expires</code>；</li>
<li>协商缓存：浏览器与服务器确认资源是否更新，<code>ETag</code>、<code>Last-Modified</code>。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 前端请求频繁导致服务器压力大，如何优化？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>设置合理缓存策略，减少重复请求；</li>
<li>使用 ETag 或 Last-Modified 验证资源更新；</li>
<li>对静态资源 CDN 缓存加速。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> Cache-Control 指令常见有哪些？</p>
<p><strong>答案</strong>：</p>
<ul>
<li><code>no-cache</code>：必须向服务器验证；</li>
<li><code>no-store</code>：不缓存；</li>
<li><code>max-age</code>：最大缓存时间；</li>
<li><code>public</code>：可被共享缓存；</li>
<li><code>private</code>：只能被浏览器缓存。</li>
</ul>
<hr>
<h3 id="WebSocket、SSE、长轮询"><a href="#WebSocket、SSE、长轮询" class="headerlink" title="WebSocket、SSE、长轮询"></a>WebSocket、SSE、长轮询</h3><p><strong>题目 1（基础）</strong>：<br> WebSocket 与 HTTP 有何区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>WebSocket：全双工通信，客户端和服务器可主动发送消息；</li>
<li>HTTP：请求-响应模式，客户端发起请求；</li>
<li>WebSocket 建立后可持续连接，减少轮询开销。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 实现实时聊天应用，如何选择通信方式？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>需要高频率双向通信：WebSocket；</li>
<li>只需服务端推送，客户端偶尔获取：SSE；</li>
<li>无 WebSocket 支持，低频通信：长轮询。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 长轮询与 WebSocket 性能差异？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>长轮询：每次请求结束立即重新发送，频繁 HTTP 建立连接，开销大；</li>
<li>WebSocket：一次连接可持续通信，CPU 和网络开销小；</li>
<li>高并发或低延迟场景推荐 WebSocket。</li>
</ul>
<hr>
<h2 id="模块-6：框架"><a href="#模块-6：框架" class="headerlink" title="模块 6：框架"></a>模块 6：框架</h2><h3 id="6-1-Spring（IoC-容器、Bean-生命周期、AOP）"><a href="#6-1-Spring（IoC-容器、Bean-生命周期、AOP）" class="headerlink" title="6.1 Spring（IoC 容器、Bean 生命周期、AOP）"></a>6.1 Spring（IoC 容器、Bean 生命周期、AOP）</h3><p><strong>题目 1（基础）</strong>：<br> Spring 的 IoC 容器是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>IoC（Inversion of Control，控制反转）：对象创建、依赖管理交给容器；</li>
<li>容器管理 Bean 的生命周期和依赖注入；</li>
<li>支持 XML、注解、JavaConfig 等配置方式。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 如何自定义 Bean 初始化和销毁方法？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>方法一：在 <code>@Bean(initMethod=&quot;init&quot;, destroyMethod=&quot;destroy&quot;)</code> 中指定；</li>
<li>方法二：实现 <code>InitializingBean.afterPropertiesSet()</code> 和 <code>DisposableBean.destroy()</code>；</li>
<li>方法三：使用 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> Spring AOP 的实现原理？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>JDK 动态代理：接口代理，生成代理对象实现接口；</li>
<li>CGLIB：继承目标类生成子类代理（非接口类）；</li>
<li>代理对象拦截方法调用，织入切面逻辑（Before、After、Around）。</li>
</ul>
<hr>
<h3 id="6-2-Spring-Boot（自动配置原理、Starter-模块、配置优先级、Actuator）"><a href="#6-2-Spring-Boot（自动配置原理、Starter-模块、配置优先级、Actuator）" class="headerlink" title="6.2 Spring Boot（自动配置原理、Starter 模块、配置优先级、Actuator）"></a>6.2 Spring Boot（自动配置原理、Starter 模块、配置优先级、Actuator）</h3><p><strong>题目 1（基础）</strong>：<br> Spring Boot 自动配置原理是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>通过 <code>@EnableAutoConfiguration</code> 注解触发；</li>
<li>根据类路径存在的依赖、条件注解（<code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>）自动创建 Bean；</li>
<li>避免手动繁琐配置，提高开发效率。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 同一个配置项在多个地方定义，Spring Boot 如何选择？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>优先级：命令行 &gt; <code>application.yml</code>&#x2F;<code>application.properties</code> &gt; 外部配置文件 &gt; <code>@Value</code>&#x2F;<code>@ConfigurationProperties</code> 默认值；</li>
<li>Spring Boot 按顺序覆盖配置，确保灵活性。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> Spring Boot Actuator 能做什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>健康检查 <code>/actuator/health</code>；</li>
<li>监控应用指标 <code>/actuator/metrics</code>；</li>
<li>查看环境变量 <code>/actuator/env</code>；</li>
<li>支持自定义端点，结合 Prometheus&#x2F;Grafana 可观测性。</li>
</ul>
<hr>
<h3 id="6-3-Spring-MVC（DispatcherServlet、拦截器、异常处理）"><a href="#6-3-Spring-MVC（DispatcherServlet、拦截器、异常处理）" class="headerlink" title="6.3 Spring MVC（DispatcherServlet、拦截器、异常处理）"></a>6.3 Spring MVC（DispatcherServlet、拦截器、异常处理）</h3><p><strong>题目 1（基础）</strong>：<br> Spring MVC 的请求处理流程？</p>
<p><strong>答案</strong>：</p>
<ol>
<li>请求到 <code>DispatcherServlet</code>；</li>
<li>根据 <code>HandlerMapping</code> 找到 Controller 方法；</li>
<li><code>HandlerAdapter</code> 执行方法；</li>
<li>返回 <code>ModelAndView</code>；</li>
<li><code>ViewResolver</code> 渲染视图；</li>
<li>返回响应给客户端。</li>
</ol>
<p><strong>题目 2（场景题）</strong>：<br> 需要在 Controller 执行前后做统一处理，比如日志或权限，如何实现？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用 Spring MVC 拦截器 <code>HandlerInterceptor</code>；</li>
<li><code>preHandle</code> 前置处理，<code>postHandle</code> 后置处理，<code>afterCompletion</code> 请求完成处理；</li>
<li>可用于统一日志记录、权限校验、性能监控。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> Spring MVC 如何统一处理异常？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>；</li>
<li>也可继承 <code>ResponseEntityExceptionHandler</code>；</li>
<li>可返回统一错误响应 JSON，方便前端处理。</li>
</ul>
<hr>
<h3 id="6-4-MyBatis（SQL-映射、动态-SQL、缓存、N-1-问题）"><a href="#6-4-MyBatis（SQL-映射、动态-SQL、缓存、N-1-问题）" class="headerlink" title="6.4 MyBatis（SQL 映射、动态 SQL、缓存、N+1 问题）"></a>6.4 MyBatis（SQL 映射、动态 SQL、缓存、N+1 问题）</h3><p><strong>题目 1（基础）</strong>：<br> MyBatis 的核心功能是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>SQL 映射：Java 对象与数据库表对应；</li>
<li>动态 SQL：通过 <code>&lt;if&gt;</code>、<code>&lt;where&gt;</code> 等标签生成 SQL；</li>
<li>支持 XML 和注解方式配置；</li>
<li>支持一级缓存、二级缓存提高性能。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 查询用户及其订单列表出现 N+1 问题，如何优化？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用关联查询（JOIN）减少 SQL 次数；</li>
<li>使用 <code>collection</code> 或 <code>association</code> 在 MyBatis 中一条 SQL 查询完成多表关联；</li>
<li>可通过批量查询再在内存组装数据。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> MyBatis 一级缓存和二级缓存区别？</p>
<p><strong>答案</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>一级缓存</th>
<th>二级缓存</th>
</tr>
</thead>
<tbody><tr>
<td>范围</td>
<td>SqlSession</td>
<td>Mapper&#x2F;namespace</td>
</tr>
<tr>
<td>生命周期</td>
<td>SqlSession 级别</td>
<td>Mapper 级别，可跨 SqlSession</td>
</tr>
<tr>
<td>默认开启</td>
<td>是</td>
<td>需配置 <code>&lt;cache/&gt;</code></td>
</tr>
</tbody></table>
<hr>
<p>好的，我们继续生成 <strong>模块 7：分布式</strong> 的完整面试题库，每个小要点至少三题（基础题、场景题、考点延伸题），并给出详细解答。</p>
<hr>
<h2 id="模块-7：分布式"><a href="#模块-7：分布式" class="headerlink" title="模块 7：分布式"></a>模块 7：分布式</h2><h3 id="7-1-Spring-Cloud（服务注册发现、负载均衡、网关、熔断限流）"><a href="#7-1-Spring-Cloud（服务注册发现、负载均衡、网关、熔断限流）" class="headerlink" title="7.1 Spring Cloud（服务注册发现、负载均衡、网关、熔断限流）"></a>7.1 Spring Cloud（服务注册发现、负载均衡、网关、熔断限流）</h3><p><strong>题目 1（基础）</strong>：<br> Spring Cloud 的服务注册与发现机制是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用 Eureka 或 Nacos 作为注册中心；</li>
<li>服务启动时注册自身信息（IP、端口、元数据）；</li>
<li>客户端通过服务名称查询可用实例，实现服务调用；</li>
<li>支持心跳检测，保证服务可用性。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 微服务调用经常出现实例不可用或延迟，如何优化？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用 Ribbon 或 Feign 实现客户端负载均衡；</li>
<li>引入 Hystrix 或 Sentinel 实现熔断、降级、限流；</li>
<li>结合 Spring Cloud Gateway 做统一路由、限流；</li>
<li>监控服务健康状态，剔除不可用实例。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 负载均衡策略有哪些？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>轮询（Round Robin）；</li>
<li>随机（Random）；</li>
<li>最小并发请求（Least Connections）；</li>
<li>权重轮询（Weighted Round Robin）；</li>
<li>Ribbon 默认支持多种策略，可自定义。</li>
</ul>
<hr>
<h3 id="7-2-分布式核心要点（雪花算法、JWT-OAuth2、Redis、MQ、分布式事务、CAP-BASE、一致性协调、可观测性）"><a href="#7-2-分布式核心要点（雪花算法、JWT-OAuth2、Redis、MQ、分布式事务、CAP-BASE、一致性协调、可观测性）" class="headerlink" title="7.2 分布式核心要点（雪花算法、JWT&#x2F;OAuth2、Redis、MQ、分布式事务、CAP&#x2F;BASE、一致性协调、可观测性）"></a>7.2 分布式核心要点（雪花算法、JWT&#x2F;OAuth2、Redis、MQ、分布式事务、CAP&#x2F;BASE、一致性协调、可观测性）</h3><h4 id="雪花算法（分布式唯一-ID）"><a href="#雪花算法（分布式唯一-ID）" class="headerlink" title="雪花算法（分布式唯一 ID）"></a>雪花算法（分布式唯一 ID）</h4><p><strong>题目 1（基础）</strong>：<br> 雪花算法生成 ID 原理是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>64 位二进制结构：1 位符号 + 41 位时间戳 + 10 位机器 ID + 12 位序列号；</li>
<li>高性能生成唯一、递增 ID，避免数据库瓶颈；</li>
<li>可支持分布式系统多节点生成。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 为什么需要雪花算法而不是自增 ID？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>自增 ID 在多节点下会冲突，需要数据库集中管理；</li>
<li>雪花算法分布式生成，无需依赖中心 DB，性能高；</li>
<li>支持水平扩展。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 雪花算法生成的 ID 可能存在问题吗？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>系统时间回退可能导致重复 ID；</li>
<li>序列号溢出需等待下一毫秒；</li>
<li>需保证机器 ID 唯一，否则可能重复。</li>
</ul>
<hr>
<h4 id="JWT-OAuth2（无状态认证）"><a href="#JWT-OAuth2（无状态认证）" class="headerlink" title="JWT &#x2F; OAuth2（无状态认证）"></a>JWT &#x2F; OAuth2（无状态认证）</h4><p><strong>题目 1（基础）</strong>：<br> JWT 有哪三个部分？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Header：算法类型、Token 类型；</li>
<li>Payload：用户信息、过期时间等；</li>
<li>Signature：签名，保证数据完整性。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 前后端分离项目如何使用 JWT 实现登录？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>登录成功生成 JWT，返回给前端；</li>
<li>前端每次请求携带 Token；</li>
<li>服务端通过验证签名和过期时间确认身份，无需存储会话。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> JWT 的安全问题及解决方法？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>不可存储敏感信息（如密码）；</li>
<li>使用 HTTPS 避免中间人攻击；</li>
<li>过期时间控制 Token 生命周期；</li>
<li>可使用刷新 Token 机制。</li>
</ul>
<hr>
<h4 id="Redis（数据结构、持久化、集群、分布式锁、缓存问题）"><a href="#Redis（数据结构、持久化、集群、分布式锁、缓存问题）" class="headerlink" title="Redis（数据结构、持久化、集群、分布式锁、缓存问题）"></a>Redis（数据结构、持久化、集群、分布式锁、缓存问题）</h4><p><strong>题目 1（基础）</strong>：<br> Redis 常用数据结构有哪些？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>String、Hash、List、Set、ZSet（有序集合）；</li>
<li>支持快速读写、计数、排行榜、缓存。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 高并发下如何实现 Redis 分布式锁？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用 <code>SETNX key value NX PX 10000</code> 原子操作；</li>
<li>使用 Redisson 客户端封装安全的分布式锁；</li>
<li>确保过期时间防止死锁。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 缓存问题（穿透、击穿、雪崩）如何解决？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>穿透：请求不存在数据，可缓存空对象；</li>
<li>击穿：热点 key 过期并发请求，可加互斥锁；</li>
<li>雪崩：大量 key 同时过期，分散过期时间或使用随机过期；</li>
<li>使用合理 TTL、双级缓存策略。</li>
</ul>
<hr>
<h4 id="MQ（削峰填谷、解耦、异步、消费语义）"><a href="#MQ（削峰填谷、解耦、异步、消费语义）" class="headerlink" title="MQ（削峰填谷、解耦、异步、消费语义）"></a>MQ（削峰填谷、解耦、异步、消费语义）</h4><p><strong>题目 1（基础）</strong>：<br> 消息队列常用场景？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>流量削峰填谷；</li>
<li>系统解耦；</li>
<li>异步处理；</li>
<li>异步通知、日志处理、订单系统等。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> Kafka、RocketMQ、RabbitMQ 消费语义有何区别？</p>
<p><strong>答案</strong>：</p>
<table>
<thead>
<tr>
<th>消费语义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>at-most-once</td>
<td>消息可能丢失，但不会重复</td>
</tr>
<tr>
<td>at-least-once</td>
<td>消息可能重复，但不丢失</td>
</tr>
<tr>
<td>exactly-once</td>
<td>消息不丢失也不重复（事务或幂等性实现）</td>
</tr>
</tbody></table>
<p><strong>题目 3（考点延伸）</strong>：<br> 如何保证 MQ 消息顺序消费？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Kafka 分区顺序消费，保证同一分区内顺序；</li>
<li>RabbitMQ 使用单队列 + 单消费者；</li>
<li>避免多线程并行消费同一顺序队列。</li>
</ul>
<hr>
<h4 id="分布式事务（2PC、XA、Saga、补偿、Seata）"><a href="#分布式事务（2PC、XA、Saga、补偿、Seata）" class="headerlink" title="分布式事务（2PC、XA、Saga、补偿、Seata）"></a>分布式事务（2PC、XA、Saga、补偿、Seata）</h4><p><strong>题目 1（基础）</strong>：<br> 2PC（两阶段提交）流程？</p>
<p><strong>答案</strong>：</p>
<ol>
<li>准备阶段：协调者询问各参与者能否提交；</li>
<li>提交阶段：所有参与者同意提交则正式提交，否则回滚；</li>
</ol>
<ul>
<li>保证原子性，但性能低，阻塞资源。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 电商系统跨服务扣库存和创建订单，如何保证分布式事务？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>方案 1：2PC&#x2F;XA，保证强一致性；</li>
<li>方案 2：Saga 事务 + 补偿事务，保证最终一致性；</li>
<li>方案 3：使用 Seata 框架管理分布式事务，简化开发。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 分布式事务与本地事务区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>本地事务：单数据库，ACID 保证强一致性；</li>
<li>分布式事务：跨服务或数据库，需要协调机制，通常追求最终一致性，性能开销大。</li>
</ul>
<hr>
<h4 id="CAP-BASE-理论"><a href="#CAP-BASE-理论" class="headerlink" title="CAP &#x2F; BASE 理论"></a>CAP &#x2F; BASE 理论</h4><p><strong>题目 1（基础）</strong>：<br> CAP 理论是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Consistency（强一致性）、Availability（可用性）、Partition tolerance（分区容错）；</li>
<li>分布式系统最多同时保证两项。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 电商秒杀系统为什么选择 AP 系统而非 CP 系统？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>秒杀系统追求高可用和快速响应；</li>
<li>可接受最终一致性；</li>
<li>AP 系统保证可用性和分区容错，牺牲短时间一致性。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> BASE 理论如何理解？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Basically Available（基本可用）、Soft state（软状态）、Eventually consistent（最终一致性）；</li>
<li>弥补 CAP 理论的实际应用场景，实现高可用分布式系统。</li>
</ul>
<hr>
<h4 id="一致性协调（Zookeeper、etcd）"><a href="#一致性协调（Zookeeper、etcd）" class="headerlink" title="一致性协调（Zookeeper、etcd）"></a>一致性协调（Zookeeper、etcd）</h4><p><strong>题目 1（基础）</strong>：<br> Zookeeper 的主要功能？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>分布式协调服务；</li>
<li>提供选举、配置管理、命名服务、分布式锁等；</li>
<li>使用 ZAB 协议保证顺序一致性。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 多个微服务如何利用 Zookeeper 实现分布式锁？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用临时顺序节点；</li>
<li>获取最小序号节点的客户端获得锁；</li>
<li>锁释放后通知下一个等待客户端。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> etcd 与 Zookeeper 有何区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>etcd：使用 Raft 协议，API 简洁，HTTP&#x2F;JSON 接口；</li>
<li>Zookeeper：ZAB 协议，Java 原生客户端，功能丰富；</li>
<li>都可实现配置管理、分布式锁、服务注册。</li>
</ul>
<hr>
<h4 id="可观测性（ELK、Prometheus、Grafana、Jaeger）"><a href="#可观测性（ELK、Prometheus、Grafana、Jaeger）" class="headerlink" title="可观测性（ELK、Prometheus、Grafana、Jaeger）"></a>可观测性（ELK、Prometheus、Grafana、Jaeger）</h4><p><strong>题目 1（基础）</strong>：<br> 可观测性三要素？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Metrics（指标）；</li>
<li>Logs（日志）；</li>
<li>Tracing（分布式调用链）。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 服务出现性能瓶颈，如何定位？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用 Prometheus 收集指标（CPU、内存、请求延迟）；</li>
<li>Grafana 可视化监控；</li>
<li>ELK 分析日志，定位错误或异常；</li>
<li>Jaeger 查看分布式调用链，找出慢链路。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 为什么微服务系统需要可观测性？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>系统复杂，单点问题难定位；</li>
<li>提前发现异常，提高可靠性；</li>
<li>支持容量规划和优化决策。</li>
</ul>
<hr>
<p>好的，我们继续生成 <strong>模块 8：运维&#x2F;容器化</strong> 的完整面试题库，每个小要点至少三题（基础题、场景题、考点延伸题），并附详细解答。</p>
<hr>
<h2 id="模块-8：运维-容器化"><a href="#模块-8：运维-容器化" class="headerlink" title="模块 8：运维&#x2F;容器化"></a>模块 8：运维&#x2F;容器化</h2><h3 id="Docker（镜像、容器、Dockerfile）"><a href="#Docker（镜像、容器、Dockerfile）" class="headerlink" title="Docker（镜像、容器、Dockerfile）"></a>Docker（镜像、容器、Dockerfile）</h3><p><strong>题目 1（基础）</strong>：<br> Docker 镜像和容器有什么区别？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>镜像：静态文件，包含应用及运行环境；</li>
<li>容器：镜像运行后的实例，独立进程环境，可读写文件系统；</li>
<li>镜像不可修改，容器可写。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 如何构建一个轻量化的 Docker 镜像？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用官方基础镜像（Alpine、Debian Slim）；</li>
<li>多阶段构建减少临时文件；</li>
<li>清理缓存和不必要文件；</li>
<li>合理拆分层，减少镜像体积。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> Dockerfile 常用指令有哪些？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>FROM：基础镜像；</li>
<li>COPY&#x2F;ADD：复制文件到镜像；</li>
<li>RUN：构建期间执行命令；</li>
<li>CMD&#x2F;ENTRYPOINT：容器启动命令；</li>
<li>EXPOSE：暴露端口；</li>
<li>ENV：设置环境变量；</li>
<li>WORKDIR：工作目录。</li>
</ul>
<hr>
<h3 id="Kubernetes（Pod、Deployment、Service、Ingress、ConfigMap、Secret、StatefulSet）"><a href="#Kubernetes（Pod、Deployment、Service、Ingress、ConfigMap、Secret、StatefulSet）" class="headerlink" title="Kubernetes（Pod、Deployment、Service、Ingress、ConfigMap、Secret、StatefulSet）"></a>Kubernetes（Pod、Deployment、Service、Ingress、ConfigMap、Secret、StatefulSet）</h3><p><strong>题目 1（基础）</strong>：<br> Kubernetes 中 Pod、Deployment、Service 有何作用？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Pod：最小调度单元，封装容器及资源；</li>
<li>Deployment：管理 Pod 副本，保证期望状态；</li>
<li>Service：提供访问入口，实现负载均衡，暴露 Pod。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 如何在 Kubernetes 中配置应用数据库连接信息？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>ConfigMap：存储非敏感配置；</li>
<li>Secret：存储敏感信息（密码、Token），支持加密；</li>
<li>Pod 通过环境变量或挂载卷读取配置。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> StatefulSet 与 Deployment 有何区别？</p>
<p><strong>答案</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Deployment</th>
<th>StatefulSet</th>
</tr>
</thead>
<tbody><tr>
<td>Pod 名称</td>
<td>随机</td>
<td>稳定，序号递增</td>
</tr>
<tr>
<td>数据持久化</td>
<td>不保证</td>
<td>与 Pod 一一对应的持久卷</td>
</tr>
<tr>
<td>场景</td>
<td>无状态应用</td>
<td>有状态应用（数据库、缓存）</td>
</tr>
</tbody></table>
<hr>
<h3 id="部署策略（滚动更新、蓝绿、金丝雀）"><a href="#部署策略（滚动更新、蓝绿、金丝雀）" class="headerlink" title="部署策略（滚动更新、蓝绿、金丝雀）"></a>部署策略（滚动更新、蓝绿、金丝雀）</h3><p><strong>题目 1（基础）</strong>：<br> Kubernetes 中滚动更新是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Deployment 默认策略；</li>
<li>逐步替换旧 Pod，保证服务不中断；</li>
<li>可配置最大不可用和最大超额副本数。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 如何在生产环境中安全发布新版本？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>蓝绿部署：同时保留旧版本和新版本，流量切换后回退简单；</li>
<li>金丝雀发布：先小部分用户访问新版本，验证稳定后全量切换；</li>
<li>滚动更新：逐步替换 Pod，减少宕机。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 滚动更新与蓝绿部署优缺点？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>滚动更新：平滑升级，不占用额外资源，但回退复杂；</li>
<li>蓝绿部署：快速回退，但需要双份资源，成本高。</li>
</ul>
<hr>
<h3 id="CI-CD（Jenkins、GitLab-CI、ArgoCD）"><a href="#CI-CD（Jenkins、GitLab-CI、ArgoCD）" class="headerlink" title="CI&#x2F;CD（Jenkins、GitLab CI、ArgoCD）"></a>CI&#x2F;CD（Jenkins、GitLab CI、ArgoCD）</h3><p><strong>题目 1（基础）</strong>：<br> CI&#x2F;CD 的核心作用是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>持续集成（CI）：自动构建、测试代码，提高开发效率；</li>
<li>持续交付&#x2F;部署（CD）：自动发布、部署到环境，保证快速、可重复交付；</li>
<li>提高软件质量和发布速度。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 如何实现微服务应用自动化部署？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>Jenkins&#x2F;GitLab CI 构建镜像、执行测试；</li>
<li>Docker Push 镜像到 Registry；</li>
<li>ArgoCD 或 Helm 部署更新 Kubernetes 集群；</li>
<li>结合监控报警和回滚策略保证安全。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> CI&#x2F;CD 常见挑战有哪些？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>多环境一致性问题；</li>
<li>构建&#x2F;部署失败回滚处理；</li>
<li>依赖管理和版本控制；</li>
<li>流水线安全、权限控制；</li>
<li>微服务依赖顺序和配置管理。</li>
</ul>
<hr>
<h3 id="高可用（多-AZ、故障切换、自动伸缩）"><a href="#高可用（多-AZ、故障切换、自动伸缩）" class="headerlink" title="高可用（多 AZ、故障切换、自动伸缩）"></a>高可用（多 AZ、故障切换、自动伸缩）</h3><p><strong>题目 1（基础）</strong>：<br> 高可用的核心指标是什么？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>SLA（Service Level Agreement）：服务可用性目标；</li>
<li>容错能力：单点故障不影响系统整体；</li>
<li>自动故障切换和自愈能力。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> Web 服务在单 AZ 宕机时如何保证可用？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>多可用区部署（Multi-AZ）；</li>
<li>使用负载均衡器自动切换健康节点；</li>
<li>自动伸缩（HPA&#x2F;VPA）保证服务压力可控；</li>
<li>数据库采用主备或集群模式，保证数据可用性。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> Kubernetes 如何实现自动伸缩？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>HPA（Horizontal Pod Autoscaler）：根据 CPU&#x2F;内存或自定义指标自动增加&#x2F;减少 Pod 副本；</li>
<li>VPA（Vertical Pod Autoscaler）：动态调整 Pod 资源请求；</li>
<li>Cluster Autoscaler：动态扩缩集群节点。</li>
</ul>
<hr>
<h3 id="监控与告警（SLO-SLI-SLA，Prometheus-Grafana）"><a href="#监控与告警（SLO-SLI-SLA，Prometheus-Grafana）" class="headerlink" title="监控与告警（SLO&#x2F;SLI&#x2F;SLA，Prometheus+Grafana）"></a>监控与告警（SLO&#x2F;SLI&#x2F;SLA，Prometheus+Grafana）</h3><p><strong>题目 1（基础）</strong>：<br> SLO、SLI、SLA 含义？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>SLI（Service Level Indicator）：服务级别指标，如延迟、错误率；</li>
<li>SLO（Service Level Objective）：服务指标目标值；</li>
<li>SLA（Service Level Agreement）：与用户约定的服务可用性协议，包含处罚条款。</li>
</ul>
<p><strong>题目 2（场景题）</strong>：<br> 如何监控微服务性能并触发告警？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>使用 Prometheus 收集指标（CPU、内存、请求延迟、错误率）；</li>
<li>Grafana 可视化，创建仪表盘；</li>
<li>设置 Alertmanager 告警规则，触发短信&#x2F;邮件&#x2F;钉钉通知；</li>
<li>可结合自动伸缩策略缓解高负载。</li>
</ul>
<p><strong>题目 3（考点延伸）</strong>：<br> 微服务可观测性与单体系统有何不同？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>微服务分布式，链路复杂，需要分布式追踪；</li>
<li>指标、日志、追踪需集中采集；</li>
<li>故障定位需支持跨服务调用分析；</li>
<li>SLA&#x2F;SLO 监控粒度更细。</li>
</ul>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://charlotte030710.github.io">Charlotte</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://charlotte030710.github.io/2025/09/22/%E9%A2%98%E5%BA%93/">https://charlotte030710.github.io/2025/09/22/%E9%A2%98%E5%BA%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://charlotte030710.github.io" target="_blank">浮生若梦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/Mysql/">Mysql</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/img/title.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/22/java%E7%9F%A5%E8%AF%86%E7%82%B9/" title="重要知识点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">重要知识点</div></div><div class="info-2"><div class="info-item-1"> 网络基础一、网络基础概念 网络的定义 网络是多个计算机及通信设备通过通信介质互联的系统，用于信息传输、资源共享、协同工作。 核心目标：可靠、高效、可扩展的数据传输。 设计原则：分层、模块化、接口标准化。   数据传输方式 单工：单向传输（电视广播）。 半双工：双向传输，但不能同时发送（对讲机）。 全双工：双向同时传输（电话、以太网交换机端口）。   通信方式 点对点：两个节点直接通信（PPP）。 广播：单点发送，多点接收（Ethernet）。 组播：单点发送，特定组接收（IP 多播）。   网络分类 按地理范围：LAN、MAN、WAN。 按拓扑结构：星型、总线型、环型、混合型。 按访问控制方式：CSMA&#x2F;CD（Ethernet）、令牌环（Token Ring）。     二、OSI 七层模型OSI 模型将网络通信划分为七层，每层负责特定功能，确保模块化与互操作性。    层 功能 数据单位 典型协议&#x2F;设备 面试易问点    物理层 比特流传输，电气&#x2F;光学&#x2F;机械接口 比特 Bit 网线、光纤、集线器、网卡物理部分、调制解调器 电压、传输速率...</div></div></div></a><a class="pagination-related  no-desc" href="/2025/09/22/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" title="文件上传"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">文件上传</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/23/%E7%AE%80%E6%98%93%E7%89%88%E9%A2%98%E7%9B%AE/" title="简易版题目"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-23</div><div class="info-item-2">简易版题目</div></div><div class="info-2"><div class="info-item-1">📚 数据库题库答案1、OSI 七层模型 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 功能：自下而上分别负责传输介质、链路控制、路由转发、端到端传输、会话管理、数据格式转换、应用服务。   2、TCP 的三次握手 客户端 → 服务端：SYN&#x3D;1（请求建立连接）。 服务端 → 客户端：SYN&#x3D;1, ACK&#x3D;1（确认并同意建立）。 客户端 → 服务端：ACK&#x3D;1（确认）。 👉 作用：确保双方具备收发能力，并同步初始序列号。   3、TCP 的四次挥手 客户端 → 服务端：FIN&#x3D;1（我没数据了）。 服务端 → 客户端：ACK&#x3D;1（收到）。 服务端 → 客户端：FIN&#x3D;1（我也没数据了）。 客户端 → 服务端：ACK&#x3D;1（收到）。 👉 双方各自独立关闭。   4、SQL 语言和方言的区别 SQL 语言：标准 SQL（ANSI&#x2F;ISO 定义），如 SELECT * FROM table;。 SQL 方言：不同数据库厂商在标准 SQL 基础上扩展的特性，如 MySQL 的 LIM...</div></div></div></a><a class="pagination-related" href="/2025/09/22/java%E7%9F%A5%E8%AF%86%E7%82%B9/" title="重要知识点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-22</div><div class="info-item-2">重要知识点</div></div><div class="info-2"><div class="info-item-1"> 网络基础一、网络基础概念 网络的定义 网络是多个计算机及通信设备通过通信介质互联的系统，用于信息传输、资源共享、协同工作。 核心目标：可靠、高效、可扩展的数据传输。 设计原则：分层、模块化、接口标准化。   数据传输方式 单工：单向传输（电视广播）。 半双工：双向传输，但不能同时发送（对讲机）。 全双工：双向同时传输（电话、以太网交换机端口）。   通信方式 点对点：两个节点直接通信（PPP）。 广播：单点发送，多点接收（Ethernet）。 组播：单点发送，特定组接收（IP 多播）。   网络分类 按地理范围：LAN、MAN、WAN。 按拓扑结构：星型、总线型、环型、混合型。 按访问控制方式：CSMA&#x2F;CD（Ethernet）、令牌环（Token Ring）。     二、OSI 七层模型OSI 模型将网络通信划分为七层，每层负责特定功能，确保模块化与互操作性。    层 功能 数据单位 典型协议&#x2F;设备 面试易问点    物理层 比特流传输，电气&#x2F;光学&#x2F;机械接口 比特 Bit 网线、光纤、集线器、网卡物理部分、调制解调器 电压、传输速率...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" title="命令大全"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">命令大全</div></div><div class="info-2"><div class="info-item-1"> 📌 一、Linux 常见命令大全🔹 文件与目录操作   命令 说明 示例    ls 列出目录内容 ls -al 显示隐藏文件和详细信息   pwd 显示当前目录 pwd   cd 切换目录 cd /usr/local   mkdir 创建目录 mkdir -p /data/logs   rmdir 删除空目录 rmdir old   rm 删除文件&#x2F;目录 rm -rf /tmp/test   cp 复制文件&#x2F;目录 cp a.txt /tmp/，cp -r dir1 dir2   mv 移动&#x2F;重命名 mv old.txt new.txt   find 查找文件 find / -name &quot;*.log&quot;   locate 快速查找文件（需 updatedb） locate nginx.conf    🔹 文件查看与编辑   命令 说明 示例    cat 查看文件内容 cat file.txt   tac 反向输出 tac file.txt   less 分页查看 less /var/log/syslog   head 查看...</div></div></div></a><a class="pagination-related" href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-11</div><div class="info-item-2">分布式</div></div><div class="info-2"><div class="info-item-1">1. Spring Cloud 体系核心思想Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的规范和解决方案的集合。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。 Netflix OSS 常用组件（部分进入维护模式） 服务注册与发现 (Service Discovery): Eureka 作用: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。 使用: 服务端添加 spring-cloud-starter-netflix-eureka-server 依赖，并使用 @EnableEurekaServer 注解。客...</div></div></div></a><a class="pagination-related" href="/2025/09/22/%E6%80%BB%E7%BB%93/" title="要点提纲"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-22</div><div class="info-item-2">要点提纲</div></div><div class="info-2"><div class="info-item-1">要点提纲1. 网络1.1 OSI 七层模型 物理层：比特流传输，网线、光纤、网卡。 数据链路层：成帧、MAC 地址、交换机、以太网协议。 网络层：IP 地址、子网、路由、ICMP、ARP。 传输层：TCP（可靠，面向连接）、UDP（无连接、不可靠，低延迟）。 会话层：建立、管理、终止会话。 表示层：数据表示、加密解密（SSL&#x2F;TLS）、编码（Unicode）。 应用层：HTTP、HTTPS、FTP、DNS、SMTP、SSH。  1.2 TCP&#x2F;IP 四层模型 网络接口层：驱动、网卡、MAC。 网络层：IP、ICMP。 传输层：TCP、UDP。 应用层：HTTP、DNS、SMTP。  1.3 TCP 机制 三次握手：SYN、SYN+ACK、ACK → 同步序列号，建立可靠连接。 四次挥手：FIN&#x2F;ACK → 关闭通道，TIME_WAIT 等待 2MSL。 状态机：SYN_SENT、ESTABLISHED、FIN_WAIT、CLOSE_WAIT、TIME_WAIT。 拥塞控制：慢启动、拥塞避免、快重传、快恢复。 流量控制：滑动窗口。 常见问题：粘包&#x...</div></div></div></a><a class="pagination-related no-desc" href="/2025/09/22/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" title="文件上传"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-22</div><div class="info-item-2">文件上传</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/title.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Charlotte</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/charlotte030710"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Das Leben schwingt wie ein Pendel, hin und her, zwischen dem Schmerz und der Langeweile.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97-1%EF%BC%9A%E7%BD%91%E7%BB%9C"><span class="toc-number">1.</span> <span class="toc-text">模块 1：网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">OSI七层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%88%E6%AF%94%E7%89%B9%E6%B5%81%E4%BC%A0%E8%BE%93%EF%BC%8C%E7%BD%91%E7%BA%BF%E3%80%81%E5%85%89%E7%BA%A4%E3%80%81%E7%BD%91%E5%8D%A1%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">物理层（比特流传输，网线、光纤、网卡）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%88%E6%88%90%E5%B8%A7%E3%80%81MAC-%E5%9C%B0%E5%9D%80%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">数据链路层（成帧、MAC 地址、交换机、以太网协议）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88IP-%E5%9C%B0%E5%9D%80%E3%80%81%E5%AD%90%E7%BD%91%E3%80%81%E8%B7%AF%E7%94%B1%E3%80%81ICMP%E3%80%81ARP%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">网络层（IP 地址、子网、路由、ICMP、ARP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%88TCP%E3%80%81UDP%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">传输层（TCP、UDP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%B1%82%EF%BC%88%E5%BB%BA%E7%AB%8B%E3%80%81%E7%AE%A1%E7%90%86%E3%80%81%E7%BB%88%E6%AD%A2%E4%BC%9A%E8%AF%9D%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">会话层（建立、管理、终止会话）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%B1%82%EF%BC%88%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E3%80%81%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E3%80%81%E7%BC%96%E7%A0%81%EF%BC%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">表示层（数据表示、加密解密、编码）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88HTTP%E3%80%81HTTPS%E3%80%81FTP%E3%80%81DNS%E3%80%81SMTP%E3%80%81SSH%EF%BC%89"><span class="toc-number">1.1.7.</span> <span class="toc-text">应用层（HTTP、HTTPS、FTP、DNS、SMTP、SSH）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82%EF%BC%88%E9%A9%B1%E5%8A%A8%E3%80%81%E7%BD%91%E5%8D%A1%E3%80%81MAC%EF%BC%89"><span class="toc-number">1.1.8.</span> <span class="toc-text">网络接口层（驱动、网卡、MAC）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88IP%E3%80%81ICMP%EF%BC%89"><span class="toc-number">1.1.9.</span> <span class="toc-text">网络层（IP、ICMP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%88TCP%E3%80%81UDP%EF%BC%89-1"><span class="toc-number">1.1.10.</span> <span class="toc-text">传输层（TCP、UDP）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">TCP 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88SYN%E3%80%81SYN-ACK%E3%80%81ACK%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">三次握手（SYN、SYN+ACK、ACK）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88FIN-ACK%E3%80%81TIME-WAIT%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">四次挥手（FIN&#x2F;ACK、TIME_WAIT）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">拥塞控制、流量控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">1.3.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-TLS"><span class="toc-number">1.4.</span> <span class="toc-text">HTTPS&#x2F;TLS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%A1%E6%89%8B%E3%80%81%E8%AF%81%E4%B9%A6%E3%80%81%E5%8A%A0%E5%AF%86"><span class="toc-number">1.5.</span> <span class="toc-text">握手、证书、加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS-%E7%89%88%E6%9C%AC%E4%B8%8E%E5%89%8D%E5%90%91%E4%BF%9D%E5%AF%86"><span class="toc-number">1.6.</span> <span class="toc-text">TLS 版本与前向保密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7"><span class="toc-number">1.7.</span> <span class="toc-text">常用网络工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ping%E3%80%81traceroute"><span class="toc-number">1.7.1.</span> <span class="toc-text">ping、traceroute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcpdump%E3%80%81wireshark"><span class="toc-number">1.7.2.</span> <span class="toc-text">tcpdump、wireshark</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ss%E3%80%81netstat%E3%80%81iftop"><span class="toc-number">1.7.3.</span> <span class="toc-text">ss、netstat、iftop</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97-2%EF%BC%9ALinux"><span class="toc-number">2.</span> <span class="toc-text">模块 2：Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88top%E3%80%81ps%E3%80%81df%E3%80%81du%E3%80%81netstat%E3%80%81ss%E3%80%81lsof%E3%80%81journalctl%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">常用命令（top、ps、df、du、netstat、ss、lsof、journalctl）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%EF%BC%88rwx%E3%80%81chmod%E3%80%81chown%E3%80%81ACL%E3%80%81SUID-SGID-sticky-bit%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">权限管理（rwx、chmod、chown、ACL、SUID&#x2F;SGID&#x2F;sticky bit）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88kill%E3%80%81jobs%E3%80%81fg%E3%80%81bg%E3%80%81nohup%E3%80%81tmux%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">进程管理（kill、jobs、fg、bg、nohup、tmux）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88ext4%E3%80%81inode%E3%80%81%E7%A1%AC-%E8%BD%AF%E9%93%BE%E6%8E%A5%E3%80%81%E6%8C%82%E8%BD%BD%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">文件系统（ext4、inode、硬&#x2F;软链接、挂载）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">IO 模型（阻塞、非阻塞、I&#x2F;O 多路复用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%92%E6%9F%A5%EF%BC%88ping%E3%80%81tcpdump%E3%80%81iftop%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">网络排查（ping、tcpdump、iftop）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%88ulimit%E3%80%81sysctl%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%81I-O-%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">性能调优（ulimit、sysctl、内存管理、I&#x2F;O 调度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systemd%EF%BC%88systemctl%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">systemd（systemctl、服务管理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%EF%BC%88SELinux%E3%80%81AppArmor%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">安全（SELinux、AppArmor）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97-3%EF%BC%9AMySQL"><span class="toc-number">3.</span> <span class="toc-text">模块 3：MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%EF%BC%88slow-query-log%E3%80%81EXPLAIN%E3%80%81performance-schema%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">慢查询优化（slow_query_log、EXPLAIN、performance_schema）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%EF%BC%88B-%E6%A0%91%E7%BB%93%E6%9E%84%E3%80%81%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-vs-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">索引（B+ 树结构、聚簇索引 vs 非聚簇索引）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%EF%BC%88ACID%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E3%80%81%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E3%80%81MVCC%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">事务（ACID、隔离级别、并发问题、MVCC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%EF%BC%88%E8%A1%A8%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81%E3%80%81%E5%85%B1%E4%BA%AB%E9%94%81%E3%80%81%E6%8E%92%E4%BB%96%E9%94%81%E3%80%81%E9%97%B4%E9%9A%99%E9%94%81%E3%80%81Next-Key-%E9%94%81%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">锁（表锁、行锁、共享锁、排他锁、间隙锁、Next-Key 锁、乐观锁、悲观锁）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%88InnoDB%E3%80%81MyISAM%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">存储引擎（InnoDB、MyISAM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%EF%BC%88redo-log%E3%80%81undo-log%E3%80%81binlog%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">日志（redo log、undo log、binlog）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97-4%EF%BC%9AJava"><span class="toc-number">4.</span> <span class="toc-text">模块 4：Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">基本类型与包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">Object 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">4.3.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%EF%BC%88Checked-vs-Unchecked%E3%80%81try-with-resources%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">异常（Checked vs Unchecked、try-with-resources）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%88synchronized%E3%80%81ReentrantLock%E3%80%81CAS%E3%80%81%E5%8E%9F%E5%AD%90%E7%B1%BB%E3%80%81ThreadLocal%E3%80%81Thread%E3%80%81Runnable%E3%80%81Callable%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">并发（synchronized、ReentrantLock、CAS、原子类、ThreadLocal、Thread、Runnable、Callable、线程池）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%EF%BC%88List%E3%80%81Set%E3%80%81Map%E3%80%81%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">集合（List、Set、Map、并发集合）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E3%80%81OOM%EF%BC%89"><span class="toc-number">4.7.</span> <span class="toc-text">JVM 内部结构（运行时内存区域、类加载、双亲委派、OOM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="toc-number">4.8.</span> <span class="toc-text">GC（垃圾回收）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97-5%EF%BC%9AWeb"><span class="toc-number">5.</span> <span class="toc-text">模块 5：Web</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%EF%BC%88%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E3%80%81%E7%8A%B6%E6%80%81%E7%A0%81%E3%80%81Header%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">HTTP（请求方法、状态码、Header）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%EF%BC%88TLS-%E5%8A%A0%E5%AF%86%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">HTTPS（TLS 加密）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie%E3%80%81Session%E3%80%81Token"><span class="toc-number">5.3.</span> <span class="toc-text">Cookie、Session、Token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RESTful-API-%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.4.</span> <span class="toc-text">RESTful API 设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%EF%BC%88CORS%E3%80%81JSONP%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">跨域（CORS、JSONP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%EF%BC%88Cache-Control%E3%80%81ETag%E3%80%81Last-Modified%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">缓存（Cache-Control、ETag、Last-Modified）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket%E3%80%81SSE%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="toc-number">5.7.</span> <span class="toc-text">WebSocket、SSE、长轮询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97-6%EF%BC%9A%E6%A1%86%E6%9E%B6"><span class="toc-number">6.</span> <span class="toc-text">模块 6：框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Spring%EF%BC%88IoC-%E5%AE%B9%E5%99%A8%E3%80%81Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81AOP%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 Spring（IoC 容器、Bean 生命周期、AOP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Spring-Boot%EF%BC%88%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E3%80%81Starter-%E6%A8%A1%E5%9D%97%E3%80%81%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%81Actuator%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 Spring Boot（自动配置原理、Starter 模块、配置优先级、Actuator）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Spring-MVC%EF%BC%88DispatcherServlet%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 Spring MVC（DispatcherServlet、拦截器、异常处理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-MyBatis%EF%BC%88SQL-%E6%98%A0%E5%B0%84%E3%80%81%E5%8A%A8%E6%80%81-SQL%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81N-1-%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 MyBatis（SQL 映射、动态 SQL、缓存、N+1 问题）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97-7%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">模块 7：分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Spring-Cloud%EF%BC%88%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E7%BD%91%E5%85%B3%E3%80%81%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 Spring Cloud（服务注册发现、负载均衡、网关、熔断限流）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9%EF%BC%88%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E3%80%81JWT-OAuth2%E3%80%81Redis%E3%80%81MQ%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E3%80%81CAP-BASE%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%B0%83%E3%80%81%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 分布式核心要点（雪花算法、JWT&#x2F;OAuth2、Redis、MQ、分布式事务、CAP&#x2F;BASE、一致性协调、可观测性）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80-ID%EF%BC%89"><span class="toc-number">7.2.1.</span> <span class="toc-text">雪花算法（分布式唯一 ID）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT-OAuth2%EF%BC%88%E6%97%A0%E7%8A%B6%E6%80%81%E8%AE%A4%E8%AF%81%EF%BC%89"><span class="toc-number">7.2.2.</span> <span class="toc-text">JWT &#x2F; OAuth2（无状态认证）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%81%E9%9B%86%E7%BE%A4%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E3%80%81%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">7.2.3.</span> <span class="toc-text">Redis（数据结构、持久化、集群、分布式锁、缓存问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MQ%EF%BC%88%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7%E3%80%81%E8%A7%A3%E8%80%A6%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E6%B6%88%E8%B4%B9%E8%AF%AD%E4%B9%89%EF%BC%89"><span class="toc-number">7.2.4.</span> <span class="toc-text">MQ（削峰填谷、解耦、异步、消费语义）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%882PC%E3%80%81XA%E3%80%81Saga%E3%80%81%E8%A1%A5%E5%81%BF%E3%80%81Seata%EF%BC%89"><span class="toc-number">7.2.5.</span> <span class="toc-text">分布式事务（2PC、XA、Saga、补偿、Seata）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAP-BASE-%E7%90%86%E8%AE%BA"><span class="toc-number">7.2.6.</span> <span class="toc-text">CAP &#x2F; BASE 理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%B0%83%EF%BC%88Zookeeper%E3%80%81etcd%EF%BC%89"><span class="toc-number">7.2.7.</span> <span class="toc-text">一致性协调（Zookeeper、etcd）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%EF%BC%88ELK%E3%80%81Prometheus%E3%80%81Grafana%E3%80%81Jaeger%EF%BC%89"><span class="toc-number">7.2.8.</span> <span class="toc-text">可观测性（ELK、Prometheus、Grafana、Jaeger）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97-8%EF%BC%9A%E8%BF%90%E7%BB%B4-%E5%AE%B9%E5%99%A8%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">模块 8：运维&#x2F;容器化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%EF%BC%88%E9%95%9C%E5%83%8F%E3%80%81%E5%AE%B9%E5%99%A8%E3%80%81Dockerfile%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">Docker（镜像、容器、Dockerfile）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes%EF%BC%88Pod%E3%80%81Deployment%E3%80%81Service%E3%80%81Ingress%E3%80%81ConfigMap%E3%80%81Secret%E3%80%81StatefulSet%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">Kubernetes（Pod、Deployment、Service、Ingress、ConfigMap、Secret、StatefulSet）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5%EF%BC%88%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0%E3%80%81%E8%93%9D%E7%BB%BF%E3%80%81%E9%87%91%E4%B8%9D%E9%9B%80%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">部署策略（滚动更新、蓝绿、金丝雀）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CI-CD%EF%BC%88Jenkins%E3%80%81GitLab-CI%E3%80%81ArgoCD%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">CI&#x2F;CD（Jenkins、GitLab CI、ArgoCD）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%88%E5%A4%9A-AZ%E3%80%81%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%E3%80%81%E8%87%AA%E5%8A%A8%E4%BC%B8%E7%BC%A9%EF%BC%89"><span class="toc-number">8.5.</span> <span class="toc-text">高可用（多 AZ、故障切换、自动伸缩）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%91%8A%E8%AD%A6%EF%BC%88SLO-SLI-SLA%EF%BC%8CPrometheus-Grafana%EF%BC%89"><span class="toc-number">8.6.</span> <span class="toc-text">监控与告警（SLO&#x2F;SLI&#x2F;SLA，Prometheus+Grafana）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/01/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/" title="框架常用注解">框架常用注解</a><time datetime="2025-09-30T16:00:00.000Z" title="发表于 2025-10-01 00:00:00">2025-10-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/01/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/" title="牛客面试题">牛客面试题</a><time datetime="2025-09-30T16:00:00.000Z" title="发表于 2025-10-01 00:00:00">2025-10-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/23/%E7%AE%80%E6%98%93%E7%89%88%E9%A2%98%E7%9B%AE/" title="简易版题目">简易版题目</a><time datetime="2025-09-22T16:00:00.000Z" title="发表于 2025-09-23 00:00:00">2025-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/22/go/" title="go">go</a><time datetime="2025-09-21T16:00:00.000Z" title="发表于 2025-09-22 00:00:00">2025-09-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/22/%E6%80%BB%E7%BB%93/" title="要点提纲">要点提纲</a><time datetime="2025-09-21T16:00:00.000Z" title="发表于 2025-09-22 00:00:00">2025-09-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bg.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Charlotte</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
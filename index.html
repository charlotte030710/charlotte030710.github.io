<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>My Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="My Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="My Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Charlotte">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="My Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">My Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我的个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-8.21学会" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/11/8.21%E5%AD%A6%E4%BC%9A/" class="article-date">
  <time class="dt-published" datetime="2025-09-11T10:29:28.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/11/8.21%E5%AD%A6%E4%BC%9A/">8.21学会</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-实现单例模式-Singleton-Pattern"><a href="#1-实现单例模式-Singleton-Pattern" class="headerlink" title="1.实现单例模式 (Singleton Pattern)"></a>1.实现单例模式 (Singleton Pattern)</h3><h4 id="懒汉式："><a href="#懒汉式：" class="headerlink" title="懒汉式："></a>懒汉式：</h4><p>使用<strong>双重检查锁定 (DCL)</strong> 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有化构造器，防止外部直接 new 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供一个全局访问点，使用 DCL 确保线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查：如果实例已经存在，直接返回，避免不必要的同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一次检查失败，进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查：在同步块内部再次检查，防止多个线程同时通过第一次检查，</span></span><br><span class="line">                <span class="comment">// 导致创建多个实例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建实例</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个线程安全的懒汉式单例模式实例。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="饿汉式："><a href="#饿汉式：" class="headerlink" title="饿汉式："></a>饿汉式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonEager</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 在类加载时就创建静态实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonEager</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonEager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有化构造器，防止外部直接创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonEager</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供一个公共的静态方法来获取唯一实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonEager <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个线程安全的饿汉式单例模式实例。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-继承与多态-Inheritance-and-Polymorphism"><a href="#2-继承与多态-Inheritance-and-Polymorphism" class="headerlink" title="2.继承与多态 (Inheritance and Polymorphism)"></a>2.继承与多态 (Inheritance and Polymorphism)</h3><p>设计一个 <code>Animal</code> 抽象类，并创建 <code>Dog</code> 和 <code>Cat</code> 类来展示继承和多态。&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Animal 抽象类，定义通用行为</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Dog 类继承 Animal，并重写 eat() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗正在吃骨头。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Cat 类继承 Animal，并重写 eat() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫正在吃鱼。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 展示多态的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PolymorphismDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showPolymorphism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 父类引用指向子类对象，这就是多态</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用相同的方法，但由于指向不同的子类实例，执行不同的行为</span></span><br><span class="line">        myDog.eat(); <span class="comment">// 输出: 狗正在吃骨头。</span></span><br><span class="line">        myCat.eat(); <span class="comment">// 输出: 猫正在吃鱼。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="equals-和-hashCode"><a href="#equals-和-hashCode" class="headerlink" title="equals() 和 hashCode()"></a><code>equals()</code> 和 <code>hashCode()</code></h3><p>编写 <code>Student</code> 类，并重写 <code>equals()</code> 和 <code>hashCode()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 equals() 方法，根据 id 和 name 判断两个 Student 对象是否相等</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 检查是否为同一个对象的引用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 2. 检查对象是否为 null 或类型是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 3. 类型转换</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="comment">// 4. 比较关键字段 (id 和 name)</span></span><br><span class="line">        <span class="keyword">return</span> id == student.id &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 hashCode() 方法，为相等的对象生成相同的哈希码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Objects.hash() 方法生成哈希码，它会为多个字段生成一个组合哈希值</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 为什么需要两者一起重写？</span></span><br><span class="line"><span class="comment">* 1. 它们之间存在约定：如果两个对象通过 equals() 方法比较是相等的，那么它们的 hashCode() 方法返回的值也必须相等。</span></span><br><span class="line"><span class="comment">* 反之则不一定，不相等的对象可以有相同的哈希码（哈希冲突）。</span></span><br><span class="line"><span class="comment">* 2. 哈希表类（如 HashSet, HashMap）依赖于这个约定：当将对象存入哈希表时，</span></span><br><span class="line"><span class="comment">* 它会先调用 hashCode() 确定存储位置，再调用 equals() 来确认是否存在相同的对象。</span></span><br><span class="line"><span class="comment">* 3. 如果只重写 equals() 但不重写 hashCode()，可能导致两个逻辑上相等的对象被存储在不同的哈希位置，</span></span><br><span class="line"><span class="comment">* 从而无法正确查找和去重。例如，在 HashSet 中，即使两个 Student 对象 id 和 name 相同，</span></span><br><span class="line"><span class="comment">* 也会被认为是不同的对象而重复添加。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="接口与实现-Interfaces-and-Implementation"><a href="#接口与实现-Interfaces-and-Implementation" class="headerlink" title="接口与实现 (Interfaces and Implementation)"></a>接口与实现 (Interfaces and Implementation)</h3><p>设计 <code>Drawable</code> 接口，并由 <code>Circle</code> 和 <code>Rectangle</code> 实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义 Drawable 接口，包含一个抽象方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Circle 类实现 Drawable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在画一个圆形。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Rectangle 类实现 Drawable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在画一个矩形。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="异常处理-Exception-Handling"><a href="#异常处理-Exception-Handling" class="headerlink" title="异常处理 (Exception Handling)"></a>异常处理 (Exception Handling)</h3><p>使用 <code>try-catch-finally</code> 结构处理 <code>FileNotFoundException</code> 并确保资源关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 在 try 块外部声明，以便在 finally 块中访问</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试打开文件</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已成功打开。&quot;</span>);</span><br><span class="line">            <span class="comment">// 假设这里进行文件读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件未找到异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;错误：指定的文件不存在！路径：&quot;</span> + filePath);</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印异常堆栈信息</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论是否发生异常，finally 块都会执行</span></span><br><span class="line">            <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 确保文件流被关闭，防止资源泄露</span></span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件流已在 finally 块中关闭。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;关闭文件流时发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a><code>try-with-resources</code></h3><p>使用 <code>try-with-resources</code> 重写上一个题目，展示其简化优势。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TryWithResourcesDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processFileWithResources</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">// try-with-resources 语句，自动管理实现了 AutoCloseable 接口的资源</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已成功打开。&quot;</span>);</span><br><span class="line">            <span class="comment">// 假设这里进行文件读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件未找到异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;错误：指定的文件不存在！路径：&quot;</span> + filePath);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件关闭时可能发生的异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;关闭文件流时发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不需要单独的 finally 块来关闭资源，JVM 会自动完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件流已在 try-with-resources 语句中自动关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* try-with-resources 的优势：</span></span><br><span class="line"><span class="comment">* 1. 简化代码：不再需要显式的 finally 块来关闭资源，代码更简洁。</span></span><br><span class="line"><span class="comment">* 2. 避免资源泄露：无论 try 块是否正常完成或抛出异常，资源都会被自动关闭，</span></span><br><span class="line"><span class="comment">* 有效防止了因忘记关闭资源而导致的内存和文件句柄泄露。</span></span><br><span class="line"><span class="comment">* 3. 更好的异常处理：如果 try 块和资源关闭时都抛出异常，try-with-resources 会</span></span><br><span class="line"><span class="comment">* 将资源关闭时抛出的异常作为被抑制（suppressed）的异常，主异常保持不变，</span></span><br><span class="line"><span class="comment">* 便于调试。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><h4 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1. 继承 Thread 类"></a>1. 继承 <code>Thread</code> 类</h4><p>通过继承 <code>java.lang.Thread</code> 类并重写其 <code>run()</code> 方法来创建线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承 Thread 类创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用继承 Thread 类的方式创建的线程正在运行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-实现-Runnable-接口"><a href="#2-实现-Runnable-接口" class="headerlink" title="2. 实现 Runnable 接口"></a>2. 实现 <code>Runnable</code> 接口</h4><p>通过实现 <code>java.lang.Runnable</code> 接口并将其作为参数传递给 <code>Thread</code> 类的构造函数来创建线程。这种方式更灵活，推荐使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Runnable 接口创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用实现 Runnable 接口的方式创建的线程正在运行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep() 与 yield()"></a><code>sleep()</code> 与 <code>yield()</code></h3><p><code>sleep()</code> 和 <code>yield()</code> 都是线程调度的方法，但它们的作用和效果不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepYieldDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 sleep() 的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// sleep() 使线程暂停指定时间，进入 WAITING 状态，但不会释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程 A: 准备睡眠 2 秒...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 A: 睡眠结束，继续执行。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 yield() 的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 B: 开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 B: 正在执行 &quot;</span> + i);</span><br><span class="line">                <span class="comment">// yield() 提示线程调度器让出 CPU 时间，但不保证一定生效</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 B: 执行完毕。&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sleep()</strong>: 使当前线程<strong>暂停执行指定的时间</strong>，进入 <strong>TIMED_WAITING</strong> 状态。它会<strong>释放 CPU 资源</strong>，但<strong>不释放锁</strong>。</li>
<li><strong>yield()</strong>: 提示线程调度器，当前线程愿意<strong>让出当前 CPU 时间片</strong>。线程会从 <strong>RUNNING</strong> 状态转换为 <strong>RUNNABLE</strong> 状态，与其他线程竞争 CPU，但<strong>不保证</strong>其他线程能立即获得执行。它主要用于优化线程调度，通常在多线程程序中<strong>不应依赖</strong>其行为来保证正确性。</li>
</ul>
<hr>
<h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join() 方法"></a><code>join()</code> 方法</h3><p><code>join()</code> 方法允许一个线程等待另一个线程执行完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JoinDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程: 正在执行...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;子线程: 执行完毕。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        workerThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 等待子线程执行完毕...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用 join() 方法，主线程进入等待状态，直到 workerThread 执行完毕</span></span><br><span class="line">        workerThread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 子线程已执行完毕，主线程继续执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="非线程安全计数器"><a href="#非线程安全计数器" class="headerlink" title="非线程安全计数器"></a>非线程安全计数器</h3><p>在多线程环境下，多个线程同时对共享资源进行读写操作，可能导致数据不一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 这一行代码并非原子操作，它包含三个步骤：读、加 1、写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafetyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">UnsafeCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsafeCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果不一定是 100 * 10000 = 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;非线程安全计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><code>synchronized</code> 关键字</h3><p>使用 <code>synchronized</code> 关键字可以保证同一时刻只有一个线程访问共享资源，从而解决线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 关键字修饰方法，锁住整个对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SynchronizedCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果为 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="synchronized-块与方法"><a href="#synchronized-块与方法" class="headerlink" title="synchronized 块与方法"></a><code>synchronized</code> 块与方法</h3><ul>
<li><strong>synchronized 方法</strong>: 锁定的是当前对象实例 (<code>this</code>)。</li>
<li><strong>synchronized 块</strong>: 提供了更细粒度的控制，可以指定锁定的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedBlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized 方法，锁定当前对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synchronizedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入 synchronized 方法。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 离开 synchronized 方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized 块，锁定指定的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedBlock1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取 lock1...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已获取 lock1。&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放 lock1。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedBlock2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取 lock2...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已获取 lock2。&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放 lock2。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 区别与适用场景:</span></span><br><span class="line"><span class="comment"> * - synchronized 方法: 简单易用，但锁定范围大，可能导致性能问题。当需要同步整个方法时使用。</span></span><br><span class="line"><span class="comment"> * - synchronized 块: 锁定范围小，可以只同步需要保护的代码段，提高并发性能。当只需要同步部分代码时使用。</span></span><br><span class="line"><span class="comment"> * 同时，可以通过锁定不同的对象来避免不必要的阻塞，实现更高的并发度。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><code>volatile</code> 关键字</h3><p><code>volatile</code> 关键字保证了变量在多线程间的<strong>可见性</strong>，但不保证<strong>原子性</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">    <span class="comment">// volatile 保证所有线程看到的是该变量的最新值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 正在等待标志位变为 true。&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="comment">// 空循环，等待 ready 变为 true</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 标志位已变为 true，循环结束。&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 确保线程 A 先运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 正在将标志位设置为 true。&quot;</span>);</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为什么 volatile 不能保证原子性?</span></span><br><span class="line"><span class="comment"> * - 原子性是指一个操作是不可中断的，要么全部执行，要么都不执行。</span></span><br><span class="line"><span class="comment"> * - volatile 只能保证变量的读写操作是原子的，但像 `count++` 这样的复合操作（读、加、写）</span></span><br><span class="line"><span class="comment"> * 依然不是原子的。多个线程可能同时读到旧值，导致最终结果不正确。</span></span><br><span class="line"><span class="comment"> * - volatile 主要用于一写多读的场景，或者用于控制线程执行流程的标志位。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a><code>AtomicInteger</code></h3><p><code>AtomicInteger</code> 是一个原子类，它使用 CAS (Compare-and-Swap) 机制来保证操作的原子性，从而实现线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 AtomicInteger 替代 int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet(); <span class="comment">// 这是一个原子操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果为 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicInteger 计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>使用 <code>wait()</code> 和 <code>notifyAll()</code> 实现两个线程交替打印奇数和偶数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintNumbers</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOdd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果是偶数，则等待</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEven</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count % <span class="number">2</span> != <span class="number">0</span>) &#123; <span class="comment">// 如果是奇数，则等待</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNumbers</span> <span class="variable">pn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumbers</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">oddThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(pn::printOdd, <span class="string">&quot;奇数线程&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">evenThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(pn::printEven, <span class="string">&quot;偶数线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        oddThread.start();</span><br><span class="line">        evenThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，以下是  中高级并发编程的实现，并附带详细注释。</p>
<h3 id="生产者-消费者模式-使用-wait-和-notifyAll"><a href="#生产者-消费者模式-使用-wait-和-notifyAll" class="headerlink" title="生产者-消费者模式 (使用 wait() 和 notifyAll())"></a>生产者-消费者模式 (使用 <code>wait()</code> 和 <code>notifyAll()</code>)</h3><p>这是一个经典的线程协作问题。生产者生产数据，放入共享队列；消费者从队列中取出数据进行消费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerClassic</span> &#123;</span><br><span class="line">    <span class="comment">// 共享队列，使用 LinkedList 实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 队列最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 如果队列已满，生产者等待</span></span><br><span class="line">                <span class="keyword">while</span> (queue.size() == MAX_SIZE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列已满，生产者等待...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 生产数据并放入队列</span></span><br><span class="line">                queue.offer(i);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 唤醒所有等待的线程（包括消费者）</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟生产时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 如果队列为空，消费者等待</span></span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列为空，消费者等待...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 消费数据</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">                <span class="comment">// 唤醒所有等待的线程（包括生产者）</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">// 模拟消费时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="生产者-消费者模式-使用-BlockingQueue"><a href="#生产者-消费者模式-使用-BlockingQueue" class="headerlink" title="生产者-消费者模式 (使用 BlockingQueue)"></a>生产者-消费者模式 (使用 <code>BlockingQueue</code>)</h3><p><code>java.util.concurrent.BlockingQueue</code> 接口提供了线程安全的队列操作，简化了生产者-消费者模型的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerBlockingQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 BlockingQueue，它内部已经处理了线程同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// put() 方法在队列满时会自动阻塞</span></span><br><span class="line">            queue.put(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// take() 方法在队列空时会自动阻塞</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h3><p>使用 <code>ReentrantLock</code> 实现线程安全计数器，并解释其与 <code>synchronized</code> 的区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReentrantLockCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++; <span class="comment">// 在 try 块中执行需要同步的代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 在 finally 块中释放锁，确保锁总是被释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* ReentrantLock 与 synchronized 的区别:</span></span><br><span class="line"><span class="comment">* 1. 语法层面: `synchronized` 是 JVM 的内置关键字，而 `ReentrantLock` 是一个类。</span></span><br><span class="line"><span class="comment">* 2. 灵活性: `ReentrantLock` 提供了更灵活的锁定控制。例如，它支持公平锁（按请求顺序获取锁），</span></span><br><span class="line"><span class="comment">* 可以尝试非阻塞地获取锁（`tryLock()`），以及支持中断（`lockInterruptibly()`）。</span></span><br><span class="line"><span class="comment">* 3. 性能: 在早期版本中，`ReentrantLock` 通常性能更好。但随着  对 `synchronized` 优化（偏向锁、轻量级锁），</span></span><br><span class="line"><span class="comment">* 两者性能已非常接近。在简单场景下，`synchronized` 更简洁。</span></span><br><span class="line"><span class="comment">* 4. 协作: `ReentrantLock` 必须配合 `Condition` 接口才能实现线程间的等待/唤醒机制，而 `synchronized` 直接</span></span><br><span class="line"><span class="comment">* 使用 `Object` 的 `wait()` 和 `notify()`。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ReentrantLock-与-Condition"><a href="#ReentrantLock-与-Condition" class="headerlink" title="ReentrantLock 与 Condition"></a><code>ReentrantLock</code> 与 <code>Condition</code></h3><p>使用 <code>ReentrantLock</code> 和 <code>Condition</code> 重新实现生产者-消费者模型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerCondition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 创建两个 Condition 实例，分别用于生产者和消费者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">producerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">consumerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == MAX_SIZE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列已满，生产者等待...&quot;</span>);</span><br><span class="line">                    producerCondition.await(); <span class="comment">// 生产者等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                consumerCondition.signalAll(); <span class="comment">// 唤醒所有消费者</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列为空，消费者等待...&quot;</span>);</span><br><span class="line">                    consumerCondition.await(); <span class="comment">// 消费者等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">                producerCondition.signalAll(); <span class="comment">// 唤醒所有生产者</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><code>ExecutorService</code></h3><p>创建一个固定大小的线程池，并向其提交多个任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutorServiceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小为 3 的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 执行。&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池，不再接收新任务，已提交的任务会继续执行</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Callable-与-Future"><a href="#Callable-与-Future" class="headerlink" title="Callable 与 Future"></a><code>Callable</code> 与 <code>Future</code></h3><p>使用 <code>Callable</code> 提交任务，并使用 <code>Future</code> 获取返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 Callable 任务，它会返回一个字符串</span></span><br><span class="line">        Callable&lt;String&gt; task = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务开始执行...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;任务执行完毕，返回结果！&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务并获得 Future 对象</span></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(task);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 任务已提交，继续执行其他操作...&quot;</span>);</span><br><span class="line">        <span class="comment">// get() 方法会阻塞，直到任务完成并返回结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 获得任务结果 -&gt; &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h3><p><code>CountDownLatch</code> 允许一个或多个线程等待直到在其他线程中执行的一组操作完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">workerCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 计数器，当计数器减到 0 时，主线程会被唤醒</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(workerCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 开始执行任务...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">2000</span>)); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 任务完成。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown(); <span class="comment">// 任务完成后，计数器减 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 等待所有工作线程完成...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 阻塞主线程，直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 所有工作线程已完成，继续执行下一步。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code> 允许一组线程相互等待，直到所有线程都到达一个共同的屏障点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">partySize</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 当 3 个线程都到达屏障时，执行一个屏障动作</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(partySize, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n所有线程已到达屏障点！继续执行下一阶段。\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(partySize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; partySize; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在执行第一阶段任务...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 第一阶段任务完成，到达屏障。&quot;</span>);</span><br><span class="line">                    barrier.await(); <span class="comment">// 线程在此处等待</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在执行第二阶段任务...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h3><p><code>Semaphore</code>（信号量）用来控制对资源的并发访问数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 允许 3 个线程同时访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessResource</span><span class="params">(<span class="type">int</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 获取许可</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在访问资源...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟资源访问时间</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 访问资源完毕。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SemaphoreDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SemaphoreDemo</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; demo.accessResource(threadId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><h4 id="1-死锁演示"><a href="#1-死锁演示" class="headerlink" title="1. 死锁演示"></a>1. 死锁演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B: 已获得 lock2，尝试获取 lock1...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B: 已获得 lock1。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadA, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadB, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 死锁产生条件:</span></span><br><span class="line"><span class="comment">* 1. 互斥条件: 资源是独占的，一个线程在使用时，其他线程无法使用。</span></span><br><span class="line"><span class="comment">* 2. 请求与保持条件: 线程已经持有至少一个资源，但又请求其他资源，同时又保持对已有资源的占有。</span></span><br><span class="line"><span class="comment">* 3. 不可剥夺条件: 资源只能在持有它的线程完成任务后由它自己释放。</span></span><br><span class="line"><span class="comment">* 4. 循环等待条件: 存在一个线程资源的循环链，每个线程都在等待下一个线程所持有的资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>通过打破死锁的四个必要条件之一来预防死锁。这里通过<strong>资源有序分配</strong>来打破<strong>循环等待</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockPrevention</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 A 按顺序先获取 lock1，再获取 lock2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 B 也按顺序先获取 lock1，再获取 lock2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockPrevention</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockPrevention</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadA, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadB, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 两个线程都按相同的顺序获取锁，不会发生死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p><code>ThreadLocal</code> 为每个线程提供了一个独立的变量副本，实现了线程间的数据隔离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAndPrint</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置线程本地变量</span></span><br><span class="line">        threadLocal.set(value);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务</span></span><br><span class="line">            <span class="comment">// 获取并打印当前线程的变量值</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的变量值: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 最佳实践：使用完后移除，防止内存泄漏</span></span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 A 的数据&quot;</span>), <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 B 的数据&quot;</span>), <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 原理和作用:</span></span><br><span class="line"><span class="comment">* 原理: ThreadLocal 内部有一个 `ThreadLocalMap`，每个线程都有一个独立的 `ThreadLocalMap`。</span></span><br><span class="line"><span class="comment">* 当我们调用 `set()` 方法时，实际上是将值存储到了当前线程的 `ThreadLocalMap` 中，</span></span><br><span class="line"><span class="comment">* 键为 `ThreadLocal` 实例本身。</span></span><br><span class="line"><span class="comment">* 作用:</span></span><br><span class="line"><span class="comment">* 1. 数据隔离: 解决了多线程访问共享变量的线程安全问题，但其本质不是同步，而是通过“以空间换时间”的方式，</span></span><br><span class="line"><span class="comment">* 为每个线程提供独立副本，避免了竞争。</span></span><br><span class="line"><span class="comment">* 2. 传递参数: 在整个方法调用链中，无需层层传递参数，可以方便地在任何地方获取当前线程的上下文信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程安全单例-静态内部类"><a href="#线程安全单例-静态内部类" class="headerlink" title="线程安全单例 (静态内部类)"></a>线程安全单例 (静态内部类)</h3><p>静态内部类方式是实现线程安全的懒汉式单例的最佳实践之一。它利用了 JVM 类加载机制的线程安全特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonThreadSafe</span> &#123;</span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonThreadSafe</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类，它只在 SingletonThreadSafe 被首次调用时才会被加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 静态成员变量，在类加载时初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonThreadSafe</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonThreadSafe</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供全局访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonThreadSafe <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 优点:</span></span><br><span class="line"><span class="comment">* 1. 线程安全: 类的加载是线程安全的，因此 INSTANCE 的初始化是原子的。</span></span><br><span class="line"><span class="comment">* 2. 懒加载: 只有在调用 getInstance() 方法时，SingletonHolder 类才会被加载，</span></span><br><span class="line"><span class="comment">* 从而实现懒加载。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a><code>ReadWriteLock</code></h3><p><code>ReadWriteLock</code> 适用于读多写少的场景，它允许多个线程同时进行读操作，但写操作必须是互斥的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sharedData</span> <span class="operator">=</span> <span class="string">&quot;初始数据&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在读取数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> (String) sharedData;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String newData)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在写入数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">// sharedData = newData; // 实际更新数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><p><code>ExecutorService</code> 的两种关闭方式：<code>shutdown()</code> 和 <code>shutdownNow()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShutdownDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交 5 个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在执行...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 被中断。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// shutdown() vs shutdownNow()</span></span><br><span class="line">        <span class="comment">// executor.shutdown(); // 优雅关闭</span></span><br><span class="line">        executor.shutdownNow(); <span class="comment">// 暴力关闭</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池已关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 区别:</span></span><br><span class="line"><span class="comment">* - shutdown(): 优雅关闭。不再接受新的任务，但会等待已提交的任务（包括正在执行和在队列中的）全部执行完毕。</span></span><br><span class="line"><span class="comment">* 执行后，isShutdown() 返回 true，isTerminated() 返回 false，直到所有任务完成。</span></span><br><span class="line"><span class="comment">* - shutdownNow(): 暴力关闭。立即停止所有正在执行的任务，并返回在队列中等待执行的任务列表。</span></span><br><span class="line"><span class="comment">* 它会向所有线程发送 interrupt() 中断信号。</span></span><br><span class="line"><span class="comment">* 执行后，isShutdown() 返回 true，isTerminated() 立即返回 true。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>一个线程通过响应 <code>interrupt()</code> 调用来正确停止自身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptedThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; <span class="comment">// 检查中断标志</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程正在执行...&quot;</span>);</span><br><span class="line">                    <span class="comment">// sleep()、wait() 等方法会抛出 InterruptedException 并清除中断标志</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程被中断！&quot;</span>);</span><br><span class="line">                    <span class="comment">// 重新设置中断标志，以便外层循环能正确退出</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">// 或者直接 return 退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程已退出。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        worker.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送中断信号</span></span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁预防-按锁顺序"><a href="#死锁预防-按锁顺序" class="headerlink" title="死锁预防 (按锁顺序)"></a>死锁预防 (按锁顺序)</h3><p>通过<strong>资源有序分配</strong>来打破死锁的<strong>循环等待</strong>条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockPrevention</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 1: 已获得 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 1: 已获得 lockB。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 两个线程都按相同的顺序（先 A 后 B）获取锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 2: 已获得 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 2: 已获得 lockB。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockPrevention</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockPrevention</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadOne, <span class="string">&quot;Thread-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadTwo, <span class="string">&quot;Thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程池异常"><a href="#线程池异常" class="headerlink" title="线程池异常"></a>线程池异常</h3><p>使用 <code>Future.get()</code> 或在任务中捕获异常来处理线程池中任务抛出的异常。<code>execute()</code> 方法无法直接捕获异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPoolExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交一个会抛出运行时异常的任务</span></span><br><span class="line">        Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;这是一个模拟的任务执行异常。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取任务结果来捕获异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;捕获到任务执行异常：&quot;</span> + e.getCause().getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 execute() 提交任务，异常会被吞掉，除非自定义 UncaughtExceptionHandler</span></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;另一个任务开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;这个异常会被吞掉。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ThreadLocal-1"><a href="#ThreadLocal-1" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p><code>ThreadLocal</code> 为每个线程提供了独立的变量副本，实现了数据隔离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAndPrint</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        threadLocal.set(value); <span class="comment">// 设置当前线程的变量副本</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的变量值: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadLocal.remove(); <span class="comment">// 最佳实践：使用完后移除，防止内存泄漏</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 A 的数据&quot;</span>), <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 B 的数据&quot;</span>), <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a><code>LockSupport</code></h3><p><code>LockSupport.park()</code> 和 <code>LockSupport.unpark()</code> 提供了更灵活的线程阻塞和唤醒机制，类似于 <code>wait()</code> 和 <code>notify()</code>，但不需要依赖锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockSupportDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;工作线程: 任务准备就绪，即将阻塞...&quot;</span>);</span><br><span class="line">            LockSupport.park(); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            System.out.println(<span class="string">&quot;工作线程: 被唤醒，继续执行。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        workerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 确保工作线程已执行 park()</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 唤醒工作线程。&quot;</span>);</span><br><span class="line">        LockSupport.unpark(workerThread); <span class="comment">// 唤醒指定线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程通信-按顺序打印"><a href="#线程通信-按顺序打印" class="headerlink" title="线程通信 (按顺序打印)"></a>线程通信 (按顺序打印)</h3><p>使用 <code>wait()</code> 和 <code>notifyAll()</code> 实现三个线程按顺序打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SequentialPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 0: A, 1: B, 2: C</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String letter, <span class="type">int</span> expectedState)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (state != expectedState) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(letter);</span><br><span class="line">                state = (state + <span class="number">1</span>) % <span class="number">3</span>; <span class="comment">// 切换到下一个状态</span></span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SequentialPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequentialPrinter</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printA);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printB);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printC);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line"></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line">        threadC.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n打印完成。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="ThreadPoolExecutor-的七个参数"><a href="#ThreadPoolExecutor-的七个参数" class="headerlink" title="ThreadPoolExecutor 的七个参数"></a><code>ThreadPoolExecutor</code> 的七个参数</h4><ol>
<li><code>corePoolSize</code>: 核心线程数。线程池中常驻的线程数量，即使空闲也不会被销毁。</li>
<li><code>maximumPoolSize</code>: 最大线程数。当工作队列已满，且任务量继续增加时，线程池可以创建的最大线程数。</li>
<li><code>keepAliveTime</code>: 空闲线程存活时间。当线程数大于 <code>corePoolSize</code> 时，非核心线程的空闲存活时间。</li>
<li><code>unit</code>: <code>keepAliveTime</code> 的时间单位。</li>
<li><code>workQueue</code>: 工作队列。用于存放等待执行的任务，常用的有 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等。</li>
<li><code>threadFactory</code>: 线程工厂。用于创建新线程，可以自定义线程的名称、优先级等。</li>
<li><code>handler</code>: 拒绝策略。当线程池和工作队列都已满时，用于处理新来的任务，例如抛出异常、由调用者执行等。</li>
</ol>
<h4 id="手写一个自定义线程池"><a href="#手写一个自定义线程池" class="headerlink" title="手写一个自定义线程池"></a>手写一个自定义线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">5</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">60L</span>, <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), <span class="comment">// 工作队列容量为 10</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 默认线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略：由调用者线程执行</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 执行。&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>使用 <code>AtomicBoolean</code> 或 <code>AtomicReference</code> 解决并发问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicBooleanDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 确保只有一个线程执行初始化操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 只有当 initialized 为 false 时，才将其设置为 true 并执行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialized.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 开始执行初始化操作...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 初始化完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 初始化已被其他线程执行，跳过。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(AtomicBooleanDemo::initialize, <span class="string">&quot;Thread-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="volatile-内存语义"><a href="#volatile-内存语义" class="headerlink" title="volatile 内存语义"></a><code>volatile</code> 内存语义</h3><p><code>volatile</code> 确保了<strong>可见性</strong>和<strong>有序性</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileMemorySemantics</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 可见性：当一个线程修改了 ready 的值，其他线程能立即看到最新值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriterThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            number = <span class="number">42</span>; <span class="comment">// 修改 number</span></span><br><span class="line">            ready = <span class="literal">true</span>; <span class="comment">// 修改 ready</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="comment">// 等待 ready 变为 true</span></span><br><span class="line">                <span class="comment">// 如果没有 volatile，这里可能会陷入死循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 有序性：写 volatile 变量（ready = true）之前的操作（number = 42）</span></span><br><span class="line">            <span class="comment">// 对其他线程都是可见的。保证了 number 的值是 42。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读取到的 number 值: &quot;</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WriterThread</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="中断机制-1"><a href="#中断机制-1" class="headerlink" title="中断机制"></a>中断机制</h3><p>一个线程通过响应 <code>interrupt()</code> 调用来正确停止自身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptibleThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; <span class="comment">// 检查中断标志</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程正在执行...&quot;</span>);</span><br><span class="line">                    <span class="comment">// sleep()、wait() 等方法会抛出 InterruptedException 并清除中断标志</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程被中断，即将退出...&quot;</span>);</span><br><span class="line">                    <span class="comment">// 重新设置中断标志，以便外层循环能正确退出</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">// 或者直接 break 或 return 退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程已优雅地退出。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        worker.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 发送中断信号。&quot;</span>);</span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h3><p><code>ConcurrentHashMap</code> 的并发原理是**分段锁（ 7）**或 <strong>CAS + Synchronized（ 8）</strong>，只对操作的桶进行锁定，大大提高了并发性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcurrentHashMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 10 个线程，每个线程向 map 中添加 1000 个键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key-&quot;</span> + (threadId * <span class="number">1000</span> + j);</span><br><span class="line">                    map.put(key, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终 map 的大小: &quot;</span> + map.size()); <span class="comment">// 期望值为 10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a><code>ForkJoinPool</code></h3><p><code>ForkJoinPool</code> 是一个用于分治任务的线程池，<code>RecursiveTask</code> 是可返回结果的分治任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 任务分解的阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SumTask</span><span class="params">(<span class="type">long</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务规模小于等于阈值，则直接计算</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，将任务分解成两个子任务</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, start, mid);</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, mid, end);</span><br><span class="line"></span><br><span class="line">            leftTask.fork(); <span class="comment">// 提交左子任务</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.compute(); <span class="comment">// 同步计算右子任务</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join(); <span class="comment">// 等待左子任务结果</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] array = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">1000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br><span class="line">        System.out.println(<span class="string">&quot;大数组的和为: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-语言基础"><a href="#1-语言基础" class="headerlink" title="1.  语言基础"></a>1.  语言基础</h3><h4 id="变量与数据类型"><a href="#变量与数据类型" class="headerlink" title="变量与数据类型"></a>变量与数据类型</h4><p> 的基本数据类型决定了变量可以存储的数据范围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTypesDetailed</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 整数类型：默认为 int</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 占用 1 字节，-128 到 127</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 占用 2 字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100000</span>; <span class="comment">// 占用 4 字节</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">10000000000L</span>; <span class="comment">// 占用 8 字节，需要 L 或 l 后缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浮点类型：默认为 double</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.14f</span>; <span class="comment">// 占用 4 字节，需要 f 或 F 后缀</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.1415926535</span>; <span class="comment">// 占用 8 字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符类型</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 单个字符，占用 2 字节</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">65</span>; <span class="comment">// 也可以使用 ASCII 码或 Unicode</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1 和 c2 是否相等？ &quot;</span> + (c1 == c2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 布尔类型</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFun</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;学Java有趣吗？&quot;</span> + isFun);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p> 中，从小范围类型向大范围类型转换是<strong>自动</strong>的（隐式转换）；从大范围向小范围转换需要<strong>强制</strong>转换（显式转换），可能造成数据丢失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeCasting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 隐式转换：int -&gt; long</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">myInt</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">myLong</span> <span class="operator">=</span> myInt;</span><br><span class="line">        System.out.println(<span class="string">&quot;隐式转换后的 long 类型: &quot;</span> + myLong);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式转换：double -&gt; int</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">myDouble</span> <span class="operator">=</span> <span class="number">9.99</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">myInteger</span> <span class="operator">=</span> (<span class="type">int</span>) myDouble; <span class="comment">// 强制转换，小数部分被丢弃</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显式转换后的 int 类型: &quot;</span> + myInteger); <span class="comment">// 输出 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是存储<strong>固定大小</strong>同类型元素的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明并初始化一个整数数组</span></span><br><span class="line">        <span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 创建一个长度为 5 的数组</span></span><br><span class="line">        numbers[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        numbers[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明、初始化并赋值</span></span><br><span class="line">        String[] fruits = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有水果:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String fruit : fruits) &#123; <span class="comment">// 增强 for 循环</span></span><br><span class="line">            System.out.println(fruit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-面向对象编程-OOP"><a href="#2-面向对象编程-OOP" class="headerlink" title="2. 面向对象编程 (OOP)"></a>2. 面向对象编程 (OOP)</h3><h4 id="构造方法与方法重载"><a href="#构造方法与方法重载" class="headerlink" title="构造方法与方法重载"></a>构造方法与方法重载</h4><p><strong>构造方法</strong>是一种特殊方法，用于创建对象时初始化。<strong>方法重载</strong>是指在同一个类中，方法名相同但参数列表不同（参数类型、数量或顺序）的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;未知&quot;</span>, <span class="number">0</span>, <span class="string">&quot;000&quot;</span>); <span class="comment">// 调用本类的三参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = <span class="string">&quot;000&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法重载: 计算两个数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承、多态与抽象"><a href="#继承、多态与抽象" class="headerlink" title="继承、多态与抽象"></a>继承、多态与抽象</h4><p>继承实现代码复用，多态实现行为多样化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类：抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String brand; <span class="comment">// 子类可以访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vehicle</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;品牌是: &quot;</span> + brand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：继承 Vehicle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汽车正在路上行驶...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：继承 Vehicle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bicycle</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bicycle</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自行车正在骑行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphismDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;BMW&quot;</span>); <span class="comment">// 多态引用</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">myBicycle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bicycle</span>(<span class="string">&quot;Giant&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个方法调用，不同行为</span></span><br><span class="line">        myCar.run(); <span class="comment">// 输出 &quot;汽车正在路上行驶...&quot;</span></span><br><span class="line">        myBicycle.run(); <span class="comment">// 输出 &quot;自行车正在骑行...&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-核心类库"><a href="#3-核心类库" class="headerlink" title="3.  核心类库"></a>3.  核心类库</h3><p>好的，这次我们将把<strong>各种方法的使用代码</strong>直接嵌入到每个知识点的解释中，让您在学习概念的同时，就能看到具体的代码实现和效果。我们将专注于<strong>数组、字符串和集合</strong>这三大核心部分，把它们的创建、遍历、和各种常用方法的代码示例都清晰地展示出来。</p>
<hr>
<h3 id="1-数组（Array）"><a href="#1-数组（Array）" class="headerlink" title="1. 数组（Array）"></a>1. 数组（Array）</h3><p>数组是一种固定大小的、用于存储同类型元素的容器。</p>
<h4 id="创建和遍历"><a href="#创建和遍历" class="headerlink" title="创建和遍历"></a>创建和遍历</h4><p>这里展示两种最常见的创建数组的方式，并使用两种循环进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式一：声明并分配空间，系统赋默认值</span></span><br><span class="line">        <span class="type">int</span>[] intArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">// 创建一个包含3个整数的数组，默认值都是0</span></span><br><span class="line">        intArray[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        intArray[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">        intArray[<span class="number">2</span>] = <span class="number">30</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;数组 intArray 的第一个元素是: &quot;</span> + intArray[<span class="number">0</span>]); <span class="comment">// 输出: 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式二：声明并直接初始化</span></span><br><span class="line">        String[] stringArray = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;Java&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方式一：使用 for 循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 使用 for 循环遍历 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringArray.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stringArray[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + stringArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历方式二：使用增强 for 循环（更简洁）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 使用增强 for 循环遍历 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : stringArray) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;元素: &quot;</span> + element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Arrays-类的常用方法"><a href="#Arrays-类的常用方法" class="headerlink" title="Arrays 类的常用方法"></a><code>Arrays</code> 类的常用方法</h4><p><code>java.util.Arrays</code> 类提供了很多静态方法，方便我们对数组进行操作，比如排序、查找、复制等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysMethodExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 排序：Arrays.sort()</span></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后: &quot;</span> + Arrays.toString(numbers)); <span class="comment">// 输出: [1, 2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 查找：Arrays.binarySearch() (必须先排序)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素 6 的索引是: &quot;</span> + index); <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 填充：Arrays.fill()</span></span><br><span class="line">        <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        Arrays.fill(newArray, <span class="number">99</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;填充后: &quot;</span> + Arrays.toString(newArray)); <span class="comment">// 输出: [99, 99, 99, 99, 99]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 复制：Arrays.copyOf()</span></span><br><span class="line">        <span class="type">int</span>[] copiedArray = Arrays.copyOf(numbers, <span class="number">3</span>); <span class="comment">// 复制前3个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;复制前3个元素: &quot;</span> + Arrays.toString(copiedArray)); <span class="comment">// 输出: [1, 2, 4]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 比较：Arrays.equals()</span></span><br><span class="line">        <span class="type">int</span>[] anotherArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;两个数组是否相等: &quot;</span> + Arrays.equals(numbers, anotherArray)); <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-字符串（String）"><a href="#2-字符串（String）" class="headerlink" title="2. 字符串（String）"></a>2. 字符串（String）</h3><p><code>String</code> 是一个不可变的字符序列，这意味着一旦创建，它的内容就不能被修改。所有修改操作都会返回一个新的 <code>String</code> 对象。</p>
<h4 id="创建和常用方法"><a href="#创建和常用方法" class="headerlink" title="创建和常用方法"></a>创建和常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;  Java is a great language. &quot;</span>; <span class="comment">// 字面量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java is a great language.&quot;</span>); <span class="comment">// 使用 new 关键字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常用方法</span></span><br><span class="line">        <span class="comment">// 1. 获取长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str1.length();</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度: &quot;</span> + length); <span class="comment">// 输出: 29</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 访问字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> str1.charAt(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第3个字符是: &quot;</span> + firstChar); <span class="comment">// 输出: J</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 截取子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> str1.substring(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;截取子串: &quot;</span> + sub); <span class="comment">// 输出: is</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 查找位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str1.indexOf(<span class="string">&quot;great&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&#x27;great&#x27; 的索引: &quot;</span> + index); <span class="comment">// 输出: 11</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 判断</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> str1.contains(<span class="string">&quot;language&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含 &#x27;language&#x27;: &quot;</span> + contains); <span class="comment">// 输出: true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">startsWith</span> <span class="operator">=</span> str1.startsWith(<span class="string">&quot;  Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否以 &#x27;  Java&#x27; 开头: &quot;</span> + startsWith); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 替换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">replacedStr</span> <span class="operator">=</span> str1.replace(<span class="string">&quot;great&quot;</span>, <span class="string">&quot;wonderful&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;替换后: &quot;</span> + replacedStr); <span class="comment">// 输出:   Java is a wonderful language. </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 大小写转换和去空格</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">trimmedStr</span> <span class="operator">=</span> str1.trim();</span><br><span class="line">        System.out.println(<span class="string">&quot;去除首尾空格: &#x27;&quot;</span> + trimmedStr + <span class="string">&quot;&#x27;&quot;</span>); <span class="comment">// 输出: &#x27;Java is a great language.&#x27;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;转为大写: &quot;</span> + trimmedStr.toUpperCase());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 8. 分割和连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line">        String[] fruits = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;分割后: &quot;</span> + Arrays.toString(fruits)); <span class="comment">// 输出: [apple, banana, orange]</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">joinedString</span> <span class="operator">=</span> String.join(<span class="string">&quot; - &quot;</span>, fruits);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接后: &quot;</span> + joinedString); <span class="comment">// 输出: apple - banana - orange</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StringBuilder-和-StringBuffer"><a href="#StringBuilder-和-StringBuffer" class="headerlink" title="StringBuilder 和 StringBuffer"></a><code>StringBuilder</code> 和 <code>StringBuffer</code></h4><p>对于需要频繁修改字符串的场景，应使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 以提高性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 追加内容</span></span><br><span class="line">        sb.append(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;追加后: &quot;</span> + sb); <span class="comment">// 输出: Hello World</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 插入内容</span></span><br><span class="line">        sb.insert(<span class="number">6</span>, <span class="string">&quot;Beautiful &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;插入后: &quot;</span> + sb); <span class="comment">// 输出: Hello Beautiful World</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 删除内容</span></span><br><span class="line">        sb.delete(<span class="number">6</span>, <span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + sb); <span class="comment">// 输出: Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-集合（Collections）"><a href="#3-集合（Collections）" class="headerlink" title="3. 集合（Collections）"></a>3. 集合（Collections）</h3><p>Java 集合框架提供了强大的数据结构来存储和操作对象。</p>
<h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a><strong>List</strong>（列表）</h4><p><code>List</code> 是一种有序、可重复的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 ArrayList（查询快）</span></span><br><span class="line">        List&lt;String&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        fruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 添加元素</span></span><br><span class="line">        fruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        fruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 允许重复</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;列表元素: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Banana, Apple]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个元素: &quot;</span> + fruits.get(<span class="number">0</span>)); <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;列表大小: &quot;</span> + fruits.size());</span><br><span class="line"></span><br><span class="line">        fruits.set(<span class="number">1</span>, <span class="string">&quot;Grape&quot;</span>); <span class="comment">// 替换第二个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;替换后: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Grape, Apple]</span></span><br><span class="line"></span><br><span class="line">        fruits.remove(<span class="number">1</span>); <span class="comment">// 删除第二个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Apple]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Set（集）"><a href="#Set（集）" class="headerlink" title="Set（集）"></a><strong>Set</strong>（集）</h4><p><code>Set</code> 是一种无序、不可重复的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashSet</span></span><br><span class="line">        Set&lt;String&gt; uniqueFruits = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 添加重复元素，会失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;集合元素: &quot;</span> + uniqueFruits); <span class="comment">// 输出: [Apple, Banana] (顺序不定)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">containsBanana</span> <span class="operator">=</span> uniqueFruits.contains(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含 &#x27;Banana&#x27;: &quot;</span> + containsBanana); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">        uniqueFruits.remove(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + uniqueFruits); <span class="comment">// 输出: [Apple]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Map（映射）"><a href="#Map（映射）" class="headerlink" title="Map（映射）"></a><strong>Map</strong>（映射）</h4><p><code>Map</code> 存储键值对，键是唯一的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap</span></span><br><span class="line">        Map&lt;String, Integer&gt; studentScores = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        studentScores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">95</span>); <span class="comment">// 添加键值对</span></span><br><span class="line">        studentScores.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">88</span>);</span><br><span class="line">        studentScores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">100</span>); <span class="comment">// 键已存在，会覆盖旧值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Alice 的分数: &quot;</span> + studentScores.get(<span class="string">&quot;Alice&quot;</span>)); <span class="comment">// 输出: 100</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历 Map 的三种方式</span></span><br><span class="line">        <span class="comment">// 方式一：遍历键集</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历键集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : studentScores.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名: &quot;</span> + name + <span class="string">&quot;, 分数: &quot;</span> + studentScores.get(name));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式二：遍历值集</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历值集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer score : studentScores.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分数: &quot;</span> + score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式三：遍历键值对集 (Entry Set)，最常用且高效</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历键值对集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : studentScores.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名: &quot;</span> + entry.getKey() + <span class="string">&quot;, 分数: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/11/8.21%E5%AD%A6%E4%BC%9A/" data-id="cmffake6j000050uy7grd0zwl" data-title="8.21学会" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo-Markdown/" rel="tag">Hexo, Markdown</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-web" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/11/web/" class="article-date">
  <time class="dt-published" datetime="2025-09-11T10:29:28.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/11/web/">web</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>好的，让我们深入到 HTTP 协议的底层，全面解剖它的工作原理、请求-响应模型、以及各个组成部分。</p>
<hr>
<h3 id="一、HTTP-协议概述"><a href="#一、HTTP-协议概述" class="headerlink" title="一、HTTP 协议概述"></a>一、HTTP 协议概述</h3><p>HTTP（Hypertext Transfer Protocol，超文本传输协议）是应用层协议，它定义了 Web 客户端（如浏览器）和 Web 服务器之间交换数据的规则。它的核心特点是<strong>无状态（Stateless）</strong>，这意味着服务器不会保存客户端的任何信息，每次请求都是独立的。</p>
<hr>
<h3 id="二、HTTP-请求（Request）"><a href="#二、HTTP-请求（Request）" class="headerlink" title="二、HTTP 请求（Request）"></a>二、HTTP 请求（Request）</h3><p>一个完整的 HTTP 请求由四部分组成：</p>
<h4 id="1-请求行（Request-Line）"><a href="#1-请求行（Request-Line）" class="headerlink" title="1. 请求行（Request Line）"></a>1. 请求行（Request Line）</h4><p>这是请求的第一行，它定义了请求的基本信息。</p>
<ul>
<li><strong>请求方法（Method）</strong>：如 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 等，表示对资源的操作类型。</li>
<li><strong>请求 URL (URI)</strong>：资源的地址。</li>
<li><strong>HTTP 协议版本</strong>：如 <code>HTTP/1.1</code>, <code>HTTP/2.0</code>。</li>
</ul>
<p>示例：</p>
<p>GET &#x2F;index.html HTTP&#x2F;1.1</p>
<h4 id="2-请求头（Request-Headers）"><a href="#2-请求头（Request-Headers）" class="headerlink" title="2. 请求头（Request Headers）"></a>2. 请求头（Request Headers）</h4><p>请求头提供了关于客户端、请求体和一些其他元数据的信息。它们以键值对的形式存在。</p>
<ul>
<li><strong>Host</strong>：指定请求的目标服务器的域名和端口号。</li>
<li><strong>User-Agent</strong>：客户端的软件类型和版本，如浏览器信息。</li>
<li><strong>Accept</strong>：客户端能够处理的媒体类型，告诉服务器希望返回什么格式的数据（如 <code>application/json</code>, <code>text/html</code>）。</li>
<li><strong>Content-Type</strong>：<strong>请求体</strong>中的数据类型，只在有请求体时使用（如 <code>POST</code>）。常见的有：<ul>
<li><code>application/x-www-form-urlencoded</code>：默认编码，用于提交表单数据。</li>
<li><code>multipart/form-data</code>：用于上传文件。</li>
<li><code>application/json</code>：用于前后端分离，提交 JSON 数据。</li>
</ul>
</li>
<li><strong>Content-Length</strong>：请求体的长度（字节）。</li>
<li><strong>Cookie</strong>：客户端存储的 Cookie 信息，用于会话管理。</li>
<li><strong>Authorization</strong>：用于身份认证，如携带 Bearer Token。</li>
<li><strong>Referer</strong>：请求从哪个页面跳转而来。</li>
</ul>
<h4 id="3-空行"><a href="#3-空行" class="headerlink" title="3. 空行"></a>3. 空行</h4><p>一个空行用于分隔请求头和请求体。</p>
<h4 id="4-请求体（Request-Body）"><a href="#4-请求体（Request-Body）" class="headerlink" title="4. 请求体（Request Body）"></a>4. 请求体（Request Body）</h4><p>请求体包含客户端提交给服务器的数据，通常用于 <code>POST</code>、<code>PUT</code> 等请求。GET 请求通常没有请求体。</p>
<hr>
<h3 id="三、HTTP-响应（Response）"><a href="#三、HTTP-响应（Response）" class="headerlink" title="三、HTTP 响应（Response）"></a>三、HTTP 响应（Response）</h3><p>一个完整的 HTTP 响应由三部分组成：</p>
<h4 id="1-状态行（Status-Line）"><a href="#1-状态行（Status-Line）" class="headerlink" title="1. 状态行（Status Line）"></a>1. 状态行（Status Line）</h4><p>这是响应的第一行，定义了响应的基本信息。</p>
<ul>
<li><strong>HTTP 协议版本</strong>：如 <code>HTTP/1.1</code>。</li>
<li><strong>状态码（Status Code）</strong>：三位数字，表示请求结果。</li>
<li><strong>状态信息（Reason Phrase）</strong>：对状态码的简短描述。</li>
</ul>
<p>示例：</p>
<p>HTTP&#x2F;1.1 200 OK</p>
<h4 id="2-响应头（Response-Headers）"><a href="#2-响应头（Response-Headers）" class="headerlink" title="2. 响应头（Response Headers）"></a>2. 响应头（Response Headers）</h4><p>响应头提供了关于服务器、响应体和会话的元数据信息。</p>
<ul>
<li><strong>Content-Type</strong>：<strong>响应体</strong>的数据类型。</li>
<li><strong>Content-Length</strong>：响应体的长度。</li>
<li><strong>Set-Cookie</strong>：服务器向客户端发送 Cookie，用于存储会话 ID 等信息。</li>
<li><strong>Location</strong>：用于重定向，指定新的 URL。</li>
<li><strong>Cache-Control</strong>：控制浏览器缓存行为。</li>
</ul>
<h4 id="3-空行-1"><a href="#3-空行-1" class="headerlink" title="3. 空行"></a>3. 空行</h4><p>一个空行用于分隔响应头和响应体。</p>
<h4 id="4-响应体（Response-Body）"><a href="#4-响应体（Response-Body）" class="headerlink" title="4. 响应体（Response Body）"></a>4. 响应体（Response Body）</h4><p>响应体包含了服务器返回给客户端的实际数据，如 HTML 网页内容、JSON 数据或图片等。</p>
<hr>
<h3 id="四、HTTP-方法的幂等性与安全性"><a href="#四、HTTP-方法的幂等性与安全性" class="headerlink" title="四、HTTP 方法的幂等性与安全性"></a>四、HTTP 方法的幂等性与安全性</h3><ul>
<li><strong>安全性</strong>：指请求方法不会对服务器上的资源状态产生修改。<code>GET</code> 和 <code>HEAD</code> 方法是安全的。</li>
<li><strong>幂等性</strong>：指请求方法重复执行多次，对服务器上的资源状态产生的影响与执行一次的影响相同。<ul>
<li><strong>幂等方法</strong>：<code>GET</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>。</li>
<li><strong>非幂等方法</strong>：<code>POST</code>。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>安全性</th>
<th>幂等性</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>GET</strong></td>
<td>是</td>
<td>是</td>
<td>获取资源</td>
</tr>
<tr>
<td><strong>POST</strong></td>
<td>否</td>
<td>否</td>
<td>创建资源</td>
</tr>
<tr>
<td><strong>PUT</strong></td>
<td>否</td>
<td>是</td>
<td>更新或替换资源</td>
</tr>
<tr>
<td><strong>DELETE</strong></td>
<td>否</td>
<td>是</td>
<td>删除资源</td>
</tr>
</tbody></table>
<hr>
<h3 id="五、HTTP-的会话管理：Cookie"><a href="#五、HTTP-的会话管理：Cookie" class="headerlink" title="五、HTTP 的会话管理：Cookie"></a>五、HTTP 的会话管理：Cookie</h3><p>HTTP 本身是无状态的，但为了跟踪用户，引入了 Cookie。</p>
<ol>
<li><strong>创建</strong>：服务器通过响应头 <code>Set-Cookie</code> 向客户端发送一个 Cookie。</li>
<li><strong>存储</strong>：浏览器接收到 <code>Set-Cookie</code> 后，会将其存储在本地。</li>
<li><strong>携带</strong>：之后，每次对同一域名发起请求时，浏览器都会自动在请求头 <code>Cookie</code> 中带上这个 Cookie。</li>
</ol>
<p>通过在 Cookie 中存储一个 SessionID，服务器就可以在后续请求中找到对应的会话数据，从而实现状态管理。</p>
<hr>
<h3 id="六、HTTP-1-1-与-HTTP-2-的区别"><a href="#六、HTTP-1-1-与-HTTP-2-的区别" class="headerlink" title="六、HTTP&#x2F;1.1 与 HTTP&#x2F;2 的区别"></a>六、HTTP&#x2F;1.1 与 HTTP&#x2F;2 的区别</h3><ul>
<li><strong>多路复用（Multiplexing）</strong>：HTTP&#x2F;2 允许在<strong>一个 TCP 连接</strong>上同时发送多个请求和响应，解决了 HTTP&#x2F;1.1 队头阻塞的问题，显著提高了性能。</li>
<li><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;2 使用 HPACK 算法压缩请求和响应头，减少了数据传输量。</li>
<li><strong>服务器推送（Server Push）</strong>：服务器可以在客户端请求一个资源时，主动推送其他它认为客户端可能需要的资源，减少了客户端的请求次数。</li>
<li><strong>二进制分帧（Binary Framing）</strong>：HTTP&#x2F;2 将所有传输信息分割成更小的消息和帧，并采用二进制编码，使得解析更高效。</li>
</ul>
<p>好的，我们来详细补充 <strong>HTTP&#x2F;1.0</strong> 的核心概念，并对整个 HTTP 协议族进行全面的对比和深入解析。</p>
<hr>
<h3 id="一、HTTP-协议族演变：从-1-0-到-2-0"><a href="#一、HTTP-协议族演变：从-1-0-到-2-0" class="headerlink" title="一、HTTP 协议族演变：从 1.0 到 2.0"></a>一、HTTP 协议族演变：从 1.0 到 2.0</h3><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h4><p>HTTP&#x2F;1.0 是 HTTP 协议的早期版本，它的设计相对简单，主要用于满足基本的网页浏览需求。</p>
<ul>
<li><strong>核心特点：</strong><ul>
<li><strong>非持久连接（Non-persistent Connection）</strong>：这是 HTTP&#x2F;1.0 最显著的特点。每进行一次 HTTP 请求-响应，客户端和服务器之间就会建立一个新的 <strong>TCP 连接</strong>，并在请求完成后立即断开。<ul>
<li><strong>缺点</strong>：每次请求都需要经过 TCP 三次握手和四次挥手的过程，这带来了巨大的性能开销。如果一个网页包含多个图片、CSS 或 JavaScript 文件，浏览器需要为每个文件单独建立和断开连接，导致页面加载速度慢。</li>
</ul>
</li>
<li><strong>无主机头（No Host Header）</strong>：请求头中没有 <code>Host</code> 字段。这意味着一个 IP 地址只能对应一个域名。如果服务器上有多个网站，就无法通过 IP 地址来区分它们，这在虚拟主机时代是个大问题。</li>
<li><strong>不支持管线化（Pipelining）</strong>：客户端发送一个请求后，必须等待服务器的响应，才能发送下一个请求。</li>
</ul>
</li>
</ul>
<h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h4><p>HTTP&#x2F;1.1 协议是对 1.0 的重大改进，解决了其大部分性能瓶颈。</p>
<ul>
<li><strong>核心特点：</strong><ul>
<li><strong>持久连接（Persistent Connection）</strong>：默认情况下，HTTP&#x2F;1.1 会在一次请求-响应之后<strong>保持 TCP 连接不断开</strong>。客户端可以继续在这个连接上发送后续请求。<ul>
<li><strong>优点</strong>：显著减少了 TCP 连接的建立和断开开销，提高了页面加载速度。这个特性也称为“Keep-Alive”。</li>
</ul>
</li>
<li><strong>支持主机头（Host Header）</strong>：请求头中引入了 <code>Host</code> 字段，允许在同一个 IP 地址上部署多个虚拟主机（域名）。</li>
<li><strong>支持管线化（Pipelining）</strong>：客户端可以在收到上一个响应之前，连续发送多个请求。<ul>
<li><strong>缺点</strong>：虽然提高了效率，但存在**队头阻塞（Head-of-Line Blocking）**问题。如果第一个请求处理时间很长，后面的请求即使已经处理完成，也必须等待它的响应，导致整个连接的效率降低。</li>
</ul>
</li>
<li><strong>引入缓存机制</strong>：通过 <code>Cache-Control</code>, <code>ETag</code>, <code>If-None-Match</code> 等请求头，HTTP&#x2F;1.1 提供了更完善的缓存机制，减少了不必要的请求。</li>
</ul>
</li>
</ul>
<h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h4><p>HTTP&#x2F;2.0 是为了解决 HTTP&#x2F;1.1 在移动互联网和高并发场景下的性能问题而设计的。它不是对 HTTP&#x2F;1.1 的简单升级，而是对协议底层进行了重构。</p>
<ul>
<li><strong>核心特点：</strong><ul>
<li><strong>多路复用（Multiplexing）</strong>：这是 HTTP&#x2F;2 的核心。它允许在<strong>一个 TCP 连接</strong>上同时处理多个 HTTP 请求和响应。<ul>
<li><strong>如何实现？</strong>：HTTP&#x2F;2 将所有数据流（Stream）分割成更小的二进制帧（Frame），每个帧都带有唯一的标识符。这样，客户端和服务器可以在同一个连接上交错发送和接收帧，然后根据标识符重新组装，从而彻底解决了 HTTP&#x2F;1.1 的队头阻塞问题。</li>
</ul>
</li>
<li><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;2 使用 HPACK 算法来压缩请求和响应头，尤其是对于重复发送的字段，大大减少了数据传输量。</li>
<li><strong>服务器推送（Server Push）</strong>：服务器可以在客户端请求一个资源（如 HTML 页面）时，主动推送其他它认为客户端可能需要的资源（如 CSS 和 JS 文件），而无需客户端显式请求，进一步提高了加载速度。</li>
<li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议，而不是文本协议，解析更高效、更不容易出错。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、HTTP-协议版本对比总结"><a href="#二、HTTP-协议版本对比总结" class="headerlink" title="二、HTTP 协议版本对比总结"></a>二、HTTP 协议版本对比总结</h3><p>理解 HTTP 协议的演变历程，能让你更深刻地体会到 Web 性能优化的方向，以及现代 Web 框架如何利用这些底层协议特性来提供更高效的服务。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>HTTP&#x2F;1.0</th>
<th>HTTP&#x2F;1.1</th>
<th>HTTP&#x2F;2.0</th>
</tr>
</thead>
<tbody><tr>
<td><strong>TCP 连接</strong></td>
<td>非持久连接</td>
<td>默认持久连接</td>
<td>单个 TCP 连接多路复用</td>
</tr>
<tr>
<td><strong>性能瓶颈</strong></td>
<td>多次握手挥手开销</td>
<td>队头阻塞</td>
<td>无</td>
</tr>
<tr>
<td><strong>主机头</strong></td>
<td>不支持</td>
<td>支持 (<code>Host</code> Header)</td>
<td>支持</td>
</tr>
<tr>
<td><strong>并发请求</strong></td>
<td>串行（一个请求一个连接）</td>
<td>串行（一个连接一个请求）</td>
<td>并行（一个连接多个请求）</td>
</tr>
<tr>
<td><strong>数据格式</strong></td>
<td>文本协议</td>
<td>文本协议</td>
<td>二进制协议</td>
</tr>
<tr>
<td><strong>头部</strong></td>
<td>无压缩</td>
<td>无压缩</td>
<td>HPACK 算法压缩</td>
</tr>
<tr>
<td><strong>服务器推送</strong></td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>好的，让我们把所有关于 Servlet 的知识点整合在一起，进行一次最全面、最深入的剖析。我们将从基础概念开始，逐步深入到它的生命周期、配置、核心方法以及与 Servlet 规范相关的其他重要组件。</p>
<hr>
<h3 id="Servlet-概述：Java-Web-的核心基石"><a href="#Servlet-概述：Java-Web-的核心基石" class="headerlink" title="Servlet 概述：Java Web 的核心基石"></a>Servlet 概述：Java Web 的核心基石</h3><p><strong>Servlet</strong> 是 Java EE 规范中的一个核心组件，它是一个运行在服务器端的 Java 程序，用于处理 HTTP 请求和生成动态响应。你可以把它看作是所有 Java Web 框架（如 Spring MVC）的底层引擎。</p>
<p><strong>它的核心作用</strong>是作为客户端（浏览器）和 Java 应用程序之间的“桥梁”。Servlet 容器（如 Tomcat、Jetty）负责监听网络请求，然后将请求分发给相应的 Servlet 进行处理。</p>
<h3 id="Servlet-的生命周期：由容器严格管理"><a href="#Servlet-的生命周期：由容器严格管理" class="headerlink" title="Servlet 的生命周期：由容器严格管理"></a>Servlet 的生命周期：由容器严格管理</h3><p>一个 Servlet 的生命周期由 Servlet 容器严格管理，通常分为三个阶段：</p>
<ol>
<li><strong>初始化（Initialization）</strong><ul>
<li><strong>时机</strong>：当 Servlet 容器第一次加载 Servlet 类并创建其实例后，立即调用 <code>init()</code> 方法。</li>
<li><strong>特性</strong>：这个方法<strong>只执行一次</strong>，通常用于加载配置文件、建立数据库连接池等一次性、耗时的任务。如果 <code>init()</code> 方法抛出异常，Servlet 将无法提供服务。</li>
</ul>
</li>
<li><strong>服务（Servicing）</strong><ul>
<li><strong>时机</strong>：每当一个客户端请求到达时，容器会为该请求创建一个新的线程，并调用 <code>service()</code> 方法。</li>
<li><strong>特性</strong>：<code>service()</code> 方法是 Servlet 的核心，它会根据请求类型（如 GET、POST）自动调用相应的 <code>doGet()</code>、<code>doPost()</code> 等方法。由于此方法会被多个线程并发调用，因此访问共享资源时必须注意<strong>线程安全</strong>。</li>
</ul>
</li>
<li><strong>销毁（Destruction）</strong><ul>
<li><strong>时机</strong>：当 Servlet 容器关闭或决定卸载某个 Servlet 时，会调用其 <code>destroy()</code> 方法。</li>
<li><strong>特性</strong>：这个方法也<strong>只执行一次</strong>，用于释放资源，如关闭数据库连接或文件流。</li>
</ul>
</li>
</ol>
<h3 id="Servlet-的配置和部署：两种主要方式"><a href="#Servlet-的配置和部署：两种主要方式" class="headerlink" title="Servlet 的配置和部署：两种主要方式"></a>Servlet 的配置和部署：两种主要方式</h3><p>为了让容器知道如何加载和映射 Servlet，你需要进行配置。</p>
<ol>
<li><strong>web.xml 配置（传统方式）</strong><ul>
<li>在 <code>web.xml</code> 文件中，使用 <code>&lt;servlet&gt;</code> 标签定义 Servlet 类，并使用 <code>&lt;servlet-mapping&gt;</code> 标签将它映射到一个 URL 路径。</li>
<li><strong>优点</strong>：配置集中，易于管理。</li>
<li><strong>缺点</strong>：如果 Servlet 很多，<code>web.xml</code> 文件会变得非常庞大。</li>
</ul>
</li>
<li><strong>注解配置（现代方式）</strong><ul>
<li>从 Servlet 3.0 规范开始，你可以使用 <code>@WebServlet</code> 注解来简化配置。只需在你的 Servlet 类上添加 <code>@WebServlet(&quot;/path&quot;)</code> 注解，容器就会自动识别和配置它。</li>
<li><strong>优点</strong>：配置简单，代码和配置在一起，提高了可读性。</li>
</ul>
</li>
</ol>
<h3 id="Servlet-的核心方法：处理请求和响应"><a href="#Servlet-的核心方法：处理请求和响应" class="headerlink" title="Servlet 的核心方法：处理请求和响应"></a>Servlet 的核心方法：处理请求和响应</h3><p>所有 Servlet 都应该实现 <code>javax.servlet.Servlet</code> 接口。通常，我们更常继承 <code>javax.servlet.http.HttpServlet</code>，因为它提供了更方便的 HTTP 请求处理方法。</p>
<ul>
<li><code>service(HttpServletRequest req, HttpServletResponse res)</code>：这是核心服务方法，由容器调用。它会根据请求的 HTTP 方法（GET、POST、PUT 等）来调用相应的 <code>doGet()</code>、<code>doPost()</code> 等方法。</li>
<li><code>doGet(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 GET 请求。</li>
<li><code>doPost(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 POST 请求。</li>
<li><code>doPut(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 PUT 请求。</li>
<li><code>doDelete(HttpServletRequest req, HttpServletResponse res)</code>：处理所有 DELETE 请求。</li>
</ul>
<p>在这些方法中，你可以通过 <code>req</code> (请求) 和 <code>res</code> (响应) 对象来与客户端进行交互。</p>
<h3 id="Servlet-的请求和响应处理：与客户端交互"><a href="#Servlet-的请求和响应处理：与客户端交互" class="headerlink" title="Servlet 的请求和响应处理：与客户端交互"></a>Servlet 的请求和响应处理：与客户端交互</h3><ul>
<li><strong>获取请求参数</strong><ul>
<li><code>req.getParameter(&quot;paramName&quot;)</code>：获取单个参数值。</li>
<li><code>req.getParameterValues(&quot;paramName&quot;)</code>：获取具有相同名称的多个参数值（如复选框）。</li>
</ul>
</li>
<li><strong>设置响应头</strong><ul>
<li><code>res.setContentType(&quot;text/html;charset=UTF-8&quot;)</code>：设置响应的内容类型和字符编码。</li>
<li><code>res.setHeader(&quot;HeaderName&quot;, &quot;HeaderValue&quot;)</code>：设置自定义响应头。</li>
</ul>
</li>
<li><strong>写入响应内容</strong><ul>
<li><code>res.getWriter()</code>：获取一个 <code>PrintWriter</code>，用于向客户端发送文本响应。</li>
<li><code>res.getOutputStream()</code>：获取一个 <code>ServletOutputStream</code>，用于向客户端发送二进制响应（如图片、文件）。</li>
</ul>
</li>
</ul>
<h3 id="Servlet-的核心组件与作用域"><a href="#Servlet-的核心组件与作用域" class="headerlink" title="Servlet 的核心组件与作用域"></a>Servlet 的核心组件与作用域</h3><p>理解 Servlet 规范中的这些组件，能帮助你更合理地管理数据和资源。</p>
<ol>
<li><strong>ServletContext (应用上下文)</strong><ul>
<li><strong>作用</strong>：代表整个 Web 应用，它的生命周期与应用相同。</li>
<li><strong>作用域</strong>：数据在所有 Servlet、JSP 和 Filter 之间<strong>共享</strong>。</li>
<li><strong>用途</strong>：存储全局配置和共享数据。</li>
</ul>
</li>
<li><strong>ServletConfig (配置对象)</strong><ul>
<li><strong>作用</strong>：代表一个 Servlet 独有的配置。</li>
<li><strong>作用域</strong>：仅在它所关联的 Servlet 内部有效。</li>
<li><strong>用途</strong>：获取特定 Servlet 的初始化参数。</li>
</ul>
</li>
<li><strong>四大作用域</strong><ul>
<li><strong>PageContext (页面作用域)</strong>：仅在 JSP 页面内有效。</li>
<li><strong>HttpServletRequest (请求作用域)</strong>：在一次完整的请求-响应周期内有效，即使请求被转发，数据依然可见。</li>
<li><strong>HttpSession (会话作用域)</strong>：在同一个浏览器会话中有效，用于存储用户特定数据。</li>
<li><strong>ServletContext (应用作用域)</strong>：在整个 Web 应用中都有效，用于存储全局数据。</li>
</ul>
</li>
</ol>
<p>好的，我们来详细、深入地聊聊 Web 开发中至关重要的两个概念：Cookie 和 Session。它们是解决 HTTP 无状态问题的核心方案，但工作机制和应用场景却大不相同。</p>
<hr>
<h3 id="Cookie：客户端的“小纸条”"><a href="#Cookie：客户端的“小纸条”" class="headerlink" title="Cookie：客户端的“小纸条”"></a>Cookie：客户端的“小纸条”</h3><p><strong>Cookie</strong> 是服务器发送给浏览器并存储在客户端的一小段文本信息。浏览器在下次访问同一服务器时，会自动将该 Cookie 包含在请求中发送回去。</p>
<h4 id="核心工作机制"><a href="#核心工作机制" class="headerlink" title="核心工作机制"></a>核心工作机制</h4><ol>
<li><p>服务器创建 Cookie：</p>
<p>当用户首次访问网站时，服务器在响应头（Response Header）中添加一个 Set-Cookie 字段。</p>
<p>比如：Set-Cookie: JSESSIONID&#x3D;abcde12345; Path&#x3D;&#x2F;; HttpOnly</p>
</li>
<li><p>浏览器保存 Cookie：</p>
<p>浏览器接收到响应后，会解析 Set-Cookie 头，并将该信息以键值对的形式存储在本地。</p>
</li>
<li><p>浏览器发送 Cookie：</p>
<p>在后续的请求中，只要请求的域名和路径与 Cookie 的设置相符，浏览器就会自动在请求头（Request Header）中添加 Cookie 字段，将存储的 Cookie 信息发送给服务器。</p>
<p>比如：Cookie: JSESSIONID&#x3D;abcde12345</p>
</li>
</ol>
<h4 id="Cookie-的优缺点"><a href="#Cookie-的优缺点" class="headerlink" title="Cookie 的优缺点"></a>Cookie 的优缺点</h4><ul>
<li><strong>优点</strong>：<ul>
<li><strong>减轻服务器压力</strong>：数据存储在客户端，服务器不需要为每个用户维护状态，适用于大规模访问。</li>
<li><strong>可扩展性强</strong>：无状态，天然适合分布式架构。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>安全性差</strong>：数据以明文形式存储，容易被窃取和篡改。</li>
<li><strong>容量限制</strong>：单个 Cookie 的大小通常不超过 4KB，且一个域名下的 Cookie 总数也有限制。</li>
<li><strong>用户可禁用</strong>：如果用户禁用了浏览器 Cookie 功能，相关功能将无法使用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Session：服务器的“个人档案”"><a href="#Session：服务器的“个人档案”" class="headerlink" title="Session：服务器的“个人档案”"></a>Session：服务器的“个人档案”</h3><p><strong>Session</strong> 是服务器为每个用户创建的一个对象，用于存储特定用户的会话数据。它将用户的状态信息保存在服务器端，并通过一个唯一的 <strong>Session ID</strong> 来识别不同的用户。</p>
<h4 id="核心工作机制-1"><a href="#核心工作机制-1" class="headerlink" title="核心工作机制"></a>核心工作机制</h4><ol>
<li><p>服务器创建 Session：</p>
<p>当用户首次访问 Web 应用时，服务器会创建一个 HttpSession 对象，并为其分配一个唯一的 Session ID。</p>
</li>
<li><p>传递 Session ID：</p>
<p>服务器将这个 Session ID 以 Cookie 的形式发送给浏览器（这个 Cookie 通常叫 JSESSIONID）。</p>
<ul>
<li>如果浏览器禁用了 Cookie，服务器可以通过 <strong>URL 重写</strong>的方式，将 Session ID 附加到每个 URL 的末尾，例如：<code>.../index.jsp;jsessionid=abcde12345</code>。</li>
</ul>
</li>
<li><p>服务器维护 Session：</p>
<p>Session ID 传递到客户端后，服务器会在内存中或持久化存储中保存这个 HttpSession 对象及其数据。</p>
</li>
<li><p>识别用户：</p>
<p>后续的请求中，浏览器都会带着包含 Session ID 的 Cookie。服务器通过这个 ID 就能从内存中找到对应的 HttpSession 对象，从而获取该用户的状态信息。</p>
</li>
</ol>
<h4 id="Session-的优缺点"><a href="#Session-的优缺点" class="headerlink" title="Session 的优缺点"></a>Session 的优缺点</h4><ul>
<li><strong>优点</strong>：<ul>
<li><strong>安全性高</strong>：核心数据存储在服务器，客户端只传递一个无法猜解的 ID。</li>
<li><strong>容量大</strong>：存储在服务器，理论上没有大小限制。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>占用服务器资源</strong>：每个活跃的 Session 都会占用服务器内存，在高并发场景下可能成为瓶颈。</li>
<li><strong>分布式挑战</strong>：在多台服务器组成的集群环境中，需要额外的机制（如 Session 共享或粘性会话）来确保用户的请求总是被转发到同一个 Session 所在的服务器，或者所有服务器都能访问到 Session 数据。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Cookie-与-Session-的对比总结"><a href="#Cookie-与-Session-的对比总结" class="headerlink" title="Cookie 与 Session 的对比总结"></a>Cookie 与 Session 的对比总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据存储位置</strong></td>
<td>客户端（浏览器）</td>
<td>服务器端</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>较低，易被篡改</td>
<td>较高，数据安全</td>
</tr>
<tr>
<td><strong>数据容量</strong></td>
<td>较小（~4KB）</td>
<td>较大，无明显限制</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>轻量，不占用服务器资源</td>
<td>占用服务器内存，可能影响性能</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td>天然无状态，易于扩展</td>
<td>分布式环境下需要额外配置</td>
</tr>
<tr>
<td><strong>主要用途</strong></td>
<td>购物车、用户偏好、轻量级状态</td>
<td>登录状态、权限验证、敏感数据</td>
</tr>
</tbody></table>
<p>好的，我已将 GET 和 POST 请求的所有核心区别整理成一个简洁明了的表格，并补充了更多细节，使其更全面。</p>
<h3 id="GET-和-POST-请求的全面对比"><a href="#GET-和-POST-请求的全面对比" class="headerlink" title="GET 和 POST 请求的全面对比"></a>GET 和 POST 请求的全面对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>GET 请求</th>
<th>POST 请求</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基本作用</strong></td>
<td>从服务器<strong>获取</strong>资源</td>
<td>向服务器<strong>提交</strong>数据，通常用于<strong>创建</strong>资源。</td>
<td>语义不同是所有区别的根本。</td>
</tr>
<tr>
<td><strong>传参方式</strong></td>
<td>参数附加在 URL 中</td>
<td>参数放在请求体（Request Body）中</td>
<td>GET 参数可见，POST 参数隐藏。</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td><strong>不安全</strong>，URL 暴露</td>
<td><strong>相对安全</strong>，参数隐藏在请求体中</td>
<td>这里的“安全”指数据不被暴露。</td>
</tr>
<tr>
<td><strong>幂等性</strong></td>
<td><strong>是</strong>（多次执行结果相同）</td>
<td><strong>否</strong>（多次执行可能产生新资源）</td>
<td>幂等性是 RESTful 设计的关键原则。</td>
</tr>
<tr>
<td><strong>浏览器行为</strong></td>
<td>回退无害，可被记录在历史、收藏为书签。</td>
<td>回退时通常会提示重新提交，不记录在历史、不可收藏。</td>
<td>防止意外提交导致数据重复。</td>
</tr>
<tr>
<td><strong>缓存</strong></td>
<td><strong>可以被缓存</strong></td>
<td><strong>不会被缓存</strong></td>
<td>缓存能提高性能，但仅限于只读操作。</td>
</tr>
<tr>
<td><strong>传输数据量</strong></td>
<td>有长度限制（URL长度限制）</td>
<td>无长度限制（取决于服务器配置）</td>
<td>GET 不适合传输大量数据。</td>
</tr>
<tr>
<td><strong>数据编码</strong></td>
<td>只支持 URL 编码</td>
<td>支持多种编码（如<code>application/json</code>）</td>
<td>POST 灵活性高，适合各种数据类型。</td>
</tr>
<tr>
<td><strong>发送文件</strong></td>
<td>不支持</td>
<td>支持 (<code>multipart/form-data</code>)</td>
<td>文件必须通过请求体传输。</td>
</tr>
<tr>
<td><strong>HTTP 报文</strong></td>
<td>无请求体</td>
<td>有请求体</td>
<td>GET 请求报文更小，更轻量。</td>
</tr>
<tr>
<td><strong>TCP&#x2F;IP 协议</strong></td>
<td>一次性发送所有数据包</td>
<td>浏览器通常会先发送请求头，服务器响应 100-continue 后再发送请求体</td>
<td>POST 的分步发送机制可以避免发送不必要的数据。</td>
</tr>
</tbody></table>
<p>好的，我们将以 Servlet 的详细剖析方式，全面、深入地介绍 WebSocket。我们将从它的概念、生命周期、核心 API，到它与 HTTP 的区别以及在现代 Web 中的应用，进行系统性的梳理。</p>
<hr>
<h3 id="WebSocket-概述：Web-通信的革命"><a href="#WebSocket-概述：Web-通信的革命" class="headerlink" title="WebSocket 概述：Web 通信的革命"></a>WebSocket 概述：Web 通信的革命</h3><p><strong>WebSocket</strong> 协议是 HTML5 开始提供的一种在单个 TCP 连接上进行<strong>全双工通信</strong>的协议。与传统的 HTTP 协议不同，它打破了请求-响应的单向模式，使得客户端和服务器可以<strong>实时地双向自由传输数据</strong>。</p>
<p><strong>它的核心作用</strong>是解决 Web 应用中<strong>实时通信</strong>的需求，例如：聊天应用、在线游戏、股票行情、实时协作工具等。它极大地减少了网络开销，提高了通信效率。</p>
<h3 id="WebSocket-的核心工作原理"><a href="#WebSocket-的核心工作原理" class="headerlink" title="WebSocket 的核心工作原理"></a>WebSocket 的核心工作原理</h3><p>要理解 WebSocket，必须首先理解它与 HTTP 的关系。</p>
<ol>
<li><strong>基于 HTTP 的握手（Handshake）</strong>：<ul>
<li>WebSocket 的连接建立过程是基于 HTTP 协议的。</li>
<li>客户端发送一个特殊的 HTTP 请求，其中包含 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code> 请求头，向服务器请求将 HTTP 协议升级到 WebSocket 协议。</li>
<li>这是一个**“握手”**过程。</li>
</ul>
</li>
<li><strong>协议升级与持久连接</strong>：<ul>
<li>如果服务器支持 WebSocket，它会返回一个特殊的 HTTP 响应（状态码 <code>101 Switching Protocols</code>）。</li>
<li>握手成功后，客户端和服务器之间的 TCP 连接将<strong>保持打开状态</strong>。</li>
<li>这时，协议就从 HTTP 升级到了 WebSocket，双方可以在这个<strong>持久的 TCP 连接</strong>上自由地双向发送数据，而无需再进行 HTTP 头部开销。</li>
</ul>
</li>
<li><strong>数据帧传输</strong>：<ul>
<li>WebSocket 协议定义了**数据帧（Data Frames）**的概念。它将数据分割成更小、更轻量级的帧，而不是像 HTTP 那样发送整个报文。</li>
<li>这样，即使传输少量数据，也不会有很大的协议开销，非常适合实时通信。</li>
</ul>
</li>
</ol>
<h3 id="WebSocket-的生命周期：事件驱动模型"><a href="#WebSocket-的生命周期：事件驱动模型" class="headerlink" title="WebSocket 的生命周期：事件驱动模型"></a>WebSocket 的生命周期：事件驱动模型</h3><p>WebSocket 的生命周期由客户端和服务器共同维护，由一系列事件驱动：</p>
<h4 id="1-连接建立（Connection-Establishment）"><a href="#1-连接建立（Connection-Establishment）" class="headerlink" title="1. 连接建立（Connection Establishment）"></a>1. 连接建立（Connection Establishment）</h4><ul>
<li><strong>客户端</strong>：通过 <code>new WebSocket(url)</code> 建立连接。</li>
<li><strong>服务器</strong>：当客户端发送握手请求后，服务器处理并接受连接，此时触发 <code>onopen</code> 事件。</li>
</ul>
<h4 id="2-数据传输（Data-Transmission）"><a href="#2-数据传输（Data-Transmission）" class="headerlink" title="2. 数据传输（Data Transmission）"></a>2. 数据传输（Data Transmission）</h4><ul>
<li><strong>发送</strong>：客户端和服务器都可以通过各自的 <code>send()</code> 方法向对方发送数据。</li>
<li><strong>接收</strong>：当一方接收到数据时，会触发 <code>onmessage</code> 事件。</li>
</ul>
<h4 id="3-连接关闭（Connection-Close）"><a href="#3-连接关闭（Connection-Close）" class="headerlink" title="3. 连接关闭（Connection Close）"></a>3. 连接关闭（Connection Close）</h4><ul>
<li><strong>主动关闭</strong>：客户端或服务器可以调用 <code>close()</code> 方法主动关闭连接。</li>
<li><strong>异常关闭</strong>：连接可能因网络故障、心跳超时等原因意外关闭。</li>
<li><strong>事件</strong>：无论是主动还是被动，连接关闭时都会触发 <code>onclose</code> 事件。</li>
</ul>
<h3 id="WebSocket-的核心-API（以-JavaScript-为例）"><a href="#WebSocket-的核心-API（以-JavaScript-为例）" class="headerlink" title="WebSocket 的核心 API（以 JavaScript 为例）"></a>WebSocket 的核心 API（以 JavaScript 为例）</h3><p>WebSocket 的 API 设计非常简洁，主要基于事件监听和方法调用。</p>
<ul>
<li><strong>new WebSocket(url)</strong>：创建一个 WebSocket 客户端实例。</li>
<li><strong>websocket.onopen</strong>：连接成功建立时触发。</li>
<li><strong>websocket.onmessage &#x3D; function(event)</strong>：接收到服务器数据时触发，数据在 <code>event.data</code> 中。</li>
<li><strong>websocket.onerror</strong>：连接发生错误时触发。</li>
<li><strong>websocket.onclose</strong>：连接关闭时触发。</li>
<li><strong>websocket.send(data)</strong>：向服务器发送数据。</li>
<li><strong>websocket.close()</strong>：关闭连接。</li>
</ul>
<h3 id="WebSocket-与-HTTP-的本质区别"><a href="#WebSocket-与-HTTP-的本质区别" class="headerlink" title="WebSocket 与 HTTP 的本质区别"></a>WebSocket 与 HTTP 的本质区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>HTTP</th>
<th>WebSocket</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>通信模式</strong></td>
<td><strong>单向</strong>（请求-响应）</td>
<td><strong>双向</strong>（全双工）</td>
<td>HTTP 客户端必须先发请求，服务器才能响应。</td>
</tr>
<tr>
<td><strong>连接状态</strong></td>
<td><strong>无状态</strong>，短连接</td>
<td><strong>有状态</strong>，长连接</td>
<td>HTTP 每次请求都需要重新建立连接。</td>
</tr>
<tr>
<td><strong>协议开销</strong></td>
<td><strong>大</strong>（每次请求都携带头部）</td>
<td><strong>小</strong>（握手后只传输数据帧）</td>
<td>HTTP 适合传输大文件，WebSocket 适合小数据频繁传输。</td>
</tr>
<tr>
<td><strong>服务器主动性</strong></td>
<td><strong>被动</strong>（无法主动推送）</td>
<td><strong>主动</strong>（可随时推送数据）</td>
<td>WebSocket 解决了 HTTP 的“服务器推”难题。</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>网页浏览、API 调用、文件下载</td>
<td>聊天、游戏、实时数据更新</td>
<td></td>
</tr>
</tbody></table>
<h3 id="WebSocket-在现代-Java-Web-中的应用"><a href="#WebSocket-在现代-Java-Web-中的应用" class="headerlink" title="WebSocket 在现代 Java Web 中的应用"></a>WebSocket 在现代 Java Web 中的应用</h3><p>在 Java 后端，WebSocket 通常由专门的框架或容器来实现，如：</p>
<ul>
<li><strong>JavaEE 7+ 的 WebSocket API</strong>：提供了 <code>javax.websocket</code> 包，可以直接在 Servlet 容器中开发 WebSocket 应用。</li>
<li><strong>Spring Framework</strong>：提供了强大的 WebSocket 支持，集成了 STOMP（Simple Text Oriented Messaging Protocol）协议，简化了消息路由和管理。</li>
</ul>
<p>在这些框架中，你通常会定义一个 WebSocket 端点（Endpoint），类似于 Servlet，它负责处理连接的建立、消息的接收和发送、以及连接的关闭。</p>
<p>总而言之，WebSocket 是 HTTP 协议在实时通信领域的有力补充。它通过一次性的握手建立一个持久的双向通道，极大地提高了 Web 应用的交互性和效率，是现代 Web 架构中不可或缺的一部分。</p>
<p>好的，为了更好地理解 WebSocket 的工作原理，我将提供几个具体的应用场景和相应的代码示例。这些示例将涵盖客户端（JavaScript）和服务器端（Java&#x2F;Spring Boot）的代码，以便你能够完整地看到双向通信是如何实现的。</p>
<hr>
<h3 id="示例一：实时聊天应用"><a href="#示例一：实时聊天应用" class="headerlink" title="示例一：实时聊天应用"></a>示例一：实时聊天应用</h3><p>这是 WebSocket 最经典的用例。</p>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a><strong>应用场景</strong>：</h4><p>多个用户连接到聊天室，当一个用户发送消息时，服务器将该消息实时广播给所有其他在线用户。</p>
<h4 id="核心逻辑："><a href="#核心逻辑：" class="headerlink" title="核心逻辑："></a><strong>核心逻辑</strong>：</h4><ul>
<li><strong>客户端</strong>：当用户在输入框中按下回车，JavaScript 将消息通过 WebSocket 连接发送给服务器。</li>
<li><strong>服务器</strong>：接收到消息后，遍历所有已连接的 WebSocket 会话，将消息逐一发送给每个会话。</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a><strong>代码示例</strong>：</h4><p><strong>1. 客户端 (JavaScript)</strong></p>
<p>JavaScript</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接 WebSocket 服务器</span></span><br><span class="line"><span class="type">const</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/chat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接成功事件</span></span><br><span class="line">socket.onopen = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket连接已建立&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听接收消息事件</span></span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="variable">message</span> <span class="operator">=</span> event.data;</span><br><span class="line">  <span class="type">const</span> <span class="variable">chatBox</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;chat-box&#x27;</span>);</span><br><span class="line">  chatBox.innerHTML += `&lt;p&gt;$&#123;message&#125;&lt;/p&gt;`; <span class="comment">// 将消息添加到聊天框</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接关闭事件</span></span><br><span class="line">socket.onclose = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket连接已关闭&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听错误事件</span></span><br><span class="line">socket.onerror = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;WebSocket发生错误:&quot;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息函数</span></span><br><span class="line">function <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="variable">input</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;message-input&#x27;</span>);</span><br><span class="line">  <span class="type">const</span> <span class="variable">message</span> <span class="operator">=</span> input.value;</span><br><span class="line">  <span class="keyword">if</span> (message) &#123;</span><br><span class="line">    socket.send(message); <span class="comment">// 通过 WebSocket 发送消息</span></span><br><span class="line">    input.value = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 清空输入框</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定回车事件</span></span><br><span class="line">document.getElementById(<span class="string">&#x27;message-input&#x27;</span>).addEventListener(<span class="string">&#x27;keypress&#x27;</span>, function(e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.key === <span class="string">&#x27;Enter&#x27;</span>) &#123;</span><br><span class="line">    sendMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>2. 服务器端 (Java&#x2F;Spring Boot)</strong></p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatWebSocketEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储所有连接的客户端会话</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端连接成功时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.add(session); <span class="comment">// 添加新会话</span></span><br><span class="line">        System.out.println(<span class="string">&quot;新连接：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端发送消息时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息：&quot;</span> + message + <span class="string">&quot; 来自：&quot;</span> + session.getId());</span><br><span class="line">        <span class="comment">// 遍历所有会话，广播消息</span></span><br><span class="line">        sessions.forEach(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当连接关闭时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.remove(session); <span class="comment">// 移除会话</span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接关闭：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当发生错误时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接发生错误：&quot;</span> + session.getId());</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="示例二：实时股票行情或数据看板"><a href="#示例二：实时股票行情或数据看板" class="headerlink" title="示例二：实时股票行情或数据看板"></a>示例二：实时股票行情或数据看板</h3><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a><strong>应用场景</strong>：</h4><p>客户端连接到服务器，服务器定期或在数据更新时，向所有连接的客户端推送最新的股票价格或监控数据。</p>
<h4 id="核心逻辑：-1"><a href="#核心逻辑：-1" class="headerlink" title="核心逻辑："></a><strong>核心逻辑</strong>：</h4><ul>
<li><strong>客户端</strong>：只监听 <code>onmessage</code> 事件，被动接收服务器推送的数据。</li>
<li><strong>服务器</strong>：在后台启动一个定时任务或数据监听器。当数据变化时，主动通过 WebSocket 连接将新数据发送给客户端。</li>
</ul>
<h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a><strong>代码示例</strong>：</h4><p><strong>1. 客户端 (JavaScript)</strong></p>
<p>JavaScript</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/stock&#x27;</span>);</span><br><span class="line"></span><br><span class="line">socket.onopen = function(event) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;股票行情连接已建立&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">  <span class="comment">// 假设服务器发送的是JSON格式的股票数据</span></span><br><span class="line">  <span class="type">const</span> <span class="variable">stockData</span> <span class="operator">=</span> JSON.parse(event.data);</span><br><span class="line">  <span class="type">const</span> <span class="variable">stockPriceElement</span> <span class="operator">=</span> document.getElementById(<span class="string">&#x27;stock-price&#x27;</span>);</span><br><span class="line">  stockPriceElement.innerText = `当前价格: $&#123;stockData.price&#125;`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无需 sendMessage 函数，因为是单向被动接收</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 服务器端 (Java&#x2F;Spring Boot)</strong></p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/stock&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockWebSocketEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Session&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.add(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;新股票行情订阅者：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是一个定时任务，每隔5秒向所有客户端推送数据</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushStockData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟获取最新股票价格</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> Math.random() * <span class="number">100</span> + <span class="number">100</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;price\&quot;: &quot;</span> + String.format(<span class="string">&quot;%.2f&quot;</span>, price) + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有会话，推送数据</span></span><br><span class="line">        sessions.forEach(session -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                    session.getBasicRemote().sendText(json);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个例子清楚地展示了 WebSocket 如何通过<strong>持久连接</strong>和<strong>双向通信</strong>来解决实时应用中的核心痛点。</p>
<p>好的，让我们详细、清晰地解释<strong>静态资源</strong>和<strong>动态资源</strong>的概念，以及为什么某些服务器或工具只能处理静态资源。</p>
<hr>
<h3 id="一、静态资源-Static-Resources"><a href="#一、静态资源-Static-Resources" class="headerlink" title="一、静态资源 (Static Resources)"></a>一、静态资源 (Static Resources)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>静态资源</strong>是指在服务器端<strong>不需要经过任何处理或计算</strong>，就能直接返回给客户端的资源。它们的<strong>内容是固定不变</strong>的，无论何时、被谁请求，服务器返回的都是同一个文件。</p>
<h4 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h4><ul>
<li><strong>HTML 文件</strong> (<code>.html</code>)：纯 HTML 代码，浏览器直接渲染。</li>
<li><strong>CSS 样式表</strong> (<code>.css</code>)：定义网页样式。</li>
<li><strong>JavaScript 脚本</strong> (<code>.js</code>)：用于网页交互。</li>
<li><strong>图片</strong> (<code>.jpg</code>, <code>.png</code>, <code>.gif</code>)：图像文件。</li>
<li><strong>字体文件</strong> (<code>.woff</code>, <code>.ttf</code>)：网页字体。</li>
<li><strong>视频</strong> (<code>.mp4</code>, <code>.webm</code>)：视频文件。</li>
</ul>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li>客户端向服务器请求一个 URL，例如 <code>http://example.com/styles.css</code>。</li>
<li>服务器接收到请求，直接从<strong>文件系统</strong>中找到名为 <code>styles.css</code> 的文件。</li>
<li>服务器将 <code>styles.css</code> 的内容原封不动地返回给客户端。</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>高效</strong>：无需服务器计算，直接读取文件，响应速度极快。</li>
<li><strong>可缓存</strong>：由于内容不变，浏览器、代理服务器都可以对静态资源进行缓存，进一步减少网络传输。</li>
<li><strong>部署简单</strong>：只需将文件放在服务器的特定目录下即可。</li>
</ul>
<h3 id="二、动态资源-Dynamic-Resources"><a href="#二、动态资源-Dynamic-Resources" class="headerlink" title="二、动态资源 (Dynamic Resources)"></a>二、动态资源 (Dynamic Resources)</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>动态资源</strong>是指服务器端<strong>需要经过处理、计算或查询数据库</strong>，才能生成并返回给客户端的资源。它们的内容是<strong>可变</strong>的，不同的请求、不同的时间，返回的内容可能不同。</p>
<h4 id="常见类型-1"><a href="#常见类型-1" class="headerlink" title="常见类型"></a>常见类型</h4><ul>
<li><strong>Servlet&#x2F;JSP</strong>：Java 后端通过 Servlet 或 JSP 动态生成 HTML。</li>
<li><strong>PHP 脚本</strong> (<code>.php</code>)：PHP 后端生成 HTML。</li>
<li><strong>Python&#x2F;Django 视图</strong>：Python 后端处理请求并返回数据。</li>
<li><strong>RESTful API</strong>：返回 JSON、XML 等格式的数据。</li>
</ul>
<h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li>客户端向服务器请求一个 URL，例如 <code>http://example.com/user/profile?id=123</code>。</li>
<li>服务器接收到请求，将请求转发给<strong>后端程序</strong>（如 Servlet 容器）。</li>
<li>后端程序接收请求，根据请求参数 <code>id=123</code> 查询数据库，获取该用户的信息。</li>
<li>后端程序将数据渲染到 HTML 模板中，或者将数据封装成 JSON 格式。</li>
<li>后端程序将<strong>动态生成的内容</strong>作为响应返回给服务器。</li>
<li>服务器将该响应发送给客户端。</li>
</ol>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>灵活</strong>：可以根据业务逻辑生成个性化内容。</li>
<li><strong>消耗资源</strong>：需要消耗 CPU、内存、数据库连接等资源进行计算。</li>
<li><strong>不可直接缓存</strong>：由于内容可变，通常无法像静态资源那样直接缓存。</li>
</ul>
<h3 id="三、是什么东西只能解析静态资源？"><a href="#三、是什么东西只能解析静态资源？" class="headerlink" title="三、是什么东西只能解析静态资源？"></a>三、是什么东西只能解析静态资源？</h3><p>这个问题的核心在于**“解析”<strong>这个词。能“解析”静态资源的，通常指的是</strong>Web 服务器**。</p>
<ul>
<li><strong>Web 服务器</strong>：一种软件，它的主要职责是处理 HTTP 请求并返回文件。</li>
</ul>
<h4 id="1-纯静态-Web-服务器-Static-Web-Server"><a href="#1-纯静态-Web-服务器-Static-Web-Server" class="headerlink" title="1. 纯静态 Web 服务器 (Static Web Server)"></a>1. 纯静态 Web 服务器 (Static Web Server)</h4><p><strong>这类服务器的核心功能就是提供静态文件服务。</strong> 它们只知道如何根据 URL 路径，去文件系统找到对应的文件，然后返回。</p>
<ul>
<li><strong>工作原理</strong>：它们没有内置的后端语言解析器（如 Java 虚拟机、PHP 解释器）。当它们收到一个请求时，只会将 URL 映射到文件目录。如果文件存在，就返回；如果不存在，就返回 404 错误。</li>
<li><strong>代表</strong>：<strong>Nginx</strong>（作为反向代理或静态文件服务器时）、<strong>Apache HTTP Server</strong>（作为静态文件服务器时）。</li>
</ul>
<p><strong>为什么它们不能解析动态资源？</strong></p>
<p>因为它们<strong>不具备</strong>执行后端代码的能力。例如，当 Nginx 收到一个对 <code>.jsp</code> 文件的请求时，它不知道如何运行 Java 代码来生成 HTML。它只会把 <code>.jsp</code> 文件当作一个普通的文本文件返回给浏览器，浏览器也无法正确地解析。</p>
<h4 id="2-动态-Web-服务器-Dynamic-Web-Server"><a href="#2-动态-Web-服务器-Dynamic-Web-Server" class="headerlink" title="2. 动态 Web 服务器 (Dynamic Web Server)"></a>2. 动态 Web 服务器 (Dynamic Web Server)</h4><p>这类服务器通常被称为 <strong>“应用服务器”</strong>，它们在 Web 服务器的功能上，<strong>内置了后端语言的运行环境</strong>。</p>
<ul>
<li><strong>工作原理</strong>：<ul>
<li>当它们收到静态资源请求时，行为与静态服务器相同：直接返回文件。</li>
<li>当它们收到动态资源请求时，会将请求转发给内置的<strong>后端程序运行环境</strong>。例如，Tomcat 会将 <code>.jsp</code> 文件交给 JSP 引擎来编译和执行。</li>
</ul>
</li>
<li><strong>代表</strong>：<strong>Apache Tomcat</strong>、<strong>Jetty</strong>。</li>
</ul>
<p>因此，在实际生产环境中，我们经常采用<strong>动静分离</strong>的架构：</p>
<ul>
<li><strong>静态资源</strong>（<code>index.html</code>、<code>style.css</code> 等）交给 <strong>Nginx</strong> 这样的高效静态服务器处理。</li>
<li><strong>动态资源</strong>（<code>api/user</code>, <code>.jsp</code> 等）交给 <strong>Tomcat</strong> 这样的应用服务器处理。</li>
</ul>
<p>这样做的目的是，让专业的工具做专业的事：Nginx 擅长高并发的静态文件服务，而 Tomcat 则专注于复杂的动态业务逻辑。</p>
<p>好的，让我们来系统、全面地梳理前端的核心知识，这不仅是前端工程师的必备技能，也是后端开发者理解整个 Web 应用架构的关键。</p>
<h3 id="一、基础三剑客：构建网页的基石"><a href="#一、基础三剑客：构建网页的基石" class="headerlink" title="一、基础三剑客：构建网页的基石"></a>一、基础三剑客：构建网页的基石</h3><p>这三者是所有前端技术的基础，就像建筑的钢筋、水泥和水电。</p>
<h4 id="1-HTML-HyperText-Markup-Language"><a href="#1-HTML-HyperText-Markup-Language" class="headerlink" title="1. HTML (HyperText Markup Language)"></a>1. HTML (HyperText Markup Language)</h4><ul>
<li><strong>是什么</strong>：超文本标记语言，用于<strong>定义网页的结构和内容</strong>。它由一系列标签（tag）组成，这些标签告诉浏览器如何组织页面内容，如段落、标题、图片、链接等。</li>
<li><strong>核心概念</strong>：<ul>
<li><strong>标签（Tags）</strong>：如 <code>&lt;p&gt;</code> (段落), <code>&lt;h1&gt;</code> (一级标题), <code>&lt;img&gt;</code> (图片), <code>&lt;a&gt;</code> (超链接)。</li>
<li><strong>元素（Elements）</strong>：由开始标签、内容和结束标签组成，例如 <code>&lt;p&gt;这是一个段落。&lt;/p&gt;</code>。</li>
<li><strong>属性（Attributes）</strong>：提供关于元素的额外信息，如 <code>&lt;img src=&quot;image.jpg&quot; alt=&quot;描述&quot;&gt;</code> 中的 <code>src</code> 和 <code>alt</code>。</li>
<li><strong>语义化（Semantic HTML）</strong>：使用恰当的标签来表达内容的含义，如 <code>&lt;header&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;footer&gt;</code>，这有助于搜索引擎优化（SEO）和无障碍访问。</li>
</ul>
</li>
</ul>
<h4 id="2-CSS-Cascading-Style-Sheets"><a href="#2-CSS-Cascading-Style-Sheets" class="headerlink" title="2. CSS (Cascading Style Sheets)"></a>2. CSS (Cascading Style Sheets)</h4><ul>
<li><strong>是什么</strong>：层叠样式表，用于<strong>定义网页的样式和表现</strong>。它告诉浏览器如何显示 HTML 元素，如颜色、字体、布局、大小等。</li>
<li><strong>核心概念</strong>：<ul>
<li><strong>选择器（Selectors）</strong>：用于选中要应用样式的 HTML 元素，如 <code>h1</code> (标签选择器), <code>.my-class</code> (类选择器), <code>#my-id</code> (ID 选择器)。</li>
<li><strong>盒模型（Box Model）</strong>：每个 HTML 元素都被视为一个矩形盒子，包含 <code>content</code>（内容）、<code>padding</code>（内边距）、<code>border</code>（边框）和 <code>margin</code>（外边距）。</li>
<li><strong>布局（Layout）</strong>：<ul>
<li><strong>传统布局</strong>：<code>float</code>, <code>position</code>, <code>display</code>。</li>
<li><strong>现代布局</strong>：<strong>Flexbox</strong> (弹性盒子，用于一维布局) 和 <strong>Grid</strong> (网格系统，用于二维布局)。这两种是目前最主流的布局方式。</li>
</ul>
</li>
<li><strong>响应式设计（Responsive Design）</strong>：使用 <code>@media</code> 查询来根据设备屏幕大小调整样式，使网页在不同设备上都能良好显示。</li>
</ul>
</li>
</ul>
<h4 id="3-JavaScript-JS"><a href="#3-JavaScript-JS" class="headerlink" title="3. JavaScript (JS)"></a>3. JavaScript (JS)</h4><ul>
<li><strong>是什么</strong>：一种高级编程语言，用于<strong>实现网页的动态行为和交互</strong>。它可以操作 HTML 和 CSS，处理用户事件，并与服务器进行通信。</li>
<li><strong>核心概念</strong>：<ul>
<li><strong>DOM (Document Object Model) 操作</strong>：通过 <code>document</code> 对象，JS 可以获取、修改、添加或删除页面上的 HTML 元素。例如 <code>document.getElementById(&#39;myId&#39;)</code>。</li>
<li><strong>事件处理（Event Handling）</strong>：响应用户的行为，如点击、输入、鼠标移动等。例如 <code>element.addEventListener(&#39;click&#39;, function() &#123; ... &#125;)</code>。</li>
<li><strong>异步编程（Asynchronous Programming）</strong>：处理耗时操作，如网络请求。<ul>
<li><strong>Callback (回调函数)</strong>：传统方式。</li>
<li><strong>Promise</strong>：ES6 引入，解决了回调地狱问题。</li>
<li><strong>async&#x2F;await</strong>：基于 <code>Promise</code> 的语法糖，使异步代码看起来像同步代码，更易读。</li>
</ul>
</li>
<li><strong>AJAX (Asynchronous JavaScript and XML)</strong>：在不重新加载整个页面的情况下，与服务器进行异步通信。现代应用中通常使用 <code>fetch()</code> API 或 <code>Axios</code> 库来发送 JSON 数据。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、现代前端框架：提升开发效率"><a href="#二、现代前端框架：提升开发效率" class="headerlink" title="二、现代前端框架：提升开发效率"></a>二、现代前端框架：提升开发效率</h3><p>为了处理日益复杂的 Web 应用，开发者通常会使用以下框架。</p>
<ul>
<li><strong>React</strong>：由 Facebook 开发，<strong>组件化</strong>、<strong>声明式</strong>的 UI 库。<ul>
<li><strong>核心</strong>：<strong>组件（Components）</strong>，将 UI 拆分成独立、可复用的部分。</li>
<li><strong>工作原理</strong>：使用<strong>虚拟 DOM (Virtual DOM)</strong>，在内存中进行计算，然后只更新实际改变的部分，提高了性能。</li>
<li><strong>生态</strong>：庞大而活跃，有成熟的状态管理（Redux, Zustand）、路由（React Router）等解决方案。</li>
</ul>
</li>
<li><strong>Vue.js</strong>：由尤雨溪开发，易学易用，<strong>渐进式</strong>框架。<ul>
<li><strong>核心</strong>：<strong>响应式数据绑定</strong>，数据改变，视图自动更新。</li>
<li><strong>特点</strong>：上手快，文档友好，社区生态完善。</li>
</ul>
</li>
<li><strong>Angular</strong>：由 Google 开发，<strong>全能型</strong>框架。<ul>
<li><strong>核心</strong>：提供了完整的解决方案，包括路由、依赖注入、状态管理等。</li>
<li><strong>特点</strong>：适合大型企业级应用，学习曲线相对陡峭。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三、工程化：高效协作和自动化"><a href="#三、工程化：高效协作和自动化" class="headerlink" title="三、工程化：高效协作和自动化"></a>三、工程化：高效协作和自动化</h3><p>现代前端开发已经不仅仅是写代码，还需要使用一系列工具来提高效率。</p>
<ul>
<li><strong>包管理器</strong>：<code>npm</code>, <code>yarn</code>, <code>pnpm</code>。用于管理项目依赖。</li>
<li><strong>构建工具</strong>：<ul>
<li><strong>Webpack</strong>：将多个模块打包成一个或多个文件，并能处理资源依赖、代码压缩等。</li>
<li><strong>Vite</strong>：基于 ES Modules 的新一代构建工具，开发模式下速度极快。</li>
</ul>
</li>
<li><strong>转译工具</strong>：<strong>Babel</strong>。将 ES6+ 的代码转译为浏览器兼容的 ES5 代码。</li>
<li><strong>代码规范</strong>：<strong>ESLint</strong> (代码风格检查), <strong>Prettier</strong> (代码格式化)。</li>
<li><strong>版本控制</strong>：<strong>Git</strong>。用于团队协作和代码版本管理。</li>
</ul>
<p>好的，让我们详细、全面地介绍 CSS 选择器。选择器是 CSS 的核心，掌握它才能精确地控制网页样式。我们将从基础到高级，系统地梳理不同类型的选择器及其用法。</p>
<hr>
<h3 id="一、基础选择器-Basic-Selectors"><a href="#一、基础选择器-Basic-Selectors" class="headerlink" title="一、基础选择器 (Basic Selectors)"></a>一、基础选择器 (Basic Selectors)</h3><p>这些是 CSS 中最简单、最常用的选择器，用于直接选中元素。</p>
<h4 id="1-元素选择器-Type-Selector"><a href="#1-元素选择器-Type-Selector" class="headerlink" title="1. 元素选择器 (Type Selector)"></a>1. 元素选择器 (Type Selector)</h4><ul>
<li><strong>作用</strong>：根据元素的标签名来选择元素。</li>
<li><strong>语法</strong>：<code>element_name &#123; ... &#125;</code></li>
<li><strong>示例</strong>：<ul>
<li><code>p &#123; color: blue; &#125;</code>：选中所有 <code>&lt;p&gt;</code> 元素。</li>
<li><code>h1 &#123; font-size: 24px; &#125;</code>：选中所有 <code>&lt;h1&gt;</code> 元素。</li>
</ul>
</li>
</ul>
<h4 id="2-类选择器-Class-Selector"><a href="#2-类选择器-Class-Selector" class="headerlink" title="2. 类选择器 (Class Selector)"></a>2. 类选择器 (Class Selector)</h4><ul>
<li><strong>作用</strong>：根据元素的 <code>class</code> 属性来选择元素。</li>
<li><strong>语法</strong>：<code>.class_name &#123; ... &#125;</code></li>
<li><strong>特点</strong>：一个元素可以有多个类名，类名可以重复使用，非常灵活。</li>
<li><strong>示例</strong>：<ul>
<li><code>.highlight &#123; background-color: yellow; &#125;</code>：选中所有 <code>class</code> 属性中包含 <code>highlight</code> 的元素。</li>
</ul>
</li>
</ul>
<h4 id="3-ID-选择器-ID-Selector"><a href="#3-ID-选择器-ID-Selector" class="headerlink" title="3. ID 选择器 (ID Selector)"></a>3. ID 选择器 (ID Selector)</h4><ul>
<li><strong>作用</strong>：根据元素的 <code>id</code> 属性来选择元素。</li>
<li><strong>语法</strong>：<code>#id_name &#123; ... &#125;</code></li>
<li><strong>特点</strong>：在 HTML 文档中，一个 <code>id</code> 属性的值必须是<strong>唯一的</strong>。</li>
<li><strong>示例</strong>：<ul>
<li><code>#header &#123; height: 100px; &#125;</code>：选中 <code>id</code> 为 <code>header</code> 的唯一元素。</li>
</ul>
</li>
</ul>
<h4 id="4-通用选择器-Universal-Selector"><a href="#4-通用选择器-Universal-Selector" class="headerlink" title="4. 通用选择器 (Universal Selector)"></a>4. 通用选择器 (Universal Selector)</h4><ul>
<li><strong>作用</strong>：选择页面上的所有元素。</li>
<li><strong>语法</strong>：<code>* &#123; ... &#125;</code></li>
<li><strong>示例</strong>：<ul>
<li><code>* &#123; margin: 0; padding: 0; &#125;</code>：清除所有元素的默认外边距和内边距，常用于 CSS 重置。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、组合选择器-Combinators"><a href="#二、组合选择器-Combinators" class="headerlink" title="二、组合选择器 (Combinators)"></a>二、组合选择器 (Combinators)</h3><p>这些选择器用于根据元素之间的关系来选择元素，如父子关系、兄弟关系等。</p>
<h4 id="1-后代选择器-Descendant-Selector"><a href="#1-后代选择器-Descendant-Selector" class="headerlink" title="1. 后代选择器 (Descendant Selector)"></a>1. 后代选择器 (Descendant Selector)</h4><ul>
<li><strong>作用</strong>：选择某个元素内部的<strong>所有</strong>后代元素（包括子元素、孙子元素等）。</li>
<li><strong>语法</strong>：<code>ancestor descendant &#123; ... &#125;</code>，用<strong>空格</strong>分隔。</li>
<li><strong>示例</strong>：<ul>
<li><code>ul li &#123; list-style-type: none; &#125;</code>：选中所有 <code>&lt;ul&gt;</code> 内部的 <code>&lt;li&gt;</code> 元素。</li>
</ul>
</li>
</ul>
<h4 id="2-子选择器-Child-Selector"><a href="#2-子选择器-Child-Selector" class="headerlink" title="2. 子选择器 (Child Selector)"></a>2. 子选择器 (Child Selector)</h4><ul>
<li><strong>作用</strong>：选择某个元素的<strong>直接子元素</strong>。</li>
<li><strong>语法</strong>：<code>parent &gt; child &#123; ... &#125;</code>，用 <code>&gt;</code> 分隔。</li>
<li><strong>示例</strong>：<ul>
<li><code>ul &gt; li &#123; list-style-type: none; &#125;</code>：只选中 <code>&lt;ul&gt;</code> 的直接子元素 <code>&lt;li&gt;</code>。</li>
<li><strong>区别</strong>：与后代选择器相比，更加精确，性能也更好。</li>
</ul>
</li>
</ul>
<h4 id="3-相邻兄弟选择器-Adjacent-Sibling-Selector"><a href="#3-相邻兄弟选择器-Adjacent-Sibling-Selector" class="headerlink" title="3. 相邻兄弟选择器 (Adjacent Sibling Selector)"></a>3. 相邻兄弟选择器 (Adjacent Sibling Selector)</h4><ul>
<li><strong>作用</strong>：选择紧接在另一个元素后面的<strong>兄弟元素</strong>。</li>
<li><strong>语法</strong>：<code>element + adjacent_element &#123; ... &#125;</code>，用 <code>+</code> 分隔。</li>
<li><strong>示例</strong>：<ul>
<li><code>h1 + p &#123; margin-top: 0; &#125;</code>：选中紧跟在 <code>&lt;h1&gt;</code> 后的第一个 <code>&lt;p&gt;</code> 元素。</li>
</ul>
</li>
</ul>
<h4 id="4-通用兄弟选择器-General-Sibling-Selector"><a href="#4-通用兄弟选择器-General-Sibling-Selector" class="headerlink" title="4. 通用兄弟选择器 (General Sibling Selector)"></a>4. 通用兄弟选择器 (General Sibling Selector)</h4><ul>
<li><strong>作用</strong>：选择某个元素后面<strong>所有</strong>的兄弟元素（不限于紧邻的）。</li>
<li><strong>语法</strong>：<code>element ~ sibling &#123; ... &#125;</code>，用 <code>~</code> 分隔。</li>
<li><strong>示例</strong>：<ul>
<li><code>h1 ~ p &#123; margin-top: 0; &#125;</code>：选中 <code>&lt;h1&gt;</code> 后的所有 <code>&lt;p&gt;</code> 元素。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三、属性选择器-Attribute-Selectors"><a href="#三、属性选择器-Attribute-Selectors" class="headerlink" title="三、属性选择器 (Attribute Selectors)"></a>三、属性选择器 (Attribute Selectors)</h3><p>这些选择器根据元素的属性及其值来选择元素。</p>
<ul>
<li><strong>[attribute]</strong>：选择具有该属性的元素。<ul>
<li><code>[title] &#123; ... &#125;</code>：选中所有具有 <code>title</code> 属性的元素。</li>
</ul>
</li>
<li><strong>[attribute&#x3D;”value”]</strong>：选择具有特定属性和值的元素。<ul>
<li><code>input[type=&quot;text&quot;] &#123; ... &#125;</code>：选中所有 <code>type</code> 属性值为 <code>text</code> 的 <code>&lt;input&gt;</code> 元素。</li>
</ul>
</li>
<li><strong>[attribute~&#x3D;”value”]</strong>：选择属性值中包含特定<strong>独立单词</strong>的元素。<ul>
<li><code>[class~=&quot;box&quot;] &#123; ... &#125;</code>：选中所有 <code>class</code> 属性中包含 <code>box</code> 这个独立单词的元素（如 <code>class=&quot;card box&quot;</code>）。</li>
</ul>
</li>
<li><strong>[attribute|&#x3D;”value”]</strong>：选择属性值以特定字符串开头（后跟连字符 <code>-</code>）的元素。<ul>
<li><code>[lang|=&quot;en&quot;] &#123; ... &#125;</code>：选中 <code>lang</code> 属性值为 <code>en</code> 或 <code>en-us</code> 等的元素。</li>
</ul>
</li>
<li><strong>[attribute^&#x3D;”value”]</strong>：选择属性值以特定字符串开头的元素。<ul>
<li><code>a[href^=&quot;https&quot;] &#123; ... &#125;</code>：选中所有 <code>href</code> 属性以 <code>https</code> 开头的 <code>&lt;a&gt;</code> 元素。</li>
</ul>
</li>
<li><strong>[attribute$&#x3D;”value”]</strong>：选择属性值以特定字符串结尾的元素。<ul>
<li><code>img[src$=&quot;.png&quot;] &#123; ... &#125;</code>：选中所有 <code>src</code> 属性以 <code>.png</code> 结尾的 <code>&lt;img&gt;</code> 元素。</li>
</ul>
</li>
<li><strong>[attribute*&#x3D;”value”]</strong>：选择属性值中包含特定字符串的元素。<ul>
<li><code>[title*=&quot;hello&quot;] &#123; ... &#125;</code>：选中所有 <code>title</code> 属性值中包含 <code>hello</code> 的元素。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四、伪类选择器-Pseudo-class-Selectors"><a href="#四、伪类选择器-Pseudo-class-Selectors" class="headerlink" title="四、伪类选择器 (Pseudo-class Selectors)"></a>四、伪类选择器 (Pseudo-class Selectors)</h3><p>伪类用于选择元素的<strong>特定状态</strong>。</p>
<ul>
<li><strong>a:link</strong>：未访问的链接。</li>
<li><strong>a:visited</strong>：已访问的链接。</li>
<li><strong>a:hover</strong>：鼠标悬停在元素上。</li>
<li><strong>a:active</strong>：元素被点击时。</li>
<li><strong>element:focus</strong>：元素获得焦点时（常用于表单）。</li>
<li><strong>:nth-child(n)</strong>：选择属于其父元素的第 n 个子元素。</li>
<li><strong>:first-child</strong>：选择属于其父元素的第一个子元素。</li>
<li><strong>:last-child</strong>：选择属于其父元素的最后一个子元素。</li>
<li><strong>:not(selector)</strong>：选择不匹配指定选择器的元素。</li>
<li><strong>:empty</strong>：选择没有子元素或文本内容的元素。</li>
</ul>
<hr>
<h3 id="五、伪元素选择器-Pseudo-element-Selectors"><a href="#五、伪元素选择器-Pseudo-element-Selectors" class="headerlink" title="五、伪元素选择器 (Pseudo-element Selectors)"></a>五、伪元素选择器 (Pseudo-element Selectors)</h3><p>伪元素用于选择元素的<strong>特定部分</strong>。</p>
<ul>
<li><strong>::first-line</strong>：选择元素的第一行。</li>
<li><strong>::first-letter</strong>：选择元素的首个字母。</li>
<li><strong>::before</strong>：在元素的内容前面插入生成的内容。</li>
<li><strong>::after</strong>：在元素的内容后面插入生成的内容。</li>
</ul>
<hr>
<h3 id="优先级与层叠"><a href="#优先级与层叠" class="headerlink" title="优先级与层叠"></a>优先级与层叠</h3><p>当多个选择器选中同一个元素并应用不同的样式时，浏览器会根据**优先级（Specificity）**来决定最终样式。</p>
<ul>
<li><strong>优先级计算</strong>：<ul>
<li><code>!important</code>：最高优先级。</li>
<li><strong>行内样式</strong>：1000</li>
<li><strong>ID 选择器</strong>：100</li>
<li><strong>类、属性、伪类选择器</strong>：10</li>
<li><strong>元素、伪元素选择器</strong>：1</li>
<li><strong>通用选择器</strong>：0</li>
</ul>
</li>
<li><strong>举例</strong>：<ul>
<li><code>p &#123; color: red; &#125;</code>（优先级 1）</li>
<li><code>.highlight &#123; color: blue; &#125;</code>（优先级 10）</li>
<li><code>#main p &#123; color: green; &#125;</code>（优先级 101）</li>
</ul>
</li>
</ul>
<p>在这个例子中，即使 <code>p</code> 的样式最先声明，但 <code>main p</code> 的优先级最高，因此 <code>&lt;p id=&quot;main&quot;&gt;</code> 的字体颜色最终会是绿色。</p>
<p>好的，让我们来全面、深入地介绍 Maven，并剖析一些关键细节以及面试中可能遇到的问题。</p>
<hr>
<h3 id="一、Maven-核心概念"><a href="#一、Maven-核心概念" class="headerlink" title="一、Maven 核心概念"></a>一、Maven 核心概念</h3><h4 id="1-什么是-Maven？"><a href="#1-什么是-Maven？" class="headerlink" title="1. 什么是 Maven？"></a>1. 什么是 Maven？</h4><p>Maven 是一个<strong>项目管理和构建自动化工具</strong>。它提供了一套标准化的项目结构、统一的构建生命周期，并依赖于一个<strong>中央仓库</strong>来管理项目所需的依赖。</p>
<p>它的核心思想是**“约定优于配置”（Convention over Configuration）**，这意味着它有一套默认的项目目录结构和构建流程。只要你遵循这些约定，就可以用很少的配置完成复杂的构建任务。</p>
<h4 id="2-为什么需要-Maven？"><a href="#2-为什么需要-Maven？" class="headerlink" title="2. 为什么需要 Maven？"></a>2. 为什么需要 Maven？</h4><p>在 Maven 出现之前，Java 项目的构建非常混乱：</p>
<ul>
<li><strong>项目结构不统一</strong>：每个项目都有自己的目录结构，新成员需要花时间熟悉。</li>
<li><strong>依赖管理混乱</strong>：需要手动下载所有 JAR 包，并添加到项目中，非常容易出错。</li>
<li><strong>构建过程不统一</strong>：编译、测试、打包等操作需要手动执行脚本，效率低下。</li>
</ul>
<p>Maven 通过<strong>标准化</strong>解决了这些问题：</p>
<ul>
<li><strong>标准化的项目结构</strong>：所有 Maven 项目都遵循相同的目录结构，如 <code>src/main/java</code>、<code>src/test/java</code> 等。</li>
<li><strong>统一的依赖管理</strong>：通过在 <code>pom.xml</code> 中声明依赖，Maven 会自动从仓库下载并管理。</li>
<li><strong>标准化的构建生命周期</strong>：定义了一系列标准的构建阶段（如 <code>compile</code>, <code>test</code>, <code>package</code>），可以一键执行。</li>
</ul>
<hr>
<h3 id="二、Maven-的核心组成部分"><a href="#二、Maven-的核心组成部分" class="headerlink" title="二、Maven 的核心组成部分"></a>二、Maven 的核心组成部分</h3><h4 id="1-POM-Project-Object-Model"><a href="#1-POM-Project-Object-Model" class="headerlink" title="1. POM (Project Object Model)"></a>1. POM (Project Object Model)</h4><ul>
<li><strong>概念</strong>：<code>pom.xml</code> 文件是 Maven 项目的<strong>核心配置文件</strong>。它定义了项目的元数据、依赖、插件、构建配置等所有信息。</li>
<li><strong>重要标签</strong>：<ul>
<li><code>&lt;project&gt;</code>：根元素。</li>
<li><code>&lt;groupId&gt;</code>, <code>&lt;artifactId&gt;</code>, <code>&lt;version&gt;</code>：项目的唯一标识符，通常称为 <strong>GAV 坐标</strong>。</li>
<li><code>&lt;packaging&gt;</code>：打包类型，如 <code>jar</code>, <code>war</code>, <code>pom</code>。</li>
<li><code>&lt;dependencies&gt;</code>：定义项目所需的依赖。</li>
<li><code>&lt;parent&gt;</code>：继承父 POM，实现依赖的统一管理。</li>
<li><code>&lt;build&gt;</code>：定义构建过程，如插件配置。</li>
</ul>
</li>
</ul>
<h4 id="2-依赖管理-Dependency-Management"><a href="#2-依赖管理-Dependency-Management" class="headerlink" title="2. 依赖管理 (Dependency Management)"></a>2. 依赖管理 (Dependency Management)</h4><ul>
<li><strong>概念</strong>：通过在 <code>&lt;dependencies&gt;</code> 中定义 GAV 坐标，Maven 会自动从本地或远程仓库下载依赖。</li>
<li><strong>传递性依赖</strong>：如果你的项目依赖 A，A 又依赖 B，Maven 会自动将 B 也下载下来。这是其强大的地方，但有时也可能导致版本冲突。</li>
<li><strong><dependencyManagement></strong>：这是一个非常重要的标签，通常在<strong>父 POM</strong> 中使用。它只定义依赖的版本，但<strong>不实际引入</strong>。子项目继承后，只需声明 <code>&lt;artifactId&gt;</code> 和 <code>&lt;groupId&gt;</code>，版本号会自动继承，这能确保整个项目所有模块的依赖版本一致。</li>
</ul>
<h4 id="3-仓库-Repositories"><a href="#3-仓库-Repositories" class="headerlink" title="3. 仓库 (Repositories)"></a>3. 仓库 (Repositories)</h4><p>Maven 仓库是用来存放所有依赖 JAR 包的地方。它分为三种：</p>
<ul>
<li><strong>本地仓库 (Local Repository)</strong>：<code>~/.m2/repository</code>，首次下载的依赖会存放在这里，后续构建时会优先从这里读取。</li>
<li><strong>远程仓库 (Remote Repository)</strong>：<ul>
<li><strong>中央仓库 (Central Repository)</strong>：Maven 官方维护的公共仓库，包含了绝大多数常用的开源库。</li>
<li><strong>私服 (Private Repository)</strong>：企业内部搭建的仓库，用于存放公司内部的 JAR 包或作为中央仓库的代理，加快下载速度。</li>
</ul>
</li>
</ul>
<h4 id="4-生命周期与阶段-Lifecycle-Phases"><a href="#4-生命周期与阶段-Lifecycle-Phases" class="headerlink" title="4. 生命周期与阶段 (Lifecycle &amp; Phases)"></a>4. 生命周期与阶段 (Lifecycle &amp; Phases)</h4><p>Maven 有一套标准的构建生命周期，分为三个：</p>
<ul>
<li><strong>clean</strong>：清理项目。<ul>
<li><code>clean</code>：删除 <code>target</code> 目录。</li>
</ul>
</li>
<li><strong>default</strong>：构建项目。<ul>
<li><code>validate</code></li>
<li><code>compile</code>：编译源代码。</li>
<li><code>test</code>：运行测试。</li>
<li><code>package</code>：打包。</li>
<li><code>install</code>：安装到本地仓库。</li>
<li><code>deploy</code>：部署到远程仓库。</li>
</ul>
</li>
<li><strong>site</strong>：生成项目站点。</li>
</ul>
<p><strong>重要规则</strong>：执行某个阶段时，它之前的所有阶段都会按顺序执行。例如，<code>mvn package</code> 会自动执行 <code>compile</code> 和 <code>test</code>。</p>
<hr>
<h3 id="三、面试常见问题与回答技巧"><a href="#三、面试常见问题与回答技巧" class="headerlink" title="三、面试常见问题与回答技巧"></a>三、面试常见问题与回答技巧</h3><h4 id="1-Maven-的-GAV-坐标是什么？有什么作用？"><a href="#1-Maven-的-GAV-坐标是什么？有什么作用？" class="headerlink" title="1. Maven 的 GAV 坐标是什么？有什么作用？"></a>1. Maven 的 GAV 坐标是什么？有什么作用？</h4><ul>
<li><strong>回答</strong>：GAV 坐标是 Maven 项目的唯一标识符，由 <code>&lt;groupId&gt;</code>, <code>&lt;artifactId&gt;</code>, 和 <code>&lt;version&gt;</code> 三个元素组成。</li>
<li><strong>作用</strong>：<ul>
<li><strong>唯一性</strong>：确保每个项目和每个版本的依赖在仓库中都是唯一的。</li>
<li><strong>定位</strong>：Maven 通过 GAV 坐标来查找和下载依赖。</li>
<li><strong>传递性</strong>：在传递性依赖中，通过 GAV 坐标来识别和处理依赖关系。</li>
</ul>
</li>
</ul>
<h4 id="2-和-有什么区别？"><a href="#2-和-有什么区别？" class="headerlink" title="2. &lt;dependencyManagement&gt; 和 &lt;dependencies&gt; 有什么区别？"></a>2. <code>&lt;dependencyManagement&gt;</code> 和 <code>&lt;dependencies&gt;</code> 有什么区别？</h4><ul>
<li><strong>回答</strong>：这是面试高频问题，需要清晰地说明两者的职责。</li>
<li><strong><dependencies></strong>：<strong>实际引入</strong>依赖。它用于在当前项目中添加一个具体的依赖，Maven 会立即下载并使用它。</li>
<li><strong><dependencyManagement></strong>：<strong>只定义版本</strong>。它只声明依赖的版本，但<strong>不实际引入</strong>。其主要目的是<strong>统一管理子模块的依赖版本</strong>。子模块继承父 POM 后，只需在自己的 <code>&lt;dependencies&gt;</code> 中声明 <code>&lt;groupId&gt;</code> 和 <code>&lt;artifactId&gt;</code>，版本号会自动从父 POM 中继承，这避免了版本不一致的问题。</li>
</ul>
<h4 id="3-什么是-Maven-的生命周期？mvn-install-和-mvn-deploy-有什么区别？"><a href="#3-什么是-Maven-的生命周期？mvn-install-和-mvn-deploy-有什么区别？" class="headerlink" title="3. 什么是 Maven 的生命周期？mvn install 和 mvn deploy 有什么区别？"></a>3. 什么是 Maven 的生命周期？<code>mvn install</code> 和 <code>mvn deploy</code> 有什么区别？</h4><ul>
<li><strong>回答</strong>：</li>
<li><strong>生命周期</strong>：Maven 有三个标准的生命周期：<code>clean</code>、<code>default</code> 和 <code>site</code>。其中 <code>default</code> 包含了从编译到部署的所有阶段。</li>
<li><strong>mvn install</strong>：执行 <code>default</code> 生命周期到 <code>install</code> 阶段。它会将项目打包，并安装到<strong>本地仓库</strong>。这样，其他本地项目就可以依赖这个包。</li>
<li><strong>mvn deploy</strong>：执行 <code>default</code> 生命周期到 <code>deploy</code> 阶段。它会将项目打包，并部署到<strong>远程仓库</strong>（私服或中央仓库）。这使得其他团队成员或项目可以从远程仓库获取并使用这个包。</li>
</ul>
<h4 id="4-Maven-依赖冲突如何解决？"><a href="#4-Maven-依赖冲突如何解决？" class="headerlink" title="4. Maven 依赖冲突如何解决？"></a>4. Maven 依赖冲突如何解决？</h4><ul>
<li><strong>回答</strong>：当多个依赖间接引入了同一个库的不同版本时，就会发生依赖冲突。</li>
<li><strong>解决策略</strong>：<ul>
<li><strong>依赖调解（Dependency Mediation）</strong>：Maven 的默认规则是“<strong>路径最短者优先</strong>”。即在依赖树中，路径最短的那个版本会被选中。</li>
<li><strong>手动排除（Exclusion）</strong>：如果默认规则不能解决问题，可以在 <code>&lt;dependency&gt;</code> 标签内使用 <code>&lt;exclusions&gt;</code> 标签手动排除有问题的传递性依赖。</li>
<li><strong>手动引入（Declaration）</strong>：在 <code>&lt;dependencies&gt;</code> 中明确声明需要使用的版本。Maven 的另一个规则是“<strong>最近声明者优先</strong>”，即如果两个依赖路径长度相同，先声明的那个会被使用。但更好的做法是直接在父 POM 的 <code>&lt;dependencyManagement&gt;</code> 中统一版本。</li>
</ul>
</li>
</ul>
<p>好的，我们来详细梳理你提供的这份关于会话技术的笔记，并按照你要求的逻辑，以一种更清晰、更专业的面试回答或技术讲解的方式进行重新组织和补充。</p>
<hr>
<h3 id="一、会话技术概述：解决-HTTP-无状态问题"><a href="#一、会话技术概述：解决-HTTP-无状态问题" class="headerlink" title="一、会话技术概述：解决 HTTP 无状态问题"></a>一、会话技术概述：解决 HTTP 无状态问题</h3><p>HTTP 协议本身是无状态的，它不记得上一次请求的任何信息。为了在多次请求之间共享数据并识别用户，引入了两种核心的会话技术：客户端会话（Cookie）和服务器端会话（Session）。</p>
<h3 id="二、客户端会话：Cookie"><a href="#二、客户端会话：Cookie" class="headerlink" title="二、客户端会话：Cookie"></a>二、客户端会话：Cookie</h3><p><strong>核心概念</strong>：Cookie 是服务器发送给浏览器并存储在客户端的一小段文本信息。浏览器在下次访问同一服务器时会自动将该 Cookie 携带在请求中。</p>
<h4 id="1-关于-Cookie-的几个常见问题"><a href="#1-关于-Cookie-的几个常见问题" class="headerlink" title="1. 关于 Cookie 的几个常见问题"></a>1. 关于 Cookie 的几个常见问题</h4><ul>
<li><strong>一次请求响应可以发送多个 Cookie 吗？</strong><ul>
<li><strong>回答</strong>：<strong>可以</strong>。服务器可以在一个响应中通过多个 <code>Set-Cookie</code> 响应头来设置多个 Cookie。浏览器会分别存储这些 Cookie，并在后续请求中将它们全部发送给服务器。</li>
</ul>
</li>
<li><strong>Cookie 支持中文传输吗？</strong><ul>
<li><strong>回答</strong>：<strong>在大多数现代服务器和浏览器中都支持。</strong> 在早期的 Servlet 容器（如 Tomcat 8.0 之前），Cookie 不能直接存储中文，需要手动进行 URL 编码（<code>URLEncoder</code>）和解码（<code>URLDecoder</code>）。<strong>在 Tomcat 8.0 及以后版本</strong>，容器默认支持 UTF-8 编码，可以直接存储中文。</li>
</ul>
</li>
<li><strong>Cookie 的过期时间如何设置？</strong><ul>
<li><strong>回答</strong>：通过 <code>response.addCookie(cookie)</code> 方法，并调用 <code>cookie.setMaxAge(int expiry)</code> 方法来设置。<ul>
<li><code>expiry &gt; 0</code>：表示 Cookie 将被<strong>持久化</strong>到客户端硬盘，有效期为 <code>expiry</code> 秒。即使浏览器关闭，Cookie 依然存在，直到过期。</li>
<li><code>expiry = 0</code>：表示<strong>立即删除</strong>该 Cookie。常用于退出登录功能。</li>
<li><code>expiry &lt; 0</code>：<strong>默认值</strong>。表示 Cookie 只在内存中存在，当<strong>浏览器关闭时</strong>，该 Cookie 就会被删除。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-Cookie-的特点"><a href="#2-Cookie-的特点" class="headerlink" title="2. Cookie 的特点"></a>2. Cookie 的特点</h4><ul>
<li><strong>存储位置</strong>：存储在客户端（浏览器）。</li>
<li><strong>大小限制</strong>：单个 Cookie 最大约 4KB。</li>
<li><strong>数量限制</strong>：一个服务器最多可以向一个浏览器保存 20 个 Cookie，一个浏览器最多可以保存 300 个 Cookie（这些是早期的规范，现代浏览器已放宽，但仍有限制）。</li>
<li><strong>安全性</strong>：数据以明文形式存储，且容易被用户修改，安全性较差。</li>
</ul>
<h4 id="3-Cookie-案例：获取上一次访问时间"><a href="#3-Cookie-案例：获取上一次访问时间" class="headerlink" title="3. Cookie 案例：获取上一次访问时间"></a>3. Cookie 案例：获取上一次访问时间</h4><p>这个案例是经典的 Cookie 用法。</p>
<ul>
<li><strong>首次访问</strong>：服务器接收请求，判断 Cookie 中没有记录上次访问时间。服务器创建一个新的 Cookie，存储当前时间，并将其发送给浏览器。</li>
<li><strong>再次访问</strong>：浏览器自动将上次存储的 Cookie 发送给服务器。服务器读取 Cookie，获取上次访问时间，并将其显示给用户。然后，服务器可以更新 Cookie 的时间，再次发送给浏览器。</li>
</ul>
<h3 id="三、服务器端会话：HttpSession"><a href="#三、服务器端会话：HttpSession" class="headerlink" title="三、服务器端会话：HttpSession"></a>三、服务器端会话：HttpSession</h3><p><strong>核心概念</strong>：Session 是服务器端为每个客户端创建的一个对象，用于在一次会话的多个请求之间存储和共享数据。</p>
<h4 id="1-Session-的快速使用"><a href="#1-Session-的快速使用" class="headerlink" title="1. Session 的快速使用"></a>1. Session 的快速使用</h4><ul>
<li><strong>获取对象</strong>：通过 <code>HttpServletRequest</code> 对象的 <code>getSession()</code> 方法来获取 <code>HttpSession</code> 对象。</li>
<li><strong>使用对象（域对象）</strong>：Session 是一个<strong>域对象</strong>，提供了以下方法：<ul>
<li><code>void setAttribute(String name, Object value)</code>：将数据以键值对形式存储到 Session 中。</li>
<li><code>Object getAttribute(String name)</code>：根据键名获取存储的数据。</li>
<li><code>void removeAttribute(String name)</code>：根据键名删除存储的数据。</li>
</ul>
</li>
</ul>
<h4 id="2-Session-的失效时间"><a href="#2-Session-的失效时间" class="headerlink" title="2. Session 的失效时间"></a>2. Session 的失效时间</h4><ul>
<li><p><strong>服务器关闭</strong>：当服务器关闭时，所有 Session 对象都会被销毁。</p>
</li>
<li><p><strong>手动失效</strong>：调用 <code>session.invalidate()</code> 方法，可以立即强制 Session 失效。常用于用户退出登录。</p>
</li>
<li><p><strong>默认失效时间</strong>：默认情况下，Session 有一个超时时间，通常是 30 分钟。如果客户端在 30 分钟内没有向服务器发送任何请求，Session 就会自动失效。这个时间可以在 <code>web.xml</code> 中配置。</p>
</li>
<li><p>对的 👍，在 **Java Web 应用（Servlet 容器，比如 Tomcat）**里，<code>Session</code> 的默认失效时间通常是 <strong>30 分钟</strong>。</p>
<p>要修改它，可以在 <code>web.xml</code> 中配置 <code>&lt;session-config&gt;</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- session 过期时间设置（单位：分钟） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>60<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>📌 说明：</p>
<ul>
<li><code>60</code> 表示 Session 在 <strong>60 分钟</strong>无请求时会自动失效。</li>
<li>默认值是 <strong>30</strong> 分钟，如果不配置，就走默认。</li>
<li>这个配置对所有用户 Session 都生效。</li>
</ul>
<h3 id="🔧-在代码里动态设置（单个-Session）"><a href="#🔧-在代码里动态设置（单个-Session）" class="headerlink" title="🔧 在代码里动态设置（单个 Session）"></a>🔧 在代码里动态设置（单个 Session）</h3><p>除了在 <code>web.xml</code> 里全局配置，还可以针对某个用户的 Session 动态修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">session.setMaxInactiveInterval(<span class="number">120</span> * <span class="number">60</span>); <span class="comment">// 单位：秒，这里是 2 小时</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔧-特殊情况"><a href="#🔧-特殊情况" class="headerlink" title="🔧 特殊情况"></a>🔧 特殊情况</h3><ul>
<li>如果 <code>session-timeout</code> 设置为 <strong>0</strong> → Session 永不超时（危险 ⚠️，容易导致内存泄露）。</li>
<li>如果设置为 <strong>负数</strong>（如 -1） → 表示 Session 仅在浏览器关闭时销毁（有些容器支持，有些不支持。</li>
</ul>
<h4 id="3-Session-的特点"><a href="#3-Session-的特点" class="headerlink" title="3. Session 的特点"></a>3. Session 的特点</h4><ul>
<li><strong>存储位置</strong>：存储在服务器端。</li>
<li><strong>大小限制</strong>：可以存储任意类型、任意大小的数据（受限于服务器内存）。</li>
<li><strong>安全性</strong>：由于数据存储在服务器，客户端只传递一个 Session ID，安全性相对较高。</li>
</ul>
<h4 id="4-面试题：Cookie-和-Session-的区别？"><a href="#4-面试题：Cookie-和-Session-的区别？" class="headerlink" title="4. 面试题：Cookie 和 Session 的区别？"></a>4. 面试题：Cookie 和 Session 的区别？</h4><ul>
<li><strong>存储位置</strong>：Cookie 存储在<strong>客户端</strong>，Session 存储在<strong>服务器端</strong>。</li>
<li><strong>数据大小</strong>：Cookie 的大小<strong>有限制</strong>（约 4KB），Session 的大小<strong>没有限制</strong>。</li>
<li><strong>安全性</strong>：Session <strong>相对安全</strong>，Cookie <strong>相对不安全</strong>。因为 Session ID 难以被猜测，而 Cookie 存储的数据是明文。</li>
<li><strong>服务器开销</strong>：Session 会占用服务器内存，在高并发场景下可能成为性能瓶颈；而 Cookie 不占用服务器资源。</li>
</ul>
<h3 id="四、Servlet-三大域对象的关系（按照你的逻辑）"><a href="#四、Servlet-三大域对象的关系（按照你的逻辑）" class="headerlink" title="四、Servlet 三大域对象的关系（按照你的逻辑）"></a>四、Servlet 三大域对象的关系（按照你的逻辑）</h3><p><strong>域对象</strong>（Scope Object）是指那些可以用来在不同组件之间共享数据的对象。Servlet 规范提供了三个这样的对象，它们的生命周期不同，从而决定了数据的共享范围。</p>
<ul>
<li><strong>request 域</strong>：生命周期最短。数据只能在<strong>一次请求-响应</strong>的周期内共享。即使请求被转发（forward），数据也依然可见。</li>
<li><strong>session 域</strong>：生命周期中等。数据可以在<strong>一次会话</strong>（多个请求）之间共享。只要浏览器不关闭，且 Session 未超时或失效，数据就一直存在。</li>
<li><strong>servletContext 域</strong>：生命周期最长。数据可以在<strong>整个 Web 应用</strong>中共享。从 Web 应用启动到关闭，数据都一直存在。</li>
</ul>
<p><strong>三大域对象之间的关系是包含关系，即 request &lt; session &lt; servletContext。</strong></p>
<ul>
<li><strong>request 包含于 session</strong>：一个 Session 中可以有多个请求。</li>
<li><strong>session 包含于 servletContext</strong>：一个 Web 应用（ServletContext）中可以有多个 Session。</li>
</ul>
<p>这个关系图清晰地展示了它们各自的生命周期和数据共享范围，是理解 Servlet 域对象的关键。</p>
<p>啊哈～你这个场景就是 <strong>同一个库的两个版本必须共存</strong>，典型的 “深度 JAR hell” 🚨。<br> 比如：</p>
<ul>
<li>你的系统用到 <strong>老版本 log4j</strong>，</li>
<li>但某个第三方库硬性依赖 <strong>新版本 log4j</strong>。</li>
</ul>
<p>这时候如果放到同一个 classpath 里，肯定会冲突。解决思路主要有三类：</p>
<hr>
<h2 id="✅-两个版本-JAR-共存的解决方案"><a href="#✅-两个版本-JAR-共存的解决方案" class="headerlink" title="✅ 两个版本 JAR 共存的解决方案"></a>✅ 两个版本 JAR 共存的解决方案</h2><h3 id="1-ClassLoader-隔离（推荐方式）"><a href="#1-ClassLoader-隔离（推荐方式）" class="headerlink" title="1. ClassLoader 隔离（推荐方式）"></a>1. <strong>ClassLoader 隔离</strong>（推荐方式）</h3><p>利用 <strong>不同的类加载器</strong> 来隔离两个版本的依赖，让它们互不干扰。</p>
<ul>
<li><p><strong>Web 容器隔离</strong>：</p>
<ul>
<li>把一个版本放在 <code>WEB-INF/lib</code>，另一个放在全局 <code>lib/ext</code>。</li>
<li>通过 parent-first &#x2F; parent-last 策略控制加载。</li>
</ul>
</li>
<li><p><strong>自定义 ClassLoader</strong>：</p>
<ul>
<li><p>用 <code>URLClassLoader</code> 指定不同版本 JAR 的路径。</p>
</li>
<li><p>哪个模块需要哪个版本，就用哪个 ClassLoader。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">URLClassLoader loaderV1 = new URLClassLoader(</span><br><span class="line">    new URL[]&#123; new File(&quot;lib/lib-old.jar&quot;).toURI().toURL() &#125;,</span><br><span class="line">    null // 不委托父加载器</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">URLClassLoader loaderV2 = new URLClassLoader(</span><br><span class="line">    new URL[]&#123; new File(&quot;lib/lib-new.jar&quot;).toURI().toURL() &#125;,</span><br><span class="line">    null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; clazz1 = loaderV1.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">Class&lt;?&gt; clazz2 = loaderV2.loadClass(&quot;com.example.MyClass&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>👉 OSGi、Spring Boot 的 <strong>ClassLoader 层级</strong>就是用这种方法解决多版本依赖的。</p>
<hr>
<h3 id="2-包重定位（Shading-Relocation）"><a href="#2-包重定位（Shading-Relocation）" class="headerlink" title="2. 包重定位（Shading &#x2F; Relocation）"></a>2. <strong>包重定位（Shading &#x2F; Relocation）</strong></h3><p>把其中一个版本的包路径 <strong>改名</strong>，让 JVM 认为它是完全不同的类库。</p>
<ul>
<li><p>工具：</p>
<ul>
<li><code>jarjar</code></li>
<li>Maven Shade（即使你不用 Maven，也可以单独跑插件）</li>
<li>Gradle Shadow</li>
</ul>
</li>
<li><p>原理：自动把 <code>org.apache.commons</code> 改成 <code>myproject.shaded.org.apache.commons</code>。</p>
</li>
<li><p>示例（JarJar 规则）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule org.apache.log4j.** com.myapp.shaded.log4j.@1</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样，项目就能同时用 <code>log4j-1.2</code> 和 <code>log4j-2.x</code>。</p>
<hr>
<h3 id="3-服务解耦-模块化"><a href="#3-服务解耦-模块化" class="headerlink" title="3. 服务解耦 &#x2F; 模块化"></a>3. <strong>服务解耦 &#x2F; 模块化</strong></h3><p>如果两个版本都要在 <strong>同一个 JVM 里用</strong>，但 ClassLoader 太麻烦：</p>
<ul>
<li><strong>拆分成微服务 &#x2F; 子进程</strong>，让不同进程使用不同版本的依赖。</li>
<li>或者在 <strong>Java 9+ 模块系统 (JPMS)</strong> 下，给不同模块声明不同依赖，避免直接冲突。</li>
</ul>
<hr>
<h2 id="🚀-实际建议"><a href="#🚀-实际建议" class="headerlink" title="🚀 实际建议"></a>🚀 实际建议</h2><ul>
<li>如果你是 <strong>自己开发的项目</strong> → 用 <strong>包重定位</strong> 比较简单。</li>
<li>如果是 <strong>插件式系统 &#x2F; 容器运行</strong> → 用 <strong>ClassLoader 隔离</strong>。</li>
<li>如果是 <strong>重量级系统</strong>（比如需要不同版本的 JDBC 驱动） → 拆进程更干净。</li>
</ul>
<hr>
<p>要不要我帮你写一个 <strong>最小可运行的 Java Demo</strong>（两个版本 JAR 同时运行，通过 ClassLoader 隔离）？这样你可以直接跑起来看看效果。</p>
<p>好的，我将根据您提供的这份详尽的笔记，以更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p>
<hr>
<h3 id="一、CSS-选择器概述：精准定位网页元素"><a href="#一、CSS-选择器概述：精准定位网页元素" class="headerlink" title="一、CSS 选择器概述：精准定位网页元素"></a>一、CSS 选择器概述：精准定位网页元素</h3><p><strong>选择器</strong>是 CSS 的核心，它用于<strong>精确地选择 HTML 文档中的元素</strong>，并为其应用样式。掌握不同类型的选择器及其组合，是高效编写 CSS 代码的关键。</p>
<h3 id="二、基础选择器-Basic-Selectors"><a href="#二、基础选择器-Basic-Selectors" class="headerlink" title="二、基础选择器 (Basic Selectors)"></a>二、基础选择器 (Basic Selectors)</h3><p>基础选择器用于根据最基本的属性（标签、类、ID）来选择元素。</p>
<h4 id="1-标签选择器-Type-Selector"><a href="#1-标签选择器-Type-Selector" class="headerlink" title="1. 标签选择器 (Type Selector)"></a>1. 标签选择器 (Type Selector)</h4><ul>
<li><p><strong>原理</strong>：根据元素的<strong>标签名称</strong>来匹配。</p>
</li>
<li><p><strong>优点</strong>：简单、直接，可以一次性选中所有同类型的元素。</p>
</li>
<li><p><strong>缺点</strong>：过于笼统，无法对个别元素进行精确控制。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123; color: red; &#125; /* 所有&lt;div&gt;标签的字体颜色都为红色 */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-类选择器-Class-Selector-1"><a href="#2-类选择器-Class-Selector-1" class="headerlink" title="2. 类选择器 (Class Selector)"></a>2. 类选择器 (Class Selector)</h4><ul>
<li><p><strong>原理</strong>：根据元素的 <code>class</code> 属性值来匹配。</p>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>高度复用</strong>：可以在多个元素上使用同一个类名。</li>
<li><strong>灵活</strong>：一个元素可以拥有多个类名，用空格分隔。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.cl1 &#123; color: red; &#125; /* 所有class属性包含cl1的元素，字体颜色为红色 */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-ID-选择器-ID-Selector-1"><a href="#3-ID-选择器-ID-Selector-1" class="headerlink" title="3. ID 选择器 (ID Selector)"></a>3. ID 选择器 (ID Selector)</h4><ul>
<li><p><strong>原理</strong>：根据元素的 <code>id</code> 属性值来匹配。</p>
</li>
<li><p><strong>优点</strong>：<strong>唯一性</strong>，精确地选中文档中唯一的元素。</p>
</li>
<li><p><strong>缺点</strong>：不具复用性，一个 ID 在文档中只能出现一次。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#p1 &#123; color: red; &#125; /* id为p1的唯一元素，字体颜色为红色 */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-通配符选择器-Universal-Selector"><a href="#4-通配符选择器-Universal-Selector" class="headerlink" title="4. 通配符选择器 (Universal Selector)"></a>4. 通配符选择器 (Universal Selector)</h4><ul>
<li><p><strong>原理</strong>：匹配文档中<strong>所有</strong>的元素。</p>
</li>
<li><p><strong>优点</strong>：可以快速设置全局样式，常用于重置浏览器默认样式。</p>
</li>
<li><p><strong>缺点</strong>：性能开销大，因为浏览器需要遍历所有元素，应谨慎使用。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123; margin: 0; padding: 0; &#125; /* 清除所有元素的内外边距 */</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="三、组合选择器-Combinators"><a href="#三、组合选择器-Combinators" class="headerlink" title="三、组合选择器 (Combinators)"></a>三、组合选择器 (Combinators)</h3><p>组合选择器通过符号连接多个选择器，根据元素之间的关系来匹配。</p>
<h4 id="1-交集选择器-Intersection-Selector"><a href="#1-交集选择器-Intersection-Selector" class="headerlink" title="1. 交集选择器 (Intersection Selector)"></a>1. 交集选择器 (Intersection Selector)</h4><ul>
<li><p><strong>原理</strong>：同时满足多个选择器条件的元素。</p>
</li>
<li><p><strong>语法</strong>：<code>selector1selector2 &#123; ... &#125;</code>，中间<strong>没有空格</strong>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.cl1 &#123; color: red; &#125; /* 既是&lt;div&gt;标签，又拥有cl1这个class的元素 */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-并集选择器-Union-Selector"><a href="#2-并集选择器-Union-Selector" class="headerlink" title="2. 并集选择器 (Union Selector)"></a>2. 并集选择器 (Union Selector)</h4><ul>
<li><p><strong>原理</strong>：匹配所有满足其中任意一个选择器条件的元素。</p>
</li>
<li><p><strong>语法</strong>：<code>selector1, selector2 &#123; ... &#125;</code>，以<strong>逗号</strong>分隔。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, p &#123; color: red; &#125; /* 所有&lt;a&gt;标签和所有&lt;p&gt;标签的字体颜色都为红色 */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-子选择器-Child-Selector"><a href="#3-子选择器-Child-Selector" class="headerlink" title="3. 子选择器 (Child Selector)"></a>3. 子选择器 (Child Selector)</h4><ul>
<li><p><strong>原理</strong>：匹配<strong>直接</strong>子元素。</p>
</li>
<li><p><strong>语法</strong>：<code>parent &gt; child &#123; ... &#125;</code>，以 <code>&gt;</code> 符号分隔。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#outer &gt; span &#123; color: red; &#125; /* 只选中id为outer的&lt;div&gt;的直接子元素&lt;span&gt; */</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-后代选择器-Descendant-Selector"><a href="#4-后代选择器-Descendant-Selector" class="headerlink" title="4. 后代选择器 (Descendant Selector)"></a>4. 后代选择器 (Descendant Selector)</h4><ul>
<li><p><strong>原理</strong>：匹配所有位于祖先元素内部的<strong>所有后代</strong>元素。</p>
</li>
<li><p><strong>语法</strong>：<code>ancestor descendant &#123; ... &#125;</code>，以<strong>空格</strong>分隔。</p>
</li>
<li><p><strong>示例</strong>：</p>
<p>CSS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#outer span &#123; color: red; &#125; /* 选中id为outer的&lt;div&gt;内部的所有&lt;span&gt;，无论嵌套多深 */</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="四、属性选择器-Attribute-Selectors"><a href="#四、属性选择器-Attribute-Selectors" class="headerlink" title="四、属性选择器 (Attribute Selectors)"></a>四、属性选择器 (Attribute Selectors)</h3><p>属性选择器根据元素的属性及其值来匹配。</p>
<ul>
<li><strong>[attribute]</strong>：匹配具有该属性的元素。<ul>
<li>示例：<code>[class]</code> 匹配所有具有 <code>class</code> 属性的元素。</li>
</ul>
</li>
<li><strong>[attribute&#x3D;”value”]</strong>：匹配属性值完全相等的元素。<ul>
<li>示例：<code>[type=&quot;text&quot;]</code> 匹配 <code>type</code> 属性值恰好为 <code>&quot;text&quot;</code> 的元素。</li>
</ul>
</li>
<li><strong>[attribute~&#x3D;”value”]</strong>：匹配属性值中包含该<strong>独立单词</strong>的元素。</li>
<li><strong>[attribute^&#x3D;”value”]</strong>：匹配属性值以该字符串<strong>开头</strong>的元素。</li>
<li><strong>[attribute$&#x3D;”value”]</strong>：匹配属性值以该字符串<strong>结尾</strong>的元素。</li>
<li><strong>[attribute*&#x3D;”value”]</strong>：匹配属性值中包含该字符串的<strong>任意位置</strong>的元素。</li>
</ul>
<hr>
<h3 id="五、伪类与伪元素选择器-Pseudo-class-Pseudo-element-Selectors"><a href="#五、伪类与伪元素选择器-Pseudo-class-Pseudo-element-Selectors" class="headerlink" title="五、伪类与伪元素选择器 (Pseudo-class &amp; Pseudo-element Selectors)"></a>五、伪类与伪元素选择器 (Pseudo-class &amp; Pseudo-element Selectors)</h3><ul>
<li><strong>伪类</strong>：用<strong>一个冒号 :</strong>，表示元素在<strong>特定状态</strong>下的样式。<ul>
<li><strong>:link</strong>：未访问的链接。</li>
<li><strong>:visited</strong>：已访问的链接。</li>
<li><strong>:hover</strong>：鼠标悬停状态。</li>
<li><strong>:active</strong>：被点击状态。</li>
<li><strong>:focus</strong>：获得焦点状态（常用于表单）。</li>
</ul>
</li>
<li><strong>伪元素</strong>：用<strong>两个冒号 ::</strong>，表示元素的<strong>特定部分</strong>。<ul>
<li><strong>::before</strong> 和 <strong>::after</strong>：在元素内容的前后插入内容。</li>
<li><strong>::first-line</strong>：元素的文本第一行。</li>
<li><strong>::first-letter</strong>：元素的文本第一个字母。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="六、选择器优先级-Specificity"><a href="#六、选择器优先级-Specificity" class="headerlink" title="六、选择器优先级 (Specificity)"></a>六、选择器优先级 (Specificity)</h3><p>这是 CSS 的核心机制，决定了当多个规则应用到同一个元素时，哪一个会生效。</p>
<ul>
<li><strong>计算规则</strong>：优先级由<strong>选择器的类型</strong>和<strong>数量</strong>决定。<ol>
<li><strong>行内样式</strong>：优先级最高，为 <code>1000</code>。</li>
<li><strong>ID 选择器</strong>：优先级为 <code>100</code>。</li>
<li><strong>类、属性、伪类选择器</strong>：优先级为 <code>10</code>。</li>
<li><strong>元素、伪元素选择器</strong>：优先级为 <code>1</code>。</li>
<li><strong>通用选择器 *</strong>：优先级为 <code>0</code>。</li>
</ol>
</li>
<li><strong>!important</strong>：最高优先级，但会破坏层叠机制，应<strong>避免使用</strong>。</li>
</ul>
<p>如何计算：</p>
<p>将每个选择器的优先级数字相加，得到一个最终的权重值。权重值越高的规则越优先。</p>
<ul>
<li>示例：<ul>
<li><code>p</code>：权重 <code>1</code>。</li>
<li><code>.cl1</code>：权重 <code>10</code>。</li>
<li><code>div.cl1</code>：权重 <code>1 + 10 = 11</code>。</li>
<li><code>#p1</code>：权重 <code>100</code>。</li>
<li><code>#outer span</code>：权重 <code>100 + 1 = 101</code>。</li>
</ul>
</li>
</ul>
<p><strong>!important</strong> 会凌驾于所有这些规则之上。当你遇到样式不生效的问题时，首先要检查优先级，其次是是否有 <code>!important</code> 的存在。</p>
<p>好的，让我们来详细、深入地解释 <strong>BOM</strong> 和 <strong>DOM</strong> 这两个 JavaScript 在浏览器中操作网页的核心概念。</p>
<hr>
<h3 id="BOM-Browser-Object-Model"><a href="#BOM-Browser-Object-Model" class="headerlink" title="BOM (Browser Object Model)"></a>BOM (Browser Object Model)</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p><strong>BOM</strong>，即<strong>浏览器对象模型</strong>，是 JavaScript 用于<strong>操作浏览器窗口</strong>的一套 API。它没有统一的标准，而是由各个浏览器厂商各自实现的。BOM 的核心是 <code>window</code> 对象，它既代表了浏览器窗口本身，也是 JavaScript 全局作用域的唯一对象。</p>
<h4 id="2-BOM-的核心对象与功能"><a href="#2-BOM-的核心对象与功能" class="headerlink" title="2. BOM 的核心对象与功能"></a>2. BOM 的核心对象与功能</h4><p>BOM 提供了以下关键对象，用于与浏览器进行交互：</p>
<ul>
<li><strong>window 对象</strong>：<ul>
<li><strong>全局对象</strong>：<code>window</code> 是 JavaScript 的全局对象，所有全局变量和函数都是 <code>window</code> 对象的属性和方法。</li>
<li><strong>窗口控制</strong>：<code>window.open()</code> (打开新窗口), <code>window.close()</code> (关闭当前窗口)。</li>
<li><strong>定时器</strong>：<code>setTimeout()</code> 和 <code>setInterval()</code>，用于延迟或重复执行代码。</li>
<li><strong>导航与位置</strong>：<code>window.location</code>，用于获取和修改当前页面的 URL。</li>
</ul>
</li>
<li><strong>location 对象</strong>：<ul>
<li><strong>URL 信息</strong>：提供了当前 URL 的详细信息，如 <code>location.href</code> (完整 URL), <code>location.protocol</code> (协议), <code>location.hostname</code> (主机名), <code>location.pathname</code> (路径)。</li>
<li><strong>页面跳转</strong>：<code>location.href = &#39;new_url&#39;</code> 或 <code>location.assign(&#39;new_url&#39;)</code> (有历史记录), <code>location.replace(&#39;new_url&#39;)</code> (不留历史记录), <code>location.reload()</code> (刷新页面)。</li>
</ul>
</li>
<li><strong>history 对象</strong>：<ul>
<li><strong>历史记录</strong>：提供了对浏览器历史记录的访问。</li>
<li><strong>导航</strong>：<code>history.back()</code> (后退), <code>history.forward()</code> (前进), <code>history.go(n)</code> (前进或后退 n 页)。</li>
</ul>
</li>
<li><strong>navigator 对象</strong>：<ul>
<li><strong>浏览器信息</strong>：提供了关于浏览器本身的信息，如 <code>navigator.userAgent</code> (用户代理字符串), <code>navigator.platform</code> (操作系统), <code>navigator.onLine</code> (是否在线)。</li>
</ul>
</li>
<li><strong>screen 对象</strong>：<ul>
<li><strong>屏幕信息</strong>：提供了关于用户屏幕的信息，如 <code>screen.width</code> (屏幕宽度), <code>screen.height</code> (屏幕高度)。</li>
</ul>
</li>
</ul>
<h4 id="3-BOM-的特点"><a href="#3-BOM-的特点" class="headerlink" title="3. BOM 的特点"></a>3. BOM 的特点</h4><ul>
<li><strong>没有标准</strong>：BOM 没有 W3C 的正式标准，不同浏览器可能在实现上存在差异。</li>
<li><strong>以 window 为核心</strong>：所有 BOM 对象都是 <code>window</code> 对象的属性。</li>
</ul>
<hr>
<h3 id="DOM-Document-Object-Model"><a href="#DOM-Document-Object-Model" class="headerlink" title="DOM (Document Object Model)"></a>DOM (Document Object Model)</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h4><p><strong>DOM</strong>，即<strong>文档对象模型</strong>，是 JavaScript 用于<strong>操作 HTML 或 XML 文档</strong>的一套 API。它将整个 HTML 文档解析为一个<strong>树形结构</strong>，每个 HTML 标签、属性和文本都成为了树中的一个节点（Node）。DOM 是一个由 W3C 制定的标准。</p>
<h4 id="2-DOM-的核心对象与功能"><a href="#2-DOM-的核心对象与功能" class="headerlink" title="2. DOM 的核心对象与功能"></a>2. DOM 的核心对象与功能</h4><p>DOM 的核心是 <code>document</code> 对象，它是整个文档的入口。</p>
<ul>
<li><strong>document 对象</strong>：<ul>
<li><strong>DOM 树的根节点</strong>：代表整个 HTML 文档。</li>
<li><strong>元素获取</strong>：提供了多种方法来获取页面上的元素：<ul>
<li><code>document.getElementById(&#39;id&#39;)</code>：通过 ID 获取单个元素。</li>
<li><code>document.getElementsByClassName(&#39;class&#39;)</code>：通过类名获取元素集合。</li>
<li><code>document.getElementsByTagName(&#39;tag&#39;)</code>：通过标签名获取元素集合。</li>
<li><code>document.querySelector(&#39;css_selector&#39;)</code>：通过 CSS 选择器获取第一个匹配的元素。</li>
<li><code>document.querySelectorAll(&#39;css_selector&#39;)</code>：通过 CSS 选择器获取所有匹配的元素。</li>
</ul>
</li>
</ul>
</li>
<li><strong>元素节点（Element Nodes）</strong>：<ul>
<li><strong>操作元素</strong>：提供了操作 HTML 元素的方法和属性：<ul>
<li><code>element.innerHTML</code>：获取或设置元素的 HTML 内容。</li>
<li><code>element.style.color</code>：修改元素的行内样式。</li>
<li><code>element.setAttribute(&#39;attr&#39;, &#39;val&#39;)</code>：设置元素的属性。</li>
<li><code>element.addEventListener(&#39;event&#39;, handler)</code>：添加事件监听器。</li>
</ul>
</li>
</ul>
</li>
<li><strong>DOM 树操作</strong>：<ul>
<li><strong>创建</strong>：<code>document.createElement(&#39;tag&#39;)</code> (创建新元素)。</li>
<li><strong>添加</strong>：<code>parent.appendChild(child)</code> (添加子元素)。</li>
<li><strong>删除</strong>：<code>parent.removeChild(child)</code> (删除子元素)。</li>
<li><strong>替换</strong>：<code>parent.replaceChild(newChild, oldChild)</code> (替换子元素)。</li>
</ul>
</li>
</ul>
<h4 id="3-DOM-的特点"><a href="#3-DOM-的特点" class="headerlink" title="3. DOM 的特点"></a>3. DOM 的特点</h4><ul>
<li><strong>有标准</strong>：DOM 是由 W3C 制定的标准，因此在不同浏览器中的实现差异较小。</li>
<li><strong>树形结构</strong>：将 HTML 文档抽象为树形结构，使得我们可以通过编程的方式像操作树一样操作网页。</li>
</ul>
<hr>
<h3 id="BOM-和-DOM-的核心区别与联系"><a href="#BOM-和-DOM-的核心区别与联系" class="headerlink" title="BOM 和 DOM 的核心区别与联系"></a>BOM 和 DOM 的核心区别与联系</h3><table>
<thead>
<tr>
<th>特性</th>
<th>BOM (Browser Object Model)</th>
<th>DOM (Document Object Model)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>主要功能</strong></td>
<td><strong>操作浏览器窗口</strong></td>
<td><strong>操作网页文档内容</strong></td>
</tr>
<tr>
<td><strong>核心对象</strong></td>
<td><code>window</code></td>
<td><code>document</code></td>
</tr>
<tr>
<td><strong>标准化</strong></td>
<td>无统一标准（各浏览器实现不同）</td>
<td>有 W3C 标准</td>
</tr>
<tr>
<td><strong>层级关系</strong></td>
<td><code>window</code> 包含了 <code>location</code>, <code>history</code>, <code>navigator</code> 等，<strong>也包含了 document 对象</strong>。</td>
<td><code>document</code> 包含了 HTML 元素的树形结构。</td>
</tr>
</tbody></table>
<p>它们的关系：</p>
<p>BOM 是 DOM 的超集。window 对象是所有 JavaScript 对象的全局对象，它包含了 document 对象。换句话说，window.document 就是 document。因此，当我们使用 document 对象来操作网页时，实际上是通过 window 对象来访问的。</p>
<p>这个关系可以理解为：</p>
<p>window -&gt; 浏览器窗口</p>
<p>document -&gt; 窗口中加载的文档</p>
<p>掌握 BOM 和 DOM 是成为一个合格前端工程师的基础，它们是 JavaScript 驱动 Web 页面交互的两个最重要的工具。</p>
<p>好的，我将根据您提供的这份 JS 学习笔记，以一种更深入、更条理化的方式，逐一进行详细的展开和补充。这不仅是对知识点的梳理，也包含了其背后的原理和一些进阶用法，使其更具面试和实战价值。</p>
<hr>
<h3 id="一、JavaScript-中的数据类型"><a href="#一、JavaScript-中的数据类型" class="headerlink" title="一、JavaScript 中的数据类型"></a>一、JavaScript 中的数据类型</h3><h4 id="1-基础数据类型（原始数据类型）"><a href="#1-基础数据类型（原始数据类型）" class="headerlink" title="1. 基础数据类型（原始数据类型）"></a>1. 基础数据类型（原始数据类型）</h4><ul>
<li><p><strong>number 类型</strong>：</p>
<ul>
<li><strong>深入</strong>：JS 采用 IEEE 754 标准的双精度 64 位浮点数来表示所有数字。这意味着它<strong>没有单独的整数类型</strong>，所有数字都是浮点数。</li>
<li><code>NaN</code> (Not a Number)：表示非数字值。需要注意的是，<code>typeof NaN</code> 结果是 <code>number</code>。<code>NaN</code> 不等于自身，<code>NaN === NaN</code> 结果为 <code>false</code>。</li>
<li><code>Infinity</code>：表示正无穷大，<code>+Infinity</code> 和 <code>-Infinity</code> 分别表示正负无穷大。</li>
<li><code>0.1 + 0.2 !== 0.3</code>：由于浮点数表示的精度问题，这个经典问题需要注意。</li>
</ul>
</li>
<li><p><strong>boolean 类型</strong>：</p>
<ul>
<li><strong>深入</strong>：<code>true</code> 和 <code>false</code>。在条件判断中，所有数据类型都会被隐式转换为布尔值。</li>
</ul>
</li>
<li><p><strong>undefined 类型</strong>：</p>
<ul>
<li><strong>深入</strong>：表示一个<strong>未定义</strong>的变量或变量<strong>未被赋值</strong>。<code>typeof undefined</code> 结果为 <code>undefined</code>。它是一个值也是一个类型。</li>
<li><code>null</code>：与 <code>undefined</code> 的区别在于，<code>null</code> 是一种<strong>意图</strong>，表示变量被显式地赋予了“空”值。<code>typeof null</code> 结果为 <code>object</code>，这是一个历史遗留的 bug。</li>
</ul>
</li>
<li><p><strong>string 类型</strong>：</p>
<ul>
<li><p><strong>深入</strong>：JS 中<strong>没有字符类型</strong>。字符串是不可变的，一旦创建就不能修改。</p>
</li>
<li><p><strong>反引号（     ）</strong>：ES6 引入，支持<strong>模板字面量</strong>。它允许在字符串中嵌入变量和表达式，并支持多行书写，极大提升了字符串拼接的便利性。</p>
<p>JavaScript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = &quot;张三&quot;;</span><br><span class="line">console.log(`你好，我的名字是$&#123;name&#125;。`);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-数据类型转换"><a href="#2-数据类型转换" class="headerlink" title="2. 数据类型转换"></a>2. 数据类型转换</h4><ul>
<li><p><strong>转换为 number</strong>：<code>Number(value)</code></p>
<ul>
<li><strong>深入</strong>：会尝试将参数转换为数字。非数字字符串会返回 <code>NaN</code>。<code>null</code> 转为 <code>0</code>，<code>undefined</code> 转为 <code>NaN</code>。</li>
</ul>
</li>
<li><p><strong>转换为 boolean</strong>：<code>Boolean(value)</code></p>
<ul>
<li><strong>深入</strong>：所有能被转换为 <code>false</code> 的值被称为<strong>假值（Falsy Value）</strong>。</li>
<li><strong>假值列表</strong>：<code>0</code>, <code>-0</code>, <code>null</code>, <code>false</code>, <code>NaN</code>, <code>undefined</code>, <code>&#39;&#39;</code> (空字符串)。</li>
<li><strong>真值（Truthy Value）</strong>：除上述假值外，所有值都是真值，包括空数组 <code>[]</code> 和空对象 <code>&#123;&#125;</code>。</li>
</ul>
</li>
<li><p><strong>转换为 string</strong>：<code>String(value)</code> 或 <code>value + &#39;&#39;</code></p>
<ul>
<li><strong>深入</strong>：<code>value + &#39;&#39;</code> 是最常用的技巧，利用了 JS 的隐式类型转换。</li>
</ul>
</li>
<li><p><strong>parseInt 和 parseFloat</strong>：</p>
<ul>
<li><p><strong>深入</strong>：这两个函数专门用于从<strong>字符串开头</strong>解析出数字。</p>
</li>
<li><p><code>parseInt</code>：解析<strong>整数</strong>。遇到第一个非数字字符就停止解析。</p>
<p>JavaScript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&quot;100px&quot;); // 100</span><br><span class="line">parseInt(&quot;a100&quot;);  // NaN</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>parseFloat</code>：解析<strong>浮点数</strong>。遇到第一个非数字字符（除了小数点）就停止解析。</p>
</li>
</ul>
</li>
</ul>
<h3 id="二、JavaScript-中的弹出框"><a href="#二、JavaScript-中的弹出框" class="headerlink" title="二、JavaScript 中的弹出框"></a>二、JavaScript 中的弹出框</h3><p>这些是浏览器提供的 BOM API。</p>
<ul>
<li><code>alert(message)</code>：<strong>警告框</strong>。阻塞式，显示一条消息，不返回任何值。</li>
<li><code>prompt(message, default_value)</code>：<strong>询问框</strong>。返回用户输入的字符串，如果点击“取消”则返回 <code>null</code>。</li>
<li><code>confirm(message)</code>：<strong>确认框</strong>。返回一个布尔值，用户点击“确定”返回 <code>true</code>，点击“取消”返回 <code>false</code>。</li>
</ul>
<h3 id="三、条件运算符：-和"><a href="#三、条件运算符：-和" class="headerlink" title="三、条件运算符：== 和 ==="></a>三、条件运算符：<code>==</code> 和 <code>===</code></h3><ul>
<li><p><strong>&#x3D;&#x3D;（宽松相等）</strong>：只比较<strong>值</strong>，不比较类型。它在比较前会进行<strong>隐式类型转换</strong>。</p>
<p>JavaScript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 == &quot;5&quot;;     // true</span><br><span class="line">null == undefined; // true</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x3D;&#x3D;&#x3D;（严格相等）</strong>：既比较<strong>值</strong>，也比较<strong>类型</strong>。不会进行类型转换。</p>
<p>JavaScript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 === &quot;5&quot;;    // false</span><br><span class="line">null === undefined; // false</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>面试建议</strong>：在实际开发中，<strong>强烈建议使用 &#x3D;&#x3D;&#x3D;</strong>，以避免不必要的类型转换带来的 bug。</p>
</li>
</ul>
<h3 id="四、字符串和数组"><a href="#四、字符串和数组" class="headerlink" title="四、字符串和数组"></a>四、字符串和数组</h3><ul>
<li><strong>字符串</strong>：<ul>
<li><strong>深入</strong>：<code>string</code> 是一个<strong>对象</strong>，拥有 <code>length</code> 属性和许多方法（如 <code>split()</code>, <code>slice()</code>, <code>indexOf()</code> 等），但它<strong>不可变</strong>。</li>
</ul>
</li>
<li><strong>数组</strong>：<ul>
<li><strong>特点</strong>：<ol>
<li><strong>动态长度</strong>：JS 数组的长度是可变的，你可以随时添加或删除元素。</li>
<li><strong>异构性</strong>：一个数组可以存放不同数据类型的元素，如 <code>[1, &quot;hello&quot;, true]</code>。</li>
</ol>
</li>
<li><strong>方法</strong>：<ul>
<li><code>push()</code>, <code>pop()</code>：在数组<strong>末尾</strong>添加和删除。</li>
<li><code>unshift()</code>, <code>shift()</code>：在数组<strong>开头</strong>添加和删除。</li>
<li><code>splice()</code>：功能强大的方法，用于删除、替换或添加元素。</li>
<li><code>forEach()</code>, <code>map()</code>, <code>filter()</code>：常用的遍历方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="五、函数和对象"><a href="#五、函数和对象" class="headerlink" title="五、函数和对象"></a>五、函数和对象</h3><ul>
<li><strong>函数</strong>：<ul>
<li><strong>深入</strong>：在 JS 中，函数是<strong>一等公民（First-Class Citizens）</strong>。这意味着函数可以作为参数传递、作为返回值，也可以赋值给变量。</li>
</ul>
</li>
<li><strong>对象</strong>：<ul>
<li><strong>深入</strong>：JS 对象是<strong>键值对</strong>的集合。键是字符串，值可以是任意类型。</li>
<li><strong>访问属性</strong>：<ul>
<li>点语法：<code>obj.prop</code>。</li>
<li>中括号语法：<code>obj[&#39;prop&#39;]</code>。后者适用于键名包含特殊字符或动态键名的情况。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="六、定时器"><a href="#六、定时器" class="headerlink" title="六、定时器"></a>六、定时器</h3><ul>
<li><strong>setTimeout(callback, delay)</strong>：<ul>
<li><strong>用途</strong>：只执行<strong>一次</strong>。</li>
<li><strong>深入</strong>：<code>delay</code> 参数是<strong>最小延迟时间</strong>。由于 JS 是单线程的，如果主线程被阻塞，<code>callback</code> 的执行会延迟。</li>
</ul>
</li>
<li><strong>setInterval(callback, delay)</strong>：<ul>
<li><strong>用途</strong>：<strong>重复</strong>执行。</li>
<li><strong>深入</strong>：每次执行完回调函数后，<code>setInterval</code> 都会将下一个回调任务放入队列。</li>
</ul>
</li>
</ul>
<h3 id="七、ES6-新特性（重要）"><a href="#七、ES6-新特性（重要）" class="headerlink" title="七、ES6 新特性（重要）"></a>七、ES6 新特性（重要）</h3><ul>
<li><strong>let 和 const</strong>：<ul>
<li><strong>var 的问题</strong>：全局作用域，可以被重复声明，有变量提升。</li>
<li><strong>let</strong>：<strong>块级作用域</strong>（<code>&#123;&#125;</code> 内），不能重复声明，没有变量提升。</li>
<li><strong>const</strong>：<strong>块级作用域</strong>，用于声明<strong>常量</strong>。一旦声明，其引用地址不能改变。</li>
</ul>
</li>
<li><strong>字符串模板字面量</strong>：使用反引号（<code>     </code>）创建多行字符串和嵌入变量。</li>
<li><strong>箭头函数</strong>：<ul>
<li><strong>语法</strong>：<code>const func = (param) =&gt; &#123; ... &#125;</code>。</li>
<li><strong>this 指向</strong>：箭头函数<strong>没有自己的 this</strong>，它会捕获其所在上下文的 <code>this</code> 值。这解决了传统函数中 <code>this</code> 绑定复杂的问题。</li>
</ul>
</li>
<li><strong>可变参数</strong>：<code>...args</code>，用于函数接收不确定数量的参数。</li>
</ul>
<h3 id="八、DOM"><a href="#八、DOM" class="headerlink" title="八、DOM"></a>八、DOM</h3><ul>
<li><strong>什么是 DOM</strong>：<ul>
<li><strong>深入</strong>：DOM 是浏览器将 HTML 文档解析后生成的<strong>树形结构</strong>，是 JavaScript 操作网页的接口。HTML 文件是文本，DOM 是一个对象，可以被 JS 编程控制。</li>
</ul>
</li>
<li><strong>DOM 操作</strong>：<ul>
<li><strong>获取标签对象</strong>：<ul>
<li><code>document.getElementById()</code></li>
<li><code>document.getElementsByClassName()</code></li>
<li><code>document.querySelector()</code> (更常用)</li>
</ul>
</li>
<li><strong>操作属性</strong>：<ul>
<li><code>element.attribute = &#39;...&#39;</code> (例如 <code>element.style.color = &#39;red&#39;</code>)</li>
<li><code>element.setAttribute(&#39;attr&#39;, &#39;value&#39;)</code></li>
</ul>
</li>
<li><strong>操作内容</strong>：<ul>
<li><code>element.innerHTML</code>：获取或设置元素的 HTML 内容（包括子标签）。</li>
<li><code>element.textContent</code>：获取或设置元素的文本内容（不含 HTML）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>好的，我将根据您提供的这份详尽的 Web 技术笔记，以一种更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p>
<hr>
<h3 id="一、Web-架构与网络基础"><a href="#一、Web-架构与网络基础" class="headerlink" title="一、Web 架构与网络基础"></a>一、Web 架构与网络基础</h3><h4 id="1-常见的软件架构"><a href="#1-常见的软件架构" class="headerlink" title="1. 常见的软件架构"></a>1. 常见的软件架构</h4><ul>
<li><strong>B&#x2F;S 架构 (Browser&#x2F;Server)</strong>：<ul>
<li><strong>概念</strong>：浏览器和服务器架构。客户端只需安装一个通用的浏览器，业务逻辑和数据都存储在服务器端。</li>
<li><strong>优点</strong>：易于维护和升级，跨平台性好。</li>
<li><strong>缺点</strong>：对网络依赖性强，用户体验可能不如 C&#x2F;S 架构。</li>
</ul>
</li>
<li><strong>C&#x2F;S 架构 (Client&#x2F;Server)</strong>：<ul>
<li><strong>概念</strong>：客户端和服务器架构。客户端需要安装专用的应用程序，例如桌面 QQ、微信等。</li>
<li><strong>优点</strong>：用户体验好，响应速度快，可以离线使用。</li>
<li><strong>缺点</strong>：维护和升级复杂，需要为不同平台开发不同版本。</li>
</ul>
</li>
</ul>
<h4 id="2-网络编程三要素"><a href="#2-网络编程三要素" class="headerlink" title="2. 网络编程三要素"></a>2. 网络编程三要素</h4><p>这是所有网络通信的基础，理解这三点至关重要。</p>
<ul>
<li><strong>IP 地址</strong>：设备在网络上的唯一标识，类似于你的家庭住址。它用于在网络中定位到一台具体的计算机。</li>
<li><strong>端口号</strong>：应用程序在计算机上的唯一标识，类似于你家里的电话号码或门牌号。一台计算机上可以运行多个应用程序，端口号用于区分它们。</li>
<li><strong>协议</strong>：通信规则。就像人与人交流需要遵循共同的语言一样，网络设备之间通信也需要遵循特定的协议，如 HTTP、FTP、TCP 等。</li>
</ul>
<h4 id="3-资源的分类"><a href="#3-资源的分类" class="headerlink" title="3. 资源的分类"></a>3. 资源的分类</h4><ul>
<li><strong>静态资源</strong>：<ul>
<li><strong>特点</strong>：内容固定，无需服务器端处理，可由浏览器直接解析。</li>
<li><strong>原理</strong>：当浏览器请求静态资源时，Web 服务器直接从文件系统中读取文件并返回。</li>
<li><strong>示例</strong>：HTML、CSS、JS、图片等。</li>
</ul>
</li>
<li><strong>动态资源</strong>：<ul>
<li><strong>特点</strong>：内容动态生成，需要服务器端处理后才能返回给浏览器。</li>
<li><strong>原理</strong>：当浏览器请求动态资源时，Web 服务器将请求交给<strong>后台程序</strong>（如 Servlet 容器），后台程序执行业务逻辑，生成静态内容（如 HTML、JSON 等），然后返回给服务器，服务器再返回给浏览器。</li>
<li><strong>示例</strong>：Servlet、JSP、PHP、ASP 等。</li>
</ul>
</li>
</ul>
<h3 id="二、Web-服务器"><a href="#二、Web-服务器" class="headerlink" title="二、Web 服务器"></a>二、Web 服务器</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>Web 服务器（也称为 <strong>Web 容器</strong>）是一个软件，它负责处理 HTTP 请求，并提供静态资源和动态资源。它为动态资源（如 Servlet）提供了一个运行环境。</p>
<h4 id="2-常见的-Web-服务器"><a href="#2-常见的-Web-服务器" class="headerlink" title="2. 常见的 Web 服务器"></a>2. 常见的 Web 服务器</h4><ul>
<li><strong>Tomcat</strong>：Apache 基金组织开发，<strong>中小型的 JavaEE 服务器</strong>，<strong>免费</strong>且开源。它是一个<strong>Servlet 容器</strong>，能够运行 Servlet 和 JSP。</li>
<li><strong>WebSphere</strong>：IBM 公司开发，<strong>大型的 JavaEE 服务器</strong>，<strong>收费</strong>。功能强大，支持完整的 JavaEE 规范。</li>
<li><strong>WebLogic</strong>：Oracle 公司开发，<strong>大型的 JavaEE 服务器</strong>，<strong>收费</strong>。</li>
<li><strong>JBoss&#x2F;WildFly</strong>：开源，但其商业版收费。</li>
</ul>
<h3 id="三、Tomcat-的使用与配置"><a href="#三、Tomcat-的使用与配置" class="headerlink" title="三、Tomcat 的使用与配置"></a>三、Tomcat 的使用与配置</h3><ul>
<li><strong>安装与启动</strong>：Tomcat 是免安装的，解压即可。启动前需要配置 <code>JAVA_HOME</code> 环境变量。启动后，默认监听 <code>8080</code> 端口。</li>
<li><strong>端口号修改</strong>：<ul>
<li><strong>面试题</strong>：修改 Tomcat 端口号在哪个文件？</li>
<li><strong>回答</strong>：在 Tomcat 的 <code>conf</code> 目录下的 <code>server.xml</code> 文件中，修改 <code>&lt;Connector&gt;</code> 标签的 <code>port</code> 属性。</li>
<li><strong>注意</strong>：HTTP 协议的默认端口号是 <code>80</code>。如果将 Tomcat 端口号改为 <code>80</code>，那么访问时就可以省略端口号，例如 <code>http://localhost/</code>。</li>
</ul>
</li>
<li><strong>项目部署</strong>：<ul>
<li><strong>静态项目</strong>：将 HTML、CSS、JS 等文件直接放到 <code>webapps</code> 目录下的文件夹中。</li>
<li><strong>动态项目</strong>：将包含 <code>WEB-INF</code> 文件夹的整个项目目录放到 <code>webapps</code> 目录下。</li>
<li><strong>WEB-INF</strong>：这是动态项目的核心目录，具有特殊作用，外部无法直接通过 URL 访问该目录下的资源，保证了项目的安全性。<ul>
<li><code>classes</code>：存放所有编译后的 <code>.class</code> 字节码文件。</li>
<li><code>lib</code>：存放项目依赖的第三方 <code>.jar</code> 包。</li>
<li><code>web.xml</code>：Web 项目的<strong>核心配置文件</strong>，用于配置 Servlet、监听器、过滤器等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四、Servlet-深入解析"><a href="#四、Servlet-深入解析" class="headerlink" title="四、Servlet 深入解析"></a>四、Servlet 深入解析</h3><h4 id="1-Servlet-的概念和本质"><a href="#1-Servlet-的概念和本质" class="headerlink" title="1. Servlet 的概念和本质"></a>1. Servlet 的概念和本质</h4><ul>
<li><strong>概念</strong>：Servlet 是运行在服务器端的 Java 程序，用于处理客户端请求并生成动态响应。它不是一个独立的程序，<strong>必须部署到支持 Servlet 的容器中</strong>（如 Tomcat）才能运行。</li>
<li><strong>本质</strong>：Servlet 的本质是一个<strong>接口</strong>。所有自定义的 Servlet 类都必须<strong>实现 javax.servlet.Servlet 接口</strong>。</li>
</ul>
<h4 id="2-Servlet-的执行原理（详细解释）"><a href="#2-Servlet-的执行原理（详细解释）" class="headerlink" title="2. Servlet 的执行原理（详细解释）"></a>2. Servlet 的执行原理（详细解释）</h4><p>这是一个非常重要的面试点，需要从请求-响应的整个流程来详细阐述。</p>
<ol>
<li><strong>客户端请求</strong>：用户在浏览器中输入 URL，向服务器发送一个 HTTP 请求。</li>
<li><strong>Web 服务器接收请求</strong>：Web 服务器（Tomcat）接收到这个请求。</li>
<li><strong>Servlet 容器处理</strong>：Tomcat 会根据请求 URL，在 <code>web.xml</code> 或通过注解（如 <code>@WebServlet</code>）查找匹配的 Servlet。</li>
<li><strong>Servlet 实例创建</strong>：<ul>
<li>如果是<strong>第一次</strong>访问该 Servlet，Servlet 容器会创建一个该 Servlet 的实例。</li>
<li><strong>面试点</strong>：Servlet 是<strong>单例的</strong>，一个 Servlet 在容器中只会被创建一次。</li>
</ul>
</li>
<li><strong>init() 方法执行</strong>：<ul>
<li>在 Servlet 实例创建后，容器会立即调用它的 <code>init()</code> 方法。</li>
<li><code>init()</code> 方法只在 Servlet 的<strong>生命周期中执行一次</strong>，用于完成一些初始化工作，如加载配置文件、数据库连接等。</li>
</ul>
</li>
<li><strong>service() 方法执行</strong>：<ul>
<li>每次客户端请求该 Servlet 时，容器都会调用它的 <code>service()</code> 方法。</li>
<li><code>service()</code> 方法根据请求的 HTTP 方法（GET、POST 等），将请求分发给相应的 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li>
<li><strong>面试点</strong>：<code>service()</code> 方法是处理请求的核心方法，它是<strong>多线程的</strong>，每个请求都会在新线程中执行 <code>service()</code> 方法。</li>
</ul>
</li>
<li><strong>destroy() 方法执行</strong>：<ul>
<li>当 Servlet 容器关闭，或者决定卸载该 Servlet 时，会调用其 <code>destroy()</code> 方法。</li>
<li><code>destroy()</code> 方法也只执行一次，用于释放资源，如关闭数据库连接池。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：Servlet 的生命周期是：<strong>创建实例</strong> -&gt; <strong>调用 init()</strong> (只一次) -&gt; <strong>调用 service()</strong> (多次) -&gt; <strong>调用 destroy()</strong> (只一次) -&gt; <strong>销毁实例</strong>。</p>
<p>好的，我们来将“网络编程三要素”这一部分进行更深入、更详细的展开，并补充常见应用的默认端口号，使其更具实用性和面试价值。</p>
<hr>
<h3 id="一、网络编程三要素：深入解析"><a href="#一、网络编程三要素：深入解析" class="headerlink" title="一、网络编程三要素：深入解析"></a>一、网络编程三要素：深入解析</h3><p>网络编程的本质就是让不同的计算机上的应用程序能够进行通信。要实现这一点，必须解决三个核心问题：</p>
<ol>
<li><strong>找到对方计算机</strong>：IP 地址</li>
<li><strong>找到对方计算机上的应用程序</strong>：端口号</li>
<li><strong>以什么样的规则进行通信</strong>：协议</li>
</ol>
<p>这三者缺一不可。</p>
<h4 id="1-IP-地址-Internet-Protocol-Address"><a href="#1-IP-地址-Internet-Protocol-Address" class="headerlink" title="1. IP 地址 (Internet Protocol Address)"></a>1. IP 地址 (Internet Protocol Address)</h4><ul>
<li><strong>概念</strong>：IP 地址是分配给连接到网络中的设备（如计算机、手机、服务器）的一串数字标识。</li>
<li><strong>作用</strong>：它用于<strong>唯一地标识网络上的一个设备</strong>。数据包在网络中传输时，就是根据 IP 地址来路由和寻址的。</li>
<li><strong>版本</strong>：<ul>
<li><strong>IPv4</strong>：由 32 位二进制数组成，通常表示为四个十进制数，用点分隔（例如 <code>192.168.1.1</code>）。由于地址资源枯竭，现在已经不够用。</li>
<li><strong>IPv6</strong>：由 128 位二进制数组成，地址空间巨大，足以满足未来需求。</li>
</ul>
</li>
<li><strong>类型</strong>：<ul>
<li><strong>公网 IP</strong>：在互联网上是唯一的，可以直接访问。</li>
<li><strong>内网 IP</strong>：在局域网内是唯一的，不能直接在互联网上访问。例如 <code>192.168.x.x</code>、<code>10.x.x.x</code>。</li>
</ul>
</li>
</ul>
<h4 id="2-端口号-Port-Number"><a href="#2-端口号-Port-Number" class="headerlink" title="2. 端口号 (Port Number)"></a>2. 端口号 (Port Number)</h4><ul>
<li><strong>概念</strong>：端口号是用于<strong>区分一台计算机上不同应用程序</strong>的数字标识。它的范围是从 <code>0</code> 到 <code>65535</code>。</li>
<li><strong>作用</strong>：当一个数据包到达一台计算机时，操作系统会检查其目的端口号，然后将数据包交给监听该端口号的相应应用程序。</li>
<li><strong>与 IP 地址的关系</strong>：IP 地址解决了“数据包发送到哪台计算机”的问题，而端口号则解决了“数据包发送到这台计算机上的哪个应用程序”的问题。两者结合起来才能唯一确定一个网络连接的端点。</li>
</ul>
<h4 id="3-协议-Protocol"><a href="#3-协议-Protocol" class="headerlink" title="3. 协议 (Protocol)"></a>3. 协议 (Protocol)</h4><ul>
<li><strong>概念</strong>：协议是网络通信中<strong>数据传输的规则和约定</strong>。它定义了数据如何打包、传输、路由和接收。</li>
<li><strong>作用</strong>：确保通信双方能够理解彼此发送的数据。没有协议，数据包就是一堆无意义的字节。</li>
<li><strong>分层</strong>：网络协议通常是分层的，最经典的是 <strong>TCP&#x2F;IP 协议栈</strong>。<ul>
<li><strong>应用层</strong>：<strong>决定数据内容</strong>，如 HTTP、FTP、SMTP。</li>
<li><strong>传输层</strong>：<strong>决定数据如何传输</strong>，如 TCP 和 UDP。<ul>
<li><strong>TCP (Transmission Control Protocol)</strong>：面向连接、可靠、有序。适用于对数据完整性要求高的场景，如文件传输、网页浏览。</li>
<li><strong>UDP (User Datagram Protocol)</strong>：无连接、不可靠、速度快。适用于对实时性要求高的场景，如在线视频、游戏。</li>
</ul>
</li>
<li><strong>网络层</strong>：<strong>决定数据如何路由</strong>，如 IP 协议。</li>
<li><strong>数据链路层&#x2F;物理层</strong>：负责物理设备的通信。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、常见应用的默认端口号"><a href="#二、常见应用的默认端口号" class="headerlink" title="二、常见应用的默认端口号"></a>二、常见应用的默认端口号</h3><p>了解这些默认端口号，可以帮助你更好地理解网络协议和服务。</p>
<ul>
<li><strong>Web 服务</strong><ul>
<li><strong>HTTP</strong> (HyperText Transfer Protocol)：<strong>80</strong></li>
<li><strong>HTTPS</strong> (HTTP Secure)：<strong>443</strong></li>
<li><strong>Tomcat</strong> (默认)：<strong>8080</strong></li>
<li><strong>WebLogic</strong> (默认)：<strong>7001</strong></li>
</ul>
</li>
<li><strong>文件传输</strong><ul>
<li><strong>FTP</strong> (File Transfer Protocol)：<strong>21</strong> (控制连接)</li>
<li><strong>SFTP</strong> (SSH File Transfer Protocol)：<strong>22</strong></li>
</ul>
</li>
<li><strong>远程登录与管理</strong><ul>
<li><strong>SSH</strong> (Secure Shell)：<strong>22</strong></li>
<li><strong>Telnet</strong>：<strong>23</strong></li>
<li><strong>RDP</strong> (Remote Desktop Protocol)：<strong>3389</strong></li>
</ul>
</li>
<li><strong>数据库服务</strong><ul>
<li><strong>MySQL</strong>：<strong>3306</strong></li>
<li><strong>PostgreSQL</strong>：<strong>5432</strong></li>
<li><strong>SQL Server</strong>：<strong>1433</strong></li>
<li><strong>Oracle</strong>：<strong>1521</strong></li>
</ul>
</li>
<li><strong>邮件服务</strong><ul>
<li><strong>SMTP</strong> (Simple Mail Transfer Protocol)：<strong>25</strong> (发送邮件)</li>
<li><strong>POP3</strong> (Post Office Protocol 3)：<strong>110</strong> (接收邮件)</li>
<li><strong>IMAP</strong> (Internet Message Access Protocol)：<strong>143</strong> (接收邮件)</li>
</ul>
</li>
<li><strong>其他常见服务</strong><ul>
<li><strong>DNS</strong> (Domain Name System)：<strong>53</strong></li>
<li><strong>Redis</strong>：<strong>6379</strong></li>
<li><strong>MongoDB</strong>：<strong>27017</strong></li>
<li><strong>Kafka</strong>：<strong>9092</strong></li>
</ul>
</li>
</ul>
<p>为什么需要默认端口号？</p>
<p>为了方便用户。当你在浏览器中访问 <a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a> 时，你不需要手动输入 <a href="http://www.example.com:80，因为浏览器知道">www.example.com:80，因为浏览器知道</a> HTTP 协议的默认端口就是 80。如果服务器的端口不是默认端口，你就必须手动指定，比如 <a href="http://www.example.com:8080。">www.example.com:8080。</a></p>
<p>好的，我将根据您提供的这份详尽的 Web 技术笔记，以一种更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p>
<hr>
<h3 id="一、Servlet-剩余部分"><a href="#一、Servlet-剩余部分" class="headerlink" title="一、Servlet 剩余部分"></a>一、Servlet 剩余部分</h3><h4 id="1-Servlet-的生命周期方法"><a href="#1-Servlet-的生命周期方法" class="headerlink" title="1. Servlet 的生命周期方法"></a>1. Servlet 的生命周期方法</h4><p>这是理解 Servlet 工作原理的核心。</p>
<ul>
<li><strong>init() 方法</strong>：<ul>
<li><strong>特点</strong>：只执行<strong>一次</strong>，用于初始化 Servlet 实例。</li>
<li><strong>执行时机</strong>：<ul>
<li><strong>默认（懒加载）</strong>：第一次被访问时执行。这是一种“按需加载”的策略，节省了服务器启动时的资源。</li>
<li><strong>预加载</strong>：可以在 <code>web.xml</code> 中通过 <code>&lt;load-on-startup&gt;</code> 标签来设置。如果值为非负整数（<code>0</code>或正数），Servlet 容器将在服务器启动时立即创建并初始化该 Servlet。这适用于需要立即提供服务、启动耗时较长的 Servlet。</li>
</ul>
</li>
</ul>
</li>
<li><strong>service() 方法</strong>：<ul>
<li><strong>特点</strong>：每次客户端请求该 Servlet 时，都会执行一次。</li>
<li><strong>原理</strong>：它是 Servlet 接口的核心方法，用于处理请求。对于 <code>HttpServlet</code> 来说，它会根据 HTTP 请求方法（GET、POST 等）来分发请求给相应的 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li>
<li><strong>重要性</strong>：<strong>service() 方法是多线程的</strong>。Servlet 容器会为每个请求创建一个新线程来执行 <code>service()</code> 方法，确保并发访问时互不影响。</li>
</ul>
</li>
<li><strong>destroy() 方法</strong>：<ul>
<li><strong>特点</strong>：只执行<strong>一次</strong>，在 Servlet 实例正常销毁时调用。</li>
<li><strong>执行时机</strong>：通常在 Web 应用关闭或 Servlet 容器关闭时。用于释放资源，如关闭数据库连接、文件句柄等。</li>
</ul>
</li>
</ul>
<h4 id="2-Servlet-的实现方式：XML-vs-注解"><a href="#2-Servlet-的实现方式：XML-vs-注解" class="headerlink" title="2. Servlet 的实现方式：XML vs. 注解"></a>2. Servlet 的实现方式：XML vs. 注解</h4><ul>
<li><p><strong>XML 配置方式</strong>：在 <code>web.xml</code> 文件中，通过 <code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code> 标签来配置 Servlet 的名称、类和访问路径。这是 Servlet 2.x 及以前版本的主流方式。</p>
</li>
<li><p><strong>注解方式</strong>：自 Servlet 3.0 开始引入，可以使用 <code>@WebServlet</code> 注解来代替 XML 配置。</p>
<ul>
<li><strong>优点</strong>：简化了配置，代码和配置更集中，提高了开发效率。</li>
<li><strong>示例</strong>：</li>
</ul>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;/demo&quot;)</span><br><span class="line">public class MyServlet extends HttpServlet &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-Servlet-的体系结构"><a href="#3-Servlet-的体系结构" class="headerlink" title="3. Servlet 的体系结构"></a>3. Servlet 的体系结构</h4><ul>
<li><code>Servlet</code> <strong>接口</strong>：所有 Servlet 的顶层接口，定义了 <code>init()</code>, <code>service()</code>, <code>destroy()</code> 等核心方法。</li>
<li><code>GenericServlet</code> <strong>抽象类</strong>：实现了 <code>Servlet</code> 接口，并提供了 <code>init()</code>, <code>destroy()</code> 的空实现，以及一些通用方法。开发者可以继承它来编写协议无关的 Servlet。</li>
<li><code>HttpServlet</code> <strong>抽象类</strong>：继承自 <code>GenericServlet</code>，专门用于处理 <strong>HTTP 请求</strong>。它重写了 <code>service()</code> 方法，并根据请求方法分发给 <code>doGet()</code>, <code>doPost()</code> 等具体方法。</li>
<li><strong>总结</strong>：在 Web 项目中，我们几乎总是处理 HTTP 请求，因此<strong>继承 HttpServlet 是最常用、最推荐的方式</strong>。</li>
</ul>
<hr>
<h3 id="二、HTTP-协议"><a href="#二、HTTP-协议" class="headerlink" title="二、HTTP 协议"></a>二、HTTP 协议</h3><h4 id="1-概念与特点"><a href="#1-概念与特点" class="headerlink" title="1. 概念与特点"></a>1. 概念与特点</h4><ul>
<li><strong>概念</strong>：<strong>超文本传输协议</strong>，是 Web 应用层协议，基于 TCP&#x2F;IP。它规定了客户端和服务器之间的通信格式。</li>
<li><strong>特点</strong>：<ul>
<li><strong>基于 TCP&#x2F;IP</strong>：它位于 TCP&#x2F;IP 协议栈的应用层，利用了 TCP 的可靠传输特性。</li>
<li><strong>请求&#x2F;响应模型</strong>：客户端发送请求，服务器返回响应，一次请求只对应一次响应。</li>
<li><strong>无状态</strong>：这是 HTTP 的核心特征。服务器不保留任何关于客户端过去请求的信息。每个请求都是独立的。</li>
<li><strong>无状态带来的问题</strong>：服务器无法识别多个请求是否来自同一个用户，因此需要引入<strong>会话技术</strong>（如 Cookie 和 Session）来解决。</li>
</ul>
</li>
</ul>
<h4 id="2-HTTP-协议的数据格式"><a href="#2-HTTP-协议的数据格式" class="headerlink" title="2. HTTP 协议的数据格式"></a>2. HTTP 协议的数据格式</h4><p>HTTP 协议是文本格式，由<strong>请求格式</strong>和<strong>响应格式</strong>两部分组成。</p>
<ul>
<li><strong>请求格式</strong>：<ol>
<li><strong>请求行</strong>：<code>请求方式 虚拟路径/资源路径[?参数] 请求协议/版本</code>。</li>
<li><strong>请求头</strong>：键值对形式，提供额外信息。<ul>
<li><code>Host</code>：目标主机名。</li>
<li><code>User-Agent</code>：浏览器类型和版本。</li>
<li><code>Referer</code>：请求来源地址，常用于防盗链。</li>
</ul>
</li>
<li><strong>请求空行</strong>：一个空行，用于分隔请求头和请求体。</li>
<li><strong>请求体</strong>：<strong>只有 POST 请求才有</strong>，用于封装请求参数。</li>
</ol>
</li>
</ul>
<h4 id="3-ServletRequest-对象"><a href="#3-ServletRequest-对象" class="headerlink" title="3. ServletRequest 对象"></a>3. <code>ServletRequest</code> 对象</h4><p><code>ServletRequest</code> 是 Servlet 容器在接收到请求后，封装请求信息的对象。</p>
<ul>
<li><strong>获取请求行信息</strong>：<ul>
<li><code>getMethod()</code>：获取请求方式（GET&#x2F;POST）。</li>
<li><code>getContextPath()</code>：获取虚拟路径。</li>
<li><code>getRequestURI()</code>：获取 URI，如 <code>/web02/demo4</code>。</li>
<li><code>getRequestURL()</code>：获取 URL，如 <code>http://localhost:8080/web02/demo4</code>。</li>
</ul>
</li>
<li><strong>获取请求头信息</strong>：<ul>
<li><code>getHeader(name)</code>：根据请求头名获取值。</li>
<li><code>getHeaderNames()</code>：获取所有请求头名。</li>
</ul>
</li>
<li><strong>获取请求体信息</strong>：<ul>
<li><code>getReader()</code> (字符流) 和 <code>getInputStream()</code> (字节流)，用于读取 POST 请求的请求体内容。</li>
</ul>
</li>
<li><strong>获取请求参数（通用）</strong>：<ul>
<li><code>getParameter(name)</code>：获取单个参数值。</li>
<li><code>getParameterValues(name)</code>：获取参数值数组，用于复选框等。</li>
</ul>
</li>
<li><strong>中文乱码</strong>：<ul>
<li><strong>GET 请求</strong>：在 Tomcat 8.x 及以后版本，默认已解决。</li>
<li><strong>POST 请求</strong>：需要手动设置编码，<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code>。</li>
</ul>
</li>
</ul>
<h4 id="4-request-请求转发"><a href="#4-request-请求转发" class="headerlink" title="4. request 请求转发"></a>4. <code>request</code> 请求转发</h4><ul>
<li><strong>概念</strong>：是一种<strong>服务器内部</strong>的资源跳转方式。请求从一个 Servlet 转发到另一个 Servlet 或 JSP，<strong>浏览器地址栏不会发生改变</strong>。</li>
<li><strong>特点</strong>：<ol>
<li><strong>地址栏不变</strong>：用户不知道发生了跳转。</li>
<li><strong>一次请求&#x2F;响应</strong>：整个转发过程发生在一次 HTTP 请求和一次 HTTP 响应中。</li>
<li><strong>共享数据</strong>：由于是同一次请求，<code>request</code> 对象中的数据在转发前后是共享的。</li>
</ol>
</li>
</ul>
<h4 id="5-request-作为域对象"><a href="#5-request-作为域对象" class="headerlink" title="5. request 作为域对象"></a>5. <code>request</code> 作为域对象</h4><ul>
<li><strong>概念</strong>：<code>request</code> 是一种<strong>域对象</strong>，其作用范围是<strong>一次请求-响应的生命周期</strong>。</li>
<li><strong>共享数据</strong>：可以使用 <code>setAttribute()</code>, <code>getAttribute()</code>, <code>removeAttribute()</code> 方法在这次请求的生命周期内共享数据。</li>
<li><strong>应用场景</strong>：常用于在 Servlet 和 JSP 之间传递数据。</li>
<li><strong>与会话技术的联系</strong>：<code>request</code> 是三大域对象（<code>request</code>, <code>session</code>, <code>servletContext</code>）中作用范围最小的一个。</li>
</ul>
<p>好的，我将根据您提供的这份详尽的 Web 技术笔记，以一种更专业、更系统的方式，对其进行重新组织、补充和深入解析，使其成为一份高质量的技术讲解或面试回答。</p>
<hr>
<h3 id="一、HTTP-协议的响应格式"><a href="#一、HTTP-协议的响应格式" class="headerlink" title="一、HTTP 协议的响应格式"></a>一、HTTP 协议的响应格式</h3><h4 id="1-响应格式组成"><a href="#1-响应格式组成" class="headerlink" title="1. 响应格式组成"></a>1. 响应格式组成</h4><p>HTTP 响应格式由四部分组成：<code>响应行</code>、<code>响应头</code>、<code>响应空行</code>、<code>响应体</code>。这与 HTTP 请求格式相呼应。</p>
<h4 id="2-响应行"><a href="#2-响应行" class="headerlink" title="2. 响应行"></a>2. 响应行</h4><ul>
<li><strong>格式</strong>：<code>协议/版本号 状态码 状态描述</code>。例如：<code>HTTP/1.1 200 OK</code>。</li>
<li><strong>状态码</strong>：一个三位数的数字，服务器用于告诉浏览器本次响应的状态。<ul>
<li><strong>2xx 成功</strong>：<ul>
<li><strong>200 OK</strong>：请求成功，一切正常。</li>
</ul>
</li>
<li><strong>3xx 重定向</strong>：<ul>
<li><strong>302 Found</strong>：重定向。服务器告诉浏览器，资源临时移动到另一个位置，请重新发起请求。</li>
<li><strong>304 Not Modified</strong>：访问缓存。服务器告诉浏览器，请求的资源没有更新，可以使用浏览器本地的缓存副本。</li>
</ul>
</li>
<li><strong>4xx 客户端错误</strong>：<ul>
<li><strong>404 Not Found</strong>：找不到资源。请求的路径没有对应的资源。</li>
<li><strong>405 Method Not Allowed</strong>：请求方法不被允许。例如，客户端用 POST 请求访问了只支持 GET 方法的 Servlet。</li>
</ul>
</li>
<li><strong>5xx 服务器端错误</strong>：<ul>
<li><strong>500 Internal Server Error</strong>：服务器内部错误。通常是服务器端的代码出现了异常。</li>
</ul>
</li>
</ul>
</li>
<li><strong>面试题</strong>：列举 5 个常见的状态码：200、302、304、404、405、500。</li>
</ul>
<h4 id="3-响应头"><a href="#3-响应头" class="headerlink" title="3. 响应头"></a>3. 响应头</h4><ul>
<li><strong>作用</strong>：以键值对形式提供关于响应的额外信息。</li>
<li><strong>常见响应头</strong>：<ul>
<li><strong>Content-Type</strong>：告诉浏览器响应体的数据类型和字符编码，例如 <code>text/html;charset=utf-8</code>。</li>
<li><strong>Content-disposition</strong>：<ul>
<li><strong>inline</strong> (默认)：浏览器在当前页面内直接打开。</li>
<li><strong>attachment;filename&#x3D;xxx</strong>：浏览器将数据作为附件下载。</li>
</ul>
</li>
<li><strong>Location</strong>：与 <code>3xx</code> 状态码配合使用，用于告诉浏览器重定向到哪个 URL。</li>
</ul>
</li>
</ul>
<h3 id="二、ServletResponse-response"><a href="#二、ServletResponse-response" class="headerlink" title="二、ServletResponse (response)"></a>二、ServletResponse (response)</h3><ul>
<li><strong>简介</strong>：<code>ServletResponse</code> 对象由 Tomcat 创建，封装了服务器发送给客户端的响应消息。</li>
<li><strong>相关方法</strong>：<ul>
<li><strong>设置响应行</strong>：<code>setStatus(int sc)</code></li>
<li><strong>设置响应头</strong>：<code>setHeader(String name, String value)</code></li>
<li><strong>设置响应体</strong>：<ul>
<li><code>getWriter()</code>：获取字符输出流，用于发送<strong>文本</strong>数据。</li>
<li><code>getOutputStream()</code>：获取字节输出流，用于发送<strong>字节</strong>数据（如图片、视频）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三、转发（Forward）和重定向（Redirect）的区别"><a href="#三、转发（Forward）和重定向（Redirect）的区别" class="headerlink" title="三、转发（Forward）和重定向（Redirect）的区别"></a>三、转发（Forward）和重定向（Redirect）的区别</h3><p>这是一个非常重要的面试题，需要从多个角度进行对比。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>转发（Forward）</th>
<th>重定向（Redirect）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>发生方</strong></td>
<td>服务器内部</td>
<td>浏览器</td>
</tr>
<tr>
<td><strong>地址栏</strong></td>
<td><strong>不变</strong></td>
<td><strong>会改变</strong></td>
</tr>
<tr>
<td><strong>请求次数</strong></td>
<td><strong>一次</strong>请求，一次响应</td>
<td><strong>两次</strong>请求，两次响应</td>
</tr>
<tr>
<td><strong>共享数据</strong></td>
<td><code>request</code> 对象共享数据</td>
<td><code>request</code> 对象不共享数据</td>
</tr>
<tr>
<td><strong>跳转范围</strong></td>
<td><strong>只能</strong>在当前 Web 项目内部</td>
<td>可以跳出项目，访问外部资源</td>
</tr>
<tr>
<td><strong>调用方</strong></td>
<td><code>RequestDispatcher</code> (<code>request</code>)</td>
<td><code>ServletResponse</code> (<code>response</code>)</td>
</tr>
<tr>
<td><strong>底层实现</strong></td>
<td><code>request.getRequestDispatcher().forward()</code></td>
<td><code>response.sendRedirect()</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>重定向的实现原理</strong>：<ol>
<li>服务器收到请求，执行 <code>response.sendRedirect()</code>，并发送 <code>302</code> 状态码和 <code>Location</code> 响应头（值为新的 URL）。</li>
<li>浏览器收到响应，解析到 <code>302</code> 和 <code>Location</code> 头后，会<strong>自动</strong>向新的 URL 发起<strong>第二次</strong>请求。</li>
</ol>
</li>
</ul>
<h3 id="四、ServletContext"><a href="#四、ServletContext" class="headerlink" title="四、ServletContext"></a>四、ServletContext</h3><h4 id="1-简介与特点"><a href="#1-简介与特点" class="headerlink" title="1. 简介与特点"></a>1. 简介与特点</h4><ul>
<li><strong>作用</strong>：代表<strong>整个 Web 应用</strong>。可以用来和服务器容器进行通信。</li>
<li><strong>特点</strong>：<ul>
<li><strong>单例</strong>：一个 Web 应用只有一个 <code>ServletContext</code> 对象。</li>
<li><strong>作用域</strong>：是<strong>最大的域对象</strong>，其作用范围是整个 Web 应用，从应用启动到关闭。</li>
</ul>
</li>
</ul>
<h4 id="2-获取-ServletContext-对象"><a href="#2-获取-ServletContext-对象" class="headerlink" title="2. 获取 ServletContext 对象"></a>2. 获取 <code>ServletContext</code> 对象</h4><ul>
<li><strong>通过 request</strong>：<code>request.getServletContext()</code></li>
<li><strong>通过 HttpServlet</strong>：<code>getServletContext()</code></li>
</ul>
<h4 id="3-ServletContext-的方法"><a href="#3-ServletContext-的方法" class="headerlink" title="3. ServletContext 的方法"></a>3. <code>ServletContext</code> 的方法</h4><ul>
<li><strong>获取文件 MIME 类型</strong>：<code>getMimeType(String file)</code>，返回文件的类型，如 <code>image/jpeg</code>。</li>
<li><strong>作为域对象</strong>：提供了 <code>setAttribute()</code>, <code>getAttribute()</code>, <code>removeAttribute()</code> 方法，用于在整个 Web 应用范围内共享数据。<ul>
<li><strong>示例</strong>：您提供的代码片段完美地展示了如何使用 <code>ServletContext</code> 来统计服务器的访问次数。这是 <code>ServletContext</code> 作为域对象最经典的用法。</li>
</ul>
</li>
<li><strong>获取文件真实路径</strong>：<code>getRealPath(String path)</code>，将相对路径转换为服务器上的绝对路径。</li>
</ul>
<h3 id="五、会话（Session）"><a href="#五、会话（Session）" class="headerlink" title="五、会话（Session）"></a>五、会话（Session）</h3><h4 id="1-概念与作用"><a href="#1-概念与作用" class="headerlink" title="1. 概念与作用"></a>1. 概念与作用</h4><ul>
<li><strong>概念</strong>：在 HTTP 协议的无状态特性基础上，通过会话技术将多次请求和响应联系起来，形成一个完整的会话。</li>
<li><strong>作用</strong>：在一次会话范围内的多次请求之间<strong>共享数据</strong>，从而识别用户。</li>
<li><strong>实现方式</strong>：<ul>
<li><strong>客户端会话（Cookie）</strong>：数据存储在客户端浏览器。</li>
<li><strong>服务器端会话（Session）</strong>：数据存储在服务器端。</li>
</ul>
</li>
</ul>
<h4 id="2-客户端会话：Cookie"><a href="#2-客户端会话：Cookie" class="headerlink" title="2. 客户端会话：Cookie"></a>2. 客户端会话：Cookie</h4><ul>
<li><strong>快速开始</strong>：<ol>
<li><strong>创建</strong>：<code>new Cookie(name, value)</code>。</li>
<li><strong>发送</strong>：<code>response.addCookie(cookie)</code>，将 Cookie 发送给浏览器。</li>
<li><strong>获取</strong>：<code>request.getCookies()</code>，从请求中获取所有 Cookie。</li>
</ol>
</li>
<li><strong>特点</strong>：数据存储在客户端，有大小限制，安全性低。</li>
</ul>
<p>这是一个非常好的问题，它触及了 Web 开发中一个容易混淆但至关重要的概念。<code>enctype</code> 和 <code>Content-Type</code> 确实有相似之处，但它们的作用域和角色是完全不同的。</p>
<p>让我来详细解释一下它们的区别：</p>
<hr>
<h3 id="一、enctype"><a href="#一、enctype" class="headerlink" title="一、enctype"></a>一、<code>enctype</code></h3><ul>
<li><strong>作用域</strong>：HTML <code>&lt;form&gt;</code> 标签的属性。</li>
<li><strong>角色</strong>：客户端<strong>表单的编码方式</strong>。</li>
<li><strong>概念</strong>：<code>enctype</code> (Encoding Type) 告诉<strong>浏览器</strong>如何将 <code>&lt;form&gt;</code> 表单中的数据<strong>编码</strong>成 HTTP 请求体中的数据。它只作用于<strong>表单提交</strong>这个行为。</li>
<li><strong>常见值</strong>：<ul>
<li><code>application/x-www-form-urlencoded</code>：默认值，用于文本数据。</li>
<li><code>multipart/form-data</code>：用于文件上传。</li>
<li><code>text/plain</code>：用于纯文本提交。</li>
</ul>
</li>
</ul>
<p><strong>简单来说，enctype 是“表单数据在浏览器端如何打包”的规则。</strong></p>
<h3 id="二、Content-Type"><a href="#二、Content-Type" class="headerlink" title="二、Content-Type"></a>二、<code>Content-Type</code></h3><ul>
<li><strong>作用域</strong>：HTTP 请求头或响应头。</li>
<li><strong>角色</strong>：<strong>通信数据的媒体类型</strong>。</li>
<li><strong>概念</strong>：<code>Content-Type</code> 告诉接收方（服务器或浏览器）请求体或响应体中的<strong>数据是什么格式</strong>。它是一个通用的 HTTP 头部，不仅限于表单提交。</li>
<li><strong>常见值</strong>：<ul>
<li><code>text/html</code>：HTML 文档。</li>
<li><code>application/json</code>：JSON 格式数据。</li>
<li><code>image/jpeg</code>：JPEG 图片。</li>
<li><code>application/xml</code>：XML 文档。</li>
<li><code>text/plain</code>：纯文本。</li>
</ul>
</li>
</ul>
<p><strong>简单来说，Content-Type 是“我发送给你的数据是什么类型”的声明。</strong></p>
<h3 id="三、核心区别与联系"><a href="#三、核心区别与联系" class="headerlink" title="三、核心区别与联系"></a>三、核心区别与联系</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>enctype</code></th>
<th><code>Content-Type</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>位置</strong></td>
<td>HTML <code>&lt;form&gt;</code> 标签的属性</td>
<td>HTTP 请求头或响应头</td>
</tr>
<tr>
<td><strong>谁定义</strong></td>
<td>开发者在 HTML 中设置</td>
<td>发送方（浏览器或服务器）在 HTTP 头部中设置</td>
</tr>
<tr>
<td><strong>作用</strong></td>
<td>告诉<strong>浏览器</strong>如何<strong>打包</strong>表单数据</td>
<td>告诉<strong>接收方</strong>如何<strong>解析</strong>数据</td>
</tr>
<tr>
<td><strong>关系</strong></td>
<td><strong>enctype 的值决定了 HTTP 请求头中 Content-Type 的值。</strong></td>
<td><code>Content-Type</code> 是 HTTP 协议的一部分，<code>enctype</code> 是 HTML 的一部分。</td>
</tr>
</tbody></table>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假设你有一个包含用户名和头像上传的表单：</p>
<p>HTML</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/profile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;avatar&quot;&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>当用户点击提交时，浏览器会做两件事：</p>
<ol>
<li><p><strong>根据 enctype&#x3D;”multipart&#x2F;form-data” 规则</strong>，浏览器会生成一个**多部分（<code>multipart</code>）**的请求体，包含用户名和头像文件的二进制数据。</p>
</li>
<li><p>在发送 HTTP 请求时，浏览器会在请求头中自动添加一个 <code>Content-Type</code> 字段，其值为<strong>与 enctype 匹配的</strong> <code>multipart/form-data</code>。</p>
<p>HTTP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /profile HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>enctype 是一个前端概念</strong>，它是 HTML 表单的属性，用于指导浏览器如何构建请求体。</li>
<li><strong>Content-Type 是一个 HTTP 协议概念</strong>，它是 HTTP 头部的一个字段，用于告知数据格式。</li>
<li>两者之间存在<strong>联动关系</strong>：你在 HTML 中设置的 <code>enctype</code> 值，会<strong>最终影响</strong>浏览器在 HTTP 请求中设置的 <code>Content-Type</code> 头的值。</li>
</ul>
<p>好的，我来为你分别列出 <code>enctype</code> 和 <code>Content-Type</code> 各自常见的属性值，并简要说明其用途。</p>
<hr>
<h3 id="一、enctype-的常见值"><a href="#一、enctype-的常见值" class="headerlink" title="一、enctype 的常见值"></a>一、<code>enctype</code> 的常见值</h3><p><code>enctype</code> 是 HTML <code>&lt;form&gt;</code> 标签的属性，用于定义表单数据提交的编码方式。</p>
<ol>
<li><strong>application&#x2F;x-www-form-urlencoded</strong><ul>
<li><strong>用途</strong>：这是 <code>enctype</code> 的<strong>默认值</strong>。它将表单数据编码为键值对字符串，其中所有特殊字符都会被 URL 编码（例如空格被 <code>%20</code> 替代）。</li>
<li><strong>适用场景</strong>：只包含文本数据的普通表单提交。</li>
</ul>
</li>
<li><strong>multipart&#x2F;form-data</strong><ul>
<li><strong>用途</strong>：将表单数据分割成多个部分，每个部分都有独立的 <code>Content-Type</code> 和 <code>Content-Disposition</code> 头部。这种格式能够<strong>同时处理文本和二进制数据</strong>。</li>
<li><strong>适用场景</strong>：<strong>文件上传</strong>。</li>
</ul>
</li>
<li><strong>text&#x2F;plain</strong><ul>
<li><strong>用途</strong>：将表单数据以纯文本格式发送，不进行任何编码。数据以键值对的形式，用换行符分隔。</li>
<li><strong>适用场景</strong>：不常用，主要用于调试目的。</li>
</ul>
</li>
</ol>
<h3 id="二、Content-Type-的常见值"><a href="#二、Content-Type-的常见值" class="headerlink" title="二、Content-Type 的常见值"></a>二、<code>Content-Type</code> 的常见值</h3><p><code>Content-Type</code> 是 HTTP 头部字段，用于指定消息体的媒体类型（MIME 类型）。</p>
<h4 id="1-文本类型-text"><a href="#1-文本类型-text" class="headerlink" title="1. 文本类型 (text/)"></a>1. 文本类型 (<code>text/</code>)</h4><ul>
<li><strong>text&#x2F;plain</strong>：纯文本。</li>
<li><strong>text&#x2F;html</strong>：HTML 文档。这是浏览器渲染网页的默认类型。</li>
<li><strong>text&#x2F;css</strong>：CSS 样式表。</li>
<li><strong>text&#x2F;javascript</strong>：JavaScript 代码。</li>
</ul>
<h4 id="2-应用类型-application"><a href="#2-应用类型-application" class="headerlink" title="2. 应用类型 (application/)"></a>2. 应用类型 (<code>application/</code>)</h4><ul>
<li><strong>application&#x2F;json</strong>：JSON 格式的数据。目前最常用的前后端数据交互格式。</li>
<li><strong>application&#x2F;xml</strong>：XML 格式的数据。</li>
<li><strong>application&#x2F;pdf</strong>：PDF 文档。</li>
<li><strong>application&#x2F;octet-stream</strong>：通用的<strong>二进制流数据</strong>。通常用于<strong>强制浏览器下载</strong>未知类型的文件，因为它告诉浏览器“这是一个原始的字节流，请不要尝试解析它”。</li>
<li><strong>application&#x2F;x-www-form-urlencoded</strong>：与 <code>enctype</code> 的默认值对应，表明请求体是 URL 编码的键值对。</li>
<li><strong>application&#x2F;javascript</strong>：与 <code>text/javascript</code> 类似，更推荐使用。</li>
</ul>
<h4 id="3-图片类型-image"><a href="#3-图片类型-image" class="headerlink" title="3. 图片类型 (image/)"></a>3. 图片类型 (<code>image/</code>)</h4><ul>
<li><strong>image&#x2F;jpeg</strong>：JPEG&#x2F;JPG 格式的图片。</li>
<li><strong>image&#x2F;png</strong>：PNG 格式的图片。</li>
<li><strong>image&#x2F;gif</strong>：GIF 格式的图片。</li>
<li><strong>image&#x2F;svg+xml</strong>：SVG 矢量图。</li>
</ul>
<h4 id="4-音视频类型"><a href="#4-音视频类型" class="headerlink" title="4. 音视频类型"></a>4. 音视频类型</h4><ul>
<li><strong>audio&#x2F;mpeg</strong>：MP3 音频文件。</li>
<li><strong>video&#x2F;mp4</strong>：MP4 视频文件。</li>
</ul>
<h4 id="5-多部分类型-multipart"><a href="#5-多部分类型-multipart" class="headerlink" title="5. 多部分类型 (multipart/)"></a>5. 多部分类型 (<code>multipart/</code>)</h4><ul>
<li><strong>multipart&#x2F;form-data</strong>：用于文件上传，与 <code>enctype</code> 的值对应。</li>
<li><strong>multipart&#x2F;byteranges</strong>：用于分块下载，支持断点续传。</li>
</ul>
<p>好的，这是一个非常经典的面试题，也是理解 Web 基础知识的关键。我会详细、清晰地解释 URL 和 URI，并用通俗易懂的方式区分它们。</p>
<hr>
<h3 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h3><ul>
<li><strong>URI (Uniform Resource Identifier) - 统一资源标识符</strong><ul>
<li><strong>概念</strong>：URI 是一个用于<strong>标识</strong>互联网上<strong>任何资源</strong>的字符串。它不仅仅能标识网页，还可以标识文件、服务、电子邮箱等。</li>
<li><strong>作用</strong>：<strong>标识</strong>。URI 就像一个资源的“身份证号”，它能唯一地识别一个资源，但<strong>不一定</strong>告诉我们如何访问它。</li>
</ul>
</li>
<li><strong>URL (Uniform Resource Locator) - 统一资源定位符</strong><ul>
<li><strong>概念</strong>：URL 是一个用于<strong>定位</strong>互联网上资源的字符串。它是 URI 的一个<strong>子集</strong>。</li>
<li><strong>作用</strong>：<strong>定位</strong>。URL 就像一个资源的“详细地址”，它不仅标识了资源，还提供了<strong>如何访问该资源</strong>的完整信息，包括协议、主机名、端口号和路径等。</li>
</ul>
</li>
</ul>
<h3 id="二、URL-和-URI-的关系"><a href="#二、URL-和-URI-的关系" class="headerlink" title="二、URL 和 URI 的关系"></a>二、URL 和 URI 的关系</h3><p>用一个比喻来理解：</p>
<ul>
<li><strong>URI</strong> 就像一个人的<strong>名字</strong>。<code>张三</code>这个名字可以标识这个人，但你不知道他在哪里、怎么找到他。</li>
<li><strong>URL</strong> 就像一个人的<strong>家庭住址</strong>。<code>北京市海淀区中关村大街1号</code>。这个地址不仅标识了这个人，还告诉了你如何定位他。</li>
</ul>
<p><strong>因此，所有的 URL 都是 URI，但并非所有的 URI 都是 URL。</strong></p>
<h3 id="三、URL-和-URI-的具体结构"><a href="#三、URL-和-URI-的具体结构" class="headerlink" title="三、URL 和 URI 的具体结构"></a>三、URL 和 URI 的具体结构</h3><h4 id="URI-的结构："><a href="#URI-的结构：" class="headerlink" title="URI 的结构："></a>URI 的结构：</h4><p>一个 URI 通常由两部分组成：</p>
<p><code>scheme:[//authority][path][?query][#fragment]</code></p>
<ul>
<li><code>scheme</code>：协议，如 <code>http</code>, <code>ftp</code>, <code>mailto</code>。</li>
<li><code>path</code>：资源路径。</li>
</ul>
<h4 id="URL-的结构："><a href="#URL-的结构：" class="headerlink" title="URL 的结构："></a>URL 的结构：</h4><p>URL 包含了 URI 的所有组成部分，并加入了定位信息。</p>
<p><code>scheme://host:port/path?query#fragment</code></p>
<ul>
<li><code>scheme</code>：协议。如 <code>http</code>, <code>https</code>, <code>ftp</code>。</li>
<li><code>host</code>：主机名或 IP 地址。</li>
<li><code>port</code>：端口号（可选，如果使用默认端口则可以省略）。</li>
<li><code>path</code>：资源路径。</li>
<li><code>query</code>：查询参数，以 <code>?</code> 开始。</li>
<li><code>fragment</code>：片段标识符，以 <code>#</code> 开始。</li>
</ul>
<h3 id="四、举例说明"><a href="#四、举例说明" class="headerlink" title="四、举例说明"></a>四、举例说明</h3><table>
<thead>
<tr>
<th>字符串</th>
<th>类别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>https://www.google.com/search?q=url+uri</code></td>
<td><strong>URL</strong> 和 <strong>URI</strong></td>
<td>既是 URI（标识），也是 URL（定位），提供了完整的访问信息。</td>
</tr>
<tr>
<td><code>urn:isbn:0451450523</code></td>
<td><strong>URI</strong> 但<strong>不是 URL</strong></td>
<td><code>urn:isbn</code> 是一个 URN (Uniform Resource Name)，它是 URI 的另一种类型，用于标识一本书。它标识了资源，但没有提供如何访问它的位置信息。</td>
</tr>
<tr>
<td><code>/images/logo.png</code></td>
<td><strong>URI</strong> 但<strong>不是 URL</strong></td>
<td>这是一个相对路径，它标识了资源，但没有完整的定位信息（如协议、主机名），需要结合当前页面的 URL 才能确定完整位置。</td>
</tr>
<tr>
<td><code>mailto:test@example.com</code></td>
<td><strong>URI</strong> 但<strong>不是 URL</strong></td>
<td>标识了一个邮箱资源，但无法通过它来定位到具体的文件或服务器。</td>
</tr>
</tbody></table>
<h3 id="五、面试回答总结"><a href="#五、面试回答总结" class="headerlink" title="五、面试回答总结"></a>五、面试回答总结</h3><ol>
<li><p><strong>开门见山</strong>：URL 是 URI 的子集。</p>
</li>
<li><p><strong>核心区别</strong>：</p>
<ul>
<li><strong>URI 是标识符</strong>，它只负责<strong>标识</strong>一个资源，不提供如何访问它的信息。</li>
<li><strong>URL 是定位符</strong>，它在标识资源的同时，还提供了<strong>定位</strong>该资源的完整信息，如协议、主机名等。</li>
</ul>
</li>
<li><p><strong>举例</strong>：</p>
<ul>
<li>URL：<code>https://www.example.com/index.html</code>，包含了协议、主机、路径，可以明确地定位一个资源。</li>
<li>URI：<code>urn:isbn:0451450523</code>，它标识了一本书，但你无法通过它来访问这本书的电子版。</li>
</ul>
</li>
<li><p><strong>关系图</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------------+</span><br><span class="line">|      URI    |</span><br><span class="line">|             |</span><br><span class="line">|  +----------+---------+</span><br><span class="line">|  |   URL    |   URN   |</span><br><span class="line">|  | (定位)   |  (命名) |</span><br><span class="line">|  +----------+---------+</span><br><span class="line">|             |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>用这个图能非常清晰地展现它们之间的关系。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/11/web/" data-id="cmffake6o000550uy2oso86ze" data-title="web" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo-Markdown/" rel="tag">Hexo, Markdown</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-分布式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2025-09-11T10:29:28.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="1-Spring-Cloud-体系"><a href="#1-Spring-Cloud-体系" class="headerlink" title="1. Spring Cloud 体系"></a><strong>1. Spring Cloud 体系</strong></h4><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h5><p>Spring Cloud 并非一个全新的框架，而是一套用于构建微服务架构的<strong>规范和解决方案的集合</strong>。它巧妙地利用了 Spring Boot 的自动配置和快速开发特性，将业界经过广泛验证的优秀微服务组件（如 Netflix OSS、Alibaba Nacos、HashiCorp Consul 等）进行封装和集成，为开发者提供了一站式的分布式系统开发工具箱，涵盖了服务治理、配置管理、熔断降级、智能路由、服务调用等方方面面。</p>
<h5 id="Netflix-OSS-常用组件（部分进入维护模式）"><a href="#Netflix-OSS-常用组件（部分进入维护模式）" class="headerlink" title="Netflix OSS 常用组件（部分进入维护模式）"></a><strong>Netflix OSS 常用组件（部分进入维护模式）</strong></h5><ul>
<li><strong>服务注册与发现 (Service Discovery): Eureka</strong><ul>
<li><strong>作用</strong>: 提供一个服务注册中心。每个微服务启动时，将自己的网络地址等信息“注册”到 Eureka Server。其他服务（消费者）则从 Eureka Server “发现”并拉取所需服务提供者的地址列表，从而实现服务间的动态寻址和调用。</li>
<li><strong>使用</strong>: 服务端添加 <code>spring-cloud-starter-netflix-eureka-server</code> 依赖，并使用 <code>@EnableEurekaServer</code> 注解。客户端添加 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖，并配置 Eureka Server 地址。</li>
</ul>
</li>
<li><strong>服务调用与负载均衡 (RPC &amp; Load Balancing): OpenFeign + Ribbon</strong><ul>
<li><strong>作用</strong>: Feign 让远程服务调用变得像调用本地方法一样简单。开发者只需定义一个接口，并使用 <code>@FeignClient</code> 注解，即可完成对远程服务的调用。Ribbon（现已被 Spring Cloud LoadBalancer 替代）则提供了客户端负载均衡能力，当从 Eureka 获取到多个服务实例地址时，Ribbon 会根据配置的策略（如轮询、随机）选择一个实例进行调用。</li>
<li><strong>使用</strong>: 添加 <code>spring-cloud-starter-openfeign</code> 依赖，在启动类上加 <code>@EnableFeignClients</code>，创建接口并使用 <code>@FeignClient(&quot;service-name&quot;)</code> 注解。</li>
</ul>
</li>
<li><strong>熔断与降级 (Circuit Breaker): Hystrix</strong><ul>
<li><strong>作用</strong>: 当某个下游服务出现故障或响应缓慢时，为了防止故障在系统中蔓延（即“服务雪崩”），熔断器会快速失败，暂时切断对该服务的调用。同时，可以执行一个预定义的降级逻辑（Fallback），例如返回一个缓存的、默认的或友好的提示信息。</li>
<li><strong>状态</strong>: Hystrix 已进入维护模式，官方推荐使用 Resilience4j 或其他替代方案。</li>
</ul>
</li>
<li><strong>API 网关 (API Gateway): Zuul</strong><ul>
<li><strong>作用</strong>: 作为系统的统一入口，API 网关负责请求路由、协议转换、权限校验、流量控制、日志监控等。所有外部请求都先经过网关，再由网关分发到后端的各个微服务。</li>
<li><strong>状态</strong>: Zuul 1.x 已进入维护模式，官方推荐使用 Spring Cloud Gateway。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Spring-Cloud-Alibaba-详解"><a href="#Spring-Cloud-Alibaba-详解" class="headerlink" title="Spring Cloud Alibaba 详解"></a><strong>Spring Cloud Alibaba 详解</strong></h5><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案，是 Spring Cloud 体系的重要实现。它集成了阿里巴巴开源的优秀组件，为开发者提供了更符合国内技术生态的选择。</p>
<ul>
<li><strong>服务注册与发现 &amp; 分布式配置中心: Nacos</strong><ul>
<li><strong>作用</strong>: Nacos (Naming and Configuration Service) 是一个功能丰富的平台，完美整合了<strong>服务注册发现</strong>和<strong>配置管理</strong>两大核心功能。<ul>
<li><strong>服务发现</strong>: 与 Eureka 类似，提供服务注册、发现和健康检查。但 Nacos 支持基于 DNS 和 RPC 的服务发现，并提供更实时的健康检查机制。</li>
<li><strong>配置管理</strong>: 可以作为分布式配置中心，对所有微服务的配置进行集中化管理。支持配置的热更新，即修改配置后无需重启服务即可生效。还支持配置的版本管理、灰度发布等高级功能。</li>
</ul>
</li>
<li><strong>使用</strong>:<ol>
<li>引入 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 和 <code>spring-cloud-starter-alibaba-nacos-config</code> 依赖。</li>
<li>在 <code>bootstrap.properties</code> (或 <code>.yml</code>) 文件中配置 Nacos 服务器地址和应用名。</li>
<li>使用 <code>@Value</code> 或 <code>@ConfigurationProperties</code> 注解即可动态获取和刷新配置。</li>
</ol>
</li>
</ul>
</li>
<li><strong>熔断、降级与流量控制: Sentinel</strong><ul>
<li><strong>作用</strong>: Sentinel 是面向分布式服务架构的“流量的守护者”，以流量为切入点，从<strong>流量控制、熔断降级、系统负载保护</strong>等多个维度保护服务的稳定性。相较于 Hystrix，Sentinel 功能更强大，提供了可视化的监控和配置平台，并且支持热点参数限流等精细化控制。</li>
<li><strong>核心概念</strong>:<ul>
<li><strong>资源 (Resource)</strong>: Sentinel 中一切皆资源，可以是一个方法、一段代码或一个服务 URL。</li>
<li><strong>规则 (Rule)</strong>: 定义如何保护资源，包括流控规则、降级规则、系统保护规则等。</li>
</ul>
</li>
<li><strong>使用</strong>:<ol>
<li>引入 <code>spring-cloud-starter-alibaba-sentinel</code> 依赖。</li>
<li>配置 Sentinel 控制台地址。</li>
<li>通过 <code>@SentinelResource</code> 注解来定义资源，并指定 Fallback (降级逻辑) 和 BlockHandler (流控&#x2F;熔断逻辑)。</li>
</ol>
</li>
</ul>
</li>
<li><strong>分布式事务解决方案: Seata</strong><ul>
<li><strong>作用</strong>: Seata 是一个开源的分布式事务解决方案，提供了高性能且易于使用的分布式事务服务。它支持多种事务模式，包括 AT（自动补偿）、TCC、Saga 和 XA 模式，旨在解决微服务架构下的数据一致性问题。</li>
<li><strong>使用</strong>: 引入 <code>spring-cloud-starter-alibaba-seata</code> 依赖，配置 Seata Server 地址，并使用 <code>@GlobalTransactional</code> 注解开启全局事务。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-分布式ID：雪花算法（Snowflake）"><a href="#2-分布式ID：雪花算法（Snowflake）" class="headerlink" title="2. 分布式ID：雪花算法（Snowflake）"></a><strong>2. 分布式ID：雪花算法（Snowflake）</strong></h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>Snowflake 是 Twitter 开源的一种分布式 ID 生成算法，它能生成一个 64 位的 <code>long</code> 型数字作为全局唯一 ID。这个 64 位的 ID 由四部分构成：</p>
<ul>
<li><strong>1位符号位</strong>: 最高位，固定为0，表示正数，无实际意义。</li>
<li><strong>41位时间戳 (Timestamp)</strong>: 精确到毫秒级，是 <code>(当前时间戳 - 起始时间戳)</code> 的差值。41位可以表示 (241−1) 毫秒，大约可以使用 69 年。</li>
<li><strong>10位工作机器ID (Worker ID)</strong>: 这 10 位可以被灵活划分，例如前 5 位代表数据中心 ID (Datacenter ID)，后 5 位代表机器 ID (Machine ID)。这样总共可以支持 210&#x3D;1024 台机器。</li>
<li><strong>12位序列号 (Sequence)</strong>: 表示在同一毫秒内，同一台机器上生成的 ID 序列号。12位意味着每台机器每毫秒可以生成 212&#x3D;4096 个不同的 ID。</li>
</ul>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h5><ul>
<li><strong>全局唯一</strong>: 通过时间戳、机器 ID 和序列号的组合，可以保证在分布式环境下的 ID 唯一性。</li>
<li><strong>趋势递增</strong>: 由于时间戳在高位，所以生成的 ID 整体上是按时间趋势递增的，这对于数据库索引（特别是 B+树）非常友好，可以减少页分裂，提高插入性能。</li>
<li><strong>高性能</strong>: ID 在本地生成，不依赖任何外部服务（如数据库或 Redis），生成效率极高。</li>
<li><strong>高可用</strong>: 算法本身不依赖网络，部署简单，具有很高的可用性。</li>
</ul>
<h5 id="面试题：“雪花算法有时钟回拨问题，如何解决？”"><a href="#面试题：“雪花算法有时钟回拨问题，如何解决？”" class="headerlink" title="面试题：“雪花算法有时钟回拨问题，如何解决？”"></a><strong>面试题：“雪花算法有时钟回拨问题，如何解决？”</strong></h5><p>回答要点:</p>
<p>时钟回拨是指服务器时间被同步到一个过去的时间点。如果算法不做处理，可能会生成重复的 ID。解决方案通常是：在生成 ID 时，记录上一次生成 ID 时所使用的时间戳。当发现当前时间戳小于上次记录的时间戳时，就意味着发生了时钟回拨。</p>
<ul>
<li><strong>方案一（拒绝服务）</strong>: 直接抛出异常，拒绝生成 ID，等待时钟恢复正常。这种方案简单，但会暂时影响可用性，适合对 ID 连续性要求不高的场景。</li>
<li><strong>方案二（等待追赶）</strong>: 如果回拨幅度很小（比如几毫秒），程序可以 <code>while(currentTime &lt; lastTimestamp)</code> 这样自旋等待，直到当前时间追赶上上次的时间戳。这会造成短暂的线程阻塞。</li>
<li><strong>方案三（使用备用位）</strong>: 一些改进版的雪花算法会预留几位作为扩展位，当发生时钟回拨时，在这几位上做自增，从而在短时间回拨内仍能生成不同的 ID。（这种方案实现较为复杂）</li>
<li><strong>业界实践（美团 Leaf）</strong>: 在发生时钟回拨时，切换到另一种备用 ID 生成策略（如号段模式），或者直接报错。</li>
</ul>
<hr>
<h4 id="3-RBAC（基于角色的访问控制）"><a href="#3-RBAC（基于角色的访问控制）" class="headerlink" title="3. RBAC（基于角色的访问控制）"></a><strong>3. RBAC（基于角色的访问控制）</strong></h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>RBAC (Role-Based Access Control) 是一种主流且灵活的权限管理模型。它的核心思想是在 <strong>用户 (User)</strong> 和 <strong>权限 (Permission)</strong> 之间引入一个中间层——<strong>角色 (Role)</strong>。权限不再直接授予用户，而是授予角色；然后将角色分配给用户。这样，用户与权限实现了解耦，当需要修改大量用户的权限时，只需修改他们共同拥有的角色的权限即可，极大地简化了权限管理和维护。</p>
<h5 id="核心三要素"><a href="#核心三要素" class="headerlink" title="核心三要素"></a><strong>核心三要素</strong></h5><ul>
<li><strong>用户 (User)</strong>: 系统操作的主体。</li>
<li><strong>角色 (Role)</strong>: 权限的集合，代表了一组特定的职责或身份，如“管理员”、“文章编辑”、“普通会员”。</li>
<li><strong>权限 (Permission)</strong>: 对系统中特定资源进行特定操作的许可。通常用一个字符串表示，如 <code>user:create</code>、<code>order:delete</code>、<code>article:publish</code>。</li>
</ul>
<h5 id="面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”"><a href="#面试题：“请设计一个-RBAC-权限管理系统的数据库表结构。”" class="headerlink" title="面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”"></a><strong>面试题：“请设计一个 RBAC 权限管理系统的数据库表结构。”</strong></h5><p>回答要点:</p>
<p>一个基础的 RBAC 模型至少需要五张表：</p>
<ul>
<li><strong>用户表 (t_user)</strong>: 存储用户信息。<ul>
<li><code>user_id</code> (主键), <code>username</code>, <code>password</code>, …</li>
</ul>
</li>
<li><strong>角色表 (t_role)</strong>: 存储角色信息。<ul>
<li><code>role_id</code> (主键), <code>role_name</code> (角色名, 如”管理员”), <code>role_key</code> (角色标识, 如”admin”), …</li>
</ul>
</li>
<li><strong>权限表 (t_permission)</strong>: 存储具体的权限点信息。<ul>
<li><code>permission_id</code> (主键), <code>permission_name</code> (权限名称, 如“新增用户”), <code>permission_code</code> (权限标识, 如 <code>user:add</code>), <code>parent_id</code> (用于菜单层级), …</li>
</ul>
</li>
<li><strong>用户-角色关联表 (t_user_role)</strong>: 存储用户和角色的多对多关系。<ul>
<li><code>user_id</code> (外键), <code>role_id</code> (外键)。(主键是 <code>user_id</code> 和 <code>role_id</code> 的联合主键)</li>
</ul>
</li>
<li><strong>角色-权限关联表 (t_role_permission)</strong>: 存储角色和权限的多对多关系。<ul>
<li><code>role_id</code> (外键), <code>permission_id</code> (外键)。(主键是 <code>role_id</code> 和 <code>permission_id</code> 的联合主键)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-Redis-进阶详解"><a href="#4-Redis-进阶详解" class="headerlink" title="4. Redis 进阶详解"></a><strong>4. Redis 进阶详解</strong></h4><h5 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h5><ul>
<li><strong>基于内存</strong>: Redis 是一个内存数据结构存储系统，所有数据都存放在内存中，因此读写速度极快。</li>
<li><strong>单线程模型</strong>: Redis 的核心网络模型处理客户端请求是单线程的。这避免了多线程环境下的上下文切换和锁竞争带来的开销。（注意：Redis 6.0 之后引入了多线程来处理 I&#x2F;O，但执行命令的核心仍然是单线程）。</li>
<li><strong>IO多路复用</strong>: 单线程能实现高性能的关键在于它使用了 IO 多路复用技术（如 Linux 下的 epoll）。该技术允许单个线程同时监听多个网络连接上的 IO 事件，当某个连接准备好读或写时，才去处理它，极大地提高了并发处理能力。</li>
<li><strong>丰富的数据类型</strong>: 支持 String, Hash, List, Set, Sorted Set, Bitmap, HyperLogLog, GEO 等多种数据结构。</li>
</ul>
<h5 id="缓存三大问题与解决方案"><a href="#缓存三大问题与解决方案" class="headerlink" title="缓存三大问题与解决方案"></a><strong>缓存三大问题与解决方案</strong></h5><ul>
<li><strong>缓存穿透</strong>:<ul>
<li><strong>问题</strong>: 客户端查询一个数据库和缓存中<strong>都</strong>不存在的数据。这导致每次请求都会绕过缓存，直接打到数据库上，当有大量此类请求时，会给数据库带来巨大压力。</li>
<li><strong>解决</strong>:<ol>
<li><strong>缓存空对象</strong>: 当从数据库查询不到数据时，也在缓存中存入一个特殊的空值（如 <code>null</code> 或特定字符串），并设置一个较短的过期时间。</li>
<li><strong>布隆过滤器 (Bloom Filter)</strong>: 在访问缓存之前，先通过布隆过滤器判断 key 是否<strong>可能</strong>存在。布隆过滤器可以高效地判断一个元素<strong>一定不存在</strong>，从而在第一层就拦截掉大量无效请求。</li>
</ol>
</li>
</ul>
</li>
<li><strong>缓存击穿</strong>:<ul>
<li><strong>问题</strong>: 某个<strong>热点 Key</strong> 在某一时刻突然失效，而此时恰好有大量的并发请求访问这个 Key，这些请求会同时穿透缓存，直接打到数据库上，可能导致数据库瞬间崩溃。</li>
<li><strong>解决</strong>:<ol>
<li><strong>设置热点 Key 永不过期</strong>: 对于一些访问极其频繁且数据相对固定的热点数据，可以考虑不设置过期时间，通过后台任务定时更新。</li>
<li><strong>使用分布式锁</strong>: 在查询数据库之前，先获取一个该 Key 对应的分布式锁。只有第一个获取到锁的线程才能去查询数据库并回写缓存，其他线程则等待或直接返回。</li>
</ol>
</li>
</ul>
</li>
<li><strong>缓存雪崩</strong>:<ul>
<li><strong>问题</strong>: 大量的缓存 Key 在<strong>同一时间集中失效</strong>（例如，在应用启动时缓存了大量数据，并设置了相同的过期时间），导致所有请求都瞬间涌向数据库，造成数据库压力剧增甚至宕机。</li>
<li><strong>解决</strong>:<ol>
<li><strong>过期时间加随机值</strong>: 在设置缓存的过期时间时，在一个基础时间上增加一个随机数，使得 Key 的失效时间点尽可能分散。</li>
<li><strong>多级缓存</strong>: 建立多级缓存体系，如 Nginx 缓存 + Redis 缓存 + JVM 本地缓存（Caffeine&#x2F;Guava Cache）。</li>
<li><strong>熔断降级</strong>: 使用 Hystrix 或 Sentinel 等组件，当检测到数据库压力过大时，进行熔断或降级处理，暂时不访问数据库，返回一个默认值或提示信息。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-消息队列（MQ）"><a href="#5-消息队列（MQ）" class="headerlink" title="5. 消息队列（MQ）"></a><strong>5. 消息队列（MQ）</strong></h4><h5 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a><strong>核心作用</strong></h5><ul>
<li><strong>异步 (Asynchronous)</strong>: 将耗时的操作（如发送邮件、生成报表）作为消息放入 MQ，主流程可以立即返回，无需等待这些操作完成，从而提高系统的响应速度和吞吐量。</li>
<li><strong>解耦 (Decoupling)</strong>: 生产者和消费者之间通过 MQ 进行通信，无需直接相互依赖。任何一方的修改、宕机或升级都不会影响到另一方，增强了系统的灵活性和可维护性。</li>
<li><strong>削峰 (Peak Shaving)</strong>: 在秒杀、大促等高并发场景下，将瞬时涌入的大量请求暂存在 MQ 中，下游的消费者系统可以按照自己的处理能力，平稳地从 MQ 中拉取并处理请求，避免了流量洪峰直接冲垮下游服务。</li>
</ul>
<h5 id="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"><a href="#面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”" class="headerlink" title="面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”"></a><strong>面试题：“请列举你使用消息队列时可能遇到的问题，并给出解决方案。”</strong></h5><p><strong>回答要点</strong>:</p>
<ul>
<li><strong>消息丢失 (Message Loss)</strong>:<ul>
<li><strong>问题</strong>: 消息从生产者发出后，由于网络或 MQ 服务故障，未能成功到达消费者。</li>
<li><strong>解决</strong>:<ol>
<li><strong>生产者端</strong>: 开启生产者的 <code>confirm</code> 或 <code>ack</code> 机制，确保消息被 MQ 成功接收。如果发送失败，可以进行重试。</li>
<li><strong>MQ 服务端</strong>: 对消息进行持久化，防止 MQ 宕机导致消息丢失（如 RabbitMQ 的持久化队列和消息，Kafka 的磁盘存储）。</li>
<li><strong>消费者端</strong>: 消费者在处理完业务逻辑后，再向 MQ 发送确认应答（<code>ack</code>）。如果处理过程中消费者宕机，MQ 没有收到 <code>ack</code>，会将该消息重新投递给其他消费者。</li>
</ol>
</li>
</ul>
</li>
<li><strong>重复消费 (Duplicate Consumption)</strong>:<ul>
<li><strong>问题</strong>: 由于网络抖动、消费者 <code>ack</code> 超时等原因，MQ 可能会重复投递同一条消息。</li>
<li><strong>解决</strong>: 核心是保证消费逻辑的<strong>幂等性 (Idempotence)</strong>。即多次执行同一个操作，结果都是相同的。实现方式有：<ol>
<li>在数据库中为业务操作创建一个<strong>唯一键</strong>，每次操作前先检查该唯一键是否存在。</li>
<li>使用一个全局唯一的<strong>业务 ID</strong>（如订单号），在处理消息前，先查询这个 ID 是否已经被处理过（例如，存入 Redis Set 或数据库）。</li>
</ol>
</li>
</ul>
</li>
<li><strong>消息堆积 (Message Backlog)</strong>:<ul>
<li><strong>问题</strong>: 生产者的生产速度远大于消费者的消费速度，导致大量消息在 MQ 中积压，占用资源并可能导致消息超时丢失。</li>
<li><strong>解决</strong>:<ol>
<li><strong>水平扩展消费者</strong>: 增加消费者实例的数量，并行处理消息。这是最常用的方法。</li>
<li><strong>优化消费逻辑</strong>: 检查消费者代码，看是否有可以优化的慢操作（如 I&#x2F;O 密集型操作）。</li>
<li><strong>消息分片&#x2F;分区</strong>: 对 Topic 进行分区（Partitioning），让不同的消费者组处理不同的分区，提高并发度。</li>
<li><strong>增加预警监控</strong>: 对消息堆积数量设置阈值，达到阈值时及时告警，人工介入。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-分布式锁详解"><a href="#6-分布式锁详解" class="headerlink" title="6. 分布式锁详解"></a><strong>6. 分布式锁详解</strong></h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在分布式系统环境下，多个进程或服务器上的多个线程需要访问同一个共享资源时，为了保证数据的一致性和操作的原子性，需要一种机制来确保在同一时刻，只有一个客户端能够持有锁并访问该资源。</p>
<h5 id="实现方案对比"><a href="#实现方案对比" class="headerlink" title="实现方案对比"></a><strong>实现方案对比</strong></h5><table>
<thead>
<tr>
<th>实现方式</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基于数据库</strong></td>
<td>实现简单，直接利用数据库（如唯一索引、悲观锁 <code>for update</code>）。</td>
<td>性能开销大，有锁库锁表的风险，不可重入，不是阻塞锁，数据库单点故障问题。</td>
<td>并发度不高的简单场景。</td>
</tr>
<tr>
<td><strong>基于 ZooKeeper</strong></td>
<td>可靠性高，天然支持阻塞锁和可重入，解决死锁问题（临时节点），无锁过期问题，支持公平锁。</td>
<td>性能不如 Redis，实现复杂，依赖 ZK 集群。</td>
<td>对可靠性要求极高，且能容忍一定性能损耗的场景，如分布式协调。</td>
</tr>
<tr>
<td><strong>基于 Redis</strong></td>
<td>性能极高，实现相对简单，有成熟的框架 (Redisson) 可用。</td>
<td>可靠性相对 ZK 稍差，需要处理锁过期和业务未执行完的问题，非公平锁。</td>
<td>互联网高并发、对性能要求高的绝大多数场景。</td>
</tr>
</tbody></table>
<h5 id="基于-Redis-的实现进阶"><a href="#基于-Redis-的实现进阶" class="headerlink" title="基于 Redis 的实现进阶"></a><strong>基于 Redis 的实现进阶</strong></h5><ul>
<li><p>加锁的正确姿势:</p>
<p>使用 SET key value NX EX time 命令。</p>
<ul>
<li><p><code>SET key value</code>: 设置键值。<code>value</code> 通常是一个唯一的随机字符串（如 UUID），用于标识锁的持有者。</p>
</li>
<li><p><code>NX</code>: (if Not eXists)，确保只有在 key 不存在时才能设置成功，实现了“加锁”的原子性。</p>
</li>
<li><p>EX time: 设置一个自动过期时间（秒），防止因客户端宕机而导致死锁。</p>
<p>这三个参数必须在一个命令中执行，保证原子性。</p>
</li>
</ul>
</li>
<li><p><strong>解锁的正确姿势：Lua 脚本</strong></p>
<ul>
<li><p><strong>为什么需要 Lua</strong>: 解锁操作包含“判断”和“删除”两步：1. <code>GET</code> 锁的 <code>value</code>，判断是否与自己加锁时设置的随机字符串相等。2. 如果相等，则 <code>DEL</code> 锁。如果不用 Lua 脚本，在执行完第一步后，若该线程阻塞，此时锁恰好过期，另一个线程获取了锁，那么当原线程恢复执行第二步时，就会<strong>误删掉新线程的锁</strong>。</p>
</li>
<li><p><strong>Lua 脚本示例</strong>:</p>
<p>Lua</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 脚本接收两个参数：KEYS[1] 是锁的 key，ARGV[1] 是加锁时设置的唯一值</span><br><span class="line">if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Lua 脚本可以确保多个命令在 Redis 服务端被原子性地执行，杜绝了上述问题。</p>
</li>
<li><p><strong>Redis 乐观锁：WATCH 命令</strong></p>
<ul>
<li><p><strong>作用</strong>: <code>WATCH</code> 命令可以监视一个或多个 key，如果在事务 <code>EXEC</code> 执行之前，任何一个被监视的 key 被其他命令修改了，那么整个事务将被取消，<code>EXEC</code> 返回 <code>nil</code>。</p>
</li>
<li><p><strong>原理</strong>: 这是一种<strong>检查后设置 (Check-And-Set, CAS)</strong> 的实现。它不是真正的加锁，而是在更新数据时检查数据是否被修改过。</p>
</li>
<li><p><strong>使用场景</strong>: 适用于<strong>读多写少</strong>的并发场景，可以减少锁的开销。例如，更新商品库存。</p>
<ol>
<li><p><code>WATCH stock_key</code> &#x2F;&#x2F; 监视库存</p>
</li>
<li><p><code>current_stock = GET stock_key</code> &#x2F;&#x2F; 获取当前库存</p>
</li>
<li><p>(在客户端代码中判断 <code>current_stock</code> 是否足够)</p>
</li>
<li><p><code>MULTI</code> &#x2F;&#x2F; 开启事务</p>
</li>
<li><p><code>SET stock_key new_stock</code> &#x2F;&#x2F; 准备更新库存</p>
</li>
<li><p>EXEC &#x2F;&#x2F; 执行事务</p>
<p>如果从 WATCH 到 EXEC 之间 stock_key 被其他客户端修改，EXEC 将失败，此时客户端需要重试整个操作。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”"><a href="#面试题：“Redis-分布式锁锁过期了但业务没执行完怎么办？”" class="headerlink" title="面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”"></a><strong>面试题：“Redis 分布式锁锁过期了但业务没执行完怎么办？”</strong></h5><p>回答要点:</p>
<p>这是分布式锁的一个经典问题，被称为锁的超时续期问题。</p>
<ul>
<li><strong>问题根源</strong>: 我们给锁设置了一个过期时间，比如 30 秒，但业务执行了 35 秒。在第 30 秒时锁会自动释放，其他线程就能获取到锁，导致并发问题。</li>
<li><strong>解决方案：“看门狗”(Watchdog)机制</strong>。<ul>
<li><strong>原理</strong>: 比如 Java 中的 Redisson 框架就内置了看门狗。当一个线程获取锁成功后，Redisson 会启动一个后台线程（看门狗），定期（例如每 10 秒）检查该线程是否还持有锁。如果持有，并且业务仍在执行，看门狗就会自动为这个锁<strong>延长过期时间</strong>（续期），比如再续 30 秒。这个过程会一直持续，直到业务执行完毕，线程主动释放锁，看门狗才会停止。</li>
<li><strong>总结</strong>: 看门狗机制通过后台线程自动续期，确保了在业务执行完成之前，锁不会因为超时而提前释放，从而保证了锁的可靠性。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-分布式事务详解"><a href="#7-分布式事务详解" class="headerlink" title="7. 分布式事务详解"></a><strong>7. 分布式事务详解</strong></h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>在微服务架构中，一个业务操作可能需要调用多个独立的服务来共同完成（例如，电商下单操作需要调用订单服务、库存服务、积分服务）。分布式事务旨在保证这些跨服务的数据库操作能够遵循 ACID 原则，要么全部成功，要么全部回滚，以确保数据的<strong>最终一致性</strong>。</p>
<h5 id="解决方案深入分析"><a href="#解决方案深入分析" class="headerlink" title="解决方案深入分析"></a><strong>解决方案深入分析</strong></h5><ul>
<li><strong>XA (2PC&#x2F;3PC)</strong>: 两阶段&#x2F;三阶段提交协议。<ul>
<li><strong>角色</strong>: 事务管理器 (Transaction Manager, TM) 和 资源管理器 (Resource Manager, RM)。</li>
<li><strong>流程 (2PC)</strong>:<ol>
<li><strong>准备阶段 (Prepare)</strong>: TM 通知所有 RM 准备提交，RM 执行本地事务并锁定资源，但不提交，然后向 TM 报告准备就绪。</li>
<li><strong>提交&#x2F;回滚阶段 (Commit&#x2F;Rollback)</strong>: 如果所有 RM 都准备就绪，TM 通知所有 RM 提交；否则，通知所有 RM 回滚。</li>
</ol>
</li>
<li><strong>评价</strong>: 是一种<strong>强一致性</strong>的方案，但协议复杂，性能差，同步阻塞模型会长时间锁定资源，且协调器存在单点故障风险，在互联网高并发场景下<strong>很少使用</strong>。</li>
</ul>
</li>
<li><strong>TCC (Try-Confirm-Cancel)</strong>: 补偿型事务。<ul>
<li><strong>核心</strong>: 是一种<strong>业务层面</strong>的柔性事务方案，对代码侵入性强。</li>
<li><strong>流程</strong>:<ol>
<li><strong>Try</strong>: 对业务资源进行<strong>检查和预留</strong>。例如，扣减库存操作，Try 阶段是冻结库存。</li>
<li><strong>Confirm</strong>: 如果所有服务的 Try 阶段都成功，则执行所有服务的 <strong>Confirm</strong> 操作，真正完成业务。例如，将冻结的库存真实扣减。</li>
<li><strong>Cancel</strong>: 如果任何一个服务的 Try 阶段失败，则执行所有已成功服务的 <strong>Cancel</strong> 操作，释放预留的资源。例如，解冻之前被冻结的库存。</li>
</ol>
</li>
<li><strong>评价</strong>: 性能较好，数据一致性高于可靠消息方案。但开发成本极高，需要为每个操作都编写 Try, Confirm, Cancel 三个幂等的方法。</li>
</ul>
</li>
<li><strong>Saga 模式</strong>: 长事务解决方案。<ul>
<li><strong>核心</strong>: 将一个大的分布式事务拆分成多个<strong>本地事务</strong>，每个本地事务都有一个对应的<strong>补偿操作</strong>。</li>
<li><strong>流程</strong>:<ul>
<li><strong>正向执行</strong>: Saga 协调器按顺序调用 T1, T2, T3…Tn。</li>
<li><strong>反向补偿</strong>: 如果 Ti 失败，Saga 会按相反顺序调用前面已成功事务的补偿操作 C(i-1)…C2, C1，进行回滚。</li>
</ul>
</li>
<li><strong>与 TCC 对比</strong>:<ul>
<li>TCC 有资源<strong>预留</strong>阶段，锁资源时间长；Saga 没有预留，直接提交本地事务，锁资源时间短。</li>
<li>TCC 的补偿是<strong>逆向操作</strong> (Cancel)；Saga 的补偿是<strong>反向操作</strong>。</li>
</ul>
</li>
<li><strong>评价</strong>: 适合于业务流程长、需要保证最终一致性的场景。同样对代码有侵入性，需要设计好每个子事务的补偿逻辑。</li>
</ul>
</li>
<li><strong>基于可靠消息的最终一致性 (常用)</strong>:<ul>
<li><strong>核心</strong>: 这是微服务架构中<strong>最常用</strong>的柔性事务方案。</li>
<li><strong>原理</strong>: 服务 A 在执行完本地事务后，发送一条消息到 MQ。服务 B 订阅该消息，消费消息并执行自己的本地事务。</li>
<li><strong>关键问题</strong>: 如何保证<strong>本地事务执行</strong>和<strong>消息发送</strong>的原子性？<ul>
<li><strong>事务消息 (RocketMQ 支持)</strong>: 生产者先发送一条“半消息”到 MQ，MQ 收到后不投递。然后生产者执行本地事务。如果事务成功，则向 MQ 发送确认，MQ 投递该消息；如果事务失败，则通知 MQ 删除该半消息。</li>
<li><strong>本地消息表</strong>: 业务操作和“待发送消息”记录在同一本地事务中。一个后台任务定时扫描这张表，将消息发送到 MQ，发送成功后更新表状态。</li>
</ul>
</li>
<li><strong>评价</strong>: 实现了服务间的解耦，性能高，吞吐量大。但它不保证数据的强一致性，只保证<strong>最终一致性</strong>，存在一个短暂的数据不一致状态窗口。需要处理好消息的可靠投递和幂等消费问题。</li>
</ul>
</li>
</ul>
<h3 id="Lua-脚本详解-在-Redis-中的应用"><a href="#Lua-脚本详解-在-Redis-中的应用" class="headerlink" title="Lua 脚本详解 (在 Redis 中的应用)"></a><strong>Lua 脚本详解 (在 Redis 中的应用)</strong></h3><h4 id="1-Lua-是什么？"><a href="#1-Lua-是什么？" class="headerlink" title="1. Lua 是什么？"></a><strong>1. Lua 是什么？</strong></h4><p>Lua 是一种轻量级、可扩展的脚本语言，被设计用于嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。它以其简洁的语法、高效的执行性能和极小的内存占用而闻名。</p>
<p>在 Redis 的上下文中，Lua 脚本提供了一种在 Redis 服务器端执行复杂逻辑的强大能力。</p>
<h4 id="2-为什么-Redis-要支持-Lua-脚本？"><a href="#2-为什么-Redis-要支持-Lua-脚本？" class="headerlink" title="2. 为什么 Redis 要支持 Lua 脚本？"></a><strong>2. 为什么 Redis 要支持 Lua 脚本？</strong></h4><ul>
<li><strong>原子性 (Atomicity)</strong>: 这是在 Redis 中使用 Lua 最核心的原因。Redis 会将整个 Lua 脚本作为一个单独的命令来执行，<strong>在脚本执行期间，不会有其他客户端的命令被插入执行</strong>。这完美地解决了需要组合多个 Redis 命令才能完成一个业务逻辑时，可能出现的竞态条件问题。例如前面提到的“判断锁并删除锁”的操作，如果分两步执行，就不是原子的，而封装在 Lua 脚本中就是原子的。</li>
<li><strong>减少网络开销</strong>: 对于需要多次与 Redis 交互的复杂操作，可以将所有逻辑封装在一个 Lua 脚本中，一次性发送给 Redis 服务器。客户端只需发送一次请求，而不是多次，这显著减少了客户端与服务器之间的网络往返时间（RTT），提升了性能。</li>
<li><strong>代码复用</strong>: 编写好的 Lua 脚本可以被缓存（通过 <code>SCRIPT LOAD</code> 命令生成一个 SHA1 校验和），之后客户端可以通过这个简短的 SHA1 校验和（使用 <code>EVALSHA</code> 命令）来调用脚本，避免了每次都发送完整的脚本内容。</li>
</ul>
<h4 id="3-如何在-Redis-中使用-Lua-脚本？"><a href="#3-如何在-Redis-中使用-Lua-脚本？" class="headerlink" title="3. 如何在 Redis 中使用 Lua 脚本？"></a><strong>3. 如何在 Redis 中使用 Lua 脚本？</strong></h4><p>通过 EVAL 或 EVALSHA 命令来执行。</p>
<p>EVAL script numkeys key [key …] arg [arg …]</p>
<ul>
<li><code>script</code>: 要执行的 Lua 脚本字符串。</li>
<li><code>numkeys</code>: 后面跟的 <code>key</code> 参数的数量。这有助于 Redis 正确地将参数区分为键名（<code>KEYS</code>）和普通参数（<code>ARGV</code>），这对于 Redis Cluster 模式下的路由至关重要。</li>
<li><code>key [key ...]</code>：脚本中要操作的 Redis 键，在 Lua 脚本中可以通过全局变量 <code>KEYS</code> table（例如 <code>KEYS[1]</code>）来访问。</li>
<li><code>arg [arg ...]</code>：传递给脚本的额外参数，在 Lua 脚本中可以通过全局变量 <code>ARGV</code> table（例如 <code>ARGV[1]</code>）来访问。</li>
</ul>
<p><strong>示例：实现一个安全的库存扣减</strong></p>
<p>Lua</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 脚本逻辑：检查库存是否充足，如果充足则扣减并返回1，否则返回0</span><br><span class="line">-- KEYS[1]: 库存的 key，例如 &quot;product:1001:stock&quot;</span><br><span class="line">-- ARGV[1]: 本次要扣减的数量</span><br><span class="line"></span><br><span class="line">local stock = tonumber(redis.call(&#x27;get&#x27;, KEYS[1]))</span><br><span class="line">local quantity = tonumber(ARGV[1])</span><br><span class="line"></span><br><span class="line">if stock &gt;= quantity then</span><br><span class="line">    redis.call(&#x27;decrby&#x27;, KEYS[1], quantity)</span><br><span class="line">    return 1</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这个脚本保证了“读取库存”和“扣减库存”两个操作的原子性，避免了在高并发下超卖的问题。</p>
<hr>
<h3 id="Token-认证机制详解"><a href="#Token-认证机制详解" class="headerlink" title="Token 认证机制详解"></a><strong>Token 认证机制详解</strong></h3><h4 id="1-Token-是什么？"><a href="#1-Token-是什么？" class="headerlink" title="1. Token 是什么？"></a><strong>1. Token 是什么？</strong></h4><p>Token（令牌）是在服务端生成的一串加密字符串，作为客户端进行请求的一个“凭证”。当用户第一次登录成功后，服务端会生成一个 Token 并返回给客户端。之后，客户端在每次请求需要身份认证的接口时，都需要在请求头（通常是 <code>Authorization</code> 字段）中携带这个 Token。服务端接收到请求后，会验证 Token 的有效性，如果验证通过，则处理该请求；否则，拒绝该请求。</p>
<p>一个典型的 Token 是 <strong>JWT (JSON Web Token)</strong>，它由三部分组成，用 <code>.</code> 分隔：</p>
<ul>
<li><strong>Header (头部)</strong>: 包含了令牌的类型（<code>typ</code>，即 JWT）和所使用的签名算法（<code>alg</code>，如 HMAC SHA256 或 RSA）。</li>
<li><strong>Payload (负载)</strong>: 包含了“声明 (claims)”，是存放实际需要传递的数据的地方。例如用户ID（<code>sub</code>）、签发时间（<code>iat</code>）、过期时间（<code>exp</code>）以及其他自定义的用户信息。<strong>注意：Payload 部分是 Base64 编码的，并非加密，因此不应存放敏感信息。</strong></li>
<li><strong>Signature (签名)</strong>: 对前两部分（Header 和 Payload）使用指定的算法和存储在服务端的密钥（secret）进行签名。这个签名的作用是<strong>防止数据被篡改</strong>。服务端收到 Token 后，会用同样的算法和密钥重新计算签名，并与 Token 中的签名进行比对，若一致，则说明 Token 未被篡改且是可信的。</li>
</ul>
<h4 id="2-Token-认证原理（工作流程）"><a href="#2-Token-认证原理（工作流程）" class="headerlink" title="2. Token 认证原理（工作流程）"></a><strong>2. Token 认证原理（工作流程）</strong></h4><ol>
<li><strong>登录</strong>: 用户使用用户名和密码发起登录请求。</li>
<li><strong>验证</strong>: 服务端验证用户的凭据是否正确。</li>
<li><strong>签发 Token</strong>: 验证成功后，服务端根据用户ID、角色等信息，结合密钥（secret），生成一个 Token。</li>
<li><strong>返回 Token</strong>: 服务端将生成的 Token 返回给客户端。</li>
<li><strong>存储 Token</strong>: 客户端（浏览器、App）将 Token 存储起来，通常放在 <code>localStorage</code>、<code>sessionStorage</code> 或 <code>HttpOnly</code> 的 Cookie 中。</li>
<li><strong>携带 Token 请求</strong>: 客户端在后续每次请求受保护的 API 时，都会在 HTTP 请求头的 <code>Authorization</code> 字段中附上 Token，格式通常为 <code>Bearer &lt;token&gt;</code>。</li>
<li><strong>验证 Token</strong>: 服务端收到请求后，从请求头中解析出 Token，然后：<ul>
<li>验证签名是否正确，确保 Token 未被篡改。</li>
<li>检查 Token 是否在有效期内（<code>exp</code> 声明）。</li>
<li>如果验证通过，则从 Payload 中获取用户信息，执行业务逻辑并返回结果。</li>
<li>如果验证失败，则返回 <code>401 Unauthorized</code> 错误。</li>
</ul>
</li>
</ol>
<h4 id="3-为什么使用-Token？（与-Session-的区别）"><a href="#3-为什么使用-Token？（与-Session-的区别）" class="headerlink" title="3. 为什么使用 Token？（与 Session 的区别）"></a><strong>3. 为什么使用 Token？（与 Session 的区别）</strong></h4><p>在 Web 开发早期，<code>Session-Cookie</code> 机制是主流。服务端在用户登录后创建一个 Session 对象存储在内存或 Redis 中，并生成一个 Session ID，通过 Cookie 返回给浏览器。浏览器后续请求会自动带上这个 Session ID，服务端根据 ID 找到对应的 Session 信息来识别用户。</p>
<p><strong>Token 机制相比 Session 机制，核心优势在于“无状态性 (Statelessness)”</strong>，这带来了以下好处：</p>
<table>
<thead>
<tr>
<th>特性对比</th>
<th>Session 机制</th>
<th>Token 机制</th>
<th>优势说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>状态存储</strong></td>
<td><strong>有状态 (Stateful)</strong>。Session 信息需存储在服务端。</td>
<td><strong>无状态 (Stateless)</strong>。用户信息包含在 Token 的 Payload 中，服务端无需存储。</td>
<td><strong>减轻服务端压力</strong>。服务端不需要为每个在线用户维护一个 Session 对象。</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td><strong>差</strong>。在分布式或集群环境下，需要解决 Session 共享问题（如 Session Sticky、Session Replication、集中存储）。</td>
<td><strong>好</strong>。由于服务端不存储状态，任何一台服务器只要有相同的密钥，就能验证 Token，天然适合分布式和微服务架构。</td>
<td><strong>轻松实现水平扩展</strong>。增加服务器节点无需额外配置 Session 共享。</td>
</tr>
<tr>
<td><strong>跨域支持</strong></td>
<td><strong>有限</strong>。基于 Cookie 的 Session 机制在跨域（CORS）场景下处理起来比较麻烦。</td>
<td><strong>优秀</strong>。Token 可以通过 HTTP 请求头发送，不受同源策略限制，非常适合前后端分离和跨域 API 调用。</td>
<td><strong>适应现代架构</strong>。完美支持 SPA（单页应用）、移动 App 等多种客户端。</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>依赖 Cookie 机制，可能遭受 CSRF 攻击。</td>
<td>如果 Token 存储在 <code>localStorage</code>，可能遭受 XSS 攻击。需要综合考虑存储方式。</td>
<td>两者各有安全风险点，需配合其他安全策略。Token 机制不依赖 Cookie，更灵活。</td>
</tr>
<tr>
<td><strong>适用性</strong></td>
<td>适合传统的、一体化的 Web 应用。</td>
<td>适合现代的、分布式的、跨终端的（Web, Mobile, IoT）应用架构。</td>
<td>Token 更具通用性和前瞻性。</td>
</tr>
</tbody></table>
<h4 id="4-双令牌策略-Access-Token-Refresh-Token"><a href="#4-双令牌策略-Access-Token-Refresh-Token" class="headerlink" title="4. 双令牌策略 (Access Token + Refresh Token)"></a><strong>4. 双令牌策略 (Access Token + Refresh Token)</strong></h4><ul>
<li><strong>Q: 为什么不用单个 Token？</strong><ul>
<li><strong>如果 Token 有效期很长（如一个月）</strong>: 安全风险高。一旦 Token 在此期间被窃取，攻击者可以长时间冒充用户身份进行操作。</li>
<li><strong>如果 Token 有效期很短（如 15 分钟）</strong>: 用户体验差。用户需要频繁地重新登录，这是无法接受的。</li>
</ul>
</li>
<li><strong>A: 双令牌策略应运而生，完美平衡了安全性和用户体验。</strong><ul>
<li><strong>Access Token (访问令牌)</strong>: 它的有效期<strong>非常短</strong>（如 15 分钟到 1 小时）。它被用于访问受保护的资源，由于其生命周期短，即使被窃取，攻击者能造成的危害也有限。</li>
<li><strong>Refresh Token (刷新令牌)</strong>: 它的有效期<strong>很长</strong>（如 7 天或 30 天）。它的<strong>唯一作用</strong>是用来获取新的 Access Token。Refresh Token 本身不包含任何权限信息，不能用于直接访问 API。</li>
</ul>
</li>
<li><strong>双令牌工作流程（静默刷新）</strong><ol>
<li><strong>首次登录</strong>: 用户登录成功，服务端返回一个短期的 <code>Access Token</code> 和一个长期的 <code>Refresh Token</code>。客户端将两者都存储起来。</li>
<li><strong>正常访问</strong>: 客户端使用 <code>Access Token</code> 访问 API。服务端验证 <code>Access Token</code> 通过，返回数据。</li>
<li><strong>Access Token 过期</strong>: 客户端再次使用过期的 <code>Access Token</code> 访问 API，服务端返回 <code>401 Unauthorized</code> 错误，并可能带上一个特定错误码，告知客户端是“令牌过期”而非“无效令牌”。</li>
<li><strong>静默刷新</strong>: 客户端的请求拦截器捕获到这个 <code>401</code> 错误后，<strong>不会立即跳转到登录页</strong>。而是自动发起一个特殊的请求，携带那个长期的 <code>Refresh Token</code> 去访问一个专门的刷新接口（如 <code>/api/token/refresh</code>）。</li>
<li><strong>签发新令牌</strong>: 服务端验证 <code>Refresh Token</code> 的有效性（通常会将其存储在 Redis 或数据库中进行比对，以实现强制下线功能）。如果验证通过，就生成一个<strong>新的 Access Token</strong>（有时也会生成一个新的 <code>Refresh Token</code>，这被称为刷新令牌滚动策略）并返回给客户端。</li>
<li><strong>重试请求</strong>: 客户端收到新的 <code>Access Token</code> 后，用它替换掉本地旧的 <code>Access Token</code>，然后<strong>自动重新发送刚才因令牌过期而失败的那个请求</strong>。</li>
<li><strong>无感体验</strong>: 整个过程对用户是透明的，用户感觉不到令牌已经过期并被刷新，实现了“静默刷新”，体验非常流畅。</li>
<li><strong>Refresh Token 过期</strong>: 如果 <code>Refresh Token</code> 也过期了，那么刷新接口会返回错误，此时客户端才会真正清除用户凭证并引导用户重新登录。</li>
</ol>
</li>
</ul>
<h4 id="5-Token-相关场景与面试题"><a href="#5-Token-相关场景与面试题" class="headerlink" title="5. Token 相关场景与面试题"></a><strong>5. Token 相关场景与面试题</strong></h4><ul>
<li><strong>面试题 1：“Token 应该存储在哪里？localStorage、sessionStorage 还是 Cookie？”</strong><ul>
<li><strong>回答要点</strong>:<ul>
<li><strong>localStorage&#x2F;sessionStorage</strong>:<ul>
<li><strong>优点</strong>: 方便 JavaScript 直接读写，容量较大（5MB）。</li>
<li><strong>缺点</strong>: 容易受到 <strong>XSS (跨站脚本攻击)</strong>。如果网站存在 XSS 漏洞，攻击者可以执行 JS 代码直接窃取存储在其中的 Token。</li>
</ul>
</li>
<li><strong>Cookie (HttpOnly)</strong>:<ul>
<li><strong>优点</strong>: 设置为 <code>HttpOnly</code> 后，JavaScript 将无法读写该 Cookie，可以有效<strong>防御 XSS 攻击</strong>。浏览器会自动在同域请求中携带它。</li>
<li><strong>缺点</strong>: 容易受到 <strong>CSRF (跨站请求伪造)</strong> 攻击。攻击者可以诱导用户点击恶意链接，浏览器会自动带上用户的 Cookie 去请求你的网站，执行非用户本意的操作。需要配合 Anti-CSRF Token 等机制来防御。容量较小（4KB）。</li>
</ul>
</li>
<li><strong>最佳实践&#x2F;结论</strong>: 没有绝对完美的选择，需要权衡。<ul>
<li><strong>高安全性方案</strong>: 将 <code>Refresh Token</code> 存储在 <code>HttpOnly</code> 的 Cookie 中（防止 XSS），将 <code>Access Token</code> 存储在内存中（变量里，页面刷新丢失）或 <code>sessionStorage</code> 中。同时，后端接口必须实施 CSRF 防御策略。</li>
<li><strong>主流实践方案 (前后端分离)</strong>: 将 Token 存储在 <code>localStorage</code> 中，并在 <code>Authorization</code> 请求头中携带。同时，前端必须严格做好输入过滤和内容转义，尽最大努力防止 XSS 漏洞的出现。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>面试题 2：“用户点击“退出登录”时，Token 如何失效？”</strong><ul>
<li><strong>回答要点</strong>:<ul>
<li><strong>对于无状态的 JWT</strong>: 由于所有信息都在 Token 自身，服务端无法主动让其失效。因此，“退出登录”主要是一个<strong>客户端行为</strong>。<ul>
<li><strong>客户端</strong>: 只需从 <code>localStorage</code> 或其他存储位置清除 Token 即可。用户将无法再发起认证请求。</li>
</ul>
</li>
<li><strong>如何实现服务端强制下线？</strong>: 如果需要实现“踢人下线”或“修改密码后所有设备强制下线”的功能，就必须打破纯粹的无状态。<ul>
<li><strong>黑名单机制</strong>: 服务端可以建立一个 Token 黑名单（例如，使用 Redis Set）。当用户退出登录时，将该 Token 的 <code>jti</code> (JWT ID) 或整个 Token 放入黑名单，并设置与 Token 剩余有效期相同的过期时间。在每次验证 Token 时，除了常规验证，还需检查该 Token 是否在黑名单中。</li>
<li><strong>基于 Refresh Token</strong>: 在双令牌模式下，退出登录时只需让服务端的 <code>Refresh Token</code> 失效（例如，从 Redis 中删除）。这样用户就无法再获取新的 <code>Access Token</code>，当旧的 <code>Access Token</code> 过期后，自然就下线了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>面试题 3：“请你设计一个支持 Web 端和 App 端统一登录的认证系统。”</strong><ul>
<li><strong>回答要点</strong>:<ul>
<li>这正是 Token 认证机制的典型应用场景。我会采用基于 <strong>OAuth 2.0&#x2F;OIDC</strong> 或自定义的**双令牌（Access&#x2F;Refresh Token）**方案。</li>
<li><strong>统一认证中心 (UAC)</strong>: 建立一个独立的认证服务，负责处理所有客户端（Web, iOS, Android）的登录、注册、Token 签发和刷新。</li>
<li><strong>API 网关</strong>: 所有业务请求都通过 API 网关。网关的核心职责之一就是<strong>统一鉴权</strong>。它会拦截所有请求，解析 <code>Authorization</code> 头中的 <code>Access Token</code>，调用认证中心或自行验证 Token 的有效性。验证通过后，可以将解析出的用户信息（如用户ID）附加到请求头中，再转发给后端的业务微服务。</li>
<li><strong>业务微服务</strong>: 业务微服务本身<strong>不再关心 Token 的验证细节</strong>，它们信任来自网关的请求，直接从请求头中获取用户信息进行业务处理，实现了业务与认证的解耦。</li>
<li><strong>流程</strong>:<ol>
<li>Web&#x2F;App 客户端引导用户到认证中心进行登录。</li>
<li>登录成功后，认证中心返回 <code>Access Token</code> 和 <code>Refresh Token</code>。</li>
<li>客户端保存令牌，后续访问业务 API 时，在请求头携带 <code>Access Token</code>。</li>
<li>API 网关拦截请求，验证 <code>Access Token</code>。</li>
<li><code>Access Token</code> 过期后，客户端使用 <code>Refresh Token</code> 向认证中心申请新令牌。</li>
</ol>
</li>
<li>这个架构具有高内聚、低耦合、可扩展性强、安全性高的优点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Redis-详细技术解析"><a href="#Redis-详细技术解析" class="headerlink" title="Redis 详细技术解析"></a>Redis 详细技术解析</h1><h2 id="Redis-核心架构与原理"><a href="#Redis-核心架构与原理" class="headerlink" title="Redis 核心架构与原理"></a>Redis 核心架构与原理</h2><h3 id="内存模型与数据结构"><a href="#内存模型与数据结构" class="headerlink" title="内存模型与数据结构"></a>内存模型与数据结构</h3><p>Redis采用基于内存的存储架构，所有数据都保存在RAM中，这是其高性能的根本原因。Redis使用了多种底层数据结构来实现上层的抽象数据类型：</p>
<p><strong>SDS（Simple Dynamic String）</strong> Redis没有直接使用C语言的字符串，而是构建了SDS。SDS在字符串头部记录了长度信息，避免了strlen的O(n)复杂度，同时预分配空间减少内存重分配次数。</p>
<p><strong>跳跃表（Skip List）</strong> 有序集合的底层实现之一，是一种随机化的数据结构，通过多层链表实现O(log N)的查找复杂度。相比红黑树，跳跃表实现更简单，且支持范围查询。</p>
<p><strong>压缩列表（Ziplist）</strong> 当哈希、列表、有序集合元素较少时使用的紧凑存储结构，所有元素存储在一块连续内存中，节省内存但插入删除效率较低。</p>
<p><strong>字典（Dict）</strong> Redis的核心数据结构，使用开放寻址法解决哈希冲突，支持渐进式rehash。当负载因子过高时，会创建新的哈希表并逐步迁移数据。</p>
<h3 id="单线程模型与事件循环"><a href="#单线程模型与事件循环" class="headerlink" title="单线程模型与事件循环"></a>单线程模型与事件循环</h3><p>Redis 6.0之前采用单线程模型处理客户端请求，通过I&#x2F;O多路复用（epoll&#x2F;kqueue）实现高并发。单线程避免了线程切换开销和并发控制问题，但也限制了CPU利用率。</p>
<p><strong>事件循环机制</strong> Redis使用Reactor模式的事件循环，分为文件事件和时间事件：</p>
<ul>
<li>文件事件：处理客户端连接、读写请求</li>
<li>时间事件：处理定时任务，如过期键删除、持久化等</li>
</ul>
<p>Redis 6.0引入了多线程I&#x2F;O，但命令执行仍是单线程，多线程只用于网络I&#x2F;O操作的读写，这样既提高了网络处理能力，又保持了数据操作的原子性。</p>
<h2 id="数据类型详解与应用场景"><a href="#数据类型详解与应用场景" class="headerlink" title="数据类型详解与应用场景"></a>数据类型详解与应用场景</h2><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String是Redis最基础的数据类型，底层可以是SDS、整数或浮点数。</p>
<p><strong>常用命令</strong>：SET、GET、INCR、DECR、APPEND、GETRANGE <strong>应用场景</strong>：</p>
<ul>
<li>缓存：存储用户会话、配置信息</li>
<li>计数器：网站访问量、点赞数（INCR原子性保证）</li>
<li>分布式锁：SET key value NX EX seconds</li>
<li>限流：结合EXPIRE实现滑动窗口限流</li>
</ul>
<h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash类型适合存储对象，避免了将对象序列化为JSON字符串的开销。</p>
<p><strong>底层实现</strong>：元素较少时使用ziplist，元素较多时使用hashtable <strong>应用场景</strong>：</p>
<ul>
<li>存储用户信息：HSET user:1001 name “张三” age 25</li>
<li>购物车：HSET cart:1001 product:123 2</li>
<li>配置管理：分类存储不同模块的配置</li>
</ul>
<h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>List是双向链表实现，支持在两端进行O(1)的插入和删除操作。</p>
<p><strong>常用命令</strong>：LPUSH、RPUSH、LPOP、RPOP、LRANGE、BLPOP <strong>应用场景</strong>：</p>
<ul>
<li>消息队列：生产者LPUSH，消费者BRPOP实现阻塞队列</li>
<li>最新列表：朋友圈动态、商品评论</li>
<li>栈和队列：LPUSH+LPOP实现栈，LPUSH+RPOP实现队列</li>
</ul>
<h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Set是无序集合，元素唯一，底层使用hashtable或intset实现。</p>
<p><strong>集合运算</strong>：SINTER（交集）、SUNION（并集）、SDIFF（差集） <strong>应用场景</strong>：</p>
<ul>
<li>去重：统计网站独立访客</li>
<li>社交关系：共同好友、推荐用户</li>
<li>标签系统：用户标签、文章分类</li>
<li>抽奖系统：SRANDMEMBER随机抽取</li>
</ul>
<h3 id="Sorted-Set类型"><a href="#Sorted-Set类型" class="headerlink" title="Sorted Set类型"></a>Sorted Set类型</h3><p>有序集合，每个元素关联一个分数，按分数排序。底层使用跳跃表和哈希表。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li>排行榜：游戏积分、热搜榜</li>
<li>延时队列：分数为执行时间戳</li>
<li>范围查询：按时间、按分数范围获取数据</li>
</ul>
<h2 id="持久化机制深度解析"><a href="#持久化机制深度解析" class="headerlink" title="持久化机制深度解析"></a>持久化机制深度解析</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB通过fork子进程，将内存数据快照写入磁盘。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>文件紧凑，适合备份和灾难恢复</li>
<li>恢复速度快</li>
<li>对Redis性能影响小（子进程操作）</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>数据丢失风险：两次快照间的数据可能丢失</li>
<li>fork过程会阻塞主进程</li>
<li>大数据集fork耗时较长</li>
</ul>
<p><strong>触发条件</strong>：</p>
<ul>
<li>手动执行SAVE或BGSAVE命令</li>
<li>配置自动触发：save 900 1（900秒内至少1个键改变）</li>
<li>主从复制时自动生成RDB</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF记录每个写命令，通过重放命令恢复数据。</p>
<p><strong>写入时机</strong>：</p>
<ul>
<li>always：每个写命令立即同步，安全但性能低</li>
<li>everysec：每秒同步一次，平衡安全性和性能</li>
<li>no：由操作系统决定同步时机，性能高但安全性低</li>
</ul>
<p><strong>AOF重写</strong>： AOF文件会越来越大，Redis提供重写机制优化：</p>
<ul>
<li>遍历内存数据，用最少命令重建AOF文件</li>
<li>重写期间的新命令写入AOF重写缓冲区</li>
<li>原子性替换旧AOF文件</li>
</ul>
<p><strong>混合持久化</strong>： Redis 4.0引入RDB+AOF混合模式，重写时以RDB格式写入基础数据，增量命令以AOF格式追加，兼顾了恢复速度和数据安全。</p>
<h2 id="缓存问题与解决方案"><a href="#缓存问题与解决方案" class="headerlink" title="缓存问题与解决方案"></a>缓存问题与解决方案</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询不存在的数据，缓存无法生效，请求直达数据库。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>空值缓存</strong>：查询结果为空时也缓存，设置较短过期时间</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (data == null) &#123;</span><br><span class="line">    redis.setex(key, 60, &quot;null&quot;);  // 缓存空值60秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>布隆过滤器</strong>：预先将所有可能存在的数据哈希到位数组</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BloomFilter&lt;String&gt; filter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()), 1000000, 0.01);</span><br><span class="line">// 查询前先检查布隆过滤器</span><br><span class="line">if (!filter.mightContain(key)) &#123;</span><br><span class="line">    return null;  // 一定不存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>参数校验</strong>：在API层面进行参数合法性校验</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>热点数据过期瞬间，大量并发请求击穿缓存。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>互斥锁</strong>：只允许一个线程查询数据库并重建缓存</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public String getData(String key) &#123;</span><br><span class="line">    String data = redis.get(key);</span><br><span class="line">    if (data == null) &#123;</span><br><span class="line">        String lockKey = &quot;lock:&quot; + key;</span><br><span class="line">        if (redis.setnx(lockKey, &quot;1&quot;, 10)) &#123;  // 获取锁</span><br><span class="line">            try &#123;</span><br><span class="line">                data = database.query(key);  // 查询数据库</span><br><span class="line">                redis.setex(key, 3600, data);  // 重建缓存</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                redis.del(lockKey);  // 释放锁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Thread.sleep(50);  // 等待其他线程重建缓存</span><br><span class="line">            return getData(key);  // 递归重试</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>热点数据永不过期</strong>：逻辑上设置过期时间，物理上不过期，异步更新</li>
<li><strong>预热机制</strong>：系统启动时预先加载热点数据</li>
<li><strong>二级缓存</strong>：L1缓存过期后，先返回L2缓存数据，异步更新L1</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量缓存同时过期或Redis宕机，请求涌向数据库。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>过期时间随机化</strong>：避免同时过期</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int randomExpire = baseExpire + new Random().nextInt(300);  // 基础时间+随机时间</span><br><span class="line">redis.setex(key, randomExpire, data);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>多级缓存架构</strong>：<ul>
<li>L1：本地缓存（如Caffeine）</li>
<li>L2：Redis分布式缓存</li>
<li>L3：数据库</li>
</ul>
</li>
<li><strong>限流降级</strong>：使用Sentinel、Hystrix等组件</li>
<li><strong>Redis高可用</strong>：主从复制、哨兵模式、集群部署</li>
</ol>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>系统启动时预先加载热点数据到缓存。</p>
<p><strong>实现方式</strong>：</p>
<ol>
<li><strong>定时任务预热</strong>：凌晨低峰期执行</li>
<li><strong>手动预热</strong>：管理后台触发预热任务</li>
<li><strong>实时预热</strong>：监控系统发现热点数据自动预热</li>
</ol>
<h2 id="数据一致性保证"><a href="#数据一致性保证" class="headerlink" title="数据一致性保证"></a>数据一致性保证</h2><h3 id="Cache-Aside模式（旁路缓存）"><a href="#Cache-Aside模式（旁路缓存）" class="headerlink" title="Cache Aside模式（旁路缓存）"></a>Cache Aside模式（旁路缓存）</h3><p>应用程序负责维护缓存和数据库的一致性。</p>
<p><strong>读操作</strong>：</p>
<ol>
<li>先读缓存，命中则返回</li>
<li>缓存不命中，查询数据库</li>
<li>将数据写入缓存并返回</li>
</ol>
<p><strong>写操作</strong>：</p>
<ol>
<li>先更新数据库</li>
<li>删除缓存（让下次读取时重新加载）</li>
</ol>
<p><strong>为什么是删除而不是更新缓存？</strong></p>
<ul>
<li>更新缓存可能存在并发问题</li>
<li>复杂查询的缓存更新成本高</li>
<li>删除缓存更简单可靠</li>
</ul>
<h3 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h3><p>解决读写并发导致的数据不一致问题。</p>
<p><strong>实现步骤</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void updateData(String key, Object data) &#123;</span><br><span class="line">    // 1. 删除缓存</span><br><span class="line">    redis.del(key);</span><br><span class="line">    </span><br><span class="line">    // 2. 更新数据库</span><br><span class="line">    database.update(data);</span><br><span class="line">    </span><br><span class="line">    // 3. 延时删除缓存（异步）</span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);  // 延时500ms</span><br><span class="line">            redis.del(key);     // 再次删除缓存</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            log.error(&quot;延时删除缓存失败&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>延时时间设置</strong>：通常为主从同步时间 + 读数据库时间 + 几十毫秒</p>
<h3 id="基于消息队列的最终一致性"><a href="#基于消息队列的最终一致性" class="headerlink" title="基于消息队列的最终一致性"></a>基于消息队列的最终一致性</h3><p>使用消息队列异步处理缓存更新，保证最终一致性。</p>
<p><strong>实现流程</strong>：</p>
<ol>
<li>更新数据库，发送消息到队列</li>
<li>消息消费者删除相关缓存</li>
<li>消费失败时重试，保证最终一致性</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 发送缓存删除消息</span><br><span class="line">@Transactional</span><br><span class="line">public void updateUser(User user) &#123;</span><br><span class="line">    userDao.update(user);  // 更新数据库</span><br><span class="line">    </span><br><span class="line">    // 发送缓存删除消息（事务提交后发送）</span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(</span><br><span class="line">        new TransactionSynchronizationAdapter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void afterCommit() &#123;</span><br><span class="line">                cacheDeleteMQ.send(&quot;user:&quot; + user.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式事务方案"><a href="#分布式事务方案" class="headerlink" title="分布式事务方案"></a>分布式事务方案</h3><p>对于强一致性要求高的场景，可以使用分布式事务。</p>
<p><strong>2PC（两阶段提交）</strong>：</p>
<ul>
<li>准备阶段：协调者询问参与者是否准备好</li>
<li>提交阶段：所有参与者都准备好则提交，否则回滚</li>
</ul>
<p><strong>TCC（Try-Confirm-Cancel）</strong>：</p>
<ul>
<li>Try：尝试执行，预留资源</li>
<li>Confirm：确认提交</li>
<li>Cancel：取消执行，释放资源</li>
</ul>
<h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><h3 id="基于SET命令的分布式锁"><a href="#基于SET命令的分布式锁" class="headerlink" title="基于SET命令的分布式锁"></a>基于SET命令的分布式锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class RedisDistributedLock &#123;</span><br><span class="line">    private Jedis jedis;</span><br><span class="line">    </span><br><span class="line">    public boolean tryLock(String lockKey, String requestId, int expireTime) &#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, &quot;NX&quot;, &quot;PX&quot;, expireTime);</span><br><span class="line">        return &quot;OK&quot;.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean releaseLock(String lockKey, String requestId) &#123;</span><br><span class="line">        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                       &quot;return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey),</span><br><span class="line">                                 Collections.singletonList(requestId));</span><br><span class="line">        return &quot;1&quot;.equals(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = &quot;lock:user:1001&quot;;</span><br><span class="line">String requestId = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">if (tryLock(lockKey, requestId, 30000)) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 执行业务逻辑</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        releaseLock(lockKey, requestId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h3><p>为了解决单点故障问题，Redis官方提出了Redlock算法。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li>获取当前时间戳</li>
<li>依次向N个Redis实例申请锁</li>
<li>如果在大多数实例（N&#x2F;2+1）上获取锁成功，且总耗时小于锁超时时间，则认为获取锁成功</li>
<li>锁的有效时间 &#x3D; 初始有效时间 - 获取锁消耗的时间</li>
<li>释放锁时，向所有Redis实例发送释放命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Redlock &#123;</span><br><span class="line">    private List&lt;Jedis&gt; jedisInstances;</span><br><span class="line">    </span><br><span class="line">    public boolean lock(String resource, int ttl) &#123;</span><br><span class="line">        int quorum = jedisInstances.size() / 2 + 1;</span><br><span class="line">        int successCount = 0;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        for (Jedis jedis : jedisInstances) &#123;</span><br><span class="line">            if (lockInstance(jedis, resource, ttl)) &#123;</span><br><span class="line">                successCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        long elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        if (successCount &gt;= quorum &amp;&amp; elapsedTime &lt; ttl) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            unlock(resource);  // 释放已获取的锁</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁的问题与优化"><a href="#锁的问题与优化" class="headerlink" title="锁的问题与优化"></a>锁的问题与优化</h3><p><strong>锁超时问题</strong>： 业务执行时间超过锁超时时间，锁自动释放，可能导致并发问题。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>看门狗机制</strong>：定时续期锁的过期时间</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class WatchDog &#123;</span><br><span class="line">    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);</span><br><span class="line">    </span><br><span class="line">    public void startWatchDog(String lockKey, String requestId) &#123;</span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            // 续期锁</span><br><span class="line">            String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                           &quot;return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) else return 0 end&quot;;</span><br><span class="line">            jedis.eval(script, Arrays.asList(lockKey), </span><br><span class="line">                      Arrays.asList(requestId, &quot;30&quot;));</span><br><span class="line">        &#125;, 10, 10, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>合理评估业务执行时间</strong>：设置足够的锁超时时间</li>
</ol>
<p><strong>锁竞争激烈问题</strong>： 大量线程竞争同一把锁，导致性能下降。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>分段锁</strong>：将资源分段，减少锁竞争</li>
<li><strong>队列锁</strong>：使用List实现公平锁</li>
<li><strong>自旋锁优化</strong>：适当的退避算法</li>
</ol>
<h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>假设会发生并发冲突，在操作数据前先获取锁。</p>
<p><strong>Redis实现</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 使用Redis分布式锁实现悲观锁</span><br><span class="line">public void updateWithPessimisticLock(String userId, int amount) &#123;</span><br><span class="line">    String lockKey = &quot;lock:account:&quot; + userId;</span><br><span class="line">    String requestId = UUID.randomUUID().toString();</span><br><span class="line">    </span><br><span class="line">    if (tryLock(lockKey, requestId, 30000)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 查询账户余额</span><br><span class="line">            int balance = getBalance(userId);</span><br><span class="line">            if (balance &gt;= amount) &#123;</span><br><span class="line">                // 扣减余额</span><br><span class="line">                updateBalance(userId, balance - amount);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InsufficientBalanceException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            releaseLock(lockKey, requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new LockAcquisitionException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>假设不会发生冲突，在更新时检查数据是否被修改。</p>
<p><strong>基于版本号的乐观锁</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public boolean updateWithOptimisticLock(String userId, int amount, int expectedVersion) &#123;</span><br><span class="line">    // 使用Lua脚本保证原子性</span><br><span class="line">    String script = </span><br><span class="line">        &quot;local current = redis.call(&#x27;hmget&#x27;, KEYS[1], &#x27;balance&#x27;, &#x27;version&#x27;) &quot; +</span><br><span class="line">        &quot;if current[2] == ARGV[2] then &quot; +</span><br><span class="line">        &quot;  if tonumber(current[1]) &gt;= tonumber(ARGV[1]) then &quot; +</span><br><span class="line">        &quot;    redis.call(&#x27;hmset&#x27;, KEYS[1], &#x27;balance&#x27;, current[1] - ARGV[1], &#x27;version&#x27;, current[2] + 1) &quot; +</span><br><span class="line">        &quot;    return 1 &quot; +</span><br><span class="line">        &quot;  else &quot; +</span><br><span class="line">        &quot;    return -1 &quot; +  // 余额不足</span><br><span class="line">        &quot;  end &quot; +</span><br><span class="line">        &quot;else &quot; +</span><br><span class="line">        &quot;  return 0 &quot; +     // 版本号不匹配</span><br><span class="line">        &quot;end&quot;;</span><br><span class="line">    </span><br><span class="line">    String key = &quot;account:&quot; + userId;</span><br><span class="line">    Object result = jedis.eval(script, Arrays.asList(key), </span><br><span class="line">                              Arrays.asList(String.valueOf(amount), String.valueOf(expectedVersion)));</span><br><span class="line">    </span><br><span class="line">    int code = ((Long) result).intValue();</span><br><span class="line">    if (code == 1) &#123;</span><br><span class="line">        return true;  // 更新成功</span><br><span class="line">    &#125; else if (code == 0) &#123;</span><br><span class="line">        throw new OptimisticLockException(&quot;数据已被修改&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new InsufficientBalanceException(&quot;余额不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基于CAS的乐观锁</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void updateWithCAS(String key, Function&lt;String, String&gt; updater) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 1. 获取当前值</span><br><span class="line">        String currentValue = redis.get(key);</span><br><span class="line">        </span><br><span class="line">        // 2. 计算新值</span><br><span class="line">        String newValue = updater.apply(currentValue);</span><br><span class="line">        </span><br><span class="line">        // 3. CAS更新</span><br><span class="line">        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br><span class="line">                       &quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[2]) else return nil end&quot;;</span><br><span class="line">        Object result = redis.eval(script, Arrays.asList(key), </span><br><span class="line">                                  Arrays.asList(currentValue, newValue));</span><br><span class="line">        </span><br><span class="line">        if (result != null) &#123;</span><br><span class="line">            break;  // 更新成功</span><br><span class="line">        &#125;</span><br><span class="line">        // 更新失败，重试</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="悲观锁-vs-乐观锁选择"><a href="#悲观锁-vs-乐观锁选择" class="headerlink" title="悲观锁 vs 乐观锁选择"></a>悲观锁 vs 乐观锁选择</h3><p><strong>悲观锁适用场景</strong>：</p>
<ul>
<li>写操作频繁，冲突概率高</li>
<li>业务逻辑复杂，重试成本高</li>
<li>对数据一致性要求严格</li>
</ul>
<p><strong>乐观锁适用场景</strong>：</p>
<ul>
<li>读多写少，冲突概率低</li>
<li>业务逻辑简单，重试成本低</li>
<li>对性能要求高</li>
</ul>
<h2 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Master负责写操作，Slave负责读操作，通过复制实现数据同步。</p>
<p><strong>复制原理</strong>：</p>
<ol>
<li>Slave向Master发送PSYNC命令</li>
<li>Master执行BGSAVE生成RDB文件</li>
<li>Master将RDB文件发送给Slave</li>
<li>Slave载入RDB文件</li>
<li>Master将缓冲区的写命令发送给Slave</li>
<li>后续写命令实时同步</li>
</ol>
<p><strong>部分重同步</strong>： 网络断连后，Slave只需要同步断连期间的命令，而不是完整重同步。</p>
<h3 id="哨兵模式（Sentinel）"><a href="#哨兵模式（Sentinel）" class="headerlink" title="哨兵模式（Sentinel）"></a>哨兵模式（Sentinel）</h3><p>哨兵负责监控Master状态，在Master故障时自动进行故障转移。</p>
<p><strong>哨兵职责</strong>：</p>
<ul>
<li>监控：定期ping Master和Slave</li>
<li>通知：故障时通知管理员和客户端</li>
<li>故障转移：自动将Slave提升为新Master</li>
<li>配置管理：为客户端提供服务发现</li>
</ul>
<p><strong>故障转移流程</strong>：</p>
<ol>
<li>哨兵发现Master下线（主观下线）</li>
<li>多个哨兵确认Master下线（客观下线）</li>
<li>选举领导哨兵执行故障转移</li>
<li>选择合适的Slave作为新Master</li>
<li>修改其他Slave的配置指向新Master</li>
<li>通知客户端Master地址变更</li>
</ol>
<h3 id="集群模式（Cluster）"><a href="#集群模式（Cluster）" class="headerlink" title="集群模式（Cluster）"></a>集群模式（Cluster）</h3><p>Redis Cluster通过分片实现横向扩展和高可用。</p>
<p><strong>分片算法</strong>： 使用CRC16算法计算key的哈希值，然后对16384取模得到槽位号。</p>
<p><strong>节点通信</strong>： 使用Gossip协议在节点间交换状态信息，包括节点上线&#x2F;下线、槽位分配等。</p>
<p><strong>故障转移</strong>： 当Master节点故障时，其Slave自动提升为新Master，过程对客户端透明。</p>
<p><strong>数据迁移</strong>： 集群扩容时，需要将部分槽位从现有节点迁移到新节点。</p>
<h2 id="性能监控与优化"><a href="#性能监控与优化" class="headerlink" title="性能监控与优化"></a>性能监控与优化</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>Redis提供慢查询日志功能，记录执行时间超过阈值的命令。</p>
<p><strong>配置参数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than 10000  # 超过10毫秒记录</span><br><span class="line">slowlog-max-len 128           # 最多保存128条记录</span><br></pre></td></tr></table></figure>

<p><strong>查看慢查询</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLOWLOG GET 10  # 获取最近10条慢查询</span><br></pre></td></tr></table></figure>

<h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p>使用MEMORY命令分析内存使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MEMORY USAGE key         # 查看key占用内存</span><br><span class="line">MEMORY STATS            # 查看内存统计信息</span><br><span class="line">MEMORY DOCTOR           # 内存使用建议</span><br></pre></td></tr></table></figure>

<h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><p><strong>避免大key</strong>：</p>
<ul>
<li>单个key的value不要超过10KB</li>
<li>集合类型元素数量控制在合理范围</li>
<li>使用SCAN代替KEYS命令</li>
</ul>
<p><strong>合理使用数据结构</strong>：</p>
<ul>
<li>小对象使用Hash而不是多个String</li>
<li>合理设置ziplist等压缩结构的阈值</li>
<li>使用位图(bitmap)存储布尔类型大数据集</li>
</ul>
<p><strong>网络优化</strong>：</p>
<ul>
<li>使用Pipeline批量操作</li>
<li>合理设置客户端连接池</li>
<li>启用TCP_NODELAY选项</li>
</ul>
<p><strong>持久化优化</strong>：</p>
<ul>
<li>根据业务需求选择RDB或AOF</li>
<li>合理配置自动保存条件</li>
<li>在从节点上进行持久化操作</li>
</ul>
<p>这些详细的技术点涵盖了Redis的核心概念、常见问题解决方案和实际应用场景，是Redis技术面试的重要考查内容。掌握这些知识点并能结合实际项目经验进行说明，将大大提高面试通过率。</p>
<h2 id="内存管理与淘汰机制"><a href="#内存管理与淘汰机制" class="headerlink" title="内存管理与淘汰机制"></a>内存管理与淘汰机制</h2><h3 id="内存淘汰策略详解"><a href="#内存淘汰策略详解" class="headerlink" title="内存淘汰策略详解"></a>内存淘汰策略详解</h3><p>当Redis内存使用达到maxmemory限制时，会根据配置的策略淘汰数据。</p>
<p><strong>8种淘汰策略</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 针对所有key</span><br><span class="line">noeviction          # 不淘汰，写入返回错误</span><br><span class="line">allkeys-lru         # 所有key中淘汰最近最少使用</span><br><span class="line">allkeys-lfu         # 所有key中淘汰最少频率使用</span><br><span class="line">allkeys-random      # 所有key中随机淘汰</span><br><span class="line"></span><br><span class="line"># 针对设置了过期时间的key</span><br><span class="line">volatile-lru        # 过期key中淘汰最近最少使用</span><br><span class="line">volatile-lfu        # 过期key中淘汰最少频率使用</span><br><span class="line">volatile-random     # 过期key中随机淘汰</span><br><span class="line">volatile-ttl        # 过期key中淘汰即将过期的</span><br></pre></td></tr></table></figure>

<p><strong>LRU vs LFU 实现细节</strong>： Redis的LRU并非严格的LRU，而是近似LRU算法：</p>
<ul>
<li>每个key都有24位的时钟字段记录访问时间</li>
<li>淘汰时随机采样5个key（可配置），选择时钟值最小的</li>
</ul>
<p>LFU算法维护访问频率：</p>
<ul>
<li>高16位存储上次访问时间</li>
<li>低8位存储访问频率计数器</li>
<li>计数器采用概率性递增，避免频率无限增长</li>
</ul>
<h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p><strong>产生原因</strong>：</p>
<ul>
<li>频繁的数据更新导致内存分配&#x2F;释放</li>
<li>Redis使用jemalloc内存分配器，存在内存对齐</li>
<li>删除大key后留下内存空洞</li>
</ul>
<p><strong>检测方法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"># 关注 mem_fragmentation_ratio 指标</span><br><span class="line"># 比值 &gt; 1.5 表示碎片较多</span><br><span class="line"># 比值 &lt; 1 表示使用了swap，性能严重下降</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>内存整理</strong>（Redis 4.0+）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET activedefrag yes        # 开启自动整理</span><br><span class="line">CONFIG SET active-defrag-threshold-lower 10  # 碎片率超过10%启动</span><br><span class="line">MEMORY PURGE                       # 手动触发整理</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>重启Redis</strong>：最彻底但影响服务可用性</li>
<li><strong>优化数据结构</strong>：减少小对象，使用Hash存储相关数据</li>
</ol>
<h2 id="过期策略与删除机制"><a href="#过期策略与删除机制" class="headerlink" title="过期策略与删除机制"></a>过期策略与删除机制</h2><h3 id="三种过期删除策略"><a href="#三种过期删除策略" class="headerlink" title="三种过期删除策略"></a>三种过期删除策略</h3><p><strong>定时删除</strong>：设置过期时间时创建定时器，到期立即删除</p>
<ul>
<li>优点：及时释放内存</li>
<li>缺点：消耗CPU资源创建和管理定时器</li>
</ul>
<p><strong>惰性删除</strong>：访问key时检查是否过期，过期则删除</p>
<ul>
<li>优点：CPU友好，只在必要时删除</li>
<li>缺点：内存不友好，过期key可能长期占用内存</li>
</ul>
<p><strong>定期删除</strong>：定期随机检查部分key，删除过期的</p>
<ul>
<li>Redis的实际策略，平衡CPU和内存使用</li>
</ul>
<h3 id="Redis过期删除实现"><a href="#Redis过期删除实现" class="headerlink" title="Redis过期删除实现"></a>Redis过期删除实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 简化的过期删除逻辑</span><br><span class="line">void activeExpireCycle(int type) &#123;</span><br><span class="line">    static int current_db = 0;</span><br><span class="line">    static int timelimit_exit = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">        redisDb *db = server.db + current_db % server.dbnum;</span><br><span class="line">        </span><br><span class="line">        int iteration = 0;</span><br><span class="line">        while (iteration &lt; 20) &#123;  // 最多检查20个key</span><br><span class="line">            long sampled = 0, expired = 0;</span><br><span class="line">            </span><br><span class="line">            // 随机选择key检查过期</span><br><span class="line">            for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                dictEntry *de = dictGetRandomKey(db-&gt;expires);</span><br><span class="line">                if (de == NULL) break;</span><br><span class="line">                </span><br><span class="line">                sampled++;</span><br><span class="line">                if (keyIsExpired(db, de)) &#123;</span><br><span class="line">                    deleteExpiredKey(db, de);</span><br><span class="line">                    expired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 如果过期比例超过25%，继续下轮检查</span><br><span class="line">            if (expired &gt; 5) iteration++;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        current_db++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构底层实现深度解析"><a href="#数据结构底层实现深度解析" class="headerlink" title="数据结构底层实现深度解析"></a>数据结构底层实现深度解析</h2><h3 id="压缩列表（ZipList）演进"><a href="#压缩列表（ZipList）演进" class="headerlink" title="压缩列表（ZipList）演进"></a>压缩列表（ZipList）演进</h3><p>Redis 7.0用ListPack替代了ZipList，解决了级联更新问题。</p>
<p><strong>ZipList问题</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ZipList结构导致的级联更新</span><br><span class="line">// 当插入元素导致某个entry的长度改变时</span><br><span class="line">// 可能引起后续所有entry的重新编码</span><br></pre></td></tr></table></figure>

<p><strong>ListPack优势</strong>：</p>
<ul>
<li>每个元素独立编码，避免级联更新</li>
<li>支持从尾部遍历，提高某些操作效率</li>
</ul>
<h3 id="字典扩容与rehash"><a href="#字典扩容与rehash" class="headerlink" title="字典扩容与rehash"></a>字典扩容与rehash</h3><p>Redis字典使用增量式rehash避免阻塞：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 渐进式rehash实现</span><br><span class="line">int dictRehash(dict *d, int n) &#123;</span><br><span class="line">    int empty_visits = n * 10;</span><br><span class="line">    </span><br><span class="line">    if (!dictIsRehashing(d)) return 0;</span><br><span class="line">    </span><br><span class="line">    while (n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;</span><br><span class="line">        // 跳过空桶</span><br><span class="line">        while (d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            if (--empty_visits == 0) return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 迁移桶中所有元素</span><br><span class="line">        dictEntry *de = d-&gt;ht[0].table[d-&gt;rehashidx];</span><br><span class="line">        while (de) &#123;</span><br><span class="line">            dictEntry *nextde = de-&gt;next;</span><br><span class="line">            unsigned int h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[1].table[h];</span><br><span class="line">            d-&gt;ht[1].table[h] = de;</span><br><span class="line">            d-&gt;ht[0].used--;</span><br><span class="line">            d-&gt;ht[1].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络模型与性能优化"><a href="#网络模型与性能优化" class="headerlink" title="网络模型与性能优化"></a>网络模型与性能优化</h2><h3 id="Redis-6-0-多线程I-O"><a href="#Redis-6-0-多线程I-O" class="headerlink" title="Redis 6.0 多线程I&#x2F;O"></a>Redis 6.0 多线程I&#x2F;O</h3><p>多线程只用于网络I&#x2F;O，命令执行仍是单线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 多线程I/O处理流程</span><br><span class="line">void *IOThreadMain(void *myid) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 等待主线程分配任务</span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[id]);</span><br><span class="line">        </span><br><span class="line">        while (io_threads_list[id] &amp;&amp; io_threads_pending[id] == 0) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;io_threads_cond[id], &amp;io_threads_mutex[id]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 处理读写任务</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line">        listRewind(io_threads_list[id], &amp;li);</span><br><span class="line">        </span><br><span class="line">        while ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *c = listNodeValue(ln);</span><br><span class="line">            if (io_threads_op == IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                writeToClient(c, 0);</span><br><span class="line">            &#125; else if (io_threads_op == IO_THREADS_OP_READ) &#123;</span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        io_threads_pending[id] = 0;</span><br><span class="line">        pthread_mutex_unlock(&amp;io_threads_mutex[id]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端连接管理"><a href="#客户端连接管理" class="headerlink" title="客户端连接管理"></a>客户端连接管理</h3><p><strong>连接池配置优化</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Jedis连接池配置</span><br><span class="line">JedisPoolConfig config = new JedisPoolConfig();</span><br><span class="line">config.setMaxTotal(200);                    // 最大连接数</span><br><span class="line">config.setMaxIdle(50);                      // 最大空闲连接</span><br><span class="line">config.setMinIdle(10);                      // 最小空闲连接</span><br><span class="line">config.setTestOnBorrow(true);               // 获取连接时测试</span><br><span class="line">config.setTestOnReturn(true);               // 归还连接时测试</span><br><span class="line">config.setTestWhileIdle(true);              // 空闲时测试</span><br><span class="line">config.setTimeBetweenEvictionRunsMillis(30000);  // 检查间隔</span><br><span class="line">config.setNumTestsPerEvictionRun(10);       // 每次检查连接数</span><br><span class="line">config.setMinEvictableIdleTimeMillis(60000);     // 最小空闲时间</span><br><span class="line"></span><br><span class="line">JedisPool pool = new JedisPool(config, &quot;localhost&quot;, 6379);</span><br></pre></td></tr></table></figure>

<p><strong>Pipeline优化</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Pipeline批量操作</span><br><span class="line">public void batchSet(Map&lt;String, String&gt; data) &#123;</span><br><span class="line">    try (Jedis jedis = pool.getResource()) &#123;</span><br><span class="line">        Pipeline pipeline = jedis.pipelined();</span><br><span class="line">        </span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : data.entrySet()) &#123;</span><br><span class="line">            pipeline.set(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Object&gt; results = pipeline.syncAndReturnAll();</span><br><span class="line">        // 处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高级数据类型与应用"><a href="#高级数据类型与应用" class="headerlink" title="高级数据类型与应用"></a>高级数据类型与应用</h2><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>用于基数统计，占用内存固定（12KB），误差率0.81%。</p>
<p><strong>实现原理</strong>：</p>
<ul>
<li>基于概率算法，通过观察随机数的最大前导零个数估算基数</li>
<li>使用调和平均数减少误差</li>
<li>适用于UV统计等场景</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 网站UV统计</span><br><span class="line">PFADD uv:20230815 user1 user2 user3</span><br><span class="line">PFCOUNT uv:20230815                    # 获取UV数量</span><br><span class="line">PFMERGE uv:week uv:20230815 uv:20230816  # 合并多日数据</span><br></pre></td></tr></table></figure>

<h3 id="布隆过滤器（Redis-Module）"><a href="#布隆过滤器（Redis-Module）" class="headerlink" title="布隆过滤器（Redis Module）"></a>布隆过滤器（Redis Module）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Redis布隆过滤器模块</span><br><span class="line">BF.RESERVE myfilter 0.01 1000000       # 创建过滤器，误报率0.01%，预期元素100万</span><br><span class="line">BF.ADD myfilter &quot;user123&quot;              # 添加元素</span><br><span class="line">BF.EXISTS myfilter &quot;user123&quot;           # 检查元素是否存在</span><br><span class="line">BF.MADD myfilter item1 item2 item3     # 批量添加</span><br><span class="line">BF.MEXISTS myfilter item1 item2 item3  # 批量检查</span><br></pre></td></tr></table></figure>

<h3 id="Geo地理位置"><a href="#Geo地理位置" class="headerlink" title="Geo地理位置"></a>Geo地理位置</h3><p>基于Sorted Set实现，使用GeoHash算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 添加地理位置</span><br><span class="line">GEOADD cities 116.397128 39.916527 &quot;北京&quot; 121.473701 31.230416 &quot;上海&quot;</span><br><span class="line"></span><br><span class="line"># 计算距离</span><br><span class="line">GEODIST cities &quot;北京&quot; &quot;上海&quot; km</span><br><span class="line"></span><br><span class="line"># 范围查询</span><br><span class="line">GEORADIUS cities 116.397128 39.916527 1000 km WITHDIST WITHCOORD</span><br><span class="line"></span><br><span class="line"># 根据成员查询</span><br><span class="line">GEORADIUSBYMEMBER cities &quot;北京&quot; 1000 km</span><br></pre></td></tr></table></figure>

<h2 id="安全性问题与防护"><a href="#安全性问题与防护" class="headerlink" title="安全性问题与防护"></a>安全性问题与防护</h2><h3 id="常见安全漏洞"><a href="#常见安全漏洞" class="headerlink" title="常见安全漏洞"></a>常见安全漏洞</h3><p><strong>命令注入</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 错误做法：直接拼接用户输入</span><br><span class="line">String key = &quot;user:&quot; + userInput;  // userInput可能包含恶意命令</span><br><span class="line">jedis.eval(&quot;return redis.call(&#x27;get&#x27;, &#x27;&quot; + key + &quot;&#x27;)&quot;, 0);</span><br><span class="line"></span><br><span class="line">// 正确做法：使用参数化查询</span><br><span class="line">jedis.eval(&quot;return redis.call(&#x27;get&#x27;, KEYS[1])&quot;, 1, key);</span><br></pre></td></tr></table></figure>

<p><strong>未授权访问</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># redis.conf安全配置</span><br><span class="line">bind 127.0.0.1                        # 绑定指定IP</span><br><span class="line">requirepass your_password              # 设置密码</span><br><span class="line">protected-mode yes                     # 开启保护模式</span><br><span class="line">port 0                                # 禁用默认端口</span><br><span class="line">port 6380                             # 使用非标准端口</span><br></pre></td></tr></table></figure>

<p><strong>危险命令禁用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 重命名危险命令</span><br><span class="line">rename-command FLUSHDB &quot;&quot;             # 禁用FLUSHDB</span><br><span class="line">rename-command FLUSHALL &quot;&quot;            # 禁用FLUSHALL</span><br><span class="line">rename-command SHUTDOWN &quot;REDIS_SHUTDOWN&quot;  # 重命名SHUTDOWN</span><br><span class="line">rename-command CONFIG &quot;REDIS_CONFIG&quot;   # 重命名CONFIG</span><br></pre></td></tr></table></figure>

<h3 id="ACL访问控制（Redis-6-0-）"><a href="#ACL访问控制（Redis-6-0-）" class="headerlink" title="ACL访问控制（Redis 6.0+）"></a>ACL访问控制（Redis 6.0+）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户</span><br><span class="line">ACL SETUSER alice on &gt;password123 ~cached:* +get +set</span><br><span class="line"></span><br><span class="line"># 查看用户权限</span><br><span class="line">ACL LIST</span><br><span class="line"></span><br><span class="line"># 删除用户</span><br><span class="line">ACL DELUSER alice</span><br><span class="line"></span><br><span class="line"># 检查权限</span><br><span class="line">AUTH alice password123</span><br></pre></td></tr></table></figure>

<h2 id="监控与运维"><a href="#监控与运维" class="headerlink" title="监控与运维"></a>监控与运维</h2><h3 id="关键监控指标"><a href="#关键监控指标" class="headerlink" title="关键监控指标"></a>关键监控指标</h3><p><strong>性能指标</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 通过INFO命令获取</span><br><span class="line">INFO stats</span><br><span class="line"># 关注指标：</span><br><span class="line"># - instantaneous_ops_per_sec: QPS</span><br><span class="line"># - keyspace_hits/keyspace_misses: 命中率</span><br><span class="line"># - used_cpu_sys/used_cpu_user: CPU使用率</span><br><span class="line"># - connected_clients: 连接数</span><br><span class="line"># - blocked_clients: 阻塞连接数</span><br></pre></td></tr></table></figure>

<p><strong>内存指标</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"># 关注指标：</span><br><span class="line"># - used_memory: 已使用内存</span><br><span class="line"># - used_memory_rss: 物理内存占用</span><br><span class="line"># - mem_fragmentation_ratio: 内存碎片率</span><br><span class="line"># - used_memory_peak: 内存使用峰值</span><br></pre></td></tr></table></figure>

<p><strong>持久化指标</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO persistence</span><br><span class="line"># 关注指标：</span><br><span class="line"># - rdb_last_save_time: 最后RDB保存时间</span><br><span class="line"># - aof_last_rewrite_time_sec: AOF重写耗时</span><br><span class="line"># - aof_current_size: AOF文件大小</span><br></pre></td></tr></table></figure>

<h3 id="故障排查常用命令"><a href="#故障排查常用命令" class="headerlink" title="故障排查常用命令"></a>故障排查常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接信息</span><br><span class="line">CLIENT LIST</span><br><span class="line">CLIENT INFO</span><br><span class="line"></span><br><span class="line"># 慢查询分析</span><br><span class="line">SLOWLOG GET 10</span><br><span class="line">CONFIG GET slowlog-log-slower-than</span><br><span class="line"></span><br><span class="line"># 大key查找</span><br><span class="line">MEMORY USAGE keyname</span><br><span class="line">redis-cli --bigkeys</span><br><span class="line"></span><br><span class="line"># 热点key分析</span><br><span class="line">redis-cli --hotkeys</span><br><span class="line"></span><br><span class="line"># 延迟监控</span><br><span class="line">LATENCY HISTORY command</span><br><span class="line">CONFIG SET latency-monitor-threshold 100</span><br></pre></td></tr></table></figure>

<h2 id="特殊应用场景"><a href="#特殊应用场景" class="headerlink" title="特殊应用场景"></a>特殊应用场景</h2><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p><strong>固定窗口限流</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class RedisRateLimiter &#123;</span><br><span class="line">    public boolean isAllowed(String key, int limit, int window) &#123;</span><br><span class="line">        long current = System.currentTimeMillis() / 1000 / window;</span><br><span class="line">        String windowKey = key + &quot;:&quot; + current;</span><br><span class="line">        </span><br><span class="line">        String script = </span><br><span class="line">            &quot;local count = redis.call(&#x27;incr&#x27;, KEYS[1]) &quot; +</span><br><span class="line">            &quot;if count == 1 then &quot; +</span><br><span class="line">            &quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[1]) &quot; +</span><br><span class="line">            &quot;end &quot; +</span><br><span class="line">            &quot;return count&quot;;</span><br><span class="line">            </span><br><span class="line">        Long count = (Long) jedis.eval(script, Arrays.asList(windowKey), </span><br><span class="line">                                      Arrays.asList(String.valueOf(window)));</span><br><span class="line">        </span><br><span class="line">        return count &lt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>滑动窗口限流</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean slidingWindowLimit(String key, int limit, int window) &#123;</span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line">    long windowStart = now - window * 1000;</span><br><span class="line">    </span><br><span class="line">    String script = </span><br><span class="line">        &quot;redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">        &quot;local count = redis.call(&#x27;zcard&#x27;, KEYS[1]) &quot; +</span><br><span class="line">        &quot;if count &lt; tonumber(ARGV[2]) then &quot; +</span><br><span class="line">        &quot;  redis.call(&#x27;zadd&#x27;, KEYS[1], ARGV[3], ARGV[3]) &quot; +</span><br><span class="line">        &quot;  redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[4]) &quot; +</span><br><span class="line">        &quot;  return 1 &quot; +</span><br><span class="line">        &quot;else &quot; +</span><br><span class="line">        &quot;  return 0 &quot; +</span><br><span class="line">        &quot;end&quot;;</span><br><span class="line">    </span><br><span class="line">    Long result = (Long) jedis.eval(script, Arrays.asList(key),</span><br><span class="line">        Arrays.asList(String.valueOf(windowStart), String.valueOf(limit),</span><br><span class="line">                     String.valueOf(now), String.valueOf(window)));</span><br><span class="line">    </span><br><span class="line">    return result == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisSessionManager &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    public void createSession(String sessionId, String userId, int timeout) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        Map&lt;String, Object&gt; sessionData = new HashMap&lt;&gt;();</span><br><span class="line">        sessionData.put(&quot;userId&quot;, userId);</span><br><span class="line">        sessionData.put(&quot;createTime&quot;, System.currentTimeMillis());</span><br><span class="line">        </span><br><span class="line">        redisTemplate.opsForHash().putAll(key, sessionData);</span><br><span class="line">        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean isValidSession(String sessionId) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        return redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void renewSession(String sessionId, int timeout) &#123;</span><br><span class="line">        String key = &quot;session:&quot; + sessionId;</span><br><span class="line">        if (redisTemplate.hasKey(key)) &#123;</span><br><span class="line">            redisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息队列实现"><a href="#消息队列实现" class="headerlink" title="消息队列实现"></a>消息队列实现</h3><p><strong>基于List的简单队列</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class RedisQueue &#123;</span><br><span class="line">    // 生产者</span><br><span class="line">    public void produce(String queue, String message) &#123;</span><br><span class="line">        jedis.lpush(queue, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 消费者（阻塞式）</span><br><span class="line">    public String consume(String queue, int timeout) &#123;</span><br><span class="line">        List&lt;String&gt; result = jedis.brpop(timeout, queue);</span><br><span class="line">        return result != null ? result.get(1) : null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基于Stream的消息队列</strong>（Redis 5.0+）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 生产消息</span><br><span class="line">XADD mystream * field1 value1 field2 value2</span><br><span class="line"></span><br><span class="line"># 创建消费者组</span><br><span class="line">XGROUP CREATE mystream mygroup $ MKSTREAM</span><br><span class="line"></span><br><span class="line"># 消费消息</span><br><span class="line">XREADGROUP GROUP mygroup consumer1 COUNT 10 STREAMS mystream &gt;</span><br><span class="line"></span><br><span class="line"># 确认消息</span><br><span class="line">XACK mystream mygroup message_id</span><br></pre></td></tr></table></figure>

<h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class RedisDelayQueue &#123;</span><br><span class="line">    </span><br><span class="line">    public void addDelayTask(String task, long delayTime) &#123;</span><br><span class="line">        long executeTime = System.currentTimeMillis() + delayTime;</span><br><span class="line">        jedis.zadd(&quot;delay_queue&quot;, executeTime, task);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public List&lt;String&gt; getReadyTasks() &#123;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        Set&lt;String&gt; tasks = jedis.zrangeByScore(&quot;delay_queue&quot;, 0, now);</span><br><span class="line">        </span><br><span class="line">        if (!tasks.isEmpty()) &#123;</span><br><span class="line">            // 原子性删除已获取的任务</span><br><span class="line">            String script = </span><br><span class="line">                &quot;local tasks = redis.call(&#x27;zrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">                &quot;if #tasks &gt; 0 then &quot; +</span><br><span class="line">                &quot;  redis.call(&#x27;zremrangebyscore&#x27;, KEYS[1], 0, ARGV[1]) &quot; +</span><br><span class="line">                &quot;end &quot; +</span><br><span class="line">                &quot;return tasks&quot;;</span><br><span class="line">            </span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            List&lt;String&gt; result = (List&lt;String&gt;) jedis.eval(script, </span><br><span class="line">                Arrays.asList(&quot;delay_queue&quot;), Arrays.asList(String.valueOf(now)));</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能调优技巧"><a href="#性能调优技巧" class="headerlink" title="性能调优技巧"></a>性能调优技巧</h2><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p><strong>使用Hash存储小对象</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 不推荐：为每个用户字段单独设置key</span><br><span class="line">jedis.set(&quot;user:1001:name&quot;, &quot;张三&quot;);</span><br><span class="line">jedis.set(&quot;user:1001:age&quot;, &quot;25&quot;);</span><br><span class="line">jedis.set(&quot;user:1001:email&quot;, &quot;zhang@example.com&quot;);</span><br><span class="line"></span><br><span class="line">// 推荐：使用Hash存储</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;name&quot;, &quot;张三&quot;);</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;age&quot;, &quot;25&quot;);</span><br><span class="line">jedis.hset(&quot;user:1001&quot;, &quot;email&quot;, &quot;zhang@example.com&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>合理设置过期时间</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 避免同时过期导致雪崩</span><br><span class="line">int baseExpire = 3600;  // 1小时</span><br><span class="line">int randomExpire = baseExpire + new Random().nextInt(300);  // 增加0-5分钟随机时间</span><br><span class="line">jedis.setex(key, randomExpire, value);</span><br></pre></td></tr></table></figure>

<h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p><strong>批量操作优化</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用Pipeline</span><br><span class="line">Pipeline pipeline = jedis.pipelined();</span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    pipeline.set(&quot;key&quot; + i, &quot;value&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">pipeline.sync();</span><br><span class="line"></span><br><span class="line">// 或使用原生批量命令</span><br><span class="line">Map&lt;String, String&gt; batch = new HashMap&lt;&gt;();</span><br><span class="line">// ... 填充数据</span><br><span class="line">jedis.mset(flattenMap(batch));</span><br></pre></td></tr></table></figure>

<h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p><strong>Lua脚本减少网络往返</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 原子性增加库存</span><br><span class="line">local current = redis.call(&#x27;get&#x27;, KEYS[1])</span><br><span class="line">if current == false then</span><br><span class="line">    return -1  -- key不存在</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">current = tonumber(current)</span><br><span class="line">if current &gt;= tonumber(ARGV[1]) then</span><br><span class="line">    redis.call(&#x27;decrby&#x27;, KEYS[1], ARGV[1])</span><br><span class="line">    return current - tonumber(ARGV[1])</span><br><span class="line">else</span><br><span class="line">    return -2  -- 库存不足</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>你好，我很乐意为你详细讲解 Redis。</p>
<p>Redis 是一个开源的、基于内存的、高性能的键值存储系统。它通常被用作数据库、缓存和消息中间件。Redis 支持多种数据结构，如字符串、哈希、列表、集合和有序集合，这使得它在各种应用场景中都非常灵活。</p>
<h3 id="Redis-的核心特点"><a href="#Redis-的核心特点" class="headerlink" title="Redis 的核心特点"></a>Redis 的核心特点</h3><hr>
<ul>
<li><strong>高性能</strong>: Redis 的所有数据都存储在内存中，因此读写速度非常快。通常，单个 Redis 实例每秒能处理超过 10 万次读写操作。</li>
<li><strong>丰富的数据结构</strong>: Redis 不仅仅是简单的键值存储，它支持多种复杂的数据结构，这让它能满足更广泛的应用需求。</li>
<li><strong>持久化</strong>: 虽然 Redis 是基于内存的，但它提供了两种不同的持久化方式，可以将数据从内存中保存到磁盘上，以防止服务器重启后数据丢失。</li>
<li><strong>原子性</strong>: Redis 的所有操作都是原子性的。这意味着一个命令要么完全执行，要么根本不执行，中间不会被打断，这在多客户端并发访问时尤其重要。</li>
<li><strong>主从复制</strong>: Redis 支持主从复制，可以将数据从一个主节点（Master）同步到一个或多个从节点（Slave），从而实现数据的备份和读写分离，提高系统的可用性和扩展性。</li>
<li><strong>高可用性与集群</strong>: Redis 提供了 Sentinel（哨兵）和 Cluster（集群）两种方案，来保证系统的高可用性和扩展性。</li>
</ul>
<h3 id="Redis-的数据结构详解"><a href="#Redis-的数据结构详解" class="headerlink" title="Redis 的数据结构详解"></a>Redis 的数据结构详解</h3><hr>
<p>这是 Redis 最有特色的地方，理解这些数据结构是掌握 Redis 的关键。</p>
<h4 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1. String (字符串)"></a>1. String (字符串)</h4><ul>
<li><strong>最基本的数据结构</strong>，可以存储任何类型的数据，比如字符串、数字或二进制数据。一个键最多可以存储 512MB 的值。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>SET key value</code>: 设置键值对。</li>
<li><code>GET key</code>: 获取键对应的值。</li>
<li><code>INCR key</code>: 将键对应的值加 1，常用于计数器。</li>
<li><code>MSET key1 value1 key2 value2</code>: 同时设置多个键值对。</li>
<li><code>MGET key1 key2</code>: 同时获取多个键的值。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 缓存、计数器、分布式锁等。</li>
</ul>
<h4 id="2-Hash-哈希"><a href="#2-Hash-哈希" class="headerlink" title="2. Hash (哈希)"></a>2. Hash (哈希)</h4><ul>
<li><strong>类似于一个键值对的集合</strong>。一个哈希键可以存储多个字段（field）和对应的值（value），非常适合存储对象。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>HSET key field value</code>: 设置哈希键中一个字段的值。</li>
<li><code>HGET key field</code>: 获取哈希键中一个字段的值。</li>
<li><code>HGETALL key</code>: 获取哈希键中所有的字段和值。</li>
<li><code>HMSET key field1 value1 field2 value2</code>: 同时设置多个字段。</li>
<li><code>HDEL key field1 field2</code>: 删除一个或多个字段。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 存储用户信息（如<code>user:100</code>作为键，<code>name</code>、<code>age</code>、<code>city</code>作为字段），商品信息等。</li>
</ul>
<h4 id="3-List-列表"><a href="#3-List-列表" class="headerlink" title="3. List (列表)"></a>3. List (列表)</h4><ul>
<li><strong>一个有序的、可以重复的字符串集合</strong>。可以从列表的头部或尾部添加或删除元素。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>LPUSH key value1 value2</code>: 从列表的头部插入一个或多个值。</li>
<li><code>RPUSH key value1 value2</code>: 从列表的尾部插入一个或多个值。</li>
<li><code>LPOP key</code>: 从列表的头部移除并返回一个值。</li>
<li><code>RPOP key</code>: 从列表的尾部移除并返回一个值。</li>
<li><code>LRANGE key start stop</code>: 获取列表中指定范围的元素。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 消息队列（队列、栈）、最新文章列表、历史记录等。</li>
</ul>
<h4 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4. Set (集合)"></a>4. Set (集合)</h4><ul>
<li><strong>一个无序的、不重复的字符串集合</strong>。集合提供了交集、并集和差集等操作。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>SADD key member1 member2</code>: 向集合中添加一个或多个成员。</li>
<li><code>SMEMBERS key</code>: 获取集合中的所有成员。</li>
<li><code>SISMEMBER key member</code>: 判断一个成员是否在集合中。</li>
<li><code>SINTER key1 key2</code>: 求两个集合的交集。</li>
<li><code>SUNION key1 key2</code>: 求两个集合的并集。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 社交网络中的共同好友、标签系统、去重等。</li>
</ul>
<h4 id="5-Sorted-Set-有序集合"><a href="#5-Sorted-Set-有序集合" class="headerlink" title="5. Sorted Set (有序集合)"></a>5. Sorted Set (有序集合)</h4><ul>
<li><strong>和集合类似，但每个成员都会关联一个分数（score）</strong>。通过这个分数，可以对集合中的成员进行排序。分数可以重复，但成员必须唯一。</li>
<li><strong>常用命令</strong>:<ul>
<li><code>ZADD key score1 member1 score2 member2</code>: 向有序集合中添加一个或多个带分数的成员。</li>
<li><code>ZRANGE key start stop</code>: 按分数从小到大排序，获取指定范围的成员。</li>
<li><code>ZREVRANGE key start stop</code>: 按分数从大到小排序，获取指定范围的成员。</li>
<li><code>ZSCORE key member</code>: 获取一个成员的分数。</li>
<li><code>ZINCRBY key increment member</code>: 给指定成员的分数增加指定值。</li>
</ul>
</li>
<li><strong>应用场景</strong>: 排行榜（游戏分数、热点新闻）、带权重的任务队列等。</li>
</ul>
<h3 id="Redis-的持久化机制"><a href="#Redis-的持久化机制" class="headerlink" title="Redis 的持久化机制"></a>Redis 的持久化机制</h3><hr>
<p>Redis 提供了两种持久化方式，可以将数据从内存保存到硬盘，确保数据不会因为服务重启而丢失。</p>
<h4 id="1-RDB-Redis-Database"><a href="#1-RDB-Redis-Database" class="headerlink" title="1. RDB (Redis Database)"></a>1. RDB (Redis Database)</h4><ul>
<li><strong>快照方式</strong>。它会在指定的时间间隔内，将内存中的数据快照写入到磁盘上一个二进制文件中（<code>dump.rdb</code>）。</li>
<li><strong>优点</strong>: RDB 文件是一个非常紧凑的二进制文件，非常适合备份和灾难恢复。</li>
<li><strong>缺点</strong>: 每次保存都会丢失从上次快照到现在之间的数据。</li>
</ul>
<h4 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2. AOF (Append Only File)"></a>2. AOF (Append Only File)</h4><ul>
<li><strong>日志方式</strong>。它会记录每一次对 Redis 数据库的写操作命令，并以追加（append）的方式写入到文件中。当 Redis 重启时，会重新执行 AOF 文件中的命令来恢复数据。</li>
<li><strong>优点</strong>: 数据丢失风险低，可以配置为每秒同步一次，或者每执行一个命令就同步一次。</li>
<li><strong>缺点</strong>: AOF 文件通常比 RDB 文件大，且恢复速度可能较慢。</li>
</ul>
<p>在实际应用中，通常会<strong>同时使用 RDB 和 AOF</strong>，以获得更高的可靠性。</p>
<h3 id="Redis-的高可用性"><a href="#Redis-的高可用性" class="headerlink" title="Redis 的高可用性"></a>Redis 的高可用性</h3><hr>
<h4 id="1-主从复制-Replication"><a href="#1-主从复制-Replication" class="headerlink" title="1. 主从复制 (Replication)"></a>1. 主从复制 (Replication)</h4><ul>
<li><strong>基本原理</strong>: 将一个 Redis 实例（主节点）的数据复制到一个或多个其他实例（从节点）。从节点的数据是主节点的完整副本。</li>
<li><strong>作用</strong>:<ul>
<li><strong>数据备份</strong>: 从节点可以作为数据的热备份。</li>
<li><strong>读写分离</strong>: 大多数读操作可以分流到从节点上，减轻主节点的压力。</li>
</ul>
</li>
</ul>
<h4 id="2-Sentinel-哨兵"><a href="#2-Sentinel-哨兵" class="headerlink" title="2. Sentinel (哨兵)"></a>2. Sentinel (哨兵)</h4><ul>
<li><strong>作用</strong>: 自动化管理主从复制集群。它是一个监控系统，可以监控主节点和从节点是否正常运行。</li>
<li><strong>核心功能</strong>:<ul>
<li><strong>监控</strong>: 不断检查主从节点是否正常工作。</li>
<li><strong>通知</strong>: 当某个 Redis 实例出现问题时，会发送通知。</li>
<li><strong>故障转移</strong>: 如果主节点发生故障，Sentinel 会自动从剩下的从节点中选举一个新的主节点，并让其他从节点切换到这个新的主节点上，从而实现高可用。</li>
</ul>
</li>
</ul>
<h4 id="3-Redis-Cluster-集群"><a href="#3-Redis-Cluster-集群" class="headerlink" title="3. Redis Cluster (集群)"></a>3. Redis Cluster (集群)</h4><ul>
<li><strong>作用</strong>: 解决 Redis 单机内存容量和并发量的瓶颈问题。它将数据分散到多个节点上，每个节点只负责存储部分数据。</li>
<li><strong>核心功能</strong>:<ul>
<li><strong>数据分片</strong>: 自动将数据分布在多个节点上。</li>
<li><strong>高可用性</strong>: 即使部分节点宕机，集群也能继续正常工作。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/" data-id="cmffake6p000650uy8oku3o4z" data-title="分布式" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo-Markdown/" rel="tag">Hexo, Markdown</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-命令大全" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" class="article-date">
  <time class="dt-published" datetime="2025-09-11T10:29:28.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/">命令大全</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" data-id="cmffake6p000850uy88f6hi7d" data-title="命令大全" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo-Markdown/" rel="tag">Hexo, Markdown</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/11/%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-09-11T10:29:28.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/11/%E7%AE%97%E6%B3%95/">算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/11/%E7%AE%97%E6%B3%95/" data-id="cmffake6q000a50uycbeqeyt2" data-title="算法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo-Markdown/" rel="tag">Hexo, Markdown</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-框架" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/11/%E6%A1%86%E6%9E%B6/" class="article-date">
  <time class="dt-published" datetime="2025-09-11T10:29:28.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/11/%E6%A1%86%E6%9E%B6/">框架</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/11/%E6%A1%86%E6%9E%B6/" data-id="cmffake6q000d50uy09ea4ixm" data-title="框架" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo-Markdown/" rel="tag">Hexo, Markdown</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-框架背诵" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/11/%E6%A1%86%E6%9E%B6%E8%83%8C%E8%AF%B5/" class="article-date">
  <time class="dt-published" datetime="2025-09-11T10:29:28.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/11/%E6%A1%86%E6%9E%B6%E8%83%8C%E8%AF%B5/">框架背诵</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java框架核心知识详解"><a href="#Java框架核心知识详解" class="headerlink" title="Java框架核心知识详解"></a>Java框架核心知识详解</h1><h2 id="一、Spring框架深入解析"><a href="#一、Spring框架深入解析" class="headerlink" title="一、Spring框架深入解析"></a>一、Spring框架深入解析</h2><h3 id="1-1-Spring核心概念与原理"><a href="#1-1-Spring核心概念与原理" class="headerlink" title="1.1 Spring核心概念与原理"></a>1.1 Spring核心概念与原理</h3><p>Spring框架是一个分层的企业级应用开发框架，其核心是控制反转（IoC）和面向切面编程（AOP）。</p>
<h4 id="IoC容器原理深入分析"><a href="#IoC容器原理深入分析" class="headerlink" title="IoC容器原理深入分析"></a>IoC容器原理深入分析</h4><p><strong>IoC（控制反转）的本质：</strong> 传统开发中，对象的创建和依赖关系由程序代码直接控制，而IoC将这个控制权交给了外部容器。Spring通过依赖注入（DI）来实现IoC。</p>
<p><strong>IoC容器的实现机制：</strong></p>
<ol>
<li><strong>BeanFactory</strong>: 基础容器，提供基本的IoC功能</li>
<li><strong>ApplicationContext</strong>: 高级容器，继承BeanFactory，提供更多企业级功能</li>
</ol>
<p><strong>Bean的生命周期详解：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例化 → 属性赋值 → 初始化前处理 → 初始化 → 初始化后处理 → 使用 → 销毁前处理 → 销毁</span><br></pre></td></tr></table></figure>

<p><strong>详细生命周期步骤：</strong></p>
<ol>
<li>Bean元数据解析（XML、注解、Java配置）</li>
<li>调用Bean构造函数实例化</li>
<li>依赖注入（setter方法、构造函数、字段注入）</li>
<li>如果实现了BeanNameAware，调用setBeanName()</li>
<li>如果实现了BeanFactoryAware，调用setBeanFactory()</li>
<li>如果实现了ApplicationContextAware，调用setApplicationContext()</li>
<li>如果有BeanPostProcessor，调用postProcessBeforeInitialization()</li>
<li>如果实现了InitializingBean，调用afterPropertiesSet()</li>
<li>如果配置了init-method，调用自定义初始化方法</li>
<li>如果有BeanPostProcessor，调用postProcessAfterInitialization()</li>
<li>Bean可以被使用</li>
<li>容器关闭时，如果实现了DisposableBean，调用destroy()</li>
<li>如果配置了destroy-method，调用自定义销毁方法</li>
</ol>
<h4 id="DI的三种注入方式对比"><a href="#DI的三种注入方式对比" class="headerlink" title="DI的三种注入方式对比"></a>DI的三种注入方式对比</h4><ul>
<li><p><strong>构造器注入（Constructor Injection）</strong></p>
<ul>
<li><strong>优点</strong>：强制依赖、依赖清晰、不可变性</li>
<li><strong>缺点</strong>：当依赖项过多时构造函数臃肿</li>
<li><strong>最佳实践</strong>：官方推荐，特别是当依赖是必需的、不可选的时候</li>
</ul>
</li>
<li><p><strong>Setter注入（Setter Injection）</strong></p>
<ul>
<li><strong>优点</strong>：可选依赖，灵活性高</li>
<li><strong>缺点</strong>：对象可能处于不完整状态，无法使用final修饰</li>
<li><strong>最佳实践</strong>：用于注入可选的依赖项</li>
</ul>
</li>
<li><p><strong>字段注入（Field Injection）</strong></p>
<ul>
<li><strong>优点</strong>：代码简洁</li>
<li><strong>缺点</strong>：不推荐使用，隐藏依赖、测试困难、无法使用final修饰</li>
</ul>
</li>
</ul>
<h4 id="AOP原理深入分析"><a href="#AOP原理深入分析" class="headerlink" title="AOP原理深入分析"></a>AOP原理深入分析</h4><p><strong>AOP实现机制：</strong> Spring AOP基于代理模式实现，支持两种代理方式：</p>
<ol>
<li><strong>JDK动态代理</strong>: 针对实现了接口的类</li>
<li><strong>CGLIB代理</strong>: 针对没有实现接口的类</li>
</ol>
<p>我们来系统性地讲解一下 <strong>Spring AOP 的实现机制</strong>，包括：</p>
<ol>
<li>JDK 动态代理</li>
<li>CGLIB 动态代理</li>
<li>静态代理（对比说明）</li>
</ol>
<hr>
<h2 id="🌟-一、Spring-AOP-实现机制概述"><a href="#🌟-一、Spring-AOP-实现机制概述" class="headerlink" title="🌟 一、Spring AOP 实现机制概述"></a>🌟 一、Spring AOP 实现机制概述</h2><p>Spring AOP（面向切面编程）是基于 <strong>代理模式</strong> 实现的，它通过在目标方法执行前后织入逻辑（增强），实现横切关注点（如日志、安全、事务等）的分离。</p>
<blockquote>
<p>Spring AOP 仅支持方法级别的代理（即对方法进行增强），不支持字段、构造器等底层字节码增强（这要用 AspectJ）。</p>
</blockquote>
<hr>
<h2 id="🧩-二、Spring-AOP-的两种动态代理方式"><a href="#🧩-二、Spring-AOP-的两种动态代理方式" class="headerlink" title="🧩 二、Spring AOP 的两种动态代理方式"></a>🧩 二、Spring AOP 的两种动态代理方式</h2><h3 id="1️⃣-JDK-动态代理（基于接口）"><a href="#1️⃣-JDK-动态代理（基于接口）" class="headerlink" title="1️⃣ JDK 动态代理（基于接口）"></a>1️⃣ JDK 动态代理（基于接口）</h3><h4 id="✅-原理："><a href="#✅-原理：" class="headerlink" title="✅ 原理："></a>✅ 原理：</h4><ul>
<li>基于 Java 的 <code>java.lang.reflect.Proxy</code> 类实现。</li>
<li>必须要有接口，Spring 会为接口生成代理类。</li>
<li>代理类在运行时实现接口，并将调用委托给 InvocationHandler。</li>
</ul>
<h4 id="📦-示例："><a href="#📦-示例：" class="headerlink" title="📦 示例："></a>📦 示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring AOP 为 <code>UserService</code> 创建代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">    userService.getClass().getClassLoader(),</span><br><span class="line">    userService.getClass().getInterfaces(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="🎯-特点："><a href="#🎯-特点：" class="headerlink" title="🎯 特点："></a>🎯 特点：</h4><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>是否依赖接口</td>
<td>✅ 是</td>
</tr>
<tr>
<td>性能</td>
<td>较高（比 CGLIB 略快）</td>
</tr>
<tr>
<td>生成的代理类</td>
<td>实现接口</td>
</tr>
</tbody></table>
<hr>
<h3 id="2️⃣-CGLIB-动态代理（基于子类）"><a href="#2️⃣-CGLIB-动态代理（基于子类）" class="headerlink" title="2️⃣ CGLIB 动态代理（基于子类）"></a>2️⃣ CGLIB 动态代理（基于子类）</h3><h4 id="✅-原理：-1"><a href="#✅-原理：-1" class="headerlink" title="✅ 原理："></a>✅ 原理：</h4><ul>
<li>使用 CGLIB 库在运行时 <strong>生成目标类的子类</strong>，并重写其方法来实现增强。</li>
<li>适用于 <strong>没有接口</strong> 的类，或者想对类本身增强而非接口。</li>
</ul>
<h4 id="🧪-示例："><a href="#🧪-示例：" class="headerlink" title="🧪 示例："></a>🧪 示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 通过 CGLIB 生成子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">enhancer.setSuperclass(UserService.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) enhancer.create();</span><br></pre></td></tr></table></figure>

<h4 id="🎯-特点：-1"><a href="#🎯-特点：-1" class="headerlink" title="🎯 特点："></a>🎯 特点：</h4><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>是否依赖接口</td>
<td>❌ 否</td>
</tr>
<tr>
<td>是否可代理 final 类&#x2F;方法</td>
<td>❌ 否（final 无法被继承&#x2F;重写）</td>
</tr>
<tr>
<td>生成的代理类</td>
<td>子类</td>
</tr>
</tbody></table>
<hr>
<h2 id="🏗-三、静态代理（对比动态代理）"><a href="#🏗-三、静态代理（对比动态代理）" class="headerlink" title="🏗 三、静态代理（对比动态代理）"></a>🏗 三、静态代理（对比动态代理）</h2><h3 id="✅-原理：-2"><a href="#✅-原理：-2" class="headerlink" title="✅ 原理："></a>✅ 原理：</h3><ul>
<li>自己写一个代理类，<strong>实现相同接口</strong>，将方法调用委托给目标对象，并在调用前后手动添加增强逻辑。</li>
</ul>
<h4 id="🧪-示例：-1"><a href="#🧪-示例：-1" class="headerlink" title="🧪 示例："></a>🧪 示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">        target.addUser();</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="🎯-特点：-2"><a href="#🎯-特点：-2" class="headerlink" title="🎯 特点："></a>🎯 特点：</h4><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>是否自动生成</td>
<td>❌ 需手动编码</td>
</tr>
<tr>
<td>灵活性</td>
<td>差（每个类都要写一个代理类）</td>
</tr>
<tr>
<td>是否支持 AOP</td>
<td>❌ 无法动态织入多个切面</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔚-四、三者对比总结"><a href="#🔚-四、三者对比总结" class="headerlink" title="🔚 四、三者对比总结"></a>🔚 四、三者对比总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>静态代理</th>
<th>JDK 动态代理</th>
<th>CGLIB 动态代理</th>
</tr>
</thead>
<tbody><tr>
<td>是否依赖接口</td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>❌ 否</td>
</tr>
<tr>
<td>是否自动生成代理类</td>
<td>❌ 手动编写</td>
<td>✅ 运行时生成</td>
<td>✅ 运行时生成</td>
</tr>
<tr>
<td>是否可代理类</td>
<td>❌ 否（接口为主）</td>
<td>❌ 否（接口为主）</td>
<td>✅ 是（类的子类）</td>
</tr>
<tr>
<td>性能</td>
<td>一般</td>
<td>较高</td>
<td>略慢（但可接受）</td>
</tr>
<tr>
<td>是否支持 final 方法</td>
<td>✅</td>
<td>✅</td>
<td>❌ 否</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-Spring-如何选择代理方式？"><a href="#✅-Spring-如何选择代理方式？" class="headerlink" title="✅ Spring 如何选择代理方式？"></a>✅ Spring 如何选择代理方式？</h2><ul>
<li>默认使用 JDK 动态代理（如果目标类实现了接口）。</li>
<li>如果目标类没有接口，Spring 自动切换为 CGLIB。</li>
<li>可以强制使用 CGLIB：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br></pre></td></tr></table></figure>

<p><strong>AOP核心概念：</strong></p>
<ul>
<li><strong>切面（Aspect）</strong>: 横切关注点的模块化</li>
<li><strong>连接点（Joinpoint）</strong>: 程序执行中的特定点</li>
<li><strong>切点（Pointcut）</strong>: 连接点的集合</li>
<li><strong>通知（Advice）</strong>: 切面在特定连接点执行的代码</li>
<li><strong>目标对象（Target）</strong>: 被代理的对象</li>
<li><strong>代理对象（Proxy）</strong>: AOP框架创建的对象</li>
</ul>
<p><strong>JDK动态代理 vs. CGLIB动态代理</strong></p>
<ul>
<li><p><strong>JDK动态代理</strong>：</p>
<ul>
<li>基于接口实现</li>
<li>使用Proxy.newProxyInstance()创建代理</li>
<li>只能代理实现了接口的类</li>
</ul>
</li>
<li><p><strong>CGLIB动态代理</strong>：</p>
<ul>
<li>基于继承实现</li>
<li>使用Enhancer类创建代理</li>
<li>可以代理普通类</li>
<li>不能代理final类和方法</li>
</ul>
</li>
</ul>
<h3 id="1-2-Spring核心注解详解"><a href="#1-2-Spring核心注解详解" class="headerlink" title="1.2 Spring核心注解详解"></a>1.2 Spring核心注解详解</h3><h4 id="基础配置注解"><a href="#基础配置注解" class="headerlink" title="基础配置注解"></a>基础配置注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">// 表示这是一个配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span>  <span class="comment">// 组件扫描</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>  <span class="comment">// 启用自动配置</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span>  <span class="comment">// SpringBoot主类注解，包含上述三个</span></span><br><span class="line"><span class="meta">@Import(OtherConfig.class)</span>  <span class="comment">// 导入其他配置类</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span>  <span class="comment">// 加载属性文件</span></span><br></pre></td></tr></table></figure>

<h4 id="Bean定义注解"><a href="#Bean定义注解" class="headerlink" title="Bean定义注解"></a>Bean定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">// 通用组件</span></span><br><span class="line"><span class="meta">@Service</span>    <span class="comment">// 业务层组件</span></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 数据访问层组件</span></span><br><span class="line"><span class="meta">@Controller</span> <span class="comment">// 控制层组件</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// RESTful控制器，相当于@Controller + @ResponseBody</span></span><br><span class="line"><span class="meta">@Bean</span>       <span class="comment">// 方法级别，定义Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton/prototype/request/session&quot;)</span>  <span class="comment">// Bean作用域</span></span><br><span class="line"><span class="meta">@Lazy</span>       <span class="comment">// 延迟初始化</span></span><br><span class="line"><span class="meta">@Primary</span>    <span class="comment">// 优先注入</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;beanName&quot;)</span>  <span class="comment">// 指定注入的Bean名称</span></span><br></pre></td></tr></table></figure>

<h4 id="依赖注入注解"><a href="#依赖注入注解" class="headerlink" title="依赖注入注解"></a>依赖注入注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>  <span class="comment">// 自动装配，可用于构造函数、方法、字段</span></span><br><span class="line"><span class="meta">@Resource</span>   <span class="comment">// JSR-250标准，按名称注入</span></span><br><span class="line"><span class="meta">@Inject</span>     <span class="comment">// JSR-330标准</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;property.name&#125;&quot;)</span>  <span class="comment">// 注入配置值</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span>  <span class="comment">// 绑定配置属性</span></span><br></pre></td></tr></table></figure>

<h4 id="生命周期注解"><a href="#生命周期注解" class="headerlink" title="生命周期注解"></a>生命周期注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span>  <span class="comment">// 初始化方法</span></span><br><span class="line"><span class="meta">@PreDestroy</span>     <span class="comment">// 销毁方法</span></span><br></pre></td></tr></table></figure>

<h4 id="AOP相关注解"><a href="#AOP相关注解" class="headerlink" title="AOP相关注解"></a>AOP相关注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>         <span class="comment">// 声明切面</span></span><br><span class="line"><span class="meta">@Pointcut</span>       <span class="comment">// 定义切点</span></span><br><span class="line"><span class="meta">@Before</span>         <span class="comment">// 前置通知</span></span><br><span class="line"><span class="meta">@After</span>          <span class="comment">// 后置通知</span></span><br><span class="line"><span class="meta">@AfterReturning</span> <span class="comment">// 返回后通知</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>  <span class="comment">// 异常通知</span></span><br><span class="line"><span class="meta">@Around</span>         <span class="comment">// 环绕通知</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-Spring常见使用场景"><a href="#1-3-Spring常见使用场景" class="headerlink" title="1.3 Spring常见使用场景"></a>1.3 Spring常见使用场景</h3><h4 id="场景1：服务层事务管理"><a href="#场景1：服务层事务管理" class="headerlink" title="场景1：服务层事务管理"></a>场景1：服务层事务管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景2：缓存管理"><a href="#场景2：缓存管理" class="headerlink" title="场景2：缓存管理"></a>场景2：缓存管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;products&quot;, key = &quot;#product.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productRepository.save(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-Spring常见面试问题"><a href="#1-4-Spring常见面试问题" class="headerlink" title="1.4 Spring常见面试问题"></a>1.4 Spring常见面试问题</h3><p><strong>Q1: Spring IoC容器的初始化过程是怎样的？</strong></p>
<p>A: Spring IoC容器初始化分为三个阶段：</p>
<ol>
<li><strong>Resource定位</strong>: 定位配置文件</li>
<li><strong>BeanDefinition载入</strong>: 将配置信息转换为Spring内部数据结构</li>
<li><strong>BeanDefinition注册</strong>: 将BeanDefinition注册到IoC容器的HashMap中</li>
</ol>
<p>具体流程：</p>
<ul>
<li>创建ApplicationContext</li>
<li>加载配置元数据（XML、注解、Java配置）</li>
<li>解析配置，创建BeanDefinition</li>
<li>注册BeanDefinition到BeanDefinitionRegistry</li>
<li>实例化非懒加载的单例Bean</li>
</ul>
<p><strong>Q2: Spring中的循环依赖是如何解决的？</strong></p>
<p>A: Spring通过三级缓存解决循环依赖：</p>
<ol>
<li><strong>singletonObjects</strong>: 一级缓存，存放完整的Bean实例</li>
<li><strong>earlySingletonObjects</strong>: 二级缓存，存放早期的Bean实例</li>
<li><strong>singletonFactories</strong>: 三级缓存，存放Bean工厂</li>
</ol>
<p>解决过程：</p>
<ul>
<li>A依赖B，B依赖A</li>
<li>创建A时，将A的工厂放入三级缓存</li>
<li>A需要注入B，开始创建B</li>
<li>B需要注入A，从缓存中获取A的早期实例</li>
<li>B创建完成，A继续创建完成</li>
</ul>
<p><strong>Q3: Spring AOP的实现原理？</strong></p>
<p>A: Spring AOP基于代理模式实现：</p>
<ol>
<li><strong>JDK动态代理</strong>: 目标类实现接口时使用，基于反射机制</li>
<li><strong>CGLIB代理</strong>: 目标类没有接口时使用，基于字节码技术</li>
</ol>
<p>代理创建过程：</p>
<ul>
<li>Spring在Bean初始化后，检查是否需要AOP</li>
<li>如果需要，创建代理对象替换原始Bean</li>
<li>代理对象拦截方法调用，执行切面逻辑</li>
</ul>
<h2 id="二、Spring-Boot深入解析"><a href="#二、Spring-Boot深入解析" class="headerlink" title="二、Spring Boot深入解析"></a>二、Spring Boot深入解析</h2><h3 id="2-1-Spring-Boot核心原理"><a href="#2-1-Spring-Boot核心原理" class="headerlink" title="2.1 Spring Boot核心原理"></a>2.1 Spring Boot核心原理</h3><p><strong>自动配置原理：</strong> Spring Boot通过@EnableAutoConfiguration注解启用自动配置机制。</p>
<p>核心类分析：</p>
<ol>
<li><strong>SpringBootApplication</strong>: 组合注解，包含@Configuration、@EnableAutoConfiguration、@ComponentScan</li>
<li><strong>AutoConfigurationImportSelector</strong>: 负责导入自动配置类</li>
<li><strong>spring.factories</strong>: META-INF&#x2F;spring.factories文件定义自动配置类</li>
</ol>
<p><strong>自动配置流程：</strong></p>
<ol>
<li>SpringBoot启动时扫描所有jar包下的META-INF&#x2F;spring.factories文件</li>
<li>加载文件中定义的自动配置类</li>
<li>根据条件注解(@ConditionalOnClass等)判断是否生效</li>
<li>生效的配置类会创建相应的Bean</li>
</ol>
<h3 id="2-2-Spring-Boot启动流程详解"><a href="#2-2-Spring-Boot启动流程详解" class="headerlink" title="2.2 Spring Boot启动流程详解"></a>2.2 Spring Boot启动流程详解</h3><p><strong>SpringApplication.run()方法执行流程：</strong></p>
<ol>
<li><strong>准备阶段</strong>：<ul>
<li>创建SpringApplication实例</li>
<li>确定应用类型（SERVLET、REACTIVE、NONE）</li>
<li>加载ApplicationContextInitializer</li>
<li>加载ApplicationListener</li>
</ul>
</li>
<li><strong>启动阶段</strong>：<ul>
<li>启动计时器</li>
<li>配置Headless模式</li>
<li>获取并启动监听器</li>
<li>准备环境（Environment）</li>
<li>打印Banner</li>
</ul>
</li>
<li><strong>容器创建阶段</strong>：<ul>
<li>创建ApplicationContext</li>
<li>准备ApplicationContext</li>
<li>刷新ApplicationContext</li>
<li>刷新后处理</li>
</ul>
</li>
<li><strong>完成阶段</strong>：<ul>
<li>停止计时器</li>
<li>发布启动完成事件</li>
<li>调用Runners</li>
</ul>
</li>
</ol>
<h3 id="2-3-Spring-Boot核心注解"><a href="#2-3-Spring-Boot核心注解" class="headerlink" title="2.3 Spring Boot核心注解"></a>2.3 Spring Boot核心注解</h3><h4 id="启动类注解"><a href="#启动类注解" class="headerlink" title="启动类注解"></a>启动类注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 等价于以下三个注解的组合</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span>  <span class="comment">// Spring Boot配置类</span></span><br><span class="line"><span class="meta">@EnableScheduling</span>        <span class="comment">// 启用定时任务</span></span><br><span class="line"><span class="meta">@EnableAsync</span>            <span class="comment">// 启用异步处理</span></span><br><span class="line"><span class="meta">@EnableCaching</span>          <span class="comment">// 启用缓存</span></span><br></pre></td></tr></table></figure>

<h4 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(DataSource.class)</span>      <span class="comment">// 类路径下存在指定类</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span> <span class="comment">// 容器中不存在指定Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;app.enabled&quot;, havingValue = &quot;true&quot;)</span> <span class="comment">// 属性匹配</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>               <span class="comment">// Web应用环境</span></span><br><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span>            <span class="comment">// 非Web应用环境</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span>                           <span class="comment">// 激活的profile</span></span><br></pre></td></tr></table></figure>

<h4 id="配置属性注解"><a href="#配置属性注解" class="headerlink" title="配置属性注解"></a>配置属性注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Spring-Boot实际应用场景"><a href="#2-4-Spring-Boot实际应用场景" class="headerlink" title="2.4 Spring Boot实际应用场景"></a>2.4 Spring Boot实际应用场景</h3><h4 id="场景1：微服务架构"><a href="#场景1：微服务架构" class="headerlink" title="场景1：微服务架构"></a>场景1：微服务架构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;order-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/orders/&#123;userId&#125;&quot;)</span></span><br><span class="line">    List&lt;Order&gt; <span class="title function_">getOrdersByUserId</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景2：数据访问层整合"><a href="#场景2：数据访问层整合" class="headerlink" title="场景2：数据访问层整合"></a>场景2：数据访问层整合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource.primary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProperties <span class="title function_">primaryDataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource.secondary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProperties <span class="title function_">secondaryDataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Spring-Boot面试问题"><a href="#2-5-Spring-Boot面试问题" class="headerlink" title="2.5 Spring Boot面试问题"></a>2.5 Spring Boot面试问题</h3><p><strong>Q1: Spring Boot的启动原理是什么？</strong></p>
<p>A: Spring Boot启动原理核心在于自动配置：</p>
<ol>
<li><strong>@SpringBootApplication</strong>组合了三个注解，其中@EnableAutoConfiguration是关键</li>
<li><strong>AutoConfigurationImportSelector</strong>会扫描所有引入的jar包，查找其META-INF&#x2F;spring.factories文件中org.springframework.boot.autoconfigure.EnableAutoConfiguration键所对应的配置类全限定名列表</li>
<li>根据条件注解判断哪些自动配置类生效</li>
<li>生效的配置类会向容器中注册相应的Bean</li>
</ol>
<p><strong>Q2: Spring Boot如何实现自动配置？</strong></p>
<p>A: 自动配置通过以下机制实现：</p>
<ol>
<li><strong>条件注解</strong>: @ConditionalOnClass、@ConditionalOnBean等判断配置是否生效</li>
<li><strong>配置文件</strong>: spring.factories定义自动配置类列表</li>
<li><strong>配置属性</strong>: @ConfigurationProperties绑定配置文件中的属性</li>
<li><strong>默认配置</strong>: 提供合理的默认值，用户可覆盖</li>
</ol>
<p><strong>Q3: Spring Boot Starter的工作原理？</strong></p>
<p>A: Starter是Spring Boot自动配置的载体：</p>
<ol>
<li><strong>依赖管理</strong>: 通过Maven&#x2F;Gradle引入相关依赖</li>
<li><strong>自动配置</strong>: 包含AutoConfiguration类</li>
<li><strong>属性绑定</strong>: 提供ConfigurationProperties类</li>
<li><strong>条件装配</strong>: 使用条件注解控制Bean的创建</li>
</ol>
<h2 id="三、Spring-MVC深入解析"><a href="#三、Spring-MVC深入解析" class="headerlink" title="三、Spring MVC深入解析"></a>三、Spring MVC深入解析</h2><h3 id="3-1-Spring-MVC核心组件"><a href="#3-1-Spring-MVC核心组件" class="headerlink" title="3.1 Spring MVC核心组件"></a>3.1 Spring MVC核心组件</h3><p><strong>DispatcherServlet处理流程：</strong></p>
<ol>
<li><strong>接收请求</strong>: DispatcherServlet接收HTTP请求</li>
<li><strong>查找Handler</strong>: HandlerMapping查找处理请求的Handler</li>
<li><strong>获取HandlerAdapter</strong>: 获取能够执行Handler的HandlerAdapter</li>
<li><strong>执行Handler</strong>: HandlerAdapter执行Handler（Controller方法）</li>
<li><strong>处理结果</strong>: 返回ModelAndView</li>
<li><strong>视图解析</strong>: ViewResolver解析视图名称</li>
<li><strong>渲染视图</strong>: View渲染模型数据</li>
<li><strong>返回响应</strong>: 响应结果返回给客户端</li>
</ol>
<p><strong>核心组件详解：</strong></p>
<ul>
<li><strong>DispatcherServlet</strong>: 前端控制器，统一处理请求</li>
<li><strong>HandlerMapping</strong>: 处理器映射器，URL与Handler的映射</li>
<li><strong>HandlerAdapter</strong>: 处理器适配器，执行Handler</li>
<li><strong>Handler</strong>: 处理器，即Controller</li>
<li><strong>ViewResolver</strong>: 视图解析器</li>
<li><strong>View</strong>: 视图</li>
</ul>
<h3 id="3-2-Spring-MVC核心注解"><a href="#3-2-Spring-MVC核心注解" class="headerlink" title="3.2 Spring MVC核心注解"></a>3.2 Spring MVC核心注解</h3><h4 id="控制器注解"><a href="#控制器注解" class="headerlink" title="控制器注解"></a>控制器注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>             <span class="comment">// 标记控制器类</span></span><br><span class="line"><span class="meta">@RestController</span>        <span class="comment">// RESTful控制器</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span> <span class="comment">// 请求映射</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span>   <span class="comment">// GET请求映射</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span>  <span class="comment">// POST请求映射</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/users/&#123;id&#125;&quot;)</span>    <span class="comment">// PUT请求映射</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;id&#125;&quot;)</span> <span class="comment">// DELETE请求映射</span></span><br><span class="line"><span class="meta">@PatchMapping(&quot;/users/&#123;id&#125;&quot;)</span>  <span class="comment">// PATCH请求映射</span></span><br></pre></td></tr></table></figure>

<h4 id="参数绑定注解"><a href="#参数绑定注解" class="headerlink" title="参数绑定注解"></a>参数绑定注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam(&quot;name&quot;)</span>           <span class="comment">// 请求参数</span></span><br><span class="line"><span class="meta">@PathVariable(&quot;id&quot;)</span>            <span class="comment">// 路径变量</span></span><br><span class="line"><span class="meta">@RequestBody</span>                   <span class="comment">// 请求体</span></span><br><span class="line"><span class="meta">@RequestHeader(&quot;Content-Type&quot;)</span> <span class="comment">// 请求头</span></span><br><span class="line"><span class="meta">@CookieValue(&quot;sessionId&quot;)</span>      <span class="comment">// Cookie值</span></span><br><span class="line"><span class="meta">@ModelAttribute</span>               <span class="comment">// 模型属性</span></span><br><span class="line"><span class="meta">@SessionAttribute</span>            <span class="comment">// Session属性</span></span><br><span class="line"><span class="meta">@RequestPart</span>                 <span class="comment">// 文件上传</span></span><br></pre></td></tr></table></figure>

<h4 id="响应处理注解"><a href="#响应处理注解" class="headerlink" title="响应处理注解"></a>响应处理注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>              <span class="comment">// 响应体</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.CREATED)</span> <span class="comment">// 响应状态码</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>         <span class="comment">// 异常处理</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>        <span class="comment">// 全局控制器增强</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span>    <span class="comment">// RESTful全局异常处理</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-Spring-MVC实际应用场景"><a href="#3-3-Spring-MVC实际应用场景" class="headerlink" title="3.3 Spring MVC实际应用场景"></a>3.3 Spring MVC实际应用场景</h3><h4 id="场景1：RESTful-API开发"><a href="#场景1：RESTful-API开发" class="headerlink" title="场景1：RESTful API开发"></a>场景1：RESTful API开发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;PageResult&lt;User&gt;&gt; <span class="title function_">getUsers</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class="type">int</span> page,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(required = false)</span> String keyword)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        PageResult&lt;User&gt; result = userService.findUsers(page, size, keyword);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserCreateRequest request)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.createUser(request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).body(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">updateUser</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@PathVariable</span> Long id,</span></span><br><span class="line"><span class="params">            <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserUpdateRequest request)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.updateUser(id, request);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        userService.deleteUser(id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景2：全局异常处理"><a href="#场景2：全局异常处理" class="headerlink" title="场景2：全局异常处理"></a>场景2：全局异常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(ValidationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleValidationException</span><span class="params">(ValidationException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorResponse.builder()</span><br><span class="line">                .code(<span class="string">&quot;VALIDATION_ERROR&quot;</span>)</span><br><span class="line">                .message(e.getMessage())</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(EntityNotFoundException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleEntityNotFoundException</span><span class="params">(EntityNotFoundException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorResponse.builder()</span><br><span class="line">                .code(<span class="string">&quot;ENTITY_NOT_FOUND&quot;</span>)</span><br><span class="line">                .message(e.getMessage())</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleGenericException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error occurred&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ErrorResponse.builder()</span><br><span class="line">                .code(<span class="string">&quot;INTERNAL_ERROR&quot;</span>)</span><br><span class="line">                .message(<span class="string">&quot;An unexpected error occurred&quot;</span>)</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景3：文件上传处理"><a href="#场景3：文件上传处理" class="headerlink" title="场景3：文件上传处理"></a>场景3：文件上传处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/files&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;FileUploadResponse&gt; <span class="title function_">uploadFile</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile file,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(required = false)</span> String description)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件类型验证</span></span><br><span class="line">        <span class="keyword">if</span> (!isValidFileType(file.getContentType())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidFileTypeException</span>(<span class="string">&quot;Invalid file type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件大小验证</span></span><br><span class="line">        <span class="keyword">if</span> (file.getSize() &gt; MAX_FILE_SIZE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileSizeExceededException</span>(<span class="string">&quot;File size exceeds limit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> fileService.saveFile(file, description);</span><br><span class="line">        </span><br><span class="line">        <span class="type">FileUploadResponse</span> <span class="variable">response</span> <span class="operator">=</span> FileUploadResponse.builder()</span><br><span class="line">                .fileName(fileName)</span><br><span class="line">                .originalName(file.getOriginalFilename())</span><br><span class="line">                .size(file.getSize())</span><br><span class="line">                .contentType(file.getContentType())</span><br><span class="line">                .uploadTime(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-Spring-MVC面试问题"><a href="#3-4-Spring-MVC面试问题" class="headerlink" title="3.4 Spring MVC面试问题"></a>3.4 Spring MVC面试问题</h3><p><strong>Q1: Spring MVC的执行流程是怎样的？</strong></p>
<p>A: Spring MVC的执行流程如下：</p>
<ol>
<li>用户发送请求到DispatcherServlet</li>
<li>DispatcherServlet调用HandlerMapping查找Handler</li>
<li>HandlerMapping返回HandlerExecutionChain（包含Handler和拦截器）</li>
<li>DispatcherServlet调用HandlerAdapter执行Handler</li>
<li>Handler执行完成后返回ModelAndView</li>
<li>DispatcherServlet调用ViewResolver解析视图名称</li>
<li>ViewResolver返回View对象</li>
<li>DispatcherServlet调用View的render方法渲染视图</li>
<li>响应结果返回给用户</li>
</ol>
<p><strong>Q2: Spring MVC中的拦截器是如何工作的？</strong></p>
<p>A: 拦截器基于AOP思想，在Handler执行前后进行处理：</p>
<ol>
<li><strong>HandlerInterceptor接口</strong>提供三个方法：<ul>
<li>preHandle(): 前置处理，返回false则中断请求</li>
<li>postHandle(): 后置处理，Handler执行后调用</li>
<li>afterCompletion(): 完成处理，视图渲染后调用</li>
</ul>
</li>
<li><strong>执行顺序</strong>：<ul>
<li>多个拦截器按配置顺序执行preHandle()</li>
<li>按相反顺序执行postHandle()和afterCompletion()</li>
</ul>
</li>
</ol>
<p><strong>Q3: @RequestBody和@ResponseBody的工作原理？</strong></p>
<p>A: 这两个注解基于HttpMessageConverter工作：</p>
<ol>
<li><strong>@RequestBody</strong>:<ul>
<li>使用HttpMessageConverter将HTTP请求体转换为Java对象</li>
<li>常用的转换器：MappingJackson2HttpMessageConverter处理JSON</li>
</ul>
</li>
<li><strong>@ResponseBody</strong>:<ul>
<li>使用HttpMessageConverter将Java对象转换为HTTP响应体</li>
<li>根据Accept头选择合适的转换器</li>
</ul>
</li>
</ol>
<h2 id="四、MyBatis深入解析"><a href="#四、MyBatis深入解析" class="headerlink" title="四、MyBatis深入解析"></a>四、MyBatis深入解析</h2><h3 id="4-1-MyBatis核心原理"><a href="#4-1-MyBatis核心原理" class="headerlink" title="4.1 MyBatis核心原理"></a>4.1 MyBatis核心原理</h3><p><strong>MyBatis架构分析：</strong> MyBatis采用分层架构设计：</p>
<ol>
<li><strong>API接口层</strong>: 提供给外部使用的接口API</li>
<li><strong>数据处理层</strong>: 参数映射、SQL解析、结果映射</li>
<li><strong>基础支撑层</strong>: 连接管理、事务管理、配置加载、缓存处理</li>
</ol>
<p><strong>MyBatis核心组件：</strong></p>
<ul>
<li><strong>SqlSessionFactory</strong>: 会话工厂，负责创建SqlSession</li>
<li><strong>SqlSession</strong>: 会话，执行SQL的核心接口</li>
<li><strong>Executor</strong>: 执行器，实际执行SQL</li>
<li><strong>StatementHandler</strong>: 语句处理器，处理SQL语句</li>
<li><strong>ParameterHandler</strong>: 参数处理器，处理SQL参数</li>
<li><strong>ResultSetHandler</strong>: 结果集处理器，处理查询结果</li>
<li><strong>MappedStatement</strong>: 映射语句，封装SQL配置信息</li>
</ul>
<h3 id="4-2-MyBatis执行流程详解"><a href="#4-2-MyBatis执行流程详解" class="headerlink" title="4.2 MyBatis执行流程详解"></a>4.2 MyBatis执行流程详解</h3><p><strong>SQL执行流程：</strong></p>
<ol>
<li><strong>解析配置</strong>: 解析mybatis-config.xml和Mapper XML文件</li>
<li><strong>创建会话</strong>: 通过SqlSessionFactory创建SqlSession</li>
<li><strong>获取Mapper</strong>: 通过动态代理创建Mapper接口实例</li>
<li><strong>执行SQL</strong>: 调用Mapper方法，转换为MappedStatement执行</li>
<li><strong>参数处理</strong>: ParameterHandler处理输入参数</li>
<li><strong>执行查询</strong>: StatementHandler执行SQL语句</li>
<li><strong>结果映射</strong>: ResultSetHandler处理结果集</li>
<li><strong>返回结果</strong>: 将结果返回给调用方</li>
</ol>
<p><strong>动态代理原理：</strong> MyBatis使用JDK动态代理为Mapper接口创建代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperProxy实现InvocationHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据方法签名找到对应的MappedStatement</span></span><br><span class="line">        <span class="comment">// 执行SQL并返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-MyBatis核心注解"><a href="#4-3-MyBatis核心注解" class="headerlink" title="4.3 MyBatis核心注解"></a>4.3 MyBatis核心注解</h3><h4 id="基础映射注解"><a href="#基础映射注解" class="headerlink" title="基础映射注解"></a>基础映射注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">findById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert(&quot;INSERT INTO users(name, email) VALUES(#&#123;name&#125;, #&#123;email&#125;)&quot;)</span></span><br><span class="line"><span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update(&quot;UPDATE users SET name = #&#123;name&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete(&quot;DELETE FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="高级映射注解"><a href="#高级映射注解" class="headerlink" title="高级映射注解"></a>高级映射注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果映射</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;user_id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;user_name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT user_id, user_name, create_time FROM users&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对一映射</span></span><br><span class="line"><span class="meta">@One(select = &quot;findUserById&quot;)</span></span><br><span class="line"><span class="meta">@Result(column = &quot;user_id&quot;, property = &quot;user&quot;)</span></span><br><span class="line">Order <span class="title function_">findOrderById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对多映射</span></span><br><span class="line"><span class="meta">@Many(select = &quot;findOrdersByUserId&quot;)</span></span><br><span class="line"><span class="meta">@Result(column = &quot;id&quot;, property = &quot;orders&quot;)</span></span><br><span class="line">User <span class="title function_">findUserWithOrders</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="动态SQL注解"><a href="#动态SQL注解" class="headerlink" title="动态SQL注解"></a>动态SQL注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;findUsers&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsers</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUsers</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (params.get(<span class="string">&quot;name&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;name LIKE CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (params.get(<span class="string">&quot;email&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;email = #&#123;email&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-MyBatis缓存机制"><a href="#4-4-MyBatis缓存机制" class="headerlink" title="4.4 MyBatis缓存机制"></a>4.4 MyBatis缓存机制</h3><p><strong>一级缓存（默认开启）：</strong></p>
<ul>
<li>作用域：SqlSession级别</li>
<li>生命周期：与SqlSession相同</li>
<li>存储：HashMap结构，key为CacheKey</li>
</ul>
<p><strong>二级缓存（需要配置）：</strong></p>
<ul>
<li>作用域：Mapper级别</li>
<li>生命周期：与应用程序相同</li>
<li>配置：@CacheNamespace注解或<cache>标签</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace(</span></span><br><span class="line"><span class="meta">    eviction = LRU.class,</span></span><br><span class="line"><span class="meta">    flushInterval = 60000,</span></span><br><span class="line"><span class="meta">    size = 1024,</span></span><br><span class="line"><span class="meta">    readWrite = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">// mapper methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-MyBatis实际应用场景"><a href="#4-5-MyBatis实际应用场景" class="headerlink" title="4.5 MyBatis实际应用场景"></a>4.5 MyBatis实际应用场景</h3><h4 id="场景1：复杂查询场景"><a href="#场景1：复杂查询场景" class="headerlink" title="场景1：复杂查询场景"></a>场景1：复杂查询场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分页查询订单</span></span><br><span class="line">    <span class="meta">@Select(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        SELECT o.*, u.name as user_name, u.email as user_email</span></span><br><span class="line"><span class="meta">        FROM orders o</span></span><br><span class="line"><span class="meta">        LEFT JOIN users u ON o.user_id = u.id</span></span><br><span class="line"><span class="meta">        WHERE o.status = #&#123;status&#125;</span></span><br><span class="line"><span class="meta">        AND o.create_time BETWEEN #&#123;startTime&#125; AND #&#123;endTime&#125;</span></span><br><span class="line"><span class="meta">        ORDER BY o.create_time DESC</span></span><br><span class="line"><span class="meta">        LIMIT #&#123;offset&#125;, #&#123;limit&#125;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;user_id&quot;, property = &quot;userId&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;user_name&quot;, property = &quot;user.name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;user_email&quot;, property = &quot;user.email&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    List&lt;OrderVO&gt; <span class="title function_">findOrdersWithUser</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;status&quot;)</span> String status,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;startTime&quot;)</span> LocalDateTime startTime,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;endTime&quot;)</span> LocalDateTime endTime,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计查询</span></span><br><span class="line">    <span class="meta">@Select(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        SELECT </span></span><br><span class="line"><span class="meta">            COUNT(*) as total_count,</span></span><br><span class="line"><span class="meta">            SUM(amount) as total_amount,</span></span><br><span class="line"><span class="meta">            AVG(amount) as avg_amount</span></span><br><span class="line"><span class="meta">        FROM orders </span></span><br><span class="line"><span class="meta">        WHERE status = #&#123;status&#125;</span></span><br><span class="line"><span class="meta">        AND create_time &gt;= #&#123;startTime&#125;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    OrderStatistics <span class="title function_">getOrderStatistics</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;status&quot;)</span> String status,</span></span><br><span class="line"><span class="params">        <span class="meta">@Param(&quot;startTime&quot;)</span> LocalDateTime startTime</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景2：批量操作场景"><a href="#场景2：批量操作场景" class="headerlink" title="场景2：批量操作场景"></a>场景2：批量操作场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BatchMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 批量插入</span></span><br><span class="line">    <span class="meta">@Insert(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        &lt;script&gt;</span></span><br><span class="line"><span class="meta">        INSERT INTO users (name, email, create_time) VALUES</span></span><br><span class="line"><span class="meta">        &lt;foreach collection=&quot;users&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="meta">            (#&#123;user.name&#125;, #&#123;user.email&#125;, #&#123;user.createTime&#125;)</span></span><br><span class="line"><span class="meta">        &lt;/foreach&gt;</span></span><br><span class="line"><span class="meta">        &lt;/script&gt;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">batchInsertUsers</span><span class="params">(<span class="meta">@Param(&quot;users&quot;)</span> List&lt;User&gt; users)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 批量更新</span></span><br><span class="line">    <span class="meta">@Update(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">        &lt;script&gt;</span></span><br><span class="line"><span class="meta">        &lt;foreach collection=&quot;users&quot; item=&quot;user&quot; separator=&quot;;&quot;&gt;</span></span><br><span class="line"><span class="meta">            UPDATE users SET </span></span><br><span class="line"><span class="meta">                name = #&#123;user.name&#125;,</span></span><br><span class="line"><span class="meta">                email = #&#123;user.email&#125;,</span></span><br><span class="line"><span class="meta">                update_time = NOW()</span></span><br><span class="line"><span class="meta">            WHERE id = #&#123;user.id&#125;</span></span><br><span class="line"><span class="meta">        &lt;/foreach&gt;</span></span><br><span class="line"><span class="meta">        &lt;/script&gt;</span></span><br><span class="line"><span class="meta">    &quot;&quot;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">batchUpdateUsers</span><span class="params">(<span class="meta">@Param(&quot;users&quot;)</span> List&lt;User&gt; users)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景3：动态SQL场景"><a href="#场景3：动态SQL场景" class="headerlink" title="场景3：动态SQL场景"></a>场景3：动态SQL场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;searchUsers&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">searchUsers</span><span class="params">(UserSearchCriteria criteria)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">searchUsers</span><span class="params">(UserSearchCriteria criteria)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;u.*, p.name as profile_name&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;users u&quot;</span>);</span><br><span class="line">            LEFT_OUTER_JOIN(<span class="string">&quot;user_profiles p ON u.id = p.user_id&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(criteria.getName())) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.name LIKE CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(criteria.getEmail())) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.email = #&#123;email&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getMinAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.age &gt;= #&#123;minAge&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getMaxAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.age &lt;= #&#123;maxAge&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getCreateTimeStart() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.create_time &gt;= #&#123;createTimeStart&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (criteria.getCreateTimeEnd() != <span class="literal">null</span>) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.create_time &lt;= #&#123;createTimeEnd&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(criteria.getStatuses())) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;u.status IN (&quot;</span> + </span><br><span class="line">                    criteria.getStatuses().stream()</span><br><span class="line">                        .map(s -&gt; <span class="string">&quot;&#x27;&quot;</span> + s + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">                        .collect(Collectors.joining(<span class="string">&quot;,&quot;</span>)) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 排序</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(criteria.getSortField())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;desc&quot;</span>.equalsIgnoreCase(criteria.getSortDirection())) &#123;</span><br><span class="line">                    ORDER_BY(<span class="string">&quot;u.&quot;</span> + criteria.getSortField() + <span class="string">&quot; DESC&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ORDER_BY(<span class="string">&quot;u.&quot;</span> + criteria.getSortField() + <span class="string">&quot; ASC&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ORDER_BY(<span class="string">&quot;u.create_time DESC&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-MyBatis性能优化"><a href="#4-6-MyBatis性能优化" class="headerlink" title="4.6 MyBatis性能优化"></a>4.6 MyBatis性能优化</h3><h4 id="优化策略1：合理使用缓存"><a href="#优化策略1：合理使用缓存" class="headerlink" title="优化策略1：合理使用缓存"></a>优化策略1：合理使用缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启二级缓存，设置合理的缓存策略</span></span><br><span class="line"><span class="meta">@CacheNamespace(</span></span><br><span class="line"><span class="meta">    eviction = LRU.class,        // 缓存回收策略</span></span><br><span class="line"><span class="meta">    flushInterval = 300000,      // 缓存刷新间隔（5分钟）</span></span><br><span class="line"><span class="meta">    size = 1024,                 // 缓存大小</span></span><br><span class="line"><span class="meta">    readWrite = true,            // 读写缓存</span></span><br><span class="line"><span class="meta">    blocking = false             // 非阻塞缓存</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于频繁查询且变化不大的数据使用缓存</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM products WHERE category_id = #&#123;categoryId&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useCache = true)</span></span><br><span class="line">    List&lt;Product&gt; <span class="title function_">findByCategory</span><span class="params">(<span class="meta">@Param(&quot;categoryId&quot;)</span> Long categoryId)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于实时性要求高的数据禁用缓存</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM products WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useCache = false)</span></span><br><span class="line">    Product <span class="title function_">findRealTimeById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化策略2：批量操作"><a href="#优化策略2：批量操作" class="headerlink" title="优化策略2：批量操作"></a>优化策略2：批量操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用批量插入替代循环插入</span></span><br><span class="line"><span class="meta">@Insert(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    &lt;script&gt;</span></span><br><span class="line"><span class="meta">    INSERT INTO order_items (order_id, product_id, quantity, price) VALUES</span></span><br><span class="line"><span class="meta">    &lt;foreach collection=&quot;items&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="meta">        (#&#123;item.orderId&#125;, #&#123;item.productId&#125;, #&#123;item.quantity&#125;, #&#123;item.price&#125;)</span></span><br><span class="line"><span class="meta">    &lt;/foreach&gt;</span></span><br><span class="line"><span class="meta">    &lt;/script&gt;</span></span><br><span class="line"><span class="meta">&quot;&quot;&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">batchInsertOrderItems</span><span class="params">(<span class="meta">@Param(&quot;items&quot;)</span> List&lt;OrderItem&gt; items)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量更新优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdateProducts</span><span class="params">(List&lt;Product&gt; products)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH)) &#123;</span><br><span class="line">        <span class="type">ProductMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ProductMapper.class);</span><br><span class="line">        <span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">            mapper.updateProduct(product);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化策略3：延迟加载"><a href="#优化策略3：延迟加载" class="headerlink" title="优化策略3：延迟加载"></a>优化策略3：延迟加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResultMap(&quot;userResultMap&quot;)</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">findUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在ResultMap中配置延迟加载</span></span><br><span class="line">&lt;resultMap id=<span class="string">&quot;userResultMap&quot;</span> type=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span>/&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;name&quot;</span> property=<span class="string">&quot;name&quot;</span>/&gt;</span><br><span class="line">    &lt;collection property=<span class="string">&quot;orders&quot;</span> </span><br><span class="line">                select=<span class="string">&quot;findOrdersByUserId&quot;</span> </span><br><span class="line">                column=<span class="string">&quot;id&quot;</span> </span><br><span class="line">                fetchType=<span class="string">&quot;lazy&quot;</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-MyBatis常见问题与解决方案"><a href="#4-7-MyBatis常见问题与解决方案" class="headerlink" title="4.7 MyBatis常见问题与解决方案"></a>4.7 MyBatis常见问题与解决方案</h3><h4 id="问题1：N-1查询问题"><a href="#问题1：N-1查询问题" class="headerlink" title="问题1：N+1查询问题"></a>问题1：N+1查询问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题：会产生N+1次查询</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findAllUsers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM orders WHERE user_id = #&#123;userId&#125;&quot;)</span></span><br><span class="line">List&lt;Order&gt; <span class="title function_">findOrdersByUserId</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案1：使用联表查询</span></span><br><span class="line"><span class="meta">@Select(&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    SELECT u.*, o.id as order_id, o.amount, o.status as order_status</span></span><br><span class="line"><span class="meta">    FROM users u</span></span><br><span class="line"><span class="meta">    LEFT JOIN orders o ON u.id = o.user_id</span></span><br><span class="line"><span class="meta">&quot;&quot;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;order_id&quot;, property = &quot;orders.id&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;amount&quot;, property = &quot;orders.amount&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;order_status&quot;, property = &quot;orders.status&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersWithOrders</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案2：使用批量查询</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUsersWithOrdersOptimized</span><span class="params">(List&lt;Long&gt; userIds)</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.findUsersByIds(userIds);</span><br><span class="line">    <span class="keyword">if</span> (!users.isEmpty()) &#123;</span><br><span class="line">        List&lt;Long&gt; ids = users.stream().map(User::getId).collect(Collectors.toList());</span><br><span class="line">        List&lt;Order&gt; orders = orderMapper.findOrdersByUserIds(ids);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手动组装数据</span></span><br><span class="line">        Map&lt;Long, List&lt;Order&gt;&gt; orderMap = orders.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Order::getUserId));</span><br><span class="line">        </span><br><span class="line">        users.forEach(user -&gt; user.setOrders(orderMap.get(user.getId())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题2：大数据量查询内存溢出"><a href="#问题2：大数据量查询内存溢出" class="headerlink" title="问题2：大数据量查询内存溢出"></a>问题2：大数据量查询内存溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题：一次性加载大量数据导致内存溢出</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM large_table&quot;)</span></span><br><span class="line">List&lt;LargeData&gt; <span class="title function_">findAllData</span><span class="params">()</span>; <span class="comment">// 可能导致OOM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案1：分页查询</span></span><br><span class="line"><span class="keyword">public</span> List&lt;LargeData&gt; <span class="title function_">findAllDataWithPaging</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;LargeData&gt; allData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;LargeData&gt; pageData;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        pageData = mapper.findDataWithLimit(offset, pageSize);</span><br><span class="line">        allData.addAll(pageData);</span><br><span class="line">        offset += pageSize;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pageData.size() == pageSize);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> allData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案2：使用游标查询</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM large_table WHERE process_status = &#x27;PENDING&#x27;&quot;)</span></span><br><span class="line"><span class="meta">@Options(resultSetType = ResultSetType.FORWARD_ONLY, fetchSize = 1000)</span></span><br><span class="line">Cursor&lt;LargeData&gt; <span class="title function_">findPendingDataCursor</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processLargeData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (Cursor&lt;LargeData&gt; cursor = mapper.findPendingDataCursor()) &#123;</span><br><span class="line">        cursor.forEach(<span class="built_in">this</span>::processData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题3：SQL注入防护"><a href="#问题3：SQL注入防护" class="headerlink" title="问题3：SQL注入防护"></a>问题3：SQL注入防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险：直接拼接SQL，容易SQL注入</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = &#x27;$&#123;name&#125;&#x27;&quot;)</span> <span class="comment">// 错误示例</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByNameUnsafe</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全：使用参数绑定</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = #&#123;name&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByNameSafe</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态排序的安全处理</span></span><br><span class="line"><span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;findUsersWithSort&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersWithSort</span><span class="params">(<span class="meta">@Param(&quot;sortField&quot;)</span> String sortField, </span></span><br><span class="line"><span class="params">                            <span class="meta">@Param(&quot;sortDirection&quot;)</span> String sortDirection)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; ALLOWED_SORT_FIELDS = </span><br><span class="line">        Set.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;create_time&quot;</span>, <span class="string">&quot;update_time&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUsersWithSort</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sortField</span> <span class="operator">=</span> (String) params.get(<span class="string">&quot;sortField&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sortDirection</span> <span class="operator">=</span> (String) params.get(<span class="string">&quot;sortDirection&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 白名单验证</span></span><br><span class="line">        <span class="keyword">if</span> (!ALLOWED_SORT_FIELDS.contains(sortField)) &#123;</span><br><span class="line">            sortField = <span class="string">&quot;id&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;DESC&quot;</span>.equalsIgnoreCase(sortDirection)) &#123;</span><br><span class="line">            sortDirection = <span class="string">&quot;ASC&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SELECT * FROM users ORDER BY &quot;</span> + sortField + <span class="string">&quot; &quot;</span> + sortDirection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-MyBatis面试高频问题"><a href="#4-8-MyBatis面试高频问题" class="headerlink" title="4.8 MyBatis面试高频问题"></a>4.8 MyBatis面试高频问题</h3><p><strong>Q1: MyBatis的执行流程是怎样的？</strong></p>
<p>A: MyBatis的执行流程包括以下步骤：</p>
<ol>
<li><strong>配置解析</strong>: 解析mybatis-config.xml配置文件和Mapper XML文件，创建Configuration对象</li>
<li><strong>SqlSessionFactory创建</strong>: 根据Configuration创建SqlSessionFactory</li>
<li><strong>SqlSession创建</strong>: 通过SqlSessionFactory.openSession()创建SqlSession</li>
<li><strong>Mapper获取</strong>: 通过SqlSession.getMapper()获取Mapper接口的代理对象</li>
<li><strong>方法调用</strong>: 调用Mapper接口方法，通过动态代理转换为SQL执行</li>
<li><strong>SQL执行</strong>: 通过Executor执行SQL，包括参数处理、语句执行、结果映射</li>
<li><strong>结果返回</strong>: 将执行结果返回给调用方</li>
</ol>
<p><strong>Q2: MyBatis的一级缓存和二级缓存有什么区别？</strong></p>
<p>A: 两级缓存的主要区别：</p>
<p><strong>一级缓存（默认开启）：</strong></p>
<ul>
<li>作用域：SqlSession级别</li>
<li>生命周期：与SqlSession相同，SqlSession关闭时缓存清空</li>
<li>存储结构：HashMap，key为CacheKey（由SQL、参数、分页等组成）</li>
<li>失效条件：执行update、insert、delete操作或手动清空</li>
</ul>
<p><strong>二级缓存（需要配置）：</strong></p>
<ul>
<li>作用域：Mapper级别，多个SqlSession可以共享</li>
<li>生命周期：与应用程序相同</li>
<li>存储结构：可配置（HashMap、LRU、FIFO等）</li>
<li>配置方式：@CacheNamespace注解或<cache>标签</li>
<li>注意事项：需要序列化，可能存在脏读问题</li>
</ul>
<p><strong>Q3: MyBatis如何防止SQL注入？</strong></p>
<p>A: MyBatis通过以下方式防止SQL注入：</p>
<ol>
<li><strong>参数绑定</strong>: 使用#{}而不是${}<ul>
<li>#{}：预编译处理，参数作为占位符传递</li>
<li>${}：字符串替换，直接拼接到SQL中（危险）</li>
</ul>
</li>
<li><strong>类型检查</strong>: MyBatis会对参数类型进行检查</li>
<li><strong>白名单验证</strong>: 对于动态排序等场景，使用白名单验证</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全的写法</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = #&#123;name&#125; AND age &gt; #&#123;age&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsers</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险的写法（避免使用）</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users WHERE name = &#x27;$&#123;name&#125;&#x27;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersUnsafe</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Q4: MyBatis中#{}和${}的区别？</strong></p>
<p>A: 两者的主要区别：</p>
<p><strong>#{}（推荐使用）：</strong></p>
<ul>
<li>预编译处理，生成PreparedStatement</li>
<li>参数会被处理为占位符?</li>
<li>可以防止SQL注入</li>
<li>会进行类型转换</li>
<li>适用于参数值传递</li>
</ul>
<p><strong>${}（谨慎使用）：</strong></p>
<ul>
<li>字符串替换，直接拼接到SQL中</li>
<li>不会进行预编译</li>
<li>存在SQL注入风险</li>
<li>不会进行类型转换</li>
<li>适用于动态表名、列名等场景</li>
</ul>
<p><strong>Q5: MyBatis的动态SQL是如何实现的？</strong></p>
<p>A: MyBatis的动态SQL通过以下标签实现：</p>
<ol>
<li><strong>if标签</strong>: 条件判断</li>
<li><strong>choose&#x2F;when&#x2F;otherwise</strong>: 类似switch-case</li>
<li><strong>where标签</strong>: 智能处理WHERE条件</li>
<li><strong>set标签</strong>: 智能处理SET语句</li>
<li><strong>foreach标签</strong>: 循环处理</li>
<li><strong>trim标签</strong>: 去除多余的字符</li>
</ol>
<p>实现原理：</p>
<ul>
<li>使用OGNL表达式进行条件判断</li>
<li>在SQL解析阶段根据参数值动态生成SQL</li>
<li>通过SqlNode树结构表示动态SQL</li>
<li>在执行时遍历SqlNode树生成最终SQL</li>
</ul>
<h2 id="五、框架整合与最佳实践"><a href="#五、框架整合与最佳实践" class="headerlink" title="五、框架整合与最佳实践"></a>五、框架整合与最佳实践</h2><h3 id="5-1-Spring-Boot-MyBatis整合"><a href="#5-1-Spring-Boot-MyBatis整合" class="headerlink" title="5.1 Spring Boot + MyBatis整合"></a>5.1 Spring Boot + MyBatis整合</h3><h4 id="完整配置示例"><a href="#完整配置示例" class="headerlink" title="完整配置示例"></a>完整配置示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主启动类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据源配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource.primary&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProperties <span class="title function_">primaryDataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">primaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> primaryDataSourceProperties()</span><br><span class="line">                .initializeDataSourceBuilder()</span><br><span class="line">                .type(HikariDataSource.class)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        factory.setDataSource(dataSource);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// MyBatis配置</span></span><br><span class="line">        org.apache.ibatis.session.<span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">org</span>.apache.ibatis.session.Configuration();</span><br><span class="line">        config.setMapUnderscoreToCamelCase(<span class="literal">true</span>);</span><br><span class="line">        config.setLogImpl(Slf4jImpl.class);</span><br><span class="line">        config.setCacheEnabled(<span class="literal">true</span>);</span><br><span class="line">        config.setLazyLoadingEnabled(<span class="literal">true</span>);</span><br><span class="line">        config.setAggressiveLazyLoading(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        factory.setConfiguration(config);</span><br><span class="line">        <span class="keyword">return</span> factory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事务管理配置"><a href="#事务管理配置" class="headerlink" title="事务管理配置"></a>事务管理配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderItemMapper orderItemMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductMapper productMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">createOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setUserId(request.getUserId());</span><br><span class="line">        order.setStatus(<span class="string">&quot;PENDING&quot;</span>);</span><br><span class="line">        order.setCreateTime(LocalDateTime.now());</span><br><span class="line">        orderMapper.insert(order);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建订单项</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">totalAmount</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">        List&lt;OrderItem&gt; orderItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (CreateOrderItemRequest itemRequest : request.getItems()) &#123;</span><br><span class="line">            <span class="comment">// 检查库存</span></span><br><span class="line">            <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productMapper.findById(itemRequest.getProductId());</span><br><span class="line">            <span class="keyword">if</span> (product == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ProductNotFoundException</span>(<span class="string">&quot;Product not found: &quot;</span> + itemRequest.getProductId());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (product.getStock() &lt; itemRequest.getQuantity()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientStockException</span>(<span class="string">&quot;Insufficient stock for product: &quot;</span> + product.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 减库存</span></span><br><span class="line">            productMapper.decreaseStock(itemRequest.getProductId(), itemRequest.getQuantity());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建订单项</span></span><br><span class="line">            <span class="type">OrderItem</span> <span class="variable">orderItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderItem</span>();</span><br><span class="line">            orderItem.setOrderId(order.getId());</span><br><span class="line">            orderItem.setProductId(itemRequest.getProductId());</span><br><span class="line">            orderItem.setQuantity(itemRequest.getQuantity());</span><br><span class="line">            orderItem.setPrice(product.getPrice());</span><br><span class="line">            orderItems.add(orderItem);</span><br><span class="line">            </span><br><span class="line">            totalAmount = totalAmount.add(</span><br><span class="line">                product.getPrice().multiply(BigDecimal.valueOf(itemRequest.getQuantity()))</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 批量插入订单项</span></span><br><span class="line">        <span class="keyword">if</span> (!orderItems.isEmpty()) &#123;</span><br><span class="line">            orderItemMapper.batchInsert(orderItems);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 更新订单总金额</span></span><br><span class="line">        order.setTotalAmount(totalAmount);</span><br><span class="line">        orderMapper.updateAmount(order.getId(), totalAmount);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> OrderDetailVO <span class="title function_">getOrderDetail</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">        <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderNotFoundException</span>(<span class="string">&quot;Order not found: &quot;</span> + orderId);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;OrderItem&gt; orderItems = orderItemMapper.findByOrderId(orderId);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> OrderDetailVO.builder()</span><br><span class="line">                .order(order)</span><br><span class="line">                .items(orderItems)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-统一异常处理"><a href="#5-2-统一异常处理" class="headerlink" title="5.2 统一异常处理"></a>5.2 统一异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(ValidationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleValidationException</span><span class="params">(ValidationException e)</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Validation error: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;VALIDATION_ERROR&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleMethodArgumentNotValid</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        List&lt;String&gt; errors = e.getBindingResult()</span><br><span class="line">                .getFieldErrors()</span><br><span class="line">                .stream()</span><br><span class="line">                .map(error -&gt; error.getField() + <span class="string">&quot;: &quot;</span> + error.getDefaultMessage())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;VALIDATION_ERROR&quot;</span>, String.join(<span class="string">&quot;, &quot;</span>, errors));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(DataIntegrityViolationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CONFLICT)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleDataIntegrityViolation</span><span class="params">(DataIntegrityViolationException e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Data integrity violation&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;DATA_CONFLICT&quot;</span>, <span class="string">&quot;Data conflict occurred&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(OptimisticLockingFailureException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CONFLICT)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleOptimisticLockingFailure</span><span class="params">(OptimisticLockingFailureException e)</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Optimistic locking failure: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;OPTIMISTIC_LOCK_ERROR&quot;</span>, <span class="string">&quot;Resource has been modified by another user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">handleGenericException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error occurred&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;INTERNAL_ERROR&quot;</span>, <span class="string">&quot;An unexpected error occurred&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-接口文档与验证"><a href="#5-3-接口文档与验证" class="headerlink" title="5.3 接口文档与验证"></a>5.3 接口文档与验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统一响应格式</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiResponse</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> success;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Long timestamp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResponse&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.&lt;T&gt;builder()</span><br><span class="line">                .success(<span class="literal">true</span>)</span><br><span class="line">                .code(<span class="string">&quot;SUCCESS&quot;</span>)</span><br><span class="line">                .data(data)</span><br><span class="line">                .timestamp(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResponse&lt;T&gt; <span class="title function_">error</span><span class="params">(String code, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.&lt;T&gt;builder()</span><br><span class="line">                .success(<span class="literal">false</span>)</span><br><span class="line">                .code(code)</span><br><span class="line">                .message(message)</span><br><span class="line">                .timestamp(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求参数验证</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Valid</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateUserRequest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 2, max = 20, message = &quot;用户名长度必须在2-20个字符之间&quot;)</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^[a-zA-Z0-9_\\u4e00-\\u9fa5]+$&quot;, message = &quot;用户名只能包含字母、数字、下划线和中文&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;邮箱不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 8, max = 20, message = &quot;密码长度必须在8-20个字符之间&quot;)</span></span><br><span class="line">    <span class="meta">@Pattern(</span></span><br><span class="line"><span class="meta">        regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]+$&quot;,</span></span><br><span class="line"><span class="meta">        message = &quot;密码必须包含大小写字母、数字和特殊字符&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull(message = &quot;年龄不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 1, message = &quot;年龄必须大于0&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 150, message = &quot;年龄不能超过150&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;角色不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="meta">@NotBlank(message = &quot;角色名称不能为空&quot;)</span> String&gt; roles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-性能监控与优化"><a href="#5-4-性能监控与优化" class="headerlink" title="5.4 性能监控与优化"></a>5.4 性能监控与优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能监控切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerformanceMonitorAspect</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(org.springframework.web.bind.annotation.RequestMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.GetMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.PostMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.PutMapping) || &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(org.springframework.web.bind.annotation.DeleteMapping)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">monitorPerformance</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().toShortString();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">long</span> <span class="variable">executionTime</span> <span class="operator">=</span> endTime - startTime;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (executionTime &gt; <span class="number">1000</span>) &#123; <span class="comment">// 超过1秒记录警告</span></span><br><span class="line">                log.warn(<span class="string">&quot;Slow API detected: &#123;&#125; took &#123;&#125;ms&quot;</span>, methodName, executionTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;API performance: &#123;&#125; took &#123;&#125;ms&quot;</span>, methodName, executionTime);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            log.error(<span class="string">&quot;API error: &#123;&#125; took &#123;&#125;ms, error: &#123;&#125;&quot;</span>, </span><br><span class="line">                     methodName, endTime - startTime, e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库连接池监控</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceHealthIndicator</span> <span class="keyword">implements</span> <span class="title class_">HealthIndicator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Health <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> HikariDataSource) &#123;</span><br><span class="line">                <span class="type">HikariDataSource</span> <span class="variable">hikariDataSource</span> <span class="operator">=</span> (HikariDataSource) dataSource;</span><br><span class="line">                <span class="type">HikariPoolMXBean</span> <span class="variable">poolBean</span> <span class="operator">=</span> hikariDataSource.getHikariPoolMXBean();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> Health.up()</span><br><span class="line">                        .withDetail(<span class="string">&quot;database&quot;</span>, <span class="string">&quot;MySQL&quot;</span>)</span><br><span class="line">                        .withDetail(<span class="string">&quot;activeConnections&quot;</span>, poolBean.getActiveConnections())</span><br><span class="line">                        .withDetail(<span class="string">&quot;idleConnections&quot;</span>, poolBean.getIdleConnections())</span><br><span class="line">                        .withDetail(<span class="string">&quot;totalConnections&quot;</span>, poolBean.getTotalConnections())</span><br><span class="line">                        .withDetail(<span class="string">&quot;threadsAwaitingConnection&quot;</span>, poolBean.getThreadsAwaitingConnection())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection()) &#123;</span><br><span class="line">                <span class="keyword">return</span> Health.up()</span><br><span class="line">                        .withDetail(<span class="string">&quot;database&quot;</span>, connection.getMetaData().getDatabaseProductName())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down()</span><br><span class="line">                    .withDetail(<span class="string">&quot;error&quot;</span>, e.getMessage())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-高频面试综合题"><a href="#5-5-高频面试综合题" class="headerlink" title="5.5 高频面试综合题"></a>5.5 高频面试综合题</h3><p><strong>Q1: 在微服务架构中，如何设计一个高并发的订单系统？</strong></p>
<p>A: 设计高并发订单系统需要考虑以下几个方面：</p>
<p><strong>1. 架构设计：</strong></p>
<ul>
<li>使用分布式架构，订单服务、库存服务、支付服务分离</li>
<li>引入消息队列处理异步任务</li>
<li>使用Redis做缓存和分布式锁</li>
<li>数据库读写分离，分库分表</li>
</ul>
<p><strong>2. 并发控制：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">createOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;order:lock:&quot;</span> + request.getUserId();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分布式锁防止重复下单</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">locked</span> <span class="operator">=</span> redisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(lockKey, <span class="string">&quot;1&quot;</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderCreationException</span>(<span class="string">&quot;Order creation in progress&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 订单创建逻辑</span></span><br><span class="line">            <span class="keyword">return</span> processOrder(request);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redisTemplate.delete(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 性能优化：</strong></p>
<ul>
<li>使用批量操作减少数据库交互</li>
<li>合理使用缓存策略</li>
<li>异步处理非核心业务逻辑</li>
<li>数据库连接池优化</li>
</ul>
<p><strong>Q2: 如何处理分布式事务？</strong></p>
<p>A: 分布式事务处理方案：</p>
<p><strong>1. 2PC&#x2F;3PC协议：</strong></p>
<ul>
<li>强一致性，但性能较差</li>
<li>适用于对一致性要求极高的场景</li>
</ul>
<p><strong>2. TCC模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TccTransaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTccService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryCreateOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// Try阶段：预留资源</span></span><br><span class="line">        orderService.reserveOrder(request);</span><br><span class="line">        stockService.reserveStock(request.getItems());</span><br><span class="line">        paymentService.reservePayment(request.getPaymentInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirmCreateOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// Confirm阶段：确认操作</span></span><br><span class="line">        orderService.confirmOrder(request);</span><br><span class="line">        stockService.confirmStock(request.getItems());</span><br><span class="line">        paymentService.confirmPayment(request.getPaymentInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancelCreateOrder</span><span class="params">(CreateOrderRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// Cancel阶段：回滚操作</span></span><br><span class="line">        orderService.cancelOrder(request);</span><br><span class="line">        stockService.cancelStock(request.getItems());</span><br><span class="line">        paymentService.cancelPayment(request.getPaymentInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 消息队列最终一致性：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEventService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleOrderCreated</span><span class="params">(OrderCreatedEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 异步处理订单相关业务</span></span><br><span class="line">        notificationService.sendOrderNotification(event.getOrder());</span><br><span class="line">        inventoryService.updateInventory(event.getOrderItems());</span><br><span class="line">        pointsService.addPoints(event.getUserId(), event.getAmount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Q3: Spring Boot应用如何优化启动速度？</strong></p>
<p>A: Spring Boot启动优化策略：</p>
<p><strong>1. 依赖优化：</strong></p>
<ul>
<li>移除不必要的依赖</li>
<li>使用spring-boot-starter-web替代完整的spring-web</li>
<li>避免引入大量自动配置类</li>
</ul>
<p><strong>2. 配置优化：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">lazy-initialization:</span> <span class="literal">true</span>  <span class="comment"># 启用懒加载</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">none</span>           <span class="comment"># 禁用DDL自动生成</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">false</span>            <span class="comment"># 禁用SQL日志</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span>           <span class="comment"># 生产环境禁用热重启</span></span><br></pre></td></tr></table></figure>

<p><strong>3. JVM优化：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockExperimentalVMOptions </span><br><span class="line">     -XX:+UseZGC </span><br><span class="line">     -XX:+UseTransparentHugePages</span><br><span class="line">     -XX:MaxMetaspaceSize=256m</span><br><span class="line">     -Xms512m -Xmx1024m</span><br><span class="line">     -jar application.jar</span><br></pre></td></tr></table></figure>

<p><strong>4. 代码优化：</strong></p>
<ul>
<li>使用@Lazy注解延迟Bean初始化</li>
<li>避免在@PostConstruct中执行耗时操作</li>
<li>合理使用@ConditionalOn*注解</li>
</ul>
<p>好的，这是一份详细的解释，我们来逐个分析这些 Java 虚拟机（JVM）参数：</p>
<p>Bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -XX:+UseTransparentHugePages -XX:MaxMetaspaceSize=256m -Xms512m -Xmx1024m -jar application.jar</span><br></pre></td></tr></table></figure>

<ul>
<li><code>java</code>: 这是启动 Java 程序的命令。</li>
</ul>
<hr>
<h3 id="内存管理和垃圾回收"><a href="#内存管理和垃圾回收" class="headerlink" title="内存管理和垃圾回收"></a>内存管理和垃圾回收</h3><p>这部分参数主要用于优化 JVM 的内存使用和垃圾回收机制，以获得更好的性能。</p>
<ul>
<li><code>-XX:+UnlockExperimentalVMOptions</code>: 这个参数是用来<strong>解锁实验性（experimental）的 JVM 选项</strong>。ZGC 曾经是实验性功能，所以需要这个参数才能使用。</li>
<li><code>-XX:+UseZGC</code>: 这条命令是启用 <strong>Z 垃圾回收器（Z Garbage Collector）</strong>。ZGC 是一种为<strong>超大堆内存</strong>（从几GB到几十TB）设计的、<strong>低延迟</strong>的垃圾回收器。它的主要目标是在垃圾回收时，尽量减少应用程序的停顿时间，这对于需要极低延迟的应用程序非常重要。</li>
<li><code>-XX:+UseTransparentHugePages</code>: 这个参数开启了<strong>透明大页（Transparent Huge Pages）的支持。在操作系统层面，通常内存是以 4KB 的小页来管理的。而大页（通常是 2MB 或 1GB）可以减少 CPU 在内存管理上的开销，从而提升性能，尤其对于内存占用较大</strong>的应用效果更明显。</li>
<li><code>-XX:MaxMetaspaceSize=256m</code>: 这个参数设置了<strong>元空间（Metaspace）的最大大小为 256MB</strong>。元空间是 JVM 存储类的元数据（如类的名称、方法、字段等信息）的地方。在 Java 8 之后，它取代了之前的“永久代”（PermGen）。</li>
<li><code>-Xms512m</code>: 这条命令设定了 <strong>JVM 堆的初始内存为 512MB</strong>。堆是用来存放 Java 对象的地方。<code>-Xms</code> 决定了 JVM 启动时会申请的最小内存。</li>
<li><code>-Xmx1024m</code>: 这条命令设定了 <strong>JVM 堆的最大内存为 1024MB（即 1GB）</strong>。这是 JVM 运行时可以使用的最大内存。当堆内存用尽时，JVM 会触发垃圾回收，如果依然不足，就会抛出 <code>OutOfMemoryError</code>。</li>
</ul>
<hr>
<p>好的，我们来更详细地聊聊 JVM 堆内存的结构，特别是分代设计和具体的划分比例。</p>
<hr>
<h3 id="堆内存的传统分代结构"><a href="#堆内存的传统分代结构" class="headerlink" title="堆内存的传统分代结构"></a>堆内存的传统分代结构</h3><p>在绝大多数的垃圾回收器中（例如 CMS、G1 之前的串行和并行 GC），堆内存被分为以下几个代（Generation）：</p>
<h4 id="1-年轻代（Young-Generation）"><a href="#1-年轻代（Young-Generation）" class="headerlink" title="1. 年轻代（Young Generation）"></a>1. 年轻代（Young Generation）</h4><p><strong>年轻代是新对象的诞生地。</strong> 绝大多数对象，比如局部变量创建的临时对象，都会在年轻代被创建。年轻代被设计成较小且垃圾回收频率高的区域。</p>
<ul>
<li><strong>Eden 区</strong>：这是年轻代的主要部分，新创建的对象首先被分配到这里。</li>
<li><strong>Survivor 区（幸存者区）</strong>：有两个大小相等的 Survivor 区，通常命名为 <strong>S0</strong> 和 <strong>S1</strong>。它们的作用是保存每次垃圾回收后，还存活的对象。</li>
</ul>
<p><strong>划分比例</strong></p>
<p>在默认情况下，年轻代内部的划分比例通常是：</p>
<ul>
<li><strong>Eden 区 : S0 区 : S1 区 &#x3D; 8 : 1 : 1</strong></li>
</ul>
<p>这个比例可以通过 JVM 参数进行调整，比如使用 <code>-XX:SurvivorRatio=8</code>。这意味着 Eden 区的大小是单个 Survivor 区的 8 倍。</p>
<h4 id="2-老年代（Old-Generation）"><a href="#2-老年代（Old-Generation）" class="headerlink" title="2. 老年代（Old Generation）"></a>2. 老年代（Old Generation）</h4><p><strong>老年代用于存放生命周期较长的对象。</strong> 当一个对象在年轻代经过多次垃圾回收（通常是 15 次，这个次数也可以通过 <code>-XX:MaxTenuringThreshold</code> 参数调整）后仍然存活，或者年轻代放不下的大对象，就会被“晋升”到老年代。</p>
<p>老年代的垃圾回收频率远低于年轻代，但每次回收的开销更大。</p>
<p><strong>划分比例</strong></p>
<p>堆内存中，年轻代和老年代的默认划分比例通常是：</p>
<ul>
<li><strong>年轻代 : 老年代 &#x3D; 1 : 2</strong></li>
</ul>
<p>例如，如果你设置 <code>-Xms1200m -Xmx1200m</code>，那么年轻代大约是 400MB，老年代大约是 800MB。这个比例可以通过 <code>-XX:NewRatio</code> 参数来调整。例如，<code>-XX:NewRatio=2</code> 表示老年代与年轻代的大小比值为 2:1。</p>
<hr>
<h3 id="垃圾回收过程（以-Minor-GC-为例）"><a href="#垃圾回收过程（以-Minor-GC-为例）" class="headerlink" title="垃圾回收过程（以 Minor GC 为例）"></a>垃圾回收过程（以 Minor GC 为例）</h3><p>理解了这些区域，我们再来看看垃圾回收是怎么进行的：</p>
<ol>
<li>当 <strong>Eden 区</strong>满了，会触发一次 <strong>Minor GC</strong>。</li>
<li>Minor GC 会检查 Eden 区和其中一个 Survivor 区（比如 S0）。</li>
<li>它会将所有还<strong>存活的对象</strong>复制到另一个空的 Survivor 区（比如 S1）。</li>
<li>同时，那些<strong>不再被引用的对象</strong>则会被清理。</li>
<li>所有被复制到 S1 区的对象，它们的年龄（<code>age</code>）会加一。</li>
<li>下一次 Minor GC 发生时，同样会扫描 Eden 区和 S1 区，将存活对象复制到 S0 区，清空 Eden 和 S1 区，并增加对象的年龄。</li>
<li>当对象的年龄达到某个阈值时，它就会被<strong>晋升</strong>到老年代。</li>
</ol>
<h3 id="现代垃圾回收器（如-G1-和-ZGC）"><a href="#现代垃圾回收器（如-G1-和-ZGC）" class="headerlink" title="现代垃圾回收器（如 G1 和 ZGC）"></a>现代垃圾回收器（如 G1 和 ZGC）</h3><p>值得注意的是，像 <strong>G1 垃圾回收器</strong>已经打破了这种严格的分代比例。它将堆划分为一个个大小相等的<strong>区域（Region）</strong>，每个区域都可以是 Eden、Survivor 或者老年代。G1 能够更智能地选择要回收的区域，从而在保证低停顿的同时，提高吞吐量。</p>
<p>而 <strong>ZGC</strong> 则更进一步，如我之前所说，它<strong>完全没有年轻代、老年代的概念</strong>，而是通过着色指针和读屏障技术，在不中断应用程序的情况下并发地进行垃圾回收，实现了更低的停顿。</p>
<p>因此，当你使用 ZGC 时，传统的分代比例就不适用了。不过，了解传统的分代结构对于理解 Java 内存管理的基础依然非常重要。</p>
<p>以下是针对Spring Cloud Alibaba及其他分布式技术的深度补充，包含实现原理和核心组件的详细说明：</p>
<hr>
<h2 id="六、Spring-Cloud与分布式技术详解"><a href="#六、Spring-Cloud与分布式技术详解" class="headerlink" title="六、Spring Cloud与分布式技术详解"></a>六、Spring Cloud与分布式技术详解</h2><h3 id="6-1-Spring-Cloud-Alibaba核心组件"><a href="#6-1-Spring-Cloud-Alibaba核心组件" class="headerlink" title="6.1 Spring Cloud Alibaba核心组件"></a>6.1 Spring Cloud Alibaba核心组件</h3><h4 id="Nacos深度解析"><a href="#Nacos深度解析" class="headerlink" title="Nacos深度解析"></a>Nacos深度解析</h4><p><strong>服务发现原理</strong>：</p>
<ol>
<li><p><strong>注册流程</strong>：</p>
<ul>
<li>服务启动时向Nacos Server发送注册请求（HTTP&#x2F;GRPC）</li>
<li>注册信息包含元数据、健康检查方式（TCP&#x2F;HTTP&#x2F;MySQL）</li>
<li>客户端本地缓存服务列表（故障转移）</li>
</ul>
</li>
<li><p><strong>健康检查机制</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nacos健康检查配置示例</span></span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        health-check-enabled: <span class="literal">true</span></span><br><span class="line">        health-check-interval: 10s</span><br><span class="line">        health-check-timeout: 5s</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>配置中心实现</strong>：</p>
<ul>
<li><strong>长轮询机制</strong>（Push+Pull混合模式）：<ul>
<li>客户端发起长轮询请求（默认30秒超时）</li>
<li>服务端配置变更时立即响应</li>
<li>客户端收到变更后拉取最新配置</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态配置刷新示例</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.config.item&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Sentinel核心原理"><a href="#Sentinel核心原理" class="headerlink" title="Sentinel核心原理"></a>Sentinel核心原理</h4><p><strong>流量控制规则</strong>：</p>
<ul>
<li><strong>滑动窗口算法</strong>：<ul>
<li>统计周期（1秒）分为多个格子（如20个50ms）</li>
<li>实时淘汰过期格子数据</li>
<li>QPS计算基于当前窗口总请求数</li>
</ul>
</li>
</ul>
<p><strong>熔断降级策略</strong>：</p>
<table>
<thead>
<tr>
<th>策略类型</th>
<th>计算公式</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>慢调用比例</td>
<td>响应时间 &gt; RT阈值 &amp;&amp; 比例 &gt; 阈值</td>
<td>接口性能波动</td>
</tr>
<tr>
<td>异常比例</td>
<td>异常数 &#x2F; 请求数 &gt; 阈值</td>
<td>依赖服务不稳定</td>
</tr>
<tr>
<td>异常数</td>
<td>异常数 &gt; 阈值（时间窗口内）</td>
<td>关键业务熔断</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sentinel规则持久化到Nacos示例</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRules</span><span class="params">()</span> &#123;</span><br><span class="line">    FlowRuleManager.register2Property(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NacosDataSourceWrapper</span>(</span><br><span class="line">            <span class="string">&quot;nacos-server:8848&quot;</span>, <span class="string">&quot;sentinel-flow-rules&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> List&lt;FlowRule&gt; <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> JSON.parseArray(source, FlowRule.class);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RocketMQ集成"><a href="#RocketMQ集成" class="headerlink" title="RocketMQ集成"></a>RocketMQ集成</h4><p><strong>消息轨迹追踪</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RocketMQTemplate <span class="title function_">rocketMQTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RocketMQTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RocketMQTemplate</span>();</span><br><span class="line">    template.setProducer(<span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;producer_group&quot;</span>) &#123;&#123;</span><br><span class="line">        setVipChannelEnabled(<span class="literal">false</span>);</span><br><span class="line">        setTraceDispatcher(<span class="keyword">new</span> <span class="title class_">AsyncTraceDispatcher</span>(<span class="string">&quot;trace_topic&quot;</span>));</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者轨迹追踪</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">    topic = &quot;order_topic&quot;, </span></span><br><span class="line"><span class="meta">    consumerGroup = &quot;order_consumer&quot;,</span></span><br><span class="line"><span class="meta">    enableMsgTrace = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-分布式事务增强（Seata原理）"><a href="#6-2-分布式事务增强（Seata原理）" class="headerlink" title="6.2 分布式事务增强（Seata原理）"></a>6.2 分布式事务增强（Seata原理）</h3><h4 id="AT模式工作流程"><a href="#AT模式工作流程" class="headerlink" title="AT模式工作流程"></a>AT模式工作流程</h4><ol>
<li><p><strong>一阶段</strong>：</p>
<ul>
<li>解析SQL生成前后镜像</li>
<li>注册分支事务到TC（Transaction Coordinator）</li>
<li>本地事务提交前记录undo_log</li>
</ul>
</li>
<li><p><strong>二阶段</strong>：</p>
<ul>
<li>成功：异步删除undo_log</li>
<li>失败：根据undo_log补偿（反向SQL）</li>
</ul>
</li>
</ol>
<p><strong>undo_log表示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="TCC模式最佳实践"><a href="#TCC模式最佳实践" class="headerlink" title="TCC模式最佳实践"></a>TCC模式最佳实践</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 账户服务TCC接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountTccService</span> &#123;</span><br><span class="line">    <span class="meta">@TwoPhaseBusinessAction(</span></span><br><span class="line"><span class="meta">        name = &quot;deduct&quot;,</span></span><br><span class="line"><span class="meta">        commitMethod = &quot;confirmDeduct&quot;,</span></span><br><span class="line"><span class="meta">        rollbackMethod = &quot;cancelDeduct&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">prepareDeduct</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@BusinessActionContextParameter(paramName = &quot;userId&quot;)</span> String userId,</span></span><br><span class="line"><span class="params">        <span class="meta">@BusinessActionContextParameter(paramName = &quot;amount&quot;)</span> BigDecimal amount</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">confirmDeduct</span><span class="params">(BusinessActionContext context)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancelDeduct</span><span class="params">(BusinessActionContext context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务调用方</span></span><br><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 冻结库存</span></span><br><span class="line">    inventoryTccService.prepare(<span class="literal">null</span>, order.getProductId(), order.getCount());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 预扣款</span></span><br><span class="line">    accountTccService.prepareDeduct(order.getUserId(), order.getAmount());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 创建订单</span></span><br><span class="line">    orderMapper.insert(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-分布式缓存深度优化"><a href="#6-3-分布式缓存深度优化" class="headerlink" title="6.3 分布式缓存深度优化"></a>6.3 分布式缓存深度优化</h3><h4 id="Redis多级缓存架构"><a href="#Redis多级缓存架构" class="headerlink" title="Redis多级缓存架构"></a>Redis多级缓存架构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地缓存+Caffeine+Redis实现</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CaffeineRedisCacheManager</span>(</span><br><span class="line">        Caffeine.newBuilder()</span><br><span class="line">            .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">            .maximumSize(<span class="number">1000</span>),</span><br><span class="line">        RedisCacheWriter.nonLockingRedisCacheWriter(factory),</span><br><span class="line">        RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            .entryTtl(Duration.ofHours(<span class="number">1</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 热点Key探测</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getWithHotspotProtection</span><span class="params">(String key, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 本地缓存查询</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> localCache.getIfPresent(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) <span class="keyword">return</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. Redis集群查询（带随机过期时间）</span></span><br><span class="line">    value = redisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        localCache.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 分布式锁防击穿</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span> + key;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (redisLock.tryLock(lockKey, <span class="number">3</span>, <span class="number">30</span>)) &#123;</span><br><span class="line">            <span class="comment">// 4. 数据库查询</span></span><br><span class="line">            value = databaseLoader.load(key);</span><br><span class="line">            redisTemplate.opsForValue().set(</span><br><span class="line">                key, value, </span><br><span class="line">                ThreadLocalRandom.current().nextInt(<span class="number">30</span>) + <span class="number">30</span>, </span><br><span class="line">                TimeUnit.MINUTES</span><br><span class="line">            );</span><br><span class="line">            localCache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-消息队列高级特性"><a href="#6-4-消息队列高级特性" class="headerlink" title="6.4 消息队列高级特性"></a>6.4 消息队列高级特性</h3><h4 id="RocketMQ事务消息"><a href="#RocketMQ事务消息" class="headerlink" title="RocketMQ事务消息"></a>RocketMQ事务消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务消息生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTransactionMessage</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="type">TransactionSendResult</span> <span class="variable">result</span> <span class="operator">=</span> rocketMQTemplate.sendMessageInTransaction(</span><br><span class="line">        <span class="string">&quot;order-tx-group&quot;</span>,</span><br><span class="line">        MessageBuilder.withPayload(order)</span><br><span class="line">            .setHeader(RocketMQHeaders.TRANSACTION_ID, order.getId())</span><br><span class="line">            .build(),</span><br><span class="line">        order</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地事务执行器</span></span><br><span class="line"><span class="meta">@RocketMQTransactionListener(txProducerGroup = &quot;order-tx-group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">RocketMQLocalTransactionListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> (Order) arg;</span><br><span class="line">            orderService.createOrder(order); <span class="comment">// 本地事务</span></span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> msg.getHeaders().get(<span class="string">&quot;TRANSACTION_ID&quot;</span>).toString();</span><br><span class="line">        <span class="keyword">return</span> orderService.exists(orderId) ? </span><br><span class="line">            RocketMQLocalTransactionState.COMMIT : </span><br><span class="line">            RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Kafka精确一次语义"><a href="#Kafka精确一次语义" class="headerlink" title="Kafka精确一次语义"></a>Kafka精确一次语义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ProducerFactory&lt;String, String&gt; <span class="title function_">producerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    configs.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, <span class="literal">true</span>);</span><br><span class="line">    configs.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, <span class="string">&quot;tx-producer-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultKafkaProducerFactory</span>&lt;&gt;(configs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者配置</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ConsumerFactory&lt;String, String&gt; <span class="title function_">consumerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    configs.put(ConsumerConfig.ISOLATION_LEVEL_CONFIG, <span class="string">&quot;read_committed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultKafkaConsumerFactory</span>&lt;&gt;(configs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务性消费</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &quot;order-topic&quot;)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(ConsumerRecord&lt;String, String&gt; record)</span> &#123;</span><br><span class="line">    <span class="type">OrderEvent</span> <span class="variable">event</span> <span class="operator">=</span> parseEvent(record.value());</span><br><span class="line">    orderService.process(event); <span class="comment">// 数据库操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、云原生支持（新增）"><a href="#七、云原生支持（新增）" class="headerlink" title="七、云原生支持（新增）"></a>七、云原生支持（新增）</h2><h3 id="7-1-Kubernetes集成方案"><a href="#7-1-Kubernetes集成方案" class="headerlink" title="7.1 Kubernetes集成方案"></a>7.1 Kubernetes集成方案</h3><h4 id="服务发现适配"><a href="#服务发现适配" class="headerlink" title="服务发现适配"></a>服务发现适配</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Nacos与K8s Service集成</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">kubernetes:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">all-namespaces:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">$&#123;NACOS_HOST:nacos-headless&#125;:$&#123;NACOS_PORT:8848&#125;</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">$&#123;POD_NAMESPACE:default&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置管理方案"><a href="#配置管理方案" class="headerlink" title="配置管理方案"></a>配置管理方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多配置源加载（K8s ConfigMap + Nacos）</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;configFromNacos&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nacosConfig;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;configFromK8s&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String k8sConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-Service-Mesh整合"><a href="#7-2-Service-Mesh整合" class="headerlink" title="7.2 Service Mesh整合"></a>7.2 Service Mesh整合</h3><h4 id="Istio流量治理"><a href="#Istio流量治理" class="headerlink" title="Istio流量治理"></a>Istio流量治理</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 金丝雀发布策略</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">order-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">order-service</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">            <span class="attr">host:</span> <span class="string">order-service</span></span><br><span class="line">            <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">          <span class="attr">weight:</span> <span class="number">90</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">            <span class="attr">host:</span> <span class="string">order-service</span></span><br><span class="line">            <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">          <span class="attr">weight:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、性能优化深度实践"><a href="#八、性能优化深度实践" class="headerlink" title="八、性能优化深度实践"></a>八、性能优化深度实践</h2><h3 id="8-1-全链路压测方案"><a href="#8-1-全链路压测方案" class="headerlink" title="8.1 全链路压测方案"></a>8.1 全链路压测方案</h3><h4 id="影子库表配置"><a href="#影子库表配置" class="headerlink" title="影子库表配置"></a>影子库表配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ShardingSphere影子库配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">ds-real,ds-shadow</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="attr">shadow:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">data-sources:</span></span><br><span class="line">          <span class="attr">shadow-data-source:</span></span><br><span class="line">            <span class="attr">source-data-source-name:</span> <span class="string">ds-real</span></span><br><span class="line">            <span class="attr">shadow-data-source-name:</span> <span class="string">ds-shadow</span></span><br><span class="line">        <span class="attr">tables:</span></span><br><span class="line">          <span class="attr">t_order:</span></span><br><span class="line">            <span class="attr">shadow-algorithm-names:</span> [<span class="string">simple-hint-algorithm</span>]</span><br></pre></td></tr></table></figure>

<h4 id="流量染色标记"><a href="#流量染色标记" class="headerlink" title="流量染色标记"></a>流量染色标记</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ThreadLocal传递压测标记</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PressureTestContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; FLAG = ThreadLocal.withInitial(() -&gt; <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">markPressureTest</span><span class="params">()</span> &#123;</span><br><span class="line">        FLAG.set(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPressureTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FLAG.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyBatis拦截器自动路由</span></span><br><span class="line"><span class="meta">@Intercepts(@Signature(type=Executor.class, method=&quot;update&quot;, args=&#123;MappedStatement.class,Object.class&#125;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShadowDbInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (PressureTestContext.isPressureTest()) &#123;</span><br><span class="line">            RoutingContext.setShadowDataSource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/11/%E6%A1%86%E6%9E%B6%E8%83%8C%E8%AF%B5/" data-id="cmffake6r000g50uy6or16ilg" data-title="框架背诵" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo-Markdown/" rel="tag">Hexo, Markdown</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-手写答案" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/" class="article-date">
  <time class="dt-published" datetime="2025-09-11T10:29:28.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/">手写答案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-实现单例模式-Singleton-Pattern"><a href="#1-实现单例模式-Singleton-Pattern" class="headerlink" title="1.实现单例模式 (Singleton Pattern)"></a>1.实现单例模式 (Singleton Pattern)</h3><h4 id="懒汉式："><a href="#懒汉式：" class="headerlink" title="懒汉式："></a>懒汉式：</h4><p>使用<strong>双重检查锁定 (DCL)</strong> 实现线程安全的懒汉式单例模式。这种模式在第一次调用时才创建实例，并且通过两次检查和同步块确保了线程安全和性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. volatile 关键字确保多线程环境下，instance 变量的修改能够立即被其他线程看到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有化构造器，防止外部直接 new 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供一个全局访问点，使用 DCL 确保线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查：如果实例已经存在，直接返回，避免不必要的同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一次检查失败，进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查：在同步块内部再次检查，防止多个线程同时通过第一次检查，</span></span><br><span class="line">                <span class="comment">// 导致创建多个实例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建实例</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个线程安全的懒汉式单例模式实例。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="饿汉式："><a href="#饿汉式：" class="headerlink" title="饿汉式："></a>饿汉式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonEager</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 在类加载时就创建静态实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonEager</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonEager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有化构造器，防止外部直接创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonEager</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供一个公共的静态方法来获取唯一实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonEager <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个线程安全的饿汉式单例模式实例。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-继承与多态-Inheritance-and-Polymorphism"><a href="#2-继承与多态-Inheritance-and-Polymorphism" class="headerlink" title="2.继承与多态 (Inheritance and Polymorphism)"></a>2.继承与多态 (Inheritance and Polymorphism)</h3><p>设计一个 <code>Animal</code> 抽象类，并创建 <code>Dog</code> 和 <code>Cat</code> 类来展示继承和多态。&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Animal 抽象类，定义通用行为</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Dog 类继承 Animal，并重写 eat() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗正在吃骨头。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Cat 类继承 Animal，并重写 eat() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫正在吃鱼。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 展示多态的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PolymorphismDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showPolymorphism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 父类引用指向子类对象，这就是多态</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用相同的方法，但由于指向不同的子类实例，执行不同的行为</span></span><br><span class="line">        myDog.eat(); <span class="comment">// 输出: 狗正在吃骨头。</span></span><br><span class="line">        myCat.eat(); <span class="comment">// 输出: 猫正在吃鱼。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="equals-和-hashCode"><a href="#equals-和-hashCode" class="headerlink" title="equals() 和 hashCode()"></a><code>equals()</code> 和 <code>hashCode()</code></h3><p>编写 <code>Student</code> 类，并重写 <code>equals()</code> 和 <code>hashCode()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 equals() 方法，根据 id 和 name 判断两个 Student 对象是否相等</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 检查是否为同一个对象的引用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 2. 检查对象是否为 null 或类型是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 3. 类型转换</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="comment">// 4. 比较关键字段 (id 和 name)</span></span><br><span class="line">        <span class="keyword">return</span> id == student.id &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 hashCode() 方法，为相等的对象生成相同的哈希码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Objects.hash() 方法生成哈希码，它会为多个字段生成一个组合哈希值</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 为什么需要两者一起重写？</span></span><br><span class="line"><span class="comment">* 1. 它们之间存在约定：如果两个对象通过 equals() 方法比较是相等的，那么它们的 hashCode() 方法返回的值也必须相等。</span></span><br><span class="line"><span class="comment">* 反之则不一定，不相等的对象可以有相同的哈希码（哈希冲突）。</span></span><br><span class="line"><span class="comment">* 2. 哈希表类（如 HashSet, HashMap）依赖于这个约定：当将对象存入哈希表时，</span></span><br><span class="line"><span class="comment">* 它会先调用 hashCode() 确定存储位置，再调用 equals() 来确认是否存在相同的对象。</span></span><br><span class="line"><span class="comment">* 3. 如果只重写 equals() 但不重写 hashCode()，可能导致两个逻辑上相等的对象被存储在不同的哈希位置，</span></span><br><span class="line"><span class="comment">* 从而无法正确查找和去重。例如，在 HashSet 中，即使两个 Student 对象 id 和 name 相同，</span></span><br><span class="line"><span class="comment">* 也会被认为是不同的对象而重复添加。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="接口与实现-Interfaces-and-Implementation"><a href="#接口与实现-Interfaces-and-Implementation" class="headerlink" title="接口与实现 (Interfaces and Implementation)"></a>接口与实现 (Interfaces and Implementation)</h3><p>设计 <code>Drawable</code> 接口，并由 <code>Circle</code> 和 <code>Rectangle</code> 实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义 Drawable 接口，包含一个抽象方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Circle 类实现 Drawable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在画一个圆形。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Rectangle 类实现 Drawable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在画一个矩形。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="异常处理-Exception-Handling"><a href="#异常处理-Exception-Handling" class="headerlink" title="异常处理 (Exception Handling)"></a>异常处理 (Exception Handling)</h3><p>使用 <code>try-catch-finally</code> 结构处理 <code>FileNotFoundException</code> 并确保资源关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 在 try 块外部声明，以便在 finally 块中访问</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试打开文件</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已成功打开。&quot;</span>);</span><br><span class="line">            <span class="comment">// 假设这里进行文件读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件未找到异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;错误：指定的文件不存在！路径：&quot;</span> + filePath);</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印异常堆栈信息</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论是否发生异常，finally 块都会执行</span></span><br><span class="line">            <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 确保文件流被关闭，防止资源泄露</span></span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件流已在 finally 块中关闭。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;关闭文件流时发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a><code>try-with-resources</code></h3><p>使用 <code>try-with-resources</code> 重写上一个题目，展示其简化优势。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TryWithResourcesDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processFileWithResources</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">// try-with-resources 语句，自动管理实现了 AutoCloseable 接口的资源</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已成功打开。&quot;</span>);</span><br><span class="line">            <span class="comment">// 假设这里进行文件读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件未找到异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;错误：指定的文件不存在！路径：&quot;</span> + filePath);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获文件关闭时可能发生的异常</span></span><br><span class="line">            System.err.println(<span class="string">&quot;关闭文件流时发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不需要单独的 finally 块来关闭资源，JVM 会自动完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件流已在 try-with-resources 语句中自动关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* try-with-resources 的优势：</span></span><br><span class="line"><span class="comment">* 1. 简化代码：不再需要显式的 finally 块来关闭资源，代码更简洁。</span></span><br><span class="line"><span class="comment">* 2. 避免资源泄露：无论 try 块是否正常完成或抛出异常，资源都会被自动关闭，</span></span><br><span class="line"><span class="comment">* 有效防止了因忘记关闭资源而导致的内存和文件句柄泄露。</span></span><br><span class="line"><span class="comment">* 3. 更好的异常处理：如果 try 块和资源关闭时都抛出异常，try-with-resources 会</span></span><br><span class="line"><span class="comment">* 将资源关闭时抛出的异常作为被抑制（suppressed）的异常，主异常保持不变，</span></span><br><span class="line"><span class="comment">* 便于调试。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 (Bubble Sort)"></a>冒泡排序 (Bubble Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortingAlgorithms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">// 外层循环控制比较轮数，共进行 n-1 轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 优化：如果在某一轮没有发生交换，说明数组已经有序</span></span><br><span class="line">            <span class="comment">// 内层循环负责每轮比较和交换，将最大元素“冒”到数组末尾</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换元素</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    swapped = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果没有发生交换，提前结束排序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortingAlgorithms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 找到基准元素的正确位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">            <span class="comment">// 递归地对左子数组进行排序</span></span><br><span class="line">            quickSort(arr, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归地对右子数组进行排序</span></span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择最右边的元素作为基准</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (low - <span class="number">1</span>); <span class="comment">// i 指向小于等于基准的元素的最后一个位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素小于等于基准</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 交换 arr[i] 和 arr[j]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基准元素放到正确的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i + <span class="number">1</span>];</span><br><span class="line">        arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">        arr[high] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二分查找-Binary-Search"><a href="#二分查找-Binary-Search" class="headerlink" title="二分查找 (Binary Search)"></a>二分查找 (Binary Search)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchAlgorithms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止整数溢出</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// 找到目标，返回索引</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 目标在右半部分，更新左边界</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 目标在左半部分，更新右边界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 没有找到目标</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="链表反转-Reverse-Linked-List"><a href="#链表反转-Reverse-Linked-List" class="headerlink" title="链表反转 (Reverse Linked List)"></a>链表反转 (Reverse Linked List)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 前一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head; <span class="comment">// 当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextTemp</span> <span class="operator">=</span> current.next; <span class="comment">// 暂存下一个节点</span></span><br><span class="line">            current.next = prev; <span class="comment">// 将当前节点的指针指向前一个节点</span></span><br><span class="line">            prev = current; <span class="comment">// 前一个节点向前移动</span></span><br><span class="line">            current = nextTemp; <span class="comment">// 当前节点向前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev; <span class="comment">// prev 最终会是新的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="链表中间节点-Middle-of-Linked-List"><a href="#链表中间节点-Middle-of-Linked-List" class="headerlink" title="链表中间节点 (Middle of Linked List)"></a>链表中间节点 (Middle of Linked List)</h3><p>使用<strong>快慢指针</strong>，快指针每次走两步，慢指针每次走一步。当快指针到达链表末尾时，慢指针正好在中间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findMiddleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head; <span class="comment">// 慢指针，每次走一步</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head; <span class="comment">// 快指针，每次走两步</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当快指针到达末尾时，慢指针正好在中间</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="移除重复元素-Remove-Duplicates"><a href="#移除重复元素-Remove-Duplicates" class="headerlink" title="移除重复元素 (Remove Duplicates)"></a>移除重复元素 (Remove Duplicates)</h3><p>不使用 <code>Set</code>，通过双层循环或排序后遍历实现。这里使用排序后遍历的方法，因为它更高效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeDuplicates</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span> || list.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(list); <span class="comment">// 先排序，使得重复元素相邻</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 倒序遍历，移除重复元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).equals(list.get(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                list.remove(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="字符串反转-Reverse-String"><a href="#字符串反转-Reverse-String" class="headerlink" title="字符串反转 (Reverse String)"></a>字符串反转 (Reverse String)</h3><p>不使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 的 <code>reverse()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> charArray.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 交换首尾字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> charArray[left];</span><br><span class="line">            charArray[left] = charArray[right];</span><br><span class="line">            charArray[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="回文字符串-Palindrome-String"><a href="#回文字符串-Palindrome-String" class="headerlink" title="回文字符串 (Palindrome String)"></a>回文字符串 (Palindrome String)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将字符串转换为小写并移除非字母数字字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cleanedStr</span> <span class="operator">=</span> str.toLowerCase().replaceAll(<span class="string">&quot;[^a-z0-9]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> cleanedStr.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cleanedStr.charAt(left) != cleanedStr.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="计算阶乘-Factorial-Calculation"><a href="#计算阶乘-Factorial-Calculation" class="headerlink" title="计算阶乘 (Factorial Calculation)"></a>计算阶乘 (Factorial Calculation)</h3><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">factorialRecursive</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Factorial is not defined for negative numbers.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * factorialRecursive(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MathProblems &#123;</span><br><span class="line">    public static long factorialIterative(int n) &#123;</span><br><span class="line">        if (n &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Factorial is not defined for negative numbers.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        long result = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            result *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="斐波那契数列-Fibonacci-Sequence"><a href="#斐波那契数列-Fibonacci-Sequence" class="headerlink" title="斐波那契数列 (Fibonacci Sequence)"></a>斐波那契数列 (Fibonacci Sequence)</h3><h4 id="递归方式-1"><a href="#递归方式-1" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fibonacciRecursive</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid input for Fibonacci sequence.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibonacciRecursive(n - <span class="number">1</span>) + fibonacciRecursive(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归方式-1"><a href="#非递归方式-1" class="headerlink" title="非递归方式"></a>非递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fibonacciIterative</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid input for Fibonacci sequence.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="字符串中字符计数-Character-Count"><a href="#字符串中字符计数-Character-Count" class="headerlink" title="字符串中字符计数 (Character Count)"></a>字符串中字符计数 (Character Count)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Character, Integer&gt; <span class="title function_">countCharacters</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; charCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> charCountMap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            charCountMap.put(c, charCountMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> charCountMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="两数之和-Two-Sum"><a href="#两数之和-Two-Sum" class="headerlink" title="两数之和 (Two Sum)"></a>两数之和 (Two Sum)</h3><p>使用 <code>HashMap</code> 将值和索引存储起来，实现一次遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; numMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (numMap.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;numMap.get(complement), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            numMap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;; <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="数组中最大-小值-Max-Min-in-Array"><a href="#数组中最大-小值-Max-Min-in-Array" class="headerlink" title="数组中最大&#x2F;小值 (Max&#x2F;Min in Array)"></a>数组中最大&#x2F;小值 (Max&#x2F;Min in Array)</h3><p>一次遍历找到最大值和最小值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findMaxMin(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Array cannot be null or empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;max, min&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="质数判断-Prime-Number"><a href="#质数判断-Prime-Number" class="headerlink" title="质数判断 (Prime Number)"></a>质数判断 (Prime Number)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1 和更小的数都不是质数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只需要检查到 n 的平方根</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="集合交集-List-Intersection"><a href="#集合交集-List-Intersection" class="headerlink" title="集合交集 (List Intersection)"></a>集合交集 (List Intersection)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">intersection</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span> &#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">null</span> || list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历第一个列表，检查元素是否在第二个列表中</span></span><br><span class="line">        <span class="keyword">for</span> (T element : list1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list2.contains(element) &amp;&amp; !result.contains(element)) &#123;</span><br><span class="line">                result.add(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="数组合并-Merge-Sorted-Arrays"><a href="#数组合并-Merge-Sorted-Arrays" class="headerlink" title="数组合并 (Merge Sorted Arrays)"></a>数组合并 (Merge Sorted Arrays)</h3><p>将两个已排序的数组合并为一个新的已排序数组，使用<strong>双指针</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeSortedArrays(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="type">int</span>[] merged = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length + arr2.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] &lt; arr2[j]) &#123;</span><br><span class="line">                merged[k++] = arr1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged[k++] = arr2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr1.length) &#123;</span><br><span class="line">            merged[k++] = arr1[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; arr2.length) &#123;</span><br><span class="line">            merged[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="判断回文数-Palindrome-Number"><a href="#判断回文数-Palindrome-Number" class="headerlink" title="判断回文数 (Palindrome Number)"></a>判断回文数 (Palindrome Number)</h3><p>不使用 <code>String</code> 转换，通过数学方法反转一半数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindromeNumber</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 负数和以 0 结尾的非 0 数字都不是回文</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">reversedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; reversedNumber) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lastDigit</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">            reversedNumber = reversedNumber * <span class="number">10</span> + lastDigit;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偶数位数字时，x 等于 reversedNumber</span></span><br><span class="line">        <span class="comment">// 奇数位数字时，x 等于 reversedNumber 除以 10</span></span><br><span class="line">        <span class="keyword">return</span> x == reversedNumber || x == reversedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="罗马数字转整数-Roman-to-Integer"><a href="#罗马数字转整数-Roman-to-Integer" class="headerlink" title="罗马数字转整数 (Roman to Integer)"></a>罗马数字转整数 (Roman to Integer)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; romanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        romanMap.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        romanMap.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentVal</span> <span class="operator">=</span> romanMap.get(s.charAt(i));</span><br><span class="line">            <span class="comment">// 如果当前字符的值小于下一个字符的值，则需要减去当前值</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; s.length() - <span class="number">1</span> &amp;&amp; currentVal &lt; romanMap.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                result -= currentVal;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += currentVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="爬楼梯-Climbing-Stairs"><a href="#爬楼梯-Climbing-Stairs" class="headerlink" title="爬楼梯 (Climbing Stairs)"></a>爬楼梯 (Climbing Stairs)</h3><p>这是经典的<strong>动态规划</strong>问题。</p>
<h4 id="动态规划方式-非递归"><a href="#动态规划方式-非递归" class="headerlink" title="动态规划方式 (非递归)"></a>动态规划方式 (非递归)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 爬 1 级台阶，有 1 种方法</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>; <span class="comment">// 爬 2 级台阶，有 2 种方法 (1+1, 2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 到达第 i 级台阶的方法数 = (从 i-1 级爬 1 级的方法数) + (从 i-2 级爬 2 级的方法数)</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，以下是基于  语言的线程基础与同步的实现，并附带详细注释。</p>
<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><h4 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1. 继承 Thread 类"></a>1. 继承 <code>Thread</code> 类</h4><p>通过继承 <code>java.lang.Thread</code> 类并重写其 <code>run()</code> 方法来创建线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承 Thread 类创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用继承 Thread 类的方式创建的线程正在运行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-实现-Runnable-接口"><a href="#2-实现-Runnable-接口" class="headerlink" title="2. 实现 Runnable 接口"></a>2. 实现 <code>Runnable</code> 接口</h4><p>通过实现 <code>java.lang.Runnable</code> 接口并将其作为参数传递给 <code>Thread</code> 类的构造函数来创建线程。这种方式更灵活，推荐使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Runnable 接口创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用实现 Runnable 接口的方式创建的线程正在运行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep() 与 yield()"></a><code>sleep()</code> 与 <code>yield()</code></h3><p><code>sleep()</code> 和 <code>yield()</code> 都是线程调度的方法，但它们的作用和效果不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepYieldDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 sleep() 的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// sleep() 使线程暂停指定时间，进入 WAITING 状态，但不会释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程 A: 准备睡眠 2 秒...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 A: 睡眠结束，继续执行。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 yield() 的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 B: 开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 B: 正在执行 &quot;</span> + i);</span><br><span class="line">                <span class="comment">// yield() 提示线程调度器让出 CPU 时间，但不保证一定生效</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 B: 执行完毕。&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sleep()</strong>: 使当前线程<strong>暂停执行指定的时间</strong>，进入 <strong>TIMED_WAITING</strong> 状态。它会<strong>释放 CPU 资源</strong>，但<strong>不释放锁</strong>。</li>
<li><strong>yield()</strong>: 提示线程调度器，当前线程愿意<strong>让出当前 CPU 时间片</strong>。线程会从 <strong>RUNNING</strong> 状态转换为 <strong>RUNNABLE</strong> 状态，与其他线程竞争 CPU，但<strong>不保证</strong>其他线程能立即获得执行。它主要用于优化线程调度，通常在多线程程序中<strong>不应依赖</strong>其行为来保证正确性。</li>
</ul>
<hr>
<h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join() 方法"></a><code>join()</code> 方法</h3><p><code>join()</code> 方法允许一个线程等待另一个线程执行完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JoinDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程: 正在执行...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;子线程: 执行完毕。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        workerThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 等待子线程执行完毕...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用 join() 方法，主线程进入等待状态，直到 workerThread 执行完毕</span></span><br><span class="line">        workerThread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 子线程已执行完毕，主线程继续执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="非线程安全计数器"><a href="#非线程安全计数器" class="headerlink" title="非线程安全计数器"></a>非线程安全计数器</h3><p>在多线程环境下，多个线程同时对共享资源进行读写操作，可能导致数据不一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 这一行代码并非原子操作，它包含三个步骤：读、加 1、写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafetyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">UnsafeCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsafeCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果不一定是 100 * 10000 = 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;非线程安全计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><code>synchronized</code> 关键字</h3><p>使用 <code>synchronized</code> 关键字可以保证同一时刻只有一个线程访问共享资源，从而解决线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 关键字修饰方法，锁住整个对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SynchronizedCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果为 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="synchronized-块与方法"><a href="#synchronized-块与方法" class="headerlink" title="synchronized 块与方法"></a><code>synchronized</code> 块与方法</h3><ul>
<li><strong>synchronized 方法</strong>: 锁定的是当前对象实例 (<code>this</code>)。</li>
<li><strong>synchronized 块</strong>: 提供了更细粒度的控制，可以指定锁定的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedBlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized 方法，锁定当前对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synchronizedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入 synchronized 方法。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 离开 synchronized 方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized 块，锁定指定的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedBlock1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取 lock1...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已获取 lock1。&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放 lock1。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedBlock2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 尝试获取 lock2...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已获取 lock2。&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放 lock2。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 区别与适用场景:</span></span><br><span class="line"><span class="comment"> * - synchronized 方法: 简单易用，但锁定范围大，可能导致性能问题。当需要同步整个方法时使用。</span></span><br><span class="line"><span class="comment"> * - synchronized 块: 锁定范围小，可以只同步需要保护的代码段，提高并发性能。当只需要同步部分代码时使用。</span></span><br><span class="line"><span class="comment"> * 同时，可以通过锁定不同的对象来避免不必要的阻塞，实现更高的并发度。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><code>volatile</code> 关键字</h3><p><code>volatile</code> 关键字保证了变量在多线程间的<strong>可见性</strong>，但不保证<strong>原子性</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">    <span class="comment">// volatile 保证所有线程看到的是该变量的最新值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 正在等待标志位变为 true。&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="comment">// 空循环，等待 ready 变为 true</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A: 标志位已变为 true，循环结束。&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 确保线程 A 先运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 正在将标志位设置为 true。&quot;</span>);</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为什么 volatile 不能保证原子性?</span></span><br><span class="line"><span class="comment"> * - 原子性是指一个操作是不可中断的，要么全部执行，要么都不执行。</span></span><br><span class="line"><span class="comment"> * - volatile 只能保证变量的读写操作是原子的，但像 `count++` 这样的复合操作（读、加、写）</span></span><br><span class="line"><span class="comment"> * 依然不是原子的。多个线程可能同时读到旧值，导致最终结果不正确。</span></span><br><span class="line"><span class="comment"> * - volatile 主要用于一写多读的场景，或者用于控制线程执行流程的标志位。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a><code>AtomicInteger</code></h3><p><code>AtomicInteger</code> 是一个原子类，它使用 CAS (Compare-and-Swap) 机制来保证操作的原子性，从而实现线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 AtomicInteger 替代 int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet(); <span class="comment">// 这是一个原子操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicCounter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicCounter</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    counter.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果为 1000000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicInteger 计数器的最终结果: &quot;</span> + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>使用 <code>wait()</code> 和 <code>notifyAll()</code> 实现两个线程交替打印奇数和偶数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintNumbers</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOdd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果是偶数，则等待</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEven</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count % <span class="number">2</span> != <span class="number">0</span>) &#123; <span class="comment">// 如果是奇数，则等待</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNumbers</span> <span class="variable">pn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumbers</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">oddThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(pn::printOdd, <span class="string">&quot;奇数线程&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">evenThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(pn::printEven, <span class="string">&quot;偶数线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        oddThread.start();</span><br><span class="line">        evenThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，以下是  中高级并发编程的实现，并附带详细注释。</p>
<h3 id="生产者-消费者模式-使用-wait-和-notifyAll"><a href="#生产者-消费者模式-使用-wait-和-notifyAll" class="headerlink" title="生产者-消费者模式 (使用 wait() 和 notifyAll())"></a>生产者-消费者模式 (使用 <code>wait()</code> 和 <code>notifyAll()</code>)</h3><p>这是一个经典的线程协作问题。生产者生产数据，放入共享队列；消费者从队列中取出数据进行消费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerClassic</span> &#123;</span><br><span class="line">    <span class="comment">// 共享队列，使用 LinkedList 实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 队列最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 如果队列已满，生产者等待</span></span><br><span class="line">                <span class="keyword">while</span> (queue.size() == MAX_SIZE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列已满，生产者等待...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 生产数据并放入队列</span></span><br><span class="line">                queue.offer(i);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 唤醒所有等待的线程（包括消费者）</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟生产时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 如果队列为空，消费者等待</span></span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列为空，消费者等待...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 消费数据</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">                <span class="comment">// 唤醒所有等待的线程（包括生产者）</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">// 模拟消费时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="生产者-消费者模式-使用-BlockingQueue"><a href="#生产者-消费者模式-使用-BlockingQueue" class="headerlink" title="生产者-消费者模式 (使用 BlockingQueue)"></a>生产者-消费者模式 (使用 <code>BlockingQueue</code>)</h3><p><code>java.util.concurrent.BlockingQueue</code> 接口提供了线程安全的队列操作，简化了生产者-消费者模型的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerBlockingQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 BlockingQueue，它内部已经处理了线程同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// put() 方法在队列满时会自动阻塞</span></span><br><span class="line">            queue.put(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// take() 方法在队列空时会自动阻塞</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h3><p>使用 <code>ReentrantLock</code> 实现线程安全计数器，并解释其与 <code>synchronized</code> 的区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReentrantLockCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++; <span class="comment">// 在 try 块中执行需要同步的代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 在 finally 块中释放锁，确保锁总是被释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* ReentrantLock 与 synchronized 的区别:</span></span><br><span class="line"><span class="comment">* 1. 语法层面: `synchronized` 是 JVM 的内置关键字，而 `ReentrantLock` 是一个类。</span></span><br><span class="line"><span class="comment">* 2. 灵活性: `ReentrantLock` 提供了更灵活的锁定控制。例如，它支持公平锁（按请求顺序获取锁），</span></span><br><span class="line"><span class="comment">* 可以尝试非阻塞地获取锁（`tryLock()`），以及支持中断（`lockInterruptibly()`）。</span></span><br><span class="line"><span class="comment">* 3. 性能: 在早期版本中，`ReentrantLock` 通常性能更好。但随着  对 `synchronized` 优化（偏向锁、轻量级锁），</span></span><br><span class="line"><span class="comment">* 两者性能已非常接近。在简单场景下，`synchronized` 更简洁。</span></span><br><span class="line"><span class="comment">* 4. 协作: `ReentrantLock` 必须配合 `Condition` 接口才能实现线程间的等待/唤醒机制，而 `synchronized` 直接</span></span><br><span class="line"><span class="comment">* 使用 `Object` 的 `wait()` 和 `notify()`。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ReentrantLock-与-Condition"><a href="#ReentrantLock-与-Condition" class="headerlink" title="ReentrantLock 与 Condition"></a><code>ReentrantLock</code> 与 <code>Condition</code></h3><p>使用 <code>ReentrantLock</code> 和 <code>Condition</code> 重新实现生产者-消费者模型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumerCondition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 创建两个 Condition 实例，分别用于生产者和消费者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">producerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">consumerCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == MAX_SIZE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列已满，生产者等待...&quot;</span>);</span><br><span class="line">                    producerCondition.await(); <span class="comment">// 生产者等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了: &quot;</span> + i);</span><br><span class="line">                i++;</span><br><span class="line">                consumerCondition.signalAll(); <span class="comment">// 唤醒所有消费者</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列为空，消费者等待...&quot;</span>);</span><br><span class="line">                    consumerCondition.await(); <span class="comment">// 消费者等待</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了: &quot;</span> + data);</span><br><span class="line">                producerCondition.signalAll(); <span class="comment">// 唤醒所有生产者</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><code>ExecutorService</code></h3><p>创建一个固定大小的线程池，并向其提交多个任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutorServiceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小为 3 的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 执行。&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池，不再接收新任务，已提交的任务会继续执行</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Callable-与-Future"><a href="#Callable-与-Future" class="headerlink" title="Callable 与 Future"></a><code>Callable</code> 与 <code>Future</code></h3><p>使用 <code>Callable</code> 提交任务，并使用 <code>Future</code> 获取返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 Callable 任务，它会返回一个字符串</span></span><br><span class="line">        Callable&lt;String&gt; task = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务开始执行...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;任务执行完毕，返回结果！&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务并获得 Future 对象</span></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(task);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 任务已提交，继续执行其他操作...&quot;</span>);</span><br><span class="line">        <span class="comment">// get() 方法会阻塞，直到任务完成并返回结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 获得任务结果 -&gt; &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h3><p><code>CountDownLatch</code> 允许一个或多个线程等待直到在其他线程中执行的一组操作完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">workerCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 计数器，当计数器减到 0 时，主线程会被唤醒</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(workerCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 开始执行任务...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">2000</span>)); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 任务完成。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown(); <span class="comment">// 任务完成后，计数器减 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 等待所有工作线程完成...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 阻塞主线程，直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 所有工作线程已完成，继续执行下一步。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code> 允许一组线程相互等待，直到所有线程都到达一个共同的屏障点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">partySize</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 当 3 个线程都到达屏障时，执行一个屏障动作</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(partySize, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n所有线程已到达屏障点！继续执行下一阶段。\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(partySize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; partySize; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在执行第一阶段任务...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 第一阶段任务完成，到达屏障。&quot;</span>);</span><br><span class="line">                    barrier.await(); <span class="comment">// 线程在此处等待</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在执行第二阶段任务...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h3><p><code>Semaphore</code>（信号量）用来控制对资源的并发访问数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 允许 3 个线程同时访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessResource</span><span class="params">(<span class="type">int</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 获取许可</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在访问资源...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟资源访问时间</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 访问资源完毕。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SemaphoreDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SemaphoreDemo</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; demo.accessResource(threadId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><h4 id="1-死锁演示"><a href="#1-死锁演示" class="headerlink" title="1. 死锁演示"></a>1. 死锁演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B: 已获得 lock2，尝试获取 lock1...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B: 已获得 lock1。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadA, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadB, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 死锁产生条件:</span></span><br><span class="line"><span class="comment">* 1. 互斥条件: 资源是独占的，一个线程在使用时，其他线程无法使用。</span></span><br><span class="line"><span class="comment">* 2. 请求与保持条件: 线程已经持有至少一个资源，但又请求其他资源，同时又保持对已有资源的占有。</span></span><br><span class="line"><span class="comment">* 3. 不可剥夺条件: 资源只能在持有它的线程完成任务后由它自己释放。</span></span><br><span class="line"><span class="comment">* 4. 循环等待条件: 存在一个线程资源的循环链，每个线程都在等待下一个线程所持有的资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>通过打破死锁的四个必要条件之一来预防死锁。这里通过<strong>资源有序分配</strong>来打破<strong>循环等待</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockPrevention</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 A 按顺序先获取 lock1，再获取 lock2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 B 也按顺序先获取 lock1，再获取 lock2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B: 已获得 lock1，尝试获取 lock2...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B: 已获得 lock2。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockPrevention</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockPrevention</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadA, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadB, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 两个线程都按相同的顺序获取锁，不会发生死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p><code>ThreadLocal</code> 为每个线程提供了一个独立的变量副本，实现了线程间的数据隔离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAndPrint</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置线程本地变量</span></span><br><span class="line">        threadLocal.set(value);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务</span></span><br><span class="line">            <span class="comment">// 获取并打印当前线程的变量值</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的变量值: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 最佳实践：使用完后移除，防止内存泄漏</span></span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 A 的数据&quot;</span>), <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 B 的数据&quot;</span>), <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 原理和作用:</span></span><br><span class="line"><span class="comment">* 原理: ThreadLocal 内部有一个 `ThreadLocalMap`，每个线程都有一个独立的 `ThreadLocalMap`。</span></span><br><span class="line"><span class="comment">* 当我们调用 `set()` 方法时，实际上是将值存储到了当前线程的 `ThreadLocalMap` 中，</span></span><br><span class="line"><span class="comment">* 键为 `ThreadLocal` 实例本身。</span></span><br><span class="line"><span class="comment">* 作用:</span></span><br><span class="line"><span class="comment">* 1. 数据隔离: 解决了多线程访问共享变量的线程安全问题，但其本质不是同步，而是通过“以空间换时间”的方式，</span></span><br><span class="line"><span class="comment">* 为每个线程提供独立副本，避免了竞争。</span></span><br><span class="line"><span class="comment">* 2. 传递参数: 在整个方法调用链中，无需层层传递参数，可以方便地在任何地方获取当前线程的上下文信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程安全单例-静态内部类"><a href="#线程安全单例-静态内部类" class="headerlink" title="线程安全单例 (静态内部类)"></a>线程安全单例 (静态内部类)</h3><p>静态内部类方式是实现线程安全的懒汉式单例的最佳实践之一。它利用了 JVM 类加载机制的线程安全特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonThreadSafe</span> &#123;</span><br><span class="line">    <span class="comment">// 私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonThreadSafe</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类，它只在 SingletonThreadSafe 被首次调用时才会被加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 静态成员变量，在类加载时初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonThreadSafe</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonThreadSafe</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供全局访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonThreadSafe <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 优点:</span></span><br><span class="line"><span class="comment">* 1. 线程安全: 类的加载是线程安全的，因此 INSTANCE 的初始化是原子的。</span></span><br><span class="line"><span class="comment">* 2. 懒加载: 只有在调用 getInstance() 方法时，SingletonHolder 类才会被加载，</span></span><br><span class="line"><span class="comment">* 从而实现懒加载。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a><code>ReadWriteLock</code></h3><p><code>ReadWriteLock</code> 适用于读多写少的场景，它允许多个线程同时进行读操作，但写操作必须是互斥的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sharedData</span> <span class="operator">=</span> <span class="string">&quot;初始数据&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在读取数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> (String) sharedData;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String newData)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在写入数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">// sharedData = newData; // 实际更新数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><p><code>ExecutorService</code> 的两种关闭方式：<code>shutdown()</code> 和 <code>shutdownNow()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShutdownDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交 5 个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在执行...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 被中断。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// shutdown() vs shutdownNow()</span></span><br><span class="line">        <span class="comment">// executor.shutdown(); // 优雅关闭</span></span><br><span class="line">        executor.shutdownNow(); <span class="comment">// 暴力关闭</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池已关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 区别:</span></span><br><span class="line"><span class="comment">* - shutdown(): 优雅关闭。不再接受新的任务，但会等待已提交的任务（包括正在执行和在队列中的）全部执行完毕。</span></span><br><span class="line"><span class="comment">* 执行后，isShutdown() 返回 true，isTerminated() 返回 false，直到所有任务完成。</span></span><br><span class="line"><span class="comment">* - shutdownNow(): 暴力关闭。立即停止所有正在执行的任务，并返回在队列中等待执行的任务列表。</span></span><br><span class="line"><span class="comment">* 它会向所有线程发送 interrupt() 中断信号。</span></span><br><span class="line"><span class="comment">* 执行后，isShutdown() 返回 true，isTerminated() 立即返回 true。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>一个线程通过响应 <code>interrupt()</code> 调用来正确停止自身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptedThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; <span class="comment">// 检查中断标志</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程正在执行...&quot;</span>);</span><br><span class="line">                    <span class="comment">// sleep()、wait() 等方法会抛出 InterruptedException 并清除中断标志</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程被中断！&quot;</span>);</span><br><span class="line">                    <span class="comment">// 重新设置中断标志，以便外层循环能正确退出</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">// 或者直接 return 退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程已退出。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        worker.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送中断信号</span></span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子数组求和-Subarray-Sum"><a href="#子数组求和-Subarray-Sum" class="headerlink" title="子数组求和 (Subarray Sum)"></a>子数组求和 (Subarray Sum)</h3><p>使用<strong>滑动窗口</strong>或<strong>前缀和 + 哈希表</strong>两种方式解决。这里演示前缀和 + 哈希表，它能处理负数情况且时间复杂度更优。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出和等于目标值的连续子数组。</span></span><br><span class="line"><span class="comment">     * 使用前缀和与哈希表的方式，时间复杂度为 O(n)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums   整数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到，返回子数组的起始和结束索引；否则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findSubarraySum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key: 前缀和, value: 出现该前缀和的索引</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; prefixSumMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        prefixSumMap.put(<span class="number">0</span>, -<span class="number">1</span>); <span class="comment">// 初始化，处理从数组开头开始的子数组</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            currentSum += nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否存在 (currentSum - target) 这样的前缀和</span></span><br><span class="line">            <span class="keyword">if</span> (prefixSumMap.containsKey(currentSum - target)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> prefixSumMap.get(currentSum - target) + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prefixSumMap.put(currentSum, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="字符串去重-Remove-Duplicates-from-String"><a href="#字符串去重-Remove-Duplicates-from-String" class="headerlink" title="字符串去重 (Remove Duplicates from String)"></a>字符串去重 (Remove Duplicates from String)</h3><p>使用 <code>LinkedHashSet</code> 保持相对顺序或手动遍历。这里手动遍历实现，避免使用额外数据结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对一个字符串进行去重，并保持原有字符的相对顺序。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 待去重的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 去重后的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">removeDuplicates</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">boolean</span>[] charSet = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>]; <span class="comment">// 假设为 ASCII 字符集</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!charSet[c]) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                charSet[c] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="最长不重复子串-Longest-Substring-Without-Repeating-Characters"><a href="#最长不重复子串-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="最长不重复子串 (Longest Substring Without Repeating Characters)"></a>最长不重复子串 (Longest Substring Without Repeating Characters)</h3><p>使用<strong>滑动窗口</strong>加<strong>哈希表</strong>或<strong>数组</strong>来高效解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出最长不重复子串的长度。</span></span><br><span class="line"><span class="comment">     * 使用滑动窗口（双指针）和哈希表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 输入字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长不重复子串的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key: 字符, value: 字符的最新索引</span></span><br><span class="line">        Map&lt;Character, Integer&gt; charIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 滑动窗口的左边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">currentChar</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前字符已在窗口内，更新左边界</span></span><br><span class="line">            <span class="keyword">if</span> (charIndexMap.containsKey(currentChar)) &#123;</span><br><span class="line">                left = Math.max(left, charIndexMap.get(currentChar) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            charIndexMap.put(currentChar, right);</span><br><span class="line">            maxLength = Math.max(maxLength, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="字符串转整数-String-to-Integer-atoi"><a href="#字符串转整数-String-to-Integer-atoi" class="headerlink" title="字符串转整数 (String to Integer - atoi)"></a>字符串转整数 (String to Integer - atoi)</h3><p>实现 <code>atoi</code> 函数，需要考虑各种边界情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 atoi 函数，将字符串转换为整数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换后的整数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.trim(); <span class="comment">// 1. 去掉前导空格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2. 处理正负号</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(index) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = -<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(index) == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(index);</span><br><span class="line">            <span class="comment">// 3. 检查是否为数字</span></span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(c)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            result = result * <span class="number">10</span> + digit;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 处理溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="number">1</span> &amp;&amp; result &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sign == -<span class="number">1</span> &amp;&amp; -result &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (result * sign);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="判断子串-Substring-Check"><a href="#判断子串-Substring-Check" class="headerlink" title="判断子串 (Substring Check)"></a>判断子串 (Substring Check)</h3><p>使用 <code>String.indexOf()</code> 是最直接的方式。如果不能使用内置方法，可以通过双指针或 KMP 算法实现。这里提供双指针的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个字符串是否是另一个字符串的子串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mainStr 主字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subStr  子字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果 subStr 是 mainStr 的子串，返回 true；否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSubstring</span><span class="params">(String mainStr, String subStr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mainStr == <span class="literal">null</span> || subStr == <span class="literal">null</span> || mainStr.length() &lt; subStr.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subStr.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= mainStr.length() - subStr.length(); i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; subStr.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mainStr.charAt(i + j) != subStr.charAt(j)) &#123;</span><br><span class="line">                    match = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="数组旋转-Array-Rotation"><a href="#数组旋转-Array-Rotation" class="headerlink" title="数组旋转 (Array Rotation)"></a>数组旋转 (Array Rotation)</h3><p>向右旋转 <code>k</code> 步，可以通过三次反转或使用额外数组实现。这里使用空间复杂度为 <code>O(1)</code> 的三次反转方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个整数数组向右旋转 k 步。</span></span><br><span class="line"><span class="comment">     * 使用三次反转的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 整数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k    旋转步数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k %= nums.length; <span class="comment">// 处理 k 大于数组长度的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 反转整个数组</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 2. 反转前 k 个元素</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 反转剩下的元素</span></span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="交错字符串-Interleaving-String"><a href="#交错字符串-Interleaving-String" class="headerlink" title="交错字符串 (Interleaving String)"></a>交错字符串 (Interleaving String)</h3><p>判断 <code>s3</code> 是否由 <code>s1</code> 和 <code>s2</code> 交错而成，可以使用<strong>动态规划</strong>解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两个字符串交错形成的字符串是否等于第三个字符串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1 字符串1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2 字符串2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3 字符串3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是交错字符串，返回 true；否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s1 的前 i 个字符和 s2 的前 j 个字符能否交错组成 s3 的前 i+j 个字符</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行 (s1 不取字符)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s2.length(); j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一列 (s2 不取字符)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s1.length(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充 DP 表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s2.length(); j++) &#123;</span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>)) ||</span><br><span class="line">                           (dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="最长公共前缀-Longest-Common-Prefix"><a href="#最长公共前缀-Longest-Common-Prefix" class="headerlink" title="最长公共前缀 (Longest Common Prefix)"></a>最长公共前缀 (Longest Common Prefix)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出字符串数组中的最长公共前缀。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs 字符串数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长公共前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 循环比较，直到找到子串</span></span><br><span class="line">            <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 每次缩短 prefix</span></span><br><span class="line">                prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (prefix.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="字符串压缩-String-Compression"><a href="#字符串压缩-String-Compression" class="headerlink" title="字符串压缩 (String Compression)"></a>字符串压缩 (String Compression)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现基本的字符串压缩，例如 aabcccccaaa 压缩为 a2b1c5a3。</span></span><br><span class="line"><span class="comment">     * 如果压缩后的字符串没有变短，则返回原字符串。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 待压缩的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 压缩后的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">compressString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">compressed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; str.length() &amp;&amp; str.charAt(i) == str.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                compressed.append(str.charAt(i - <span class="number">1</span>)).append(count);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (compressed.length() &gt;= str.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> str; <span class="comment">// 如果压缩后没有变短，返回原字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compressed.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="寻找重复数-Find-the-Duplicate-Number"><a href="#寻找重复数-Find-the-Duplicate-Number" class="headerlink" title="寻找重复数 (Find the Duplicate Number)"></a>寻找重复数 (Find the Duplicate Number)</h3><p>给定一个包含 <code>n+1</code> 个整数的数组，数字都在 <code>1</code> 到 <code>n</code> 的范围内。找出这个重复的数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用**快慢指针**（类似于检测链表环）来寻找重复数。</span></span><br><span class="line"><span class="comment">     * 假设数组是一个链表，索引 `i` 指向 `nums[i]`</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 包含 n+1 个整数的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 重复的数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 寻找环的入口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 找到环后，从头开始，快慢指针以相同速度前进，相遇点即为环的入口（重复数）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = nums[p1];</span><br><span class="line">            p2 = nums[p2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="链表、栈与队列"><a href="#链表、栈与队列" class="headerlink" title="链表、栈与队列"></a>链表、栈与队列</h3><h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>使用<strong>双指针</strong>方法，创建一个新的链表，遍历两个输入链表，比较节点值并依次添加到新链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个哑节点，简化操作</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                current.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将剩余的节点添加到新链表末尾</span></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            current.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            current.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表倒数第-k-个节点"><a href="#链表倒数第-k-个节点" class="headerlink" title="链表倒数第 k 个节点"></a>链表倒数第 k 个节点</h4><p>使用<strong>快慢指针</strong>，只遍历一次。快指针先走 <code>k</code> 步，然后快慢指针同时前进，当快指针到达末尾时，慢指针正好在倒数第 <code>k</code> 个位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快指针先走 k 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 链表长度小于 k</span></span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针同时前进，直到快指针到达末尾</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除重复节点"><a href="#删除重复节点" class="headerlink" title="删除重复节点"></a>删除重复节点</h4><p>给定一个已排序的链表，删除所有重复的节点，使得每个元素只出现一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.val == current.next.val) &#123;</span><br><span class="line">                current.next = current.next.next; <span class="comment">// 删除下一个重复节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.next; <span class="comment">// 前进到下一个不重复的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h4><p>使用<strong>快慢指针</strong>。如果链表有环，快指针最终会追上慢指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已经到达末尾，没有环</span></span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h4><p>两个非负整数由链表表示，每个节点包含一个数字。计算它们的和。这里假设链表按<strong>逆序</strong>存储数字（个位在前）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h4><p>使用两个栈，一个用于入队 (<code>inStack</code>)，一个用于出队 (<code>outStack</code>)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        outStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            transfer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            transfer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h4><p>使用两个队列，一个用于入栈 (<code>q1</code>)，一个用于辅助 (<code>q2</code>)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; q1;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; q2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        q1.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (q1.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            q2.offer(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> q1.poll();</span><br><span class="line">        Queue&lt;Integer&gt; temp = q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pop();</span><br><span class="line">        q1.offer(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h4><p>使用一个<strong>栈</strong>来检查括号是否匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                    (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                    (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="树与递归"><a href="#树与递归" class="headerlink" title="树与递归"></a>树与递归</h3><p>定义一个简单的二叉树节点类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树前序遍历-Preorder-Traversal"><a href="#二叉树前序遍历-Preorder-Traversal" class="headerlink" title="二叉树前序遍历 (Preorder Traversal)"></a>二叉树前序遍历 (Preorder Traversal)</h4><p><strong>递归方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">preorderTraversalRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        preorder(node.left, list);</span><br><span class="line">        preorder(node.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非递归方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">preorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="comment">// 先压入右子节点，再压入左子节点，保证弹出时先处理左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树中序遍历-Inorder-Traversal"><a href="#二叉树中序遍历-Inorder-Traversal" class="headerlink" title="二叉树中序遍历 (Inorder Traversal)"></a>二叉树中序遍历 (Inorder Traversal)</h4><p><strong>递归方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">inorderTraversalRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node.left, list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        inorder(node.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非递归方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">inorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 将所有左子节点压入栈</span></span><br><span class="line">            <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(current);</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 弹出栈顶节点，并处理其右子树</span></span><br><span class="line">            current = stack.pop();</span><br><span class="line">            result.add(current.val);</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树后序遍历-Postorder-Traversal"><a href="#二叉树后序遍历-Postorder-Traversal" class="headerlink" title="二叉树后序遍历 (Postorder Traversal)"></a>二叉树后序遍历 (Postorder Traversal)</h4><p><strong>递归方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">postorderTraversalRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(node.left, list);</span><br><span class="line">        postorder(node.right, list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非递归方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">postorderTraversalIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">// 倒序插入</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result); <span class="comment">// 将结果反转</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树层序遍历-Level-Order-Traversal"><a href="#二叉树层序遍历-Level-Order-Traversal" class="headerlink" title="二叉树层序遍历 (Level Order Traversal)"></a>二叉树层序遍历 (Level Order Traversal)</h4><p>使用<strong>队列</strong>实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">levelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; currentLevel = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                currentLevel.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currentLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对称二叉树-Symmetric-Tree"><a href="#对称二叉树-Symmetric-Tree" class="headerlink" title="对称二叉树 (Symmetric Tree)"></a>对称二叉树 (Symmetric Tree)</h4><p>使用<strong>递归</strong>，检查根节点的左右子树是否是镜像对称的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (t1.val == t2.val) &amp;&amp; isMirror(t1.right, t2.left) &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最大深度-Maximum-Depth-of-Binary-Tree"><a href="#最大深度-Maximum-Depth-of-Binary-Tree" class="headerlink" title="最大深度 (Maximum Depth of Binary Tree)"></a>最大深度 (Maximum Depth of Binary Tree)</h4><p>使用<strong>递归</strong>（深度优先搜索）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证二叉搜索树-Validate-Binary-Search-Tree"><a href="#验证二叉搜索树-Validate-Binary-Search-Tree" class="headerlink" title="验证二叉搜索树 (Validate Binary Search Tree)"></a>验证二叉搜索树 (Validate Binary Search Tree)</h4><p>使用<strong>递归</strong>或<strong>中序遍历</strong>。二叉搜索树的中序遍历结果是升序的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查当前节点的值是否在有效范围内</span></span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归检查左右子树，并缩小有效范围</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(node.left, min, node.val) &amp;&amp; isValidBST(node.right, node.val, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="最大子数组和-Maximum-Subarray-Sum"><a href="#最大子数组和-Maximum-Subarray-Sum" class="headerlink" title="最大子数组和 (Maximum Subarray Sum)"></a>最大子数组和 (Maximum Subarray Sum)</h4><p>使用<strong>动态规划</strong> (Kadane’s algorithm)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSoFar</span> <span class="operator">=</span> nums[<span class="number">0</span>]; <span class="comment">// 迄今为止的最大和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxEndingHere</span> <span class="operator">=</span> nums[<span class="number">0</span>]; <span class="comment">// 以当前位置结尾的最大和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// maxEndingHere 的值是：(当前元素) 或 (当前元素 + 之前的最大和)</span></span><br><span class="line">            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);</span><br><span class="line">            maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两数相加-Large-Number-Addition"><a href="#两数相加-Large-Number-Addition" class="headerlink" title="两数相加 (Large Number Addition)"></a>两数相加 (Large Number Addition)</h4><p>将两个超长正整数字符串相加，模拟小学加法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit1</span> <span class="operator">=</span> (i &gt;= <span class="number">0</span>) ? num1.charAt(i--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit2</span> <span class="operator">=</span> (j &gt;= <span class="number">0</span>) ? num2.charAt(j--) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> digit1 + digit2 + carry;</span><br><span class="line">            sb.append(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="位运算实现加法-Addition-with-Bitwise-Operators"><a href="#位运算实现加法-Addition-with-Bitwise-Operators" class="headerlink" title="位运算实现加法 (Addition with Bitwise Operators)"></a>位运算实现加法 (Addition with Bitwise Operators)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        <span class="type">int</span> carry;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算无进位的和（异或）</span></span><br><span class="line">            sum = a ^ b;</span><br><span class="line">            <span class="comment">// 计算进位（与&amp;左移）</span></span><br><span class="line">            carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="全排列-Permutations"><a href="#全排列-Permutations" class="headerlink" title="全排列 (Permutations)"></a>全排列 (Permutations)</h4><p>使用<strong>回溯算法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BacktrackingProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrackPermute(result, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtrackPermute</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList, <span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempList.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrackPermute(result, tempList, nums, used);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="子集-Subsets"><a href="#子集-Subsets" class="headerlink" title="子集 (Subsets)"></a>子集 (Subsets)</h4><p>使用<strong>回溯算法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BacktrackingProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrackSubsets(result, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtrackSubsets</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; tempList, <span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrackSubsets(result, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跳台阶-Climbing-Stairs"><a href="#跳台阶-Climbing-Stairs" class="headerlink" title="跳台阶 (Climbing Stairs)"></a>跳台阶 (Climbing Stairs)</h4><p>这是经典的<strong>动态规划</strong>问题，与斐波那契数列类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现一个简单的-Trie-前缀树"><a href="#实现一个简单的-Trie-前缀树" class="headerlink" title="实现一个简单的 Trie (前缀树)"></a>实现一个简单的 Trie (前缀树)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    Map&lt;Character, TrieNode&gt; children;</span><br><span class="line">    <span class="type">boolean</span> isEndOfWord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        isEndOfWord = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            current = current.children.computeIfAbsent(c, k -&gt; <span class="keyword">new</span> <span class="title class_">TrieNode</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        current.isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!current.children.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.children.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!current.children.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.children.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反转链表-II-Reverse-Linked-List-II"><a href="#反转链表-II-Reverse-Linked-List-II" class="headerlink" title="反转链表 II (Reverse Linked List II)"></a>反转链表 II (Reverse Linked List II)</h4><p>反转链表从位置 <code>m</code> 到 <code>n</code> 的部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre.next; <span class="comment">// 移动到反转部分的前一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next; <span class="comment">// 反转部分的起始节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">then</span> <span class="operator">=</span> start.next; <span class="comment">// 待反转的第二个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">            start.next = then.next;</span><br><span class="line">            then.next = pre.next;</span><br><span class="line">            pre.next = then;</span><br><span class="line">            then = start.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LRU-缓存-LRU-Cache"><a href="#LRU-缓存-LRU-Cache" class="headerlink" title="LRU 缓存 (LRU Cache)"></a>LRU 缓存 (LRU Cache)</h4><p>使用 <code>LinkedHashMap</code> 可以非常方便地实现 LRU 缓存，因为它本身就维护了插入顺序或访问顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity, <span class="number">0.75f</span>, <span class="literal">true</span>); <span class="comment">// true 表示按访问顺序排序</span></span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="comment">// 当容量超过限制时，自动移除最老的（最久未访问的）条目</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getOrDefault(key, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断回文链表-Palindrome-Linked-List"><a href="#判断回文链表-Palindrome-Linked-List" class="headerlink" title="判断回文链表 (Palindrome Linked List)"></a>判断回文链表 (Palindrome Linked List)</h4><p>可以使用快慢指针找到中点，然后反转后半部分，最后比较两部分是否相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListProblems</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 快慢指针找中点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转后半部分</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">secondHalf</span> <span class="operator">=</span> reverseList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 比较前半部分和反转后的后半部分</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">firstHalf</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (secondHalf != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstHalf.val != secondHalf.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            firstHalf = firstHalf.next;</span><br><span class="line">            secondHalf = secondHalf.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextTemp</span> <span class="operator">=</span> current.next;</span><br><span class="line">            current.next = prev;</span><br><span class="line">            prev = current;</span><br><span class="line">            current = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ReadWriteLock-1"><a href="#ReadWriteLock-1" class="headerlink" title="ReadWriteLock"></a><code>ReadWriteLock</code></h3><p><code>ReadWriteLock</code> 允许多个线程同时进行读操作，但只允许一个线程进行写操作，从而提高读多写少的场景下的并发性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;初始数据&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作：允许多个线程同时访问</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwLock.readLock().lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在读取数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作：同一时刻只能有一个线程访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String newData)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在写入数据...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h3><p><code>CountDownLatch</code> 允许一个线程等待，直到其他线程都完成了某项工作。它就像一个倒计时器，一旦计数为零，等待的线程就会被唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 创建一个计数器，初始值为 5</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(workerCount);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：启动 &quot;</span> + workerCount + <span class="string">&quot; 个工作线程...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 开始执行任务...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">2000</span>)); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;工作线程 &quot;</span> + workerId + <span class="string">&quot; 任务完成。&quot;</span>);</span><br><span class="line">                    latch.countDown(); <span class="comment">// 任务完成后，计数器减 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：等待所有工作线程完成...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 阻塞主线程，直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：所有工作线程已完成，继续执行下一步。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="CyclicBarrier-1"><a href="#CyclicBarrier-1" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code> 允许一组线程在到达一个共同的屏障点后，再一起继续执行。它就像赛跑的起跑线，所有选手都准备好后，发令枪才响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">runnerCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 创建一个屏障，当 3 个线程都到达时，执行一个屏障动作</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(runnerCount, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n所有赛跑者都已就位，发令枪响！\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(runnerCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; runnerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">runnerId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;赛跑者 &quot;</span> + runnerId + <span class="string">&quot; 正在走向起跑线...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">3000</span>)); <span class="comment">// 模拟准备时间</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;赛跑者 &quot;</span> + runnerId + <span class="string">&quot; 到达起跑线，准备就绪。&quot;</span>);</span><br><span class="line">                    barrier.await(); <span class="comment">// 线程在此处等待，直到所有线程都到达</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;赛跑者 &quot;</span> + runnerId + <span class="string">&quot; 开始跑步！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Semaphore-1"><a href="#Semaphore-1" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h3><p><code>Semaphore</code>（信号量）用来控制对某个资源的并发访问数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 停车场最多允许 3 辆车停放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">int</span> carId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;汽车 &quot;</span> + carId + <span class="string">&quot; 正在寻找车位...&quot;</span>);</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">            System.out.println(<span class="string">&quot;汽车 &quot;</span> + carId + <span class="string">&quot; 成功进入停车场。&quot;</span>);</span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">3000</span>)); <span class="comment">// 模拟停车时间</span></span><br><span class="line">            System.out.println(<span class="string">&quot;汽车 &quot;</span> + carId + <span class="string">&quot; 离开停车场。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SemaphoreDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SemaphoreDemo</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>); <span class="comment">// 10 辆车</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">carId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; demo.park(carId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="死锁预防-按锁顺序"><a href="#死锁预防-按锁顺序" class="headerlink" title="死锁预防 (按锁顺序)"></a>死锁预防 (按锁顺序)</h3><p>通过<strong>资源有序分配</strong>来打破死锁的<strong>循环等待</strong>条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadlockPrevention</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 1: 已获得 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 1: 已获得 lockB。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 两个线程都按相同的顺序（先 A 后 B）获取锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 2: 已获得 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 2: 已获得 lockB。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadlockPrevention</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadlockPrevention</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadOne, <span class="string">&quot;Thread-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::threadTwo, <span class="string">&quot;Thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程池异常"><a href="#线程池异常" class="headerlink" title="线程池异常"></a>线程池异常</h3><p>使用 <code>Future.get()</code> 或在任务中捕获异常来处理线程池中任务抛出的异常。<code>execute()</code> 方法无法直接捕获异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPoolExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交一个会抛出运行时异常的任务</span></span><br><span class="line">        Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;这是一个模拟的任务执行异常。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取任务结果来捕获异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;捕获到任务执行异常：&quot;</span> + e.getCause().getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 execute() 提交任务，异常会被吞掉，除非自定义 UncaughtExceptionHandler</span></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;另一个任务开始执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;这个异常会被吞掉。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ThreadLocal-1"><a href="#ThreadLocal-1" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p><code>ThreadLocal</code> 为每个线程提供了独立的变量副本，实现了数据隔离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAndPrint</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        threadLocal.set(value); <span class="comment">// 设置当前线程的变量副本</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的变量值: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadLocal.remove(); <span class="comment">// 最佳实践：使用完后移除，防止内存泄漏</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 A 的数据&quot;</span>), <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.setAndPrint(<span class="string">&quot;线程 B 的数据&quot;</span>), <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a><code>LockSupport</code></h3><p><code>LockSupport.park()</code> 和 <code>LockSupport.unpark()</code> 提供了更灵活的线程阻塞和唤醒机制，类似于 <code>wait()</code> 和 <code>notify()</code>，但不需要依赖锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockSupportDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;工作线程: 任务准备就绪，即将阻塞...&quot;</span>);</span><br><span class="line">            LockSupport.park(); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            System.out.println(<span class="string">&quot;工作线程: 被唤醒，继续执行。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        workerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 确保工作线程已执行 park()</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 唤醒工作线程。&quot;</span>);</span><br><span class="line">        LockSupport.unpark(workerThread); <span class="comment">// 唤醒指定线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程通信-按顺序打印"><a href="#线程通信-按顺序打印" class="headerlink" title="线程通信 (按顺序打印)"></a>线程通信 (按顺序打印)</h3><p>使用 <code>wait()</code> 和 <code>notifyAll()</code> 实现三个线程按顺序打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SequentialPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 0: A, 1: B, 2: C</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String letter, <span class="type">int</span> expectedState)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (state != expectedState) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(letter);</span><br><span class="line">                state = (state + <span class="number">1</span>) % <span class="number">3</span>; <span class="comment">// 切换到下一个状态</span></span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SequentialPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequentialPrinter</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printA);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printB);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printC);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line"></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line">        threadC.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n打印完成。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="ThreadPoolExecutor-的七个参数"><a href="#ThreadPoolExecutor-的七个参数" class="headerlink" title="ThreadPoolExecutor 的七个参数"></a><code>ThreadPoolExecutor</code> 的七个参数</h4><ol>
<li><code>corePoolSize</code>: 核心线程数。线程池中常驻的线程数量，即使空闲也不会被销毁。</li>
<li><code>maximumPoolSize</code>: 最大线程数。当工作队列已满，且任务量继续增加时，线程池可以创建的最大线程数。</li>
<li><code>keepAliveTime</code>: 空闲线程存活时间。当线程数大于 <code>corePoolSize</code> 时，非核心线程的空闲存活时间。</li>
<li><code>unit</code>: <code>keepAliveTime</code> 的时间单位。</li>
<li><code>workQueue</code>: 工作队列。用于存放等待执行的任务，常用的有 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等。</li>
<li><code>threadFactory</code>: 线程工厂。用于创建新线程，可以自定义线程的名称、优先级等。</li>
<li><code>handler</code>: 拒绝策略。当线程池和工作队列都已满时，用于处理新来的任务，例如抛出异常、由调用者执行等。</li>
</ol>
<h4 id="手写一个自定义线程池"><a href="#手写一个自定义线程池" class="headerlink" title="手写一个自定义线程池"></a>手写一个自定义线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">5</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">60L</span>, <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), <span class="comment">// 工作队列容量为 10</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 默认线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略：由调用者线程执行</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在由线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 执行。&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>使用 <code>AtomicBoolean</code> 或 <code>AtomicReference</code> 解决并发问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicBooleanDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 确保只有一个线程执行初始化操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 只有当 initialized 为 false 时，才将其设置为 true 并执行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialized.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 开始执行初始化操作...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 初始化完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 初始化已被其他线程执行，跳过。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(AtomicBooleanDemo::initialize, <span class="string">&quot;Thread-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="volatile-内存语义"><a href="#volatile-内存语义" class="headerlink" title="volatile 内存语义"></a><code>volatile</code> 内存语义</h3><p><code>volatile</code> 确保了<strong>可见性</strong>和<strong>有序性</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileMemorySemantics</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 可见性：当一个线程修改了 ready 的值，其他线程能立即看到最新值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriterThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            number = <span class="number">42</span>; <span class="comment">// 修改 number</span></span><br><span class="line">            ready = <span class="literal">true</span>; <span class="comment">// 修改 ready</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="comment">// 等待 ready 变为 true</span></span><br><span class="line">                <span class="comment">// 如果没有 volatile，这里可能会陷入死循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 有序性：写 volatile 变量（ready = true）之前的操作（number = 42）</span></span><br><span class="line">            <span class="comment">// 对其他线程都是可见的。保证了 number 的值是 42。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读取到的 number 值: &quot;</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WriterThread</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="中断机制-1"><a href="#中断机制-1" class="headerlink" title="中断机制"></a>中断机制</h3><p>一个线程通过响应 <code>interrupt()</code> 调用来正确停止自身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptibleThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; <span class="comment">// 检查中断标志</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程正在执行...&quot;</span>);</span><br><span class="line">                    <span class="comment">// sleep()、wait() 等方法会抛出 InterruptedException 并清除中断标志</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程被中断，即将退出...&quot;</span>);</span><br><span class="line">                    <span class="comment">// 重新设置中断标志，以便外层循环能正确退出</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">// 或者直接 break 或 return 退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程已优雅地退出。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        worker.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程: 发送中断信号。&quot;</span>);</span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h3><p><code>ConcurrentHashMap</code> 的并发原理是**分段锁（ 7）**或 <strong>CAS + Synchronized（ 8）</strong>，只对操作的桶进行锁定，大大提高了并发性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcurrentHashMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 10 个线程，每个线程向 map 中添加 1000 个键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key-&quot;</span> + (threadId * <span class="number">1000</span> + j);</span><br><span class="line">                    map.put(key, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终 map 的大小: &quot;</span> + map.size()); <span class="comment">// 期望值为 10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a><code>ForkJoinPool</code></h3><p><code>ForkJoinPool</code> 是一个用于分治任务的线程池，<code>RecursiveTask</code> 是可返回结果的分治任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 任务分解的阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SumTask</span><span class="params">(<span class="type">long</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务规模小于等于阈值，则直接计算</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，将任务分解成两个子任务</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, start, mid);</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, mid, end);</span><br><span class="line"></span><br><span class="line">            leftTask.fork(); <span class="comment">// 提交左子任务</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.compute(); <span class="comment">// 同步计算右子任务</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join(); <span class="comment">// 等待左子任务结果</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] array = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">1000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br><span class="line">        System.out.println(<span class="string">&quot;大数组的和为: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-语言基础"><a href="#1-语言基础" class="headerlink" title="1.  语言基础"></a>1.  语言基础</h3><h4 id="变量与数据类型"><a href="#变量与数据类型" class="headerlink" title="变量与数据类型"></a>变量与数据类型</h4><p> 的基本数据类型决定了变量可以存储的数据范围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTypesDetailed</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 整数类型：默认为 int</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 占用 1 字节，-128 到 127</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 占用 2 字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100000</span>; <span class="comment">// 占用 4 字节</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">10000000000L</span>; <span class="comment">// 占用 8 字节，需要 L 或 l 后缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浮点类型：默认为 double</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.14f</span>; <span class="comment">// 占用 4 字节，需要 f 或 F 后缀</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.1415926535</span>; <span class="comment">// 占用 8 字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符类型</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 单个字符，占用 2 字节</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">65</span>; <span class="comment">// 也可以使用 ASCII 码或 Unicode</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1 和 c2 是否相等？ &quot;</span> + (c1 == c2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 布尔类型</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFun</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;学Java有趣吗？&quot;</span> + isFun);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p> 中，从小范围类型向大范围类型转换是<strong>自动</strong>的（隐式转换）；从大范围向小范围转换需要<strong>强制</strong>转换（显式转换），可能造成数据丢失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeCasting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 隐式转换：int -&gt; long</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">myInt</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">myLong</span> <span class="operator">=</span> myInt;</span><br><span class="line">        System.out.println(<span class="string">&quot;隐式转换后的 long 类型: &quot;</span> + myLong);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式转换：double -&gt; int</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">myDouble</span> <span class="operator">=</span> <span class="number">9.99</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">myInteger</span> <span class="operator">=</span> (<span class="type">int</span>) myDouble; <span class="comment">// 强制转换，小数部分被丢弃</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显式转换后的 int 类型: &quot;</span> + myInteger); <span class="comment">// 输出 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是存储<strong>固定大小</strong>同类型元素的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明并初始化一个整数数组</span></span><br><span class="line">        <span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 创建一个长度为 5 的数组</span></span><br><span class="line">        numbers[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        numbers[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明、初始化并赋值</span></span><br><span class="line">        String[] fruits = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有水果:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String fruit : fruits) &#123; <span class="comment">// 增强 for 循环</span></span><br><span class="line">            System.out.println(fruit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-面向对象编程-OOP"><a href="#2-面向对象编程-OOP" class="headerlink" title="2. 面向对象编程 (OOP)"></a>2. 面向对象编程 (OOP)</h3><h4 id="构造方法与方法重载"><a href="#构造方法与方法重载" class="headerlink" title="构造方法与方法重载"></a>构造方法与方法重载</h4><p><strong>构造方法</strong>是一种特殊方法，用于创建对象时初始化。<strong>方法重载</strong>是指在同一个类中，方法名相同但参数列表不同（参数类型、数量或顺序）的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;未知&quot;</span>, <span class="number">0</span>, <span class="string">&quot;000&quot;</span>); <span class="comment">// 调用本类的三参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = <span class="string">&quot;000&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法重载: 计算两个数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承、多态与抽象"><a href="#继承、多态与抽象" class="headerlink" title="继承、多态与抽象"></a>继承、多态与抽象</h4><p>继承实现代码复用，多态实现行为多样化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类：抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String brand; <span class="comment">// 子类可以访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vehicle</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;品牌是: &quot;</span> + brand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：继承 Vehicle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汽车正在路上行驶...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：继承 Vehicle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bicycle</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bicycle</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自行车正在骑行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphismDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;BMW&quot;</span>); <span class="comment">// 多态引用</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">myBicycle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bicycle</span>(<span class="string">&quot;Giant&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个方法调用，不同行为</span></span><br><span class="line">        myCar.run(); <span class="comment">// 输出 &quot;汽车正在路上行驶...&quot;</span></span><br><span class="line">        myBicycle.run(); <span class="comment">// 输出 &quot;自行车正在骑行...&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-核心类库"><a href="#3-核心类库" class="headerlink" title="3.  核心类库"></a>3.  核心类库</h3><p>好的，这次我们将把<strong>各种方法的使用代码</strong>直接嵌入到每个知识点的解释中，让您在学习概念的同时，就能看到具体的代码实现和效果。我们将专注于<strong>数组、字符串和集合</strong>这三大核心部分，把它们的创建、遍历、和各种常用方法的代码示例都清晰地展示出来。</p>
<hr>
<h3 id="1-数组（Array）"><a href="#1-数组（Array）" class="headerlink" title="1. 数组（Array）"></a>1. 数组（Array）</h3><p>数组是一种固定大小的、用于存储同类型元素的容器。</p>
<h4 id="创建和遍历"><a href="#创建和遍历" class="headerlink" title="创建和遍历"></a>创建和遍历</h4><p>这里展示两种最常见的创建数组的方式，并使用两种循环进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式一：声明并分配空间，系统赋默认值</span></span><br><span class="line">        <span class="type">int</span>[] intArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">// 创建一个包含3个整数的数组，默认值都是0</span></span><br><span class="line">        intArray[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        intArray[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">        intArray[<span class="number">2</span>] = <span class="number">30</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;数组 intArray 的第一个元素是: &quot;</span> + intArray[<span class="number">0</span>]); <span class="comment">// 输出: 10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式二：声明并直接初始化</span></span><br><span class="line">        String[] stringArray = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;Java&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方式一：使用 for 循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 使用 for 循环遍历 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringArray.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stringArray[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + stringArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历方式二：使用增强 for 循环（更简洁）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 使用增强 for 循环遍历 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : stringArray) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;元素: &quot;</span> + element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Arrays-类的常用方法"><a href="#Arrays-类的常用方法" class="headerlink" title="Arrays 类的常用方法"></a><code>Arrays</code> 类的常用方法</h4><p><code>java.util.Arrays</code> 类提供了很多静态方法，方便我们对数组进行操作，比如排序、查找、复制等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysMethodExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 排序：Arrays.sort()</span></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后: &quot;</span> + Arrays.toString(numbers)); <span class="comment">// 输出: [1, 2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 查找：Arrays.binarySearch() (必须先排序)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素 6 的索引是: &quot;</span> + index); <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 填充：Arrays.fill()</span></span><br><span class="line">        <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        Arrays.fill(newArray, <span class="number">99</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;填充后: &quot;</span> + Arrays.toString(newArray)); <span class="comment">// 输出: [99, 99, 99, 99, 99]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 复制：Arrays.copyOf()</span></span><br><span class="line">        <span class="type">int</span>[] copiedArray = Arrays.copyOf(numbers, <span class="number">3</span>); <span class="comment">// 复制前3个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;复制前3个元素: &quot;</span> + Arrays.toString(copiedArray)); <span class="comment">// 输出: [1, 2, 4]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 比较：Arrays.equals()</span></span><br><span class="line">        <span class="type">int</span>[] anotherArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;两个数组是否相等: &quot;</span> + Arrays.equals(numbers, anotherArray)); <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-字符串（String）"><a href="#2-字符串（String）" class="headerlink" title="2. 字符串（String）"></a>2. 字符串（String）</h3><p><code>String</code> 是一个不可变的字符序列，这意味着一旦创建，它的内容就不能被修改。所有修改操作都会返回一个新的 <code>String</code> 对象。</p>
<h4 id="创建和常用方法"><a href="#创建和常用方法" class="headerlink" title="创建和常用方法"></a>创建和常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;  Java is a great language. &quot;</span>; <span class="comment">// 字面量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java is a great language.&quot;</span>); <span class="comment">// 使用 new 关键字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常用方法</span></span><br><span class="line">        <span class="comment">// 1. 获取长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str1.length();</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度: &quot;</span> + length); <span class="comment">// 输出: 29</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 访问字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> str1.charAt(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第3个字符是: &quot;</span> + firstChar); <span class="comment">// 输出: J</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 截取子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> str1.substring(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;截取子串: &quot;</span> + sub); <span class="comment">// 输出: is</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 查找位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str1.indexOf(<span class="string">&quot;great&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&#x27;great&#x27; 的索引: &quot;</span> + index); <span class="comment">// 输出: 11</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 判断</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> str1.contains(<span class="string">&quot;language&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含 &#x27;language&#x27;: &quot;</span> + contains); <span class="comment">// 输出: true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">startsWith</span> <span class="operator">=</span> str1.startsWith(<span class="string">&quot;  Java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否以 &#x27;  Java&#x27; 开头: &quot;</span> + startsWith); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 替换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">replacedStr</span> <span class="operator">=</span> str1.replace(<span class="string">&quot;great&quot;</span>, <span class="string">&quot;wonderful&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;替换后: &quot;</span> + replacedStr); <span class="comment">// 输出:   Java is a wonderful language. </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 大小写转换和去空格</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">trimmedStr</span> <span class="operator">=</span> str1.trim();</span><br><span class="line">        System.out.println(<span class="string">&quot;去除首尾空格: &#x27;&quot;</span> + trimmedStr + <span class="string">&quot;&#x27;&quot;</span>); <span class="comment">// 输出: &#x27;Java is a great language.&#x27;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;转为大写: &quot;</span> + trimmedStr.toUpperCase());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 8. 分割和连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line">        String[] fruits = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;分割后: &quot;</span> + Arrays.toString(fruits)); <span class="comment">// 输出: [apple, banana, orange]</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">joinedString</span> <span class="operator">=</span> String.join(<span class="string">&quot; - &quot;</span>, fruits);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接后: &quot;</span> + joinedString); <span class="comment">// 输出: apple - banana - orange</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StringBuilder-和-StringBuffer"><a href="#StringBuilder-和-StringBuffer" class="headerlink" title="StringBuilder 和 StringBuffer"></a><code>StringBuilder</code> 和 <code>StringBuffer</code></h4><p>对于需要频繁修改字符串的场景，应使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 以提高性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 追加内容</span></span><br><span class="line">        sb.append(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;追加后: &quot;</span> + sb); <span class="comment">// 输出: Hello World</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 插入内容</span></span><br><span class="line">        sb.insert(<span class="number">6</span>, <span class="string">&quot;Beautiful &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;插入后: &quot;</span> + sb); <span class="comment">// 输出: Hello Beautiful World</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 删除内容</span></span><br><span class="line">        sb.delete(<span class="number">6</span>, <span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + sb); <span class="comment">// 输出: Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-集合（Collections）"><a href="#3-集合（Collections）" class="headerlink" title="3. 集合（Collections）"></a>3. 集合（Collections）</h3><p>Java 集合框架提供了强大的数据结构来存储和操作对象。</p>
<h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a><strong>List</strong>（列表）</h4><p><code>List</code> 是一种有序、可重复的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 ArrayList（查询快）</span></span><br><span class="line">        List&lt;String&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        fruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 添加元素</span></span><br><span class="line">        fruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        fruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 允许重复</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;列表元素: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Banana, Apple]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个元素: &quot;</span> + fruits.get(<span class="number">0</span>)); <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;列表大小: &quot;</span> + fruits.size());</span><br><span class="line"></span><br><span class="line">        fruits.set(<span class="number">1</span>, <span class="string">&quot;Grape&quot;</span>); <span class="comment">// 替换第二个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;替换后: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Grape, Apple]</span></span><br><span class="line"></span><br><span class="line">        fruits.remove(<span class="number">1</span>); <span class="comment">// 删除第二个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + fruits); <span class="comment">// 输出: [Apple, Apple]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Set（集）"><a href="#Set（集）" class="headerlink" title="Set（集）"></a><strong>Set</strong>（集）</h4><p><code>Set</code> 是一种无序、不可重复的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashSet</span></span><br><span class="line">        Set&lt;String&gt; uniqueFruits = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        uniqueFruits.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 添加重复元素，会失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;集合元素: &quot;</span> + uniqueFruits); <span class="comment">// 输出: [Apple, Banana] (顺序不定)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">containsBanana</span> <span class="operator">=</span> uniqueFruits.contains(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含 &#x27;Banana&#x27;: &quot;</span> + containsBanana); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">        uniqueFruits.remove(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后: &quot;</span> + uniqueFruits); <span class="comment">// 输出: [Apple]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Map（映射）"><a href="#Map（映射）" class="headerlink" title="Map（映射）"></a><strong>Map</strong>（映射）</h4><p><code>Map</code> 存储键值对，键是唯一的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap</span></span><br><span class="line">        Map&lt;String, Integer&gt; studentScores = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        studentScores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">95</span>); <span class="comment">// 添加键值对</span></span><br><span class="line">        studentScores.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">88</span>);</span><br><span class="line">        studentScores.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">100</span>); <span class="comment">// 键已存在，会覆盖旧值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Alice 的分数: &quot;</span> + studentScores.get(<span class="string">&quot;Alice&quot;</span>)); <span class="comment">// 输出: 100</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历 Map 的三种方式</span></span><br><span class="line">        <span class="comment">// 方式一：遍历键集</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历键集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : studentScores.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名: &quot;</span> + name + <span class="string">&quot;, 分数: &quot;</span> + studentScores.get(name));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式二：遍历值集</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历值集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer score : studentScores.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分数: &quot;</span> + score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式三：遍历键值对集 (Entry Set)，最常用且高效</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 遍历键值对集 ---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : studentScores.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名: &quot;</span> + entry.getKey() + <span class="string">&quot;, 分数: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/11/%E6%89%8B%E5%86%99%E7%AD%94%E6%A1%88/" data-id="cmffake6r000j50uygblnaor5" data-title="手写答案" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo-Markdown/" rel="tag">Hexo, Markdown</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-基础背诵" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/11/%E5%9F%BA%E7%A1%80%E8%83%8C%E8%AF%B5/" class="article-date">
  <time class="dt-published" datetime="2025-09-11T10:29:28.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/11/%E5%9F%BA%E7%A1%80%E8%83%8C%E8%AF%B5/">基础背诵</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>OSI (Open Systems Interconnection) 参考模型是一个抽象的、概念性的框架，旨在定义网络通信的功能分层，促进不同系统之间的互操作性。它将网络通信过程分为七个独立的层次，每层负责特定的功能。数据在发送端从上层向下层传输，每层添加自己的控制信息（封装），在接收端则从下层向上层传输，每层剥离对应的控制信息（解封装）。</p>
<ol>
<li><h3 id="物理层-Physical-Layer"><a href="#物理层-Physical-Layer" class="headerlink" title="物理层 (Physical Layer)"></a>物理层 (Physical Layer)</h3></li>
</ol>
<ul>
<li>功能：负责传输比特流，即原始的二进制数据。定义了物理媒介的电气特性、机械特性、功能特性和过程特性。</li>
<li>工作方式：不关心比特的含义，只负责将其从一个节点传输到另一个节点。例如，规定网络的接口形状、电压、传输速率等。</li>
<li>协议&#x2F;设备：网线 (Ethernet Cable)、光纤 (Fiber Optic)、集线器 (Hub)、中继器 (Repeater)、网卡 (NIC) 的物理部分。</li>
<li>数据单位：比特 (Bit)。</li>
</ul>
<ol start="2">
<li><h3 id="数据链路层-Data-Link-Layer"><a href="#数据链路层-Data-Link-Layer" class="headerlink" title="数据链路层 (Data Link Layer)"></a>数据链路层 (Data Link Layer)</h3></li>
</ol>
<ul>
<li>功能：在物理层提供的不可靠比特流服务的基础上，将比特组合成帧，提供节点到节点之间的数据传输。负责差错控制（检测和纠正帧传输错误）、流量控制（防止发送方传输速度过快）和物理寻址 (MAC 地址）。</li>
<li>子层：通常分为 LLC (Logical Link Control) 子层（负责逻辑链路控制，向上层提供服务接口）和 MAC (Media Access Control) 子层（负责媒体访问控制，处理共享介质的访问，例如 CSMA&#x2F;CD 协议）。</li>
<li>工作方式：在局域网内，通过 MAC 地址识别不同的设备，确保数据能够正确地在相邻节点之间传输。</li>
<li>协议&#x2F;设备：Ethernet、PPP (Point-to-Point Protocol)、交换机 (Switch)、网桥 (Bridge)。</li>
<li>数据单位：帧 (Frame)。</li>
</ul>
<ol start="3">
<li><h3 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层 (Network Layer)"></a>网络层 (Network Layer)</h3></li>
</ol>
<ul>
<li>功能：负责将数据包从源主机传输到目标主机，可能需要跨越多个网络（即路由）。主要功能包括逻辑寻址 (IP 地址)、路由选择（确定数据包传输路径）和拥塞控制。</li>
<li>工作方式：根据数据包中的 IP 地址，通过路由表决定数据包的转发路径，使其能够跨越不同的网络到达最终目的地。</li>
<li>协议&#x2F;设备：IP (Internet Protocol)、ICMP (Internet Control Message Protocol，用于错误报告和查询)、IGMP (Internet Group Management Protocol，用于多播组管理)、路由器 (Router)。</li>
<li>数据单位：数据包 (Packet) 或 数据报 (Datagram)。</li>
</ul>
<ol start="4">
<li><h3 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层 (Transport Layer)"></a>传输层 (Transport Layer)</h3></li>
</ol>
<ul>
<li>功能：负责端到端 (End-to-End) 的数据传输，即从源主机上的某个进程到目标主机上的某个进程的通信。提供分段与重组、错误检测、流量控制和拥塞控制。</li>
<li>工作方式：通过端口号来标识应用进程，使得数据能够正确地交付给目标主机上的特定应用程序。</li>
<li>协议&#x2F;设备：<ul>
<li>TCP (Transmission Control Protocol)：面向连接、可靠的、基于字节流的服务，提供顺序、无损的数据传输。</li>
<li>UDP (User Datagram Protocol)：无连接、不可靠的数据报服务，速度快，开销小，适用于对实时性要求高但允许少量丢包的应用（如音视频传输）。</li>
</ul>
</li>
<li>数据单位：报文段 (Segment) (TCP) 或 用户数据报 (Datagram) (UDP)。</li>
</ul>
<ol start="5">
<li><h3 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层 (Session Layer)"></a>会话层 (Session Layer)</h3></li>
</ol>
<ul>
<li>功能：负责管理和协调应用程序之间的会话(对话)。包括建立、管理和终止会话，以及数据同步(如设置同步点，在网络故障时从上一个同步点恢复)。</li>
<li>工作方式：提供了一种机制，使得应用程序可以有条不紊地进行通信，例如，在一次文件传输中，可以在传输中断后从断点续传。</li>
<li>协议&#x2F;设备：NetBIOS, RPC (Remote Procedure Call), SQL, NFS。</li>
<li>数据单位：会话数据 (Session Data)。</li>
</ul>
<ol start="6">
<li><h3 id="表示层-Presentation-Layer"><a href="#表示层-Presentation-Layer" class="headerlink" title="表示层 (Presentation Layer)"></a>表示层 (Presentation Layer)</h3></li>
</ol>
<ul>
<li>功能：负责处理两个系统之间的数据表示，确保应用程序层接收到的信息是可用的。包括数据格式化、数据加密&#x2F;解密、数据压缩&#x2F;解压缩。</li>
<li>工作方式：将应用层的数据转换为网络标准格式(如 ASCII 转 EBCDIC)，或将网络格式的数据转换为应用层可用的格式。例如，JPEG, MPEG 等图像视频格式的处理，以及 SSL&#x2F;TLS 加密解密。</li>
<li>协议&#x2F;设备：JPEG, MPEG, ASCII, Unicode, TLS&#x2F;SSL (通常认为 TLS&#x2F;SSL 位于会话层与表示层之间，或独立于此)。</li>
<li>数据单位：表示数据 (Presentation Data)。</li>
</ul>
<ol start="7">
<li><h3 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层 (Application Layer)"></a>应用层 (Application Layer)</h3></li>
</ol>
<ul>
<li>功能：最靠近用户的一层，为用户提供网络服务。直接与用户应用程序进行交互，负责处理特定的应用程序细节。</li>
<li>工作方式：定义了应用程序如何访问网络服务，以及不同应用程序之间如何交换数据。</li>
<li>协议&#x2F;设备：HTTP (Web 浏览)、FTP (文件传输)、SMTP (电子邮件发送)、POP3&#x2F;IMAP (电子邮件接收)、DNS (域名解析)、Telnet, SNMP (简单网络管理协议)等。</li>
<li>数据单位：应用数据 (Application Data)。</li>
</ul>
<h2 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP&#x2F;IP 协议族"></a>TCP&#x2F;IP 协议族</h2><p>TCP&#x2F;IP 模型是互联网的基础，它简化了 OSI 模型，通常分为四层：应用层、传输层、网络层、网络接口层（数据链路层和物理层合并）。我重点阐述其中的核心协议：</p>
<ul>
<li>TCP（传输控制协议）：我理解 TCP 是一种可靠的、面向连接的、基于字节流的传输协议。其可靠性通过以下机制实现：<ul>
<li><p>三次握手：这是 TCP 建立连接的过程，旨在确保通信双方都能正常收发数据，并协商初始序列号。这个过程就像打电话：</p>
<ol>
<li>第一次握手 (SYN)：</li>
</ol>
<ul>
<li>发起方：客户端。</li>
<li>报文类型：SYN 报文段 (SYN_FLAG&#x3D;1)。SYN 标志位表示请求建立连接。</li>
<li>序列号 (Sequence Number)：客户端随机生成一个初始序列号 client_ISN。这个序列号代表客户端接下来发送数据的第一个字节的序号。</li>
<li>确认号 (Acknowledgment Number)：0（或随机值，但在此次请求中无实际意义，因为是首次请求，尚未收到对方的数据）。</li>
<li>窗口大小 (Window Size)：客户端告知服务器自己的接收窗口大小 W1，用于流量控制。</li>
<li>客户端状态变化：客户端从 CLOSED 状态转换到 SYN_SENT 状态。</li>
<li>作用：客户端向服务器发送连接请求，并告知服务器自己发送数据时将使用的起始序列号 client_ISN。此时客户端进入同步发送状态，等待服务器确认。</li>
</ul>
<ol start="2">
<li>第二次握手 (SYN-ACK)：</li>
</ol>
<ul>
<li>发起方：服务器。</li>
<li>报文类型：SYN-ACK 报文段 (SYN_FLAG&#x3D;1, ACK_FLAG&#x3D;1)。SYN 标志位表示同意建立连接并发送自己的初始序列号，ACK 标志位表示确认收到客户端的请求。</li>
<li>序列号 (Sequence Number)：服务器随机生成一个初始序列号 server_ISN。这个序列号代表服务器接下来发送数据的第一个字节的序号。</li>
<li>确认号 (Acknowledgment Number)：服务器发送 ack &#x3D; client_ISN + 1。这表示服务器已成功接收到客户端的 SYN 报文（其序列号为 client_ISN），并期望接收客户端的下一个字节的序列号是 client_ISN + 1。</li>
<li>窗口大小 (Window Size)：服务器告知客户端自己的接收窗口大小 W2，用于流量控制。</li>
<li>服务器状态变化：服务器收到客户端的 SYN 后，从 LISTEN 状态转换到 SYN_RCVD 状态。发送 SYN-ACK 后，服务器仍然处于 SYN_RCVD 状态。</li>
<li>作用：服务器确认已收到客户端端的 SYN 请求，并同意建立连接，同时告知客户端自己发送数据时将使用的起始序列号 server_ISN，并确认收到了客户端的 SYN 报文。</li>
</ul>
<ol start="3">
<li>第三次握手（ACK）：</li>
</ol>
<ul>
<li>发起方：客户端。</li>
<li>报文类型：ACK 报文段（ACK_FLAG&#x3D;1）。ACK 标志位表示确认收到服务器的响应。</li>
<li>序列号（Sequence Number）：客户端发送 seq &#x3D; client_ISN + 1。这表示客户端的 SYN 报文已经消耗了一个序列号，现在数据将从 client_ISN + 1 开始发送。</li>
<li>确认号（Acknowledgment Number）：客户端发送 ack &#x3D; server_ISN + 1。这表示客户端已成功接收到服务器的 SYN-ACK 报文（其序列号为 server_ISN），并期望接收服务器的下一个字节的序列号是 server_ISN + 1。</li>
<li>客户端状态变化：客户端收到服务器的 SYN-ACK 后，从 SYN_SENT 状态转换到 ESTABLISHED 状态。</li>
<li>服务器状态变化：服务器收到客户端的 ACK 后，从 SYN_RCVD 状态转换到 ESTABLISHED 状态。</li>
<li>作用：客户端确认已收到服务器的 SYN-ACK，并告知服务器已经准备好发送和接收数据。至此，客户端和服务器都确认了对方的收发能力，以及彼此的初始序列号。连接正式建立，可以开始数据传输。</li>
</ul>
</li>
<li><p>为什么需要三次握手？</p>
<ul>
<li>防止已失效的连接请求报文段突然又传到服务器，导致错误建立连接。如果只有两次握手，客户端发送的第一个连接请求（SYN报文）因网络延迟迟迟未到服务器，客户端随时重传并成功建立了连接并传输了数据。旧的SYN报文在某个时刻到达了服务器，服务器收到后会以为是新的连接请求，发送SYN-ACK给客户端。如果只有两次握手，服务器会认为连接建立成功并进入ESTABLISHED状态，但客户端已经处理完之前的连接并关闭，不会理会服务器。这会导致服务器一直等待客户端发送数据，浪费资源。三次握手确保客户端能识别出这是旧的SYN，从而不发送ACK，服务器也就不会进入ESTABLISHED。</li>
<li>确保双方都具备发送和接收能力。<ul>
<li>第一次握手：客户端发送 SYN，服务器收到。服务器能确认客户端能发。</li>
<li>第二次握手：服务器发送 SYN-ACK，客户端收到。客户端能确认服务器能收也能发。</li>
<li>第三次握手：客户端发送 ACK，服务器收到。服务器能确认客户端能收。</li>
<li>至此，双方都确认了对方的“发”和“收”能力，实现了双向的同步确认。</li>
</ul>
</li>
</ul>
</li>
<li><p>四次握手：这是 TCP 终止连接的过程，目的是确保全双工连接的两个方向都能独立、优雅地关闭，避免数据丢失。由于 TCP 是全双工的，每个方向的数据传输都需要独立关闭。</p>
<ul>
<li><p>全双工特性：TCP 连接是全双工的，这意味着数据可以在两个方向上独立传输。当一方完成数据发送时，另一方可能仍然有数据需要发送。</p>
</li>
<li><p>假设客户端主动关闭连接：</p>
<ol>
<li>第一次挥手（FIN）：</li>
</ol>
<ul>
<li>发起方：客户端（数据发送完毕，想关闭发送方向）。</li>
<li>报文类型：FIN 报文段（FIN_FLAG&#x3D;1, ACK_FLAG&#x3D;1）。FIN 标志位表示发送方没有数据要发送了。</li>
<li>序列号（Sequence Number）：seq &#x3D; u（其中 u 是客户端上次发送的最后一个字节的序列号加 1）。</li>
<li>确认号（Acknowledgment Number）：ack &#x3D; v（如果之前收到了服务器的数据，这是对服务器最近一次发送数据包的确认号）。</li>
<li>客户端状态变化：客户端从 ESTABLISHED 状态转换到 FIN_WAIT_1 状态。</li>
<li>作用：客户端告知服务器，它已经没有数据要发送了，它单方面地关闭了发送方向的连接。但是，客户端仍然可以接收服务器发送的数据。</li>
</ul>
<ol start="2">
<li>第二次挥手（ACK）：</li>
</ol>
<ul>
<li>发起方：服务器。</li>
<li>报文类型：ACK 报文段（ACK_FLAG&#x3D;1）。</li>
<li>序列号（Sequence Number）：seq &#x3D; v（服务器上次发送的最后一个字节的序列号加 1）。</li>
<li>确认号（Acknowledgment Number）：ack &#x3D; u + 1。这表示服务器已成功接收到客户端的 FIN 报文段，并期望接收客户端的下一个字节的序列号是 u + 1（尽管客户端已经表示不再发送数据，这只是一个确认）。</li>
<li>服务器状态变化：服务器收到客户端的 FIN 后，从 ESTABLISHED 状态转换到 CLOSE_WAIT 状态。</li>
<li>客户端状态变化：客户端收到服务器的 ACK 后，从 FIN_WAIT_1 状态转换到 FIN_WAIT_2 状态。</li>
<li>作用：服务器确认已收到客户端的关闭请求。此时，客户端到服务器方向的连接已半关闭。服务器处于 CLOSE_WAIT 状态，这意味着服务器应用层还在处理数据或者还有数据需要发送给客户端。这个状态会持续到服务器端也准备好关闭连接。</li>
</ul>
<ol start="3">
<li>第三次挥手（FIN）：</li>
</ol>
<ul>
<li>发起方：服务器（当服务器也发送完所有数据，并且准备关闭自己的发送方向时）。</li>
<li>报文类型：FIN 报文段 (FIN_FLAG&#x3D;1, ACK_FLAG&#x3D;1)。</li>
<li>序列号 (Sequence Number)：seq &#x3D; w (服务器上次发送的最后一个字节的序列号加 1, w 可能等于 v, 如果服务器在发送 ACK 后没有再发送数据)。</li>
<li>确认号 (Acknowledgment Number)：ack &#x3D; u + 1 (再次确认客户端 FIN, 表示服务器对客户端发送的数据已经全部接收并确认)。</li>
<li>服务器状态变化：服务器发送 FIN 后，从 CLOSE_WAIT 状态转换到 LAST_ACK 状态。</li>
<li>作用：服务器告知客户端，它也没有数据要发送了，并请求关闭服务器到客户端方向的连接。</li>
</ul>
<ol start="4">
<li>第四次挥手 (ACK)：</li>
</ol>
<ul>
<li>发起方：客户端。</li>
<li>报文类型：ACK 报文段 (ACK_FLAG&#x3D;1)。</li>
<li>序列号 (Sequence Number)：seq &#x3D; u + 1。</li>
<li>确认号 (Acknowledgment Number)：ack &#x3D; w + 1。这表示客户端已成功接收到服务器的 FIN 报文段，并期望接收服务器的下一个字节的序列号是 w + 1 (尽管服务器也表示不再发送数据)。</li>
<li>客户端状态变化：客户端收到服务器的 FIN 后，从 FIN_WAIT_2 状态转换到 TIME_WAIT 状态。</li>
<li>服务器状态变化：服务器收到客户端的 ACK 后，从 LAST_ACK 状态转换到 CLOSED 状态。</li>
<li>作用：客户端确认已收到服务器的 FIN。</li>
</ul>
</li>
</ul>
</li>
<li><p>TIME_WAIT 状态的必要性：客户端在发送最后一个 ACK 后会进入 TIME_WAIT 状态，并持续等待 2MSL (Maximum Segment Lifetime, 最长报文段寿命) 的时间才进入 CLOSED 状态。MSL 是一个报文在网络中能够存活的最长时间。通常设置为 30 秒或 1 分钟。</p>
<ul>
<li>确保可靠关闭：为了确保最后一个 ACK 报文段能够到达服务器。如果这个 ACK 在网络中丢失了，服务器将因为没有收到确认而超时并重传第三次挥手的 FIN 报文。客户端处于 TIME_WAIT 状态时，可以接收到这个重传的 FIN，并再次发送 ACK，从而保证服务器能够可靠地关闭连接。如果客户端立即进入 CLOSED 状态，它就无法响应服务器重传的 FIN，服务器将永远停留在 LAST_ACK 状态。</li>
<li>避免旧连接的报文干扰新连接：在 2MSL 时间内，确保本连接中所有可能在网络中滞留的报文(如迟到的数据包或重传的 FIN)都已从网络中消失。这可以防止它们在连接关闭后被一个新的、使用相同源端口和目标端口的连接接收到，从而避免数据混乱。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h1><p>我对 MySQL 数据库有丰富的操作经验和深入的理解，包括 SQL 操作、事务特性、索引原理以及存储引擎。</p>
<h2 id="SQL-操作与优化"><a href="#SQL-操作与优化" class="headerlink" title="SQL 操作与优化"></a>SQL 操作与优化</h2><p>SQL (Structured Query Language) 是用于管理关系型数据库的标准语言。我熟练掌握各种 SQL 操作，并能进行性能优化。</p>
<ul>
<li><p>**DML (Data Manipulation Language)：**用于操作数据库中的数据。</p>
<ul>
<li>SELECT：查询数据。<ul>
<li><pre><code class="language-sql">SELECT column1, column2 FROM table_name WHERE condition ORDER BY column DESC/ASC LIMIT offset, count;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 聚合函数：COUNT(), SUM(), AVG(), MAX(), MIN()。</span><br><span class="line"></span><br><span class="line">  - 分组查询：GROUP BY, HAVING (用于过滤分组)。</span><br><span class="line"></span><br><span class="line">  - 联接查询 **(JOIN)**：</span><br><span class="line">    - INNER JOIN：只返回两个表中都匹配的行。</span><br><span class="line">    - LEFT JOIN / LEFT OUTER JOIN：返回左表所有行，以及右表中匹配的行。如果右表没有匹配，则右表列为 NULL。</span><br><span class="line">    - RIGHT JOIN / RIGHT OUTER JOIN：返回右表所有行，以及左表中匹配的行。如果左表没有匹配，则左表列为 NULL。</span><br><span class="line">    - FULL JOIN / FULL OUTER JOIN (MySQL 不直接支持，通常通过 LEFT JOIN UNION ALL RIGHT JOIN 模拟)：返回两个表中的所有行，不匹配的行用 NULL 填充。</span><br><span class="line">- INSERT：插入数据。</span><br><span class="line">  - ```sql</span><br><span class="line">    - INSERT INTO table_name (column1, column2) VALUES (value1, value2);</span><br><span class="line">    - INSERT INTO table_name VALUES (value1, value2, ...); (所有列)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li>UPDATE: 更新数据。<ul>
<li><pre><code class="language-sql">UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- DELETE: 删除数据。</span><br><span class="line">  - ```sql</span><br><span class="line">    DELETE FROM table_name WHERE condition; (不带 WHERE 子句将删除所有行，但不会释放空间，比 TRUNCATE TABLE 慢)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>DDL (Data Definition Language):</strong> 用于定义数据库对象，如表、索引、视图等。</p>
<ul>
<li><pre><code class="language-sql">- CREATE DATABASE database_name;
- CREATE TABLE table_name (column1 datatype constraints, column2 datatype constraints, PRIMARY KEY (column_name));
- ALTER TABLE table_name ADD column_name datatype;
- ALTER TABLE table_name DROP COLUMN column_name;
- ALTER TABLE table_name MODIFY COLUMN column_name datatype;
- DROP TABLE table_name;
- CREATE INDEX index_name ON table_name (column_name);
- DROP INDEX index_name ON table_name;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **DCL (Data Control Language):** 用于控制数据库的访问权限。</span><br><span class="line">  - ```sql</span><br><span class="line">    - GRANT privileges ON database.table TO &#x27;user&#x27;@&#x27;host&#x27;;</span><br><span class="line">    - REVOKE privileges ON database.table FROM &#x27;user&#x27;@&#x27;host&#x27;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>TCL (Transaction Control Language):</strong> 用于管理事务。</p>
<ul>
<li><pre><code class="language-sql">- START TRANSACTION; (或 BEGIN;)
- COMMIT;
- ROLLBACK;
- SAVEPOINT savepoint_name;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **EXPLAIN 命令深入分析：**</span><br><span class="line">  - EXPLAIN 是 MySQL SQL 优化的核心工具，它显示了 MySQL 如何执行 SELECT 查询（以及 INSERT, UPDATE, DELETE 语句的执行计划）。通过分析 EXPLAIN 的输出，可以判断查询是否使用了索引，以及索引使用的情况，从而进行性能优化。</span><br><span class="line">  - id: SELECT 查询的序列号。一个大的 SELECT 查询可以被分解为多个子查询，每个子查询都有一个唯一的 id。id 越大，执行优先级越高（优先级高的先执行）；如果 id 相同，则从上到下顺序执行。</span><br><span class="line">  - select_type: 查询的类型。</span><br><span class="line">    - SIMPLE: 简单的 SELECT 查询，不包含子查询或 UNION。</span><br><span class="line">    - PRIMARY: 最外层的 SELECT 查询（对于包含子查询或 UNION 的查询）。</span><br><span class="line">    - SUBQUERY: 子查询中的第一个 SELECT。</span><br><span class="line">    - DEPENDENT SUBQUERY: 依赖外部查询结果的子查询。</span><br><span class="line">    - UNION: UNION 中的第二个或后面的 SELECT 语句。</span><br><span class="line">    - DEPENDENT UNION: UNION 中的第二个或后面的 SELECT 语句，且依赖外部查询。</span><br><span class="line">    - UNION RESULT: UNION 的结果。</span><br><span class="line">    - DERIVED: 派生表（FROM 子句中的子查询）。table: 正在访问的表名。</span><br><span class="line">  - partitions: 匹配到的分区信息（如果表有分区）。</span><br><span class="line">  - type: 最重要的指标，表示连接类型，即 MySQL 查找数据的方式。这是评估查询性能的关键，从好到差依次是：</span><br><span class="line">    - system: 表中只有一行记录(系统表)。const 的特例，性能极高。</span><br><span class="line">    - const: 通过主键或唯一索引查找，最多匹配一行。非常快。例如 SELECT * FROM users WHERE id = 1;</span><br><span class="line">    - eq_ref: 对于前一个表的每个行组合，从表中读取一行。通常用于连接操作，主键或唯一索引的所有列都被用于连接条件。例如 SELECT * FROM orders o JOIN users u ON o.user_id = u.id; (假设 u.id 是主键或唯一索引)。</span><br><span class="line">    - ref: 非唯一索引的等值查找。可能找到多行。例如 SELECT * FROM orders WHERE user_id = 100; (假设 user_id 是普通索引)。</span><br><span class="line">    - range: 范围查找，使用索引来检索给定范围的行。例如 WHERE id &gt; 100 AND id &lt; 200; 或 BETWEEN, IN。</span><br><span class="line">    - index: 全索引扫描。遍历整个索引树，比 ALL 好，因为索引通常比数据文件小，且索引是按顺序存储的，可以避免随机 I/O。如果使用了覆盖索引，效率会更高。</span><br><span class="line">    - ALL: 全索引扫描。扫描整个表来查找匹配的行。性能最差，数据量大时应极力避免。</span><br><span class="line">  - possible_keys: MySQL 认为可能用于查询的索引。</span><br><span class="line">  - key: MySQL 实际决定使用的索引。如果为 NULL，表示没有使用索引。</span><br><span class="line">  - key_len: 实际使用的索引的长度(字节数)。这个值越小越好，表示使用的索引越短。对于复合索引，可以判断索引哪些列被用到了。</span><br><span class="line">  - ref: 表示使用哪个列或常量来和 key 所指的索引列做比较。</span><br><span class="line">  - rows: MySQL 估计要扫描的行数。这是最重要的指标之一，越少越好。</span><br><span class="line">  - filtered: 表示查询条件过滤掉的行数的百分比。越高越好，表示过滤效率高。</span><br><span class="line">  - Extra: 额外信息，对查询的解释提供了额外细节，非常重要。</span><br><span class="line">    - Using filesort: 表示 MySQL 需要对结果进行外部排序(即不在索引中排序)。这通常发生在 ORDER BY 或 GROUP BY 的列没有索引或索引无法被有效利用时。会增加 CPU 开销和 I/O，应尽量通过创建合适的索引或调整查询来避免。</span><br><span class="line">    - Using temporary: 表示 MySQL 需要创建临时表来处理查询。通常发生在 GROUP BY 或 ORDER BY 中包含不相关列，或者 DISTINCT 和 ORDER BY 混用时。临时表可能在内存中，也可能在磁盘上，都会增加性能开销，应尽量避免。</span><br><span class="line">    - Using index: 表示使用了覆盖索引 (Covering Index)。查询所需的所有列都可以在索引中找到，无需回表访问数据行。这是最有效的索引使用方式。</span><br><span class="line">    - Using where: 表示使用了 WHERE 子句进行过滤。这是正常的，但如果 type 是 ALL，说明 WHERE 过滤是基于全表扫描的，效率不高。</span><br><span class="line">    - Using index condition: MySQL 5.6+ 引入的索引条件下推 (Index Condition Pushdown, ICP) 优化。它将 WHERE 子句中的部分条件下推到存储引擎层，在索引扫描过程中就进行过滤，减少了回表次数和从存储引擎层返回给服务层的数据量。</span><br><span class="line">    - Using join buffer (Block Nested Loop): 当关联查询无法使用索引时，MySQL 会使用连接缓存来优化。</span><br><span class="line"></span><br><span class="line">## 事务 (Transaction)</span><br><span class="line"></span><br><span class="line">事务是一组操作的集合，这些操作要么全部成功，要么全部失败。它具有四大特性 (ACID)。</span><br><span class="line"></span><br><span class="line">- **ACID 特性：**</span><br><span class="line">  1. **原子性 (Atomicity)**: 事务是最小的执行单位，不可再分割。事务中的所有操作要么全部成功提交，要么全部失败回滚到事务开始前的状态。</span><br><span class="line">  2. **一致性 (Consistency)**: 事务执行前后，数据库的完整性约束 (如主键唯一性、外键约束、检查约束、自定义业务规则 ) 没有被破坏，数据从一个一致性状态转换到另一个一致性状态。</span><br><span class="line">  3. **隔离性 (Isolation)**: 并发执行的事务之间是隔离的，一个事务的执行不应影响其他事务的执行，反之亦然。事务的中间状态对其他事务是不可见的。</span><br><span class="line">  4. **持久性 (Durability)**: 一旦事务提交，它对数据库中数据的改变就是永久性的，即使系统崩溃也不会丢失。</span><br><span class="line"></span><br><span class="line">- **并发事务带来的问题：**</span><br><span class="line">  1. **脏读 (Dirty Read)**: 一个事务读取了另一个未提交事务的数据。如果这个未提交事务最终回滚，那么之前读取的数据就是“脏数据”。</span><br><span class="line">  2. **不可重复读 (Non-Repeatable Read)**：一个事务在两次相同的查询中，读取到了不同的数据。通常是因为另一个已提交事务对这些数据进行了 UPDATE 或 DELETE 操作。</span><br><span class="line">  3. **幻读 (Phantom Read)**：一个事务在两次相同的查询中，读取到了不同数量的行。通常是因为另一个已提交事务对数据进行了 INSERT 操作，导致第二次查询出现了之前没有的行。</span><br><span class="line">  4. **丢失更新 (Lost Update)**：当两个事务都读取同一数据并进行修改时，其中一个事务的修改覆盖了另一个事务的修改，导致数据丢失。</span><br><span class="line"></span><br><span class="line">- **事务隔离级别 (从低到高)：**</span><br><span class="line">  1. **READ UNCOMMITTED (读未提交)：**</span><br><span class="line">    - 最低的隔离级别。</span><br><span class="line">    - 允许脏读、不可重复读和幻读。</span><br><span class="line">    - 性能最高，但数据一致性最差。</span><br><span class="line">  2. **READ COMMITTED (读已提交)：**</span><br><span class="line">    - 解决了脏读问题。一个事务只能看到其他事务已经提交的数据。</span><br><span class="line">    - 仍然存在不可重复读和幻读问题。</span><br><span class="line">    - 多数数据库 (如 Oracle, SQL Server) 的默认隔离级别。</span><br><span class="line">  3. **REPEATABLE READ (可重复读)：**</span><br><span class="line">    - MySQL (InnoDB 存储引擎) 的默认隔离级别。</span><br><span class="line">    - 解决了脏读和不可重复读问题。在同一个事务中，多次读取同一数据会得到相同的结果 (通过 MVCC - 多版本并发控制)。</span><br><span class="line">    - 仍然可能存在幻读问题 (但在 InnoDB 默认隔离级别下，通过间隙锁解决了大部分幻读问题)。</span><br><span class="line">  4. **SERIALIZABLE (串行化):**</span><br><span class="line">    - 最高的隔离级别。</span><br><span class="line">    - 完全解决了脏读、不可重复读和幻读问题。</span><br><span class="line">    - 强制事务串行执行，避免所有并发问题。</span><br><span class="line">    - 性能最低，因为它牺牲了并发性。</span><br><span class="line"></span><br><span class="line">## 索引 (Index)</span><br><span class="line"></span><br><span class="line">索引是帮助 MySQL 高效获取数据的数据结构。它类似于书籍的目录，可以快速定位到所需的数据，而无需扫描整个表。</span><br><span class="line"></span><br><span class="line">- **索引的优点:**</span><br><span class="line">  - 大大加快数据检索速度。</span><br><span class="line">  - 减少服务器的 I/O 次数。</span><br><span class="line">  - 在分组 (GROUP BY) 和排序 (ORDER BY) 操作中减少 CPU 消耗。</span><br><span class="line"></span><br><span class="line">- **索引的缺点:**</span><br><span class="line">  - 创建和维护索引需要时间成本，数据增加时需要更新索引。</span><br><span class="line">  - 索引需要占用磁盘空间。</span><br><span class="line">  - 虽然查询性能提升，但对写入操作有一定性能损耗。</span><br><span class="line"></span><br><span class="line">- **索引的底层实现: B+ 树**</span><br><span class="line">  - B+ 树 (B+Tree):</span><br><span class="line">    - 所有数据都存储在叶子节点上，非叶子节点只存储键值 (索引) 用于导航。</span><br><span class="line">    - 叶子节点之间通过链表连接，方便范围查询和遍历。</span><br><span class="line">    - 树的层高更低：相比 B 树，B+ 树的非叶子节点不存储数据，因此一个节点可以存储更多的索引键，使得树的高度更低，从而减少磁盘 I/O 次数。</span><br><span class="line">    - 适用于磁盘存储：磁盘 I/O 是数据库操作的主要瓶颈，B+ 树的设计（节点大小与磁盘块大小匹配）能够最大程度地减少磁盘寻道次数。</span><br><span class="line"></span><br><span class="line">- **索引的分类：**</span><br><span class="line">  1. 主键索引 (Primary Key Index)：</span><br><span class="line">    - 一种特殊的唯一索引，一个表只能有一个主键。</span><br><span class="line">    - 不允许有空值 (NULL)。</span><br><span class="line">    - 通常是聚集索引 (InnoDB)。</span><br><span class="line">  2. 唯一索引 (Unique Index)：</span><br><span class="line">    - 索引列的值必须唯一，但允许有空值 (NULL)，且可以有多个 NULL 值。</span><br><span class="line">    - CREATE UNIQUE INDEX index_name ON table_name (column_name):</span><br><span class="line">  3. 普通索引 (Normal Index / Non-Unique Index)：</span><br><span class="line">    - 最基本的索引，没有任何限制。</span><br><span class="line">    - CREATE INDEX index_name ON table_name (column_name):</span><br><span class="line">  4. 全文索引 (Fulltext Index)：</span><br><span class="line">    - 用于文本内容的模糊查询，在大文本字段上进行高效搜索。</span><br><span class="line">    - 只支持 MyISAM 和 InnoDB 存储引擎。</span><br><span class="line">    - CREATE FULLTEXT INDEX index_name ON table_name (column_name):</span><br><span class="line">  5. 复合索引 (Composite Index / Multi-Column Index)：</span><br><span class="line">    - 在多个列上创建的索引。</span><br><span class="line">    - 遵循“最左前缀原则”：如果查询条件使用了复合索引的第一个列，则整个索引会被利用；如果只使用了非第一个列，则索引可能无法完全利用。</span><br><span class="line">    - CREATE INDEX index_name ON table_name (column1, column2, column3);</span><br><span class="line"></span><br><span class="line">- **聚集索引（Clustered Index）与 非聚集索引（Non-Clustered Index）：**</span><br><span class="line">  - 聚集索引：</span><br><span class="line">    - 索引的叶子节点存储的就是完整的数据行。</span><br><span class="line">    - 一个表只能有一个聚集索引（通常是主键）。</span><br><span class="line">    - 数据物理存储的顺序与索引的逻辑顺序一致。</span><br><span class="line">    - 查询效率高，因为找到索引叶子节点就找到了数据。</span><br><span class="line">    - 对数据插入、更新和删除有一定影响，因为需要维护数据的物理顺序。</span><br><span class="line">    - 在 InnoDB 存储引擎中，主键索引就是聚集索引。如果我没有显式定义主键，InnoDB 会选择一个唯一非空索引作为聚集索引；如果没有，则会自动创建一个隐藏的 6 字节的行 ID 作为聚集索引。</span><br><span class="line">  - 非聚集索引：</span><br><span class="line">    - 索引的叶子节点存储的是主键值或指向数据行的指针。</span><br><span class="line">    - 一个表可以有多个非聚集索引。</span><br><span class="line">    - 数据物理存储顺序与非聚集索引的逻辑顺序无关。</span><br><span class="line">    - 查询需要回表：如果查询的列不在非聚集索引中，需要通过索引找到主键值，再通过主键索引（聚集索引）找到完整的数据行。</span><br><span class="line">    - 在 InnoDB 中，所有非主键索引都是非聚集索引。</span><br><span class="line"></span><br><span class="line">- **索引优化策略：**</span><br><span class="line">  - 选择合适的列创建索引：</span><br><span class="line">    - 在 WHERE 子句、JOIN 子句、ORDER BY 子句中经常出现的列。</span><br><span class="line">    - 选择区分度高（唯一值多）的列。</span><br><span class="line">    - 不为小型表、频繁更新的表、重复值多的列创建索引。</span><br><span class="line">  - 遵循最左前缀原则：对于复合索引 (a, b, c)，查询条件 WHERE a = 1，WHERE a = 1 AND b = 2 会使用索引，但 WHERE b = 2 或 WHERE c = 3 不会完全使用索引。</span><br><span class="line">  - 避免索引失效：</span><br><span class="line">    - 在索引列上进行函数运算或表达式运算（如 WHERE YEAR(date_column) = 2023）。</span><br><span class="line">    - 对索引列进行隐式类型转换。</span><br><span class="line">    - 使用 OR 连接条件（除非 OR 的两边都有索引，并且优化器认为合并索引更高效）。</span><br><span class="line">    - 使用 LIKE &#x27;%keyword&#x27;（左模糊匹配）会导致全索引扫描或全表扫描。</span><br><span class="line">    - 使用 NOT IN 或 != 通常无法使用索引。</span><br><span class="line">  - 覆盖索引：查询只从索引中获取数据，无需回表。</span><br><span class="line">    - SELECT column_in_index FROM table_name WHERE indexed_column = value;</span><br><span class="line">  - 防止回表：尽可能让 SELECT 语句中的列都被索引覆盖，或者只查询主键。</span><br><span class="line">  - 定期维护索引：重建或优化碎片化的索引。</span><br><span class="line"></span><br><span class="line">- #### SQL优化</span><br><span class="line"></span><br><span class="line">  ![图片](https://i-blog.csdnimg.cn/blog_migrate/bfe55c106fb1ceb9316542c424cecf9f.png) </span><br><span class="line"></span><br><span class="line">## 存储引擎</span><br><span class="line"></span><br><span class="line">MySQL 是一个关系型数据库管理系统，它的独特之处在于支持多种可插拔的存储引擎。存储引擎负责 MySQL 中数据的存储和提取。</span><br><span class="line"></span><br><span class="line">- **InnoDB (默认)：**</span><br><span class="line">  - 特性：</span><br><span class="line">    - 支持事务（ACID 特性）。</span><br><span class="line">    - 支持行级锁定：在并发写入时，只锁定需要修改的行，而不是整个表，大大提高了并发性能。</span><br><span class="line">    - 支持外键约束：维护数据完整性。</span><br><span class="line">    - 支持崩溃恢复：通过事务日志（redo log 和 undo log）保证数据持久性。</span><br><span class="line">    - 默认使用聚集索引：数据存储在 B+ 树的叶子节点中，数据行和主键一起存储，查询效率高。</span><br><span class="line">    - MVCC（多版本并发控制）：通过快照读取实现非阻塞的读操作，提高并发性能。</span><br><span class="line">  - 适用场景：事务性应用、高并发读写、对数据完整性和一致性要求要求高的场景（如电商、金融系统）。</span><br><span class="line"></span><br><span class="line">- **MyISAM（非事务性）：**</span><br><span class="line">  - 特性：</span><br><span class="line">    - 不支持事务。</span><br><span class="line">    - 支持表级锁定：并发写入时，需要锁定整个表，并发性能差。</span><br><span class="line">    - 不支持外键约束。</span><br><span class="line">    - 不支持崩溃恢复：可能导致数据丢失。</span><br><span class="line">    - 非聚集索引：数据和索引是分离的，索引叶子节点存储的是数据行的地址。</span><br><span class="line">    - SELECT COUNT(*) 效率高，因为表的总行数存储在内存中。</span><br><span class="line">  - 适用场景：只读或读多写少，对事务性要求不高，需要频繁执行 COUNT(*) 的应用（如一些日志记录、数据仓库）。在 MySQL 5.5 后，InnoDB 逐渐替代 MyISAM 成为默认和首选。</span><br><span class="line"></span><br><span class="line">- **其他存储引擎（了解）：**</span><br><span class="line">  - Memory (HEAP)：数据存储在内存中，速度极快，但重启服务器数据会丢失。适用于临时表或缓存。</span><br><span class="line">  - Archive：用于存储大量不常访问的历史数据，支持高速插入和查询（不支持更新和删除）。数据会被高度压缩。</span><br><span class="line">  - CSV：以 CSV 文件格式存储数据，便于与其他应用程序进行数据交换。</span><br><span class="line"></span><br><span class="line">## MVCC（多版本并发控制）：</span><br><span class="line"></span><br><span class="line">好的，我们来深入探讨一下 **MVCC (Multi-Version Concurrency Control)**，并分析一些常见的面试题。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **什么是 MVCC？**</span><br><span class="line"></span><br><span class="line">**MVCC**，即**多版本并发控制**，是一种在数据库中用于解决并发访问问题的方法。它不是通过加锁的方式来控制并发，而是通过**为每个事务生成一个数据快照**，让读操作在快照上进行。</span><br><span class="line"></span><br><span class="line">你可以把它想象成一个“时光机”。当一个事务开始时，数据库会为它“拍一张照片”，也就是生成一个数据快照。这个事务的所有读操作都只会看到这个快照里的数据，而不会受到其他并发事务修改的影响。这样，读操作就不需要等待写锁释放，从而实现了**读写分离**，大大提高了并发性能。</span><br><span class="line"></span><br><span class="line">简而言之，MVCC 的核心思想是：</span><br><span class="line"></span><br><span class="line">- **读不加锁**：读取数据时，直接从数据的历史版本中读取，不需要等待其他事务的写锁。</span><br><span class="line">- **写不阻塞读**：写操作修改数据时，会创建一个新的版本，而旧版本依然保留，供其他读事务使用。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **MVCC 的实现原理**</span><br><span class="line"></span><br><span class="line">MVCC 的实现通常依赖于以下几个核心要素：</span><br><span class="line"></span><br><span class="line">1. 隐藏列（Hidden Columns）：</span><br><span class="line"></span><br><span class="line">   每个表都会有几个隐藏的列，用于记录版本信息：</span><br><span class="line"></span><br><span class="line">   - **DB_TRX_ID**：事务 ID，记录最近一次修改数据的事务 ID。</span><br><span class="line">   - **DB_ROLL_PTR**：回滚指针，指向这条记录的上一个版本。</span><br><span class="line">   - **DB_ROW_ID**：行 ID，是插入新行时分配的隐藏 ID，当主键是字符串时，可能用于辅助索引。</span><br><span class="line"></span><br><span class="line">2. Undo Log (回滚日志)：</span><br><span class="line"></span><br><span class="line">   Undo Log 记录了数据在被修改之前的值。每次修改数据时，都会将修改前的数据版本记录在 Undo Log 中，并通过回滚指针 DB_ROLL_PTR 将新版本与旧版本连接起来，形成一个版本链。这样，通过版本链，我们就可以追溯到这条数据的历史版本。</span><br><span class="line"></span><br><span class="line">3. Read View (读视图)：</span><br><span class="line"></span><br><span class="line">   Read View 是 MVCC 的核心，它是一个在事务启动时生成的、用来判断某个数据版本对当前事务是否可见的数据快照。它主要包含以下几个关键信息：</span><br><span class="line"></span><br><span class="line">   - `m_ids`：在生成 `Read View` 时，当前系统中**所有活跃事务**的 ID 列表。</span><br><span class="line">   - `min_trx_id`：在生成 `Read View` 时，`m_ids` 中最小的事务 ID。</span><br><span class="line">   - `max_trx_id`：在生成 `Read View` 时，系统将要分配给下一个事务的 ID。</span><br><span class="line">   - `creator_trx_id`：创建 `Read View` 的事务 ID。</span><br><span class="line"></span><br><span class="line">   当一个事务想要读取一条数据时，会根据 `Read View` 的规则来判断这条数据的**`DB_TRX_ID`**是否可见。</span><br><span class="line"></span><br><span class="line">   - 如果 `DB_TRX_ID` 小于 `min_trx_id`，说明这个修改操作在当前事务启动前就已经提交了，数据**可见**。</span><br><span class="line">   - 如果 `DB_TRX_ID` 大于等于 `max_trx_id`，说明这个修改操作是在当前事务启动后才发生的，数据**不可见**。</span><br><span class="line">   - 如果 `DB_TRX_ID` 在 `min_trx_id` 和 `max_trx_id` 之间，那么需要判断 `DB_TRX_ID` 是否在 `m_ids` 列表中。如果在，说明这个修改操作是和当前事务同时启动的，数据**不可见**；如果不在，说明这个修改操作在当前事务启动前就已经提交了，数据**可见**。</span><br><span class="line"></span><br><span class="line">   如果当前版本不可见，事务就会通过回滚指针 `DB_ROLL_PTR` 沿着版本链找到上一版本，直到找到一个**可见**的版本。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **面试题分析**</span><br><span class="line"></span><br><span class="line">#### **1. 什么是 MVCC？它解决了什么问题？**</span><br><span class="line"></span><br><span class="line">**回答要点：**</span><br><span class="line"></span><br><span class="line">- **概念**：多版本并发控制，通过维护数据历史版本实现并发。</span><br><span class="line">- **解决问题**：在数据库隔离级别为**读已提交（RC）**和**可重复读（RR）**时，实现了读写不冲突。它解决了 **读写锁冲突** 和 **脏读** 问题，但无法完全解决幻读。</span><br><span class="line">- **核心思想**：读操作读取数据快照，写操作创建新版本。</span><br><span class="line"></span><br><span class="line">#### **2. MVCC 是如何实现可重复读（Repeatable Read）的？**</span><br><span class="line"></span><br><span class="line">**回答要点：**</span><br><span class="line"></span><br><span class="line">- **核心**：`Read View` 的创建时机。</span><br><span class="line">- **可重复读**：事务在第一次读操作时创建 `Read View`，并且在**整个事务的生命周期内都使用这个 Read View**。这意味着无论事务中执行多少次读，看到的都是同一个数据快照，所以能保证多次读取结果一致。</span><br><span class="line">- **读已提交**：相比之下，读已提交的隔离级别是**每次执行读操作时都重新生成一个 Read View**。因此，如果其他事务在两次读操作之间提交了修改，第二次读就能看到新数据，导致不可重复读。</span><br><span class="line"></span><br><span class="line">#### **3. MVCC 能解决幻读吗？**</span><br><span class="line"></span><br><span class="line">**回答要点：**</span><br><span class="line"></span><br><span class="line">- **部分解决，但不能完全解决。**</span><br><span class="line">- **幻读（Phantom Read）**：当一个事务在两次查询之间，另一个事务插入了新的数据，导致第一次查询不存在的数据，第二次查询却出现了。</span><br><span class="line">- **MVCC 的作用**：MVCC 可以防止**更新幻读**（即一个事务在两次查询之间，另一个事务更新了数据），因为它总是读取事务启动时的快照。</span><br><span class="line">- **无法解决**：MVCC 无法完全解决**插入幻读**。例如，事务 A 两次查询 `WHERE id &gt; 10`，但在两次查询之间，事务 B 插入了一条 `id=11` 的记录并提交。虽然事务 A 的 `Read View` 看不到这条新记录，但如果事务 A 执行 `UPDATE ... WHERE id &gt; 10` 时，它会发现这条新记录并对其加锁，从而更新成功。这会打破可重复读的承诺。</span><br><span class="line">- **InnoDB 的解决方案**：InnoDB 数据库在 `可重复读` 隔离级别下，除了 MVCC，还会结合**间隙锁（Gap Lock）**来彻底解决幻读问题。</span><br><span class="line"></span><br><span class="line">#### **4. Undo Log 和 Redo Log 有什么区别？**</span><br><span class="line"></span><br><span class="line">**回答要点：**</span><br><span class="line"></span><br><span class="line">- **Undo Log (回滚日志)**：</span><br><span class="line">  - **作用**：用于**回滚事务**和实现 **MVCC**。</span><br><span class="line">  - **记录内容**：记录的是**数据修改前**的版本。</span><br><span class="line">  - **生命周期**：在事务提交后，如果数据有其他事务在使用（用于 MVCC），`Undo Log` 依然保留；如果没有，`Undo Log` 会被清除。</span><br><span class="line">- **Redo Log (重做日志)**：</span><br><span class="line">  - **作用**：用于保证事务的**持久性**。</span><br><span class="line">  - **记录内容**：记录的是**数据修改后**的日志，比如“某某页的某某偏移量改成了某某值”。</span><br><span class="line">  - **生命周期**：在数据同步到磁盘后，`Redo Log` 就会被清除。</span><br><span class="line">  - **作用点**：`Redo Log` 作用于**崩溃恢复**。当数据库发生宕机时，可以根据 `Redo Log` 将已提交但尚未写入磁盘的数据重新写入，以保证数据不丢失。</span><br><span class="line"></span><br><span class="line">## MySQL日志</span><br><span class="line"></span><br><span class="line">MySQL的日志系统是其数据库管理系统(DBMS)中至关重要的组成部分，扮演着监控、审计、故障恢复和数据复制等多种关键角色。用户提到的错误日志、查询日志、慢查询日志、事务日志和二进制日志构成了MySQL日志体系的核心。下面将对这些主要日志进行详细的梳理和解析。</span><br><span class="line"></span><br><span class="line">## 1. 错误日志(Error Log)</span><br><span class="line"></span><br><span class="line">错误日志是MySQL中最基础的日志之一，它记录了mysqld服务器启动、运行和关闭过程中遇到的所有严重错误和警告。</span><br><span class="line"></span><br><span class="line">- 主要内容：</span><br><span class="line">  - 服务器启动和关闭的详细信息。</span><br><span class="line">  - 运行过程中发生的错误，例如表损坏、无法访问特定文件等。</span><br><span class="line">  - 事件调度器运行出错时的信息。</span><br><span class="line">  - 在主从复制架构中，从服务器上启动和关闭复制线程，连接主服务器时发生的错误等。</span><br><span class="line">- 作用：错误日志是诊断和解决MySQL服务器问题的首要工具。当数据库无法启动或运行异常时，应首先检查此日志。</span><br><span class="line">- 配置：默认情况下，错误日志是开启的。其文件名通常为&lt;hostname&gt;.err，位于数据目录(datadir)下。可以通过在my.cnf或my.ini配置文件中设置log_error变量来指定其路径。</span><br><span class="line"></span><br><span class="line">## 2. 查询日志(Query Log)/通用查询日志(General Query Log)</span><br><span class="line"></span><br><span class="line">通用查询日志记录了MySQL服务器接收到的每一个客户端连接和执行的每一条SQL语句。</span><br><span class="line"></span><br><span class="line">- 主要内容：</span><br><span class="line">  - 客户端的连接信息，包括连接时间、用户名和主机。</span><br><span class="line">  - 客户端发送给服务器的所有SQL语句，无论其是否正确执行。</span><br><span class="line">- 作用：该日志对于数据库的审计和问题排查非常有用，可以精确复现用户的操作序列。然而，由于它会记录所有操作，对系统性能会产生显著影响，并会迅速占用大量磁盘空间。因此，不建议在生产环境中长期开启。</span><br><span class="line">- 配置：默认关闭。可以通过设置general_log为ON来启用，并使用general_log_file指定日志文件路径。</span><br><span class="line"></span><br><span class="line">## 3. 慢查询日志(Slow Query Log)</span><br><span class="line"></span><br><span class="line">慢查询日志用于记录执行时间超过指定阈值的SQL查询语句，是数据库性能优化的关键工具。</span><br><span class="line"></span><br><span class="line">- 主要内容：</span><br><span class="line">  - 执行时间超过long_query_time阈值的SQL语句。</span><br><span class="line">  - 查询执行时的相关信息，如执行时间、锁定时间、扫描的行数、返回的行数以及执行该查询的用户和主机。</span><br><span class="line">- 作用：通过分析慢查询日志，开发者和数据库管理员(DBA)可以定位到效率低下的SQL语句，并针对性地进行优化，例如添加索引、改写查询等。</span><br><span class="line">- 配置：默认关闭。需在配置文件中设置slow_query_log为ON开启。long_query_time参数用于设定慢查询的时间阈值(单位：秒)，slow_query_log_file用于指定日志文件位置。log_queries_not_using_indexes参数还可以记录未使用索引的查询。</span><br><span class="line"></span><br><span class="line">## 4. 事务日志(Transaction Log)</span><br><span class="line"></span><br><span class="line">用户提到的&quot;事务日志&quot;在InnoDB存储引擎中，主要由两种日志构成：重做日志(Redo Log)和回滚日志(Undo Log)。它们共同保证了事务的ACID特性(原子性、一致性、隔离性、持久性)。</span><br><span class="line"></span><br><span class="line">- 重做日志(Redo Log):</span><br><span class="line">  - 作用：保证事务的持久性。它记录了数据被修改后的物理变化。当事务提交后，即使数据尚未完全写入数据文件，只要Redo Log已经持久化，在数据库发生崩溃时，也可以通过重放Redo Log来恢复已提交的事务，确保数据不丢失。这种技术被称为预写日志(Write-Ahead Logging, WAL)。</span><br><span class="line">  - 特点：Redo Log是以循环写的方式记录在连续的物理文件中，大小固定。</span><br><span class="line">- 回滚日志(Undo Log):</span><br><span class="line">  - 作用：保证事务的原子性和实现多版本并发控制(MVCC)。Undo Log记录的是数据被修改前的状态。当事务需要回滚时，可以通过Undo Log将数据恢复到修改之前的版本。同时，在读已提交(Read Committed)和可重复读(Repeatable Read)隔离级别下，当一个事务需要读取被另一个未提交事务修改的行时，会通过Undo Log读取该行之前的版本，从而实现非锁定读。</span><br><span class="line">  - 特点：Undo Log逻辑上记录了每个修改操作的逆操作。</span><br><span class="line"></span><br><span class="line">## 5. 二进制日志(Binary Log/Binlog)</span><br><span class="line"></span><br><span class="line">二进制日志是MySQL中功能最强大、用途最广泛的日志之一。它以二进制格式记录了所有修改数据库数据的操作(DML)以及数据定义语言(DDL)的操作，但不包括SELECT和SHOW等不修改数据的查询。</span><br><span class="line"></span><br><span class="line">- 主要内容：记录了导致数据发生更改的所有事件。根据格式不同，可以记录为SQL语句(STATEMENT格式)、行的变更(ROW格式)或两者的混合(MIXED格式)。</span><br><span class="line">- 主要作用：</span><br><span class="line">  - 数据恢复(Point-in-Time Recovery)：通过备份的数据文件和之后的二进制日志，可以将数据库恢复到过去的任意一个时间点。</span><br><span class="line">  - 主从复制(Replication)：在主从架构中，主服务器将二进制日志传送给从服务器，从服务器重放这些日志中的事件，从而实现与主服务器的数据同步。</span><br><span class="line">- 配置：默认情况下可能关闭，需要通过配置文件中的log_bin选项来启用。启用后，会生成一个索引文件(默认为&lt;hostname&gt;-bin.index)和一系列的二进制日志文件。</span><br><span class="line"></span><br><span class="line">## 扩展：中继日志(Relay Log)</span><br><span class="line"></span><br><span class="line">在主从复制环境中，还有一个重要的日志类型——中继日志。</span><br><span class="line"></span><br><span class="line">- 作用：从服务器的I/O线程从主服务器获取二进制日志，并将其写入本地的中继日志中。然后，从服务器的SQL线程读取中继日志中的事件，并在从服务器上执行，以实现数据同步。</span><br><span class="line">- 特点：中继日志的格式与二进制日志完全相同。它的存在使得从服务器的I/O和SQL执行可以解耦，即使在网络不稳定的情况下，只要I/O线程将日志拉到本地，SQL线程就可以持续执行。</span><br><span class="line"></span><br><span class="line">## 总结</span><br><span class="line"></span><br><span class="line">| 日志类型   | 主要作用                                 | 生产环境建议                                 |</span><br><span class="line">| ---------- | ---------------------------------------- | -------------------------------------------- |</span><br><span class="line">| 错误日志   | 记录服务器启停和运行错误                 | 始终开启                                     |</span><br><span class="line">| 查询日志   | 记录所有连接和SQL语句，用于审计          | 默认关闭，仅在调试时短期开启                 |</span><br><span class="line">| 慢查询日志 | 记录执行缓慢的SQL，用于性能优化          | 建议开启                                     |</span><br><span class="line">| 事务日志   |                                          |                                              |</span><br><span class="line">| - Redo Log | 保证事务持久性，用于崩溃恢复             | InnoDB引擎核心组件，始终开启                 |</span><br><span class="line">| - Undo Log | 保证事务原子性，支持MVCC                 | InnoDB引擎核心组件，始终开启                 |</span><br><span class="line">| 二进制日志 | 数据恢复、主从复制                       | 强烈建议开启，尤其是需要数据恢复和复制的场景 |</span><br><span class="line">| 中继日志   | 主从复制中，从库用于暂存主库的二进制日志 | 在从服务器上自动创建和管理                   |</span><br><span class="line"></span><br><span class="line">## MySQL中的锁</span><br><span class="line"></span><br><span class="line">## 第一部分：数据库锁系统</span><br><span class="line"></span><br><span class="line">### 1. 锁的分类体系</span><br><span class="line"></span><br><span class="line">#### 1.1 按锁粒度的层次分类</span><br><span class="line"></span><br><span class="line">**表级锁（Table-Level Lock）** 表级锁是最粗粒度的锁机制，一次锁定整个表的所有数据。MyISAM存储引擎主要使用表级锁，其内部维护一个全局的表锁列表。当线程需要访问表时，首先检查表锁状态，如果表已被其他线程以不兼容模式锁定，则当前线程进入等待队列。表级锁的优势在于锁管理开销极小，只需要维护少量的锁对象；缺点是并发度极低，即使访问不同行的操作也会相互阻塞。</span><br><span class="line"></span><br><span class="line">**页级锁（Page-Level Lock）** 页级锁锁定数据页，是表级锁和行级锁的折中方案。BDB存储引擎使用页级锁，每个数据页通常包含多条记录。页级锁的实现需要在页头维护锁信息，包括锁模式、持有者信息等。这种锁粒度在空间局部性较好的应用中表现优秀，因为相关的数据通常存储在相邻的页面中。</span><br><span class="line"></span><br><span class="line">**行级锁（Row-Level Lock）** 行级锁是最细粒度的锁机制，InnoDB存储引擎的核心特性。行锁的实现依赖于索引结构，实际上锁定的是索引记录而不是数据行本身。当查询没有使用索引时，InnoDB会扫描整个表并对所有记录加锁，退化为类似表锁的行为。行级锁提供最高的并发度，但也带来最大的管理开销。</span><br><span class="line"></span><br><span class="line">#### 1.2 按锁模式的功能分类</span><br><span class="line"></span><br><span class="line">**共享锁（Shared Lock, S锁）** 共享锁允许多个事务同时读取同一资源，但阻止任何事务修改该资源。在InnoDB中，共享锁通过在锁对象的type_mode字段中设置LOCK_S标志位来标识。多个共享锁可以并存，这是通过锁兼容性矩阵来判断的。共享锁的获取相对简单，只需要检查是否存在冲突的排他锁。</span><br><span class="line"></span><br><span class="line">**排他锁（Exclusive Lock, X锁）** 排他锁提供独占访问，同一时间只能有一个事务持有资源的排他锁。排他锁与任何其他锁都不兼容，包括共享锁和其他排他锁。在InnoDB实现中，排他锁的获取需要等待所有现有的锁释放，这通过等待队列机制来实现。</span><br><span class="line"></span><br><span class="line">**意向锁（Intention Lock）** 意向锁是一种表级锁，用于表明事务在表的某些行上持有或即将请求某种类型的锁。意向共享锁（IS）表示事务意图在某些行上获取共享锁，意向排他锁（IX）表示事务意图在某些行上获取排他锁。意向锁的引入大大简化了表级操作的锁冲突检测，避免了遍历所有行锁的开销。</span><br><span class="line"></span><br><span class="line">#### 1.3 按锁算法的实现分类</span><br><span class="line"></span><br><span class="line">**记录锁（Record Lock）** 记录锁锁定索引中的一条具体记录，是最基本的行级锁形式。在InnoDB的实现中，记录锁通过在B+树的叶子节点记录上设置锁标记来实现。锁对象中的heap_no字段精确标识被锁定的记录在页面中的位置。记录锁只能防止其他事务修改或删除该记录，但不能防止在该记录前后插入新记录。</span><br><span class="line"></span><br><span class="line">**间隙锁（Gap Lock）** 间隙锁锁定索引记录之间的间隙，防止其他事务在该间隙中插入新记录。间隙锁的范围是开区间，不包含边界记录本身。InnoDB通过比较索引键值来确定间隙的边界，对于复合索引，间隙的比较需要考虑所有键值列的组合。间隙锁之间不冲突，多个事务可以同时持有相同间隙的间隙锁。</span><br><span class="line"></span><br><span class="line">**临键锁（Next-Key Lock）** 临键锁是记录锁和间隙锁的组合，锁定一个记录以及该记录前面的间隙。这是InnoDB在可重复读隔离级别下的默认锁算法。临键锁有效解决了幻读问题，因为它不仅锁定已存在的记录，还锁定了可能插入新记录的位置。临键锁的范围是左开右闭区间。</span><br><span class="line"></span><br><span class="line">### 2. InnoDB锁系统的深层实现</span><br><span class="line"></span><br><span class="line">#### 2.1 锁对象的数据结构设计</span><br><span class="line"></span><br></pre></td></tr></table></figure>
struct lock_t &#123;
trx_t* trx;           // 拥有该锁的事务
UT_LIST_NODE_T(lock_t) trx_locks; // 事务锁链表节点
dict_table_t* tab_lock; // 表锁信息
dict_index_t* index;    // 索引信息
hash_node_t hash;       // 哈希表节点
ulint type_mode;        // 锁类型和模式
ulint n_bits;          // 位图大小
ulint n_granted_locks; // 已授予的锁数量
ulint n_waiting_locks; // 等待的锁数量
&#125;;
</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**锁哈希表的设计：** InnoDB使用一个全局的锁哈希表来管理所有的锁对象，哈希函数基于space_id和page_no计算。每个哈希桶包含一个锁对象链表，相同页面的所有锁对象都链接在同一个桶中。这种设计支持快速的锁查找和冲突检测，时间复杂度接近O(1)。</span><br><span class="line"></span><br><span class="line">**锁位图的精巧设计：** 对于页面级别的锁管理，InnoDB使用位图来标识页面中哪些记录被锁定。每个记录对应位图中的一位，设置为1表示该记录被锁定。这种压缩表示法大大节省了内存空间，特别是在锁定大量记录时。位图操作使用高效的位运算指令，支持快速的锁状态查询和更新。</span><br><span class="line"></span><br><span class="line">#### 2.2 死锁检测的高级算法</span><br><span class="line"></span><br><span class="line">**增量式死锁检测：** InnoDB不是每次都重新构建整个等待图，而是采用增量式检测。当新的等待关系建立时，算法只检查从新等待者开始的路径是否形成环。这种优化大大减少了检测的计算开销，特别是在高并发场景下效果显著。</span><br><span class="line"></span><br><span class="line">**死锁检测的优先级调度：** 死锁检测器运行在独立的后台线程中，具有较高的调度优先级。检测频率根据系统负载动态调整：在高并发时增加检测频率，在低负载时降低频率以节省CPU资源。检测器还会维护统计信息，包括死锁发生频率、平均解决时间等，用于系统调优。</span><br><span class="line"></span><br><span class="line">**复杂死锁场景的处理：** 实际生产环境中可能出现涉及多个资源类型的复杂死锁，比如同时涉及行锁、表锁、和外键约束锁的死锁。InnoDB的死锁检测器需要构建一个多层次的等待图，包含不同类型的资源节点和等待边。解决这类死锁时，需要考虑不同锁类型的回滚代价。</span><br><span class="line"></span><br><span class="line">#### 2.3 MVCC与锁的深度集成</span><br><span class="line"></span><br><span class="line">**ReadView的内部结构：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>struct ReadView {<br>    trx_id_t low_limit_id;    &#x2F;&#x2F; 生成ReadView时的下一个事务ID<br>    trx_id_t up_limit_id;     &#x2F;&#x2F; 生成ReadView时最小的活跃事务ID<br>    trx_id_t creator_trx_id;  &#x2F;&#x2F; 创建ReadView的事务ID<br>    trx_ids_t m_ids;          &#x2F;&#x2F; 生成ReadView时的活跃事务ID列表<br>    m_low_limit_no;           &#x2F;&#x2F; 最大的事务编号<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**版本可见性的判断算法：** 当事务读取记录时，需要判断记录的某个版本是否对当前事务可见。判断逻辑基于记录的DB_TRX_ID字段和ReadView的信息：如果DB_TRX_ID小于up_limit_id，则该版本对所有事务可见；如果DB_TRX_ID大于等于low_limit_id，则该版本对当前事务不可见；如果DB_TRX_ID在两者之间，则需要检查是否在活跃事务列表中。</span><br><span class="line"></span><br><span class="line">**undo log的链式结构：** 每个事务的undo log形成一个链式结构，记录了该事务的所有修改操作。undo log不仅用于事务回滚，还用于MVCC的版本构建。当需要构建某个历史版本时，InnoDB会从当前版本开始，沿着undo log链向前回溯，逐步应用逆向操作直到达到目标版本。</span><br><span class="line"></span><br><span class="line">### 3. 数据库锁的性能优化策略</span><br><span class="line"></span><br><span class="line">#### 3.1 锁等待的自适应策略</span><br><span class="line"></span><br><span class="line">**等待时间的动态调整：** InnoDB实现了自适应的锁等待策略，根据系统负载和锁竞争情况动态调整等待超时时间。在低负载时延长等待时间以减少不必要的回滚，在高负载时缩短等待时间以快速释放资源。这种策略通过维护系统级的统计信息来实现，包括平均锁持有时间、锁竞争频率等。</span><br><span class="line"></span><br><span class="line">**等待队列的优先级管理：** 对于同一资源的多个等待者，InnoDB可以根据事务的重要性、等待时间、资源消耗等因素进行优先级排序。高优先级的事务可以优先获得锁，这对于关键业务操作特别重要。优先级的计算考虑多个维度，包括事务的年龄、修改的数据量、是否为只读事务等。</span><br><span class="line"></span><br><span class="line">#### 3.2 索引设计对锁性能的影响</span><br><span class="line"></span><br><span class="line">**覆盖索引与锁范围优化：** 当查询能够通过覆盖索引获取所有需要的数据时，InnoDB只需要在二级索引上加锁，而不需要回表访问聚簇索引。这大大减少了锁的数量和范围，提高了并发性能。覆盖索引的设计需要仔细分析查询模式，将经常一起访问的列组合成复合索引。</span><br><span class="line"></span><br><span class="line">**索引前缀长度对锁粒度的影响：** 对于字符串类型的索引，前缀长度的选择直接影响锁的粒度。较短的前缀可能导致多个不同的值映射到相同的索引前缀，从而扩大锁的范围；较长的前缀提供更精确的锁定，但增加了索引的存储开销。最优前缀长度需要在锁粒度和存储效率之间平衡。</span><br><span class="line"></span><br><span class="line">#### 3.3 事务设计对锁性能的优化</span><br><span class="line"></span><br><span class="line">**事务边界的精细控制：** 事务边界的设计直接影响锁的持有时间。长事务会长时间持有锁，阻塞其他事务的执行。优化策略包括：将大事务拆分为多个小事务，减少每个事务的锁持有时间；将只读操作和写操作分离，只读操作使用快照读避免加锁；在事务中优先执行可能失败的操作，减少无效锁持有。</span><br><span class="line"></span><br><span class="line">**批量操作的锁优化：** 对于批量插入、更新、删除操作，可以采用特殊的锁策略。比如批量插入时可以使用INSERT ... ON DUPLICATE KEY UPDATE语法，减少锁冲突；批量更新时可以按照索引顺序进行，避免死锁；批量删除时可以分批进行，避免长时间持有大量锁。</span><br><span class="line"></span><br><span class="line">## 行锁（Row Lock）</span><br><span class="line"></span><br><span class="line">## InnoDB的行锁实现</span><br><span class="line"></span><br><span class="line">InnoDB是MySQL中支持行锁的主要存储引擎：</span><br><span class="line">实现原理：</span><br><span class="line"></span><br><span class="line">1. 当事务需要锁定某行时，InnoDB会在该行对应的索引记录上加锁</span><br><span class="line">2. 如果没有索引，会锁定整个表（实际是锁定所有行）</span><br><span class="line">3. 锁信息存储在内存中的哈希表结构中</span><br><span class="line"></span><br><span class="line">## 表锁（Table Lock）</span><br><span class="line"></span><br><span class="line">## MyISAM的表锁实现</span><br><span class="line"></span><br><span class="line">MyISAM只支持表级锁</span><br><span class="line"></span><br><span class="line">1. 维护一个全局的表锁队列</span><br><span class="line">2. 写锁具有更高优先级</span><br><span class="line">3. 锁信息存储在服务器层面</span><br><span class="line"></span><br><span class="line"># Java 核心技术</span><br><span class="line"></span><br><span class="line">## 数据类型</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **八个基本数据类型（Primitive Data Types）**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### **1. 整型**</span><br><span class="line"></span><br><span class="line">整型用于存储不带小数的整数。Java 提供了四种整型，它们的区别在于所占内存空间的大小，从而影响可存储的数值范围。</span><br><span class="line"></span><br><span class="line">- **byte**</span><br><span class="line">  - 大小：1 字节（8 位）</span><br><span class="line">  - 范围：−128 到 127</span><br><span class="line">  - 用途：主要用于节省内存，尤其是在处理大量数据时，例如在文件或网络传输中。</span><br><span class="line">- **short**</span><br><span class="line">  - 大小：2 字节（16 位）</span><br><span class="line">  - 范围：−32768 到 32767</span><br><span class="line">  - 用途：同样用于节省内存，比 `byte` 的范围更大。</span><br><span class="line">- **int**</span><br><span class="line">  - 大小：4 字节（32 位）</span><br><span class="line">  - 范围：约 −2.1×109 到 2.1×109</span><br><span class="line">  - 用途：这是**最常用**的整型，通常用来表示普通的整数。</span><br><span class="line">- **long**</span><br><span class="line">  - 大小：8 字节（64 位）</span><br><span class="line">  - 范围：约 −9.2×1018 到 9.2×1018</span><br><span class="line">  - 用途：当 `int` 类型的范围不足以存储一个大数时使用，例如处理时间戳、文件大小等。在数值后面需要加上 `L` 或 `l` 来表示，例如 `long myLong = 100L;`。</span><br><span class="line"></span><br><span class="line">#### **2. 浮点型**</span><br><span class="line"></span><br><span class="line">浮点型用于存储带有小数点的数值。</span><br><span class="line"></span><br><span class="line">- **float**</span><br><span class="line">  - 大小：4 字节（32 位）</span><br><span class="line">  - 用途：单精度浮点数，有效位数为 6-7 位。在数值后面需要加上 `F` 或 `f` 来表示，例如 `float myFloat = 3.14f;`。</span><br><span class="line">- **double**</span><br><span class="line">  - 大小：8 字节（64 位）</span><br><span class="line">  - 用途：双精度浮点数，有效位数为 15-16 位。这是**最常用**的浮点型，Java 默认的浮点数类型就是 `double`。</span><br><span class="line"></span><br><span class="line">&gt; **注意**：浮点数存在精度问题，不适合用于精确的金融计算。如果需要精确计算，应使用 `java.math.BigDecimal` 类。</span><br><span class="line"></span><br><span class="line">#### **3. 字符型**</span><br><span class="line"></span><br><span class="line">- **char**</span><br><span class="line">  - 大小：2 字节（16 位）</span><br><span class="line">  - 用途：存储单个字符。在 Java 中，`char` 采用 Unicode 编码，可以表示包括中文在内的所有字符。它可以用单引号 `&#x27;` 括起来，例如 `char myChar = &#x27;A&#x27;;`。</span><br><span class="line"></span><br><span class="line">#### **4. 布尔型**</span><br><span class="line"></span><br><span class="line">- **boolean**</span><br><span class="line">  - 大小：在内存中通常被视为 1 位，但在数组中会占用 1 字节。</span><br><span class="line">  - 用途：用于存储 `true` 或 `false`，表示逻辑值。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **String 类型**</span><br><span class="line"></span><br><span class="line">`String` 是一个非常特殊的类型，它**不是基本数据类型**，而是一个**引用数据类型（Reference Data Type）**。</span><br><span class="line"></span><br><span class="line">#### **String 的核心特性**</span><br><span class="line"></span><br><span class="line">1. **不可变性（Immutability）**</span><br><span class="line">   - `String` 对象一旦被创建，它的值就不能被改变。</span><br><span class="line">   - 当你对 `String` 进行修改操作时，比如拼接字符串，实际上是**创建了一个新的 String 对象**，而原始对象没有改变。</span><br><span class="line">   - 这种不可变性使得 `String` 对象是线程安全的，可以在多线程环境中被安全地共享。</span><br><span class="line">2. **String 的创建**</span><br><span class="line">   - **字面量方式**：`String s = &quot;hello&quot;;`</span><br><span class="line">     - 这种方式创建的字符串会被存储在**字符串常量池（String Pool）**中。</span><br><span class="line">     - 当创建第二个值为 `&quot;hello&quot;` 的字符串时，JVM 会直接从常量池中返回已存在的对象引用，而不会创建新的对象。这是一种重要的内存优化。</span><br><span class="line">   - **new 关键字方式**：`String s = new String(&quot;hello&quot;);`</span><br><span class="line">     - 这种方式会创建一个新的 `String` 对象在堆（Heap）中。即使常量池中已经存在 `&quot;hello&quot;`，也会在堆中再创建一个新的对象。</span><br><span class="line"></span><br><span class="line">#### **String 的常用方法**</span><br><span class="line"></span><br><span class="line">- **拼接**：</span><br><span class="line">  - 使用 `+` 运算符：`String s3 = s1 + s2;`</span><br><span class="line">  - 使用 `concat()` 方法：`s1.concat(s2);`</span><br><span class="line">  - 推荐使用 `StringBuilder` 或 `StringBuffer` 进行大量字符串拼接，因为它们是可变的，效率更高。</span><br><span class="line">- **比较**：</span><br><span class="line">  - `equals()`：比较字符串的内容，返回 `boolean` 类型。</span><br><span class="line">  - `equalsIgnoreCase()`：忽略大小写比较字符串内容。</span><br><span class="line">  - `==`：比较的是**对象的引用地址**，只有当两个引用指向同一个对象时才为 `true`。</span><br><span class="line">- **查找**：</span><br><span class="line">  - `indexOf(char)`：查找字符第一次出现的索引。</span><br><span class="line">  - `contains(String)`：判断是否包含某个子字符串。</span><br><span class="line">- **修改**：</span><br><span class="line">  - `replace(oldChar, newChar)`：替换字符串中的字符。</span><br><span class="line">  - `substring(beginIndex, endIndex)`：截取子字符串。</span><br><span class="line"></span><br><span class="line">#### **为什么不用 char 数组代替 String？**</span><br><span class="line"></span><br><span class="line">虽然 `String` 内部也是用 `char` 数组实现的，但 `String` 的不可变性提供了很多优势：</span><br><span class="line"></span><br><span class="line">- **安全性**：作为方法参数时，可以防止方法内部修改原始字符串。</span><br><span class="line">- **线程安全**：可以在多线程环境下共享。</span><br><span class="line">- **哈希码缓存**：`String` 的哈希码会被缓存，在作为 `HashMap` 的键时，性能更好。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **基本类型与 String 的转换**</span><br><span class="line"></span><br><span class="line">- **基本类型转 String**：</span><br><span class="line">  - `String.valueOf(int i)`</span><br><span class="line">  - `Integer.toString(int i)`</span><br><span class="line">  - `&quot;&quot; + i`</span><br><span class="line">- **String 转基本类型**：</span><br><span class="line">  - `Integer.parseInt(&quot;123&quot;)`</span><br><span class="line">  - `Double.parseDouble(&quot;3.14&quot;)`</span><br><span class="line">  - `Float.parseFloat(&quot;1.23&quot;)`</span><br><span class="line">  - 等等。</span><br><span class="line"></span><br><span class="line">&gt; **注意**：`String` 转基本类型时，如果字符串格式不正确，会抛出 `NumberFormatException`。</span><br><span class="line"></span><br><span class="line">## 锁</span><br><span class="line"></span><br><span class="line">### 1. 内置锁：`synchronized` 关键字</span><br><span class="line"></span><br><span class="line">`synchronized`是Java语言层面的同步机制，使用起来相对简单。它可以修饰方法或代码块，由JVM负责加锁和释放锁，开发者不需要手动管理。</span><br><span class="line"></span><br><span class="line">- **同步方法：** 当你用`synchronized`修饰一个非静态方法时，锁对象是这个方法的实例对象（`this`）。当一个线程进入这个同步方法时，它会获得该实例的锁，其他线程就无法进入这个实例的任何同步方法，直到它释放锁。</span><br><span class="line">- **同步静态方法：** 当`synchronized`修饰一个静态方法时，锁对象是该类的`Class`对象。这意味着所有线程在访问这个类的任何同步静态方法时都会争抢同一把锁，无论有多少个实例。</span><br><span class="line">- **同步代码块：** `synchronized (object)`。这是最灵活的使用方式，你可以指定任何对象作为锁。通过缩小同步范围，可以减少锁的持有时间，从而提高程序的并发性能。</span><br><span class="line"></span><br><span class="line">**synchronized的特点：**</span><br><span class="line"></span><br><span class="line">- **可重入性（Reentrant）：** 一个线程可以重复获取它已经持有的锁，避免死锁。</span><br><span class="line">- **非公平性（Unfair）：** 默认情况下，线程获取锁的顺序是不确定的，先来的不一定先得到。</span><br><span class="line">- **锁的升级：** 为了优化性能，`synchronized`锁的实现经历了从**偏向锁**、**轻量级锁**到**重量级锁**的升级过程。这使得在竞争不激烈的情况下，加锁的开销非常小。</span><br><span class="line">- **内存可见性（Visibility）：** `synchronized`可以保证当一个线程释放锁时，它对共享变量所做的修改会立即刷新到主内存，而当另一个线程获取锁时，它会从主内存中读取最新的变量值。这是由Java内存模型（JMM）的`happens-before`规则保证的。</span><br><span class="line"></span><br><span class="line">### 底层实现机制</span><br><span class="line"></span><br><span class="line">synchronized本质上是基于JVM的**内置锁（Intrinsic Lock）**实现的。每个Java对象都天生具备一个监视器锁（Monitor），这是JVM级别的原生支持。</span><br><span class="line"></span><br><span class="line">**监视器的工作原理：**</span><br><span class="line"></span><br><span class="line">- 当线程进入synchronized代码块时，会执行monitorenter指令获取对象的监视器</span><br><span class="line">- 当线程退出时，执行monitorexit指令释放监视器</span><br><span class="line">- 如果获取失败，线程会被阻塞在操作系统级别</span><br><span class="line"></span><br><span class="line">### 锁升级的演进过程</span><br><span class="line"></span><br><span class="line">synchronized的性能优化经历了一个复杂的演进过程，从最初的重量级锁逐步优化：</span><br><span class="line"></span><br><span class="line">**偏向锁阶段：**</span><br><span class="line">当只有一个线程反复进入同步块时，JVM会将锁偏向于这个线程。此时的开销极低，几乎等同于无锁操作。对象头中会记录偏向的线程ID，后续该线程进入时直接通过简单的比较就能获取锁。</span><br><span class="line"></span><br><span class="line">**轻量级锁阶段：**</span><br><span class="line">当有其他线程开始竞争时，偏向锁会升级为轻量级锁。JVM在当前线程的栈帧中创建锁记录（Lock Record），通过CAS操作尝试将对象头的Mark Word替换为指向锁记录的指针。这个过程避免了操作系统层面的阻塞。</span><br><span class="line"></span><br><span class="line">**重量级锁阶段：**</span><br><span class="line">当CAS操作失败次数过多或者有多个线程同时竞争时，锁会膨胀为重量级锁。此时会创建Monitor对象，利用操作系统的互斥量（Mutex）来实现同步，涉及用户态和内核态的切换。</span><br><span class="line"></span><br><span class="line">### 自动化的特点</span><br><span class="line"></span><br><span class="line">synchronized的最大特点是**完全自动化**。程序员无需关心锁的获取和释放时机，JVM会自动处理所有细节。即使在异常情况下，JVM也能保证锁的正确释放，这大大降低了死锁和资源泄露的风险。</span><br><span class="line"></span><br><span class="line">### 2. 显式锁：`java.util.concurrent.locks.Lock`</span><br><span class="line"></span><br><span class="line">从JDK 1.5开始，`java.util.concurrent.locks`包提供了更灵活、更强大的锁机制，其核心是`Lock`接口。最常用的实现类是**`ReentrantLock`**。</span><br><span class="line"></span><br><span class="line">使用`Lock`需要手动进行加锁和解锁操作，通常是在`try...finally`块中进行，以确保锁在任何情况下都能被释放，防止死锁。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    // 访问共享资源的代码</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lock相比synchronized的优势：</strong></p>
<ul>
<li><strong>中断锁（Interruptibly）：</strong> <code>Lock</code>提供了<code>lockInterruptibly()</code>方法，允许在等待锁的过程中响应中断。而<code>synchronized</code>的线程如果陷入等待锁的状态，是无法被中断的。</li>
<li><strong>尝试获取锁（tryLock）：</strong> <code>Lock</code>提供了<code>tryLock()</code>和<code>tryLock(long timeout, TimeUnit unit)</code>方法，可以尝试获取锁，如果失败则立即返回或在指定时间内放弃，避免无限等待。</li>
<li><strong>公平锁与非公平锁：</strong> <code>ReentrantLock</code>可以创建公平锁（Fair Lock）。公平锁会按照线程请求锁的顺序来分配锁，虽然这可能会带来一些性能开销。而<code>synchronized</code>只能是非公平锁。</li>
<li><strong>绑定多个条件（Condition）：</strong> <code>Lock</code>配合<code>Condition</code>接口，可以实现更灵活的线程等待和唤醒机制，类似<code>Object</code>的<code>wait()</code>和<code>notify()</code>，但功能更强大，一个锁可以有多个等待队列。</li>
<li><strong>读写锁（ReadWriteLock）：</strong> <code>ReadWriteLock</code>是<code>Lock</code>的另一个重要实现，它维护了一对锁：一个用于读操作，一个用于写操作。在读多写少的场景下，多个线程可以同时获取读锁，大大提高了并发性能，只有写操作才需要获取独占的写锁。<code>ReentrantReadWriteLock</code>是其具体实现。</li>
</ul>
<h3 id="Lock接口的设计理念"><a href="#Lock接口的设计理念" class="headerlink" title="Lock接口的设计理念"></a>Lock接口的设计理念</h3><h3 id="显式锁机制"><a href="#显式锁机制" class="headerlink" title="显式锁机制"></a>显式锁机制</h3><p>Lock接口代表了Java并发包中<strong>显式锁</strong>的设计思想。与synchronized的隐式锁不同，Lock要求程序员明确控制锁的生命周期，这带来了更大的灵活性，同时也增加了使用的复杂性。</p>
<h3 id="AQS框架的核心思想"><a href="#AQS框架的核心思想" class="headerlink" title="AQS框架的核心思想"></a>AQS框架的核心思想</h3><p>Lock接口的实现基于AbstractQueuedSynchronizer（AQS）框架，这是Doug Lea设计的一个并发框架的杰作。</p>
<p><strong>同步状态的抽象：</strong><br>AQS使用一个int值来表示同步状态，不同的锁实现可以赋予这个状态不同的含义。比如ReentrantLock用它表示重入次数，Semaphore用它表示许可证数量。</p>
<p><strong>队列化的等待机制：</strong><br>当线程无法获取锁时，AQS会将其包装成节点加入到一个FIFO队列中。这个队列使用双向链表实现，每个节点都包含了线程引用和等待状态信息。</p>
<p><strong>自旋与阻塞的平衡：</strong><br>AQS巧妙地结合了自旋和阻塞两种等待策略。线程在入队后会先进行有限次数的自旋尝试，只有在确定无法获取锁时才会调用LockSupport.park()进入阻塞状态。</p>
<h3 id="3-volatile-关键字"><a href="#3-volatile-关键字" class="headerlink" title="3. volatile 关键字"></a>3. <code>volatile</code> 关键字</h3><p><code>volatile</code>关键字并不是一个锁，它是一种轻量级的同步机制，主要用于保证共享变量的<strong>可见性</strong>和<strong>有序性</strong>。</p>
<ul>
<li><strong>可见性（Visibility）：</strong> 当一个变量被<code>volatile</code>修饰后，一个线程对它的修改会立即被其他线程可见。这是通过在写操作后添加内存屏障，强制将修改后的值刷新到主内存，并在读操作前添加内存屏障，强制从主内存中读取最新值来实现的。</li>
<li><strong>有序性（Ordering）：</strong> <code>volatile</code>可以禁止指令重排序，确保代码的执行顺序不会被打乱。</li>
<li><strong>无法保证原子性（Atomicity）：</strong> <code>volatile</code>无法保证复合操作（如<code>i++</code>）的原子性，因为<code>i++</code>实际上是读、加、写三个操作的组合，这三个操作并非一次完成。如果要保证原子性，需要使用<code>synchronized</code>、<code>Lock</code>或<code>java.util.concurrent.atomic</code>包下的原子类。</li>
</ul>
<p><strong>总结一下：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>synchronized</code></th>
<th><code>Lock</code> (如<code>ReentrantLock</code>)</th>
<th><code>volatile</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>功能</strong></td>
<td>独占锁，保证原子性、可见性、有序性</td>
<td>独占锁，功能更强大，保证原子性、可见性、有序性</td>
<td>轻量级同步，只保证可见性和有序性</td>
</tr>
<tr>
<td><strong>使用方式</strong></td>
<td>关键字，自动加锁和解锁</td>
<td>接口，需要手动加锁和解锁，必须在<code>finally</code>块中释放</td>
<td>关键字，修饰变量</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>较差，功能固定</td>
<td>强，提供了更多高级功能，如可中断、超时、公平锁等</td>
<td>较差，只针对变量</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>JVM优化后性能较高，开销相对较小</td>
<td>高性能，在竞争激烈时通常优于<code>synchronized</code></td>
<td>非常高，几乎没有开销</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单的同步需求，大部分情况都适用</td>
<td>高级同步需求，需要灵活控制锁的获取和释放</td>
<td>变量的写操作不依赖于当前值，需要保证变量的可见性。</td>
</tr>
</tbody></table>
<h3 id="4-乐观锁-Optimistic-Locking"><a href="#4-乐观锁-Optimistic-Locking" class="headerlink" title="4. 乐观锁 (Optimistic Locking)"></a>4. 乐观锁 (Optimistic Locking)</h3><p>与之前讨论的<strong>悲观锁</strong>（<code>synchronized</code>和<code>Lock</code>）不同，乐观锁并非一个具体的Java关键字或类，而是一种<strong>并发控制的思想和策略</strong>。悲观锁认为“总会有其他线程来修改数据”，所以在访问共享资源前，先对资源加锁，确保独占访问。而乐观锁则认为“数据冲突发生的概率很小”，所以它<strong>不加锁</strong>，而是假设所有线程都能正常执行，只有在数据更新提交时，才去检查在此期间数据是否被其他线程修改过。</p>
<p>如果检查到数据没有被修改，则更新成功。如果发现数据已经被修改，则更新失败。处理失败的方式通常有两种：</p>
<ol>
<li><strong>重试：</strong> 循环尝试，直到更新成功为止。</li>
<li><strong>放弃：</strong> 抛出异常或直接返回失败，由调用方处理。</li>
</ol>
<p><strong>乐观锁的实现方式：</strong></p>
<p>乐观锁的核心在于如何“检查数据是否被修改”。在Java中，常见的实现方式有两种：</p>
<ul>
<li><p>版本号（Version Number）：</p>
<p>在数据表中增加一个version字段。每次读取数据时，也把version字段读出来。当要进行数据更新时，带上之前读取的version值，在更新语句中加入WHERE version &#x3D; &lt;当前版本号&gt;的条件。如果更新成功，同时把version值加1。</p>
<ul>
<li><p><strong>SQL示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE products <span class="type">SET</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">100</span>, version = version + <span class="number">1</span></span><br><span class="line"><span class="type">WHERE</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">123</span> <span class="type">AND</span> <span class="variable">version</span> <span class="operator">=</span> &lt;之前读取的版本号&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原理：</strong> 如果在更新时，其他线程已经修改了这条数据，那么<code>version</code>值已经改变，上述<code>UPDATE</code>语句的<code>WHERE</code>条件将不成立，导致更新失败，影响行数为0。此时，你可以选择重试或放弃。</p>
</li>
</ul>
</li>
<li><p>CAS (Compare-And-Swap) 算法：</p>
<p>这是乐观锁在硬件层面的支持，也是Java中实现乐观锁的核心机制。CAS是一种原子操作，它包含三个操作数：</p>
<ul>
<li><strong>V (Value)：</strong> 内存地址中存放的旧值。</li>
<li><strong>A (Expected)：</strong> 预期的旧值。</li>
<li><strong>B (New)：</strong> 想要写入的新值。</li>
</ul>
<p>CAS的操作逻辑是：</p>
<p>如果内存地址V中的值等于预期值A，那么就将V的值更新为新值B。否则，什么都不做。整个操作是原子性的，由CPU指令直接完成。</p>
<p>Java中<code>java.util.concurrent.atomic</code>包下的所有原子类，如<code>AtomicInteger</code>、<code>AtomicLong</code>等，都是基于CAS实现的。</p>
<p><strong>AtomicInteger示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="comment">// 假设多个线程同时执行以下操作</span></span><br><span class="line">count.incrementAndGet(); <span class="comment">// 内部就是CAS操作</span></span><br></pre></td></tr></table></figure>

<p><code>incrementAndGet()</code>方法的内部实现类似于一个自旋重试的循环：</p>
<ol>
<li>获取当前值<code>current</code>。</li>
<li>计算新值<code>next = current + 1</code>。</li>
<li>使用CAS尝试将<code>current</code>更新为<code>next</code>。</li>
<li>如果更新失败（说明<code>current</code>已经被其他线程修改），则重新回到第一步，再次获取最新值并尝试更新。</li>
</ol>
</li>
</ul>
<p><strong>悲观锁与乐观锁的比较：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>悲观锁 (<code>synchronized</code>, <code>Lock</code>)</th>
<th>乐观锁 (CAS, 版本号)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>加锁方式</strong></td>
<td>独占资源时先加锁，阻止其他线程访问</td>
<td>不加锁，只在提交时进行冲突检测</td>
</tr>
<tr>
<td><strong>冲突处理</strong></td>
<td>线程排队等待锁，串行执行</td>
<td>线程失败后重试或放弃，并发执行</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td><strong>写操作多、竞争激烈</strong>的场景。数据冲突概率高。</td>
<td><strong>读操作多、写操作少</strong>的场景。数据冲突概率低。</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>在高竞争环境下，线程切换和上下文开销大，性能下降。</td>
<td>在低竞争环境下，无锁开销，性能极高。在高竞争环境下，大量重试可能导致CPU开销增加。</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<p>在Java中，<strong>悲观锁</strong>和<strong>乐观锁</strong>是两种截然不同的并发控制策略。悲观锁（<code>synchronized</code>, <code>Lock</code>）适合<strong>写多读少</strong>的场景，能够保证数据的一致性，但会牺牲一定的性能。而乐观锁（<strong>CAS</strong>、<strong>版本号</strong>）则适合<strong>读多写少</strong>的场景，通过无锁的并发操作提高了性能，但在高竞争下可能导致频繁重试，反而降低效率。理解这两种锁的思想，可以帮助你根据具体的业务场景选择最合适的并发控制方案。</p>
<p>好的，我们来继续完善Java中关于锁的介绍，增加<strong>死锁</strong>及其解决方案的内容。</p>
<hr>
<h3 id="5-死锁-Deadlock"><a href="#5-死锁-Deadlock" class="headerlink" title="5. 死锁 (Deadlock)"></a>5. 死锁 (Deadlock)</h3><p><strong>死锁</strong>是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法继续执行。</p>
<p><strong>死锁的产生</strong>是一个非常经典的多线程问题，通常发生在线程需要同时持有多个锁的场景中。一个简单的死锁场景是：线程A持有锁1，想获取锁2；而线程B持有锁2，想获取锁1。此时两个线程都无法继续执行，从而进入死锁状态。</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 线程A</span><br><span class="line">synchronized (lock1) &#123;</span><br><span class="line">    synchronized (lock2) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 线程B</span><br><span class="line">synchronized (lock2) &#123;</span><br><span class="line">    synchronized (lock1) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h4><p>死锁的发生需要同时满足以下四个条件，缺一不可：</p>
<ol>
<li><strong>互斥条件（Mutual Exclusion）：</strong> 至少有一个资源是独占的，即一次只能被一个线程使用。这是锁本身的基本特性。</li>
<li><strong>请求与保持条件（Hold and Wait）：</strong> 一个线程因请求资源而阻塞时，它对自己已获得的资源保持不放。</li>
<li><strong>不剥夺条件（No Preemption）：</strong> 线程已获得的资源在未使用完之前，不能被强行剥夺，只能由该线程自己释放。</li>
<li><strong>循环等待条件（Circular Wait）：</strong> 存在一个线程等待链，其中每个线程都持有下一个线程所需的资源。例如：线程A等待线程B，线程B等待线程C，线程C又等待线程A。</li>
</ol>
<h4 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h4><p>解决死锁的根本思想是<strong>破坏上述四个必要条件之一或多个</strong>。通常，我们无法破坏互斥条件（因为资源就是独占的），因此主要从其他三个条件入手。</p>
<ol>
<li><strong>破坏“请求与保持”条件：</strong><ul>
<li><strong>一次性获取所有锁：</strong> 线程在开始执行时，就一次性获取所有需要的锁。如果获取不成功，则释放所有已获得的锁，然后等待一段时间后再次尝试。</li>
<li><strong>优点：</strong> 简单有效。</li>
<li><strong>缺点：</strong> 可能会降低并发性，因为线程在很早就持有了锁，即使这些锁在后面才被使用。</li>
</ul>
</li>
<li><strong>破坏“不剥夺”条件：</strong><ul>
<li><strong>使用可中断的锁：</strong> 使用<code>Lock</code>接口提供的<code>tryLock()</code>方法。当一个线程尝试获取锁失败时，它可以选择放弃并释放已持有的锁，而不是一直等待。<code>Lock.tryLock(long time, TimeUnit unit)</code>方法可以在指定时间内尝试获取锁，超时后会放弃。</li>
<li><strong>优点：</strong> 提高了灵活性，线程可以响应中断或超时，避免无限等待。</li>
<li><strong>缺点：</strong> 实现起来相对复杂，需要开发者手动处理获取锁失败的情况。</li>
</ul>
</li>
<li><strong>破坏“循环等待”条件：</strong><ul>
<li><strong>按顺序获取锁：</strong> 对所有的锁进行排序，并强制所有线程都按照相同的顺序获取锁。</li>
<li><strong>示例：</strong> 如果线程A和线程B都需要<code>lock1</code>和<code>lock2</code>，那么它们都必须先获取<code>lock1</code>，再获取<code>lock2</code>。这样就杜绝了线程A持有<code>lock1</code>等待<code>lock2</code>，同时线程B持有<code>lock2</code>等待<code>lock1</code>的循环。</li>
<li><strong>优点：</strong> 这是最常用、最有效的死锁解决方案，实现起来也相对简单。</li>
<li><strong>缺点：</strong> 有时很难对所有锁进行全局排序，特别是在代码模块化程度较高、依赖关系复杂的情况下。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>在实际开发中，预防死锁的最佳实践通常是<strong>破坏循环等待条件</strong>，即<strong>统一锁的获取顺序</strong>。这是最简单且最有效的方案。如果业务场景需要更灵活的控制，可以考虑使用<code>Lock</code>接口，利用<code>tryLock()</code>方法来破坏“不剥夺”条件，实现更复杂的死锁处理逻辑。</p>
<p>好的，我们来详细介绍<strong>银行家算法 (Banker’s Algorithm)</strong>。</p>
<hr>
<h3 id="银行家算法概述"><a href="#银行家算法概述" class="headerlink" title="银行家算法概述"></a>银行家算法概述</h3><p>银行家算法是一种著名的<strong>死锁避免算法</strong>，由荷兰计算机科学家Dijkstra在1965年提出。它的核心思想是：在每次分配资源之前，先进行一次<strong>安全性检查</strong>。如果分配后系统仍然处于<strong>安全状态</strong>，则分配资源；否则，不予分配，线程需要等待。</p>
<ul>
<li>优点：比死锁预防更灵活，能提高资源利用率。</li>
<li>缺点：算法复杂，需要预知进程的最大资源需求，并且系统开销大。</li>
</ul>
<p>之所以叫“银行家算法”，是因为它的工作原理类似于银行管理贷款。银行家在发放贷款时，会先确保这笔贷款发放后，自己还有足够的资金来满足所有客户可能提出的最大取款需求，从而避免因无法支付而破产的风险。</p>
<p>简单来说，银行家算法通过以下两个步骤来避免死锁：</p>
<ol>
<li><strong>安全状态的定义：</strong> 系统能够找到一个<strong>安全序列</strong>，使得所有线程都能按照这个序列执行完毕。</li>
<li><strong>资源分配策略：</strong> 当一个线程请求资源时，算法会先假设分配成功，然后检查系统是否仍处于安全状态。如果安全，就真的分配；如果不安全，就拒绝分配。</li>
</ol>
<hr>
<h3 id="银行家算法中的几个重要数据结构"><a href="#银行家算法中的几个重要数据结构" class="headerlink" title="银行家算法中的几个重要数据结构"></a>银行家算法中的几个重要数据结构</h3><p>为了实现算法，需要维护以下几个关键数据结构，假设系统中有<code>n</code>个线程和<code>m</code>种资源：</p>
<ul>
<li><strong>Available (可用资源矩阵)：</strong> 一个长度为<code>m</code>的向量。<code>Available[j]</code>表示第<code>j</code>种资源目前可用的数量。</li>
<li><strong>Max (最大需求矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Max[i, j]</code>表示线程<code>i</code>最多需要第<code>j</code>种资源多少个。</li>
<li><strong>Allocation (已分配资源矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Allocation[i, j]</code>表示线程<code>i</code>目前已拥有第<code>j</code>种资源多少个。</li>
<li><strong>Need (需求矩阵)：</strong> 一个<code>n * m</code>的矩阵。<code>Need[i, j]</code>表示线程<code>i</code>还需要第<code>j</code>种资源多少个才能完成任务。<ul>
<li><code>Need[i, j] = Max[i, j] - Allocation[i, j]</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="银行家算法的核心：安全状态的判断"><a href="#银行家算法的核心：安全状态的判断" class="headerlink" title="银行家算法的核心：安全状态的判断"></a>银行家算法的核心：安全状态的判断</h3><p>判断系统是否处于安全状态是银行家算法的核心。一个系统处于<strong>安全状态</strong>，当且仅当存在一个<strong>安全序列</strong><code>&lt;P1, P2, ..., Pn&gt;</code>。这个序列满足：对于序列中每一个线程<code>Pi</code>，它所需要的资源都能由系统中当前可用的资源，以及前面所有已完成的线程释放的资源来满足。</p>
<p><strong>安全性检查算法的步骤：</strong></p>
<ol>
<li><strong>初始化：</strong><ul>
<li>创建一个<code>Work</code>向量，初始化为<code>Available</code>（即当前可用资源）。</li>
<li>创建一个<code>Finish</code>向量，初始化为<code>false</code>，表示所有线程都未完成。</li>
</ul>
</li>
<li><strong>寻找安全线程：</strong><ul>
<li>从所有线程中找到一个线程<code>i</code>，满足以下两个条件：<ul>
<li><code>Finish[i]</code>为<code>false</code>。</li>
<li><code>Need[i]</code>向量中的每一个值都小于或等于<code>Work</code>向量中对应的值。</li>
<li>换句话说，线程<code>i</code>所需要的资源小于或等于当前可用的资源。</li>
</ul>
</li>
</ul>
</li>
<li><strong>释放资源：</strong><ul>
<li>如果找到了这样的线程<code>i</code>，则认为它可以顺利执行完毕。</li>
<li>模拟该线程执行完毕并释放资源，更新<code>Work</code>向量：<code>Work = Work + Allocation[i]</code>。</li>
<li>将<code>Finish[i]</code>设置为<code>true</code>。</li>
</ul>
</li>
<li><strong>循环检查：</strong><ul>
<li>重复步骤2和步骤3，直到找不到满足条件的线程。</li>
</ul>
</li>
<li><strong>判断结果：</strong><ul>
<li>如果最终所有线程的<code>Finish</code>都为<code>true</code>，则说明找到了一个安全序列，系统处于<strong>安全状态</strong>。</li>
<li>如果还有线程的<code>Finish</code>为<code>false</code>，则说明系统处于<strong>不安全状态</strong>，可能存在死锁。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="银行家算法的流程：资源分配"><a href="#银行家算法的流程：资源分配" class="headerlink" title="银行家算法的流程：资源分配"></a>银行家算法的流程：资源分配</h3><p>当一个线程<code>P</code>请求资源时，银行家算法会执行以下步骤：</p>
<ol>
<li><strong>请求检查：</strong> 检查线程<code>P</code>请求的资源数量是否小于或等于其<code>Need</code>向量中的需求量。如果不是，说明线程<code>P</code>的请求不合理，拒绝分配。</li>
<li><strong>可用性检查：</strong> 检查线程<code>P</code>请求的资源数量是否小于或等于当前<code>Available</code>中的资源数量。如果不是，说明资源不足，线程<code>P</code>需要等待。</li>
<li><strong>预分配并进行安全性检查：</strong><ul>
<li>假设资源可以分配，<strong>临时</strong>进行以下操作：<ul>
<li><code>Available = Available - Request</code></li>
<li><code>Allocation[P] = Allocation[P] + Request</code></li>
<li><code>Need[P] = Need[P] - Request</code></li>
</ul>
</li>
<li>调用上面的<strong>安全性检查算法</strong>，判断系统是否处于安全状态。</li>
</ul>
</li>
<li><strong>正式分配或拒绝：</strong><ul>
<li>如果安全性检查的结果是<strong>安全</strong>，则正式分配资源，并保留步骤3中的修改。</li>
<li>如果安全性检查的结果是<strong>不安全</strong>，则回滚步骤3中的所有临时修改，拒绝分配资源，线程<code>P</code>需要等待。</li>
</ul>
</li>
</ol>
<h3 id="银行家算法的优缺点"><a href="#银行家算法的优缺点" class="headerlink" title="银行家算法的优缺点"></a>银行家算法的优缺点</h3><ul>
<li><strong>优点：</strong><ul>
<li>可以有效地避免死锁的发生，保证系统的安全性。</li>
<li>通过提前检查，可以最大化地利用资源，提高系统的并发性。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>计算开销大：</strong> 每次分配资源都需要运行安全性检查算法，增加了系统的开销。</li>
<li><strong>过于保守：</strong> 安全状态不等于无死锁，不安全状态也不等于一定发生死锁。算法为了确保安全，可能会拒绝一些本可以成功分配的请求，从而降低了系统的吞吐量。</li>
<li><strong>条件苛刻：</strong> 算法要求线程在开始前就声明其所需的最大资源量，这在实际应用中很难做到。</li>
<li><strong>资源数量固定：</strong> 算法假设系统中资源的数量是固定的，不能动态增减。</li>
</ul>
</li>
</ul>
<p>因此，银行家算法虽然在理论上非常完美，但在实际操作系统中很少被直接完整地实现。然而，它的核心思想——<strong>通过安全性检查来避免死锁</strong>——仍然是许多并发控制策略的重要理论基础。</p>
<h3 id="实际应用中的死锁处理"><a href="#实际应用中的死锁处理" class="headerlink" title="实际应用中的死锁处理"></a>实际应用中的死锁处理</h3><p>在实际的并发编程和数据库系统中，最常见的死锁处理方式是：</p>
<ul>
<li><p>死锁预防(通过编程规范)：</p>
<ul>
<li>加锁顺序一致：规定所有线程在获取多个锁时，必须按照相同的顺序。这是最有效的预防死锁的编程实践。</li>
<li>使用超时锁：尝试获取锁时设置一个超时时间，如果超时未获取到锁，则放弃本次操作并释放已持有的锁，然后重试。这破坏了”请求与保持”条件。例如Java的ReentrantLocktryLock(timeout)。</li>
<li>避免嵌套锁：尽量减少持有多个锁的情况。</li>
</ul>
</li>
<li><p>死锁检测与恢复(数据库系统)：</p>
<ul>
<li>大多数关系型数据库(如MySQL InnoDB)都实现了死锁检测机制。当检测到死锁时，数据库会自动选择一个成本较低的事务(“牺牲品”)进行回滚，从而解除死锁。客户端应用会收到相应的错误码(例如MySQL中的Deadlock found when trying to get lock; try restarting transaction)。应用程序通常需要捕获这个错误并重试事务。理解死锁的四个必要条件是关键，因为解决死锁的根本方法就是破坏其中一个或多个条件。</li>
</ul>
</li>
</ul>
<h2 id="多线程与线程池"><a href="#多线程与线程池" class="headerlink" title="多线程与线程池"></a>多线程与线程池</h2><p>在 Java 中，多线程是实现并发编程的关键技术，它允许程序同时执行多个任务。线程池则是管理和复用线程的重要机制，能有效提升系统性能和资源利用率。</p>
<h3 id="线程（Thread）的概念与生命周期"><a href="#线程（Thread）的概念与生命周期" class="headerlink" title="线程（Thread）的概念与生命周期"></a>线程（Thread）的概念与生命周期</h3><p>线程是操作系统调度的最小单位，是进程中的一个执行路径。一个进程可以包含多个线程，这些线程共享进程的内存空间。</p>
<p>线程的生命周期通常包含以下六种状态（定义在 java.lang.Thread.State 枚举中）：</p>
<ul>
<li><p>NEW（新建）：线程被创建但尚未启动。当使用 new Thread() 创建一个线程实例后，它就处于此状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello from a new thread!&quot;</span>));</span><br><span class="line"><span class="comment">// 此时 myThread 处于 NEW 状态，尚未执行 start()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>RUNNABLE（可运行）：线程已调用 start() 方法，正在 JVM 中运行（可能正在执行，也可能在等待 CPU 调度）。一个 RUNNABLE 状态的线程可能正在运行，也可能并没有运行，它仅仅是具备了运行的资格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myThread.start();</span><br><span class="line"><span class="comment">// 此时 myThread 进入 RUNNABLE 状态，等待 CPU 调度执行 run() 方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BLOCKED (阻塞)：线程正在等待获取一个监视器锁(例如，进入 synchronized 块或方法)。当一个线程试图访问被其他线程锁定的资源时，它会进入此状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 线程已经持有 lock 对象的锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// ... 线程 A 正在执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程 B 尝试获取 lock 对象的锁，但被线程 A 占用，会进入 BLOCKED 状态</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WAITING (等待)：线程无限制地等待另一个线程执行特定操作。例如，调用 Object.wait(), Thread.join() (无参数) 或 LockSupport.park().这些方法会使线程放弃 CPU 使用权，并进入无限制等待，直到被其他线程 notify(), notifyAll() 或 unpark() 唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">sharedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 线程 A:</span></span><br><span class="line"><span class="keyword">synchronized</span> (sharedObject) &#123;</span><br><span class="line">    sharedObject.wait(); <span class="comment">// 线程 A 进入 WAITING 状态，并释放 sharedObject 的锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程 B:</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line">threadA.start();</span><br><span class="line">threadA.join(); <span class="comment">// 线程 B 等待 threadA 执行完毕，进入 WAITING 状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TIMED_WAITING (有时限等待)：线程在指定的时间内等待另一个线程执行特定操作，或者休眠。例如，调用 Thread.sleep(long millis)、Object.wait(long timeout)、Thread.join(long millis)、LockSupport.parkNanos() 或 LockSupport.parkUntil()。一旦超时间到达，线程会自动从等待状态唤醒，并尝试重新进入 RUNNABLE 状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 线程进入 TIMED_WAITING 状态 1 秒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TERMINATED (终止): 线程已执行完毕其 run() 方法, 或者因未捕获的异常退出。线程一旦进入此状态, 就不能再被重新启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程的 run() 方法执行完毕</span></span><br><span class="line"><span class="comment">// 线程在执行过程中抛出未捕获的异常</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类:"></a>继承 Thread 类:</h4><ul>
<li>通过创建 Thread 类的子类, 并重写其 run() 方法, 在该方法中定义线程执行的任务。</li>
<li>创建 Thread 子类的实例, 并调用其 start() 方法来启动线程。调用 start() 方法会使线程进入 RUNNABLE 状态, 并由 JVM 调度执行 run() 方法; 直接调用 run() 方法则只是在当前线程中执行普通方法, 不会启动新线程。</li>
<li>优点: 实现简单直观, 代码结构清晰。</li>
<li>缺点: Java 是单继承的, 如果你的类已经继承了其他类, 就不能再继承 Thread 类。这限制了类的灵活性。此外, 任务 (run() 方法中的逻辑 ) 与线程本身 (Thread 对象) 紧密耦合, 不利于任务的复用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyThread.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + threadName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running via extending Thread.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread: &quot;</span> + threadName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">                <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> + threadName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> + threadName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadCreationDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCreationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread started.&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;MyThread-1&quot;</span>);</span><br><span class="line">        thread1.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;MyThread-2&quot;</span>);</span><br><span class="line">        thread2.start(); <span class="comment">// 启动另一个新线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished starting other threads.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现-Runnable-接口："><a href="#实现-Runnable-接口：" class="headerlink" title="实现 Runnable 接口："></a>实现 <strong>Runnable</strong> 接口：</h4><ul>
<li>定义一个类实现 <strong>Runnable</strong> 接口，并实现其抽象方法 public void run()。run() 方法中包含线程执行的具体任务。</li>
<li>创建 <strong>Runnable</strong> 实现类的实例，然后将其作为参数传入 Thread 类的构造器 (new Thread(Runnable target))，再调用 Thread 实例的 start() 方法。</li>
<li>优点：<ul>
<li>推荐方式：避免了 Java 单继承的限制，你的类可以同时继承其他类来实现 <strong>Runnable</strong> 接口。</li>
<li>任务与线程解耦：Runnable 对象只负责定义任务，而 Thread 对象负责执行任务。这意味着同一个 <strong>Runnable</strong> 对象可以被多个 Thread 实例共享执行，从而更好地实现资源的共享和任务的复用。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyRunnable.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + taskName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running via implementing Runnable.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task: &quot;</span> + taskName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task &quot;</span> + taskName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task &quot;</span> + taskName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadCreationDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCreationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread started.&quot;</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;Runnable-Task-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable1);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;Runnable-Task-2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable2, <span class="string">&quot;Custom-Thread-Name&quot;</span>); <span class="comment">// 可以给线程命名</span></span><br><span class="line">        thread4.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished starting runnable threads.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><p><code>Callable</code> 是 Java 并发编程中一个非常重要的接口，它与 <code>Runnable</code> 类似，都用于定义一个可在线程中执行的任务。但 <code>Callable</code> 提供了更强大的功能，主要体现在两个方面：</p>
<ol>
<li><strong>可以返回结果：</strong> <code>Callable</code> 的 <code>call()</code> 方法可以返回一个泛型类型的结果。</li>
<li><strong>可以抛出异常：</strong> <code>Callable</code> 的 <code>call()</code> 方法可以声明抛出任何 <code>Exception</code>。</li>
</ol>
<p>这与 <code>Runnable</code> 接口形成了鲜明对比，<code>Runnable</code> 的 <code>run()</code> 方法没有返回值，也不能抛出受检异常（checked exception）。</p>
<ul>
<li><h3 id="Callable-的基本结构"><a href="#Callable-的基本结构" class="headerlink" title="Callable 的基本结构"></a><code>Callable</code> 的基本结构</h3></li>
</ul>
<p><code>Callable</code> 接口是一个泛型接口，定义如下：</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 计算并返回结果，或在无法做到时抛出异常。</span><br><span class="line">     * @return 计算结果</span><br><span class="line">     * @throws Exception 如果无法计算结果</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;V&gt;</code>：泛型参数，代表 <code>call()</code> 方法将要返回的结果类型。</p>
</li>
<li><p><code>V call()</code>：<code>call()</code> 方法的签名，它返回一个 <code>V</code> 类型的结果，并且可以抛出异常。</p>
</li>
<li><h3 id="如何使用-Callable"><a href="#如何使用-Callable" class="headerlink" title="如何使用 Callable"></a>如何使用 <code>Callable</code></h3></li>
</ul>
<p><code>Callable</code> 接口本身并不能直接作为 <code>Thread</code> 的构造参数。它需要配合 <code>ExecutorService</code> 线程池和 <code>Future</code> 接口一起使用。</p>
<p><strong>典型使用流程：</strong></p>
<ol>
<li><p><strong>创建 Callable 任务：</strong> 实现 <code>Callable</code> 接口，并在 <code>call()</code> 方法中编写具体的业务逻辑，返回一个结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务执行完毕，返回结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 ExecutorService 线程池：</strong> 使用 <code>Executors</code> 工厂类创建线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提交 Callable 任务：</strong> 使用 <code>ExecutorService</code> 的 <code>submit()</code> 方法提交任务。<code>submit()</code> 方法会返回一个 <code>Future</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">MyCallableTask</span>();</span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取任务结果：</strong> 通过 <code>Future</code> 对象的 <code>get()</code> 方法来获取 <code>Callable</code> 任务的执行结果。</p>
<ul>
<li><code>future.get()</code> 是一个<strong>阻塞</strong>方法，它会一直等待，直到任务执行完毕并返回结果。</li>
<li>如果任务执行过程中抛出了异常，<code>get()</code> 方法也会将这个异常包装在 <code>ExecutionException</code> 中重新抛出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 阻塞等待结果</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 线程被中断</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 任务执行过程中抛出的异常</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><h3 id="Callable-与-Runnable-的区别"><a href="#Callable-与-Runnable-的区别" class="headerlink" title="Callable 与 Runnable 的区别"></a><code>Callable</code> 与 <code>Runnable</code> 的区别</h3></li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>Callable</code></th>
<th><code>Runnable</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>返回值</strong></td>
<td><code>call()</code> 方法有返回值（泛型 <code>V</code>）</td>
<td><code>run()</code> 方法没有返回值（<code>void</code>）</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td><code>call()</code> 方法可以抛出受检异常</td>
<td><code>run()</code> 方法不能直接抛出受检异常</td>
</tr>
<tr>
<td><strong>执行方式</strong></td>
<td>必须配合 <code>ExecutorService.submit()</code> 执行</td>
<td>可以直接作为 <code>Thread</code> 构造函数的参数，也可以通过 <code>ExecutorService.execute()</code> 或 <code>submit()</code> 执行</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>适用于需要返回计算结果或可能抛出异常的异步任务</td>
<td>适用于简单的异步任务，不需要返回结果</td>
</tr>
</tbody></table>
<hr>
<ul>
<li><h3 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a><code>Future</code> 接口</h3></li>
</ul>
<p><code>Future</code> 接口是 <code>Callable</code> 的重要伴侣，它代表一个<strong>异步计算的结果</strong>。它提供了检查任务是否完成、等待任务完成以及获取任务结果的方法。</p>
<p><code>Future</code> 接口的主要方法：</p>
<ul>
<li><p><code>V get()</code>: 阻塞式地等待任务完成，并返回结果。</p>
</li>
<li><p><code>V get(long timeout, TimeUnit unit)</code>: 在指定时间内等待任务完成，超时则抛出 <code>TimeoutException</code>。</p>
</li>
<li><p><code>boolean isDone()</code>: 检查任务是否已经完成。</p>
</li>
<li><p><code>boolean cancel(boolean mayInterruptIfRunning)</code>: 尝试取消任务。</p>
</li>
<li><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
</ul>
<p><code>Callable</code> 是 Java 并发编程中一个更高级的任务抽象，它解决了 <code>Runnable</code> 接口无法返回结果和处理受检异常的痛点。通过与 <code>ExecutorService</code> 和 <code>Future</code> 接口的组合使用，<code>Callable</code> 使得异步编程变得更加简单和灵活，非常适合那些需要耗时计算并返回结果的场景，比如网络请求、数据处理等。</p>
<h4 id="线程池-Thread-Pool"><a href="#线程池-Thread-Pool" class="headerlink" title="线程池 (Thread Pool)"></a>线程池 (Thread Pool)</h4><p>线程池是一种基于池化思想的线程管理机制，用于管理和复用线程，而不是在每次需要执行任务时都创建新线程。</p>
<ul>
<li><p><strong>为什么使用线程池？</strong></p>
<ul>
<li>降低资源消耗:通过重复利用已创建的线程，降低线程创建和销毁的开销。</li>
<li>提高响应速度:当任务到达时，任务可以直接执行，无需等待线程创建。</li>
<li>提高线程的可管理性:线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配、调优和监控。</li>
<li>提供更多功能:如定时执行、周期执行、单线程化等。</li>
</ul>
</li>
<li><p><strong>线程池的核心参数 (ThreadPoolExecutor 构造方法)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">    TimeUnit unit,</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize: 核心线程数。线程池中始终保持的线程数量，即使它们处于空闲状态，除非设置了 allowCoreThreadTimeOut(true)。</li>
<li>maximumPoolSize: 最大线程数。线程池中允许存在的最大线程数量。当工作队列已满且核心线程都在忙碌时，线程池会创建新的非核心线程，直到达到这个数量。</li>
<li>keepAliveTime: 当线程池中的线程数量超过 corePoolSize 时，这些空闲的非核心线程在终止之前等待新任务的最长时间。</li>
<li>unit: keepAliveTime 参数的时间单位。</li>
<li>workQueue: 任务队列 (阻塞队列)。用于存放等待执行的任务。<ul>
<li>ArrayBlockingQueue: 基于数组的有界阻塞队列，需要指定容量。</li>
<li>LinkedBlockingQueue: 基于链表的阻塞队列，容量可以指定，也可以是无界的（默认）。如果使用无界队列，maximumPoolSize 参数将失效。</li>
<li>SynchronousQueue: 一个不存储元素的阻塞队列。每个插入操作必须等待一个对应的移除操作，反之亦然。</li>
<li>PriorityBlockingQueue: 支持优先级的无界阻塞队列，按照自然顺序或自定义比较器排序。</li>
</ul>
</li>
<li>threadFactory: 线程工厂。用于创建新线程，可以自定义线程的命名、优先级等。</li>
<li>handler: 拒绝策略 (当线程池和工作队列都已满时，新的任务到来时的处理方式)。<ul>
<li>ThreadPoolExecutor.AbortPolicy (默认): 直接抛出 RejectedExecutionException 异常。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy: 由调用线程 (提交任务的线程) 执行任务。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy: 丢弃队列中最老的任务，然后尝试提交当前任务。</li>
<li>ThreadPoolExecutor.DiscardPolicy: 直接丢弃当前新提交的任务。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线程池的执行流程</strong></p>
<ol>
<li>当一个任务提交到线程池时，如果当前运行的线程数小于 corePoolSize，即使有空闲线程，也会创建并启动一个新线程来执行任务。</li>
<li>如果当前运行的线程数大于或等于 corePoolSize，但任务队列 workQueue 未满，任务会被添加到 workQueue 中等待执行。</li>
<li>如果 workQueue 已满，但当前运行的线程数小于 maximumPoolSize，线程池会创建新的非核心线程来执行任务。</li>
<li>如果当前运行的线程数等于 maximumPoolSize 且 workQueue 已满，线程池会根据拒绝策略来处理新提交的任务。</li>
</ol>
</li>
<li><p><strong>Java 内置的四种常用线程池 (通过 Executors 工厂类创建)</strong></p>
<ul>
<li>FixedThreadPool (固定大小线程池)<ul>
<li>Executors.newFixedThreadPool(int nThreads)</li>
<li>corePoolSize &#x3D; maximumPoolSize &#x3D; nThreads</li>
<li>使用无界 LinkedBlockingQueue。</li>
<li>特点：可控制并发的线程数，超出的任务会在队列中等待。</li>
<li>问题：当任务提交速度远大于处理速度时，队列会不断增长，可能导致 OOM。</li>
</ul>
</li>
<li>SingleThreadExecutor (单线程线程池)<ul>
<li>Executors.newSingleThreadExecutor()</li>
<li>corePoolSize &#x3D; maximumPoolSize &#x3D; 1</li>
<li>使用无界 LinkedBlockingQueue。</li>
<li>特点：保证所有任务都在一个线程中按顺序执行。</li>
<li>问题：同 FixedThreadPool，队列无限增长可能导致 OOM。</li>
</ul>
</li>
<li>CachedThreadPool（可缓存线程池）<ul>
<li>Executors.newCachedThreadPool()</li>
<li>corePoolSize &#x3D; 0, maximumPoolSize &#x3D; Integer.MAX_VALUE</li>
<li>使用 SynchronousQueue。</li>
<li>keepAliveTime &#x3D; 60s</li>
<li>特点：当任务到来时，有空闲线程则复用，无空闲线程则创建新线程。适用于大量短时任务。</li>
<li>问题：maximumPoolSize 过大，当任务并发量极高时，可能创建大量线程，导致系统资源耗尽 (OOM)。</li>
</ul>
</li>
<li>ScheduledThreadPool（定时任务线程池）<ul>
<li>Executors.newScheduledThreadPool(int corePoolSize)</li>
<li>特点：支持定时及周期性任务执行。</li>
<li>内部使用 DelayedWorkQueue，一个无界队列，可以按时间进行排序。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>阿里巴巴开发手册建议：不推荐使用 Executors 创建线程池，而是手动通过 ThreadPoolExecutor 的构造方法创建，以明确线程池的运行规则，避免资源耗尽的风险。</strong></p>
</li>
</ul>
<h2 id="ThreadLocal："><a href="#ThreadLocal：" class="headerlink" title="ThreadLocal："></a>ThreadLocal：</h2><p>好的，我们来详细聊聊 <code>ThreadLocal</code>。</p>
<h3 id="ThreadLocal-是什么？"><a href="#ThreadLocal-是什么？" class="headerlink" title="ThreadLocal 是什么？"></a><code>ThreadLocal</code> 是什么？</h3><p><code>ThreadLocal</code>（线程本地变量）并不是用来解决线程间共享数据问题的，它的核心作用是<strong>为每个使用该变量的线程都提供一个独立的、隔离的副本</strong>。</p>
<p>你可以把 <code>ThreadLocal</code> 想象成一个“线程专属的储物柜”。每个线程都可以往这个储物柜里存东西（通过 <code>set()</code> 方法），取东西（通过 <code>get()</code> 方法），但它只能看到自己储物柜里的东西，无法访问其他线程的。</p>
<p><code>ThreadLocal</code> 内部其实是通过一个 <code>ThreadLocalMap</code> 来实现的。这个 Map 的键是 <code>ThreadLocal</code> 对象本身，值就是你存入的那个变量。每个线程都有一个属于自己的 <code>ThreadLocalMap</code>。</p>
<hr>
<h3 id="为什么需要-ThreadLocal？"><a href="#为什么需要-ThreadLocal？" class="headerlink" title="为什么需要 ThreadLocal？"></a>为什么需要 <code>ThreadLocal</code>？</h3><p>我们通常在开发中会遇到两种数据共享问题：</p>
<ol>
<li><strong>多个线程共享一个变量</strong>：这种情况下，需要通过 <code>synchronized</code>、<code>volatile</code> 或 <code>Lock</code> 来保证线程安全。</li>
<li><strong>每个线程需要一个独立的变量</strong>：这是 <code>ThreadLocal</code> 的主要应用场景。</li>
</ol>
<p>如果不用 <code>ThreadLocal</code>，我们可能需要自己手动维护一个 <code>Map&lt;Thread, Object&gt;</code>，每次存取数据时都以当前线程作为键。这样不仅麻烦，还容易出错。<code>ThreadLocal</code> 帮我们封装了这些细节，让使用变得非常简单。</p>
<hr>
<h3 id="ThreadLocal-的常见应用场景"><a href="#ThreadLocal-的常见应用场景" class="headerlink" title="ThreadLocal 的常见应用场景"></a><code>ThreadLocal</code> 的常见应用场景</h3><p><code>ThreadLocal</code> 最常见的应用场景是在 Web 开发中，用于<strong>存储与当前请求相关的上下文信息</strong>。</p>
<p>例如，一个 HTTP 请求从进入服务器到返回响应，可能由多个方法或组件来处理，但它们都属于同一个线程。如果需要传递一些请求相关的状态（比如用户身份、事务 ID、数据库连接），我们有很多种做法：</p>
<ul>
<li><strong>参数传递</strong>：将这些信息作为参数层层传递。这会导致方法签名变得臃肿，并且增加了代码的耦合性。</li>
<li><strong>静态变量</strong>：如果用静态变量，多个请求同时到达时会互相覆盖，导致线程不安全。</li>
<li><strong>ThreadLocal</strong>：这是最优雅的解决方案。你可以把这些信息存入 <code>ThreadLocal</code>，然后在任何需要的地方直接通过 <code>get()</code> 方法获取，无需在方法间显式传递。</li>
</ul>
<p><strong>典型的例子：</strong></p>
<ul>
<li><strong>Spring 的事务管理</strong>：Spring 框架在处理事务时，会使用 <code>ThreadLocal</code> 来保存每个线程的数据库连接，确保在同一个事务中的所有操作都使用同一个连接。</li>
<li><strong>上下文信息</strong>：例如，在请求处理链中，将用户登录信息、语言偏好等数据存入 <code>ThreadLocal</code>，下游的业务逻辑可以随时获取。</li>
</ul>
<hr>
<h3 id="ThreadLocal-可能带来的问题"><a href="#ThreadLocal-可能带来的问题" class="headerlink" title="ThreadLocal 可能带来的问题"></a><code>ThreadLocal</code> 可能带来的问题</h3><p>虽然 <code>ThreadLocal</code> 很好用，但如果使用不当，也可能导致一些问题。</p>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><strong>内存泄漏</strong></h4><p><code>ThreadLocal</code> 可能会导致<strong>内存泄漏</strong>。这是一个非常重要的问题。</p>
<p><code>ThreadLocalMap</code> 使用的是<strong>弱引用（Weak Reference）</strong> 作为键。这意味着，当 <code>ThreadLocal</code> 对象没有其他强引用时，即使它还在 <code>ThreadLocalMap</code> 中，垃圾回收器也会回收它。</p>
<p>但是，<code>ThreadLocalMap</code> 的值（也就是你存入的对象）是<strong>强引用</strong>。如果线程一直存活，但你不再使用 <code>ThreadLocal</code> 对象，<code>ThreadLocalMap</code> 中的键就会变成 <code>null</code>，但值还在。这样，值对象就无法被回收，导致内存泄漏。</p>
<p>如何避免？</p>
<p>解决这个问题的关键在于：在 ThreadLocal 使用完毕后，务必调用 remove() 方法。</p>
<p>在 Web 应用中，请求处理结束后，线程会被放回线程池。如果 <code>ThreadLocal</code> 没有被清除，那么下一次其他请求再拿到这个线程时，它会读取到上一个请求残留的数据，导致业务逻辑出错。因此，<strong>正确使用模式</strong>通常是：</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    threadLocal.set(&quot;My Data&quot;);</span><br><span class="line">    // do some work</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 确保在任何情况下都执行清理操作</span><br><span class="line">    threadLocal.remove(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a><strong>继承问题</strong></h4><p><code>ThreadLocal</code> 的值不会自动传递给子线程。如果你需要父线程创建子线程时，让子线程也能访问父线程的 <code>ThreadLocal</code> 值，你需要使用 <code>InheritableThreadLocal</code>。不过，<code>InheritableThreadLocal</code> 同样需要注意内存泄漏问题，并且在线程池环境下使用时可能会有意外行为，需要格外小心。</p>
<h2 id="Collection-集合框架"><a href="#Collection-集合框架" class="headerlink" title="Collection (集合框架):"></a>Collection (集合框架):</h2><ul>
<li>核心接口: Collection (父接口), List, Set, Map。</li>
<li>Iterable 接口: Collection 接口继承了 Iterable 接口,使得所有集合都可以通过增强for 循环(foreach)进行遍历。</li>
</ul>
<h4 id="A-List-接口及其实现类"><a href="#A-List-接口及其实现类" class="headerlink" title="A. List 接口及其实现类"></a>A. List 接口及其实现类</h4><p>List 是一种有序集合,可以包含重复元素。</p>
<h5 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h5><ul>
<li><p>底层实现:基于动态数组(Object[] elementData)实现。</p>
</li>
<li><p>特点:</p>
<ul>
<li>有序:元素有插入顺序,可以通过索引访问(get(index))。</li>
<li>可重复:允许存储重复元素。</li>
<li>随机访问效率高:通过索引访问元素(get(index))速度非常快,时间复杂度为O(1)。这是因为数组在内存中是连续存储的,可以通过基地址和偏移量直接计算出元素的内存地址。</li>
<li>插入和删除效率低:<ul>
<li>在数组末尾添加或删除元素效率较高(平均O(1))。</li>
<li>在数组中间插入或删除元素时,需要使用System.arraycopy()移动被影响位置之后的所有元素,时间复杂度为 O(n)。</li>
</ul>
</li>
<li>线程不安全:在多线程环境下,如果一个线程正在修改 ArrayList,而另一个线程正在读取或修改它,可能会导致数据不一致或 ConcurrentModificationException(在使用迭代器时)。</li>
</ul>
</li>
<li><p>扩容机制:</p>
<ul>
<li>初始容量:默认情况下,当你创建一个无参的ArrayList时,它的底层数组是空的(DEFAULTCAPACITY_EMPTY_ELEMENTDATA, 即 new Object[0])。首次添加元素时,内部数组会被初始化为默认容量 DEFAULT_CAPACITY (JDK8为10)。如果你在创建时指定了容量(new ArrayList&lt;&gt;(capacity)),则初始容量就是你指定的。</li>
<li>扩容时机:当ArrayList 的当前元素个数(size)等于底层数组的容量(elementData.length)时,就会触发扩容。</li>
<li>扩容方式:扩容逻辑位于grow()方法中。<ul>
<li>计算新的容量:newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),即新容量是旧容量的1.5倍。</li>
<li>如果计算出的新容量仍然小于需要的最小容量(minCapacity,即当前元素个数 size + 1),则直接将 minCapacity 作为新容量。</li>
<li>如果新容量超出了MAX_ARRAY_SIZE(通常是 Integer.MAX_VALUE-8),则会尝试使用 Integer.MAX_VALUE,如果仍不足则抛出 OutOfMemoryError。</li>
<li>创建一个新数组,并将旧数组中的元素复制到新数组中(Arrays.copyOf()内部调用 System.arraycopy())。</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么这么扩容(1.5倍):</p>
<ul>
<li>平衡空间与时间:<ul>
<li>相比于每次只增加1个元素,1.5倍的扩容策略减少了扩容的次数,从而减少了频繁进行数组复制带来的性能开销(数组复制是O(n)操作)。</li>
<li>相比于2倍扩容,1.5倍的策略在空间利用率上更优,避免了过度分配和浪费过多内存。</li>
</ul>
</li>
<li>这是一个在时间和空间之间权衡的选择,旨在提供一个相对高效且内存友好的动态数组实现。</li>
</ul>
</li>
<li><p>可能出现的问题:</p>
<ul>
<li>ConcurrentModificationException: 在多线程环境中,如果一个线程正在遍历 ArrayList(通过迭代器或增强 for循环),而另一个线程同时对其进行结构性修改(添加、删除元素等),就会抛出此异常。这是因为ArrayList 的迭代器是快速失败(fail-fast)的,它会检查 modCount(修改次数)是否与迭代器创建时一致。不一致则抛出异常。</li>
<li>内存开销:如果预估容量不准确,频繁扩容会导致多次数组复制,增加 CPU和内存开销。</li>
<li>内存浪费:如果初始容量设置过大,而实际使用的元素很少,会导致内存浪费。</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>add(E e): 在列表末尾添加元素。</li>
<li>add(int index, E e): 在指定位置插入元素。</li>
<li>remove(int index) &#x2F; remove(Object o): 删除指定位置或指定元素的第一个匹配项。</li>
<li>get(int index):获取指定位置的元素。</li>
<li>set(int index, E e): 替换指定位置的元素。</li>
<li>size(): 返回列表中元素的个数。</li>
<li>indexOf(Object o) &#x2F; lastIndexOf(Object o):返回元素第一次&#x2F;最后一次出现的索引。</li>
<li>contains(Object o): 判断是否包含某个元素。</li>
<li>clear(): 清空列表。</li>
</ul>
</li>
<li><p>遍历方式:</p>
<ol>
<li><p>传统 for 循环:</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增强 for 循环(foreach):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (E element: list) &#123; //内部使用迭代器</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器(Iterator):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">    // 如果需要删除元素,必须使用 it.remove(),否则会抛出</span><br><span class="line">    // ConcurrentModificationException</span><br><span class="line">    // it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8 Stream API:</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br><span class="line">// 或</span><br><span class="line">list.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h5 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h5><ul>
<li><p>底层实现:基于双向链表(Doubly Linked List)实现。每个节点都包含数据,以及指向前一个节点和后一个节点的引用。</p>
</li>
<li><p>特点:</p>
<ul>
<li>有序:元素有插入顺序。</li>
<li>可重复:允许存储重复元素。</li>
<li>插入和删除效率高:在链表的任何位置插入或删除元素,只需修改前后节点的引用,时间复杂度为O(1)。</li>
<li>随机访问效率低:get(index)操作需要从头节点或尾节点开始遍历链表直到目标索引,时间复杂度为O(n)。</li>
<li>内存开销大:每个节点除了存储数据本身,还需要额外的内存空间存储两个指针(prev 和 next),因此相比 ArrayList,在存储相同数量元素时, LinkedList 占用更多内存。</li>
<li>线程不安全:与ArrayList 类似,在多线程环境下不安全,可能抛出 ConcurrentModificationException。</li>
</ul>
</li>
<li><p>扩容机制:</p>
<ul>
<li>LinkedList 基于链表实现,没有固定容量的概念,也无需进行扩容。每次添加元素就是创建一个新节点并连接到链表中。因此不存在 ArrayList 那样的数组复制开销。</li>
</ul>
</li>
<li><p>可能出现的问题:</p>
<ul>
<li>ConcurrentModification Exception:同样在多线程环境下使用迭代器进行修改时可能发生。</li>
<li>内存碎片&#x2F;开销:频繁的节点创建和销毁,以及每个节点额外的指针开销,可能导致一定的内存碎片和更高的内存占用。</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>add(E e) &#x2F; addFirst(E e) &#x2F; addLast(E e): 添加元素。</li>
<li>remove() &#x2F; removeFirst() &#x2F; removeLast():删除元素。</li>
<li>get(int index) &#x2F; getFirst() &#x2F; getLast(): 获取元素(get(int index)效率低)。</li>
<li>peek() &#x2F; peekFirst() &#x2F; peekLast(): 获取但不移除头部&#x2F;尾部元素。</li>
<li>offer(E e) &#x2F; offerFirst(E e) &#x2F; offerLast (E e): 添加元素到队列&#x2F;双端队列(通常不抛异常)。</li>
<li>poll() &#x2F; pollFirst() &#x2F; pollLast(): 获取并移除头部&#x2F;尾部元素(为空返回null)。</li>
<li>push(E e) &#x2F; pop():实现栈的入栈和出栈操作。</li>
<li>size(), isEmpty(), contains(Object o), clear().</li>
</ul>
</li>
<li><p>遍历方式:</p>
<ol>
<li><p>传统 for 循环: <code>for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125;</code>(不推荐,效率低)</p>
</li>
<li><p>增强 for 循环(foreach): <code>for (E element: list) &#123; System.out.println(element); &#125;</code>(推荐)</p>
</li>
<li><p>迭代器(Iterator):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8 Stream API: <code>list.forEach(System.out::println);</code></p>
</li>
</ol>
</li>
</ul>
<h5 id="3-Vector"><a href="#3-Vector" class="headerlink" title="3. Vector"></a>3. Vector</h5><ul>
<li>底层实现:基于动态数组实现,与ArrayList 类似。</li>
<li>特点:<ul>
<li>线程安全:所有公共方法都使用了synchronized 关键字进行同步,因此是线程安全的。</li>
<li>效率低:因为所有操作都被同步,在单线程或并发读多写少的场景下,性能比 ArrayList 差。</li>
<li>扩容机制: Vector 的扩容策略与 ArrayList 类似,但默认是翻倍扩容(即新容量是旧容量的2倍)。可以通过构造函数指定扩容增量。</li>
</ul>
</li>
<li>可能出现的问题:<ul>
<li>性能瓶颈:全局锁导致并发性能差。</li>
</ul>
</li>
<li>使用场景:已经被 java.util.concurrent 包中的并发集合(如 CopyOnWriteArrayList)取代,基本不再推荐使用。</li>
</ul>
<h5 id="4-Stack"><a href="#4-Stack" class="headerlink" title="4. Stack"></a>4. Stack</h5><ul>
<li>底层实现:继承自Vector,因此也是基于数组实现,并具有Vector 的线程安全性。</li>
<li>特点:实现了后进先出(LIFO)的栈结构。</li>
<li>常用方法:<ul>
<li>push(E item):元素入栈。</li>
<li>pop():元素出栈。</li>
<li>peek(): 查看栈顶元素但不移除。</li>
<li>empty(): 判断栈是否为空。</li>
<li>search(Object o): 查找元素并返回离栈顶的距离。</li>
</ul>
</li>
<li>使用场景:不推荐使用,因为Stack 继承了Vector,而 Vector 本身有很多不适合栈操作的方法。通常使用 Deque 接口的实现类(如ArrayDeque 或 LinkedList)来代替栈,它们更灵活高效。</li>
</ul>
<h4 id="小结-List"><a href="#小结-List" class="headerlink" title="小结 List:"></a>小结 List:</h4><ul>
<li>ArrayList: 随机访问多,插入删除少(尤其末尾操作)的场景。</li>
<li>LinkedList: 插入删除多,随机访问少的场景;或需要作为队列&#x2F;栈使用的场景。</li>
<li>Vector &#x2F; Stack:不推荐在现代Java开发中使用,除非有特殊历史兼容需求。</li>
</ul>
<h4 id="B-Set-接口及其实现类"><a href="#B-Set-接口及其实现类" class="headerlink" title="B. Set 接口及其实现类"></a>B. Set 接口及其实现类</h4><p>Set 是一种无序集合,不允许重复元素。</p>
<h5 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h5><ul>
<li><p>底层实现:基于HashMap 实现。HashSet 内部使用一个 HashMap 实例来存储元素,HashSet 的元素作为HashMap的键(Key),而HashMap 的值(Value)则是一个固定的、无关紧要的 PRESENT 静态 Object 对象。</p>
</li>
<li><p>特点:</p>
<ul>
<li>无序:不保证元素的存储顺序和迭代顺序。</li>
<li>不可重复:元素唯一。通过元素的hashCode() 和 equals() 方法来判断元素的唯一性。当添加元素时,首先计算元素的hashCode(),然后根据哈希值找到对应的“桶”,再在该桶中遍历,如果存在 equals()为true 的元素,则不添加。</li>
<li>允许 null元素:允许且只能存储一个 null 元素。</li>
<li>查询、添加、删除的平均时间复杂度为(1) (在不发生哈希冲突或冲突较少的情况下)。最坏情况下(所有元素哈希冲突到同一个桶),会退化为 O(n)。</li>
<li>线程不安全:与HashMap 类似,非同步。</li>
</ul>
</li>
<li><p>扩容机制:</p>
<ul>
<li>由于底层是HashMap,其扩容机制与 HashMap 完全相同。</li>
<li>初始容量:默认初始容量为16。</li>
<li>负载因子:默认负载因子为0.75。</li>
<li>扩容时机:当HashSet 中存储的元素数量达到容量*负载因子时,就会进行扩容,新容量是旧容量的2倍。</li>
<li>扩容过程:创建一个新的两倍大小的底层数组,然后遍历旧数组中的所有元素,重新计算它们的哈希值,并将它们放入新数组的正确位置。</li>
</ul>
</li>
<li><p>可能出现的问题:</p>
<ul>
<li>性能下降: 如果自定义类作为元素存储在 HashSet 中，但没有正确重写 hashCode() 和 equals() 方法，可能会导致元素重复，或者哈希冲突严重，从而导致性能急剧下降。</li>
<li>ConcurrentModicationException: 同步性问题，在多线程环境下使用迭代器修改集合时会抛出。</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>add(E e): 添加元素。</li>
<li>remove(Object o): 删除元素。</li>
<li>contains(Object o): 判断是否包含元素。</li>
<li>size(): 返回集合中元素的个数。</li>
<li>isEmpty(), clear().</li>
</ul>
</li>
<li><p>遍历方式:</p>
<ol>
<li><p>增强 for 循环 (foreach): <code>for (E element : set) &#123; System.out.println(element); &#125;</code></p>
</li>
<li><p>迭代器 (Iterator):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = set.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8 Stream API: <code>set.forEach(System.out::println);</code></p>
</li>
</ol>
</li>
</ul>
<h5 id="2-LinkedHashSet"><a href="#2-LinkedHashSet" class="headerlink" title="2. LinkedHashSet"></a>2. LinkedHashSet</h5><ul>
<li>底层实现: 继承自 HashSet，内部使用 LinkedHashMap 实现。</li>
<li>特点:<ul>
<li>除了具备 HashSet 的所有特性外，最大的特点是保持元素的插入顺序（或者访问顺序，如果配置为 LRU 缓存）。这意味着遍历 LinkedHashSet时，元素的顺序与它们被添加到集合中的顺序一致。</li>
<li>维护了一个双向链表，用于维护元素的插入顺序。</li>
</ul>
</li>
<li>扩容机制: 与 HashSet 和 HashMap 相同。</li>
<li>使用场景: 需要去重，同时又需要保持元素插入顺序的场景。</li>
</ul>
<h5 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3. TreeSet"></a>3. TreeSet</h5><ul>
<li>底层实现: 基于 TreeMap 实现。TreeSet 内部使用一个 TreeMap 实例来存储元素，TreeSet 的元素作为 TreeMap 的键，而值则是一个固定的 Object。</li>
<li>特点:<ul>
<li>有序: 元素会根据其自然排序（元素必须实现 Comparable 接口）或者在创建 TreeSet 时提供的 Comparator 进行排序。</li>
<li>不可重复: 元素唯一，唯一性通过比较结果判断（compareTo() 或 compare() 方法返回 0）。</li>
<li>不允许 null 元素: 不允许存储 null 元素（因为 null 无法进行比较）。</li>
<li>查询、添加、删除的时间复杂度为 O(log n)，因为底层是红黑树。</li>
<li>线程不安全: 非同步。</li>
</ul>
</li>
<li>扩容机制:<ul>
<li>由于底层是红黑树，没有传统意义上的扩容机制。每次添加元素就是增加一个节点，并根据红黑树的平衡规则进行调整（旋转和变色）来保持树的平衡。</li>
</ul>
</li>
<li>可能出现的问题:<ul>
<li>性能: 相比 HashSet，性能略低，因为涉及比较和树的平衡操作。</li>
<li>元素必须可比较: 如果存储的元素没有实现 Comparable 接口，或者创建 TreeSet 时没有提供 Comparator，则会抛出 ClassCastException。</li>
<li>ConcurrentModicationException: 同步性问题。</li>
</ul>
</li>
<li>常用方法:<ul>
<li>与 HashSet 类似，但额外提供了与排序相关的方法，如 rst(), last(), headSet(), tailSet(), subSet() 等。</li>
</ul>
</li>
</ul>
<h4 id="小结-Set"><a href="#小结-Set" class="headerlink" title="小结 Set:"></a>小结 Set:</h4><ul>
<li>HashSet: 最常用，需要快速查找、去重，不关心元素顺序的场景。</li>
<li>LinkedHashSet: 需要去重，同时又需要保持元素插入顺序的场景。</li>
<li>TreeSet: 需要去重，并且希望元素自动按照自然顺序或自定义顺序排序的场景。</li>
</ul>
<h4 id="C-Map-接口及其实现类"><a href="#C-Map-接口及其实现类" class="headerlink" title="C. Map 接口及其实现类"></a>C. Map 接口及其实现类</h4><p>Map 存储键值对，键是唯一的，值可以重复。</p>
<h5 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h5><ul>
<li><p>底层实现: 基于哈希表实现，JDK 8 及以后是数组 + 链表 + 红黑树。</p>
<ul>
<li>数组: Node</li>
<li>链表: 用于解决哈希冲突，将哈希到同一个索引位置的键值对以链表形式连接。</li>
<li>红黑树: 当链表长度达到一定阈值（JDK 8 默认为 8）时，为了提高查找效率，该链表会转换为红黑树。当红黑树节点数少于一定阈值（JDK 8 默认为 6）时，会退化为链表。</li>
</ul>
</li>
<li><p>特点:</p>
<ul>
<li>无序: 不保证键值对的存储和迭代顺序。</li>
<li>键唯一，值可重复: 键通过 hashCode() 和 equals() 方法确定唯一性。</li>
<li>允许 null 键和 null 值: 只能有一个 null 键（存储在索引 0 的位置），可以有多个 null 值。</li>
<li>查询、添加、删除的平均时间复杂度为 O(1)，最坏情况下为 O(n)（链表）或 O(logn)（红黑树，JDK 8 及以后）。</li>
</ul>
</li>
<li><p>扩容机制:</p>
<ul>
<li><p>初始容量 (initialCapacity): 默认值为 16。最好在创建 HashMap 时预估并指定一个合适的初始容量，以减少扩容次数。</p>
</li>
<li><p>负载因子 (loadFactor): 默认值为 0.75。表示哈希表在进行扩容前的填充比例。</p>
</li>
<li><p>扩容时机: 当 HashMap 中存储的元素数量 (size) 达到 容量 * 负载因子 (即 threshold) 时，就会触发扩容。</p>
</li>
<li><p>扩容方式: resize() 方法。</p>
<ol>
<li>创建一个新的两倍大小的底层数组。</li>
<li>遍历旧数组中的所有键值对。</li>
<li>重新计算每个键的哈希值，并根据新的容量大小，将其放入新数组的正确位置。这个过程被称为再哈希 (rehash)。</li>
</ol>
<ul>
<li>JDK 8 优化: 在链表转换时，避免了每个节点单独重新计算哈希值，而是根据原索引和新容量的关系，直接判断节点在新数组中的位置，提高了效率。</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么这么扩容 (2 倍):</p>
<ul>
<li>位运算优化: 容量始终保持 2 的幂次方，可以利用位运算 (h &amp; (length - 1)) 来替代取模运算 h % length，提高哈希值到索引的映射效率。</li>
<li>减少哈希冲突: 扩容为 2 倍可以有效分散哈希冲突，使得更多的键能够映射到不同的桶，从而降低链表&#x2F;红黑树的长度，保持 O(1) 的平均性能。</li>
</ul>
</li>
<li><p>为什么负载因子是 0.75:</p>
<ul>
<li>这是一个在“空间利用率”和“查询效率”之间的权衡。</li>
<li>如果负载因子过小，会频繁扩容，浪费空间。</li>
<li>如果负载因子过大，哈希冲突会增加，链表&#x2F;红黑树变长，导致查询效率下降。</li>
<li>0.75 这个值是经过实践验证，在大多数情况下能够提供较好性能的平衡点。</li>
</ul>
</li>
<li><p>可能出现的问题:</p>
<ul>
<li>性能下降: 如果自定义类作为键存储在 HashMap 中，但没有正确重写 hashCode() 和 equals() 方法，会导致元素重复，或者哈希冲突严重，从而导致性能急剧下降。</li>
<li>多线程问题: 在多线程环境下，对 HashMap 进行修改操作可能导致数据丢失、死循环（JDK 7 及以前），或 ConcurrentModicationException。这是其最大的问题。</li>
<li>内存开销: 频繁扩容会带来数组复制的开销。</li>
</ul>
</li>
<li><p>常用方法:</p>
<ul>
<li>put(K key, V value): 关联键值对。</li>
<li>get(Object key):</li>
</ul>
</li>
<li><p>遍历方式:</p>
<ol>
<li><p>遍历键集 (keySet()):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (K key : map.keySet()) &#123;</span><br><span class="line">    V value = map.get(key);</span><br><span class="line">    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历键值对集 (entrySet()) - 推荐，效率最高:</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Value: &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历值集 (values()):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (V value : map.values()) &#123;</span><br><span class="line">    System.out.println(&quot;Value: &quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器 (Iterator):</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;K, V&gt; entry = it.next();</span><br><span class="line">    System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Value: &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8 Stream API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h5 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2. LinkedHashMap"></a>2. LinkedHashMap</h5><ul>
<li>底层实现: 继承自 HashMap，额外维护了一个双向链表，用于维护插入顺序或访问顺序。</li>
<li>特点:<ul>
<li>除了具备 HashMap 的所有特性外，最大的特点是保持键值对的插入顺序（或访问顺序）。这意味着遍历 LinkedHashMap 时，元素的顺序与它们被添加到 Map 中的顺序一致。</li>
<li>可以用于实现 LRU (Least Recently Used) 缓存策略，通过覆盖 removeEldestEntry 方法并设置访问顺序为 true。</li>
</ul>
</li>
<li>扩容机制: 与 HashMap 相同。</li>
<li>使用场景: 需要快速查找，同时又需要保持插入顺序的场景。</li>
</ul>
<h5 id="3-TreeMap"><a href="#3-TreeMap" class="headerlink" title="3. TreeMap"></a>3. TreeMap</h5><ul>
<li>底层实现: 基于红黑树（Red-Black Tree）实现。</li>
<li>特点:<ul>
<li>有序: 键会根据其自然排序（键的类型必须实现 Comparable 接口）或者在创建 TreeMap 时提供的 Comparator 进行排序。</li>
<li>键唯一，值可重复: 唯一性判断依赖于键的比较结果（compareTo() 或 compare() 方法返回 0）。</li>
<li>不允许 null 键: 不允许存储 null 键（因为 null 无法进行比较），但允许 null 值。</li>
<li>查询、添加、删除的时间复杂度为 O(log n)，因为底层是红黑树。</li>
<li>线程不安全: 非同步。</li>
</ul>
</li>
<li>扩容机制:<ul>
<li>由于底层是红黑树，没有传统意义上的扩容机制。每次添加键值对就是增加一个节点，并根据红黑树的平衡规则进行调整（旋转和变色）来保持树的平衡。</li>
</ul>
</li>
<li>可能出现的问题:<ul>
<li>性能: 相比 HashMap，性能略低，因为涉及比较和树的平衡操作。</li>
<li>键必须可比较: 如果键没有实现 Comparable 接口，或者创建 TreeMap 时没有提供 Comparator，则会抛出 ClassCastException。</li>
<li>ConcurrentModicationException: 同步性问题。</li>
</ul>
</li>
<li>常用方法:<ul>
<li>与 HashMap 类似，但额外提供了与排序相关的方法，如 rstKey(), lastKey(), ceilingEntry(), oorEntry() 等。</li>
</ul>
</li>
</ul>
<h5 id="4-Hashtable"><a href="#4-Hashtable" class="headerlink" title="4. Hashtable"></a>4. Hashtable</h5><ul>
<li>底层实现: 基于哈希表实现，与 HashMap 类似，但所有方法都使用了 synchronized 关键字。</li>
<li>特点:<ul>
<li>线程安全: 所有公共方法都进行了同步处理。</li>
<li>效率低: 全局锁导致并发性能差。</li>
<li>不允许 null 键和 null 值。</li>
<li>初始容量和扩容机制: 默认初始容量 11，负载因子 0.75。扩容时新容量是旧容量的 2 倍 + 1。</li>
</ul>
</li>
<li>使用场景: 已被 ConcurrentHashMap 取代，基本不再推荐使用。</li>
</ul>
<h5 id="5-ConcurrentHashMap-JUC-包中的并发集合"><a href="#5-ConcurrentHashMap-JUC-包中的并发集合" class="headerlink" title="5. ConcurrentHashMap (JUC 包中的并发集合)"></a>5. ConcurrentHashMap (JUC 包中的并发集合)</h5><ul>
<li><p>底层实现:</p>
<ul>
<li>JDK 7 及以前: 采用分段锁 (Segment) 的方式，将 HashMap 内部数据分成多个段（Segment），每个段是一个独立的 ReentrantLock。锁住某个段时，不影响其他段的操作。</li>
<li>JDK 8 及以后: 放弃了分段锁，改为使用 CAS (Compare-And-Swap) 操作和 synchronized 关键字（只在链表&#x2F;红黑树头节点发生竞争时才使用，锁住的范围更小）来保证线程安全。</li>
</ul>
</li>
<li><p>特点:</p>
<ul>
<li>线程安全: 高并发环境下性能优异。</li>
<li>不允许 null 键和 null 值。</li>
<li>读操作基本无锁。</li>
</ul>
</li>
<li><p>扩容机制: 与 HashMap 类似，JDK 8 中，每个 Node 数组的扩容是独立的，通过 transfer 方法实现。</p>
</li>
<li><p>使用场景: 高并发场景下替代 HashMap 和 Hashtable 的首选。</p>
</li>
<li><p><code>java.util.concurrent</code> (JUC) 包是 Java 并发编程的高级工具包，它提供了比传统 <code>synchronized</code> 关键字和 <code>wait/notify</code> 机制更强大、更灵活的并发控制手段。</p>
<p><strong>并发工具类</strong></p>
<p>这些工具类都是为了解决特定场景下的线程协作问题而设计的，它们是 JUC 包的精华所在。</p>
<ul>
<li><strong>CountDownLatch (倒计时器)</strong>：就像一个比赛的倒计时牌。主线程在等待，而其他多个子线程在执行自己的任务。每完成一个任务，倒计时就减一。当倒计时减到零时，主线程才能继续执行。这非常适合“一等多”的场景，比如主线程需要等待所有子线程的数据加载完成后再开始处理。</li>
<li><strong>CyclicBarrier (循环屏障)</strong>：可以看作是一个“集合点”。多个线程都跑到这里，互相等待。当所有线程都到达集合点后，它们才会一起继续前进。这个过程可以重复使用（“循环”），适合需要多个线程分阶段同步执行的场景。</li>
<li><strong>Semaphore (信号量)</strong>：用来控制同时访问某个资源的线程数量。你可以把它想象成一个拥有固定数量许可证的停车场。当一个线程需要访问资源时，它就获取一个许可证。当许可证用完时，其他线程就必须等待。线程用完资源后归还许可证，下一个线程才能进入。这可以用来限制并发连接数，比如数据库连接池。</li>
<li><strong>Exchanger (交换器)</strong>：提供一个两个线程间的数据交换点。当两个线程都运行到这个同步点时，它们会互相交换数据。这通常用于两个线程互相传递数据的场景，比如生产者和消费者线程之间的协作。</li>
</ul>
<p><strong>原子操作类</strong></p>
<ul>
<li><strong>AtomicInteger, AtomicLong 等原子类</strong>：这些类提供了一些“原子性”的操作，意思是这些操作是不可分割的。例如，<code>i++</code> 在多线程环境下不是一个原子操作，可能导致数据不一致。而 <code>AtomicInteger</code> 的 <code>incrementAndGet()</code> 方法就能保证自增操作是线程安全的，并且性能比使用 <code>synchronized</code> 关键字要高。它们通常用于需要对单个变量进行安全、高效地更新的场景。</li>
</ul>
</li>
</ul>
<h4 id="小结-Map"><a href="#小结-Map" class="headerlink" title="小结 Map:"></a>小结 Map:</h4><ul>
<li>HashMap: 最常用，需要快速查找，不关心键值对顺序，且在单线程或由外部同步机制保证线程安全的场景。</li>
<li>LinkedHashMap: 需要快速查找，同时需要保持插入顺序或访问顺序的场景（如实现 LRU 缓存）。</li>
<li>TreeMap: 需要根据键的自然顺序或自定义顺序排序的场景。</li>
<li>ConcurrentHashMap: 高并发场景下对 Map 进行读写操作的首选。</li>
<li>Hashtable: 已被淘汰，不推荐使用。</li>
</ul>
<h2 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO 流"></a>Java IO 流</h2><p>Java IO (Input&#x2F;Output) 流是用于处理计算机与外部设备之间数据传输的抽象概念。它将数据抽象为流 (Stream)，通过流可以实现数据的输入和输出。</p>
<h3 id="IO-流的分类"><a href="#IO-流的分类" class="headerlink" title="IO 流的分类"></a>IO 流的分类</h3><p>Java IO 流根据不同的标准有多种分类方式：</p>
<ul>
<li>按数据类型分：<ul>
<li>字节流：处理字节数据，所有文件类型（文本、图片、音视频等）都可以用字节流处理。<ul>
<li>抽象基类：InputStream（输入流）、OutputStream（输出流）。</li>
<li>常用实现：FileInputStream&#x2F;FileOutputStream（文件操作），BufferedInputStream&#x2F;BufferedOutputStream（带缓冲），ObjectInputStream&#x2F;ObjectOutputStream（对象序列化），ByteArrayInputStream&#x2F;ByteArrayOutputStream（内存操作），DataInputStream&#x2F;DataOutputStream（基本数据类型操作）。</li>
</ul>
</li>
<li>字符流：处理字符数据，专门用于处理文本文件。<ul>
<li>抽象基类：Reader（输入流）、Writer（输出流）。</li>
<li>常用实现：FileReader&#x2F;FileWriter（文件操作），BufferedReader&#x2F;BufferedWriter（带缓冲），InputStreamReader&#x2F;OutputStreamWriter（字节流与字符流的转换）。</li>
</ul>
</li>
</ul>
</li>
<li>按流向分：<ul>
<li>输入流：从数据源读取数据到程序中。</li>
<li>输出流：从程序中写入数据到目的地。</li>
</ul>
</li>
<li>按功能分：<ul>
<li>节点流（或源头流）：直接与数据源（如文件、内存、网络连接）连接的流。例如FileInputStream、FileReader。</li>
<li>处理流（或包装流）：对已存在的节点流进行包装，增加新的功能或提升性能。例如BufferedInputStream、BufferedReader。</li>
</ul>
</li>
</ul>
<h3 id="常用-IO-操作"><a href="#常用-IO-操作" class="headerlink" title="常用 IO 操作"></a>常用 IO 操作</h3><ul>
<li><p>文件读写（字节流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    fos.write(<span class="string">&quot;Hello, World!&quot;</span>.getBytes());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">while</span> ((data = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件读写（字符流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output_char.txt&quot;</span>)) &#123;</span><br><span class="line">    fw.write(<span class="string">&quot;你好，世界！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;output_char.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">while</span> ((data = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓冲流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用缓冲字节流复制文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.txt&quot;</span>));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;destination.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个可序列化的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 序列化版本UID</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">transient</span> String password; <span class="comment">// transient 关键字修饰的字段不参与序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User(name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, password=&quot;</span> + password + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    oos.writeObject(user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;user.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">deserializedUser</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">    System.out.println(deserializedUser); <span class="comment">// password 字段将为 null</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="NIO-New-Input-Output"><a href="#NIO-New-Input-Output" class="headerlink" title="NIO (New Input&#x2F;Output)"></a>NIO (New Input&#x2F;Output)</h3><p>Java NIO (New I&#x2F;O) 是在 JDK 1.4 中引入的一套新的 I&#x2F;O API，它提供了非阻塞 I&#x2F;O 的能力，并引入了“通道 (Channel)”和“缓冲区 (Buffer)”的概念，与传统的基于流 (Stream) 的 I&#x2F;O 相比，NIO 更加高效。</p>
<p><strong>核心组件：</strong></p>
<ul>
<li>Channel (通道): 类似于传统 IO 中的流，但可以双向读写。数据总是通过通道读入缓冲区或从缓冲区写入通道。<ul>
<li>常用实现: FileChannel (文件), SocketChannel (TCP 客户端), ServerSocketChannel (TCP 服务器), DatagramChannel (UDP)。</li>
</ul>
</li>
<li>Buffer (缓冲区): 用于存储数据 (字节数组)，与通道进行交互。所有数据读写都是通过缓冲区完成的。缓冲区有多种类型，如 ByteBuffer、CharBuffer、IntBuffer 等。<ul>
<li>核心属性：<ul>
<li>capacity: 缓冲区可容纳的最大数据量。一旦创建，容量不可变。</li>
<li>limit: 缓冲区中可读或可写的上限。</li>
<li>position: 下一个读或写的位置。</li>
<li>mark: 标记当前 position，可以通过 reset() 恢复到 mark 的位置。</li>
</ul>
</li>
<li>主要方法：<ul>
<li>put(): 向缓冲区写入数据。</li>
<li>get(): 从缓冲区读取数据。</li>
<li>flip(): 将缓冲区从写模式切换到读模式。limit 会设置为当前的 position, position 会重置为 0。</li>
<li>clear(): 清空缓冲区，为新的写入做准备。position 设为 0, limit 设为 capacity。</li>
<li>compact(): 压缩缓冲区，将未读的数据移到缓冲区开头，position 设为未读数据数量，limit 设为 capacity。</li>
<li>rewind(): 将 position 设为 0，可以重复读取缓冲区中的数据。</li>
</ul>
</li>
</ul>
</li>
<li>Selector (选择器): 用于监听多个通道上的事件 (如连接就绪、读就绪、写就绪等)。一个单线程可以管理多个通道，从而实现非阻塞 I&#x2F;O。</li>
</ul>
<p><strong>NIO 与传统 IO 的区别：</strong></p>
<ul>
<li>I&#x2F;O 模式:传统 IO 是阻塞式 I&#x2F;O, NIO 是非阻塞式 I&#x2F;O。</li>
<li>流与缓冲区:传统 IO 基于流(单向), NIO 基于通道和缓冲区(双向)。</li>
<li>同步与异步:传统 IO 是同步阻塞的, NIO 是同步非阻塞的(在多路复用模型下)。</li>
</ul>
<p><strong>NIO 文件复制示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">     <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;destination_nio.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> fos.getChannel()) &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (inChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buffer.flip(); <span class="comment">// 切换到读模式</span></span><br><span class="line">        outChannel.write(buffer); <span class="comment">// 从缓冲区写入通道</span></span><br><span class="line">        buffer.clear(); <span class="comment">// 清空缓冲区, 为下次写入做准备</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AIO-Asynchronous-Input-Output"><a href="#AIO-Asynchronous-Input-Output" class="headerlink" title="AIO (Asynchronous Input&#x2F;Output)"></a>AIO (Asynchronous Input&#x2F;Output)</h3><p>Java AIO (Asynchronous I&#x2F;O) 是在 JDK 7 中引入的，也称为 NIO 2.0。它提供了真正的异步非阻塞 I&#x2F;O，通过回调机制来处理 I&#x2F;O 操作的结果。与 NIO 的同步非阻塞不同，AIO 在 I&#x2F;O 操作完成后会主动通知应用程序。</p>
<ul>
<li><p><strong>核心概念:</strong></p>
<ul>
<li>AsynchronousFileChannel:异步文件通道。</li>
<li>AsynchronousSocketChannel:异步 Socket 通道。</li>
<li>AsynchronousServerSocketChannel:异步 Server Socket 通道。</li>
<li>CompletionHandler:回调处理器接口，定义了 completed() (操作成功) 和 failed() (操作失败) 方法。</li>
<li>Future:也可以通过返回 Future 对象来获取异步操作的结果。</li>
</ul>
</li>
<li><p>**工作原理:**当发起一个 I&#x2F;O 操作时，不再需要等待操作完成，而是立即返回。I&#x2F;O 操作由操作系统在后台完成，完成后通过回调函数通知应用程序。</p>
</li>
<li><p><strong>AIO 优势:</strong></p>
<ul>
<li>真正的异步非阻塞:应用程序不需要等待 I&#x2F;O 操作，可以将 CPU 资源用于其他任务。</li>
<li>提高并发性:特别适合高并发、长连接的网络应用。</li>
</ul>
</li>
<li><p><strong>AIO 劣势:</strong></p>
<ul>
<li>复杂性:编程模型相对于 NIO 更复杂，需要处理回调逻辑。</li>
<li>适用场景:对于连接数较多且连接时间长的应用，如聊天服务器，AIO 表现优异。对于短连接、高并发的场景，NIO（基于 Selector）可能表现更好。</li>
</ul>
</li>
<li><p><strong>AIO 读文件示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">file</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;async_read.txt&quot;</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(file, StandardOpenOption.READ)) &#123;</span><br><span class="line">    fileChannel.read(buffer, <span class="number">0</span>, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Read &quot;</span> + result + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">            attachment.flip();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[attachment.remaining()];</span><br><span class="line">            attachment.get(data);</span><br><span class="line">            System.out.println(<span class="string">&quot;Content: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Read failed: &quot;</span> + exc.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 为了让主线程不立即退出，等待异步操作完成</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Java-反射-Reflection"><a href="#Java-反射-Reflection" class="headerlink" title="Java 反射 (Reflection)"></a>Java 反射 (Reflection)</h2><p>Java 反射机制是指在程序运行时，能够动态地获取类的信息（包括类的属性、方法、构造器等），并能够动态地操作类或对象（如创建对象、调用方法、修改属性）。</p>
<ul>
<li><p><strong>核心类与接口：</strong></p>
<ul>
<li>Class 类：代表类的字节码文件，是反射的入口。</li>
<li>Constructor 类：代表类的构造器。</li>
<li>Method 类：代表类的方法。</li>
<li>Field 类：代表类的成员变量（属性）。</li>
<li>AccessibleObject：Field, Method, Constructor 的共同父类，提供了 setAccessible(true) 方法，用于抑制 Java 语言访问检查，从而访问私有成员。</li>
</ul>
</li>
<li><p><strong>获取 Class 对象的三种方式：</strong></p>
<ol>
<li>Class.forName(“全限定类名”)：最常用，动态加载类。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>类名.class：已知具体类名时使用，编译时加载。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = String.class;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>对象.getClass()：通过对象实例获取，运行时获取。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Class&lt;?&gt; clazz = s.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反射的应用：</strong></p>
<ul>
<li>动态创建对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance(); <span class="comment">// 调用无参构造器</span></span><br><span class="line"><span class="comment">// 或者调用指定构造器</span></span><br><span class="line">Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person2</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure></li>
<li>动态调用方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">setNameMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">setNameMethod.invoke(person, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// 调用 setName 方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getNameMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) getNameMethod.invoke(person); <span class="comment">// 调用 getName 方法</span></span><br></pre></td></tr></table></figure></li>
<li>动态操作属性：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance();</span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">// 获取私有属性</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>); <span class="comment">// 允许访问私有属性</span></span><br><span class="line">nameField.set(person, <span class="string">&quot;Charlie&quot;</span>); <span class="comment">// 设置属性值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) nameField.get(person); <span class="comment">// 获取属性值</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>反射的优缺点：</strong></p>
<ul>
<li>优点：<ul>
<li>灵活性和动态性:在运行时动态获取类信息和操作对象,大大增强了程序的灵活性,是许多框架(如Spring、ORM框架)和工具(如JSON解析库)的基础。</li>
<li>解耦:允许代码在编译时不知道具体的类,只在运行时加载和使用,实现高度解耦。</li>
</ul>
</li>
<li>缺点:<ul>
<li>性能开销:反射操作比直接调用有更高的性能开销,因为涉及到动态解析和查找。</li>
<li>安全性问题:setAccessible(true)可以绕过Java的访问控制,可能破坏封装性。</li>
<li>可维护性差:反射代码通常比直接调用更复杂,更难调试和维护。</li>
<li>编译时检查缺失:反射操作在编译时无法检查类型错误,只能在运行时发现。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="JVM内存结构与垃圾收集器"><a href="#JVM内存结构与垃圾收集器" class="headerlink" title="JVM内存结构与垃圾收集器"></a>JVM内存结构与垃圾收集器</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>JVM(Java Virtual Machine)在执行Java程序时,会将内存划分为几个不同的区域,这些区域有各自的用途和生命周期。</p>
<ul>
<li><p><strong>程序计数器 (Program Counter Register)</strong></p>
<ul>
<li>功能:一块较小的内存空间,用于存储当前线程所执行的字节码的行号指示器。</li>
<li>特点:<ul>
<li>每个线程私有,生命周期与线程一致。</li>
<li>JVM规范中唯一没有规定任何OutOfMemoryError情况的区域。</li>
<li>在多线程切换时,程序计数器记录了当前线程的执行位置,使得线程切换回来后能够知道从哪里继续执行。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Java虚拟机栈 (Java Virtual Machine Stacks)</strong></p>
<ul>
<li>功能:每个线程私有的内存区域,用于存储栈帧(Stack Frame)。每个方法被执行时都会创建一个栈帧,用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>
<li>特点:<ul>
<li>生命周期与线程一致。</li>
<li>局部变量表:存储方法参数和方法内部定义的局部变量。</li>
<li>操作数栈:用于存放方法执行时的操作数和中间结果。</li>
<li>动态链接:指向运行时常量池中该栈帧所属方法的引用。</li>
<li>方法出口:记录方法执行完后回到哪里。</li>
<li>可能抛出StackOverflowError(栈深度超过虚拟机允许的深度)或OutOfMemoryError(栈扩展时无法申请到足够的内存)。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>本地方法栈 (Native Method Stacks)</strong></p>
<ul>
<li>功能:与虚拟机栈类似,但是为JVM执行Native方法(即用C&#x2F;C++等语言实现的方法)服务。</li>
<li>特点：<ul>
<li>每个线程私有。</li>
<li>可能抛出 StackOverflowError 或 OutOfMemoryError。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Java 堆 (Java Heap)</strong></p>
<ul>
<li>功能:JVM 管理的最大一块内存区域，被所有线程共享，用于存放对象实例和数组。</li>
<li>特点：<ul>
<li><p>是垃圾收集器管理的主要区域 (GC 堆)。</p>
</li>
<li><p>是 Java 应用程序对象存放的“老家”。</p>
</li>
<li><p>根据垃圾回收的特性，可以分为新生代 (Young Generation) 和老年代 (Old Generation)。</p>
</li>
<li><p>新生代:通常分为 Eden 空间和两个 Survivor 空间 (From 和 To)。新创建的对象优先在 Eden 区分配，经过 Minor GC 后存活的对象进入 Survivor 区，多次 GC 后仍存活的对象进入老年代。</p>
</li>
<li><p>老年代:存放生命周期较长的对象。</p>
</li>
<li><p>在 JVM 内存模型中，新生代被划分为三个区域，默认的比例通常是 <strong>8:1:1</strong>。</p>
<ul>
<li><strong>Eden 区</strong>：占比 <strong>80%</strong>。这是新创建对象的主要分配区域。</li>
<li><strong>Survivor S0 区</strong>：占比 <strong>10%</strong>。</li>
<li><strong>Survivor S1 区</strong>：占比 <strong>10%</strong>。</li>
</ul>
<hr>
<h3 id="为什么要这样划分？"><a href="#为什么要这样划分？" class="headerlink" title="为什么要这样划分？"></a><strong>为什么要这样划分？</strong></h3><p>这种划分是为了配合 Minor GC 的垃圾回收流程，从而提高垃圾回收的效率。</p>
<h4 id="新生代的垃圾回收流程"><a href="#新生代的垃圾回收流程" class="headerlink" title="新生代的垃圾回收流程"></a><strong>新生代的垃圾回收流程</strong></h4><ol>
<li><strong>对象创建</strong>：新创建的对象首先在 <strong>Eden 区</strong> 分配。</li>
<li><strong>Minor GC</strong>：当 <strong>Eden 区</strong> 满了之后，会触发一次 Minor GC（也叫 Young GC）。</li>
<li><strong>存活对象转移</strong>：<ul>
<li>在 Eden 区和其中一个 Survivor 区（比如 S0）中，所有存活的对象会被复制到另一个空的 Survivor 区（比如 S1）。</li>
<li>同时，对象的年龄（age）会加一。</li>
</ul>
</li>
<li><strong>清空 Eden 和 S0</strong>：垃圾回收后，Eden 区和 S0 区都会被清空。</li>
<li><strong>角色互换</strong>：下一次 Minor GC 时，Eden 区和 S1 区中存活的对象会被复制到 S0 区。S0 和 S1 两个 Survivor 区会不断地进行角色互换。</li>
<li><strong>晋升老年代</strong>：<ul>
<li>当对象的年龄达到一个设定的阈值（默认为 15），或者 Survivor 区中同一年龄段的对象大小超过了一定比例，这些对象就会被移动到<strong>老年代</strong>。</li>
<li>这种设计也被称为<strong>复制算法（Copying Algorithm）</strong>，它在新生代存活对象较少的情况下，效率非常高。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="为什么是-8-1-1？"><a href="#为什么是-8-1-1？" class="headerlink" title="为什么是 8:1:1？"></a><strong>为什么是 8:1:1？</strong></h3><p>这个比例是一个经验值，基于大多数 Java 应用的特点：</p>
<ul>
<li><strong>大多数对象都是朝生夕灭的</strong>。因此，将 Eden 区设置得更大，可以容纳更多的新对象，减少 Minor GC 的频率。</li>
<li>两个 Survivor 区只需要用来暂存存活的对象，因此不需要太大。10% 的空间通常足以容纳一次 Minor GC 后存活的对象。</li>
</ul>
<p>当然，这个比例不是固定的。在某些特殊情况下，如果新生代存活对象较多，导致 Survivor 区无法容纳所有存活对象，JVM 会发生<strong>空间分配担保</strong>，将这些对象直接晋升到老年代。</p>
<p>你可以通过 JVM 参数来调整这个比例，例如： <code>java -Xmn100m -XX:SurvivorRatio=8</code></p>
<p>这个命令设置新生代总大小为 100MB，Eden 区和 Survivor 区的比例为 8:1:1。</p>
</li>
<li><p>可能抛出 OutOfMemoryError。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>方法区 (Method Area)</strong></p>
<ul>
<li>功能:被所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
<li>特点：<ul>
<li>在 JDK 1.7 及之前，方法区被称为“永久代 (Permanent Generation)”，它属于堆内存的一部分。</li>
<li>在 JDK 1.8 及之后，永久代被移除，方法区的实现改为“元空间 (Metaspace)”，并且元空间不使用 JVM 内存，而是直接使用本地内存 (Native Memory)。</li>
<li>可能抛出 OutOfMemoryError。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>运行时常量池 (Runtime Constant Pool)</strong></p>
<ul>
<li>功能:方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</li>
<li>特点：<ul>
<li>动态性:Java 语言并不要求常量池在编译期就全部确定，运行时也可以将新的常量放入池中 (如 String.intern())。</li>
<li>可能抛出 OutOfMemoryError。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="JVM-调优参数"><a href="#JVM-调优参数" class="headerlink" title="JVM 调优参数"></a>JVM 调优参数</h3><ul>
<li><p><strong>堆内存大小设置:</strong></p>
<ul>
<li>-Xms<size>:设置 JVM 堆的初始内存大小。</li>
<li>-Xmx<size>:设置 JVM 堆的最大内存大小。</li>
<li>最佳实践:通常建议 -Xms 和 -Xmx 设置为相同值，以避免 JVM 在运行时动态调整堆大小带来的额外开销和 GC 停顿。例如 -Xms4g -Xmx4g。</li>
</ul>
</li>
<li><p><strong>新生代大小设置:</strong></p>
<ul>
<li>-Xmn<size>:设置新生代内存大小。</li>
<li>-XX:NewRatio&#x3D;<ratio>:设置老年代与新生代的比例，例如 -XX:NewRatio&#x3D;2 表示老年代:新生代 &#x3D; 2:1。</li>
<li>考量:<ul>
<li>新生代过小:频繁 Minor GC, 导致对象过早进入老年代。</li>
<li>新生代过大:Minor GC 间隔长, 但每次 GC 耗时可能长。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>元空间大小设置 (JDK 1.8+):</strong></p>
<ul>
<li>-XX:MetaspaceSize&#x3D;<size>:设置元空间的初始大小。</li>
<li>-XX:MaxMetaspaceSize&#x3D;<size>:设置元空间的最大大小。</li>
<li>考量:如果应用加载大量类或使用动态代码生成, 可能需要调大。</li>
</ul>
</li>
<li><p><strong>选择垃圾收集器:</strong></p>
<ul>
<li>-XX:+UseG1GC:启用 G1 垃圾收集器。这是 JDK 9+ 的默认收集器。</li>
<li>-XX:MaxGCPauseMillis&#x3D;<ms>:设置 G1 收集器可接受的最大停顿时间(G1 会尽量接近这个目标, 但不保证完全达到)。例如 -XX:MaxGCPauseMillis&#x3D;200。</li>
</ul>
</li>
</ul>
<h3 id="垃圾收集器-Garbage-Collector"><a href="#垃圾收集器-Garbage-Collector" class="headerlink" title="垃圾收集器 (Garbage Collector)"></a>垃圾收集器 (Garbage Collector)</h3><p>垃圾收集器是 JVM 的一个重要组成部分, 负责自动管理 Java 堆内存中的对象的生命周期, 回收不再使用的对象所占用的内存。</p>
<h4 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法:"></a><strong>垃圾判断算法:</strong></h4><ul>
<li>引用计数算法:当一个对象被引用一次, 计数器加1;引用失效, 计数器减1。当计数器为0时, 对象被判定为可回收。<ul>
<li>缺点:难以解决对象之间的循环引用问题。Java 虚拟机不采用此算法。</li>
</ul>
</li>
<li>可达性分析算法 (Root Tracing):通过一系列称为 “GC Roots” 的对象作为起始点, 从这些节点向下搜索, 搜索所走过的路径称为引用链 (Reference Chain)。当一个对象到 GC Roots 没有任何引用链相连时, 则证明此对象是不可用的。<ul>
<li>可作为 GC Roots 的对象:<ul>
<li>虚拟机栈 (栈帧中的局部变量表) 中引用的对象。</li>
<li>本地方法栈 (Native 方法) 中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>被同步锁持有的对象。</li>
<li>JVM 内部的引用 (如基本数据类型对应的 Class 对象)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器:"></a><strong>常见垃圾收集器:</strong></h4><ul>
<li><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器:"></a>Serial 收集器:</h5><ul>
<li>特点:单线程, 工作时需要停止所有用户线程 (“Stop The World”, STW)。简单高效, 适用于单核 CPU 或内存较小的客户端应用。</li>
<li>新生代使用:复制算法。</li>
<li>老年代使用:标记-整理算法。</li>
</ul>
</li>
<li><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器:"></a>ParNew 收集器:</h5><ul>
<li>特点:Serial 收集器的多线程版本, 用于新生代。并行收集时也需要 STW。</li>
<li>新生代使用:复制算法。</li>
<li>常与 CMS 收集器配合使用。</li>
</ul>
</li>
<li><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器:"></a>Parallel Scavenge 收集器:</h5><ul>
<li>特点：关注吞吐量（Throughput &#x3D; 用户代码执行时间 &#x2F; (用户代码执行时间 + GC 时间)），可以设置最大吞吐量或最大 GC 停顿时间。</li>
<li>新生代使用：复制算法。</li>
<li>老年代使用：与 Parallel Old 配合使用，使用标记-整理算法。</li>
</ul>
</li>
<li><h5 id="CMS-Concurrent-Mark-Sweep-收集器："><a href="#CMS-Concurrent-Mark-Sweep-收集器：" class="headerlink" title="CMS (Concurrent Mark Sweep) 收集器："></a>CMS (Concurrent Mark Sweep) 收集器：</h5><ul>
<li>特点：以获取最短回收停顿时间为目标，并发收集（与用户线程一起执行）。适用于对响应时间要求高的应用（如 Web 服务器）。</li>
<li>工作步骤：<ol>
<li>初始标记 (Initial Mark)：STW，标记 GC Roots 能直接关联到的对象，速度快。</li>
<li>并发标记 (Concurrent Mark)：与用户线程并发执行，进行 GC Roots Tracing 过程，耗时最长。</li>
<li>重新标记 (Remark)：STW，修正并发标记期间因用户程序继续运行而导致标记产生变动的对象，比初始标记耗时长，但远比并发标记短。</li>
<li>并发清除 (Concurrent Sweep)：与用户线程并发执行，清除已标记为垃圾的对象。</li>
</ol>
</li>
<li>缺点：<ul>
<li>对 CPU 资源敏感：并发阶段会占用一部分 CPU。</li>
<li>无法处理浮动垃圾：并发清除阶段产生的垃圾（新生成的对象）只能下次 GC 再处理。</li>
<li>可能产生大量空间碎片：采用“标记-清除”算法，不进行整理，可能导致大对象无法分配空间而提前触发 Full GC。</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="G1-Garbage-First-收集器："><a href="#G1-Garbage-First-收集器：" class="headerlink" title="G1 (Garbage-First) 收集器："></a>G1 (Garbage-First) 收集器：</h5><ul>
<li>特点：JDK 9+ 的默认垃圾收集器。面向服务端应用，分区（将 Java 堆划分为多个独立区域 Region)，可预测的停顿时间模型。</li>
<li>工作原理：<ul>
<li>将堆内存划分为多个大小相等的 Region。</li>
<li>G1 跟踪每个 Region 的垃圾回收价值 (Garbage-First)，优先回收垃圾最多的 Region。</li>
<li>年轻化和老年代不再是物理隔离，而是逻辑上的概念，Region 可以动态地成为 Eden、Survivor 或 Old 区域。</li>
<li>并发与并行兼容：并发标记，但回收阶段并行。</li>
<li>基本无碎片：采用复制和标记-整理算法结合。</li>
</ul>
</li>
<li>工作步骤：<ol>
<li>初始标记 (Initial Mark)：STW，标记 GC Roots 能直接关联的对象。</li>
<li>并发标记 (Concurrent Mark)：与用户线程并发，遍历对象图。</li>
<li>最终标记 (Final Mark)：STW，处理并发标记阶段结束后仍然存活的对象。</li>
<li>筛选回收 (Evacuation)：STW，对各个 Region 的回收价值进行排序，根据预期停顿时间来回收 Region，采用复制算法将存活对象复制到新的 Region。</li>
</ol>
</li>
<li>优势：在保持高吞吐量的同时，降低了 GC 停顿时间，适合大内存、多核处理器场景。</li>
</ul>
</li>
<li><h5 id="zGC-Z-Garbage-Collector-和-Shenandoah-收集器："><a href="#zGC-Z-Garbage-Collector-和-Shenandoah-收集器：" class="headerlink" title="zGC (Z Garbage Collector) 和 Shenandoah 收集器："></a>zGC (Z Garbage Collector) 和 Shenandoah 收集器：</h5><ul>
<li>特点：低延迟、并发 GC 收集器，旨在实现毫秒级的 GC 停顿。</li>
<li>ZGC: JDK 11 引入，支持 TB 级别的堆内存，停顿时间与堆大小无关。</li>
<li>Shenandoah: JDK 12 引入，与 G1 类似，但能进一步降低停顿时间。</li>
<li>应用场景：对延迟要求极高的应用</li>
</ul>
</li>
</ul>
<h2 id="类加载机制-Class-Loading-Mechanism"><a href="#类加载机制-Class-Loading-Mechanism" class="headerlink" title="类加载机制 (Class Loading Mechanism)"></a>类加载机制 (Class Loading Mechanism)</h2><ul>
<li><p><strong>作用</strong>: 将 .class 文件中的字节码加载到 JVM 内存中，并转换为运行时数据结构。  </p>
</li>
<li><p><strong>生命周期</strong>: 加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载。  </p>
</li>
<li><p><strong>主要阶段</strong>:  </p>
<ul>
<li><strong>加载 (Loading)</strong>:  <ul>
<li>通过类的全限定名获取该类的二进制字节流。  </li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  </li>
<li>在内存中生成一个代表该类的 java.lang.Class 对象。</li>
</ul>
</li>
<li><strong>验证 (Verification)</strong>: 确保 Class 文件的字节流符合 JVM 规范，没有安全问题。  </li>
<li><strong>准备 (Preparation)</strong>: 为类的静态变量（static fields）分配内存并初始化为默认值（如 int 变量为 0，引用类型为 null）。  </li>
<li><strong>解析 (Resolution)</strong>: 将常量池中的符号引用替换为直接引用。  </li>
<li><strong>初始化 (Initialization)</strong>: 执行类的构造器 <code>&lt;clinit&gt;()</code> 方法，真正开始执行类中定义的 Java 程序代码（为静态变量赋予初始值，执行静态代码块）。</li>
</ul>
</li>
<li><p><strong>类加载器 (Class Loaders)</strong>:  </p>
<ul>
<li><p>类加载器的分类：</p>
<p>（1）Bootstrap class loader （使用C++编写的）</p>
<p>​    简称：启动类加载器</p>
<p>​    <strong>加载路径</strong>：JAVA_HOME&#x2F;jre&#x2F;lib</p>
<p>​    显示形式：null</p>
<p>（2）Platform class loader（由Java编写的）</p>
<p>​    简称：扩展类加载器</p>
<p>​    <strong>加载路径</strong>：JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</p>
<p>​    显示形式：ExtClassLoader</p>
<p>（3）System class loader（由Java编写的）</p>
<p>​    简称：应用程序类加载器</p>
<p>​    <strong>加载路径</strong>：类路径（src目录）</p>
<p>​    显示形式：AppClassLoader   &#x2F;&#x2F;sun.misc.Launcher$AppClassLoader@18b4aac2</p>
<p>（4）自定义类加载器（由Java编写的）</p>
<p>​    简称：自定义类加载器</p>
<p>​    加载路径：自定义</p>
<h4 id="1-启动类加载器-Bootstrap-ClassLoader"><a href="#1-启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="1. 启动类加载器 (Bootstrap ClassLoader)"></a><strong>1. 启动类加载器 (Bootstrap ClassLoader)</strong></h4><ul>
<li><strong>作用</strong>：它负责加载 Java 核心库，比如 <code>rt.jar</code>（包含 <code>java.lang.*</code>, <code>java.util.*</code> 等核心类）。</li>
<li><strong>实现</strong>：它不是用 Java 写的，而是由 C++ 实现的，是 JVM 自身的一部分。因此，你无法在 Java 代码中直接获取到它的对象，调用 <code>getClassLoader()</code> 得到的会是 <code>null</code>。</li>
<li><strong>父加载器</strong>：它没有父加载器。它是类加载器层次结构的顶端。</li>
</ul>
<h4 id="2-扩展类加载器-Extension-ClassLoader"><a href="#2-扩展类加载器-Extension-ClassLoader" class="headerlink" title="2. 扩展类加载器 (Extension ClassLoader)"></a><strong>2. 扩展类加载器 (Extension ClassLoader)</strong></h4><ul>
<li><strong>作用</strong>：它负责加载 JVM 扩展目录中的所有 jar 包，通常是 <code>JRE/lib/ext</code> 目录下的库。</li>
<li><strong>实现</strong>：它是由 Java 语言实现的。</li>
<li><strong>父加载器</strong>：它的父加载器是<strong>启动类加载器</strong>。</li>
</ul>
<h4 id="3-应用程序类加载器-Application-ClassLoader"><a href="#3-应用程序类加载器-Application-ClassLoader" class="headerlink" title="3. 应用程序类加载器 (Application ClassLoader)"></a><strong>3. 应用程序类加载器 (Application ClassLoader)</strong></h4><ul>
<li><strong>作用</strong>：它负责加载我们自己编写的 Java 程序中的类，也就是你项目中 <code>classpath</code> 路径下的所有类。</li>
<li><strong>实现</strong>：它也是由 Java 语言实现的。</li>
<li><strong>父加载器</strong>：它的父加载器是<strong>扩展类加载器</strong>。</li>
</ul>
<hr>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h3><p>除了上面三个，你也可以根据自己的需求创建<strong>自定义类加载器</strong>。</p>
<ul>
<li><strong>作用</strong>：当你需要加载一些特定来源的类时（比如从网络下载的类、对字节码进行加密或解密），自定义类加载器就很有用。例如，Web 服务器（如 Tomcat）就是通过自定义类加载器来隔离不同 Web 应用的类。</li>
<li><strong>如何实现</strong>：通常，你需要继承 <code>java.lang.ClassLoader</code> 类，并重写 <code>findClass()</code> 方法。在 <code>findClass()</code> 方法中，你需要自己定义如何获取类的字节码（比如从文件系统、网络或数据库），然后调用 <code>defineClass()</code> 方法将字节码转换为 <code>Class</code> 对象。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>双亲委派模型 (Parents Delegation Model)</strong>:  </p>
<ul>
<li><strong>原理</strong>: 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。  </li>
<li><strong>优点</strong>: 避免类的重复加载，保证 Java 核心库的类型安全。</li>
</ul>
</li>
</ul>
<h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><p>为什么需要四个类加载器，而不是一个？</p>
<p>这是一个很好的问题。为什么 Java 要设计多个类加载器，而不是用一个大一统的加载器呢？这背后主要有三个核心原因：<strong>隔离性</strong>、<strong>安全性</strong>和<strong>可扩展性</strong>。</p>
<hr>
<h3 id="1-隔离性（Isolation）"><a href="#1-隔离性（Isolation）" class="headerlink" title="1. 隔离性（Isolation）"></a>1. 隔离性（Isolation）</h3><p>多类加载器的最大优势就是实现了<strong>类隔离</strong>。</p>
<p>想象一下，你有一个 Web 服务器，上面部署了两个不同的 Web 应用（比如一个博客系统和一个论坛）。这两个应用可能依赖同一个第三方库的不同版本（例如，博客用的是 Spring 框架的 5.x 版本，而论坛用的是 4.x 版本）。</p>
<p>如果只有一个类加载器，它会把所有 <code>classpath</code> 上的类都加载到同一个内存空间。这样一来，两个不同版本的 Spring 框架就会产生冲突，JVM 根本无法区分它们，程序就会报错。</p>
<p>而有了自定义类加载器，服务器就可以为每个 Web 应用创建一个独立的类加载器。每个加载器负责加载自己应用目录下的类，这样两个应用即使使用了同一个库的不同版本，也能在内存中和谐共存，互不干扰。</p>
<hr>
<h3 id="2-安全性（Security）"><a href="#2-安全性（Security）" class="headerlink" title="2. 安全性（Security）"></a>2. 安全性（Security）</h3><p>Java 的核心库（如 <code>java.lang</code>, <code>java.util</code> 等）对 JVM 的稳定和安全至关重要。</p>
<p><strong>双亲委派模型</strong>正是为了保护这些核心库不被恶意代码或普通用户代码所篡改。</p>
<p>例如，如果你尝试自己写一个 <code>java.lang.String</code> 类并把它放在应用的 <code>classpath</code> 下，双亲委派机制会确保这个类不会被加载。因为当加载请求到达应用程序类加载器时，它会先委派给它的父加载器——扩展类加载器，然后再委派给最顶层的<strong>启动类加载器</strong>。启动类加载器会优先加载 JDK 自带的 <code>java.lang.String</code>，从而你的恶意代码就永远没有机会被执行。</p>
<hr>
<h3 id="3-可扩展性（Extensibility）"><a href="#3-可扩展性（Extensibility）" class="headerlink" title="3. 可扩展性（Extensibility）"></a>3. 可扩展性（Extensibility）</h3><p>Java 是一种非常灵活的语言，需要适应各种复杂的运行时环境。</p>
<p>如果只有一个类加载器，所有的类都必须来自文件系统。但在现实世界中，类可能来自各种地方：</p>
<ul>
<li>从网络上下载的字节码。</li>
<li>通过数据库存储和加载。</li>
<li>对字节码进行加密和解密。</li>
</ul>
<p>自定义类加载器让 Java 能够<strong>动态地加载</strong>和<strong>处理非标准来源的类</strong>。例如，热部署技术（在不重启应用的情况下更新代码）就是通过自定义类加载器实现的。它会创建一个新的加载器来加载新版本的类，而旧的加载器和它的类则可以被垃圾回收。</p>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>所以，一个大一统的类加载器虽然简单，但它无法解决复杂的<strong>类版本冲突</strong>、<strong>核心库安全</strong>和<strong>动态加载</strong>等问题。通过分层设计和双亲委派模型，Java 的类加载器体系变得既安全又灵活，能够满足从简单的桌面应用到复杂的企业级服务器等各种场景的需求。</p>
<h2 id="常见的-OOM-OutOfMemoryError-和-StackOverflowError"><a href="#常见的-OOM-OutOfMemoryError-和-StackOverflowError" class="headerlink" title="常见的 OOM (OutOfMemoryError) 和 StackOverflowError"></a>常见的 OOM (OutOfMemoryError) 和 StackOverflowError</h2><ul>
<li><strong>Java heap space</strong>: 堆内存不足，最常见。通常通过调整 JVM 启动参数 <code>-Xms</code> (初始堆大小) 和 <code>-Xmx</code> (最大堆大小) 来解决。  </li>
<li><strong>StackOverflowError</strong>: 虚拟机栈溢出。通常是递归调用过深导致栈帧不断入栈。  </li>
<li><strong>PermGen space &#x2F; Metaspace</strong>: 方法区溢出。通常是加载的类过多，或者存在大量字符串常量。通过 <code>-XX:MaxPermSize</code> (JDK 1.7) 或 <code>-XX:MaxMetaspaceSize</code> (JDK 1.8) 调整。  </li>
<li><strong>Direct buffer memory</strong>: 直接内存溢出。通常是使用了 NIO 或 Netty 等直接操作堆外内存的库。  </li>
<li><strong>unable to create new native thread</strong>: 无法创建新线程。通常是系统线程数达到上限或内存不足以分配新线程的栈空间。</li>
</ul>
<h2 id="OOM常见场景："><a href="#OOM常见场景：" class="headerlink" title="OOM常见场景："></a>OOM常见场景：</h2><hr>
<h3 id="1-java-lang-OutOfMemoryError-Java-heap-space"><a href="#1-java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="1. java.lang.OutOfMemoryError: Java heap space"></a><strong>1. java.lang.OutOfMemoryError: Java heap space</strong></h3><p>这是最常见、也最广为人知的内存溢出错误。它表示 <strong>Java 堆（Heap）</strong> 中没有足够的空间来分配新的对象。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong>内存泄漏（Memory Leak）</strong>：这是最主要的原因。你的程序中创建了对象，但本应被垃圾回收器（GC）回收的对象却因为某些原因（比如被一个长生命周期的对象引用着）而无法被回收。例如：<ul>
<li>一个静态的 <code>Map</code> 或 <code>List</code> 集合，不断地往里面添加对象，但从不删除。</li>
<li>监听器或回调函数没有正确移除，导致被监听的对象无法被回收。</li>
<li>数据库连接或文件流没有正确关闭，长时间占用资源。</li>
</ul>
</li>
<li><strong>内存使用不当</strong>：一次性加载大量数据到内存中。例如，从数据库查询数百万条记录，并把它们全部加载到一个 <code>List</code> 中；或者处理一个超大的图片或文件，导致瞬间占用大量内存。</li>
<li><strong>配置问题</strong>：JVM 的堆内存设置得太小，无法满足程序的正常运行需求。这在部署应用时很常见，可以通过调整 <code>-Xmx</code> 参数来解决。</li>
</ul>
<hr>
<h3 id="2-java-lang-StackOverflowError"><a href="#2-java-lang-StackOverflowError" class="headerlink" title="2. java.lang.StackOverflowError"></a><strong>2. java.lang.StackOverflowError</strong></h3><p>这个错误表示 <strong>虚拟机栈（Stack）</strong> 溢出。每个线程都有一个独立的栈，用于存储方法调用的栈帧。当栈的深度超过了 JVM 允许的最大深度时，就会抛出此错误。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><p><strong>无限递归（Infinite Recursion）</strong>：这是最典型的场景。一个方法不断地调用自身，且没有正确的退出条件。例如：</p>
<p>Java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void recursiveMethod() &#123;</span><br><span class="line">    // 没有退出条件</span><br><span class="line">    recursiveMethod(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子是两个方法互相调用，形成循环：A 调用 B，B 又调用 A。</p>
</li>
<li><p><strong>递归调用层级过深</strong>：即使递归有正确的退出条件，如果数据量过大，导致递归调用层级非常深，也可能导致栈溢出。例如，处理一个深度非常大的树形结构。</p>
</li>
</ul>
<hr>
<h3 id="3-java-lang-OutOfMemoryError-PermGen-space-或-Metaspace"><a href="#3-java-lang-OutOfMemoryError-PermGen-space-或-Metaspace" class="headerlink" title="3. java.lang.OutOfMemoryError: PermGen space 或 Metaspace"></a><strong>3. java.lang.OutOfMemoryError: PermGen space 或 Metaspace</strong></h3><p>这个错误发生在 <strong>方法区</strong> 溢出。方法区用于存储类的元数据信息，如类的结构、字段、方法、常量池等。</p>
<ul>
<li><strong>JDK 1.7 及之前</strong>：方法区在堆中，被称为<strong>永久代（PermGen）</strong>。溢出错误为 <code>PermGen space</code>。</li>
<li><strong>JDK 1.8 及之后</strong>：永久代被移除，方法区改为使用<strong>元空间（Metaspace）</strong>，并且默认使用本地内存。溢出错误为 <code>Metaspace</code>。</li>
</ul>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong>动态生成大量类</strong>：在运行时生成大量新的类。这在一些使用字节码增强技术的框架（如 CGLib）或动态代理的场景中很常见。</li>
<li><strong>热部署</strong>：在像 Tomcat 这样的 Web 服务器中进行频繁的热部署操作，如果没有正确清理旧的类加载器，会导致旧的类元数据无法被回收，从而逐渐耗尽方法区内存。</li>
<li><strong>常量池溢出</strong>：在 JDK 1.7 之前，字符串常量池也在永久代中。如果程序创建了大量不同的字符串（例如在循环中不断生成新的字符串），也可能导致永久代溢出。</li>
</ul>
<hr>
<h3 id="4-java-lang-OutOfMemoryError-Direct-buffer-memory"><a href="#4-java-lang-OutOfMemoryError-Direct-buffer-memory" class="headerlink" title="4. java.lang.OutOfMemoryError: Direct buffer memory"></a><strong>4. java.lang.OutOfMemoryError: Direct buffer memory</strong></h3><p>这个错误与 <strong>直接内存（Direct Memory）</strong> 相关，它不是 Java 堆的一部分，而是通过 <code>ByteBuffer.allocateDirect()</code> 在堆外分配的内存。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong>NIO 和网络编程</strong>：在使用 Java NIO、Netty、或者其他依赖堆外内存的库时，如果频繁地分配直接内存但没有及时释放，就可能导致此错误。</li>
<li><strong>内存泄漏</strong>：直接内存的回收不像堆内存那样由 GC 自动管理。如果程序中没有调用 <code>ByteBuffer</code> 的 <code>cleaner()</code> 方法，或者在没有关闭资源的情况下直接内存泄漏，就会耗尽系统的直接内存。</li>
</ul>
<hr>
<h3 id="5-java-lang-OutOfMemoryError-unable-to-create-new-native-thread"><a href="#5-java-lang-OutOfMemoryError-unable-to-create-new-native-thread" class="headerlink" title="5. java.lang.OutOfMemoryError: unable to create new native thread"></a><strong>5. java.lang.OutOfMemoryError: unable to create new native thread</strong></h3><p>这个错误通常不是因为 Java 堆内存不足，而是因为<strong>系统资源耗尽</strong>。</p>
<p><strong>常见场景：</strong></p>
<ul>
<li><strong>线程创建过多</strong>：程序中创建了大量的线程，导致系统无法为新的线程分配内存空间。每个线程除了 Java 堆中的栈空间外，还需要分配一些本地内存。</li>
<li><strong>系统限制</strong>：操作系统对单个进程创建的线程数有限制。如果达到了这个上限，JVM 就会抛出此错误。在 Linux 系统中，你可以通过 <code>ulimit -u</code> 命令查看这个限制。</li>
<li><strong>内存不足</strong>：系统内存（包括堆外内存）已经所剩无几，JVM 无法为新的线程栈分配足够的内存  r。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/11/%E5%9F%BA%E7%A1%80%E8%83%8C%E8%AF%B5/" data-id="cmffake6s000m50uyg5feew0i" data-title="基础背诵" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo-Markdown/" rel="tag">Hexo, Markdown</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-自己总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/11/%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2025-09-11T10:29:28.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/11/%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93/">自己总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1.OSI七层模型"></a>1.OSI七层模型</h3><p>物理层：</p>
<p>数据链路层：</p>
<p>网络层：</p>
<p>传输层：</p>
<p>会话层：</p>
<p>表示层：</p>
<p>应用层：</p>
<p>2.三次握手</p>
<p>3.四次挥手</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/11/%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93/" data-id="cmffake6s000p50uya2wuaj95" data-title="自己总结" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo-Markdown/" rel="tag">Hexo, Markdown</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo-Markdown/" rel="tag">Hexo, Markdown</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hexo-Markdown/" style="font-size: 10px;">Hexo, Markdown</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">九月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/09/11/8.21%E5%AD%A6%E4%BC%9A/">8.21学会</a>
          </li>
        
          <li>
            <a href="/2025/09/11/web/">web</a>
          </li>
        
          <li>
            <a href="/2025/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
          </li>
        
          <li>
            <a href="/2025/09/11/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/">命令大全</a>
          </li>
        
          <li>
            <a href="/2025/09/11/%E7%AE%97%E6%B3%95/">算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Charlotte<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>